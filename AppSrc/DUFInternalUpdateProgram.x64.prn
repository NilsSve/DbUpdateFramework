Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFInternalUpdateProgram.src
Memory Available: 100882911232
1>// *** DUF Auto-Generated Program - For Internal Usage Only! ***
1>// *** Use it to send to a collegue that is working on the same project, ***
1>// *** to update his/her database with database changes you have made. ***
1>    CompilerLevelWarning All On
1>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cApplication.pkg)
1>>>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 23.0\Pkg\windows.x64.pkd)
8251>>>
8251>>>Use LanguageText.pkg
8251>>>Use WinUser.pkg
8251>>>Use WinShell.pkg
8251>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWorkspace.pkg)
8251>>>>>Use VdfBase.pkg
8251>>>>>Use tWinStructs.pkg
8251>>>>>Use LanguageText.pkg
8251>>>>>Use WinShell.pkg // Shell API functions
8251>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\seq_chnl.pkg)
8251>>>>>>>Use LanguageText.pkg
8251>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 23.0\Pkg\errornum.inc)
8251>>>>>>>>
8251>>>>>>>>//
8251>>>>>>>>// these will get defined in fmac
8251>>>>>>>>//
8251>>>>>>>>// already defined
8251>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
8251>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
8251>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
8251>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
8251>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
8251>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
8251>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
8251>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
8251>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
8251>>>>>>>>// new compiler errors used by fmac
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
8251>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
8251>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
8251>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
8251>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
8251>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
8251>>>>>>>>
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_STRING_CMD       |CI4531 // pertaining to string commands
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TYPE_CMD         |CI4532 // pertaining to type/end_type commands
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CMD              |CI4533 // pertaining to a more generic obsolete command 
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_GLOBAL_FUNCTION  |CI4534 // Global function is obsolete
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TECHNIQUE        |CI4535 // Using some older technique
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_PACKAGE          |CI4536 // Package is obsolete, remove it if you can
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CLASS            |CI4537 // Class is obsolete, remove it if you can
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_INDICATOR_USE    |CI4538 // Using indicators anywhere
8251>>>>>>>>//    
8251>>>>>>>>//    #Replace DFERR_COMP_ILLEGAL_CONVERSION                            |CI4539 // Datatype conversion is illegal, would cause runtime-error
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_OBJECT_FUNCTION  |CI4540 // Global function is obsolete
8251>>>>>>>>//    #Replace DFERR_INVALID_LOCALE_CODE                    |CI4541 // Error thown by Set_Attribute DF_LOCALE_CODE on invalid value
8251>>>>>>>>//    #Replace DFERR_STRING_COMPARISON_ERROR                |CI4542 // Error during string comparison (ICU returned an error)
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_REDEFINING_RETURN_TYPE    |CI4543 // Warning when redefining a function with a different return type
8251>>>>>>>>//    #Replace DFERR_COMP_AMBIGUOUS_FUNCTION_EXPRESSION     |CI4544 // Error when using ambiguous function in expression
8251>>>>>>>>    
8251>>>>>>>>
8251>>>>>>>>
8251>>>>>>>
8251>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8251>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8251>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8251>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8251>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8251>>>>>>>// so that programs that use direct_input/output
8251>>>>>>>// w/o specifying a channel will work.
8251>>>>>>>Enum_List
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8251>>>>>>>End_Enum_List
8251>>>>>>>
8251>>>>>>>Enum_List
8251>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8251>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8251>>>>>>>End_Enum_List
8251>>>>>>>
8251>>>>>>>Global_Variable Integer Seq$Channel$Error$Mode
8251>>>>>>>
8251>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer iMode
8253>>>>>>>    Move iMode to Seq$Channel$Error$Mode
8254>>>>>>>End_Procedure
8255>>>>>>>
8255>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8257>>>>>>>    Function_Return Seq$Channel$Error$Mode
8258>>>>>>>End_Function
8259>>>>>>>
8259>>>>>>>Global_Variable Integer[DF_SEQ_CHANNEL_MAX] giSeqChannelList
8259>>>>>>>// initialize array
8259>>>>>>>For WindowIndex from 0 to (DF_SEQ_CHANNEL_MAX-1)
8265>>>>>>>>
8265>>>>>>>    Move 0 to giSeqChannelList[WindowIndex]
8266>>>>>>>Loop
8267>>>>>>>>
8267>>>>>>>
8267>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8268>>>>>>>
8268>>>>>>>Function Seq_Channel_Mode Global Integer iChannel Returns Integer
8270>>>>>>>    Function_Return giSeqChannelList[iChannel]
8271>>>>>>>End_Function
8272>>>>>>>
8272>>>>>>>Procedure Set Seq_Channel_Mode Global Integer iChannel Integer iMode
8274>>>>>>>    Move iMode to giSeqChannelList[iChannel]
8275>>>>>>>End_Procedure
8276>>>>>>>
8276>>>>>>>Function Seq_New_Channel Global Returns Integer
8278>>>>>>>    Integer iObject iChannel
8278>>>>>>>    
8278>>>>>>>    Move DF_SEQ_START_CHANNEL to iChannel
8279>>>>>>>    
8279>>>>>>>    While (iChannel < DF_SEQ_CHANNEL_MAX)
8283>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8285>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8286>>>>>>>            Function_Return iChannel
8287>>>>>>>        End
8287>>>>>>>>
8287>>>>>>>        
8287>>>>>>>        Increment iChannel
8288>>>>>>>    Loop
8289>>>>>>>>
8289>>>>>>>    
8289>>>>>>>    // wrap back to beginning
8289>>>>>>>    Move 0 to iChannel
8290>>>>>>>    
8290>>>>>>>    While (iChannel < DF_SEQ_START_CHANNEL)
8294>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8296>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8297>>>>>>>            Function_Return iChannel
8298>>>>>>>        End
8298>>>>>>>>
8298>>>>>>>        
8298>>>>>>>        Increment iChannel
8299>>>>>>>    Loop
8300>>>>>>>>
8300>>>>>>>    
8300>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8301>>>>>>>End_Function
8302>>>>>>>
8302>>>>>>>Procedure Seq_Release_Channel Global Integer iChannel
8304>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8306>>>>>>>        Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_CLOSED
8307>>>>>>>    End
8307>>>>>>>>
8307>>>>>>>End_Procedure
8308>>>>>>>
8308>>>>>>>Function Seq_Open_Input_Channel Global String sChannel Returns Integer
8310>>>>>>>    Integer iChannel
8310>>>>>>>    
8310>>>>>>>    Move (Seq_New_Channel()) to iChannel
8311>>>>>>>    
8311>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8313>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8315>>>>>>>            Error DFERR_CANT_OPEN_INPUT_FILE (sChannel + ":" *C_$NoOpenChannels)
8316>>>>>>>>
8316>>>>>>>        End
8316>>>>>>>>
8316>>>>>>>        Function_Return iChannel
8317>>>>>>>    End
8317>>>>>>>>
8317>>>>>>>    
8317>>>>>>>    Move False to Err
8318>>>>>>>    Direct_Input channel iChannel sChannel
8320>>>>>>>    
8320>>>>>>>    If (Err) Begin
8322>>>>>>>        Send Seq_Release_Channel iChannel
8323>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8324>>>>>>>    End
8324>>>>>>>>
8324>>>>>>>    
8324>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_INPUT
8325>>>>>>>    
8325>>>>>>>    Function_Return iChannel
8326>>>>>>>End_Function
8327>>>>>>>
8327>>>>>>>Function Seq_Open_Output_Channel Global String sChannel Returns Integer
8329>>>>>>>    Integer iChannel
8329>>>>>>>    
8329>>>>>>>    Move (Seq_New_Channel()) to iChannel
8330>>>>>>>    
8330>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8332>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8334>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8335>>>>>>>>
8335>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8336>>>>>>>        End
8336>>>>>>>>
8336>>>>>>>        
8336>>>>>>>        Function_Return iChannel
8337>>>>>>>    End
8337>>>>>>>>
8337>>>>>>>    
8337>>>>>>>    Move False to Err
8338>>>>>>>    Direct_Output channel iChannel sChannel
8340>>>>>>>    
8340>>>>>>>    If (Err) Begin
8342>>>>>>>        Send Seq_Release_Channel iChannel
8343>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8344>>>>>>>    End
8344>>>>>>>>
8344>>>>>>>    
8344>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8345>>>>>>>    
8345>>>>>>>    Function_Return iChannel
8346>>>>>>>End_Function
8347>>>>>>>
8347>>>>>>>Function Seq_Append_Output_Channel Global String sChannel Returns Integer
8349>>>>>>>    Integer iChannel
8349>>>>>>>    
8349>>>>>>>    Move (Seq_New_Channel()) to iChannel
8350>>>>>>>    
8350>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8352>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8354>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8355>>>>>>>>
8355>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8356>>>>>>>        End
8356>>>>>>>>
8356>>>>>>>        
8356>>>>>>>        Function_Return iChannel
8357>>>>>>>    End
8357>>>>>>>>
8357>>>>>>>    
8357>>>>>>>    Move False to Err
8358>>>>>>>    Append_Output channel iChannel sChannel
8360>>>>>>>    
8360>>>>>>>    If (Err) Begin
8362>>>>>>>        Send Seq_Release_Channel iChannel
8363>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8364>>>>>>>    End
8364>>>>>>>>
8364>>>>>>>    
8364>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8365>>>>>>>    
8365>>>>>>>    Function_Return iChannel
8366>>>>>>>End_Function
8367>>>>>>>
8367>>>>>>>Procedure Seq_Close_Channel Global Integer iChannel
8369>>>>>>>    Integer iMode
8369>>>>>>>    
8369>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8371>>>>>>>        Move (Seq_Channel_Mode(iChannel)) to iMode
8372>>>>>>>        
8372>>>>>>>        If (iMode = DF_SEQ_CHANNEL_MODE_OUTPUT) Begin
8374>>>>>>>            Close_Output channel iChannel
8376>>>>>>>        End
8376>>>>>>>>
8376>>>>>>>        Else If (iMode = DF_SEQ_CHANNEL_MODE_INPUT) Begin
8379>>>>>>>            Close_Input channel iChannel
8381>>>>>>>        End
8381>>>>>>>>
8381>>>>>>>        // If channel not open, release it! No (fatal) Error.
8381>>>>>>>        Send Seq_Release_Channel iChannel
8382>>>>>>>    End
8382>>>>>>>>
8382>>>>>>>End_Procedure
8383>>>>>Use GlobalFunctionsProcedures.pkg
8383>>>>>
8383>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8383>>>>>Register_Function VdfSystemDfPath   Returns String
8383>>>>>Register_Function VdfSystemMakePath Returns String
8383>>>>>
8383>>>>>Enum_List
8383>>>>>    Define wsWorkspaceOpened       // WS opened ok
8383>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8383>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8383>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8383>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8383>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8383>>>>>End_Enum_List
8383>>>>>
8383>>>>>
8383>>>>>Define INVALID_HANDLE_VALUE for -1
8383>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8383>>>>>
8383>>>>>
8383>>>>>// Wide version
8383>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8384>>>>>
8384>>>>>// Wrapper Function winFindFirstFile
8384>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8386>>>>>    
8386>>>>>    Handle  hResult
8386>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8386>>>>>    Integer iSizeOfStructWithoutStrings
8386>>>>>    String  sFileName sAlternateFileName
8386>>>>>    WString wFileName wAlternateFileName
8386>>>>>    Pointer pWFD
8386>>>>>    tWin32FindDataW tWFD
8386>>>>>    tWin32FindDataW tWFD
8386>>>>>    
8386>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8386>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8386>>>>>
8386>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8387>>>>>    Move (AddressOf(tWFD)) to pWFD
8388>>>>>    
8388>>>>>    // Call the function
8388>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8389>>>>>
8389>>>>>    // Copy the struct contents back to the incoming one.
8389>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8390>>>>>    
8390>>>>>    // But do the strings separately and convert them to UTF8
8390>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8391>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8392>>>>>    
8392>>>>>    // Extend string with 0 to the maximum number of characters
8392>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8395>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8398>>>>>        
8398>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8399>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8400>>>>>    
8400>>>>>    Function_Return hResult
8401>>>>>End_Function
8402>>>>>
8402>>>>>// When used directly, be sure to use WString types (UTF16).
8402>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8403>>>>>
8403>>>>>// Wrapper Function winFindNextFile
8403>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8405>>>>>    
8405>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8405>>>>>    Integer iSizeOfStructWithoutStrings
8405>>>>>    String  sFileName sAlternateFileName
8405>>>>>    WString wFileName wAlternateFileName
8405>>>>>    Pointer pWFD
8405>>>>>    tWin32FindDataW tWFD
8405>>>>>    tWin32FindDataW tWFD
8405>>>>>
8405>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8405>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8405>>>>>
8405>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8405>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8406>>>>>    Move (AddressOf(tWFD)) to pWFD
8407>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8408>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8408>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8409>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8410>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8411>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8412>>>>>    
8412>>>>>    // Call the function
8412>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8413>>>>>
8413>>>>>    // Copy the struct contents back to the incoming one.
8413>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8414>>>>>    
8414>>>>>    // But do the strings separately and convert them to UTF8
8414>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8415>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8416>>>>>    
8416>>>>>    // Extend string with 0 to the maximum number of characters
8416>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8419>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8422>>>>>        
8422>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8423>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8424>>>>>    
8424>>>>>    Function_Return iResult
8425>>>>>End_Function
8426>>>>>
8426>>>>>
8426>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8427>>>>>
8427>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8429>>>>>    tWin32FindDataW Win32FindData
8429>>>>>    tWin32FindDataW Win32FindData
8429>>>>>    String sMask
8429>>>>>    Integer iVoid
8429>>>>>    Handle hFileFind
8429>>>>>    
8429>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8430>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8432>>>>>        Move (winFindClose(hFileFind)) to iVoid
8433>>>>>    End
8433>>>>>>
8433>>>>>    
8433>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8434>>>>>End_Function
8435>>>>>
8435>>>>>
8435>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cIniFile.pkg)
8435>>>>>>>Use Dll.pkg
8435>>>>>>>Use errornum.inc
8435>>>>>>>Use LanguageText.pkg
8435>>>>>>>Use GlobalFunctionsProcedures.pkg
8435>>>>>>>Use seq_chnl.pkg
8435>>>>>>>Use CharTranslate.pkg
8435>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCharTranslate.pkg)
8435>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Variant.pkg)
8435>>>>>>>>>>>Use ui
8435>>>>>>>>>>>Use errornum.inc
8435>>>>>>>>>>>
8435>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8435>>>>>>>>>>>
8435>>>>>>>>>>>
8435>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8436>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8437>>>>>>>>>>>
8437>>>>>>>>>>>//  Returns the variant type
8437>>>>>>>>>>>Function VariantType Global Variant vVal Returns Integer
8439>>>>>>>>>>>    Function_Return (DeRefW(AddressOf(vVal),0))
8440>>>>>>>>>>>End_Function
8441>>>>>>>>>>>
8441>>>>>>>>>>>
8441>>>>>>>>>>>// Returns the character length of the variant string. 
8441>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8443>>>>>>>>>>>    Integer iLen iType
8443>>>>>>>>>>>
8443>>>>>>>>>>>    Move (VariantType(bStr)) to iType
8444>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8446>>>>>>>>>>>        Function_Return 0
8447>>>>>>>>>>>    End
8447>>>>>>>>>>>>
8447>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8449>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8450>>>>>>>>>>>>
8450>>>>>>>>>>>        Function_Return 0
8451>>>>>>>>>>>    End
8451>>>>>>>>>>>>
8451>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(AddressOf(bStr),8))) to iLen
8452>>>>>>>>>>>    Function_Return iLen
8453>>>>>>>>>>>End_Function
8454>>>>>>>>>>>
8454>>>>>>>>>>>
8454>>>>>>>>>>>// returns true if char string in the buffer can fit into a string.
8454>>>>>>>>>>>// Changed this to always return True, because the Max_Argument_Size limitation has been removed.
8454>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8456>>>>>>>>>>>    Function_Return True
8457>>>>>>>>>>>End_Function
8458>>>>>>>>>>>
8458>>>>>>>>>>>
8458>>>>>>>>>Use CharTranslate.pkg
8458>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8458>>>>>>>>>
8458>>>>>>>>>// special for UTF16, which is really not a code page at all
8458>>>>>>>>>Define CP_UTF16 for -1
8458>>>>>>>>>
8458>>>>>>>>>Class cCharTranslate is a cObject
8459>>>>>>>>>    
8459>>>>>>>>>    
8459>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8459>>>>>>>>>    
8459>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8459>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8459>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8461>>>>>>>>>        Pointer pWideBuf
8461>>>>>>>>>        Integer iWideBufLen iStrLen
8461>>>>>>>>>        Move 0 to pWideBuf
8462>>>>>>>>>        Move 0 to iLen
8463>>>>>>>>>        If (pMultiCharBuffer) Begin
8465>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8466>>>>>>>>>            If (iStrLen) Begin
8468>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8469>>>>>>>>>                If (iLen=0) Begin
8471>>>>>>>>>                    Function_Return 0
8472>>>>>>>>>                End
8472>>>>>>>>>>
8472>>>>>>>>>            End
8472>>>>>>>>>>
8472>>>>>>>>>        End
8472>>>>>>>>>>
8472>>>>>>>>>        Function_Return pWideBuf
8473>>>>>>>>>    End_Function
8474>>>>>>>>>    
8474>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8476>>>>>>>>>        Pointer pValue
8476>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8477>>>>>>>>>        Function_Return pValue
8478>>>>>>>>>    End_Function
8479>>>>>>>>>    
8479>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8479>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8479>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8481>>>>>>>>>        Pointer pRetBuf
8481>>>>>>>>>        Integer iRetBufLen
8481>>>>>>>>>        Move 0 to pRetBuf
8482>>>>>>>>>        If (pWideBuf and iLen) Begin
8484>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8485>>>>>>>>>            If (iRetBufLen=0) Begin
8487>>>>>>>>>                Function_Return 0
8488>>>>>>>>>            End
8488>>>>>>>>>>
8488>>>>>>>>>        End
8488>>>>>>>>>>
8488>>>>>>>>>        Function_Return pRetBuf
8489>>>>>>>>>    End_Function
8490>>>>>>>>>    
8490>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8492>>>>>>>>>        String sValue
8492>>>>>>>>>        Pointer pValue
8492>>>>>>>>>        Boolean bOk
8492>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8493>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8495>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8496>>>>>>>>>>
8496>>>>>>>>>        End
8496>>>>>>>>>>
8496>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8497>>>>>>>>>        Move (Free(pValue)) to bOk
8498>>>>>>>>>        Function_Return sValue
8499>>>>>>>>>    End_Function
8500>>>>>>>>>    
8500>>>>>>>>>    
8500>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8500>>>>>>>>>    
8500>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8502>>>>>>>>>        Pointer pWideBuf
8502>>>>>>>>>        Pointer pUtf8Buf
8502>>>>>>>>>        Integer iLen iMultiBufLen
8502>>>>>>>>>        Boolean bOk
8502>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8503>>>>>>>>>        If (iLen=0) Begin
8505>>>>>>>>>            Function_Return 0
8506>>>>>>>>>        End
8506>>>>>>>>>>
8506>>>>>>>>>        Move 0 to pUtf8Buf
8507>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8508>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8509>>>>>>>>>        Function_Return pUtf8Buf
8510>>>>>>>>>    End_Function
8511>>>>>>>>>    
8511>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8513>>>>>>>>>        Pointer pValue
8513>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8514>>>>>>>>>        Function_Return pValue
8515>>>>>>>>>    End_Function
8516>>>>>>>>>    
8516>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8518>>>>>>>>>        Pointer pRetBuf pWideBuf
8518>>>>>>>>>        Integer iWideBufLen
8518>>>>>>>>>        Integer iRetBufLen
8518>>>>>>>>>        Boolean bOk
8518>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8519>>>>>>>>>        If (iWideBufLen=0) Begin
8521>>>>>>>>>            Function_Return 0
8522>>>>>>>>>        End
8522>>>>>>>>>>
8522>>>>>>>>>        Move 0 to pRetBuf
8523>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8524>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8525>>>>>>>>>        Function_Return pRetBuf
8526>>>>>>>>>    End_Function
8527>>>>>>>>>    
8527>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8529>>>>>>>>>        String sValue
8529>>>>>>>>>        Pointer pValue
8529>>>>>>>>>        Boolean bOk
8529>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8530>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8532>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8533>>>>>>>>>>
8533>>>>>>>>>        End
8533>>>>>>>>>>
8533>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8534>>>>>>>>>        Move (Free(pValue)) to bOk
8535>>>>>>>>>        Function_Return sValue
8536>>>>>>>>>    End_Function
8537>>>>>>>>>    
8537>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8537>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8537>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8537>>>>>>>>>    
8537>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8537>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8539>>>>>>>>>        Pointer pBSTR pRetStr
8539>>>>>>>>>        Integer iLen iBufLen
8539>>>>>>>>>        Boolean bOk
8539>>>>>>>>>        Move 0 to pRetStr
8540>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8541>>>>>>>>>        If (iLen) Begin
8543>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8544>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8545>>>>>>>>>        End
8545>>>>>>>>>>
8545>>>>>>>>>        Function_Return pRetStr
8546>>>>>>>>>    End_Function
8547>>>>>>>>>    
8547>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8547>>>>>>>>>    
8547>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8549>>>>>>>>>        String sValue
8549>>>>>>>>>        Pointer pValue
8549>>>>>>>>>        Boolean bOk
8549>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8550>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8552>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8553>>>>>>>>>>
8553>>>>>>>>>        End
8553>>>>>>>>>>
8553>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8554>>>>>>>>>        Move (Free(pValue)) to bOk
8555>>>>>>>>>        Function_Return sValue
8556>>>>>>>>>    End_Function
8557>>>>>>>>>    
8557>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8557>>>>>>>>>    
8557>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8559>>>>>>>>>        Variant vValue
8559>>>>>>>>>        Pointer pvValue
8559>>>>>>>>>        Boolean bOk
8559>>>>>>>>>        Pointer pWStr
8559>>>>>>>>>        Move "" to vValue
8560>>>>>>>>>        If (pSource) Begin
8562>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8562>>>>>>>>>            Move 0 to pWStr
8563>>>>>>>>>            //Convert the Ansi string to Unicode
8563>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8564>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8564>>>>>>>>>            Move 0 to vValue
8565>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8566>>>>>>>>>            //Change the Variant type to VT_BSTR
8566>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8567>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8567>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8568>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8568>>>>>>>>>            Move (Free(pWStr)) to bOk
8569>>>>>>>>>        End
8569>>>>>>>>>>
8569>>>>>>>>>        Function_Return vValue
8570>>>>>>>>>    End_Function
8571>>>>>>>>>    
8571>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8571>>>>>>>>>    
8571>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8573>>>>>>>>>        Variant vValue
8573>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8574>>>>>>>>>        Function_Return vValue
8575>>>>>>>>>    End_Function
8576>>>>>>>>>    
8576>>>>>>>>>    // Create buffer of utf16 data from variant.
8576>>>>>>>>>    // Returns newly created memory address and length (by reference)
8576>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8578>>>>>>>>>        Pointer pBSTR pRetStr
8578>>>>>>>>>        Boolean bOk
8578>>>>>>>>>        Move 0 to pRetStr
8579>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8580>>>>>>>>>        If (iLen) Begin
8582>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8583>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8584>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8585>>>>>>>>>        End
8585>>>>>>>>>>
8585>>>>>>>>>        Function_Return pRetStr
8586>>>>>>>>>    End_Function
8587>>>>>>>>>    
8587>>>>>>>>>    // Create variant from buffer of utf16 data
8587>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8589>>>>>>>>>        Variant vValue
8589>>>>>>>>>        Pointer pvValue
8589>>>>>>>>>        Boolean bOk
8589>>>>>>>>>        Move "" to vValue
8590>>>>>>>>>        If (pSource) Begin
8592>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8592>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8592>>>>>>>>>            Move 0 to vValue
8593>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8594>>>>>>>>>            //Change the Variant type to VT_BSTR
8594>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8595>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8595>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8596>>>>>>>>>        End
8596>>>>>>>>>>
8596>>>>>>>>>        Function_Return vValue
8597>>>>>>>>>    End_Function
8598>>>>>>>>>    
8598>>>>>>>>>    // Create Uchar array from variant string.
8598>>>>>>>>>    // Data buffer is encoded by eCharType
8598>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8600>>>>>>>>>        Pointer pBSTR pRetStr
8600>>>>>>>>>        Integer iLen iBufLen
8600>>>>>>>>>        Boolean bOk
8600>>>>>>>>>        UChar[] UC1
8601>>>>>>>>>        Move 0 to pRetStr
8602>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8603>>>>>>>>>        If (iLen) Begin
8605>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8606>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8608>>>>>>>>>                Move (iLen*2) to iBufLen
8609>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8610>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8611>>>>>>>>>            End
8611>>>>>>>>>>
8611>>>>>>>>>            Else Begin
8612>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8613>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8614>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8615>>>>>>>>>                Move (Free(pRetStr)) to bOk
8616>>>>>>>>>            End
8616>>>>>>>>>>
8616>>>>>>>>>        End
8616>>>>>>>>>>
8616>>>>>>>>>        Function_Return UC1
8617>>>>>>>>>    End_Function
8618>>>>>>>>>    
8618>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8618>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8620>>>>>>>>>        Variant vValue
8620>>>>>>>>>        Pointer pvValue
8620>>>>>>>>>        Boolean bOk
8620>>>>>>>>>        Pointer pWStr
8620>>>>>>>>>        Move "" to vValue
8621>>>>>>>>>        
8621>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8621>>>>>>>>>        Move 0 to pWStr
8622>>>>>>>>>        //Convert the Ansi string to Unicode
8622>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8624>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8625>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8626>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8627>>>>>>>>>        End
8627>>>>>>>>>>
8627>>>>>>>>>        Else Begin
8628>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8629>>>>>>>>>        End
8629>>>>>>>>>>
8629>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8629>>>>>>>>>        Move 0 to vValue
8630>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8631>>>>>>>>>        //Change the Variant type to VT_BSTR
8631>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8632>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8632>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8633>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8633>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8635>>>>>>>>>            Move (Free(pWStr)) to bOk
8636>>>>>>>>>        End
8636>>>>>>>>>>
8636>>>>>>>>>        Function_Return vValue
8637>>>>>>>>>    End_Function
8638>>>>>>>>>    
8638>>>>>>>>>    
8638>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8638>>>>>>>>>    // a new UChar array with to-encoding
8638>>>>>>>>>    
8638>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8640>>>>>>>>>        Pointer pFromBuf pToBuf
8640>>>>>>>>>        Integer iBytes iChars
8640>>>>>>>>>        Boolean bOk
8640>>>>>>>>>        
8640>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8641>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8643>>>>>>>>>            Function_Return UCharData
8644>>>>>>>>>        End
8644>>>>>>>>>>
8644>>>>>>>>>        
8644>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8646>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8647>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8648>>>>>>>>>        End
8648>>>>>>>>>>
8648>>>>>>>>>        Else Begin
8649>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8650>>>>>>>>>        End
8650>>>>>>>>>>
8650>>>>>>>>>        
8650>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8652>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8654>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8655>>>>>>>>>            End
8655>>>>>>>>>>
8655>>>>>>>>>            Else Begin
8656>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8657>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8658>>>>>>>>>            End
8658>>>>>>>>>>
8658>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8659>>>>>>>>>        End
8659>>>>>>>>>>
8659>>>>>>>>>        Else Begin
8660>>>>>>>>>            Move (iChars*2) to iBytes
8661>>>>>>>>>            Move pFromBuf to pToBuf
8662>>>>>>>>>        End
8662>>>>>>>>>>
8662>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8663>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8664>>>>>>>>>        Move (Free(pToBuf)) to bOk
8665>>>>>>>>>        Function_Return UCharData
8666>>>>>>>>>    End_Function
8667>>>>>>>>>    
8667>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8667>>>>>>>>>    // Variant strings. Binary data is always buffer
8667>>>>>>>>>    
8667>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8669>>>>>>>>>        Pointer pBase64
8669>>>>>>>>>        String sResult
8669>>>>>>>>>        Integer iVoid
8669>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8670>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8671>>>>>>>>>        Move (Free(pBase64)) to iVoid
8672>>>>>>>>>        Function_Return sResult
8673>>>>>>>>>    End_Function
8674>>>>>>>>>    
8674>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8676>>>>>>>>>        Pointer pBinaryData
8676>>>>>>>>>        String sBinary
8676>>>>>>>>>        Integer iVoid
8676>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8677>>>>>>>>>        Function_Return pBinaryData
8678>>>>>>>>>    End_Function
8679>>>>>>>>>    
8679>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8681>>>>>>>>>        Pointer pBase64
8681>>>>>>>>>        Variant vVar
8681>>>>>>>>>        Integer iBase64Len iVoid
8681>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8683>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8684>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8685>>>>>>>>>            Move (Free(pBase64)) to iVoid
8686>>>>>>>>>        End
8686>>>>>>>>>>
8686>>>>>>>>>        Function_Return vVar
8687>>>>>>>>>    End_Function
8688>>>>>>>>>    
8688>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8690>>>>>>>>>        Pointer pBase64 pBinaryData
8690>>>>>>>>>        Integer iVoid
8690>>>>>>>>>        Move 0 to iBinaryLen
8691>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8692>>>>>>>>>        If (pBase64) Begin
8694>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8695>>>>>>>>>            Move (Free(pBase64)) to iVoid
8696>>>>>>>>>        End
8696>>>>>>>>>>
8696>>>>>>>>>        Function_Return pBinaryData
8697>>>>>>>>>    End_Function
8698>>>>>>>>>    
8698>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8698>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8700>>>>>>>>>        Pointer pBase64
8700>>>>>>>>>        Integer iLen
8700>>>>>>>>>        Boolean bOk
8700>>>>>>>>>        
8700>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8701>>>>>>>>>        If (iLen) Begin
8703>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8704>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8705>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8706>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8707>>>>>>>>>            Move (Free(pBase64)) to bOk
8708>>>>>>>>>        End
8708>>>>>>>>>>
8708>>>>>>>>>        Function_Return UCharData
8709>>>>>>>>>    End_Function
8710>>>>>>>>>    
8710>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8710>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8712>>>>>>>>>        Pointer pData
8712>>>>>>>>>        Integer iLen
8712>>>>>>>>>        Boolean bOk
8712>>>>>>>>>        
8712>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8713>>>>>>>>>        If (iLen) Begin
8715>>>>>>>>>            Move 0 to UCharData[iLen]
8716>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8717>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8718>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8719>>>>>>>>>            Move (Free(pData)) to bOk
8720>>>>>>>>>        End
8720>>>>>>>>>>
8720>>>>>>>>>        Function_Return UCharData
8721>>>>>>>>>    End_Function
8722>>>>>>>>>    
8722>>>>>>>>>End_Class
8723>>>>>>>>>
8723>>>>>>>>>
8723>>>>>>>
8723>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8723>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8723>>>>>>>
8723>>>>>>>
8723>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8724>>>>>>>
8724>>>>>>>
8724>>>>>>>// When called directly, be sure to use WString types.
8724>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8725>>>>>>>
8725>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8726>>>>>>>    
8726>>>>>>>// When called directly, be sure to use String types.
8726>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8727>>>>>>>    
8727>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8727>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8727>>>>>>>    
8727>>>>>>>
8727>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8727>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8729>>>>>>>    
8729>>>>>>>    Integer iResult
8729>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8729>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8729>>>>>>>
8729>>>>>>>    Send StringToWide pSection (&uwSection)
8730>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8731>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8732>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8733>>>>>>>                           
8733>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8734>>>>>>>       
8734>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8735>>>>>>>        
8735>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8736>>>>>>>    
8736>>>>>>>    Function_Return iResult
8737>>>>>>>End_Function
8738>>>>>>> 
8738>>>>>>>
8738>>>>>>>Class cIniFile is a cObject
8739>>>>>>>    Procedure Construct_Object
8741>>>>>>>        Forward Send Construct_Object
8743>>>>>>>        
8743>>>>>>>        
8743>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8743>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8743>>>>>>>        Property Boolean pbWideAPI True
8744>>>>>>>        
8744>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8744>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8744>>>>>>>        // converted on first write (WriteString).
8744>>>>>>>        Property Boolean pbStoreAsUTF16 False
8745>>>>>>>        
8745>>>>>>>        Property String psPrivate_FileName ""
8746>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8747>>>>>>>    End_Procedure
8748>>>>>>>    
8748>>>>>>>    Procedure Set psFileName String sVal
8750>>>>>>>        Set pbPrivate_FirstWrite to True
8751>>>>>>>        Set psPrivate_FileName to sVal
8752>>>>>>>    End_Procedure
8753>>>>>>>    
8753>>>>>>>    Function psFileName Returns String
8755>>>>>>>        Function_Return (psPrivate_FileName(Self))
8756>>>>>>>    End_Function
8757>>>>>>>    
8757>>>>>>>    Procedure InitFile
8759>>>>>>>        Boolean bExists bHasBom
8759>>>>>>>        Integer iChnl
8759>>>>>>>        UChar[] ucData
8760>>>>>>>        Handle hoTranslate
8760>>>>>>>        
8760>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8762>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8763>>>>>>>            If (not(bExists)) Begin
8765>>>>>>>                //  Create the file with a UTF-16 BOM so
8765>>>>>>>                Move (Seq_New_Channel()) to iChnl
8766>>>>>>>                Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8768>>>>>>>                Write channel iChnl C_BOM_UTF16LE
8770>>>>>>>                Close_Output channel iChnl
8772>>>>>>>                Send Seq_Release_Channel iChnl
8773>>>>>>>            End
8773>>>>>>>>
8773>>>>>>>            Else Begin
8774>>>>>>>                //  Check for BOM
8774>>>>>>>                Move (Seq_New_Channel()) to iChnl
8775>>>>>>>                Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8777>>>>>>>                Read_Block channel iChnl ucData 2
8779>>>>>>>                
8779>>>>>>>                Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8780>>>>>>>                
8780>>>>>>>                //  If no BOM we'll have to read the entire file to convert it
8780>>>>>>>                If (not(bHasBom)) Begin
8782>>>>>>>                    Set_Channel_Position iChnl to 0
8783>>>>>>>>
8783>>>>>>>                    Read_Block ucData -1
8784>>>>>>>                End
8784>>>>>>>>
8784>>>>>>>
8784>>>>>>>                Close_Input channel iChnl
8786>>>>>>>                
8786>>>>>>>                If (not(bHasBom)) Begin
8788>>>>>>>                    //  Convert thedata
8788>>>>>>>                    Get Create (RefClass(cCharTranslate)) to hoTranslate
8789>>>>>>>                    Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8790>>>>>>>                    
8790>>>>>>>                    //  Write out the UTF 16 file with BOM
8790>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8792>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8794>>>>>>>                    
8794>>>>>>>                    Write channel iChnl ucData
8796>>>>>>>                    
8796>>>>>>>                    Close_Output channel iChnl
8798>>>>>>>                    
8798>>>>>>>                    Send Destroy of hoTranslate
8799>>>>>>>                End
8799>>>>>>>>
8799>>>>>>>                
8799>>>>>>>                Send Seq_Release_Channel iChnl
8800>>>>>>>            End
8800>>>>>>>>
8800>>>>>>>            
8800>>>>>>>            Set pbPrivate_FirstWrite to False
8801>>>>>>>        End
8801>>>>>>>>
8801>>>>>>>    End_Procedure
8802>>>>>>>    
8802>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8804>>>>>>>        Boolean bSuccess
8804>>>>>>>        String sFileName
8804>>>>>>>        
8804>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8806>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8807>>>>>>>>
8807>>>>>>>            Procedure_Return
8808>>>>>>>        End
8808>>>>>>>>
8808>>>>>>>        
8808>>>>>>>        Send InitFile
8809>>>>>>>        
8809>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8809>>>>>>>        If (pbWideAPI(Self)) Begin
8811>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8812>>>>>>>        End
8812>>>>>>>>
8812>>>>>>>        Else Begin
8813>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8814>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8815>>>>>>>        End
8815>>>>>>>>
8815>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8818>>>>>>>    End_Procedure
8819>>>>>>>    
8819>>>>>>>    
8819>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8821>>>>>>>        Integer iNumChars iSizeValue
8821>>>>>>>        WString wValue wFileName wSection wKey wDefault
8821>>>>>>>        String sFileName sValue
8821>>>>>>>        
8821>>>>>>>        Move 2047 to iSizeValue
8822>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8823>>>>>>>        
8823>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8825>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8826>>>>>>>>
8826>>>>>>>            Function_Return ''
8827>>>>>>>        End
8827>>>>>>>>
8827>>>>>>>        
8827>>>>>>>        If (pbWideAPI(Self)) Begin
8829>>>>>>>            Move sSection to wSection
8830>>>>>>>            Move sKey to wKey
8831>>>>>>>            Move sDefault to wDefault
8832>>>>>>>            Move sValue to wValue
8833>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8834>>>>>>>            Move wValue to sValue
8835>>>>>>>        End
8835>>>>>>>>
8835>>>>>>>        Else Begin
8836>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8837>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8838>>>>>>>        End
8838>>>>>>>>
8838>>>>>>>        
8838>>>>>>>        Function_Return  (CString(sValue))
8839>>>>>>>    End_Function
8840>>>>>>>    
8840>>>>>>>    Function SectionExists String sSection Returns Boolean
8842>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8842>>>>>>>        Handle hoKeys
8842>>>>>>>        Integer icKey iKey
8842>>>>>>>        
8842>>>>>>>        Get Create U_ARRAY to hoKeys
8843>>>>>>>        Send ReadSection sSection hoKeys
8844>>>>>>>        Get Item_Count of hoKeys to icKey
8845>>>>>>>        Send Destroy of hoKeys
8846>>>>>>>        
8846>>>>>>>        Function_Return (icKey >0)
8847>>>>>>>    End_Function
8848>>>>>>>    
8848>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8850>>>>>>>        Integer iNumChars iSizeValue iPos
8850>>>>>>>        Pointer lpsKeys
8850>>>>>>>        WString wKeys wKey
8850>>>>>>>        
8850>>>>>>>        Move 16384 to iSizeValue
8851>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wKeys
8852>>>>>>>        
8852>>>>>>>        Move (AddressOf(wKeys)) to lpsKeys
8853>>>>>>>        
8853>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8855>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8856>>>>>>>>
8856>>>>>>>            Procedure_Return
8857>>>>>>>        End
8857>>>>>>>>
8857>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8857>>>>>>>        Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8858>>>>>>>        If (iNumChars >0) Begin
8860>>>>>>>            Repeat
8860>>>>>>>>
8860>>>>>>>                Move (Pos(Character(0),wKeys)) to iPos
8861>>>>>>>                If (iPos >1) Begin
8863>>>>>>>                    Move (Left(wKeys,iPos -1))  to wKey
8864>>>>>>>                    Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8865>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to wKey
8866>>>>>>>                End
8866>>>>>>>>
8866>>>>>>>            Until (iPos <=1)
8868>>>>>>>        End
8868>>>>>>>>
8868>>>>>>>    End_Procedure
8869>>>>>>>    
8869>>>>>>>    Procedure ReadSections Handle hoArray
8871>>>>>>>        Integer iNumChars iSizeValue iPos
8871>>>>>>>        Pointer lpwSections
8871>>>>>>>        WString wSections
8871>>>>>>>        String sSection
8871>>>>>>>        
8871>>>>>>>        Move 16384 to iSizeValue
8872>>>>>>>        
8872>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8873>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8874>>>>>>>        
8874>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8876>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8877>>>>>>>>
8877>>>>>>>            Procedure_Return
8878>>>>>>>        End
8878>>>>>>>>
8878>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8878>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8879>>>>>>>        If (iNumChars >0) Begin
8881>>>>>>>            Repeat
8881>>>>>>>>
8881>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8882>>>>>>>                If (iPos >1) Begin
8884>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8885>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8886>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8887>>>>>>>                End
8887>>>>>>>>
8887>>>>>>>            Until (iPos <=1)
8889>>>>>>>        End
8889>>>>>>>>
8889>>>>>>>        
8889>>>>>>>    End_Procedure
8890>>>>>>>    
8890>>>>>>>    Procedure DeleteSection String sSection
8892>>>>>>>        
8892>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8894>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8895>>>>>>>>
8895>>>>>>>            Procedure_Return
8896>>>>>>>        End
8896>>>>>>>>
8896>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8899>>>>>>>    End_Procedure
8900>>>>>>>    
8900>>>>>>>    Procedure DeleteKey String sSection String sKey
8902>>>>>>>        Integer iVoid
8902>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8904>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8905>>>>>>>>
8905>>>>>>>            Procedure_Return
8906>>>>>>>        End
8906>>>>>>>>
8906>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8907>>>>>>>    End_Procedure
8908>>>>>>>    
8908>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
8910>>>>>>>        Handle hoKeys
8910>>>>>>>        Integer iKey
8910>>>>>>>        Boolean bExists
8910>>>>>>>        
8910>>>>>>>        Move (False) to bExists
8911>>>>>>>        
8911>>>>>>>        Move (Uppercase(sKey)) to sKey
8912>>>>>>>        
8912>>>>>>>        Get Create U_ARRAY to hoKeys
8913>>>>>>>        
8913>>>>>>>        Send ReadSection sSection hoKeys
8914>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
8920>>>>>>>>
8920>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
8922>>>>>>>                Move (True) to bExists
8923>>>>>>>            End
8923>>>>>>>>
8923>>>>>>>        Loop
8924>>>>>>>>
8924>>>>>>>        
8924>>>>>>>        Send Destroy of hoKeys
8925>>>>>>>        
8925>>>>>>>        Function_Return bExists
8926>>>>>>>    End_Function
8927>>>>>>>    
8927>>>>>>>End_Class
8928>>>>>
8928>>>>>Class cWorkspace is a cObject
8929>>>>>    
8929>>>>>    Procedure Construct_Object
8931>>>>>        Forward Send Construct_Object
8933>>>>>        
8933>>>>>        
8933>>>>>        Property String psAppSrcPath
8934>>>>>        Property String psBitmapPath
8935>>>>>        Property String psDataPath
8936>>>>>        Property String psDdSrcPath
8937>>>>>        Property String psDescription
8938>>>>>        Property String psFileList
8939>>>>>        Property String psHelpPath
8940>>>>>        Property String psHome
8941>>>>>        Property String psIdeSrcPath
8942>>>>>        Property String psProgramPath
8943>>>>>        Property String psAppHtmlPath
8944>>>>>        Property String psWorkspaceName
8945>>>>>        Property String psWorkspaceWSFile
8946>>>>>        Property String psConnectionIni
8947>>>>>        
8947>>>>>        Property String psSystemDfPath // took from the Registry!
8948>>>>>        Property String psSystemMakePath // took from the Registry!
8949>>>>>        Property String psDfPath        // Calculated
8950>>>>>        
8950>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
8951>>>>>        
8951>>>>>    End_Procedure
8952>>>>>    
8952>>>>>    Function FullPathNames String sShortPathNames Returns String
8954>>>>>        String sFileName
8954>>>>>        String sFullPathNames 
8954>>>>>        WString sFullPathName sShortPathName
8954>>>>>        Pointer lpsFilePart
8954>>>>>        Integer icChar // the number of characters returned
8954>>>>>        Integer iPos
8954>>>>>        
8954>>>>>        Move (Pos(";", sShortPathNames)) to iPos
8955>>>>>        While (length(sShortPathNames) >0)
8959>>>>>            If (iPos =0) Begin
8961>>>>>                Move sShortPathNames to sShortPathName
8962>>>>>                Move "" to sShortPathNames
8963>>>>>            End
8963>>>>>>
8963>>>>>            Else Begin // multiple paths
8964>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
8965>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
8966>>>>>            End
8966>>>>>>
8966>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
8967>>>>>            Move -1 to lpsFilePart
8968>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
8969>>>>>            Append sFullPathNames (CString(sFullPathName))
8970>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
8973>>>>>            Move (Pos(";", sShortPathNames)) to iPos
8974>>>>>        Loop
8975>>>>>>
8975>>>>>        
8975>>>>>        Function_Return sFullPathNames
8976>>>>>    End_Function
8977>>>>>    
8977>>>>>    Function GetApplicationPath Returns String
8979>>>>>        // Returns the path of the Application (no trailing "\")
8979>>>>>        WString wApplicationFileName 
8979>>>>>        Boolean bRemoved
8979>>>>>        Integer iNumChars
8979>>>>>        String sFilename sPath
8979>>>>>        
8979>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
8980>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
8981>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
8982>>>>>        
8982>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
8983>>>>>        Move (CString(wApplicationFileName)) to sPath
8984>>>>>        
8984>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8987>>>>>        Function_Return sPath
8988>>>>>    End_Function
8989>>>>>    
8989>>>>>    Procedure DoClearPaths
8991>>>>>        // Call this prior to changing from one WorkspAce to another
8991>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
8991>>>>>        Set psHome           to ""
8992>>>>>        Set psAppSrcPath     to ""
8993>>>>>        Set psBitmapPath     to ""
8994>>>>>        Set psDataPath       to ""
8995>>>>>        Set psDdSrcPath      to ""
8996>>>>>        Set psDescription    to ""
8997>>>>>        Set psFileList       to ""
8998>>>>>        Set psHelpPath       to ""
8999>>>>>        Set psIdeSrcPath     to ""
9000>>>>>        Set psAppHtmlPath    to ""
9001>>>>>        Set psProgramPath    to ""
9002>>>>>        Set psWorkspaceName  to ""
9003>>>>>        Set psSystemDfPath   to ""
9004>>>>>        Set psSystemMakePath to ""
9005>>>>>        Set psWorkspaceWSFile to ""
9006>>>>>        Set psConnectionIni to ""
9007>>>>>    End_Procedure
9008>>>>>    
9008>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
9010>>>>>        WString wApplicationStartPath
9010>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
9010>>>>>        Boolean bRemoved
9010>>>>>        Handle hoIniFile
9010>>>>>        Boolean bSuccess // call succeeded?
9010>>>>>        String sOldDirectory
9010>>>>>        String sSystemDfPath sSystemMakePath
9010>>>>>        Boolean bExist // does the WS file exist?
9010>>>>>        Boolean bChangingWorkspace
9010>>>>>        
9010>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
9010>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
9010>>>>>        
9010>>>>>        Set psWorkspaceWSFile to ""
9011>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
9014>>>>>        
9014>>>>>        // Append extension if not supplied...
9014>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
9016>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
9017>>>>>        End
9017>>>>>>
9017>>>>>        
9017>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
9018>>>>>        
9018>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
9020>>>>>            // Set the properties to the paths of the Workspace
9020>>>>>            // Find the WS file (with program)...
9020>>>>>            Get GetApplicationPath to wApplicationStartPath
9021>>>>>            
9021>>>>>            Move sWorkspaceFile to sWsName
9022>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
9023>>>>>        End
9023>>>>>>
9023>>>>>        Else Begin
9024>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
9025>>>>>            
9025>>>>>            Move sWorkspaceFile to wApplicationStartPath
9026>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
9027>>>>>        End
9027>>>>>>
9027>>>>>        
9027>>>>>        // Ensure that the file can be found...
9027>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
9027>>>>>        // [JVH] Turn off support for
9027>>>>>        // Ansi extended characters in workspace until we can
9027>>>>>        // resolve all open issues
9027>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
9028>>>>>        File_Exist sWorkspaceFile bExist
9029>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
9032>>>>>        
9032>>>>>        Get psHome           to sHome
9033>>>>>        Get psAppSrcPath     to sAppSrcPath
9034>>>>>        Get psAppHtmlPath    to sAppHtmlPath
9035>>>>>        Get psBitmapPath     to sBitmapPath
9036>>>>>        Get psDataPath       to sDataPath
9037>>>>>        Get psDdSrcPath      to sDdSrcPath
9038>>>>>        Get psDescription    to sDescription
9039>>>>>        Get psFileList       to sFileList
9040>>>>>        Get psHelpPath       to sHelpPath
9041>>>>>        Get psIdeSrcPath     to sIdeSrcPath
9042>>>>>        Get psProgramPath    to sProgramPath
9043>>>>>        Get psSystemDfPath   to sSystemDfPath
9044>>>>>        Get psSystemMakePath to sSystemMakePath
9045>>>>>        Get psWorkspaceName  to sWorkspaceName
9046>>>>>        Get psConnectionIni to sConnectionIni
9047>>>>>        
9047>>>>>        Get_Current_Directory to sOldDirectory
9048>>>>>        // Note- this conversion is temporarily rolled back
9048>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9048>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9049>>>>>        
9049>>>>>        Get Create U_cIniFile to hoIniFile
9050>>>>>        Set pbWideAPI of hoIniFile to False
9051>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9052>>>>>        
9052>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9055>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9058>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9061>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9064>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9067>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9070>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9073>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9076>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9079>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9082>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9085>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9088>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9091>>>>>        
9091>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9094>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9097>>>>>        
9097>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9098>>>>>        
9098>>>>>        // Set CWD to Home...
9098>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9099>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9100>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9101>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9102>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9103>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9104>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9105>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9106>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9107>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9108>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9109>>>>>        
9109>>>>>        Set psWorkspaceName to sWorkspaceName
9110>>>>>        Set psDescription   to sDescription
9111>>>>>        
9111>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9112>>>>>        
9112>>>>>        // Restore CWD...
9112>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9113>>>>>        
9113>>>>>        // Check for error conditions:
9113>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9113>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9116>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9119>>>>>        
9119>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9120>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9123>>>>>        
9123>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9126>>>>>        
9126>>>>>        Send DoAssignPaths // set psDfPath
9127>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9128>>>>>        Set pbWorkspaceOpened to True
9129>>>>>        
9129>>>>>        Function_Return wsWorkspaceOpened
9130>>>>>    End_Function
9131>>>>>    
9131>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9133>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9133>>>>>        
9133>>>>>        Handle hoSections hoIniFile
9133>>>>>        Integer iWorkspace eOpened
9133>>>>>        String sWorkspaceName sPath
9133>>>>>        String sVdfRootDir
9133>>>>>        
9133>>>>>        Get Create U_Array    to hoSections
9134>>>>>        Get Create U_cIniFile to hoIniFile
9135>>>>>        
9135>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9138>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9141>>>>>        
9141>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9142>>>>>        
9142>>>>>        Send ReadSections of hoIniFile hoSections
9143>>>>>        
9143>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9149>>>>>>
9149>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9150>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9152>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9153>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9156>>>>>                
9156>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9157>>>>>                Send Destroy of hoSections
9158>>>>>                Send Destroy of hoIniFile
9159>>>>>                Function_Return eOpened
9160>>>>>            End
9160>>>>>>
9160>>>>>        Loop
9161>>>>>>
9161>>>>>        
9161>>>>>        Send Destroy of hoSections
9162>>>>>        Send Destroy of hoIniFile
9163>>>>>        Function_Return wsWorkspaceNotFound
9164>>>>>    End_Function
9165>>>>>    
9165>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9167>>>>>        Boolean bRegistered
9167>>>>>        Handle hoIniFile
9167>>>>>        String sVdfRootDir
9167>>>>>        
9167>>>>>        Get Create U_cIniFile to hoIniFile
9168>>>>>        
9168>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9171>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9174>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9175>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9176>>>>>        
9176>>>>>        Send Destroy of hoIniFile
9177>>>>>        
9177>>>>>        Function_Return bRegistered
9178>>>>>    End_Function
9179>>>>>    
9179>>>>>    Function VdfSystemDfPath Returns String
9181>>>>>        String sSystemDfPath
9181>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9184>>>>>        
9184>>>>>        Function_Return sSystemDfPath
9185>>>>>    End_Function
9186>>>>>    
9186>>>>>    Function VdfSystemMakePath Returns String
9188>>>>>        String sSystemMakePath
9188>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9191>>>>>        
9191>>>>>        Function_Return sSystemMakePath
9192>>>>>    End_Function
9193>>>>>    
9193>>>>>    Procedure DoAssignPaths
9195>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9195>>>>>        
9195>>>>>        Get psDataPath     to sDataPath
9196>>>>>        Get psBitmapPath   to sBitmapPath
9197>>>>>        Get psHelpPath     to sHelpPath
9198>>>>>        Get psProgramPath  to sProgramPath
9199>>>>>        Get psSystemDfPath to sSystemDfPath
9200>>>>>        
9200>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9201>>>>>        
9201>>>>>    End_Procedure
9202>>>>>    
9202>>>>>    Procedure DoSetPaths
9204>>>>>        // [JVH] must convert paths to Ansi before setting these values
9204>>>>>        // Note- this conversion is temporarily rolled back
9204>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9204>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9204>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9207>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9210>>>>>    End_Procedure
9211>>>>>    
9211>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9213>>>>>        String sPath
9213>>>>>        
9213>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9216>>>>>        Else Begin
9217>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9218>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9219>>>>>            Send hmGeneric to hoCallBack ""
9220>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9221>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9222>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9223>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9224>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9225>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9226>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9227>>>>>        End
9227>>>>>>
9227>>>>>    End_Procedure
9228>>>>>    
9228>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9230>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9230>>>>>        // returns a corresponding message string.
9230>>>>>        String sError
9230>>>>>        
9230>>>>>        Case Begin
9230>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9232>>>>>                Move C_$NoErrors to sError
9233>>>>>                Case Break
9234>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9237>>>>>                Move C_$NoWsName to sError
9238>>>>>                Case Break
9239>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9242>>>>>                Move C_$NoWsFileFound to sError
9243>>>>>                Case Break
9244>>>>>            Case (eErrorCode = wsDataPathEmpty)
9247>>>>>                Move C_$NoWsDataPath to sError
9248>>>>>                Case Break
9249>>>>>            Case (eErrorCode = wsFileListEmpty)
9252>>>>>                Move C_$NoWsFileList to sError
9253>>>>>                Case Break
9254>>>>>            Case (eErrorCode = wsFileListNotExist)
9257>>>>>                Move C_$NoFileListCfg to sError
9258>>>>>                Case Break
9259>>>>>            Case Else
9259>>>>>                Move C_$UnknownError to sError
9260>>>>>                Case Break
9261>>>>>        Case End
9261>>>>>        
9261>>>>>        Function_Return (sError-".")
9262>>>>>    End_Function
9263>>>>>    
9263>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9265>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9265>>>>>        String sVdfRootDir
9265>>>>>        Handle hoIniFile
9265>>>>>        String sPath
9265>>>>>        String sFileName
9265>>>>>        String sWorkspacePath
9265>>>>>        
9265>>>>>        Move "" to sFileName
9266>>>>>        
9266>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9269>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9272>>>>>        
9272>>>>>        Get Create U_cIniFile to hoIniFile
9273>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9274>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9275>>>>>        If (sWorkspacePath <>"") Begin
9277>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9280>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9281>>>>>        End
9281>>>>>>
9281>>>>>        Send Destroy of hoIniFile
9282>>>>>        
9282>>>>>        Function_Return sFileName
9283>>>>>    End_Function
9284>>>>>    
9284>>>>>    Function CountOfPaths String sPaths Returns Integer
9286>>>>>        // Returns the number of paths defined in a string of paths
9286>>>>>        Integer iChar icChar icPath
9286>>>>>        
9286>>>>>        If (sPaths ="") ;            Function_Return 0
9289>>>>>        
9289>>>>>        Move (Length(sPaths) -1) to icChar
9290>>>>>        For iChar from 1 to icChar
9296>>>>>>
9296>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9299>>>>>        Loop
9300>>>>>>
9300>>>>>        
9300>>>>>        Function_Return (icPath +1)
9301>>>>>    End_Function
9302>>>>>    
9302>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9304>>>>>        // Returns the path at the 1-based index of passed paths.
9304>>>>>        // If the path contains a trailing "\", it will be removed
9304>>>>>        Integer iChar icPath iPath iPos
9304>>>>>        String sPath
9304>>>>>        
9304>>>>>        Move (sPaths +";") to sPaths
9305>>>>>        For iPath from 1 to iIndex
9311>>>>>>
9311>>>>>            Move (Pos(";", sPaths)) to iPos
9312>>>>>            If iPos Begin
9314>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9315>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9318>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9319>>>>>            End
9319>>>>>>
9319>>>>>            Else ;                Function_Return "" // index past number of paths
9321>>>>>        Loop
9322>>>>>>
9322>>>>>        
9322>>>>>        Function_Return sPath
9323>>>>>    End_Function
9324>>>>>    
9324>>>>>End_Class
9325>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCommandLine.pkg)
9325>>>>>Use VDFBase.pkg
9325>>>>>
9325>>>>>Class cCommandLine is a cObject
9326>>>>>    
9326>>>>>    Procedure Construct_Object
9328>>>>>        Forward Send Construct_Object
9330>>>>>        
9330>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9331>>>>>    End_Procedure
9332>>>>>    
9332>>>>>    Procedure Private_DoCreateArgsArray
9334>>>>>        // creates the array for holding the arguments. Created upon demand only!
9334>>>>>        Integer icArg
9334>>>>>        String sArg
9334>>>>>        
9334>>>>>        Object oArgs is an Array
9336>>>>>            Delegate Set phoArgs to Self
9338>>>>>            Repeat
9338>>>>>>
9338>>>>>                CmdLine sArg
9339>>>>>>
9339>>>>>                If (sArg <> "") Begin
9341>>>>>                    Increment icArg
9342>>>>>                    Set Value  (icArg -1) to sArg
9343>>>>>                End
9343>>>>>>
9343>>>>>            Until (sArg = "")
9345>>>>>        End_Object
9346>>>>>    End_Procedure
9347>>>>>    
9347>>>>>    Function CountOfArgs Returns Integer
9349>>>>>        //Returns the number of arguments passed
9349>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9352>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9353>>>>>    End_Function
9354>>>>>    
9354>>>>>    Function Argument Integer iIndex Returns String
9356>>>>>        //Returns the one-based argument string
9356>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9359>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9360>>>>>    End_Function
9361>>>>>    
9361>>>>>End_Class
9362>>>>>
9362>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cRegistry.pkg)
9362>>>>>Use Dll.pkg
9362>>>>>Use RegistryAPI.pkg
9362>>>>>Use tWinStructs.pkg
9362>>>>>
9362>>>>>Enum_List // Registry Data types
9362>>>>>    Define rdString
9362>>>>>    Define rdDword
9362>>>>>    Define rdBinary
9362>>>>>    Define rdUnknown
9362>>>>>End_Enum_List
9362>>>>>
9362>>>>>
9362>>>>>Class cRegistry is a cObject
9363>>>>>    Procedure Construct_Object
9365>>>>>        Forward Send Construct_Object
9367>>>>>        
9367>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9368>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9369>>>>>        Property Handle phCurrentKey
9370>>>>>        Property Boolean pbLazyWrite True
9371>>>>>    End_Procedure
9372>>>>>    
9372>>>>>    Function CountOfSubkeys Returns Integer
9374>>>>>        Integer dwCountOfSubkeys
9374>>>>>        Integer iError
9374>>>>>        String sError
9374>>>>>        
9374>>>>>        Move 0 to dwCountOfSubkeys
9375>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9376>>>>>        If iError Begin
9378>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9379>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9380>>>>>>
9380>>>>>        End
9380>>>>>>
9380>>>>>        Function_Return dwCountOfSubkeys
9381>>>>>    End_Function
9382>>>>>    
9382>>>>>    Function CountOfValues Returns Integer
9384>>>>>        Integer dwCountOfValues
9384>>>>>        Integer iError
9384>>>>>        String sError
9384>>>>>        
9384>>>>>        Move 0 to dwCountOfValues
9385>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9386>>>>>        If iError Begin
9388>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9389>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9390>>>>>>
9390>>>>>        End
9390>>>>>>
9390>>>>>        
9390>>>>>        Function_Return dwCountOfValues
9391>>>>>    End_Function
9392>>>>>    
9392>>>>>    Function LongestSubkeyLength Returns Integer
9394>>>>>        Integer dwLongestSubkeyLength
9394>>>>>        Integer iError
9394>>>>>        String sError
9394>>>>>        
9394>>>>>        Move 0 to dwLongestSubkeyLength
9395>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9396>>>>>        If iError Begin
9398>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9399>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9400>>>>>>
9400>>>>>        End
9400>>>>>>
9400>>>>>        
9400>>>>>        Function_Return dwLongestSubkeyLength
9401>>>>>    End_Function
9402>>>>>    
9402>>>>>    Function LongestValueLength Returns Integer
9404>>>>>        Integer dwLongestValueLength
9404>>>>>        Integer iError
9404>>>>>        String sError
9404>>>>>        
9404>>>>>        Move 0 to dwLongestValueLength
9405>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9406>>>>>        If iError Begin
9408>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9409>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9410>>>>>>
9410>>>>>        End
9410>>>>>>
9410>>>>>        
9410>>>>>        Function_Return dwLongestValueLength
9411>>>>>    End_Function
9412>>>>>    
9412>>>>>    Function LongestDataLength Returns Integer
9414>>>>>        Integer dwLongestDataLength
9414>>>>>        Integer iError
9414>>>>>        String sError
9414>>>>>        
9414>>>>>        Move 0 to dwLongestDataLength
9415>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9416>>>>>        If iError Begin
9418>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9419>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9420>>>>>>
9420>>>>>        End
9420>>>>>>
9420>>>>>        
9420>>>>>        Function_Return dwLongestDataLength
9421>>>>>    End_Function
9422>>>>>    
9422>>>>>    Function ValueType String sValueName Returns Integer
9424>>>>>        Integer dwType
9424>>>>>        Integer iError eType
9424>>>>>        String sError
9424>>>>>        
9424>>>>>        Move 0 to dwType
9425>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9426>>>>>        If iError Begin
9428>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9429>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9430>>>>>>
9430>>>>>        End
9430>>>>>>
9430>>>>>        
9430>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9433>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9437>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9441>>>>>        Else ;            Move rdUnknown to eType
9443>>>>>        
9443>>>>>        Function_Return eType
9444>>>>>    End_Function
9445>>>>>    
9445>>>>>    Function ValueLength String sValueName Returns Integer
9447>>>>>        Integer dwSize
9447>>>>>        Integer iError
9447>>>>>        String sError
9447>>>>>        
9447>>>>>        Move 0 to dwSize
9448>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9449>>>>>        If iError Begin
9451>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9452>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9453>>>>>>
9453>>>>>        End
9453>>>>>>
9453>>>>>        
9453>>>>>        Function_Return dwSize
9454>>>>>    End_Function
9455>>>>>    
9455>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9457>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9457>>>>>        Handle hKey hKeyOpened
9457>>>>>        Integer iError
9457>>>>>        String sError
9457>>>>>        
9457>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9458>>>>>        
9458>>>>>        Get phRootKey to hKey
9459>>>>>        
9459>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9460>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9463>>>>>        Else Begin
9464>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9465>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9466>>>>>>
9466>>>>>        End
9466>>>>>>
9466>>>>>        Function_Return iError
9467>>>>>    End_Function
9468>>>>>    
9468>>>>>    Procedure CloseKey
9470>>>>>        Integer iError
9470>>>>>        Handle hKey
9470>>>>>        
9470>>>>>        Get phCurrentKey to hKey
9471>>>>>        
9471>>>>>        If (hKey <>0) Begin
9473>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9476>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9478>>>>>            
9478>>>>>            Set phCurrentKey to 0
9479>>>>>        End
9479>>>>>>
9479>>>>>    End_Procedure
9480>>>>>    
9480>>>>>    Function OpenKey String sKeyName Returns Boolean
9482>>>>>        Handle hKey hKeyOpened
9482>>>>>        Integer iError
9482>>>>>        
9482>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9483>>>>>        
9483>>>>>        Get phRootKey to hKey
9484>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9485>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9488>>>>>        
9488>>>>>        Function_Return (iError=0)
9489>>>>>    End_Function
9490>>>>>    
9490>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9492>>>>>        Handle hKey
9492>>>>>        Integer iError
9492>>>>>        Integer iData
9492>>>>>        String sError
9492>>>>>        
9492>>>>>        Move iValueData to iData
9493>>>>>        Get phCurrentKey to hKey
9494>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9495>>>>>        If iError Begin
9497>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9498>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9499>>>>>>
9499>>>>>        End
9499>>>>>>
9499>>>>>    End_Procedure
9500>>>>>    
9500>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9500>>>>>    Procedure WriteDword String sValue Integer iValueData
9502>>>>>        Send WriteInteger of Self sValue iValueData
9503>>>>>    End_Procedure
9504>>>>>    
9504>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9506>>>>>        Handle hKey
9506>>>>>        Integer iError
9506>>>>>        UInteger uData
9506>>>>>        String sError
9506>>>>>        
9506>>>>>        Move uValueData to uData
9507>>>>>        Get phCurrentKey to hKey
9508>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9509>>>>>        If iError Begin
9511>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9512>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9513>>>>>>
9513>>>>>        End
9513>>>>>>
9513>>>>>    End_Procedure
9514>>>>>
9514>>>>>    Procedure WriteString WString sValue WString wValueData
9516>>>>>        Handle hKey
9516>>>>>        Integer iError cbData
9516>>>>>        String sError
9516>>>>>        
9516>>>>>        If (wValueData = "") Begin
9518>>>>>            Move (Character(0)) to wValueData
9519>>>>>            Move 1 to cbData
9520>>>>>        End
9520>>>>>>
9520>>>>>        Else Begin
9521>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9522>>>>>        End
9522>>>>>>
9522>>>>>        Get phCurrentKey to hKey
9523>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9524>>>>>        If iError Begin
9526>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9527>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9528>>>>>>
9528>>>>>        End
9528>>>>>>
9528>>>>>    End_Procedure
9529>>>>>    
9529>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9531>>>>>        Handle hKey
9531>>>>>        Integer iError
9531>>>>>        String sError
9531>>>>>        
9531>>>>>        Get phCurrentKey to hKey
9532>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9533>>>>>        If iError Begin
9535>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9536>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9537>>>>>>
9537>>>>>        End
9537>>>>>>
9537>>>>>    End_Procedure
9538>>>>>    
9538>>>>>    Function ReadInteger WString sValueName Returns Integer
9540>>>>>        Handle hKey
9540>>>>>        Integer iError
9540>>>>>        Integer iValueData iValueDataLength
9540>>>>>        String sError
9540>>>>>        
9540>>>>>        Move 0           to iValueData
9541>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9542>>>>>        
9542>>>>>        Get phCurrentKey to hKey
9543>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9544>>>>>        If iError Begin
9546>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9547>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9548>>>>>>
9548>>>>>        End
9548>>>>>>
9548>>>>>        
9548>>>>>        Function_Return iValueData
9549>>>>>    End_Function
9550>>>>>    
9550>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9550>>>>>    Function ReadDword String sValueName Returns Integer
9552>>>>>        Function_Return (ReadInteger(Self, sValueName))
9553>>>>>    End_Function
9554>>>>>
9554>>>>>    Function ReadUInt WString sValueName Returns UInteger
9556>>>>>        Handle hKey
9556>>>>>        Integer iError
9556>>>>>        UInteger uValueData uValueDataLength
9556>>>>>        String sError
9556>>>>>        
9556>>>>>        Move 0           to uValueData
9557>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9558>>>>>        
9558>>>>>        Get phCurrentKey to hKey
9559>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9560>>>>>        If iError Begin
9562>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9563>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9564>>>>>>
9564>>>>>        End
9564>>>>>>
9564>>>>>        
9564>>>>>        Function_Return uValueData
9565>>>>>    End_Function
9566>>>>>    
9566>>>>>    Function ReadString String sValueName Returns String
9568>>>>>        Handle hKey
9568>>>>>        Integer iError
9568>>>>>        WString wValueData
9568>>>>>        DWord dwValueDataLength dwType
9568>>>>>        Pointer lpsValueData
9568>>>>>        String sError
9568>>>>>        
9568>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9569>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9570>>>>>        
9570>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9571>>>>>        
9571>>>>>        Move REG_SZ to dwType
9572>>>>>        
9572>>>>>        Get phCurrentKey to hKey
9573>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9574>>>>>        If iError Begin
9576>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9577>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9578>>>>>>
9578>>>>>        End
9578>>>>>>
9578>>>>>        
9578>>>>>        Function_Return (CString(wValueData))
9579>>>>>    End_Function
9580>>>>>    
9580>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9582>>>>>        Handle hKey
9582>>>>>        Integer iError
9582>>>>>        String sError
9582>>>>>        
9582>>>>>        Get phCurrentKey to hKey
9583>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9584>>>>>        If iError Begin
9586>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9587>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9588>>>>>>
9588>>>>>        End
9588>>>>>>
9588>>>>>        
9588>>>>>        Function_Return (iDataLength >0)
9589>>>>>    End_Function
9590>>>>>    
9590>>>>>    
9590>>>>>    // Private....
9590>>>>>    Function GetBaseKey Returns Handle
9592>>>>>        Handle hBaseKey
9592>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9595>>>>>        Else ;            Get phCurrentKey to hBaseKey
9597>>>>>        
9597>>>>>        Function_Return hBaseKey
9598>>>>>    End_Function
9599>>>>>    
9599>>>>>    Function GetKey String sKeyName Returns Handle
9601>>>>>        Handle hKeyOpened
9601>>>>>        Integer iError
9601>>>>>        
9601>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9602>>>>>        
9602>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9603>>>>>        
9603>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9606>>>>>        Else ;            Function_Return 0
9608>>>>>    End_Function
9609>>>>>    
9609>>>>>    // Public
9609>>>>>    Function KeyExists String sKeyName Returns Boolean
9611>>>>>        Handle hKey
9611>>>>>        Integer iVoid
9611>>>>>        
9611>>>>>        If (Trim(sKeyName) = "") ;            Function_Return False
9614>>>>>        
9614>>>>>        Get GetKey sKeyName to hKey
9615>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9618>>>>>        Function_Return (hKey <>0)
9619>>>>>    End_Function
9620>>>>>    
9620>>>>>    Function ValueExists String sValueName Returns Boolean
9622>>>>>        // Determines whether a Value exists for the currently-opened Key.
9622>>>>>        Integer iError
9622>>>>>        DWord dwDataType
9622>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9623>>>>>        
9623>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9624>>>>>        
9624>>>>>        Function_Return (iError=0)
9625>>>>>    End_Function
9626>>>>>    
9626>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9628>>>>>        
9628>>>>>            If (Trim(sKeyName) = "") ;            Function_Return False
9631>>>>>        
9631>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9632>>>>>    End_Function
9633>>>>>    
9633>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9635>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9636>>>>>    End_Function
9637>>>>>    
9637>>>>>    Function Subkeys Returns String[]
9639>>>>>        Integer iError
9639>>>>>        Integer icValue iLongestSubkey
9639>>>>>        Handle hKey
9639>>>>>        DWord dwSubkeyNameLength
9639>>>>>        String sSubkeyName sFileTime
9639>>>>>        Pointer lpsSubkeyName
9639>>>>>        String[] aResult
9640>>>>>        tWinFileTime fileTime
9640>>>>>        tWinFileTime fileTime
9640>>>>>
9640>>>>>        Get LongestSubkeyLength to iLongestSubkey
9641>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
9642>>>>>        Move (AddressOf(sSubkeyName)) to lpsSubkeyName
9643>>>>>
9643>>>>>        Get phCurrentKey to hKey
9644>>>>>        Repeat
9644>>>>>>
9644>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9645>>>>>
9645>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(fileTime))) to iError
9646>>>>>            If (iError =0) Begin
9648>>>>>                Move (CString(sSubkeyName)) to aResult[icValue]
9649>>>>>                Increment icValue
9650>>>>>            End
9650>>>>>>
9650>>>>>        Until (iError)
9652>>>>>        Function_Return aResult
9653>>>>>    End_Function
9654>>>>>    
9654>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9656>>>>>        Integer iError
9656>>>>>        Integer icValue iLongestSubkey
9656>>>>>        Handle hKey
9656>>>>>        DWord dwSubkeyNameLength
9656>>>>>        WString wSubkeyName
9656>>>>>        tWinFileTime FileTime
9656>>>>>        tWinFileTime FileTime
9656>>>>>        
9656>>>>>        Get LongestSubkeyLength to iLongestSubkey
9657>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9658>>>>>        
9658>>>>>        Get phCurrentKey to hKey
9659>>>>>        Repeat
9659>>>>>>
9659>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9660>>>>>            
9660>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9661>>>>>            If (iError =0) Begin
9663>>>>>                Increment icValue
9664>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9665>>>>>            End
9665>>>>>>
9665>>>>>        Until (iError)
9667>>>>>        Function_Return icValue
9668>>>>>        
9668>>>>>    End_Function
9669>>>>>    
9669>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9671>>>>>        Integer iError
9671>>>>>        Integer icValue iLongestValue
9671>>>>>        Handle hKey
9671>>>>>        DWord dwValueNameLength
9671>>>>>        WString wValueName 
9671>>>>>        String sValueNameSize
9671>>>>>        Pointer lpsValueName
9671>>>>>        
9671>>>>>        Get LongestValueLength to iLongestValue
9672>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9673>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9674>>>>>        
9674>>>>>        Get phCurrentKey to hKey
9675>>>>>        Repeat
9675>>>>>>
9675>>>>>            Move (iLongestValue +1) to dwValueNameLength
9676>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9677>>>>>            If (iError =0) Begin
9679>>>>>                Increment icValue
9680>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9681>>>>>            End
9681>>>>>>
9681>>>>>        Until (iError)
9683>>>>>        Function_Return icValue
9684>>>>>        
9684>>>>>    End_Function
9685>>>>>    
9685>>>>>End_Class
9686>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cVersionInfo.pkg)
9686>>>>>Use VdfBase.pkg
9686>>>>>Use DLL.pkg
9686>>>>>Use tWinStructs.pkg
9686>>>>>Use WinKern.pkg
9686>>>>>
9686>>>>>Define VS_FF_DEBUG         for |CI$00000001
9686>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9686>>>>>Define VS_FF_PATCHED       for |CI$00000004
9686>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9686>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9686>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9686>>>>>
9686>>>>>// Note: String pointer lpFilename must refer to WString type.
9686>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9687>>>>>    
9687>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9687>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9689>>>>>    
9689>>>>>    DWord  dwResult
9689>>>>>    UWide  uwFileName
9689>>>>>    UWide  uwFileName
9689>>>>>
9689>>>>>    Send StringToWide aFilename (&uwFileName)
9690>>>>>    
9690>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9691>>>>>    Function_Return dwResult
9692>>>>>End_Function
9693>>>>>
9693>>>>>// Note: String pointers should be referring to WString items.
9693>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9694>>>>>    
9694>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9694>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9696>>>>>    
9696>>>>>    Integer iResult
9696>>>>>    UWide   uwFileName
9696>>>>>    UWide   uwFileName
9696>>>>>
9696>>>>>    Send StringToWide aFilename (&uwFileName)
9697>>>>>    
9697>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9698>>>>>    Function_Return iResult
9699>>>>>End_Function    
9700>>>>>
9700>>>>>// Note: String pointers should be referring to WString items.
9700>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9701>>>>>
9701>>>>>// Wrapper Function VerQueryValue (when using strings)
9701>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9703>>>>>    
9703>>>>>    Integer iResult
9703>>>>>    UWide   uwSubBlock
9703>>>>>    UWide   uwSubBlock
9703>>>>>    
9703>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9704>>>>>    
9704>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9705>>>>>    
9705>>>>>    Function_Return iResult
9706>>>>>End_Function
9707>>>>>
9707>>>>>
9707>>>>>Class cVersionInfo is a cObject
9708>>>>>    Procedure Construct_Object
9710>>>>>        Forward Send Construct_Object
9712>>>>>        
9712>>>>>        
9712>>>>>        Property Integer piVersionMajor
9713>>>>>        Property Integer piVersionMinor
9714>>>>>        Property Integer piVersionRelease
9715>>>>>        Property Integer piVersionBuild
9716>>>>>        
9716>>>>>        Property Boolean pbIncluded
9717>>>>>        Property Boolean pbSpecialBuild
9718>>>>>        Property Boolean pbPrivateBuild
9719>>>>>        
9719>>>>>    End_Procedure
9720>>>>>    
9720>>>>>    Procedure DoCreate WString sFileName
9722>>>>>        DWord dwHandle
9722>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9722>>>>>        WString sData
9722>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9722>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9722>>>>>        WString sSubBlock
9722>>>>>        Pointer pVsFixedFileInfo
9722>>>>>        
9722>>>>>        Move 0 to pVsFixedFileInfo
9723>>>>>        Move 0 to dwHandle
9724>>>>>        Move 0 to iVerSize
9725>>>>>        
9725>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9726>>>>>        Set pbIncluded to (iInfoSize <>0)
9727>>>>>        
9727>>>>>        If (pbIncluded(Self)) Begin
9729>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9730>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9731>>>>>            
9731>>>>>            If (iSuccess <>0) Begin
9733>>>>>                Move "\" to sSubBlock
9734>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9736>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9737>>>>>                    
9737>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9738>>>>>                    Set piVersionMajor to (Hi(iVersion))
9739>>>>>                    Set piVersionMinor to (Low(iVersion))
9740>>>>>                    
9740>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9741>>>>>                    Set piVersionRelease to (Hi(iVersion))
9742>>>>>                    Set piVersionBuild   to (Low(iVersion))
9743>>>>>                    
9743>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9744>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9745>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9746>>>>>                End
9746>>>>>>
9746>>>>>            End
9746>>>>>>
9746>>>>>            
9746>>>>>        End
9746>>>>>>
9746>>>>>    End_Procedure
9747>>>>>    
9747>>>>>End_Class
9748>>>Use GlobalFunctionsProcedures.pkg
9748>>>Use tWinStructs.pkg
9748>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9748>>>
9748>>>Register_Function phoWorkspace Returns Handle
9748>>>Register_Function phoCommandLine Returns Handle
9748>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9748>>>Register_Function GetApplicationName Returns String
9748>>>Register_Function GetApplicationFileName Returns String
9748>>>
9748>>>Register_Function Statusbar_State Returns Integer
9748>>>Register_Function Toolbar_State Returns Integer
9748>>>Register_Procedure Set Statusbar_State
9748>>>Register_Procedure Set Toolbar_State
9748>>>
9748>>>
9748>>>Class cApplication is a cObject
9749>>>    Procedure Construct_Object
9751>>>        Forward Send Construct_Object
9753>>>        
9753>>>        Move Self to ghoApplication
9754>>>        
9754>>>        Property Handle phoVersionInfo
9755>>>        Property Handle phoWorkspace
9756>>>        Property Handle phoCommandLine
9757>>>        Property Handle phoMainPanel       // main panel will set this for us.
9758>>>        Property String psHelpFile         // type of file is determined by peHelpType
9759>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9760>>>        
9760>>>        Property String psCompany "Data Access Worldwide"
9761>>>        Property String psProduct "DataFlex Applications"
9762>>>        Property String psVersion C_DFVersion
9763>>>        Property String psProgram (Module_Name(desktop))
9764>>>        
9764>>>        // set to '' to stop the auto open workspace behavior
9764>>>        Property String psAutoOpenWorkspace 'Config.ws'
9765>>>        
9765>>>        
9765>>>        Property Boolean pbPreserveEnvironment True
9766>>>        
9766>>>        Object oCommandLine is a cCommandLine
9768>>>            Delegate Set phoCommandLine to Self
9770>>>        End_Object
9771>>>        
9771>>>        Object oWorkspace is a cWorkspace
9773>>>            Delegate Set phoWorkspace to Self
9775>>>        End_Object
9776>>>        
9776>>>        Object oVersionInfo is a cVersionInfo
9778>>>            Delegate Set phoVersionInfo to Self
9780>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9781>>>        End_Object
9782>>>        
9782>>>        Set pbUseWindowsFont to True
9783>>>        
9783>>>    End_Procedure
9784>>>    
9784>>>    Procedure Destroy_Object
9786>>>        If (ghoApplication=Self) Begin
9788>>>            Move 0 to ghoApplication
9789>>>        End
9789>>>>
9789>>>        Forward Send Destroy_Object
9791>>>    End_Procedure
9792>>>    
9792>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9792>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9792>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9794>>>        Move bNext to gbKEnterNext
9795>>>    End_Procedure
9796>>>    
9796>>>    Function pbEnterKeyAsTabKey Returns Boolean
9798>>>        Function_Return gbKEnterNext
9799>>>    End_Function
9800>>>    
9800>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9802>>>// not used with webapp
9802>>>        Handle hoRegistry hoCommandBars
9802>>>        Handle hMonitor
9802>>>        Integer iError cxy
9802>>>        tWinWindowPlacement WindowPlacement
9802>>>        tWinWindowPlacement WindowPlacement
9802>>>        String sKey
9802>>>        Boolean bSuccess
9802>>>        String sObjectName
9802>>>        
9802>>>        If (pbPreserveEnvironment(Self)) Begin
9804>>>            Get Create U_cRegistry to hoRegistry
9805>>>            Set pfAccessRights of hoRegistry to KEY_READ
9806>>>            
9806>>>            Get RegistryKeyString to sKey
9807>>>            
9807>>>            If (bProgram = False) Begin
9809>>>                Move (sKey +"\WINDOWS") to sKey
9810>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9811>>>                Move (sKey +"\" +sObjectName) to sKey
9812>>>            End
9812>>>>
9812>>>            Else ;                Move (sKey + "\Preferences") to sKey
9814>>>            
9814>>>            Get OpenKey of hoRegistry sKey to bSuccess
9815>>>            
9815>>>            If bSuccess Begin
9817>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9819>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9820>>>                    If bSuccess Begin
9822>>>                        // Do not restore size if the window is not resizable
9822>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9824>>>                            // restore always works with outer size
9824>>>                            Get GuiWindowSize     of hoContainer to cxy
9825>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9826>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9827>>>                        End
9827>>>>
9827>>>                        
9827>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9827>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9827>>>                        If (bProgram) Begin
9829>>>                            // Test the top left point
9829>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9830>>>                            
9830>>>                            If (hMonitor = 0) Begin
9832>>>                                // test the bottom right point
9832>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9833>>>                            End
9833>>>>
9833>>>                            
9833>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9833>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9833>>>                            If (hMonitor = 0) Begin
9835>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9836>>>                            End
9836>>>>
9836>>>                        End
9836>>>>
9836>>>                        
9836>>>                        // Set the placement
9836>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9837>>>                    End
9837>>>>
9837>>>                End
9837>>>>
9837>>>                If bProgram Begin
9839>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9840>>>                    If not hoCommandBars Begin
9842>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9845>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9848>>>                    End
9848>>>>
9848>>>                End
9848>>>>
9848>>>                
9848>>>                Send CloseKey of hoRegistry
9849>>>            End
9849>>>>
9849>>>            
9849>>>            Send Destroy of hoRegistry
9850>>>        End
9850>>>>
9850>>>    End_Procedure
9851>>>    
9851>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9853>>>// not used with webapp
9853>>>        Handle hoRegistry
9853>>>        Integer iError
9853>>>        tWinWindowPlacement WindowPlacement
9853>>>        tWinWindowPlacement WindowPlacement
9853>>>        String sKey
9853>>>        Boolean bSuccess
9853>>>        Integer eShowCmd
9853>>>        String sObjectName
9853>>>        
9853>>>        If (pbPreserveEnvironment(Self)) Begin
9855>>>            Get Create U_cRegistry to hoRegistry
9856>>>            Get RegistryKeyString to sKey
9857>>>            
9857>>>            If (bProgram = False) Begin
9859>>>                Move (sKey +"\WINDOWS") to sKey
9860>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9861>>>                Move (sKey +"\" +sObjectName) to sKey
9862>>>            End
9862>>>>
9862>>>            Else ;                Move (sKey +"\Preferences") to sKey
9864>>>            
9864>>>            Get CreateKey of hoRegistry sKey to iError
9865>>>            If (iError = 0) Begin
9867>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9868>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9869>>>                If bSuccess Begin
9871>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9871>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9873>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9874>>>                    End
9874>>>>
9874>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9875>>>                End
9875>>>>
9875>>>                
9875>>>                If bProgram Begin
9877>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9878>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9879>>>                End
9879>>>>
9879>>>                
9879>>>                
9879>>>                Send CloseKey of hoRegistry
9880>>>            End
9880>>>>
9880>>>            
9880>>>            Send Destroy of hoRegistry
9881>>>        End
9881>>>>
9881>>>    End_Procedure
9882>>>    
9882>>>    
9882>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9884>>>        Integer ixySize ixSize iySize
9884>>>        Integer ixOffset iyOffset
9884>>>        
9884>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9884>>>        Move (0 - WindowPos.left) to ixOffset
9885>>>        Move (0 - WindowPos.top) to iyOffset
9886>>>        
9886>>>        Move 0 to WindowPos.left
9887>>>        Move 0 to WindowPos.top
9888>>>        
9888>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9889>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9890>>>        
9890>>>        // also make sure that the size of the window is <= the size of the main monitor
9890>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9891>>>        Move (low(ixySize))      to ixSize
9892>>>        Move (hi(ixySize))       to iySize
9893>>>        
9893>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9894>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9895>>>    End_Procedure
9896>>>    
9896>>>    
9896>>>    Function RegistryKeyString Returns String
9898>>>        String sCompany sProduct sVersion sProgram
9898>>>        
9898>>>        Get psCompany to sCompany
9899>>>        Get psProduct to sProduct
9900>>>        Get psVersion to sVersion
9901>>>        Get psProgram to sProgram
9902>>>        
9902>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9905>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9908>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
9911>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
9914>>>        
9914>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
9915>>>    End_Function
9916>>>    
9916>>>    Procedure WriteString String sSubKey String sValueName String sValueData
9918>>>        String sKey
9918>>>        Handle hoRegistry
9918>>>        Integer iError
9918>>>        
9918>>>        Get Create U_cRegistry to hoRegistry
9919>>>        Get RegistryKeyString to sKey
9920>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9923>>>        Get CreateKey of hoRegistry sKey to iError
9924>>>        If (iError = 0) Begin
9926>>>            Send WriteString of hoRegistry sValueName sValueData
9927>>>            Send CloseKey of hoRegistry
9928>>>        End
9928>>>>
9928>>>        
9928>>>        Send Destroy of hoRegistry
9929>>>    End_Procedure
9930>>>    
9930>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
9932>>>        String sKey
9932>>>        Handle hoRegistry
9932>>>        Integer iError
9932>>>        
9932>>>        Get Create U_cRegistry to hoRegistry
9933>>>        Get RegistryKeyString to sKey
9934>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9937>>>        Get CreateKey of hoRegistry sKey to iError
9938>>>        If (iError = 0) Begin
9940>>>            Send WriteInteger of hoRegistry sValueName iValueData
9941>>>            Send CloseKey of hoRegistry
9942>>>        End
9942>>>>
9942>>>        
9942>>>        Send Destroy of hoRegistry
9943>>>    End_Procedure
9944>>>    
9944>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9944>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
9946>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
9947>>>    End_Procedure
9948>>>    
9948>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
9950>>>        String sKey
9950>>>        Handle hoRegistry
9950>>>        Integer iError
9950>>>        
9950>>>        Get Create U_cRegistry to hoRegistry
9951>>>        Get RegistryKeyString to sKey
9952>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9955>>>        Get CreateKey of hoRegistry sKey to iError
9956>>>        If (iError = 0) Begin
9958>>>            Send WriteUInt of hoRegistry sValueName uValueData
9959>>>            Send CloseKey of hoRegistry
9960>>>        End
9960>>>>
9960>>>        
9960>>>        Send Destroy of hoRegistry
9961>>>    End_Procedure
9962>>>
9962>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
9964>>>        String sKey
9964>>>        Handle hoRegistry
9964>>>        Integer iError
9964>>>        
9964>>>        Get Create U_cRegistry to hoRegistry
9965>>>        Get RegistryKeyString to sKey
9966>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9969>>>        Get CreateKey of hoRegistry sKey to iError
9970>>>        If (iError = 0) Begin
9972>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
9973>>>            Send CloseKey of hoRegistry
9974>>>        End
9974>>>>
9974>>>        
9974>>>        Send Destroy of hoRegistry
9975>>>    End_Procedure
9976>>>    
9976>>>    // returns true if both sub-key and value exists.
9976>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
9978>>>        String sKey
9978>>>        Handle hoRegistry
9978>>>        Boolean bOK
9978>>>        Get Create U_cRegistry to hoRegistry
9979>>>        Get RegistryKeyString to sKey
9980>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9983>>>        Get OpenKey of hoRegistry sKey to bOk
9984>>>        If (bOK) Begin
9986>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
9987>>>            Send CloseKey of hoRegistry
9988>>>        End
9988>>>>
9988>>>        Send Destroy of hoRegistry
9989>>>        Function_Return bOk
9990>>>    End_Function
9991>>>    
9991>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
9993>>>        String sKey sData
9993>>>        Handle hoRegistry
9993>>>        Boolean bOK
9993>>>        
9993>>>        Move sDefault to sData
9994>>>        Get Create U_cRegistry to hoRegistry
9995>>>        Get RegistryKeyString to sKey
9996>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9999>>>        Get OpenKey of hoRegistry sKey to bOk
10000>>>        If (bOK) Begin
10002>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
10005>>>            Send CloseKey of hoRegistry
10006>>>        End
10006>>>>
10006>>>        
10006>>>        Send Destroy of hoRegistry
10007>>>        Function_Return sData
10008>>>    End_Function
10009>>>    
10009>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
10011>>>        String sKey
10011>>>        Integer iData
10011>>>        Handle hoRegistry
10011>>>        Boolean bOK
10011>>>        
10011>>>        Move iDefault to iData
10012>>>        Get Create U_cRegistry to hoRegistry
10013>>>        Get RegistryKeyString to sKey
10014>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10017>>>        Get OpenKey of hoRegistry sKey to bOk
10018>>>        If bOK Begin
10020>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
10023>>>            Send CloseKey of hoRegistry
10024>>>        End
10024>>>>
10024>>>        
10024>>>        Send Destroy of hoRegistry
10025>>>        Function_Return iData
10026>>>    End_Function
10027>>>
10027>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
10027>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
10029>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
10030>>>    End_Function
10031>>>    
10031>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
10033>>>        String sKey
10033>>>        UInteger uData
10033>>>        Handle hoRegistry
10033>>>        Boolean bOK
10033>>>        
10033>>>        Move uDefault to uData
10034>>>        Get Create U_cRegistry to hoRegistry
10035>>>        Get RegistryKeyString to sKey
10036>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10039>>>        Get OpenKey of hoRegistry sKey to bOk
10040>>>        If bOK Begin
10042>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
10045>>>            Send CloseKey of hoRegistry
10046>>>        End
10046>>>>
10046>>>        
10046>>>        Send Destroy of hoRegistry
10047>>>        Function_Return uData
10048>>>    End_Function
10049>>>    
10049>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
10051>>>        String sKey
10051>>>        Handle hoRegistry
10051>>>        Boolean bOK bSuccess
10051>>>        
10051>>>        Get Create U_cRegistry to hoRegistry
10052>>>        Get RegistryKeyString to sKey
10053>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10056>>>        Get OpenKey of hoRegistry sKey to bOk
10057>>>        If bOK Begin
10059>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
10060>>>            Send CloseKey of hoRegistry
10061>>>        End
10061>>>>
10061>>>        
10061>>>        Send Destroy of hoRegistry
10062>>>        Function_Return bSuccess
10063>>>    End_Function
10064>>>    
10064>>>    Procedure DoOpenWorkspace String sWorkspace
10066>>>        // Tries to open in this order:
10066>>>        // 1) if absolute path, use that; otherwise
10066>>>        // 2) try to open in the path of the EXE; otherwise
10066>>>        // 3) load it via the Registered list
10066>>>        
10066>>>        Integer eOpened
10066>>>        String sError sWSFile
10066>>>        Handle hoWorkspace
10066>>>        Boolean bChangingWorkspace
10066>>>        
10066>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10066>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10066>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10066>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10066>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10066>>>        // that there should be no automatic opening of a worskpace.
10066>>>        Set psAutoOpenWorkspace to ""
10067>>>        
10067>>>        Get phoWorkspace to hoWorkspace
10068>>>        
10068>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10069>>>        If (bChangingWorkspace and ghoConnection) Begin
10071>>>            Send AutoDisconnect
10072>>>        End
10072>>>>
10072>>>        
10072>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10073>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10075>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10077>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10078>>>            End
10078>>>>
10078>>>        End
10078>>>>
10078>>>        If (eOpened <> wsWorkspaceOpened) Begin
10080>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10081>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10082>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10083>>>>
10083>>>            Abort
10084>>>>
10084>>>        End
10084>>>>
10084>>>        Else Begin
10085>>>            Send AutoConnect
10086>>>            Send OnWorkspaceOpened
10087>>>        End
10087>>>>
10087>>>    End_Procedure
10088>>>    
10088>>>    Procedure AutoConnect
10090>>>        If (ghoConnection) Begin
10092>>>            Send AutoConnect of ghoConnection
10093>>>        End
10093>>>>
10093>>>    End_Procedure
10094>>>    
10094>>>    Procedure AutoDisconnect
10096>>>        If (ghoConnection) Begin
10098>>>            Send AutoDisconnect of ghoConnection
10099>>>        End
10099>>>>
10099>>>    End_Procedure
10100>>>    
10100>>>    // send after a workspace is successfully opened and connected
10100>>>    Procedure OnWorkspaceOpened
10102>>>    End_Procedure
10103>>>    
10103>>>    Procedure OnCreate
10105>>>        // Event called when the Application object is ready to be used
10105>>>        // to open a Workspace, etc.
10105>>>    End_Procedure
10106>>>    
10106>>>    Procedure End_Construct_Object
10108>>>        String sName
10108>>>        Forward Send End_Construct_Object
10110>>>        Send OnCreate
10111>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10111>>>        Get psAutoOpenWorkspace to sName
10112>>>        If (sName<>"") Begin
10114>>>            Send DoOpenWorkspace sName
10115>>>        End
10115>>>>
10115>>>    End_Procedure
10116>>>    
10116>>>    Function GetApplicationFileName Returns String
10118>>>        // Returns the filename from Windows
10118>>>        Integer iNumChars
10118>>>        WString wFilename
10118>>>                
10118>>>        Move (Repeat(Character(0), 1024)) to wFilename
10119>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10120>>>        
10120>>>        Function_Return (CString(wFilename))
10121>>>    End_Function
10122>>>    
10122>>>    Function GetApplicationPath Returns String
10124>>>        // Returns the path of the Application (no trailing "\")
10124>>>        WString wApplicationFileName 
10124>>>        String sPath
10124>>>        Boolean bRemoved
10124>>>        
10124>>>        Get GetApplicationFileName  to wApplicationFileName
10125>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10126>>>        Move (CString(wApplicationFileName)) to sPath
10127>>>        
10127>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10130>>>        Function_Return sPath
10131>>>    End_Function
10132>>>    
10132>>>    Function GetApplicationName Returns String
10134>>>        // Returns the name of the Application (without its Path or Extension)
10134>>>        String sApplicationFileName 
10134>>>        WString wApplicationName
10134>>>        Boolean bRemoved
10134>>>        Integer iVoid
10134>>>        
10134>>>        Get GetApplicationFileName to sApplicationFileName
10135>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10136>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10137>>>        Function_Return (CString(wApplicationName))
10138>>>    End_Function
10139>>>    
10139>>>    Function DFRootPath Returns String
10141>>>        String sRoot
10141>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10144>>>        // Ensure it does not contain a trailing "\"
10144>>>        If (Right(sRoot,1) = "\") Begin
10146>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10147>>>        End
10147>>>>
10147>>>        Function_Return sRoot
10148>>>    End_Function
10149>>>    
10149>>>    Function DFBinPath Returns String
10151>>>        String sRoot
10151>>>        Get DFRootPath to sRoot
10152>>>        If (sRoot<>"") Begin
10154>>>            Move (sRoot+"\bin") to sRoot
10155>>>        End
10155>>>>
10155>>>        Else Begin
10156>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10156>>>            // bin path must be the same as the application path.
10156>>>            Get GetApplicationPath to sRoot
10157>>>        End
10157>>>>
10157>>>        Function_Return sRoot
10158>>>    End_Function
10159>>>    
10159>>>    // this just directs to the desktop property. If you are using an application object you are
10159>>>    // encouraged to set this here.
10159>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10161>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10162>>>    End_Procedure
10163>>>    
10163>>>    Function pbUseWindowsFont Returns Boolean
10165>>>        Boolean bUseWindowsFont
10165>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10166>>>        Function_Return bUseWindowsFont
10167>>>    End_Function
10168>>>    
10168>>>    // this just directs to the desktop property. If you are using an application object you are
10168>>>    // encouraged to set this here.
10168>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10170>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10171>>>    End_Procedure
10172>>>    
10172>>>    Function pbLegacyDialogRatio Returns Boolean
10174>>>        Boolean bLegacy
10174>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10175>>>        Function_Return bLegacy
10176>>>    End_Function
10177>>>End_Class
10178>>>
10178>>>
10178>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
10178>>>//****************************************************************************
10178>>>// $Module type: Class
10178>>>// $Module name: cDbUpdateHandler
10178>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
10178>>>// Web-site    : http://www.rdctools.com
10178>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
10178>>>//
10178>>>// Purpose     : A framework for doing automated code based updates of a database from within
10178>>>//               a program, when it is started.
10178>>>//
10178>>>// Description : Place _one_ object of this class right after the cApplication object.
10178>>>//               Then inside this object place a series of cDbUpdateVersion objects
10178>>>//               as childs. One child object for each new database update.
10178>>>//
10178>>>//               - OnPreUpdate is a pre-processing event called
10178>>>//               before any database changes are started.
10178>>>//               - OnPostUpdate is a post-processing event called after all
10178>>>//               database changes have taken place.
10178>>>//
10178>>>// Note        : If tables have been opened prior to an object of this class
10178>>>//               (e.g. in the cApplication object), those tables will be closed.
10178>>>//               In that case you need to use the OnPostUpdate hook event to re-open
10178>>>//               tables after the last update has finished.
10178>>>//
10178>>>// Security    : Before an update is attempted; three things are checked to ensure the
10178>>>//               database is not in use. Aka nobody else is running the application.
10178>>>//               - All tables are tested for "Open in Exclusive_Mode"
10178>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
10178>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
10178>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
10178>>>//                 folder and a bit-lock is performed for each start of the application and this
10178>>>//                 user counter is checked before an update is attempted.
10178>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
10178>>>//                            against the database being "in use", there is no such guarantee! The
10178>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
10178>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
10178>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
10178>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
10178>>>//                 automatically be released after the update is completed.
10178>>>//
10178>>>//
10178>>>// Usage       :  Use cDbUpdateHandler.pkg
10178>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
10178>>>//                    // Declare the table that contains a "database version" field.
10178>>>//                    Declare_Datafile Sys
10178>>>//                    // Either one of these syntaxes is fine:
10178>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
10178>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
10178>>>//
10178>>>//                    // Don't forget to increase the pnVersionNumber property for each
10178>>>//                    // cDbUpdateVersion object!
10178>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
10178>>>//                    // with the value of pnVersionNumber after each update has been finished.
10178>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
10178>>>//                        Set pnVersionNumber to 1.1
10178>>>//                        Use VersionUpdate1_1.pkg
10178>>>//                    End_Object
10178>>>//
10178>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
10178>>>//                        Set pnVersionNumber to 1.2
10178>>>//                        Use VersionUpdate1_2.pkg
10178>>>//                    End_Object
10178>>>//
10178>>>//                End_Object
10178>>>//
10178>>>//
10178>>>// $Rev History:
10178>>>//    2016-09-27  Module header created
10178>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
10178>>>//                take place before any tables have been opened, or errors
10178>>>//                could occur if the client database is out of sync with the
10178>>>//                compiled program.
10178>>>//                Added user counting checks + lockout while database is being
10178>>>//                updated.
10178>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
10178>>>//                as it is more in line with the child class cDbUpdateVersion name.
10178>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
10178>>>//****************************************************************************
10178>>>Use VdfBase.pkg
10178>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dferror.pkg)
10178>>>>>Use cWindowsErrorHandler.pkg
Including file: cWindowsErrorHandler.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWindowsErrorHandler.pkg)
10178>>>>>>>Use cBaseErrorHandler.pkg
Including file: cBaseErrorHandler.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cBaseErrorHandler.pkg)
10178>>>>>>>>>Use errornum.inc
10178>>>>>>>>>Use cTrappedErrors.pkg
Including file: cTrappedErrors.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cTrappedErrors.pkg)
10178>>>>>>>>>>>Define MAX_ERROR_NUMBER for 32766
10178>>>>>>>>>>>
10178>>>>>>>>>>>// This array stores the set of trapped errors as toggled ranges starting
10178>>>>>>>>>>>// with the errors that are trapped. The array should always contain 0 and
10178>>>>>>>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10178>>>>>>>>>>>// following items...
10178>>>>>>>>>>>//
10178>>>>>>>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10178>>>>>>>>>>>//
10178>>>>>>>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10178>>>>>>>>>>>// 10 through the rest are trapped.
10178>>>>>>>>>>>//
10178>>>>>>>>>>>Class cTrappedErrors is an array
10179>>>>>>>>>>>    Procedure Construct_Object
10181>>>>>>>>>>>        Forward Send Construct_Object
10183>>>>>>>>>>>        
10183>>>>>>>>>>>        Send initArray
10184>>>>>>>>>>>    End_Procedure
10185>>>>>>>>>>>    
10185>>>>>>>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10185>>>>>>>>>>>    Function findErrorLE Integer targetError Returns Integer
10187>>>>>>>>>>>        
10187>>>>>>>>>>>        Integer lowIndex hiIndex midIndex currError
10187>>>>>>>>>>>        
10187>>>>>>>>>>>        // If error is outside of boudary conditions, use
10187>>>>>>>>>>>        // value of closest valid error# instead.
10187>>>>>>>>>>>        If (targetError <= 0);            Move 1 to targetError
10190>>>>>>>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10194>>>>>>>>>>>        
10194>>>>>>>>>>>        Move 0 to lowIndex
10195>>>>>>>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10196>>>>>>>>>>>        
10196>>>>>>>>>>>        // midIndex will contain the closest error LE to target upon exit.
10196>>>>>>>>>>>        Repeat
10196>>>>>>>>>>>>
10196>>>>>>>>>>>            
10196>>>>>>>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10197>>>>>>>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10198>>>>>>>>>>>            
10198>>>>>>>>>>>            // midIndex is targetIndex if a match occurs
10198>>>>>>>>>>>            If (currError = targetError) ;                Function_Return midIndex
10201>>>>>>>>>>>            
10201>>>>>>>>>>>            // We are either on it or just below it.
10201>>>>>>>>>>>            If ( lowIndex = midIndex ) Begin
10203>>>>>>>>>>>                
10203>>>>>>>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
10206>>>>>>>>>>>                
10206>>>>>>>>>>>                Function_Return midIndex
10207>>>>>>>>>>>                
10207>>>>>>>>>>>            End
10207>>>>>>>>>>>>
10207>>>>>>>>>>>            
10207>>>>>>>>>>>            // No match, so move the boundaries.
10207>>>>>>>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10210>>>>>>>>>>>            Else ;                Move midIndex to lowIndex
10212>>>>>>>>>>>            
10212>>>>>>>>>>>        Until lowIndex gt hiIndex
10214>>>>>>>>>>>        
10214>>>>>>>>>>>        Function_Return midIndex
10215>>>>>>>>>>>        
10215>>>>>>>>>>>    End_Function
10216>>>>>>>>>>>    
10216>>>>>>>>>>>    // Boundaries of the table are assumed to hold error limits.
10216>>>>>>>>>>>    Procedure initArray
10218>>>>>>>>>>>        Send delete_data
10219>>>>>>>>>>>        Set array_value  0 to 0
10220>>>>>>>>>>>        Set array_value  1 to ( MAX_ERROR_NUMBER + 1 )
10221>>>>>>>>>>>    End_Procedure
10222>>>>>>>>>>>    
10222>>>>>>>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10222>>>>>>>>>>>    Function IsTrapped Integer Error# Returns Integer
10224>>>>>>>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10225>>>>>>>>>>>    End_Function
10226>>>>>>>>>>>    
10226>>>>>>>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10226>>>>>>>>>>>    // This routine leaves the array unsorted.
10226>>>>>>>>>>>    Procedure addError Integer Error#
10228>>>>>>>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value  ( item_count( Self ) ) to ( Integer( Error# ) )
10231>>>>>>>>>>>    End_Procedure
10232>>>>>>>>>>>    
10232>>>>>>>>>>>    // Set error to flagged state.
10232>>>>>>>>>>>    Procedure handleError Integer Error# Integer trapFlag
10234>>>>>>>>>>>        
10234>>>>>>>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10234>>>>>>>>>>>        
10234>>>>>>>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
10236>>>>>>>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10237>>>>>>>>>>>>
10237>>>>>>>>>>>            Procedure_Return
10238>>>>>>>>>>>        End
10238>>>>>>>>>>>>
10238>>>>>>>>>>>        
10238>>>>>>>>>>>        Get findErrorLE Error# to prevErrIndex
10239>>>>>>>>>>>        Get isTrapped   Error# to prevErrFlag
10240>>>>>>>>>>>        
10240>>>>>>>>>>>        // if eq, Error already handled in some range.
10240>>>>>>>>>>>        If (PrevErrFlag <> trapFlag) Begin
10242>>>>>>>>>>>            
10242>>>>>>>>>>>            // This is kind of complicated. If we are adding an error,
10242>>>>>>>>>>>            // we have to account for the error already being in the
10242>>>>>>>>>>>            // array as well as rejoining ranges that have been previously
10242>>>>>>>>>>>            // split and splitting ranges when adding a new flag.
10242>>>>>>>>>>>            
10242>>>>>>>>>>>            Get integer_value  ( prevErrIndex + 1 ) to nextErrValue
10243>>>>>>>>>>>            Get integer_value  prevErrIndex         to prevErrValue
10244>>>>>>>>>>>            
10244>>>>>>>>>>>            // Do this first so prevErrIndex stays valid.
10244>>>>>>>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10247>>>>>>>>>>>            Else ;                Send addError ( Error# + 1 )
10249>>>>>>>>>>>            
10249>>>>>>>>>>>            If ( prevErrValue < Error# ) ;                Send addError Error#
10252>>>>>>>>>>>            Else ;                Send delete_item prevErrIndex
10254>>>>>>>>>>>        End
10254>>>>>>>>>>>>
10254>>>>>>>>>>>        Send sort_items UPWARD_DIRECTION
10255>>>>>>>>>>>        
10255>>>>>>>>>>>    End_Procedure
10256>>>>>>>>>>>    
10256>>>>>>>>>>>    // Flag error as trappable
10256>>>>>>>>>>>    Procedure Trap_Error Integer Error#
10258>>>>>>>>>>>        Send handleError Error# 1
10259>>>>>>>>>>>    End_Procedure
10260>>>>>>>>>>>    
10260>>>>>>>>>>>    // Flag error as non-trappable
10260>>>>>>>>>>>    Procedure Ignore_Error Integer Error#
10262>>>>>>>>>>>        Send handleError Error# 0
10263>>>>>>>>>>>    End_Procedure
10264>>>>>>>>>>>    
10264>>>>>>>>>>>    // Flag all errors as trappable
10264>>>>>>>>>>>    Procedure Trap_All
10266>>>>>>>>>>>        Send initArray
10267>>>>>>>>>>>    End_Procedure
10268>>>>>>>>>>>    
10268>>>>>>>>>>>    // Flag all errors as non-trappable
10268>>>>>>>>>>>    Procedure Ignore_All
10270>>>>>>>>>>>        Send delete_data
10271>>>>>>>>>>>        Set array_value 0 to 0
10272>>>>>>>>>>>        Set array_value 1 to 1
10273>>>>>>>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10274>>>>>>>>>>>    End_Procedure
10275>>>>>>>>>>>End_Class
10276>>>>>>>>>>>
10276>>>>>>>>>Use LanguageText.pkg
10276>>>>>>>>>Use VdfBase.pkg
10276>>>>>>>>>
10276>>>>>>>>>// used by error handler and UserError to pull a caption out of the error string
10276>>>>>>>>>Define C_ErrorCaption for "*CAPTION*="
10276>>>>>>>>>
10276>>>>>>>>>Class cBaseErrorHandler is a cObject
10277>>>>>>>>>    Procedure Construct_Object
10279>>>>>>>>>        Forward Send Construct_Object
10281>>>>>>>>>        
10281>>>>>>>>>        Set delegation_mode to no_delegate_or_error
10282>>>>>>>>>        
10282>>>>>>>>>        // This is the caption that appears for unhandled errors dialog box
10282>>>>>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10283>>>>>>>>>        
10283>>>>>>>>>        // This is the caption that appears for standard user errors
10283>>>>>>>>>        Property String psUserErrorCaption C_$Error
10284>>>>>>>>>        
10284>>>>>>>>>        // If set false, this makes the error handler work the old way which
10284>>>>>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10284>>>>>>>>>        Property Boolean pbUnhandledErrorSupport       True
10285>>>>>>>>>        
10285>>>>>>>>>        Property Boolean pbErrorProcessingState False  // Flag which is sent when error is being processed. This stops error recursion.
10286>>>>>>>>>        
10286>>>>>>>>>        Property Integer piCurrentErrorNumber     0
10287>>>>>>>>>        Property Integer piCurrentErrorLine        0
10288>>>>>>>>>        
10288>>>>>>>>>        Property Integer[] paUserErrors       // Collection of sorted error numbers considered to be user errors. (note, this array must remain sorted!)
10289>>>>>>>>>        
10289>>>>>>>>>        
10289>>>>>>>>>        Object oTrappedErrors is a cTrappedErrors
10291>>>>>>>>>        End_Object
10292>>>>>>>>>        
10292>>>>>>>>>        Send DefineStandardUserErrors
10293>>>>>>>>>        
10293>>>>>>>>>        Move Self to Error_Object_Id
10294>>>>>>>>>        Move Self to ghoErrorHandler
10295>>>>>>>>>    End_Procedure
10296>>>>>>>>>    
10296>>>>>>>>>    Procedure DefineStandardUserErrors
10298>>>>>>>>>        Integer[] aUserErrors
10299>>>>>>>>>        
10299>>>>>>>>>        // define the standard user error numbers....
10299>>>>>>>>>        Move 0                                     to aUserErrors[0]
10300>>>>>>>>>        Move DFERR_NUMBER_TOO_LARGE                to aUserErrors[1]
10301>>>>>>>>>        Move DFERR_WINDOW_RANGE                    to aUserErrors[2]
10302>>>>>>>>>        Move DFERR_ENTRY_REQUIRED                  to aUserErrors[3]
10303>>>>>>>>>        Move DFERR_ENTER_A_NUMBER                  to aUserErrors[4]
10304>>>>>>>>>        Move DFERR_BAD_ENTRY                       to aUserErrors[5]
10305>>>>>>>>>        Move DFERR_ENTER_VALID_DATE                to aUserErrors[6]
10306>>>>>>>>>        Move DFERR_NUMERIC_RANGE                   to aUserErrors[7]
10307>>>>>>>>>        Move DFERR_DUPLICATE_REC                   to aUserErrors[8]
10308>>>>>>>>>        Move DFERR_TEXT_FIELD_TOO_LONG             to aUserErrors[9]
10309>>>>>>>>>        Move DFERR_FIND_PRIOR_BEG_OF_FILE          to aUserErrors[10]
10310>>>>>>>>>        Move DFERR_FIND_PAST_END_OF_FILE           to aUserErrors[11]
10311>>>>>>>>>        Move DFERR_NO_REC_TO_DELETE                to aUserErrors[12]
10312>>>>>>>>>        Move DFERR_FIELD_NOT_INDEXED               to aUserErrors[13]
10313>>>>>>>>>        Move DFERR_REC_NUMBER_RANGE                to aUserErrors[14]
10314>>>>>>>>>        Move DFERR_ENTER_VALID_REC_ID              to aUserErrors[15]
10315>>>>>>>>>        Move DFERR_OPERATOR_ERROR                  to aUserErrors[16]
10316>>>>>>>>>        Move DFERR_CANT_CHANGE_KEY_FIELD           to aUserErrors[17]
10317>>>>>>>>>        Move DFERR_NO_DELETE_RELATED_RECORDS_EXIST to aUserErrors[18]
10318>>>>>>>>>        Move DFERR_OPERATION_NOT_ALLOWED           to aUserErrors[19]
10319>>>>>>>>>        Move DFERR_OPERATOR                        to aUserErrors[20]
10320>>>>>>>>>        Move DFERR_XML_HTTP                        to aUserErrors[21]
10321>>>>>>>>>        Move DFERR_CLIENT_SOAP_TRANSFER            to aUserErrors[22]
10322>>>>>>>>>        Move DFERR_CLIENT_SOAP_FAULT               to aUserErrors[23]
10323>>>>>>>>>        Move DFERR_TEXT_TOO_LARGE_FOR_FIELD        to aUserErrors[24]
10324>>>>>>>>>        Move DFERR_WINPRINT                        to aUserErrors[25]
10325>>>>>>>>>        Move DFERR_CRYSTAL_REPORT                  to aUserErrors[26]
10326>>>>>>>>>        Move DFERR_MAPI                            to aUserErrors[27]
10327>>>>>>>>>        Move DFERR_FILE_ACCESS_VIOLATION           to aUserErrors[28]
10328>>>>>>>>>        Move DFERR_DATAFLEX_REPORTS                to aUserErrors[29]
10329>>>>>>>>>        Move DFERR_CANT_REFIND_RECORD              to aUserErrors[30]
10330>>>>>>>>>        // WebApp Errors
10330>>>>>>>>>        Move DFERR_WEBAPP_ACCESS_DENIED            to aUserErrors[31]
10331>>>>>>>>>        // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error number of DDs.
10331>>>>>>>>>        Move 999                                   to aUserErrors[32]
10332>>>>>>>>>        // This is session timeout (we keep the old number 950 for backwards comatibility reasons)
10332>>>>>>>>>        Move DFERR_WEBAPP_SESSION_TIMEOUT          to aUserErrors[33]
10333>>>>>>>>>        // This is session timeout (we keep the old number 951 for backwards comatibility reasons)
10333>>>>>>>>>        Move DFERR_WEBAPP_BAD_SESSION_KEY          to aUserErrors[34]
10334>>>>>>>>>        Move DFERR_WEBAPP_INVALID_URL              to aUserErrors[35]
10335>>>>>>>>>        Move DFERR_WEBAPP_INVALID_URL_REC          to aUserErrors[36]
10336>>>>>>>>>        Move (SortArray(aUserErrors)) to aUserErrors
10337>>>>>>>>>        Set paUserErrors to aUserErrors
10338>>>>>>>>>    End_Procedure
10339>>>>>>>>>    
10339>>>>>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
10341>>>>>>>>>        //  Stub method implemented by subclass
10341>>>>>>>>>    End_Procedure
10342>>>>>>>>>    
10342>>>>>>>>>    // Called by the runtime when an error occurs. Initiates the main error handling. Skips errors
10342>>>>>>>>>    // that are ignored and makes sure to prevent recursion by checking the error processing state.
10342>>>>>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrText
10344>>>>>>>>>        If (pbErrorProcessingState(Self)) ;            Procedure_Return
10347>>>>>>>>>            
10347>>>>>>>>>        If (not(IsTrapped(Self, iErrNum))) ;            Procedure_Return
10350>>>>>>>>>        
10350>>>>>>>>>        Set pbErrorProcessingState to True
10351>>>>>>>>>        Set piCurrentErrorNumber to iErrNum
10352>>>>>>>>>        Set piCurrentErrorLine to iErrLine
10353>>>>>>>>>        
10353>>>>>>>>>        Send HandleError iErrNum iErrLine sErrText
10354>>>>>>>>>        
10354>>>>>>>>>        Set piCurrentErrorNumber to 0
10355>>>>>>>>>        Set piCurrentErrorLine to 0
10356>>>>>>>>>        Move 0 to ghoErrorSource
10357>>>>>>>>>        Set pbErrorProcessingState to False
10358>>>>>>>>>    End_Procedure
10359>>>>>>>>>    
10359>>>>>>>>>    
10359>>>>>>>>>
10359>>>>>>>>>    
10359>>>>>>>>>    // Returns true if this is a user error (i.e. "find past end of file")
10359>>>>>>>>>    Function IsUserError Integer iError Returns Boolean
10361>>>>>>>>>        Integer[] aUserErrors
10362>>>>>>>>>        Get paUserErrors to aUserErrors
10363>>>>>>>>>        Function_Return (BinarySearchArray(iError, aUserErrors) <> -1)
10364>>>>>>>>>    End_Function
10365>>>>>>>>>    
10365>>>>>>>>>        // returns true if this is an unhandled error (i.e., not a user error
10365>>>>>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10367>>>>>>>>>        Integer[] UserErrors
10368>>>>>>>>>        Get paUserErrors to UserErrors
10369>>>>>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10370>>>>>>>>>    End_Function
10371>>>>>>>>>    
10371>>>>>>>>>    Procedure AddUserError Integer iError
10373>>>>>>>>>        // adds a user error to the collection of defined 'user errors'
10373>>>>>>>>>        Integer[] aUserErrors
10374>>>>>>>>>        Get paUserErrors to aUserErrors
10375>>>>>>>>>        
10375>>>>>>>>>        If (BinarySearchArray(iError, aUserErrors) = -1) Begin
10377>>>>>>>>>            Move (InsertInArray(aUserErrors, BinarySearchInsertPos(), iError)) to aUserErrors         // Keep the array sorted. Makes searching fast, adding slower.
10378>>>>>>>>>            Set paUserErrors to aUserErrors
10379>>>>>>>>>        End
10379>>>>>>>>>>
10379>>>>>>>>>    End_Procedure
10380>>>>>>>>>    
10380>>>>>>>>>    Procedure RemoveUserError Integer iError
10382>>>>>>>>>        // Removes the passed error number from the set of user errors.
10382>>>>>>>>>        Integer iIndex
10382>>>>>>>>>        Integer[] aUserErrors
10383>>>>>>>>>        
10383>>>>>>>>>        Get paUserErrors to aUserErrors
10384>>>>>>>>>        Move (BinarySearchArray(iError, aUserErrors)) to iIndex
10385>>>>>>>>>        
10385>>>>>>>>>        If (iIndex <> -1) Begin
10387>>>>>>>>>            Move (RemoveFromArray(aUserErrors, iIndex)) to aUserErrors
10388>>>>>>>>>            Set paUserErrors to aUserErrors
10389>>>>>>>>>        End
10389>>>>>>>>>>
10389>>>>>>>>>    End_Procedure
10390>>>>>>>>>    
10390>>>>>>>>>    Procedure RemoveAllUserErrors
10392>>>>>>>>>        // Clears set of User Errors
10392>>>>>>>>>        Set paUserErrors to (ResizeArray(paUserErrors(Self), 0))
10393>>>>>>>>>    End_Procedure
10394>>>>>>>>>    
10394>>>>>>>>>    // return true if an error number is critical
10394>>>>>>>>>    Function IsCritical Integer iError Returns Boolean
10396>>>>>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(iError)+"."))
10397>>>>>>>>>    End_Function
10398>>>>>>>>>    
10398>>>>>>>>>    Procedure TrapError Integer iError
10400>>>>>>>>>        Send Trap_Error of oTrappedErrors iError
10401>>>>>>>>>    End_Procedure
10402>>>>>>>>>    
10402>>>>>>>>>    Procedure IgnoreError Integer iError
10404>>>>>>>>>        Send Ignore_Error of oTrappedErrors iError
10405>>>>>>>>>    End_Procedure
10406>>>>>>>>>    
10406>>>>>>>>>    Procedure IgnoreAllErrors
10408>>>>>>>>>        Send Ignore_All of oTrappedErrors
10409>>>>>>>>>    End_Procedure
10410>>>>>>>>>    
10410>>>>>>>>>    Procedure TrapAllErrors
10412>>>>>>>>>        Send Trap_All of oTrappedErrors
10413>>>>>>>>>    End_Procedure
10414>>>>>>>>>    
10414>>>>>>>>>    Function IsTrapped Integer iError  Returns Boolean
10416>>>>>>>>>        Function_Return (IsTrapped(oTrappedErrors,iError))
10417>>>>>>>>>    End_Function
10418>>>>>>>>>    
10418>>>>>>>>>    
10418>>>>>>>>>
10418>>>>>>>>>    
10418>>>>>>>>>    // Used to fetch the default error description.
10418>>>>>>>>>    //
10418>>>>>>>>>    // iError   - Error number
10418>>>>>>>>>    // sMessage - Additional error message
10418>>>>>>>>>    // Returns  - Complete error message
10418>>>>>>>>>    Function ErrorDescription Integer iError String sMessage Returns String
10420>>>>>>>>>        String sDescription
10420>>>>>>>>>        Boolean bAvailable
10420>>>>>>>>>        
10420>>>>>>>>>        //  Fetch system error text
10420>>>>>>>>>        Get Error_Text of Desktop iError to sDescription
10421>>>>>>>>>        Get Error_Text_Available of Desktop iError to bAvailable
10422>>>>>>>>>        
10422>>>>>>>>>        //  Trim both messages
10422>>>>>>>>>        Move (Trim(sDescription)) to sDescription
10423>>>>>>>>>        Move (Trim(sMessage)) to sMessage
10424>>>>>>>>>        
10424>>>>>>>>>        //  Append message if needed
10424>>>>>>>>>        If (sMessage <> "") Begin
10426>>>>>>>>>            If (sDescription <> "" and bAvailable) Begin
10428>>>>>>>>>                Move (sDescription + " " + sMessage) to sDescription
10429>>>>>>>>>            End
10429>>>>>>>>>>
10429>>>>>>>>>            Else Begin
10430>>>>>>>>>                Move sMessage to sDescription
10431>>>>>>>>>            End
10431>>>>>>>>>>
10431>>>>>>>>>        End
10431>>>>>>>>>>
10431>>>>>>>>>        
10431>>>>>>>>>        Function_Return sDescription
10432>>>>>>>>>    End_Function
10433>>>>>>>>>    
10433>>>>>>>>>    // Legacy names here for backwards compatibility
10433>>>>>>>>>    Function Error_Description Integer iError String sMessage Returns String
10435>>>>>>>>>        Function_Return (ErrorDescription(Self, iError, sMessage))
10436>>>>>>>>>    End_Function
10437>>>>>>>>>    
10437>>>>>>>>>    
10437>>>>>>>>>    Function Error_processing_state Returns Boolean
10439>>>>>>>>>        Function_Return (pbErrorProcessingState(Self))
10440>>>>>>>>>    End_Function
10441>>>>>>>>>    
10441>>>>>>>>>    Function Current_Error_Number Returns Integer
10443>>>>>>>>>        Function_Return (piCurrentErrorNumber(Self))
10444>>>>>>>>>    End_Function
10445>>>>>>>>>    
10445>>>>>>>>>    Procedure Set Current_Error_Number Integer iErr
10447>>>>>>>>>        Set piCurrentErrorNumber to iErr
10448>>>>>>>>>    End_Procedure
10449>>>>>>>>>    
10449>>>>>>>>>    Function Error_Line_Number Returns Integer
10451>>>>>>>>>        Function_Return (piCurrentErrorLine(Self))
10452>>>>>>>>>    End_Function
10453>>>>>>>>>    
10453>>>>>>>>>    Procedure Set Error_Line_Number Integer iLine
10455>>>>>>>>>        Set piCurrentErrorLine to iLine
10456>>>>>>>>>    End_Procedure
10457>>>>>>>>>    
10457>>>>>>>>>    Procedure Trap_Error Integer iError
10459>>>>>>>>>        Send TrapError iError
10460>>>>>>>>>    End_Procedure
10461>>>>>>>>>    
10461>>>>>>>>>    Procedure Ignore_Error Integer iError
10463>>>>>>>>>        Send IgnoreError iError
10464>>>>>>>>>    End_Procedure
10465>>>>>>>>>    
10465>>>>>>>>>    Procedure Trap_All
10467>>>>>>>>>        Send TrapAllErrors
10468>>>>>>>>>    End_Procedure
10469>>>>>>>>>    
10469>>>>>>>>>    Procedure Ignore_All
10471>>>>>>>>>        Send IgnoreAllErrors
10472>>>>>>>>>    End_Procedure
10473>>>>>>>>>    
10473>>>>>>>>>    Function Is_Critical Integer iError Returns Boolean
10475>>>>>>>>>        Function_Return (IsCritical(Self, iError))
10476>>>>>>>>>    End_Function
10477>>>>>>>>>End_Class
10478>>>>>>>>>
10478>>>>>>>>>Procedure UserError Global String sMessage String sCaption
10480>>>>>>>>>    String sCapt
10480>>>>>>>>>    If (Error_Object_Id=0) Begin
10482>>>>>>>>>        Error DFERR_PROGRAM "No Error Handler"
10483>>>>>>>>>>
10483>>>>>>>>>        Procedure_Return
10484>>>>>>>>>    End
10484>>>>>>>>>>
10484>>>>>>>>>    
10484>>>>>>>>>    // Accept not passing a caption in which case the error handler's
10484>>>>>>>>>    // default caption. It had been the intention to require a caption ("" if none)
10484>>>>>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
10484>>>>>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
10484>>>>>>>>>    If (num_arguments>1) Begin
10486>>>>>>>>>        Move sCaption to sCapt
10487>>>>>>>>>    End
10487>>>>>>>>>>
10487>>>>>>>>>    
10487>>>>>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
10488>>>>>>>>>>
10488>>>>>>>>>End_Procedure
10489>>>>>>>Use Windows.pkg
10489>>>>>>>Use msgbox.pkg
10489>>>>>>>Use GlobalFunctionsProcedures.pkg
10489>>>>>>>
10489>>>>>>>Class cWindowsErrorHandler is a cBaseErrorHandler
10490>>>>>>>    Procedure Construct_Object
10492>>>>>>>        Forward Send Construct_Object
10494>>>>>>>        
10494>>>>>>>        
10494>>>>>>>        
10494>>>>>>>        // shows error numbers with user errors. Only set this true if your
10494>>>>>>>        // application has meaningful numbers that helps the end user. Note that
10494>>>>>>>        // unhandled errors always show numbers.
10494>>>>>>>        // this is ignored if pbUnhandledErrorSupport is false
10494>>>>>>>        Property Boolean pbShowErrorNumber        False
10495>>>>>>>        
10495>>>>>>>        //  This allows us to skip find errors (GT & LT) and to only
10495>>>>>>>        //  ring a bell when these occur.
10495>>>>>>>        //
10495>>>>>>>        Property Boolean pbBellOnFindErrorState True
10496>>>>>>>        
10496>>>>>>>        Property Integer pbVerboseState         True
10497>>>>>>>
10497>>>>>>>    End_Procedure
10498>>>>>>>    
10498>>>>>>>
10498>>>>>>>    
10498>>>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
10500>>>>>>>        String sCaption sCRLF
10500>>>>>>>        Move (Character(13)+Character(10)) to sCRLF
10501>>>>>>>        Get psUnhandledErrorCaption to sCaption
10502>>>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
10503>>>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
10504>>>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
10505>>>>>>>    End_Procedure
10506>>>>>>>    
10506>>>>>>>    // Handle error event, displaying error info to user.
10506>>>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
10508>>>>>>>        Integer iReply iIcon
10508>>>>>>>        String  sDescription sMess
10508>>>>>>>        String  sSource sCaption
10508>>>>>>>        Integer iSrcPos iSrc iTxtLen
10508>>>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
10508>>>>>>>        
10508>>>>>>>        
10508>>>>>>>        // if this is false, this will work old-style -- all errors go through message box
10508>>>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
10509>>>>>>>        
10509>>>>>>>        Get IsCritical iErrNum to bCritical
10510>>>>>>>        Get IsUnhandledError iErrNum to bIsUnhandled
10511>>>>>>>        
10511>>>>>>>        
10511>>>>>>>        //
10511>>>>>>>        //   Changes made so find errors don't report - just beep
10511>>>>>>>        //
10511>>>>>>>        If ( pbBellOnFindErrorState(Self) and ;             (iErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or iErrNum=DFERR_FIND_PAST_END_OF_FILE)) Begin
10513>>>>>>>            Send Bell
10514>>>>>>>        End
10514>>>>>>>>
10514>>>>>>>        Else Begin
10515>>>>>>>            
10515>>>>>>>            // See if source information is provided (Source = module.function). If so remove
10515>>>>>>>            // as detail. Must find last instance of this in string
10515>>>>>>>            Move (pos(C_ErrorContextSourceText,sErrText)) to iSrc
10516>>>>>>>            If (iSrc > 0) Begin
10518>>>>>>>                Move (iSrc-1) to iSrcPos
10519>>>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
10520>>>>>>>                Move sErrText to sSource
10521>>>>>>>                Repeat // this makes sure we find last instance of this
10521>>>>>>>>
10521>>>>>>>                    Move (Remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
10522>>>>>>>                    Move (Pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
10523>>>>>>>                    If (iSrc > 0) ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
10526>>>>>>>                Until (iSrc=0)
10528>>>>>>>                Move (Trim(Left(sErrText,iSrcPos))) to sErrText
10529>>>>>>>                If (Right(sErrText,1) = ',') ;                    Move (Left(sErrText,Length(sErrText) - 1)) to sErrText
10532>>>>>>>            End
10532>>>>>>>>
10532>>>>>>>            
10532>>>>>>>            // the caption normally used for handled user errors
10532>>>>>>>            Get psUserErrorCaption to sCaption
10533>>>>>>>            // if an operator error this may be a Procedure UserError situation where the
10533>>>>>>>            // caption is passed in the error text. If so, get the caption
10533>>>>>>>            If (iErrNum=DFERR_OPERATOR) Begin
10535>>>>>>>                Move (pos(C_ErrorCaption,sErrText)) to iSrc
10536>>>>>>>                If iSrc Begin
10538>>>>>>>                    Move (Length(C_ErrorCaption)) to  iTxtLen
10539>>>>>>>                    Move (Remove(sErrText, 1, iSrc-1 + iTxtLen )) to sCaption
10540>>>>>>>                    Move (Left(sErrText,iSrc-1)) to sErrText
10541>>>>>>>                End
10541>>>>>>>>
10541>>>>>>>            End
10541>>>>>>>>
10541>>>>>>>            
10541>>>>>>>            Get ErrorDescription iErrNum sErrText to sDescription
10542>>>>>>>            
10542>>>>>>>            // if the error source is identified we can get extended error
10542>>>>>>>            // text for our error message
10542>>>>>>>            If (ghoErrorSource > 0) Begin
10544>>>>>>>                Get extended_error_Message of ghoErrorSource to sMess
10545>>>>>>>                If (sMess <> '') ;                    Move (sDescription + "\n\n" + sMess ) to sDescription
10548>>>>>>>            End
10548>>>>>>>>
10548>>>>>>>            
10548>>>>>>>            If (bUnhandledSupport) Begin
10550>>>>>>>                // as of 14.1, this is the preferred way to do errors
10550>>>>>>>                If (bCritical or bIsUnhandled) Begin
10552>>>>>>>                    Move ( sDescription + "\n\n" + C_$Error + ":" * String(iErrNum) ) to sDescription
10553>>>>>>>                    If (sSource <> "") Begin
10555>>>>>>>                        Move (sDescription + "\n" + C_$ErrorSource +" =" * sSource) to sDescription
10556>>>>>>>                    End
10556>>>>>>>>
10556>>>>>>>                End
10556>>>>>>>>
10556>>>>>>>                Else If (pbShowErrorNumber(Self)) Begin
10559>>>>>>>                    // if a user error, we provide a way to see error numbers.
10559>>>>>>>                    Move ( sDescription + "\n\n" + C_$Error + ":" * String(iErrNum) ) to sDescription
10560>>>>>>>                End
10560>>>>>>>>
10560>>>>>>>            End
10560>>>>>>>>
10560>>>>>>>            Else Begin
10561>>>>>>>                // we get here if we want it to work the old (less good) way. This is provided
10561>>>>>>>                // only for backwards compatibility. All errors go through the message box
10561>>>>>>>                Get Verbose_State to bVerbose
10562>>>>>>>                If (bVerbose)  Begin
10564>>>>>>>                    Move ( sDescription + "\n\n" + SFormat(C_$TechnicalDetails, iErrNum, iErrLine) ) to sDescription
10565>>>>>>>                    If (sSource<>"") Begin
10567>>>>>>>                        Move (sDescription + "\n" + C_$ErrorSource +" =" * sSource) to sDescription
10568>>>>>>>                    End
10568>>>>>>>>
10568>>>>>>>                End
10568>>>>>>>>
10568>>>>>>>            End
10568>>>>>>>>
10568>>>>>>>            
10568>>>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
10570>>>>>>>                Send UnhandledErrorDisplay iErrLine sDescription
10571>>>>>>>            End
10571>>>>>>>>
10571>>>>>>>            Else Begin
10572>>>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
10573>>>>>>>                Move (Message_Box(sDescription, sCaption, MB_Ok, iIcon)) to iReply
10574>>>>>>>            End
10574>>>>>>>>
10574>>>>>>>            
10574>>>>>>>            // abort on critical errors
10574>>>>>>>            If bCritical ;                Abort
10577>>>>>>>            
10577>>>>>>>        End
10577>>>>>>>>
10577>>>>>>>        
10577>>>>>>>    End_Procedure
10578>>>>>>>    
10578>>>>>>>    
10578>>>>>>>    
10578>>>>>>>    Function Help_Context Integer Context_Type Returns String
10580>>>>>>>        Function_Return (Current_Error_Number(Self))
10581>>>>>>>    End_Function
10582>>>>>>>    
10582>>>>>>>    
10582>>>>>>>    
10582>>>>>>>    // The following functions are rarely or never used.
10582>>>>>>>    
10582>>>>>>>    // The functions below are used to construct a general help
10582>>>>>>>    // name for errors that are generated by the system.  If processing
10582>>>>>>>    // comes here, then there was no module specific help found.  These
10582>>>>>>>    // functions will provide a more general help name that appears in
10582>>>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
10582>>>>>>>    // places in the help file under this application and module name.
10582>>>>>>>    
10582>>>>>>>    // Returns "ERROR:errornum" to supply error help.
10582>>>>>>>    Function Help_Name Returns String
10584>>>>>>>        Function_Return (Append("ERROR:",lastErr))
10585>>>>>>>    End_Function
10586>>>>>>>    
10586>>>>>>>    Function Application_Name Returns String
10588>>>>>>>        Function_Return 'SYSTEM'
10589>>>>>>>    End_Function
10590>>>>>>>    
10590>>>>>>>    Function Module_Name Returns String
10592>>>>>>>        Function_Return ''
10593>>>>>>>    End_Function
10594>>>>>>>    
10594>>>>>>>    
10594>>>>>>>    // Legacy names here for backwards compatibility
10594>>>>>>>    Function Verbose_State Returns Boolean
10596>>>>>>>        Function_Return (pbVerboseState(Self))
10597>>>>>>>    End_Function
10598>>>>>>>    
10598>>>>>>>    Procedure Set Verbose_State Boolean bVal
10600>>>>>>>        Set pbVerboseState to bVal
10601>>>>>>>    End_Procedure
10602>>>>>>>    
10602>>>>>>>    Procedure Set Bell_on_Find_Error_State Boolean bVal
10604>>>>>>>        Set pbBellOnFindErrorState to bVal
10605>>>>>>>    End_Procedure
10606>>>>>>>    
10606>>>>>>>    Function Bell_on_Find_Error_State Returns Boolean
10608>>>>>>>        Function_Return (pbBellOnFindErrorState(Self))
10609>>>>>>>    End_Function
10610>>>>>>>End_Class
10611>>>>>
10611>>>>>// Legacy classnames
10611>>>>>Class ErrorSystem is a cWindowsErrorHandler
10612>>>>>End_Class
10613>>>>>
10613>>>>>Class Trapped_Errors_Array is a cTrappedErrors
10614>>>>>End_Class
10615>>>>>
10615>>>>>// Replace to make legacy code run that uses old names work
10615>>>>>
10615>>>>>Object oErrorHandler is a cWindowsErrorHandler
10617>>>>>End_Object
10618>>>>>
10618>>>Use seq_chnl.pkg
10618>>>Use Datadict.pkg
Including file: Datadict.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Datadict.pkg)
10618>>>>>Use VDFBase.pkg
10618>>>>>Use LanguageText.pkg // language support VDF pkg replacement strings
10618>>>>>
10618>>>>>Register_Procedure File_Field_Value_Changed
10618>>>>>Register_Procedure File_Field_Mask_Changed
10618>>>>>Register_Procedure File_Field_Label_Changed
10618>>>>>Register_Procedure File_Field_Option_Changed
10618>>>>>Register_Function  Extended_DEO_State Returns Integer
10618>>>>>Register_Function  Entry_Refresh_State Returns Integer
10618>>>>>Register_Procedure Set Entry_Refresh_State Integer iState
10618>>>>>Register_Function  Allow_Foreign_New_Save_State Returns Integer
10618>>>>>Register_Function  Server Returns Integer
10618>>>>>
10618>>>>>Use Data_Set.pkg
Including file: Data_set.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Data_set.pkg)
10618>>>>>>>Use VDFBase.pkg
10618>>>>>>>Use fndmodes.pkg
Including file: fndmodes.pkg    (C:\Program Files\DataFlex 23.0\Pkg\fndmodes.pkg)
10618>>>>>>>>>//
10618>>>>>>>>>// special find modes
10618>>>>>>>>>//
10618>>>>>>>>>Define NEXT_RECORD  for 5 // find-next
10618>>>>>>>>>Define FIRST_RECORD for 6 // find-first
10618>>>>>>>>>Define LAST_RECORD  for 7 // find-last 
10618>>>>>>>Use refmodes.pkg
Including file: refmodes.pkg    (C:\Program Files\DataFlex 23.0\Pkg\refmodes.pkg)
10618>>>>>>>>>//
10618>>>>>>>>>// constants for REFRESH message parameter values
10618>>>>>>>>>//
10618>>>>>>>>>Define MODE_CLEAR             for 1  //notification from origin of clear
10618>>>>>>>>>Define MODE_FIND_OR_CLEAR_SET for 2  //notification from find or clear
10618>>>>>>>>>Define MODE_CLEAR_ALL         for 3  //notification from clear-all
10618>>>>>>>>>Define MODE_DELETE            for 4  //notification after successful delete
10618>>>>>>>>>Define MODE_SAVE              for 5  //notification after successful save
10618>>>>>>>>>
10618>>>>>>>
10618>>>>>>>
10618>>>>>>>//
10618>>>>>>>//Global integer status values
10618>>>>>>>//
10618>>>>>>>Define OPERATION_MODE   for |VI99  //status of data-sets in application
10618>>>>>>>Define OPERATION_ORIGIN for |VI108 //origin of current of data-set operation
10618>>>>>>>
10618>>>>>>>//
10618>>>>>>>//Constants for Operation_Mode global int values
10618>>>>>>>//
10618>>>>>>>Define MODE_WAITING  for 0  //wait-mode
10618>>>>>>>Define MODE_FINDING  for 1  //find-mode
10618>>>>>>>Define MODE_CLEARING for 2  //clear-mode
10618>>>>>>>Define MODE_CREATING for 3  //create-mode
10618>>>>>>>Define MODE_SAVING   for 4  //save-mode
10618>>>>>>>Define MODE_DELETING for 5  //delete-mode
10618>>>>>>>Define MODE_ABORTING for 6  //abort-mode
10618>>>>>>>Define MODE_VALIDATING for 7  //request_validate-mode : added for VDF7
10618>>>>>>>Define MODE_CLEARINGALL for 8 //clear-all mode (added in VDF8)
10618>>>>>>>
10618>>>>>>>//   The Data_Set class is implemented as a subclass of Entry_Client, with
10618>>>>>>>//   a C language handler providing the majority of new behavior.  The
10618>>>>>>>//   Data_Set class is intended to be a grouping agent for data-entry objects
10618>>>>>>>//   and a container for subordinate Data_Sets.
10618>>>>>>>//
10618>>>>>>>Use BaseData_Set.pkg
10618>>>>>>>
10618>>>>>>>// Data_Set class definition, public class layer. (Extra class layer needed
10618>>>>>>>// to augment C-based (Constrain) procedure(s).)
10618>>>>>>>
10618>>>>>>>Class DataSet is a BaseData_Set
10619>>>>>>>    
10619>>>>>>>    
10619>>>>>>>    // maintain old name for the time being to maximize compatability
10619>>>>>>>    // between character mode and windows versions. Developers should be
10619>>>>>>>    // able to move DS classes back and forth without changes.
10619>>>>>>>    Replace_Class_Name Data_Set DataSet
10619>>>>>>>    
10619>>>>>>>    Procedure Construct_Object //Integer Img#
10621>>>>>>>        Forward Send Construct_Object No_Image //Img#
10623>>>>>>>        
10623>>>>>>>        Property Integer Constrain_File 0
10624>>>>>>>        Property Integer Auto_Fill_State False
10625>>>>>>>        Property Integer Change_Disabled_State  False
10626>>>>>>>        // RT sets this inside of Mark_components a part of old entry_client DSO behavior. Now it is never used
10626>>>>>>>        Property Integer Component_State False
10627>>>>>>>        
10627>>>>>>>    End_Procedure
10628>>>>>>>    
10628>>>>>>>    
10628>>>>>>>    //
10628>>>>>>>    // This may be called by legacy DSO and DDO code
10628>>>>>>>    //
10628>>>>>>>    // IMPORTANT NOTE of change for 8.2:
10628>>>>>>>    //         DO NOT call or augment this anymore.
10628>>>>>>>    //
10628>>>>>>>    //         for sending: Find all cases of Field_main_index and change it to File_Field_Index
10628>>>>>>>    //
10628>>>>>>>    //         for augmenting: In DSOs - replace Field_main_index with File_field_index
10628>>>>>>>    //                         In DDOs - replace Field_main_Index with Field_Index and do not pass
10628>>>>>>>    //                                   the file parameter.
10628>>>>>>>    //                                   See DDOs Field_index and File_field_Index for more
10628>>>>>>>    //
10628>>>>>>>    Function Field_Main_Index Integer file Integer Field Returns Integer
10630>>>>>>>        Integer dataType fldNdx retval ordr
10630>>>>>>>        Move -1 to retval      //field has no main index (default)
10631>>>>>>>        If (file <> 0) Begin
10633>>>>>>>//      FIELD_DEF file field to dataType fldNdx
10633>>>>>>>            Get_Attribute DF_FIELD_INDEX of file Field to fldNdx // main index field
10636>>>>>>>            If (fldNdx > 0 or Field = 0) ;                Move fldNdx to retval //field has main index
10639>>>>>>>        End
10639>>>>>>>>
10639>>>>>>>        If (file = main_file(Self)) Begin
10641>>>>>>>            Get ordering to ordr
10642>>>>>>>            If (ordr >= 0) ;                Move ordr to retval  //ordering takes precedence over main index
10645>>>>>>>        End
10645>>>>>>>>
10645>>>>>>>        Function_Return retval
10646>>>>>>>    End_Function
10647>>>>>>>    
10647>>>>>>>    // This allows packages that still use data-sets instead of DDOs to use this
10647>>>>>>>    // message syntax.
10647>>>>>>>    // Note that this will never get here if the DD class is used as
10647>>>>>>>    // it has its own handler for this. It only is called if DSOs are used in which
10647>>>>>>>    // case it calls the old message field_main_index above.
10647>>>>>>>    // DDO based objects will NEVER call this code
10647>>>>>>>    //
10647>>>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
10649>>>>>>>        Function_Return (Field_main_Index(Self,iFile,iField))
10650>>>>>>>    End_Function
10651>>>>>>>    
10651>>>>>>>    
10651>>>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
10653>>>>>>>        
10653>>>>>>>        RowID   riRow
10653>>>>>>>        Integer iIndex
10653>>>>>>>        Handle  hoServer
10653>>>>>>>        Integer iSegments iSeg iSegFld iSegFldMainIndex
10653>>>>>>>        Boolean bChanged bDoCheck bOk
10653>>>>>>>        
10653>>>>>>>        //Get Field_Main_Index iFile iField to iIndex
10653>>>>>>>        Get File_Field_Index iFile iField to iIndex
10654>>>>>>>        If (iIndex<>-1) Begin
10656>>>>>>>            // get prior rowId before it get cleared
10656>>>>>>>            Move (GetRowID(iFile)) to riRow
10657>>>>>>>            //  'hold' buffer to prepare for entry_update
10657>>>>>>>            Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
10660>>>>>>>            If bDoEntryUpdate Begin
10662>>>>>>>                Send Request_Entry_Update iFile 1  //entUpdt all DEOs as required
10663>>>>>>>                
10663>>>>>>>                // If the buffer is cleared (no record and no changed data) then we want
10663>>>>>>>                // to do a constrained_clear which will force the buffer to get cleared
10663>>>>>>>                // according to the rules of the current constraints.
10663>>>>>>>                //Get_field_value iFile 0 to iRec
10663>>>>>>>                //Move (GetRowID(iFile)) to riRow // 12.1 moved above the set file inactive
10663>>>>>>>                
10663>>>>>>>                // If there was an active record to begin with we consider this changed (not cleared)
10663>>>>>>>                If (not(IsNullRowId(riRow))) Begin
10665>>>>>>>                    Move True to bChanged
10666>>>>>>>                End
10666>>>>>>>>
10666>>>>>>>                Else Begin
10667>>>>>>>                    // or, if the record was already changed or the entry_update created a change
10667>>>>>>>                    // we consider this changed
10667>>>>>>>                    Get_Attribute DF_FILE_CHANGED of iFile to bChanged
10670>>>>>>>                End
10670>>>>>>>>
10670>>>>>>>                
10670>>>>>>>                If not bChanged Begin
10672>>>>>>>                    // if buffer is unchanged, do a constrained clear. It is unchanged if there was not
10672>>>>>>>                    // active record, the record was unchanged, and the update didn't change anything.
10672>>>>>>>                    Constrained_Clear eFindMode iFile by iIndex
10675>>>>>>>                End
10675>>>>>>>>
10675>>>>>>>                Else If (eFindMode=GE or eFindMode=LE and iIndex>0) Begin
10678>>>>>>>                    
10678>>>>>>>                    // If mode is GE or LE we need to do some extra processing. We want to clear
10678>>>>>>>                    // all index segemnt fields that occur after this field in the index. This way
10678>>>>>>>                    // dbList searches and find ge searches (f9) will always find the first record
10678>>>>>>>                    // that matches the data in the field being searched. This was if an index like
10678>>>>>>>                    // customer.name x customer.number where you had 10 identical names "john" typing
10678>>>>>>>                    // john will find the first record, because customer.number will get cleared.
10678>>>>>>>                    // Note we can no do this with GT or LT or you'd get stuck in fields
10678>>>>>>>                    
10678>>>>>>>                    // check all fields for index. Once you find the iField field, clear all
10678>>>>>>>                    // fields that follow it. Only do this if the other fields do not use the
10678>>>>>>>                    // same index as its primary index (in which case we assume the data is intentional).
10678>>>>>>>                    // This should handle most cases.
10678>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
10681>>>>>>>                    For iSeg from 1 to iSegments
10687>>>>>>>>
10687>>>>>>>                        Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSeg to iSegFld
10690>>>>>>>                        If not bDoCheck Begin
10692>>>>>>>                            If (iSegFld=iField) ;                                Move True to bDoCheck // marked after we find the find field in the index
10695>>>>>>>                        End
10695>>>>>>>>
10695>>>>>>>                        Else Begin // we get here after we've found the main field segment
10696>>>>>>>                            // if main index if this segment is same as our find index, do nothing
10696>>>>>>>                            Get File_Field_Index iFile iSegFld to iSegFldMainIndex
10697>>>>>>>                            If (iSegFldMainIndex<>iIndex) ;                                Set_Field_Value iFile iSegFld to ''
10702>>>>>>>                        End
10702>>>>>>>>
10702>>>>>>>                    Loop
10703>>>>>>>>
10703>>>>>>>                End
10703>>>>>>>>
10703>>>>>>>                
10703>>>>>>>                Get Which_Data_Set iFile to hoServer
10704>>>>>>>                If (hoServer and iFile=main_file(hoServer)) ;                    Send Attach_Main_File to hoServer
10707>>>>>>>                Else ;                    Attach iFile
10709>>>>>>>            End
10709>>>>>>>>
10709>>>>>>>            
10709>>>>>>>            Move False to Err
10710>>>>>>>            
10710>>>>>>>            If (Is_SuperFind_Required(Self,iFile)) ;                Send Request_SuperFind eFindMode iFile iField
10713>>>>>>>            Else If bDeferred ;                Send Request_Read eFindMode iFile iIndex
10717>>>>>>>            Else ;                Send Request_Find eFindMode iFile iIndex
10719>>>>>>>            
10719>>>>>>>            If (not(Found) and not(err)) Begin
10721>>>>>>>                // refind original record (or leave it cleared if not record)
10721>>>>>>>                Move (FindByRowId(iFile,riRow)) to bOk
10722>>>>>>>                
10722>>>>>>>                If bShowFindErr ;                    Error (If(eFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
10725>>>>>>>                Move False to Found
10726>>>>>>>            End
10726>>>>>>>>
10726>>>>>>>        End
10726>>>>>>>>
10726>>>>>>>        Else ;            If bShowFindErr ;                Error DFERR_FIELD_NOT_INDEXED
10730>>>>>>>    End_Procedure
10731>>>>>>>    
10731>>>>>>>    
10731>>>>>>>    // We only care about should_saves of DEOs and not DSOs when
10731>>>>>>>    // exiting the app. Create a handler for data set class. We still
10731>>>>>>>    // broadcast in case we've got nested deos in the dso (hopefully not).
10731>>>>>>>    //
10731>>>>>>>    Function Exit_Application_Check Returns Integer
10733>>>>>>>        Integer rVal
10733>>>>>>>        Broadcast Get Exit_Application_Check to Rval // check w/ kids
10735>>>>>>>        Function_Return rVal
10736>>>>>>>    End_Function
10737>>>>>>>    
10737>>>>>>>    Procedure Constrain
10739>>>>>>>        Integer iFile
10739>>>>>>>        Send OnConstrain
10740>>>>>>>        Forward Send Constrain
10742>>>>>>>        Get Constrain_File to iFile
10743>>>>>>>        If iFile ;            Constrain (Main_file(Self)) relates to iFile
10746>>>>>>>    End_Procedure
10747>>>>>>>    
10747>>>>>>>    Procedure OnConstrain
10749>>>>>>>    End_Procedure
10750>>>>>>>    
10750>>>>>>>    // Less confusing Message for adding Updating servers
10750>>>>>>>    //
10750>>>>>>>    Procedure Set DDO_Server Handle ObjId
10752>>>>>>>        Send Attach_Server ObjId
10753>>>>>>>    End_Procedure
10754>>>>>>>    
10754>>>>>>>    // This is called when a view takes or retakes the
10754>>>>>>>    // focus. If DD not in use, do nothing.
10754>>>>>>>    //
10754>>>>>>>    Procedure Refind_DD_Records
10756>>>>>>>        If (in_use_state(Self)) ;            Send refind_records
10759>>>>>>>    End_Procedure
10760>>>>>>>    
10760>>>>>>>    // this returns true if the data-set is changed AND there are attached
10760>>>>>>>    // DEO objects. Without this you can get "changes exist" condition reported
10760>>>>>>>    // that the user will have no way of saving.
10760>>>>>>>    //
10760>>>>>>>    Function Data_Set_Should_Save Returns Integer
10762>>>>>>>        Function_Return (Should_Save(Self) and ;            Data_Set_User_interface_count(Self))
10763>>>>>>>    End_Function
10764>>>>>>>    
10764>>>>>>>    // returns 0 indicating that this is not DD enabled. DataDictionary objects will return 1.
10764>>>>>>>    // Add DSOs and DDOs must understand this message
10764>>>>>>>    
10764>>>>>>>    Function Extended_DSO_State Returns Integer
10766>>>>>>>        Function_Return 0
10767>>>>>>>    End_Function
10768>>>>>>>    
10768>>>>>>>    
10768>>>>>>>End_Class
10769>>>>>>>
10769>>>>>>>
10769>>>>>>>
10769>>>>>Use DDValtbl.pkg  // validation table classes
Including file: Ddvaltbl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Ddvaltbl.pkg)
10769>>>>>>>//  Validation Table Support for Extended Data-Sets. Fields may
10769>>>>>>>//  attached to validation tables which can then be used for
10769>>>>>>>//  validation (if Validate_state is true) or list loading.
10769>>>>>>>//  Developers can create their own validation tables as long as they
10769>>>>>>>//  conform to the following external interface:
10769>>>>>>>//
10769>>>>>>>// Properties
10769>>>>>>>//   Static_State       - if list must be rebuilt each validation, load
10769>>>>>>>//   Allow_Blank_state  - If Blank or 0 is a valid response
10769>>>>>>>//   Validate_State     - should table be used for validation
10769>>>>>>>//   Table_Loaded_State - is the validation table initialized?
10769>>>>>>>//
10769>>>>>>>// Methods
10769>>>>>>>//  Get Validate_Value sValue to iVal - if iVal=0, it is legal
10769>>>>>>>//  Send Fill_list                    - fills a static list
10769>>>>>>>//  Send Request_Fill_From_List iObject iMessage
10769>>>>>>>//        This is a callback that will fill an external list by sending
10769>>>>>>>//        the passed message (iMessage) back to the requesting object
10769>>>>>>>//        (iObject). It will send this message for each item in the
10769>>>>>>>//        validation table. It always passes back four params. Those are:
10769>>>>>>>//                     iItem - Item count being passed back
10769>>>>>>>//                     sData - The Database value of the item
10769>>>>>>>//                     sDesc - The Value's description, "" if none
10769>>>>>>>//                     iFile - File number associated with the item (if any)
10769>>>>>>>//                     iRec  - Record associated with the item (if any)
10769>>>>>>>// Developers can create classes of any complexity to support validation
10769>>>>>>>// tables. We have provided the following four classes.
10769>>>>>>>//
10769>>>>>>>//  ValidationTable is an Array
10769>>>>>>>//           Provides simple one dimensional table support. The table must be
10769>>>>>>>//           loaded manually by creating fill_list and sending the message
10769>>>>>>>//           Add_Table_Value (send Add_Table_Value Value). If list is static
10769>>>>>>>//           it is filled once. If non-static it is filled each time it is
10769>>>>>>>//           requested to validate or fill a foreign lis.
10769>>>>>>>//
10769>>>>>>>//  DescriptionValidationTable is a ValidationTable
10769>>>>>>>//           Provides a more complex three dimension array allowing the
10769>>>>>>>//           object to store a data value, description value and a record
10769>>>>>>>//           number. The developer must fill this list using the Add_table_
10769>>>>>>>//           value message passing up to three values (data, desc, record).
10769>>>>>>>//
10769>>>>>>>//  FileValidationTable is a DescriptionValidationTable
10769>>>>>>>//           Provides a data aware table. This can be used to load data from
10769>>>>>>>//           data-files, from data-sets. If you use data-sets you can place
10769>>>>>>>//           constraints within the data-set. You must define the file-number,
10769>>>>>>>//           data-set (if any), the file index, the file's data field, and
10769>>>>>>>//           the file's description field. You can also define an optional
10769>>>>>>>//           "Type". All records are constrained to this type (with or with-
10769>>>>>>>//           data-sets). If is assumed that this file has an optimized finding
10769>>>>>>>//           index.
10769>>>>>>>//
10769>>>>>>>//  CodeValidationTable is a FileValidationTable
10769>>>>>>>//           Used for Code lists. Simply set Type_Value to the "type"
10769>>>>>>>//
10769>>>>>>>Use VDFBase.pkg
10769>>>>>>>
10769>>>>>>>
10769>>>>>>>Class ValidationTable is an Array
10770>>>>>>>    
10770>>>>>>>    Procedure Construct_Object
10772>>>>>>>        Forward Send Construct_Object
10774>>>>>>>        Property Integer Static_State        True
10775>>>>>>>        
10775>>>>>>>        Property Integer Table_Loaded_State  False
10776>>>>>>>        
10776>>>>>>>        Property Integer Validate_State      True
10777>>>>>>>        Property Integer Allow_Blank_State   False
10778>>>>>>>        Property Integer Main_File           0
10779>>>>>>>        Property String  Table_Title         DD_VALIDATION_LIST_TITLE
10780>>>>>>>        
10780>>>>>>>        Property Integer Number_Elements     1
10781>>>>>>>        
10781>>>>>>>        // System maintained. Sub-classes use these
10781>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
10781>>>>>>>        
10781>>>>>>>        Property String  Current_Code            ''
10782>>>>>>>        
10782>>>>>>>        Property String  Current_Description     ''
10783>>>>>>>        
10783>>>>>>>        Property RowID Current_RowId
10784>>>>>>>    End_Procedure
10785>>>>>>>    
10785>>>>>>>    Function Data_Item_Count Returns Integer
10787>>>>>>>        Function_Return (Item_Count(Self))
10788>>>>>>>    End_Function
10789>>>>>>>    
10789>>>>>>>    Function Data_Value Integer iItem Returns String
10791>>>>>>>        Function_Return (Value(Self,iItem))
10792>>>>>>>    End_Function
10793>>>>>>>    
10793>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
10795>>>>>>>        Set Value  iItem to sValue
10796>>>>>>>    End_Procedure
10797>>>>>>>    
10797>>>>>>>    Function Data_Description Integer iItem Returns String
10799>>>>>>>        Function_Return ''
10800>>>>>>>    End_Function
10801>>>>>>>    
10801>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
10803>>>>>>>    End_Procedure
10804>>>>>>>    
10804>>>>>>>    Function Data_RowId Integer iItem Returns RowID
10806>>>>>>>        Function_Return (NullRowId())
10807>>>>>>>    End_Function
10808>>>>>>>    
10808>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
10810>>>>>>>    End_Procedure
10811>>>>>>>    
10811>>>>>>>    
10811>>>>>>>    Procedure Add_Table_Value String sValue
10813>>>>>>>        Set Data_Value  (Data_Item_Count(Self)) to sValue
10814>>>>>>>    End_Procedure
10815>>>>>>>    
10815>>>>>>>    Function Validate_Value String sCode Returns Integer
10817>>>>>>>        Integer iMax
10817>>>>>>>        Integer iCnt
10817>>>>>>>        If (sCode = '');            Function_Return (not(Allow_Blank_State(Self)))
10820>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10822>>>>>>>            Send Delete_Data
10823>>>>>>>            Send Fill_list
10824>>>>>>>            Set Table_Loaded_State to True
10825>>>>>>>        End
10825>>>>>>>>
10825>>>>>>>        Get Data_Item_Count to iMax
10826>>>>>>>        Decrement iMax
10827>>>>>>>        For iCnt from 0 to iMax
10833>>>>>>>>
10833>>>>>>>            If (sCode=Data_Value(Self,iCnt)) Begin
10835>>>>>>>                Set Current_Code        to sCode
10836>>>>>>>                Set Current_Description to (Data_Description(Self,iCnt))
10837>>>>>>>                Set Current_RowId       to (Data_RowId(Self,iCnt))
10838>>>>>>>                Function_Return 0
10839>>>>>>>            End
10839>>>>>>>>
10839>>>>>>>        Loop
10840>>>>>>>>
10840>>>>>>>        Function_Return 1 // 0=OK
10841>>>>>>>    End_Function
10842>>>>>>>    
10842>>>>>>>    Function Find_Code_Description String sCode Returns String
10844>>>>>>>        If (sCode='' or ;            (sCode<>Current_Code(Self) and ;            Validate_Value(Self,sCode) ) );            Function_Return ''
10847>>>>>>>        Function_Return (Current_Description(Self))
10848>>>>>>>    End_Function
10849>>>>>>>    
10849>>>>>>>    
10849>>>>>>>    //  The deveveloper (or a sub-class) must fill this list. It is done
10849>>>>>>>    //  by finding the item and sending the Message:
10849>>>>>>>    //    Send Add_Table_Value sValue {sDescr}
10849>>>>>>>    //
10849>>>>>>>    Procedure Fill_List
10851>>>>>>>        Set Table_Loaded_State to True
10852>>>>>>>    End_Procedure
10853>>>>>>>    
10853>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
10855>>>>>>>        Integer iMax
10855>>>>>>>        Integer iCnt
10855>>>>>>>        Integer iFile
10855>>>>>>>        
10855>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
10858>>>>>>>        
10858>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10860>>>>>>>            Send Delete_Data
10861>>>>>>>            Send Fill_list
10862>>>>>>>            Set Table_Loaded_State to True
10863>>>>>>>        End
10863>>>>>>>>
10863>>>>>>>        Get Main_File to iFile
10864>>>>>>>        Get Data_Item_Count to iMax
10865>>>>>>>        Decrement iMax
10866>>>>>>>        For iCnt from 0 to iMax
10872>>>>>>>>
10872>>>>>>>            Send iMsg to iObj iCnt (Data_Value(Self,iCnt)) ;                (Data_Description(Self,iCnt)) iFile ;                (Data_RowId(Self,iCnt))
10873>>>>>>>        Loop
10874>>>>>>>>
10874>>>>>>>    End_Procedure
10875>>>>>>>    
10875>>>>>>>    
10875>>>>>>>    // returns all data in a two dimension variant array.
10875>>>>>>>    // [i][0] = data
10875>>>>>>>    // [i][1] = description
10875>>>>>>>    // This can be used by Crystal CDO classes (this is why a variant array is used)
10875>>>>>>>    Function TableData Returns Variant[][]
10877>>>>>>>        Variant[][2] vData
10878>>>>>>>        Integer iMax i
10878>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10880>>>>>>>            Send Delete_Data
10881>>>>>>>            Send Fill_list
10882>>>>>>>            Set Table_Loaded_State to True
10883>>>>>>>        End
10883>>>>>>>>
10883>>>>>>>        Get Data_Item_Count to iMax
10884>>>>>>>        For i from 0 to (iMax-1)
10890>>>>>>>>
10890>>>>>>>            Get Data_Value       i to vData[i][0]
10891>>>>>>>            Get Data_Description i to vData[i][1]
10892>>>>>>>        Loop
10893>>>>>>>>
10893>>>>>>>        Function_Return vData
10894>>>>>>>    End_Function
10895>>>>>>>    
10895>>>>>>>End_Class
10896>>>>>>>
10896>>>>>>>
10896>>>>>>>
10896>>>>>>>Class DescriptionValidationTable is an ValidationTable
10897>>>>>>>    
10897>>>>>>>    Procedure Construct_Object
10899>>>>>>>        Forward Send Construct_Object
10901>>>>>>>        Set Number_Elements to 2
10902>>>>>>>    End_Procedure
10903>>>>>>>    
10903>>>>>>>    Function Data_Item_Count Returns Integer
10905>>>>>>>        Function_Return (item_count(Self)/3)
10906>>>>>>>    End_Function
10907>>>>>>>    
10907>>>>>>>    Function Data_Value Integer iItem Returns String
10909>>>>>>>        Function_Return (Value(Self,iItem*3))
10910>>>>>>>    End_Function
10911>>>>>>>    
10911>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
10913>>>>>>>        Set Value  (iItem*3) to sValue
10914>>>>>>>    End_Procedure
10915>>>>>>>    
10915>>>>>>>    Function Data_Description Integer iItem Returns String
10917>>>>>>>        Function_Return (Value(Self,iItem*3+1))
10918>>>>>>>    End_Function
10919>>>>>>>    
10919>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
10921>>>>>>>        Set Value  (iItem*3+1) to sValue
10922>>>>>>>    End_Procedure
10923>>>>>>>    
10923>>>>>>>    Function Data_RowId Integer iItem Returns RowID
10925>>>>>>>        String sRowId
10925>>>>>>>        Get Value (iItem*3+2) to sRowId
10926>>>>>>>        Function_Return (DeSerializeRowId(sRowId))
10927>>>>>>>    End_Function
10928>>>>>>>    
10928>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
10930>>>>>>>        Set Value  (iItem*3+2) to (SerializeRowId(riValue))
10931>>>>>>>    End_Procedure
10932>>>>>>>    
10932>>>>>>>    Procedure Add_Table_Value String sData String sDescr RowID riRec
10934>>>>>>>        String  sVal
10934>>>>>>>        RowID   riRecVal
10934>>>>>>>        Integer iCnt
10934>>>>>>>        Get Data_Item_Count to iCnt
10935>>>>>>>        Set Data_Value iCnt to sData
10936>>>>>>>        
10936>>>>>>>        // If one param passed use it for both display and database values
10936>>>>>>>        If (num_arguments <= 1);            Move sData  to sVal
10939>>>>>>>        Else ;            Move sDescr to sVal
10941>>>>>>>        Set Data_Description iCnt to sVal
10942>>>>>>>        
10942>>>>>>>        If (num_arguments <= 2) ;            Move (NullRowId()) to riRecVal
10945>>>>>>>        Else ;            Move riRec        to riRecVal
10947>>>>>>>        Set Data_RowId iCnt to riRecVal
10948>>>>>>>    End_Procedure
10949>>>>>>>End_Class
10950>>>>>>>
10950>>>>>>>
10950>>>>>>>Class FileValidationTable is an DescriptionValidationTable
10951>>>>>>>    
10951>>>>>>>    Procedure Construct_Object
10953>>>>>>>        Forward Send Construct_Object
10955>>>>>>>        Property Integer No_Fill_State     False // this is never used and is obsolete. (JJT)
10956>>>>>>>        Property Integer Ordering          1   // Indx1 is a good guess.
10957>>>>>>>        Property String  Type_Value        ''  // default these two to
10958>>>>>>>        Property Integer Type_Field        0   // Undefined (none).
10959>>>>>>>        Property Integer Code_Field        1   // Fld 1=code, 2=descr
10960>>>>>>>        Property Integer Description_Field 2   // are good guesses.
10961>>>>>>>        
10961>>>>>>>        Property Integer Code_Load_Object  0   // or (Code_Loader(Self))
10962>>>>>>>    End_Procedure
10963>>>>>>>    
10963>>>>>>>    Function Table_Loaded_State Returns Integer
10965>>>>>>>        Integer iRVal
10965>>>>>>>        Get No_fill_State to iRVal // if true, table always is loaded
10966>>>>>>>        If not iRval ;            Forward Get table_loaded_State to iRVal
10970>>>>>>>        Function_Return iRval
10971>>>>>>>    End_Function
10972>>>>>>>    
10972>>>>>>>    Function Validate_Value String sCode Returns Integer
10974>>>>>>>        Integer iRVal
10974>>>>>>>        Integer iDSO
10974>>>>>>>        Get Code_Load_Object  to iDSO
10975>>>>>>>        // we use standard validate, if code is blank, OR if
10975>>>>>>>        //   1. if no code DSO or the code DSO exists but is not busy.
10975>>>>>>>        //   2. AND it is not no-fill
10975>>>>>>>        //   3. AND it is static
10975>>>>>>>        // Else we find the record directly
10975>>>>>>>        // Note that the operation mode is busy during request_validate (the
10975>>>>>>>        // ddo does this). WHen operation mode is busy we must not use
10975>>>>>>>        // the code dso (must find manually).
10975>>>>>>>        If (sCode='' or ;            ( (iDSO=0 or Operation_Mode=0)    and ; // if no code DSO or DSO not busy            No_Fill_State(Self)=0 and ;            Static_State(Self) ) ) ;            Forward Get Validate_Value sCode to iRVal
10979>>>>>>>        Else If (sCode<>Current_Code(Self)) ;            Get Find_Value sCode to iRVal
10983>>>>>>>        Function_Return iRVal // OK
10984>>>>>>>    End_Function
10985>>>>>>>    
10985>>>>>>>    Procedure Initialize_File
10987>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
10987>>>>>>>        Get Code_Load_Object  to iDSO
10988>>>>>>>        Get Main_File         to iFile
10989>>>>>>>        Get Code_Field        to iCodeField
10990>>>>>>>        Get Description_Field to iDescField
10991>>>>>>>        Get Ordering          to iIndex
10992>>>>>>>        Get Type_Field        to iTypeField
10993>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Initialize_File to iDSO ;            iFile iIndex iCodeField iDescField ;            iTypeField (Type_Value(Self))
10996>>>>>>>        Else Begin
10997>>>>>>>            Clear iFile
10998>>>>>>>            // if Type exists, seed the type value
10998>>>>>>>            If iTypeField ;                Set_Field_Value iFile iTypeField to (Type_Value(Self))
11003>>>>>>>        End
11003>>>>>>>>
11003>>>>>>>    End_Procedure
11004>>>>>>>    
11004>>>>>>>    Function Find_Value String Code Returns Integer
11006>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
11006>>>>>>>        Get Code_Load_Object  to iDSO
11007>>>>>>>        Get Main_File         to iFile
11008>>>>>>>        Get Ordering          to iIndex
11009>>>>>>>        Get Code_Field        to iCodeField
11010>>>>>>>        Get Description_Field to iDescField
11011>>>>>>>        Get Type_Field        to iTypeField
11012>>>>>>>        Send Initialize_File
11013>>>>>>>        //
11013>>>>>>>        Set_Field_Value iFile iCodeField to Code
11016>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Request_Find to iDSO EQ iFile iIndex
11019>>>>>>>        Else ;            Vfind iFile iIndex EQ
11022>>>>>>>        If not (Found) ;            Function_Return 1
11025>>>>>>>        // Set properties Current_code and Current_Description
11025>>>>>>>        Send Store_Current_Data iFile iCodeField iDescField
11026>>>>>>>        Function_Return 0
11027>>>>>>>    End_Function
11028>>>>>>>    
11028>>>>>>>    // internal
11028>>>>>>>    Procedure Store_Current_Data Integer iFile Integer iCodeField Integer iDescField
11030>>>>>>>        String sVal
11030>>>>>>>        Get_Field_Value iFile iCodeField to sVal
11033>>>>>>>        Set Current_Code to (trim(sVal))
11034>>>>>>>        If iDescField Begin
11036>>>>>>>            Get_Field_Value iFile iDescField to sVal
11039>>>>>>>            Set Current_Description to (trim(sVal))
11040>>>>>>>        End
11040>>>>>>>>
11040>>>>>>>        Set Current_RowId to (GetRowId(iFile))
11041>>>>>>>    End_Procedure
11042>>>>>>>    
11042>>>>>>>    Function Next_Code_Record Returns Boolean
11044>>>>>>>        Integer iFile iCodeField iDescField iIndex
11044>>>>>>>        Integer iTypeField
11044>>>>>>>        String sTypeValue sFoundTypeValue
11044>>>>>>>        Boolean bFound
11044>>>>>>>        Handle hoDSO
11044>>>>>>>        Get Code_Load_Object  to hoDSO
11045>>>>>>>        Get Description_Field to iDescField
11046>>>>>>>        Get Code_Field        to iCodeField
11047>>>>>>>        Get Main_File         to iFile
11048>>>>>>>        
11048>>>>>>>        If hoDSO Begin
11050>>>>>>>            Get Next_Code_record of hoDSO to bFound
11051>>>>>>>        End
11051>>>>>>>>
11051>>>>>>>        Else Begin
11052>>>>>>>            Get Ordering to iIndex
11053>>>>>>>            Vfind iFile iIndex GT
11055>>>>>>>            Move (Found) to bFound
11056>>>>>>>            If bFound Begin
11058>>>>>>>                // if found see if we are at the end of the valid list of types
11058>>>>>>>                Get Type_Field to iTypeField
11059>>>>>>>                Get Type_Value to sTypeValue
11060>>>>>>>                If ((iTypeField<>0) and (sTypeValue<>"")) Begin
11062>>>>>>>                    Get_Field_Value iFile iTypeField to sFoundTypeValue
11065>>>>>>>                    Move (Trim(sTypeValue)=Trim(sFoundTypeValue)) to bFound
11066>>>>>>>                End
11066>>>>>>>>
11066>>>>>>>            End
11066>>>>>>>>
11066>>>>>>>        End
11066>>>>>>>>
11066>>>>>>>        If bFound Begin
11068>>>>>>>            Send Store_Current_Data iFile iCodeField iDescField
11069>>>>>>>        End
11069>>>>>>>>
11069>>>>>>>        Function_Return bFound
11070>>>>>>>    End_Function
11071>>>>>>>    
11071>>>>>>>    Procedure Fill_List
11073>>>>>>>        RowID riId
11073>>>>>>>        Boolean bFound
11073>>>>>>>        String sCode sDesc
11073>>>>>>>        If (Static_State(Self)=0 or No_Fill_State(Self)) ;            Procedure_Return
11076>>>>>>>        //
11076>>>>>>>        Send Delete_Data
11077>>>>>>>        Send Initialize_File
11078>>>>>>>        Get Next_Code_Record to bFound
11079>>>>>>>        While bFound
11083>>>>>>>            Get Current_Code        to sCode
11084>>>>>>>            Get Current_Description to sDesc
11085>>>>>>>            Get Current_RowId       to riId
11086>>>>>>>            Send Add_Table_Value sCode sDesc riId
11087>>>>>>>            Get Next_Code_Record to bFound
11088>>>>>>>        Loop
11089>>>>>>>>
11089>>>>>>>        Set Table_Loaded_State to True
11090>>>>>>>    End_Procedure
11091>>>>>>>    
11091>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
11093>>>>>>>        Integer iItem
11093>>>>>>>        Integer iFile
11093>>>>>>>        RowID   riId
11093>>>>>>>        Boolean bFound
11093>>>>>>>        String sCode sDesc
11093>>>>>>>        
11093>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
11096>>>>>>>        
11096>>>>>>>        If (Static_State(Self) and No_Fill_State(Self)=0 ) ;            Forward Send Request_Fill_From_List iObj iMsg
11100>>>>>>>        Else Begin
11101>>>>>>>            Get Main_File to iFile
11102>>>>>>>            Send Initialize_File
11103>>>>>>>            Get Next_Code_Record to bFound
11104>>>>>>>            While bFound
11108>>>>>>>                Get Current_Code        to sCode
11109>>>>>>>                Get Current_Description to sDesc
11110>>>>>>>                Get Current_RowId       to riId
11111>>>>>>>                Send iMSG to iObj iItem sCode sDesc iFile riId
11112>>>>>>>                Increment iItem
11113>>>>>>>                Get Next_Code_Record to bFound
11114>>>>>>>            Loop
11115>>>>>>>>
11115>>>>>>>        End
11115>>>>>>>>
11115>>>>>>>    End_Procedure
11116>>>>>>>End_Class
11117>>>>>>>
11117>>>>>>>Use CodeLoad.pkg
Including file: codeload.pkg    (C:\Program Files\DataFlex 23.0\Pkg\codeload.pkg)
11117>>>>>>>>>// Interface:
11117>>>>>>>>>//
11117>>>>>>>>>//  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;
11117>>>>>>>>>//                            Integer Desc# Integer Type# String Type
11117>>>>>>>>>//
11117>>>>>>>>>//      This initializes the data-set for finding. You MUST pass all five
11117>>>>>>>>>//      parameters here. They are:
11117>>>>>>>>>//          File#  -  main file to use
11117>>>>>>>>>//         Index#  - Index to use for finding
11117>>>>>>>>>//          Code#  - field number of the code
11117>>>>>>>>>//          Desc#  - field number of the code's description
11117>>>>>>>>>//          Type#  - field number of the constraining Type (0 if none)
11117>>>>>>>>>//           Type  - the constrain type value ('' = allow all records)
11117>>>>>>>>>//
11117>>>>>>>>>//      You MUST send this message before finding records. Alternately,
11117>>>>>>>>>//      you could set the individual properties and send rebuild_constraints
11117>>>>>>>>>//      and CLEAR to initalize the file (see code on how to do this).
11117>>>>>>>>>//
11117>>>>>>>>>//    Get Next_Code_record to ret_Int
11117>>>>>>>>>//
11117>>>>>>>>>//      Returns the next record number. 0 if no more. If record exists it
11117>>>>>>>>>//      sets the value of Current_Code and Crnt_Description.
11117>>>>>>>>>//
11117>>>>>>>>>//    Get Current_Code to Ret_String
11117>>>>>>>>>//    Get Crnt_Description to Ret_String
11117>>>>>>>>>//
11117>>>>>>>>>//      Returns the code and description of the last valid record found
11117>>>>>>>>>//      with the Next_Code_Record Message
11117>>>>>>>>>//
11117>>>>>>>>>//   Sample Usage:  This was created primarily to be used by the
11117>>>>>>>>>//                  radio-entry-form classes. In particular those using
11117>>>>>>>>>//                  the "code" look up file. Look at those packages if
11117>>>>>>>>>//                  you wish to use them yourself.
11117>>>>>>>>>//
11117>>>>>>>>>Use Data_Set.pkg
11117>>>>>>>>>
11117>>>>>>>>>Class Code_Loader_Data_Set is a DataSet
11118>>>>>>>>>    
11118>>>>>>>>>    Procedure Construct_Object Integer Img#
11120>>>>>>>>>        Forward Send Construct_Object Img#
11122>>>>>>>>>        // These should be set by the Initialize_File message
11122>>>>>>>>>        Property String  Type_Value           '' // assume no defaults.
11123>>>>>>>>>        Property Integer Type_Field           0  // These values should be
11124>>>>>>>>>        Property Integer Code_Field           0  // set by initialize_file
11125>>>>>>>>>        Property Integer Description_Field    0  //
11126>>>>>>>>>        
11126>>>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
11126>>>>>>>>>        Property String  Current_Code         ''
11127>>>>>>>>>        Property String  Current_Description  ''
11128>>>>>>>>>    End_Procedure
11129>>>>>>>>>    
11129>>>>>>>>>    // If a Type exists (not a '') and there is a type field and a
11129>>>>>>>>>    // main_file constrain to the type. Else no constraints
11129>>>>>>>>>    Procedure OnConstrain
11131>>>>>>>>>        String sType
11131>>>>>>>>>        Integer iFile iField
11131>>>>>>>>>        Get Type_Value to sType
11132>>>>>>>>>        Get Main_File  to iFile
11133>>>>>>>>>        Get Type_Field to iField
11134>>>>>>>>>        If (sType<>'' and iFile<>0 and iField<>0) ;            Vconstrain iFile iField eq sType
11139>>>>>>>>>    End_Procedure
11140>>>>>>>>>    
11140>>>>>>>>>    //  This initializes the data-set for finding. You MUST pass all five
11140>>>>>>>>>    //  parameters here. They are:
11140>>>>>>>>>    //     File#  -  main file to use
11140>>>>>>>>>    //    Index#  - Index to use for finding
11140>>>>>>>>>    //     Code#  - field number of the code
11140>>>>>>>>>    //     Desc#  - field number of the code's description
11140>>>>>>>>>    //     Type#  - field number of the constraining Type (0 if none)
11140>>>>>>>>>    //      Type  - the constrain type value ('' = allow all records)
11140>>>>>>>>>    //
11140>>>>>>>>>    Procedure Initialize_File Integer File# Integer Index# Integer Code# ;            Integer Desc# Integer Type# String Type
11142>>>>>>>>>        // note: all params are required!
11142>>>>>>>>>        Set Main_File         to File#
11143>>>>>>>>>        Set Ordering          to Index#
11144>>>>>>>>>        Set Code_Field        to Code#
11145>>>>>>>>>        Set Description_Field to Desc#
11146>>>>>>>>>        Set Type_Field        to Type#
11147>>>>>>>>>        Set Type_Value        to Type
11148>>>>>>>>>        //
11148>>>>>>>>>        Send Rebuild_Constraints // set up constraints
11149>>>>>>>>>        Send Clear               // initialize the file
11150>>>>>>>>>    End_Procedure
11151>>>>>>>>>    
11151>>>>>>>>>    //  Find the next record: Return 0 if no record, 1 if record exists
11151>>>>>>>>>    //   if record exists set Current_Code and Current_Description
11151>>>>>>>>>    //
11151>>>>>>>>>    Function Next_Code_Record Returns Boolean
11153>>>>>>>>>        Integer iFile iField
11153>>>>>>>>>        String sValue
11153>>>>>>>>>        Send Request_Find GT (Main_File(Self)) (Ordering(Self))
11154>>>>>>>>>        If not (Found) ;            Function_Return False
11157>>>>>>>>>        // Set properties Current_code and Current_Description
11157>>>>>>>>>        Get Main_File to iFile
11158>>>>>>>>>        
11158>>>>>>>>>        Get Code_Field to iField
11159>>>>>>>>>        Get_Field_Value iFile iField to sValue
11162>>>>>>>>>        Set Current_Code to sValue
11163>>>>>>>>>        
11163>>>>>>>>>        Get Description_Field to iField
11164>>>>>>>>>        Get_Field_Value iFile iField to sValue
11167>>>>>>>>>        Set Current_Description to sValue
11168>>>>>>>>>        Function_Return True
11169>>>>>>>>>    End_Function
11170>>>>>>>>>    
11170>>>>>>>>>End_Class
11171>>>>>>>Use cCodeMaintOpen_Mixin.pkg
Including file: cCodeMaintOpen_Mixin.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCodeMaintOpen_Mixin.pkg)
11171>>>>>>>>>// Mixin class to support transistion support for CodeType and CodeMast files.
11171>>>>>>>>>// These files used to be in filelist and they used to reside at 207 and 208 and they
11171>>>>>>>>>// were always opened with "open as"
11171>>>>>>>>>// We want these to be in the filelist at 253 and 254. These open methods will attempt to open these files
11171>>>>>>>>>// as such. If these are old files (not in filelist or wrong number) they will get loaded with the old
11171>>>>>>>>>// open as - thus keeping this backwards compatible.
11171>>>>>>>>>// By adding to filelist, we can sort the files and we can open them as other database sources.
11171>>>>>>>>>Use VDFBase.pkg
11171>>>>>>>>>
11171>>>>>>>>>Declare_Datafile CodeType
Including file: CodeType.fd    (C:\Projects\DF20\DbUpdateFramework\DDSrc\CodeType.fd)
11171>>>>>>>>>Declare_Datafile CodeMast
Including file: CodeMast.fd    (C:\Projects\DF20\DbUpdateFramework\DDSrc\CodeMast.fd)
11171>>>>>>>>>Define C_Expected_CodeType_FileNumber for 253  // and the logical name must be CODETYPE
11171>>>>>>>>>Define C_Expected_CodeMast_FileNumber for 254  // and the logical name must be CODEMAST
11171>>>>>>>>>
11171>>>>>>>>>Class cCodeMaintOpen_Mixin is a Mixin
11172>>>>>>>>>    
11172>>>>>>>>>    Procedure OpenCodeMast
11174>>>>>>>>>        String sName
11174>>>>>>>>>        If (Codemast.File_number=C_Expected_CodeMast_FileNumber) Begin
11176>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of Codemast.File_number to sName
11179>>>>>>>>>            If (uppercase(trim(sName))="CODEMAST") Begin
11181>>>>>>>>>                Open CodeMast
11183>>>>>>>>>                Procedure_Return
11184>>>>>>>>>            End
11184>>>>>>>>>>
11184>>>>>>>>>        End
11184>>>>>>>>>>
11184>>>>>>>>>        Open "CodeMast" as Codemast.File_number
11186>>>>>>>>>    End_Procedure
11187>>>>>>>>>    
11187>>>>>>>>>    Procedure OpenCodeType
11189>>>>>>>>>        String sName
11189>>>>>>>>>        If (Codetype.File_number=C_Expected_CodeType_FileNumber) Begin
11191>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of CodeType.File_number to sName
11194>>>>>>>>>            If (uppercase(trim(sName))="CODETYPE") Begin
11196>>>>>>>>>                Open CodeType
11198>>>>>>>>>                Procedure_Return
11199>>>>>>>>>            End
11199>>>>>>>>>>
11199>>>>>>>>>        End
11199>>>>>>>>>>
11199>>>>>>>>>        Open "CodeType" as CodeType.File_number
11201>>>>>>>>>    End_Procedure
11202>>>>>>>>>    
11202>>>>>>>>>End_Class
11203>>>>>>>
11203>>>>>>>//
11203>>>>>>>//  This is the object we need for loading files.
11203>>>>>>>//
11203>>>>>>>Object Code_loader is a Code_loader_Data_Set no_Image
11205>>>>>>>End_Object
11206>>>>>>>
11206>>>>>>>
11206>>>>>>>Class CodeValidationTable is an FileValidationTable
11207>>>>>>>    
11207>>>>>>>    // supports opening of file in reserved filelist area.
11207>>>>>>>    Import_Class_Protocol cCodeMaintOpen_Mixin
11208>>>>>>>    
11208>>>>>>>    Procedure Construct_Object
11210>>>>>>>        Forward Send Construct_Object
11212>>>>>>>        
11212>>>>>>>        Send OpenCodeMast                       // methods supports w/ filelist (new) and without (old)
11213>>>>>>>        
11213>>>>>>>        Set Main_File to CodeMast.File_Number   // name of file is CODEMAST
11214>>>>>>>        Set Ordering to 1                       // Index 1: Types x Code
11215>>>>>>>        Set Type_Field to 1                     // Fld 1: Type
11216>>>>>>>        Set Code_Field to 2                     // Fld 2: Code
11217>>>>>>>        Set Description_Field to 3              // Fld 3: Description
11218>>>>>>>        Set Code_load_Object to (Code_Loader(Self))
11219>>>>>>>    End_Procedure
11220>>>>>>>    
11220>>>>>>>End_Class
11221>>>>>
11221>>>>>// Used to by DDOConstraintFindMeta to return constraint expression info in a friendlier fashion
11221>>>>>Struct tDDOConstraintFindMeta
11221>>>>>    Integer iJumpInSegments
11221>>>>>    Boolean bJumpOut
11221>>>>>    Boolean bPreRelate
11221>>>>>    Boolean bPostRelate
11221>>>>>End_Struct
11221>>>>>
11221>>>>>// used by webapp resynchs
11221>>>>>Struct tDDChangedParentInfo
11221>>>>>    Integer iTable
11221>>>>>    Boolean bSwitched
11221>>>>>End_Struct
11221>>>>>
11221>>>>>// used by webapp resynchs
11221>>>>>Struct tDDChangedInfo
11221>>>>>    Boolean bChanged
11221>>>>>    tDDChangedParentInfo[] ParentChanged
11221>>>>>    tDDChangedParentInfo[] ParentChanged
11221>>>>>End_Struct
11221>>>>>
11221>>>>>Enum_List
11221>>>>>    Define CONST_EXP_JUMPOUT     for 1
11221>>>>>    Define CONST_EXP_PRE_RELATE  for 2
11221>>>>>    Define CONST_EXP_POST_RELATE for 4
11221>>>>>End_Enum_List
11221>>>>>
11221>>>>>// Constraint Find Types
11221>>>>>Enum_List
11221>>>>>    Define CONST_VALUE for 0    // Constrain File.Field eq sValue
11221>>>>>    Define CONST_CHILD          // Constrain File Relates to iOtherFile
11221>>>>>    Define CONST_FIELD          // Constrain File.field eq OtherFile.OtherField
11221>>>>>    Define CONST_EXP            // Constrain File as (Expression) - expression is internal
11221>>>>>    Define CONST_RELATES        // Sames a CONST_CHILD - should never be used
11221>>>>>End_Enum_List
11221>>>>>
11221>>>>>// Constraint Find Modes
11221>>>>>Enum_List
11221>>>>>    Define CONST_LT for 0
11221>>>>>    Define CONST_LE for 1
11221>>>>>    Define CONST_EQ for 2
11221>>>>>    Define CONST_GE for 3
11221>>>>>    Define CONST_GT for 4
11221>>>>>    Define CONST_NE for 5
11221>>>>>    Define CONST_Matches for 6       // a matches not capable of a jump in e.g., "?A*"
11221>>>>>    Define CONST_Contains for 7      // a contains
11221>>>>>    Define CONST_MatchesJumpIn for 9 // a matches which is capable of a jump in e.g., "A*"
11221>>>>>    // note that BETWEEN is actually two constraints a GE and LE
11221>>>>>End_Enum_List
11221>>>>>
11221>>>>>// Struct used to DDOConstraints to return current constraints in an array
11221>>>>>Struct tConstraintDef
11221>>>>>    Integer eType // constraint Find type
11221>>>>>    Integer eMode // constrain file mode
11221>>>>>    Integer iFile
11221>>>>>    Integer iField
11221>>>>>    String sValue
11221>>>>>    Integer iOtherFile
11221>>>>>    Integer iOtherField
11221>>>>>End_Struct
11221>>>>>
11221>>>>>// values passed to OnPre/PostFind to indicate the operation type
11221>>>>>Enum_List
11221>>>>>    Define DDFindRequestFind    // request_find
11221>>>>>    Define DDFindFindByRowRec   // FindByRowId, Find_By_Recnum
11221>>>>>    Define DDFindRequestAssign  // Request_assign
11221>>>>>    Define DDFindClear          // Clear (note Clear_All doesn't do this)
11221>>>>>End_Enum_List
11221>>>>>
11221>>>>>
11221>>>>>// these are private
11221>>>>>Define DD_RememberLast for "_REMEMBER$LAST_"
11221>>>>>Use tDDRemembered.pkg
Including file: tDDRemembered.pkg    (C:\Program Files\DataFlex 23.0\Pkg\tDDRemembered.pkg)
11221>>>>>>>// DDRemember Struct used for DataDictionary Class
11221>>>>>>>
11221>>>>>>>// private
11221>>>>>>>
11221>>>>>>>Struct tDDRemembered
11221>>>>>>>    Integer iField // searches are performed on this segement - it must be first
11221>>>>>>>    String sDefault
11221>>>>>>>    String sLastValue
11221>>>>>>>End_Struct
11221>>>>>>>
11221>>>>>
11221>>>>>// Used to assign a global validation_object. This can be used for
11221>>>>>// automatic prompt object on non-relational validations (checks, validation_
11221>>>>>// tables, etc.)
11221>>>>>Integer DD_Global_Validation_Prompt_Object
11221>>>>>Move 0 to DD_Global_Validation_Prompt_Object
11222>>>>>
11222>>>>>// Used for Dso traversal marking - Private (do not use)
11222>>>>>Integer   DD_Current_Mark_Id
11222>>>>>Move 0 to DD_Current_Mark_Id
11223>>>>>
11223>>>>>// Used to validate DSO structures during Save and deletes
11223>>>>>Enumeration_List
11223>>>>>    Define DD_VALIDATE_STRUCTURE_ALWAYS // Validate each save/delete operation.
11223>>>>>    Define DD_VALIDATE_STRUCTURE_NEVER  // Never validate these operations.
11223>>>>>    Define DD_VALIDATE_STRUCTURE_ONCE   // Validate Once (first save or delete).
11223>>>>>End_Enumeration_List
11223>>>>>
11223>>>>>// Used as a start for error handing in DSOs. Only affects errors that go
11223>>>>>// through operation_not_allowed and Field_Error. Used by Error_Report_Mode
11223>>>>>Enumeration_List
11223>>>>>    Define DD_ERROR_REPORT              // Report Error on screen
11223>>>>>    Define DD_ERROR_NO_REPORT           // Show no Error..
11223>>>>>End_Enumeration_List
11223>>>>>
11223>>>>>Enumeration_List
11223>>>>>    Define DD_Lock_on_All             for  7  // 111
11223>>>>>    Define DD_Lock_on_New_Save_Delete for  5  // 101
11223>>>>>    Define DD_Lock_on_Delete          for  4  // 100
11223>>>>>    Define DD_Lock_on_Save            for  2  // 010
11223>>>>>    Define DD_Lock_on_New_Save        for  1  // 001
11223>>>>>End_Enumeration_List
11223>>>>>
11223>>>>>
11223>>>>>Define DD_DEFAULT_ERROR_NUMBER  for 999
11223>>>>>
11223>>>>>
11223>>>>>
11223>>>>>
11223>>>>>// The next replaces will be used to indicate default item-options
11223>>>>>// instead of a fieldnumber which is normally used.
11223>>>>>
11223>>>>>// these are the DD bits that pertain to DEO Item options.
11223>>>>>Define DD_DEO_MASK for (DD_NOENTER ior DD_SKIPFOUND ior DD_CAPSLOCK ior DD_ZERO_SUPPRESS ior DD_AUTORETURN ior DD_AUTOBACK ior DD_AUTOCLEAR)
11223>>>>>
11223>>>>>
11223>>>>>// Special parameter options that can get passed to Set Field_Options. The
11223>>>>>// purpose is to clear all fields or the remaining passed parameters. Normally,
11223>>>>>// these are not used so it does not matter if their interface is a bit odd.
11223>>>>>Enumeration_List
11223>>>>>    Define DD_CLEAR_FIELD_OPTIONS      for -1
11223>>>>>    Define DD_CLEAR_ALL_FIELD_OPTIONS  for -2
11223>>>>>End_Enumeration_List
11223>>>>>
11223>>>>>// used to keep track of extra server file information.
11223>>>>>Struct tDDServerInformation
11223>>>>>    Integer iParent             // parent file number
11223>>>>>    Boolean bAllowNullParent    // does this DD (child) allow a null parent
11223>>>>>    Integer bParentNoSwitchIfCommitted // does this DD (child) allow switching committed parents
11223>>>>>    Boolean bNoCascadeDelete           // when a child record exists should cascade delete stop the action
11223>>>>>    Boolean bCascadeDeleteNullTheParent // when a child record exists that is null parent allowed, should we delete or null the parent
11223>>>>>End_Struct
11223>>>>>
11223>>>>>Use DDExtFld.pkg // adds extended field/pointer support
Including file: DDExtFld.pkg    (C:\Program Files\DataFlex 23.0\Pkg\DDExtFld.pkg)
11223>>>>>>>// This is used by the DataDictionary class and provides a method for
11223>>>>>>>// windows DDs (for now) to support local buffers for text and binary buffers.
11223>>>>>>>// Field objects are created within the DD by sending the message:
11223>>>>>>>// The DD interface is:
11223>>>>>>>//
11223>>>>>>>//      Get  Field_Object iField to hExtFieldObject
11223>>>>>>>//      Send DefineExtendedField iField
11223>>>>>>>//      Send DefineAllExtendedFields
11223>>>>>>>//      Send ExtendedFieldsUpdate bSave
11223>>>>>>>//      Send ExtendedFieldsRefresh bCleared
11223>>>>>>>//      Set  File_Field_Current_Pointer_Value iFile iField iLen to pValue
11223>>>>>>>//      Set  Field_Current_Pointer_Value iField iLen to pValue
11223>>>>>>>//      Set  File_Field_Pointer_Entry iFile iField iLen bShowErr to pValue
11223>>>>>>>//      Set  Field_Pointer_Entry iField iOpts iLen bShowErr to pValue
11223>>>>>>>//      Get  File_Field_Current_Pointer_Value iFile iField to pData
11223>>>>>>>//      Get  Field_Current_Pointer_Value iField to pData
11223>>>>>>>//
11223>>>>>>>// Once object is identified, the following interface can be used
11223>>>>>>>//      Get FieldPointer of hExtFieldObject to iMemoryPointer
11223>>>>>>>//      Get FieldLength  of hExtFieldObject to iLen
11223>>>>>>>//      Get File_Number  of hExtFieldObject to iFile
11223>>>>>>>//      Get Field_Number of hExtFieldObject to iFile
11223>>>>>>>//      Set Update_Save_State of hExtFieldObject to bState         // be careful!
11223>>>>>>>//      Set Update_Find_State of hExtFieldObject to bState         // be careful
11223>>>>>>>//      Set FieldRefresh_Save_State of hExtFieldObject to bState   // be careful
11223>>>>>>>//
11223>>>>>>>
11223>>>>>>>//
11223>>>>>>>//  DD structure:
11223>>>>>>>//       DD Object           (property Field_objects points to child)
11223>>>>>>>//           FieldObjects    (array of field#s and field objs)
11223>>>>>>>//              FieldObject1 (heap alloc for each field)
11223>>>>>>>//              FieldObjectn
11223>>>>>>>//
11223>>>>>>>
11223>>>>>>>//
11223>>>>>>>// This is used to create a single extended field object.
11223>>>>>>>//
11223>>>>>>>// Interface
11223>>>>>>>//      Get FieldPointer to iMemoryPointer
11223>>>>>>>//      Get FieldLength  to iLen
11223>>>>>>>//      Get File_Number  to iFile
11223>>>>>>>//      Get Field_Number to iFile
11223>>>>>>>//      get/Set Update_Save_State to bState         // be careful!
11223>>>>>>>//      get/Set Update_Find_State to bState         // be careful
11223>>>>>>>//      get/Set FieldRefresh_Save_State to bState   // be careful
11223>>>>>>>//      get/set FieldChangedState
11223>>>>>>>//      send defineField  iFile iField
11223>>>>>>>//      Send FieldUpdate  bSave
11223>>>>>>>//      Send FieldRefresh bCleared bClearFieldChange
11223>>>>>>>//      Set  Field_pEntry iOpts iLen to pValue
11223>>>>>>>//      Set  Field_pValue iLen to pValue
11223>>>>>>>//
11223>>>>>>>Use VDFBase.pkg
11223>>>>>>>
11223>>>>>>>Class FieldObject is a cObject
11224>>>>>>>    
11224>>>>>>>    Procedure Construct_Object
11226>>>>>>>        Forward Send construct_object
11228>>>>>>>        // these are all set by DefineField and should not be changed
11228>>>>>>>        Property Integer File_Number        0
11229>>>>>>>        Property Integer Field_Number       0
11230>>>>>>>        Property Integer FieldLength        0
11231>>>>>>>        
11231>>>>>>>        // maintained by object
11231>>>>>>>        Property UChar[] pFieldArray
11232>>>>>>>        
11232>>>>>>>        // these can be changed, with care, by the developer
11232>>>>>>>        Property Integer Update_Save_State  True
11233>>>>>>>        Property Integer Update_Find_State  False // usually no point for finds
11234>>>>>>>        Property Integer FieldRefresh_State True
11235>>>>>>>        
11235>>>>>>>        // hopefully never used
11235>>>>>>>        Property Pointer pLegacyFieldPointer       0
11236>>>>>>>        
11236>>>>>>>    End_Procedure
11237>>>>>>>    
11237>>>>>>>    Procedure Set FieldChangedState Integer bState
11239>>>>>>>        Integer iField
11239>>>>>>>        Get Field_Number to iField
11240>>>>>>>        Delegate Set Field_Changed_state iField to bState
11242>>>>>>>    End_Procedure
11243>>>>>>>    
11243>>>>>>>    Function FieldChangedState Returns Integer
11245>>>>>>>        Integer iField  bState
11245>>>>>>>        Get Field_Number to iField
11246>>>>>>>        Delegate Get Field_Changed_state iField to bState
11248>>>>>>>        Function_Return bState
11249>>>>>>>    End_Function
11250>>>>>>>    
11250>>>>>>>    // return the field option specified
11250>>>>>>>    Function IsSaveNoPut Returns Boolean
11252>>>>>>>        Integer iField
11252>>>>>>>        Boolean  bState
11252>>>>>>>        Get Field_Number to iField
11253>>>>>>>        Delegate Get FieldSaveNoPut iField to bState
11255>>>>>>>        Function_Return bState
11256>>>>>>>    End_Function
11257>>>>>>>    
11257>>>>>>>    // for object: define file, field, fieldlength and allocate heap memory
11257>>>>>>>    //             and set memory pointer
11257>>>>>>>    Procedure DefineField Integer iFile Integer iField
11259>>>>>>>        Integer iFldLen
11259>>>>>>>        Set File_Number  to iFile
11260>>>>>>>        Set Field_Number to iField
11261>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldLen
11264>>>>>>>        Set FieldLength  to iFldLen
11265>>>>>>>    End_Procedure
11266>>>>>>>    
11266>>>>>>>    // Move from the DD Buffer to the file buffer
11266>>>>>>>    Procedure FieldUpdate Integer bSave
11268>>>>>>>        Integer iFile iField iFieldLen
11268>>>>>>>        UChar[] FieldArray
11269>>>>>>>        Integer iType
11269>>>>>>>        Boolean bNoPut
11269>>>>>>>        
11269>>>>>>>        // if bSave, part of save which means only update if changed
11269>>>>>>>        // if not bsave, part of find. You usually would not update this. You
11269>>>>>>>        // don't index on these types of fields
11269>>>>>>>        If ( (bSave and Update_Save_State(Self) and FieldChangedState(Self)) or ;            (not(bSave) and Update_Find_state(Self) ) ) Begin
11271>>>>>>>            // if save, we must respect DD_NoPut
11271>>>>>>>            If (bSave) Begin
11273>>>>>>>                // we are looking at the DD's field buffer itemoptions for, which
11273>>>>>>>                // should be set appropriately before a save. This setting has any
11273>>>>>>>                // changes made to support dd_commit
11273>>>>>>>                Get IsSaveNoPut to bNoPut
11274>>>>>>>                If bNoPut Begin
11276>>>>>>>                    Procedure_Return
11277>>>>>>>                End
11277>>>>>>>>
11277>>>>>>>            End
11277>>>>>>>>
11277>>>>>>>            Get pFieldArray to FieldArray
11278>>>>>>>            Get File_Number to iFile
11279>>>>>>>            Get Field_Number to iField
11280>>>>>>>            If iFile Begin
11282>>>>>>>                Set_Field_Value iFile iField to FieldArray // LENGTH iFieldLen
11285>>>>>>>            End
11285>>>>>>>>
11285>>>>>>>        End
11285>>>>>>>>
11285>>>>>>>    End_Procedure
11286>>>>>>>    
11286>>>>>>>    // Move from File buffer to local DD Buffer
11286>>>>>>>    // bCleared determines if this is a find or a clear.
11286>>>>>>>    // bClearFieldChange determines if we should clear the FieldChangedState.
11286>>>>>>>    Procedure FieldRefresh Boolean bCleared Boolean bClearFieldChange
11288>>>>>>>        Integer iFile iField
11288>>>>>>>        Integer bOk
11288>>>>>>>        UChar[] FieldArray
11289>>>>>>>        If (FieldRefresh_state(Self)) Begin
11291>>>>>>>            //Get FieldPointer to pField
11291>>>>>>>            Get File_Number to iFile
11292>>>>>>>            Get Field_Number to iField
11293>>>>>>>            // move from file buffer to memory pointed to by pField
11293>>>>>>>            If (iFile) Begin
11295>>>>>>>                If not bCleared Begin
11297>>>>>>>                    Get_Field_Value iFile iField to FieldArray
11300>>>>>>>                End
11300>>>>>>>>
11300>>>>>>>                Set Field_UCValue to FieldArray
11301>>>>>>>            End
11301>>>>>>>>
11301>>>>>>>        End
11301>>>>>>>>
11301>>>>>>>        If bClearFieldChange Begin
11303>>>>>>>            Set FieldChangedstate to False
11304>>>>>>>        End
11304>>>>>>>>
11304>>>>>>>    End_Procedure
11305>>>>>>>    
11305>>>>>>>    Procedure Set Field_pEntry Integer iOpts Integer iLen Integer bShowErr Pointer pValue
11307>>>>>>>        Integer iFile iField iFldLen iMemLen
11307>>>>>>>        Integer bChanged
11307>>>>>>>        UChar[] FieldArray
11308>>>>>>>        
11308>>>>>>>        // currently we do nothing with bShowErr because we don't checkfor errors!
11308>>>>>>>        
11308>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. For now we will
11308>>>>>>>        // let NoPut through, since a user might need it for finding.
11308>>>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
11311>>>>>>>        
11311>>>>>>>        // maybe in the future
11311>>>>>>>        // Force a caplsock if required
11311>>>>>>>        //If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
11311>>>>>>>        
11311>>>>>>>        Get File_Number  to iFile
11312>>>>>>>        Get Field_Number to iField
11313>>>>>>>        If (iFile) Begin
11315>>>>>>>            Get Is_pValueChanged iLen pValue to bChanged
11316>>>>>>>            If ( bChanged or (iOpts iand DD_FORCEPUT) ) Begin
11318>>>>>>>                Set Field_pValue iLen to pValue
11319>>>>>>>            End
11319>>>>>>>>
11319>>>>>>>            
11319>>>>>>>            
11319>>>>>>>            // Set changed state if changed and it is not No_put. This
11319>>>>>>>            // is an improvement on DEOs which would set changed-state for
11319>>>>>>>            // a no-put. This way, finds use the changed value but saves will
11319>>>>>>>            // not trigger a phony data loss
11319>>>>>>>            //If ( bChanged ) ;
11319>>>>>>>            If ( bChanged and not(iOpts iand DD_NOPUT) ) ;                Set FieldChangedState to True
11322>>>>>>>            
11322>>>>>>>            // The following is really highly unlikely!!!
11322>>>>>>>            // perform autofinds if needed. Note that required checking will occur as
11322>>>>>>>            // part of validation.
11322>>>>>>>            // We will only autofind if the field value is changed. This is consistent with
11322>>>>>>>            // DEOs which do not autofind on unchanged values. This provides optimizations
11322>>>>>>>            // when a parent record is already loaded.
11322>>>>>>>            If (bChanged or FieldChangedState(Self)) Begin
11324>>>>>>>                If (iOpts iand DD_AUTOFIND) ;                    Delegate Send File_Field_AutoFind iFile iField EQ
11328>>>>>>>                Else If (iOpts iand DD_AUTOFIND_GE) ;                    Delegate Send File_Field_AutoFind iFile iField GE
11333>>>>>>>            End
11333>>>>>>>>
11333>>>>>>>        End
11333>>>>>>>>
11333>>>>>>>        
11333>>>>>>>    End_Procedure
11334>>>>>>>    
11334>>>>>>>    // convert pointer to UChar[]
11334>>>>>>>    Function PointerToUCharArray Pointer pValue Integer iLen Returns UChar[]
11336>>>>>>>        UChar[] FieldArray
11337>>>>>>>        Boolean bOk
11337>>>>>>>        Move (ResizeArray(FieldArray,iLen)) to FieldArray
11338>>>>>>>        Move (MemCopy(AddressOf(FieldArray),pValue,iLen)) to bOK
11339>>>>>>>        Function_Return FieldArray
11340>>>>>>>    End_Function
11341>>>>>>>    
11341>>>>>>>    // Raw update of pValue
11341>>>>>>>    Procedure Set Field_UCValue UChar[] FieldArray
11343>>>>>>>        Set pFieldArray to FieldArray
11344>>>>>>>        Send DestroyLegacyFieldHeap
11345>>>>>>>    End_Procedure
11346>>>>>>>    
11346>>>>>>>    // Raw update of pValue
11346>>>>>>>    Procedure Set Field_pValue Integer iLen Pointer pValue
11348>>>>>>>        UChar[] FieldArray
11349>>>>>>>        Get PointerToUCharArray pValue iLen to FieldArray
11350>>>>>>>        Set Field_UCValue to FieldArray
11351>>>>>>>    End_Procedure
11352>>>>>>>    
11352>>>>>>>    Function Is_pValueChanged Integer iLen Pointer pValue Returns Boolean
11354>>>>>>>        Boolean bChanged
11354>>>>>>>        UChar[] FieldArray
11355>>>>>>>        Integer iFldLen
11355>>>>>>>        Get pFieldArray to FieldArray
11356>>>>>>>        Move (SizeOfArray(FieldArray)) to iFldLen
11357>>>>>>>        If (iLen <> SizeOfArray(FieldArray)) Begin
11359>>>>>>>            Move True to bChanged
11360>>>>>>>        End
11360>>>>>>>>
11360>>>>>>>        Else If (iLen) Begin // check for empty pointer
11363>>>>>>>            Move (MemCompare(AddressOf(FieldArray),pValue,iLen)) to bChanged
11364>>>>>>>        End
11364>>>>>>>>
11364>>>>>>>        Function_Return bChanged
11365>>>>>>>    End_Function
11366>>>>>>>    
11366>>>>>>>    // returns data as UChar array - best way to access the data
11366>>>>>>>    Function FieldArray Returns UChar[]
11368>>>>>>>        UChar[] FieldArray
11369>>>>>>>        Get pFieldArray to FieldArray
11370>>>>>>>        Function_Return FieldArray
11371>>>>>>>    End_Function
11372>>>>>>>    
11372>>>>>>>    // legacy method. Hopefully this is never called.
11372>>>>>>>    Function FieldPointer Returns Pointer
11374>>>>>>>        Pointer pValue pOldValue
11374>>>>>>>        Integer iLen
11374>>>>>>>        UChar[] FieldArray
11375>>>>>>>        Boolean bOk
11375>>>>>>>        Get pFieldArray to FieldArray
11376>>>>>>>        Move (SizeOfArray(FieldArray)) to iLen
11377>>>>>>>        Move (Alloc(iLen)) to pValue
11378>>>>>>>        Move (MemCopy(pValue,AddressOf(FieldArray),iLen)) to bOk
11379>>>>>>>        Send DestroyLegacyFieldHeap
11380>>>>>>>        Set pLegacyFieldPointer to pValue
11381>>>>>>>        Function_Return pValue
11382>>>>>>>    End_Function
11383>>>>>>>    
11383>>>>>>>    Procedure DestroyLegacyFieldHeap
11385>>>>>>>        Integer bOK
11385>>>>>>>        Pointer pField
11385>>>>>>>        Get pLegacyFieldPointer to pField
11386>>>>>>>        If (pField ) Begin
11388>>>>>>>            Move (Free(pField)) to bOk
11389>>>>>>>            Set pLegacyFieldPointer to 0
11390>>>>>>>        End
11390>>>>>>>>
11390>>>>>>>    End_Procedure
11391>>>>>>>    
11391>>>>>>>    // augment to release heap allocation
11391>>>>>>>    Procedure Destroy_Object
11393>>>>>>>        Send DestroyLegacyFieldHeap
11394>>>>>>>        Forward Send Destroy_object
11396>>>>>>>    End_Procedure
11397>>>>>>>    
11397>>>>>>>End_Class
11398>>>>>>>
11398>>>>>>>// This contains all extended field objects.
11398>>>>>>>// The array contains a list of all objects where item=field#
11398>>>>>>>// and item+1=field object.
11398>>>>>>>//
11398>>>>>>>// Interface is:
11398>>>>>>>//     Get Field_object iField to hFldObj
11398>>>>>>>//     Send DefineFieldObject iField
11398>>>>>>>//     Send ExtendedFieldsUpdate bSave
11398>>>>>>>//     Send ExtendedFieldsRefresh bCleared
11398>>>>>>>//
11398>>>>>>>Class FieldObjects is an Array
11399>>>>>>>    
11399>>>>>>>    // return object Id for iField. 0 if none.
11399>>>>>>>    Function Field_Object Integer iField Returns Integer
11401>>>>>>>        Integer iItm iCnt
11401>>>>>>>        Get Item_Count to iCnt
11402>>>>>>>        Move 0 to iItm
11403>>>>>>>        While iItm lt iCnt
11407>>>>>>>            If (Value(Self,iItm)=iField) ;                Function_Return (Value(Self,iItm+1))
11410>>>>>>>            Increment iItm
11411>>>>>>>            Increment iItm
11412>>>>>>>        Loop
11413>>>>>>>>
11413>>>>>>>        Function_Return 0
11414>>>>>>>    End_Function
11415>>>>>>>    
11415>>>>>>>    // define an extended object for field
11415>>>>>>>    Procedure DefineFieldObject Integer iField
11417>>>>>>>        Integer hFld
11417>>>>>>>        Integer iCnt  iFile
11417>>>>>>>        Boolean bInUse
11417>>>>>>>        Boolean bHasRecord
11417>>>>>>>        Delegate Get Main_File to iFile
11419>>>>>>>        Get Field_Object iField to hFld // this shouldn't exist yet
11420>>>>>>>        If not hFld Begin
11422>>>>>>>            Get Create U_FieldObject to hFld
11423>>>>>>>            Send DefineField to hFld iFile iField
11424>>>>>>>            Get Item_Count to iCnt          // add to array
11425>>>>>>>            Set Value  iCnt to iField   // Pos   = field#
11426>>>>>>>            Set Value  (iCnt+1) to hFld // Pos+1 = field object
11427>>>>>>>            Delegate Get In_Use_State to bInUse
11429>>>>>>>            If bInUse Begin
11431>>>>>>>                Delegate Send Refind_Records
11433>>>>>>>                Delegate Get HasRecord to bHasRecord
11435>>>>>>>                // updating the newly created field with the file buffer contents we don't
11435>>>>>>>                // want to change the field's changed state, which might have been set already.
11435>>>>>>>                Send FieldRefresh of hFld (not(bHasRecord)) False
11436>>>>>>>            End
11436>>>>>>>>
11436>>>>>>>        End
11436>>>>>>>>
11436>>>>>>>    End_Procedure
11437>>>>>>>    
11437>>>>>>>    // update all extended fields. Field buffer <-- DD buffer
11437>>>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
11439>>>>>>>        Integer iItm iCnt
11439>>>>>>>        Get Item_Count to iCnt
11440>>>>>>>        Move 0 to iItm
11441>>>>>>>        While iItm lt iCnt
11445>>>>>>>            Increment iItm
11446>>>>>>>            Send FieldUpdate to (Value(Self,iItm)) bSave
11447>>>>>>>            Increment iItm
11448>>>>>>>        Loop
11449>>>>>>>>
11449>>>>>>>    End_Procedure
11450>>>>>>>    
11450>>>>>>>    // refresh all extended fields. Field buffer --> DD buffer
11450>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
11452>>>>>>>        Integer iItm iCnt
11452>>>>>>>        Get Item_Count to iCnt
11453>>>>>>>        Move 0 to iItm
11454>>>>>>>        While iItm lt iCnt
11458>>>>>>>            Increment iItm
11459>>>>>>>            Send FieldRefresh to (Value(Self,iItm)) bCleared True
11460>>>>>>>            Increment iItm
11461>>>>>>>        Loop
11462>>>>>>>>
11462>>>>>>>    End_Procedure
11463>>>>>>>    
11463>>>>>>>    //
11463>>>>>>>    // these are sent from the child field object. We need to direct them
11463>>>>>>>    // to the DDO (the parent).
11463>>>>>>>    Procedure Set Field_Changed_State Integer iField Integer bState
11465>>>>>>>        Delegate Set Field_Changed_state iField to bState
11467>>>>>>>    End_Procedure
11468>>>>>>>    
11468>>>>>>>    Function Field_Changed_State Integer iField Returns Integer
11470>>>>>>>        Integer bState
11470>>>>>>>        Delegate Get Field_Changed_state iField to bState
11472>>>>>>>        Function_Return bState
11473>>>>>>>    End_Function
11474>>>>>>>    
11474>>>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iMode
11476>>>>>>>        Delegate Send File_field_AutoFind iFile iField iMode
11478>>>>>>>    End_Procedure
11479>>>>>>>    
11479>>>>>>>    Function FieldSaveNoPut Integer iField Returns Boolean
11481>>>>>>>        Boolean bIsCommited bNoPut
11481>>>>>>>        Delegate Get IsCommitted to bIsCommited
11483>>>>>>>        // we don't know if this is foreign or not (DDOs never do by themselves). We
11483>>>>>>>        // will test for regular. This should never be an issue as the DEO itself
11483>>>>>>>        // will be DisplayOnly as needed (we don't have indexed NoEnter=T/Noput=F issues)
11483>>>>>>>        Delegate Get FieldNoPut iField bIsCommited False to bNoPut
11485>>>>>>>        Function_Return bNoPut
11486>>>>>>>    End_Function
11487>>>>>>>    
11487>>>>>>>    Procedure Destroy_Object
11489>>>>>>>        Delegate Set Field_Objects to 0
11491>>>>>>>        Forward Send Destroy_object
11493>>>>>>>    End_Procedure
11494>>>>>>>    
11494>>>>>>>    
11494>>>>>>>End_Class
11495>>>>>// for text and binary. Must support Address Type
11495>>>>>
11495>>>>>
11495>>>>>// we need these from CLI.pkg for DAW drivers. These values must match what is defined
11495>>>>>// in cli.pkg
11495>>>>>Define DF_FILE_SQL_FILTER for 611
11495>>>>>Define DF_FILE_SQL_FILTER_ACTIVE for 624
11495>>>>>Define DF_FILE_SQL_FILTER_EQ for 636
11495>>>>>// same a CLI.pkg DF_FILE_TABLE_NAME but with a different name
11495>>>>>// used to avoid naming conflict. Must match cli.pkg df_file_table_name
11495>>>>>Define DF_FILE_SQL_TABLE_NAME for 609
11495>>>>>
11495>>>>>Define DF_FIELD_SQL_COLUMN_NAME         for 723
11495>>>>>
11495>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE     for 1085
11495>>>>>Define DF_FILE_DATABASE_ID              for 622
11495>>>>>
11495>>>>>// Class helper for SQL/driver assistance.
11495>>>>>// This can only be used within a DataDictionary Class as it expects that
11495>>>>>// certain properties can be Get and Set via delegation.
11495>>>>>Class cDAWSQLDriverHelper is a cObject
11496>>>>>    
11496>>>>>    Function DriverIndex String sDriver Returns Integer
11498>>>>>        String  sCurrentDriver
11498>>>>>        Integer iNumberOfDrivers iDriver iCount
11498>>>>>        Move 0 to iDriver
11499>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
11502>>>>>        For iCount from 1 to iNumberOfDrivers
11508>>>>>>
11508>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
11511>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
11513>>>>>                Function_Return iCount
11514>>>>>            End
11514>>>>>>
11514>>>>>        Loop
11515>>>>>>
11515>>>>>        Function_Return 0
11516>>>>>    End_Function
11517>>>>>    
11517>>>>>    
11517>>>>>    // returns true if this table supports SQL filter interface
11517>>>>>    Function SupportsSQLFilters Returns Boolean
11519>>>>>        String sDriver
11519>>>>>        Integer iFile iDriver iConformance
11519>>>>>        Delegate Get Main_File to iFile
11521>>>>>        Get_Attribute DF_FILE_DRIVER of iFile to sDriver
11524>>>>>        Get DriverIndex sDriver to iDriver
11525>>>>>        If (iDriver) Begin
11527>>>>>            Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
11530>>>>>        End
11530>>>>>>
11530>>>>>        Function_Return (iConformance iand 4)
11531>>>>>    End_Function
11532>>>>>    
11532>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
11532>>>>>    
11532>>>>>    // Escape character to escape LIKE wildcards
11532>>>>>    
11532>>>>>    
11532>>>>>    Function SQLEscapedStr String sSQL Returns String
11534>>>>>        String sEscapedSQL
11534>>>>>        // Replace one single quote by 2 single quotes
11534>>>>>        Move (Replaces("'",sSQL,"''")) to sEscapedSQL
11535>>>>>        Function_Return sEscapedSQL
11536>>>>>    End_Function
11537>>>>>    
11537>>>>>    
11537>>>>>    Function SQLEscapeLikeWildcards String sSQL Returns String
11539>>>>>        
11539>>>>>        // Escape the wildcard characters than can be used in a LIKE
11539>>>>>        If (Pos("%",sSQL)) ;            Move (Replaces("%",sSQL,(SQL_LIKE_ESC + "%"))) to sSQL
11542>>>>>        If (Pos("_",sSQL)) ;            Move (Replaces("_",sSQL,(SQL_LIKE_ESC + "_"))) to sSQL
11545>>>>>        
11545>>>>>        Function_Return sSQL
11546>>>>>    End_Function
11547>>>>>    
11547>>>>>    
11547>>>>>    
11547>>>>>    // Creates an SQL Like Filter for this field and search target
11547>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
11549>>>>>        String sFilter sOrigFilter sField
11549>>>>>        Integer iFile
11549>>>>>        Integer iHasLikeEscape
11549>>>>>        String  sPrefix
11549>>>>>        
11549>>>>>        Delegate Get Main_File to iFile
11551>>>>>        Delegate Get psSQLFilter to sOrigFilter
11553>>>>>        Get SQLStrFieldName iField to sField
11554>>>>>        Get SQLEscapedStr sSearch to sSearch
11555>>>>>        
11555>>>>>        Move (Pos(SQL_LIKE_ESC,sSearch)) to iHasLikeEscape
11556>>>>>        If (not(iHasLikeEscape)) Begin
11558>>>>>            Get SQLEscapeLikeWildcards sSearch to sSearch
11559>>>>>        End
11559>>>>>>
11559>>>>>        
11559>>>>>        // Add the N prefix to properly handle Unicode data
11559>>>>>        Move 'N' to sPrefix
11560>>>>>        Move (sField + " LIKE " + sPrefix + "'%" + sSearch + "%'") to sFilter
11561>>>>>        
11561>>>>>        If (not(iHasLikeEscape)) Begin
11563>>>>>            If (Pos(SQL_LIKE_ESC,sFilter)) Begin
11565>>>>>                Move (sFilter + " ESCAPE '" + SQL_LIKE_ESC + "' "  ) to sFilter
11566>>>>>            End
11566>>>>>>
11566>>>>>        End
11566>>>>>>
11566>>>>>        
11566>>>>>        Function_Return sFilter
11567>>>>>    End_Function
11568>>>>>    
11568>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
11568>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
11570>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
11572>>>>>            Move ( "(" + sOrigFilter + ") AND " + sFilter) to sFilter
11573>>>>>        End
11573>>>>>>
11573>>>>>        Else If (sFilter="") Begin
11576>>>>>            Move sOrigFilter to sFilter
11577>>>>>        End
11577>>>>>>
11577>>>>>        Function_Return sFilter
11578>>>>>    End_Function
11579>>>>>    
11579>>>>>    // Appends two filters with an or clause. Both or either can be empty.
11579>>>>>    // This may be used in OnConstrain methods when building SQL WHERE clauses in string values.
11579>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
11581>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
11583>>>>>            Move ("(" + sOrigFilter + ") OR (" + sFilter + ")") to sFilter
11584>>>>>        End
11584>>>>>>
11584>>>>>        Else If (sFilter="") Begin
11587>>>>>            Move sOrigFilter to sFilter
11588>>>>>        End
11588>>>>>>
11588>>>>>          Function_Return sFilter 
11589>>>>>    End_Function
11590>>>>>
11590>>>>>
11590>>>>>    Function SQLIdentifierQuote Handle hTable Returns String
11592>>>>>
11592>>>>>        String  sDriver        
11592>>>>>        Integer iDriverIndex
11592>>>>>        Handle  hDatabase
11592>>>>>        String  sIdentifierQuote
11592>>>>>        
11592>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriver
11595>>>>>        
11595>>>>>        Get DriverIndex sDriver to iDriverIndex        
11596>>>>>        If (iDriverIndex) Begin
11598>>>>>            Get_Attribute DF_FILE_DATABASE_ID of hTable to hDatabase            
11601>>>>>            If (hDatabase) Begin
11603>>>>>                Get_Attribute DF_DATABASE_IDENTIFIER_QUOTE of iDriverIndex hDatabase to sIdentifierQuote
11606>>>>>            End
11606>>>>>>
11606>>>>>        End
11606>>>>>>
11606>>>>>        
11606>>>>>        Function_Return sIdentifierQuote
11607>>>>>        
11607>>>>>    End_Function
11608>>>>>
11608>>>>>
11608>>>>>
11608>>>>>    // returns the name of the File and Field suitable for an SQL where statement ("Table"."Column")
11608>>>>>    Function SQLStrFileFieldName Integer iField Returns String
11610>>>>>        String sFile sField
11610>>>>>        Integer iFile
11610>>>>>        String  sIdentifierQuote
11610>>>>>        
11610>>>>>        Get Main_File to iFile
11611>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11614>>>>>        Get_Attribute DF_FIELD_SQL_COLUMN_NAME of iFile iField to sField
11617>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11618>>>>>        
11618>>>>>        Function_Return (sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11619>>>>>    End_Function
11620>>>>>
11620>>>>>    // returns the name of the Field suitable for an SQL where statement ("Column")
11620>>>>>    Function SQLStrFieldName Integer iField Returns String
11622>>>>>        String sField 
11622>>>>>        Integer iFile
11622>>>>>        String sIdentifierQuote
11622>>>>>        Get Main_File to iFile
11623>>>>>        Get_Attribute DF_FIELD_SQL_COLUMN_NAME of iFile iField to sField
11626>>>>>        
11626>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11627>>>>>        
11627>>>>>        Function_Return (sIdentifierQuote + sField + sIdentifierQuote ) 
11628>>>>>
11628>>>>>    End_Function
11629>>>>>
11629>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement ("Schema"."Table"."Column")
11629>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
11631>>>>>        String sFile sField sSchema
11631>>>>>        Integer iFile
11631>>>>>        String sIdentifierQuote
11631>>>>>        
11631>>>>>        Get Main_File to iFile
11632>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11635>>>>>        Get_Attribute DF_FIELD_SQL_COLUMN_NAME of iFile iField to sField
11638>>>>>        Get_Attribute DF_FILE_OWNER of iFile to sSchema
11641>>>>>
11641>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11642>>>>>            
11642>>>>>        If (Trim(sSchema) <> "") ;            Function_Return (sIdentifierQuote + sSchema + sIdentifierQuote + '.' + sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11645>>>>>        Else ;            Function_Return (sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11647>>>>>            
11647>>>>>            
11647>>>>>            
11647>>>>>    End_Function
11648>>>>>    
11648>>>>>    //  returns the name of a file suitable for a SQL statement
11648>>>>>    Function SQLStrFileName Integer iField Returns String
11650>>>>>        String sFile
11650>>>>>        Integer iFile
11650>>>>>        String sIdentifierQuote
11650>>>>>        
11650>>>>>        Get Main_File to iFile
11651>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11654>>>>>        
11654>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11655>>>>>        
11655>>>>>        Function_Return (sIdentifierQuote + sFile + sIdentifierQuote)
11656>>>>>    End_Function
11657>>>>>    
11657>>>>>    // called before an SQL Filter find. Make sure that any global and table attributes are
11657>>>>>    // stored.
11657>>>>>    Procedure StoreDefaultSQLFilters
11659>>>>>        String sOldFilter
11659>>>>>        Boolean bOldFilterActive bOldFilterEQ
11659>>>>>        Integer iMain
11659>>>>>        Get Main_File to iMain
11660>>>>>        Get_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
11663>>>>>        Get_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
11666>>>>>        Get_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
11669>>>>>        Delegate Set psOldFilter to sOldFilter
11671>>>>>        Delegate Set pbOldFilterActive to bOldFilterActive
11673>>>>>        Delegate Set pbOldFilterEq to bOldFilterEQ
11675>>>>>    End_Procedure
11676>>>>>    
11676>>>>>    // called after an SQL find. Must restore the global and table SQL filter attributes
11676>>>>>    Procedure RestoreDefaultSQLFilters
11678>>>>>        String sOldFilter
11678>>>>>        Boolean bOldFilterActive bOldFilterEQ
11678>>>>>        Integer iMain
11678>>>>>        Delegate Get Main_File to iMain
11680>>>>>        Delegate Get psOldFilter to sOldFilter
11682>>>>>        Delegate Get pbOldFilterActive to bOldFilterActive
11684>>>>>        Delegate Get pbOldFilterEq to bOldFilterEQ
11686>>>>>        Set_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
11689>>>>>        Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
11692>>>>>        Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
11695>>>>>    End_Procedure
11696>>>>>    
11696>>>>>    // applies the passed SQL filter. If empty, it should make sure that no filter
11696>>>>>    // is applied. If non-empty it should set the filter active, set the filter string
11696>>>>>    // and make sure this is applied to all finds (including find EQ)
11696>>>>>    Procedure ApplySQLFilterStr String sFilter
11698>>>>>        Integer iMain
11698>>>>>        Delegate Get Main_File to iMain
11700>>>>>        If (sFilter<>"") Begin
11702>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to True
11705>>>>>            Set_Attribute DF_FILE_SQL_FILTER of iMain to sFilter
11708>>>>>            Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to True
11711>>>>>        End
11711>>>>>>
11711>>>>>        Else Begin
11712>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to False
11715>>>>>        End
11715>>>>>>
11715>>>>>    End_Procedure
11716>>>>>    
11716>>>>>End_Class
11717>>>>>
11717>>>>>// Every data_set will have a object based on this class. It will hold
11717>>>>>// the values for the fields, the entry_options and the messages IDs of the
11717>>>>>// iEntry, iExit and iValidate messages for each field.
11717>>>>>// It is assumed that an object of this class will always be used as a
11717>>>>>// child object of a Data_Set object.
11717>>>>>//
11717>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.
11717>>>>>//
11717>>>>>// ITEM-PROPERTY   ASSIGNED-FUNCTION
11717>>>>>//
11717>>>>>// Value           The value of the field. Will be updated whenever the
11717>>>>>//                 value of a field changes due to data-entry or a found
11717>>>>>//                 record.
11717>>>>>// Data_File       Contains the filenumber. Is the same for every item.
11717>>>>>// Data_Field      Contains the fieldnumber for the item. Is equal to the
11717>>>>>//                 items' itemnumber.
11717>>>>>// Item_Options    Used to store the standard item-options of a field.
11717>>>>>// Aux_Value       Used to store the foreign-item-options of a field.
11717>>>>>Class cRecordBuffer is an cDDBuffer
11718>>>>>    
11718>>>>>    // This procedure will be called from the Data_Set when the Main_File is
11718>>>>>    // being set. It will create an item for each field of the file in this
11718>>>>>    // object. Fields of the types DF_OVERLAP, DF_TEXT and DF_BINARY are
11718>>>>>    // currently not added.
11718>>>>>    Procedure Create_Items Integer iFile
11720>>>>>        Integer iField_Count iField
11720>>>>>        
11720>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iField_Count
11723>>>>>        Set Main_File to iFile
11724>>>>>        Send Delete_Data
11725>>>>>        Set Item_Count to (iField_Count+1)
11726>>>>>        For iField from 0 to iField_Count
11732>>>>>>
11732>>>>>            // will skip recnum (field 0) if non-recnum table
11732>>>>>            // will set to skip if binary, text or overlap
11732>>>>>            Set Data_Field iField to iField
11733>>>>>        Loop
11734>>>>>>
11734>>>>>    End_Procedure
11735>>>>>    
11735>>>>>    // when an alias is created, we want to clear any values that will not be applied to
11735>>>>>    // this alias DD such as prompt and zoom objects (which would point to the superclass master)
11735>>>>>    Procedure ReDefineAliasItems Integer iFile
11737>>>>>        Integer i iItems
11737>>>>>        
11737>>>>>        Set Main_File to iFile
11738>>>>>        Get item_count to iItems
11739>>>>>        For i from 0 to (iItems-1)
11745>>>>>>
11745>>>>>            Set Prompt_Object i to 0
11746>>>>>            Set Zoom_Object i to 0
11747>>>>>        Loop
11748>>>>>>
11748>>>>>    End_Procedure
11749>>>>>    
11749>>>>>    
11749>>>>>    // This procedure will be called from the parent Data_Set whenever the
11749>>>>>    // Data_Set changes its Current_Record property, or after a Save, Delete or Clear operation.
11749>>>>>    // We use this event to store the values of the fields in our local record buffer.
11749>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
11751>>>>>        Integer iMain_File
11751>>>>>        Integer iOldState
11751>>>>>        tDDRemembered[] DefaultValues
11751>>>>>        tDDRemembered[] DefaultValues
11752>>>>>        Boolean bRetain bInReSync
11752>>>>>        Integer iFld iFlds iIndex
11752>>>>>        Handle hoDD
11752>>>>>        
11752>>>>>        Get Parent to hoDD
11753>>>>>        Delegate Get Main_File to iMain_File
11755>>>>>        
11755>>>>>        If not (IsNullRowId(riNew)) ;            Send Entry_Display
11758>>>>>        Else Begin            
11759>>>>>            If (OPERATION_ORIGIN) Begin
11761>>>>>                // This gets set by webapp during a resync. During resyncs, you don't want to rely
11761>>>>>                // on the values in the buffers (as they may not be yours), so you cannot do retain of rememberlast.
11761>>>>>                // Fortunately, you don't need to, as this information is not needed during a resync.
11761>>>>>                Get pbInResync of operation_origin to bInResync
11762>>>>>            End
11762>>>>>>
11762>>>>>            
11762>>>>>            // If we have any 17.0 Remember last value items, we must add those items to our array.
11762>>>>>            // Only do this if this is the operation origin or a parent (i.e., skip if a child DDO).
11762>>>>>            // Also skip if a resync. See above
11762>>>>>            If ( not(bInReSync) and ;                ( (Operation_Origin=hoDD) or ;                ( OPERATION_ORIGIN and (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ) Begin
11764>>>>>                Delegate Get pDDDefaults to DefaultValues
11766>>>>>                Move (SizeOfArray(DefaultValues)) to iFlds
11767>>>>>                For iFld from 0 to (iFlds-1)
11773>>>>>>
11773>>>>>                    Move (DefaultValues[iFld].sDefault=DD_RememberLast) to bRetain // if this is a dynamically assigned remember-last
11774>>>>>                    If bRetain Begin
11776>>>>>                        Get Value DefaultValues[iFld].iField to DefaultValues[iFld].sLastValue
11777>>>>>                    End
11777>>>>>>
11777>>>>>                    Else Begin
11778>>>>>                        Move '' to DefaultValues[iFld].sLastValue
11779>>>>>                    End
11779>>>>>>
11779>>>>>                Loop
11780>>>>>>
11780>>>>>                Delegate Set pDDDefaults to DefaultValues
11782>>>>>            End
11782>>>>>>
11782>>>>>            
11782>>>>>            // we must do this to make retains not set changed_state
11782>>>>>            Delegate Get Change_Disabled_State to iOldState
11784>>>>>            Delegate Set Change_Disabled_State to True
11786>>>>>            // If mode is anything other than clear, we do a clear all (clear keeps retains, clear all does not)
11786>>>>>            // Also do clear all if the DDO is foreign.
11786>>>>>            
11786>>>>>            // If bInReSync, we never use retains, as the buffer is not ours yet.
11786>>>>>            // The Entry_Clear, Entry_Clear_All parameter is bIgnoreRetains.
11786>>>>>            // When True, retain and retain_all states are ignored and cleared.
11786>>>>>            If (Operation_Mode=MODE_CLEARING and ;                ( (Operation_Origin=parent(Self)) or ;                (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) Begin
11788>>>>>                    Send Entry_Clear bInReSync
11789>>>>>            End
11789>>>>>>
11789>>>>>            Else Begin
11790>>>>>                Send Entry_Clear_all bInResync
11791>>>>>            End
11791>>>>>>
11791>>>>>            Delegate Set Change_Disabled_State to iOldState
11793>>>>>            Set Changed_State to False
11794>>>>>        End
11794>>>>>>
11794>>>>>    End_Procedure
11795>>>>>    
11795>>>>>    // Make sure to set the Changed_State of the Data_Set to TRUE when a
11795>>>>>    // field value changes and it's not during the Setting of the Defaults.
11795>>>>>    Procedure Set Changed_State Integer iState
11797>>>>>        Integer iNoChange
11797>>>>>        // Server.pkg in dso already knows this property
11797>>>>>        Delegate Get Change_disabled_State to iNoChange
11799>>>>>        If not iNoChange Begin
11801>>>>>            Forward Set Changed_State to iState
11803>>>>>            Delegate Set Changed_State to iState
11805>>>>>        End
11805>>>>>>
11805>>>>>    End_Procedure
11806>>>>>    
11806>>>>>End_Class
11807>>>>>
11807>>>>>
11807>>>>>// Objects of this class will be used to store all kinds of attributes
11807>>>>>// which belong to a field.
11807>>>>>//
11807>>>>>// FA_MIN_VALUE
11807>>>>>// Used to store the mininum value of field.
11807>>>>>//
11807>>>>>// FA_MAX_VALUE
11807>>>>>// Used to store the maximum value of a field.
11807>>>>>//
11807>>>>>// FA_CHECK_VALUE
11807>>>>>// Used to store a string which contains all possible values of a field.
11807>>>>>//
11807>>>>>// FA_CHECKBOX_TRUE
11807>>>>>// Used to store the TRUE value for a checkbox field
11807>>>>>//
11807>>>>>// FA_CHECKBOX_FALSE
11807>>>>>// Used to store the FALSE value of a checkbox field
11807>>>>>//
11807>>>>>// FA_TABLE_OBJECT
11807>>>>>// Stores object Id of a validation table.
11807>>>>>//
11807>>>>>// FA_ERROR_MESSAGE
11807>>>>>// Used to store a error text which will be shown to a user when a fields
11807>>>>>// value violates one of the rules defined for it.
11807>>>>>// This field may contain the special strings @MIN, @MAX and @CHECK. When
11807>>>>>// these are used, these will be replaced by the actual value of MIN_VALUE,
11807>>>>>// MAX_VALUE or CHECK_VALUE.
11807>>>>>//
11807>>>>>
11807>>>>>
11807>>>>>// Validation Types
11807>>>>>Enumeration_List
11807>>>>>    Define FA_VALIDATION_TYPE_NONE
11807>>>>>    Define FA_VALIDATION_TYPE_RANGE
11807>>>>>    Define FA_VALIDATION_TYPE_CHECK
11807>>>>>    Define FA_VALIDATION_TYPE_CHECKBOX
11807>>>>>    Define FA_VALIDATION_TYPE_TABLE
11807>>>>>End_Enumeration_List
11807>>>>>
11807>>>>>
11807>>>>>Class Field_Attributes is a Array
11808>>>>>    
11808>>>>>    Procedure Construct_Object
11810>>>>>        Forward Send Construct_Object
11812>>>>>        // Private: This replaces the use of arrays to get at this value. This
11812>>>>>        // allows us to find specific validation types (like checkboxes) more
11812>>>>>        // quickly than scanning an array
11812>>>>>        Property String Private.Validation_Types     ''
11813>>>>>    End_Procedure
11814>>>>>    
11814>>>>>    // Returns the extended validation type for the passed field.
11814>>>>>    Function Field_Validation_Type Integer iField Returns Integer
11816>>>>>        Integer iType
11816>>>>>        If iField ;            Move (mid(Private.Validation_Types(Self),1,iField)) to iType
11819>>>>>        Else ;            Move FA_VALIDATION_TYPE_NONE to iType
11821>>>>>        Function_Return iType
11822>>>>>    End_Function
11823>>>>>    
11823>>>>>    Procedure Set Field_Validation_Type Integer iField String sType
11825>>>>>        Integer iType
11825>>>>>        String sTypes
11825>>>>>        If iField Begin
11827>>>>>            Get Private.Validation_Types to sTypes
11828>>>>>            Set Private.Validation_Types to (Overstrike(sType, sTypes, iField))
11829>>>>>        End
11829>>>>>>
11829>>>>>    End_Procedure
11830>>>>>    
11830>>>>>    // Set any defaults required by this class when the main file is created.
11830>>>>>    // Create a string which contains all validation types. Set all to
11830>>>>>    // No extended validation type.
11830>>>>>    Procedure Create_Items
11832>>>>>        String  sType
11832>>>>>        Integer iCount
11832>>>>>        Delegate Get Field_Count to iCOunt
11834>>>>>        Move FA_VALIDATION_TYPE_NONE to sType
11835>>>>>        Set Private.Validation_Types to (Repeat(sType,iCount))
11836>>>>>    End_Procedure
11837>>>>>    
11837>>>>>    // Return field number of next field matching the passed validation type.
11837>>>>>    // Pass validation type and last position checked. Return 0 if no match
11837>>>>>    Function Next_Validation_Type String sType Integer iOffset Returns Integer
11839>>>>>        String sTypes
11839>>>>>        Integer iPos
11839>>>>>        Get Private.Validation_Types to sTypes
11840>>>>>        Move (Pos(sType, mid(sTypes,255,iOffset+1))) to iPos
11841>>>>>        If iPos ;            Add iOffset to iPos
11844>>>>>        Function_Return iPos
11845>>>>>    End_Function
11846>>>>>    
11846>>>>>    // This procedure will be called by the Extended_Data_Set to set the
11846>>>>>    // errornumber and message which will be triggered when it needs to.
11846>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
11848>>>>>        Integer iBase
11848>>>>>        Move (iField * FA_COUNT) to iBase
11849>>>>>        Set Value (iBase + FA_ERROR_NUMBER) to iErr
11850>>>>>        Set Value (iBase + FA_ERROR_MESSAGE) to sMsg
11851>>>>>    End_Procedure
11852>>>>>    
11852>>>>>    // Used to retreive the error number and message for a particular field
11852>>>>>    Function Field_Error_Number Integer iField Returns Integer
11854>>>>>        Integer iErr
11854>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_NUMBER)  to iErr
11855>>>>>        Function_Return iErr
11856>>>>>    End_Function
11857>>>>>    
11857>>>>>    Function Field_Error_Message Integer iField Returns String
11859>>>>>        String sValue
11859>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_MESSAGE) to sValue
11860>>>>>        Function_Return sValue
11861>>>>>    End_Function
11862>>>>>    
11862>>>>>    
11862>>>>>    // This function manages the validation of a field against its extended
11862>>>>>    // validations.
11862>>>>>    Function Validate_Field Integer iField Returns Integer
11864>>>>>        Integer iType
11864>>>>>        Integer iResult
11864>>>>>        Get Field_Validation_Type iField to iType
11865>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Get Validate_Field_Range iField to iResult
11868>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Get Validate_Field_Check iField to iResult
11872>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Get Validate_Field_Checkbox iField to iResult
11876>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Validate_Field_Table iField to iResult
11880>>>>>        Function_Return iResult
11881>>>>>    End_Function
11882>>>>>    
11882>>>>>    // All extended validations know how to send callback messages (iMsg) to
11882>>>>>    // the calling object (iObj). This allows external lists to get filled w/
11882>>>>>    // the contents of a range. Used by combo boxes, spinners, etc.
11882>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
11884>>>>>        Integer iType
11884>>>>>        Integer iResult
11884>>>>>        Get Field_Validation_Type iField to iType
11885>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Send Field_Fill_List_Field_Range iField iObj iMsg
11888>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Send Field_Fill_List_Field_Check iField iObj iMsg
11892>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Send Field_Fill_List_Field_Checkbox iField iObj iMsg
11896>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Send Field_Fill_List_Field_Table iField iObj iMsg
11900>>>>>    End_Procedure
11901>>>>>    
11901>>>>>    // Return the id of the validation table if one exists. Otherwise return
11901>>>>>    // a zero.
11901>>>>>    Function Field_Table_Object Integer iField Returns Integer
11903>>>>>        Integer iType
11903>>>>>        Integer iObj
11903>>>>>        Integer iBase
11903>>>>>        Move (iField * FA_COUNT) to iBase
11904>>>>>        Get Field_Validation_Type iField to iType
11905>>>>>        If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Value (iBase + FA_TABLE_OBJECT) to iObj
11908>>>>>        Function_Return iObj
11909>>>>>    End_Function
11910>>>>>    
11910>>>>>    // Procedure to set the range for a field. It will automatically set the
11910>>>>>    // validation type of the field as well.
11910>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
11912>>>>>        Integer iBase
11912>>>>>        Move (iField * FA_COUNT) to iBase
11913>>>>>        Set Value (iBase + FA_MIN_VALUE) to sMin
11914>>>>>        Set Value (iBase + FA_MAX_VALUE) to sMax
11915>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_RANGE
11916>>>>>    End_Procedure
11917>>>>>    
11917>>>>>    // Function to check a fields value agains a given check string.
11917>>>>>    Function Validate_Field_Range Integer iField Returns Integer
11919>>>>>        String  sMin
11919>>>>>        String  sMax
11919>>>>>        String  sValue
11919>>>>>        Integer iField_Type
11919>>>>>        Integer iResult
11919>>>>>        Integer iFile
11919>>>>>        Integer iBase
11919>>>>>        Move (iField * FA_COUNT) to iBase
11920>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
11921>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
11922>>>>>        Delegate Get Field_Current_Value iField to sValue
11924>>>>>        Delegate Get Main_File to iFile
11926>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
11929>>>>>        Move 0 to iResult
11930>>>>>        If (iField_Type=DF_ASCII) ;            Move (sValue < sMin or sValue > sMax) to iResult
11933>>>>>        Else If (iField_Type=DF_BCD) ;            Move (Number(sValue) < Number(sMin) or ;            Number(sValue) > Number(sMax)) to iResult
11937>>>>>        Else If (iField_Type=DF_DATE) ;            Move (Date(sValue) < Date(sMin) or Date(sValue) > Date(sMax)) to iResult
11941>>>>>        Else If (iField_Type=DF_DATETIME) ;            Move (Cast(sValue,DateTime) < Cast(sMin,DateTime) or Cast(sValue,DateTime) > Cast(sMax,DateTime)) to iResult
11945>>>>>        If iResult Begin
11947>>>>>            Delegate Send Field_Error iField DD_INVALID_RANGE sMin sMax
11949>>>>>            Function_Return 1
11950>>>>>        End
11950>>>>>>
11950>>>>>    End_Function
11951>>>>>    
11951>>>>>    // Callback to provide all valid value for this validation.
11951>>>>>    // Just call back with the two range values
11951>>>>>    Procedure Field_Fill_List_Field_Range Integer iField Integer iObj Integer iMsg
11953>>>>>        String  sMin
11953>>>>>        String  sMax
11953>>>>>        Integer iBase
11953>>>>>        Move (iField * FA_COUNT) to iBase
11954>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
11955>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
11956>>>>>        Send iMsg to iObj 0 sMin '' 0 (NullrowId())
11957>>>>>        Send iMsg to iObj 1 sMax '' 0 (NullrowId())
11958>>>>>    End_Procedure
11959>>>>>    
11959>>>>>    // Procedure to set the check for a field. It will automatically set the
11959>>>>>    // validation type of the field as well.
11959>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
11961>>>>>        Integer iBase
11961>>>>>        Move (iField * FA_COUNT) to iBase
11962>>>>>        Set Value (iBase + FA_CHECK_VALUE) to sCheck
11963>>>>>        //Set Value iBase to FA_VALIDATION_TYPE_CHECK
11963>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECK
11964>>>>>    End_Procedure
11965>>>>>    
11965>>>>>    // Function to check a fields value agains a given check string.
11965>>>>>    Function Validate_Field_Check Integer iField Returns Integer
11967>>>>>        String  sCheck
11967>>>>>        String  sValue
11967>>>>>        Integer iBase
11967>>>>>        Integer iPos
11967>>>>>        Integer iLength
11967>>>>>        Integer iResult
11967>>>>>        Integer iFile
11967>>>>>        Move (iField * FA_COUNT) to iBase
11968>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
11969>>>>>        Delegate Get Field_Current_Value iField to sValue
11971>>>>>        Delegate Get Main_File to iFile
11973>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
11976>>>>>        Move (Pad( sValue,iLength)) to sValue
11977>>>>>        // Replace the seperation characters with two of them so the user
11977>>>>>        // can't bypass the check by entering a seperation character.
11977>>>>>        Move (Replaces("|", sValue, "||")) to sValue
11978>>>>>        // Report an error if rules are violated.
11978>>>>>        Move (Pos( sValue, sCheck)) to iPos
11979>>>>>        If not iPos Begin
11981>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECK sCheck
11983>>>>>            Function_Return 1
11984>>>>>        End
11984>>>>>>
11984>>>>>    End_Function
11985>>>>>    
11985>>>>>    // Callback to provide all valid value for this validation.
11985>>>>>    // Call back with all valid check values
11985>>>>>    Procedure Field_Fill_List_Field_Check Integer iField Integer iObj Integer iMsg
11987>>>>>        String  sCheck
11987>>>>>        Integer iBase
11987>>>>>        Integer iPos
11987>>>>>        Integer iItem
11987>>>>>        Move (iField * FA_COUNT) to iBase
11988>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
11989>>>>>        Append sCheck "|"
11990>>>>>        Move (Pos( "|", sCheck)) to iPos
11991>>>>>        While iPos
11995>>>>>            If (iPos > 1) Begin
11997>>>>>                Send iMsg to iObj iItem (Left(sCheck,iPos-1)) '' 0 (NullrowId())
11998>>>>>                Increment iItem
11999>>>>>            End
11999>>>>>>
11999>>>>>            Move (Mid( sCheck, 255, iPos+1))  to sCheck
12000>>>>>            Move (Pos( "|", sCheck)) to iPos
12001>>>>>        Loop
12002>>>>>>
12002>>>>>    End_Procedure
12003>>>>>    
12003>>>>>    // Procedure to set up a checkbox field. We will store the TRUE and FALSE
12003>>>>>    // Values in the extended array.
12003>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
12005>>>>>        Integer iBase
12005>>>>>        Move (iField * FA_COUNT) to iBase
12006>>>>>        Set Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12007>>>>>        Set Value (iBase + FA_CHECKBOX_FALSE) to sFalse
12008>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECKBOX
12009>>>>>    End_Procedure
12010>>>>>    
12010>>>>>    // Return the Value associated with the field and its select-state.
12010>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
12012>>>>>        Integer iBase
12012>>>>>        Integer iType
12012>>>>>        String sValue
12012>>>>>        Move (iField * FA_COUNT) to iBase
12013>>>>>        Get Field_Validation_Type iField to iType
12014>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move iState to sValue
12017>>>>>        Else ;            Get Value (iBase + If(iState,FA_CHECKBOX_TRUE,FA_CHECKBOX_FALSE));            to sValue
12019>>>>>        Function_Return sValue
12020>>>>>    End_Function
12021>>>>>    
12021>>>>>    // Return the select_state based on the passed value and field
12021>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
12023>>>>>        Integer iBase
12023>>>>>        Integer iType
12023>>>>>        String  sTrue
12023>>>>>        Integer iState
12023>>>>>        Integer iFile
12023>>>>>        Integer iField_Type
12023>>>>>        Move (iField * FA_COUNT) to iBase
12024>>>>>        Get Field_Validation_Type iField to iType
12025>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12026>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move (not(sValue=0 or sValue='')) to iState
12029>>>>>        Else Begin
12030>>>>>            Delegate Get Main_File to iFile
12032>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
12035>>>>>            If (iField_Type = DF_BCD) ;                Move (Number(sValue)=Number(sTrue)) to iState
12038>>>>>            Else ; // DF_ASCII                Move (sValue=sTrue) to iState
12040>>>>>        End
12040>>>>>>
12040>>>>>        Function_Return iState
12041>>>>>    End_Function
12042>>>>>    
12042>>>>>    
12042>>>>>    // Check that the buffer value is one of the two checkbox values.
12042>>>>>    Function Validate_Field_Checkbox Integer iField Returns Integer
12044>>>>>        String  sTrue
12044>>>>>        String  sFalse
12044>>>>>        String  sValue
12044>>>>>        Integer iField_Type
12044>>>>>        Integer iResult
12044>>>>>        Integer iFile
12044>>>>>        Integer iBase
12044>>>>>        Move (iField * FA_COUNT) to iBase
12045>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12046>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
12047>>>>>        Delegate Get Field_Current_Value iField to sValue
12049>>>>>        Delegate Get Main_File to iFile
12051>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
12054>>>>>        Move 0 to iResult
12055>>>>>        If (iField_Type = DF_BCD) ;            Move (Number(sValue)=Number(sTrue) or ;            Number(sValue)=Number(sFalse)) to iResult
12058>>>>>        Else ; // DF_ASCII            Move (sValue=sTrue or sValue=sFalse) to iResult
12060>>>>>        If not iResult Begin
12062>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECKBOX sTrue sFalse
12064>>>>>            Function_Return 1
12065>>>>>        End
12065>>>>>>
12065>>>>>    End_Function
12066>>>>>    
12066>>>>>    // Callback to provide all valid value for this validation.
12066>>>>>    // Just call back with the two true and false values
12066>>>>>    Procedure Field_Fill_List_Field_Checkbox Integer iField Integer iObj Integer iMsg
12068>>>>>        String  sTrue
12068>>>>>        String  sFalse
12068>>>>>        Integer iBase
12068>>>>>        Move (iField * FA_COUNT) to iBase
12069>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12070>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
12071>>>>>        Send iMsg to iObj 0 sTrue '' 0 (NullrowId())
12072>>>>>        Send iMsg to iObj 1 sFalse '' 0 (NullrowId())
12073>>>>>    End_Procedure
12074>>>>>    
12074>>>>>    // The object keeps track of a validation table object. This table object
12074>>>>>    // can be any type of object must at a minimum understand a small message
12074>>>>>    // protocol (see xvaltbl.pkg for info)
12074>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
12076>>>>>        Integer iBase
12076>>>>>        Move (iField * FA_COUNT) to iBase
12077>>>>>        Set Value (iBase + FA_TABLE_OBJECT) to iObj
12078>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_TABLE
12079>>>>>    End_Procedure
12080>>>>>    
12080>>>>>    // This valdates against a validation table if appropriate (if a table
12080>>>>>    // exists and the table's validate_State is T). It validates by passing
12080>>>>>    // the message validate_value to the validation table object
12080>>>>>    Function Validate_Field_Table Integer iField Returns Integer
12082>>>>>        Integer iBase
12082>>>>>        Integer iTableObj
12082>>>>>        String  sValue
12082>>>>>        Integer iResult
12082>>>>>        Move (iField * FA_COUNT) to iBase
12083>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
12084>>>>>        If (iTableObj and Validate_State(iTableObj) ) Begin
12086>>>>>            Delegate Get Field_Current_Value iField to sValue
12088>>>>>            Get Validate_Value of iTableOBj sValue to iResult
12089>>>>>            If iResult ;                Delegate Send Field_Error iField DD_INVALID_VALUE_TABLE
12093>>>>>        End
12093>>>>>>
12093>>>>>        Function_Return iResult
12094>>>>>    End_Function
12095>>>>>    
12095>>>>>    // Callback to provide all valid value for this validation.
12095>>>>>    // Pass the request on to the validation table. This is the most common
12095>>>>>    // use of this.
12095>>>>>    Procedure Field_Fill_List_Field_Table Integer iField Integer iObj Integer iMsg
12097>>>>>        Integer iBase
12097>>>>>        Integer iTableObj
12097>>>>>        Move (iField * FA_COUNT) to iBase
12098>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
12099>>>>>        If iTableObj ;            Send Request_Fill_From_List to iTableObj iObj iMsg
12102>>>>>    End_Procedure
12103>>>>>    
12103>>>>>    // Often extended valditation types can provide automatic prompt
12103>>>>>    // objects. If the extended type supports a prompt object and there is
12103>>>>>    // a global validation_list object, we will use it
12103>>>>>    Function Prompt_Object Integer iField Returns Integer
12105>>>>>        Integer iType
12105>>>>>        Integer iObj
12105>>>>>        Get Field_Validation_Type iField to iType
12106>>>>>        If not (iType=FA_VALIDATION_TYPE_NONE or iType=FA_VALIDATION_TYPE_RANGE) ;            Move DD_Global_Validation_Prompt_Object to iObj
12109>>>>>        Function_Return iObj
12110>>>>>    End_Function
12111>>>>>    
12111>>>>>    
12111>>>>>End_Class
12112>>>>>
12112>>>>>
12112>>>>>
12112>>>>>// use to keep track of file field pairs such as system file file/field
12112>>>>>Struct tDDFileField
12112>>>>>    Integer iFile
12112>>>>>    Integer iField
12112>>>>>End_Struct
12112>>>>>
12112>>>>>Class Field_Mask_Array is an Array
12113>>>>>    
12113>>>>>    Function Array_Name Integer iField Integer iType Returns String
12115>>>>>        String sName
12115>>>>>        Move (iField*FMA_COUNT+iType) to iField
12116>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to sName
12119>>>>>        // sometimes an array value that is undefined returns a 0, we must change this to ''
12119>>>>>        If (sName = '0') ;            Move '' to sName
12122>>>>>        Function_Return sName
12123>>>>>    End_Function
12124>>>>>    
12124>>>>>    
12124>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
12126>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_TYPE) to iType
12127>>>>>    End_Procedure
12128>>>>>    
12128>>>>>    Function Field_Mask_Type Integer iField Returns Integer
12130>>>>>        Integer iType
12130>>>>>        Move (iField*FMA_COUNT+FMA_MASK_TYPE) to iField
12131>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iType
12134>>>>>        Function_Return iType
12135>>>>>    End_Function
12136>>>>>    
12136>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
12138>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iState
12139>>>>>    End_Procedure
12140>>>>>    
12140>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
12142>>>>>        Integer iState
12142>>>>>        Move (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iField
12143>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iState
12146>>>>>        Function_Return iState
12147>>>>>    End_Function
12148>>>>>    
12148>>>>>    Procedure Set Field_Mask Integer iField String sMask
12150>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK) to sMask
12151>>>>>    End_Procedure
12152>>>>>    
12152>>>>>    Function Field_Mask Integer iField Returns String
12154>>>>>        Function_Return (Array_Name(Self,iField,FMA_MASK))
12155>>>>>    End_Function
12156>>>>>    
12156>>>>>    Procedure Set Field_Label_Short Integer iField String sName
12158>>>>>        Set Value (iField*FMA_COUNT+FMA_SHORT_NAME) to sName
12159>>>>>    End_Procedure
12160>>>>>    
12160>>>>>    Function Field_Label_Short Integer iField Returns String
12162>>>>>        Function_Return (Array_Name(Self,iField,FMA_SHORT_NAME))
12163>>>>>    End_Function
12164>>>>>    
12164>>>>>    Procedure Set Field_Label_Long Integer iField String sName
12166>>>>>        Set Value (iField*FMA_COUNT+FMA_LONG_NAME) to sName
12167>>>>>    End_Procedure
12168>>>>>    
12168>>>>>    Function Field_Label_Long Integer iField Returns String
12170>>>>>        Function_Return (Array_Name(Self,iField,FMA_LONG_NAME))
12171>>>>>    End_Function
12172>>>>>    
12172>>>>>    Procedure Set Field_Class_Name Integer iField String sName
12174>>>>>        Set Value (iField*FMA_COUNT+FMA_CLASS_NAME) to sName
12175>>>>>    End_Procedure
12176>>>>>    
12176>>>>>    Function Field_Class_Name Integer iField Returns String
12178>>>>>        Function_Return (Array_Name(Self,iField,FMA_CLASS_NAME))
12179>>>>>    End_Function
12180>>>>>    
12180>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoPrompt
12182>>>>>        Set Value (iField*FMA_COUNT+FMA_WEBPROMPTOBJECT) to hoPrompt
12183>>>>>    End_Procedure
12184>>>>>    
12184>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
12186>>>>>        Function_Return (Array_Name(Self,iField,FMA_WEBPROMPTOBJECT))
12187>>>>>    End_Function
12188>>>>>    
12188>>>>>End_Class
12189>>>>>
12189>>>>>Class DataDictionary is a DataSet
12190>>>>>    
12190>>>>>    Procedure Construct_Object
12192>>>>>        Forward Send Construct_Object
12194>>>>>        
12194>>>>>        Property String  Existing_Key_Value                           ""
12195>>>>>        Property Integer Protect_Key_State                            True
12196>>>>>        
12196>>>>>        Property String  Key_Fields                                   ""
12197>>>>>        
12197>>>>>        // These are added to support the checking of DSO connections
12197>>>>>        // during deletes and saves. Only the first two properties are Public
12197>>>>>        Property Integer Validate_Save_Structure_Mode   DD_Validate_Structure_Once
12198>>>>>        Property Integer Validate_Delete_Structure_Mode DD_Validate_Structure_Once
12199>>>>>        Property Integer Save_Structure_Validated_State              False
12200>>>>>        Property Integer Cascade_Delete_Structure_Validated_State    False
12201>>>>>        Property Integer No_Cascade_Delete_Structure_Validated_State False
12202>>>>>        
12202>>>>>        Property Integer Last_Mark_Sequence_Id                       0
12203>>>>>        
12203>>>>>        // These are added for optimized traversal of
12203>>>>>        // entry-update and validation and maybe more
12203>>>>>        Property String  Visited_Fields          ""
12204>>>>>        Property Integer Visited_State           False
12205>>>>>        // means will be part of a downward delete (cascade deletable). This only has meaning
12205>>>>>        // when cascade_delete_state is True
12205>>>>>        Property Boolean DownDelete_State        False
12206>>>>>        
12206>>>>>        // these are set by the define_auto_increment, which is obsolete and has been replaced
12206>>>>>        // the Set Field_auto_increment method.
12206>>>>>        Property Integer Auto_Increment_Source_File  0
12207>>>>>        Property Integer Auto_Increment_Source_Field 0
12208>>>>>        Property Integer Auto_Increment_Dest_Field   0
12209>>>>>        
12209>>>>>        // used by the set Field_auto_increment method
12209>>>>>        // these are split into two arrays to make searching for the field easier
12209>>>>>        // the arrays should always be synched.
12209>>>>>        Property Integer[] pAutoIncrementFields
12210>>>>>        Property tDDFileField[] pAutoIncrementSysFileFields
12211>>>>>        
12211>>>>>        // Error Reporting Related
12211>>>>>        // If DD_Error_No_Report errors would be supressed (only ERR gets set)
12211>>>>>        Property Integer Error_Report_Mode           DD_Error_Report
12212>>>>>        
12212>>>>>        // During validation, this is the field being validated.
12212>>>>>        Property Integer Current_Validate_Field      0
12213>>>>>        
12213>>>>>        // when errors are redirected locally this maintains the original handler.
12213>>>>>        Property Integer Old_Error_Object_Id         0
12214>>>>>        
12214>>>>>        // Must be provided if local error handler is to be created
12214>>>>>        Property Integer Error_Processing_State      0
12215>>>>>        
12215>>>>>        // These should be changed most carefully and possible only and the
12215>>>>>        // DSO level. These allow you to defeat full field validation which
12215>>>>>        // makes it easier to corrupt data! Validate_DEO_Only_State limits
12215>>>>>        // save validation to DEOs (which is what data-sets have always done).
12215>>>>>        // Validate_foreign_File_State will skip validation under the following
12215>>>>>        // conditions: 1) DSO if for a parent (it did not originate the save).
12215>>>>>        //
12215>>>>>        Property Integer Validate_DEOs_Only_State    False
12216>>>>>        Property Integer Validate_Foreign_File_State True
12217>>>>>        // if set true, a field validation requested started with this
12217>>>>>        // DD will check all fields, even in an error is encountered
12217>>>>>        Property Integer Validate_All_Fields_State   False
12218>>>>>        
12218>>>>>        // If true, all entry updates will occur through the DD. Else
12218>>>>>        // saves occur through the DD and find occur through the DEOs
12218>>>>>        Property Integer EntryUpdateLocalState True // changed from false to true in 17.0
12219>>>>>        
12219>>>>>        // can be used by Refind_records method (remote refind of recs). Obsolete. Use prFindRowId
12219>>>>>        Property Integer Find_Record_Id 0
12220>>>>>        
12220>>>>>        // can be used by Refind_records method (remote refind of recs)
12220>>>>>        Property RowID prFindRowId (NullRowId())
12221>>>>>        // can be used by Refind_records method (remote refind of recs)
12221>>>>>        Property tDDChangedInfo pDDChangedInfo
12222>>>>>        
12222>>>>>        // Private: Id of field_objects container. This is not created until needed
12222>>>>>        Property Integer Field_Objects 0
12223>>>>>        
12223>>>>>        // Public: If set the DDO will never be foreign, allowing
12223>>>>>        // you to create new parents when a child is saved. This would
12223>>>>>        // normally only be set within the DDO and not the class. This would be
12223>>>>>        // used where a child table wants to save the parent (header) when the
12223>>>>>        // first child is saved. It would disable the foreign key and index
12223>>>>>        // find_Req and required settings (as well as any displayonly).
12223>>>>>        Property Integer Allow_Foreign_New_Save_State False
12224>>>>>        
12224>>>>>        Set pbDDAttach to True // set false to get (very) old attach_main_file_behavior
12225>>>>>        Set pbSmartRelate to True // Only relate if parent is attached via a DDO
12226>>>>>        
12226>>>>>        // If this is an alias file, this is the master file it is based on
12226>>>>>        Property Handle piMasterTable 0
12227>>>>>        
12227>>>>>        Property tDDServerInformation[] pServerInformation
12228>>>>>        
12228>>>>>        Property tDDRemembered[] pDDDefaults
12229>>>>>        
12229>>>>>        Property Boolean pbInSuperFind False
12230>>>>>        
12230>>>>>        // Create the local buffer.
12230>>>>>        Object Record_Buffer is a cRecordBuffer
12232>>>>>        End_Object
12233>>>>>        
12233>>>>>        // Create the extended field attributes array.
12233>>>>>        Object Field_Attributes is a Field_Attributes
12235>>>>>        End_Object
12236>>>>>        
12236>>>>>        // Create an array to maintain Status help values for each field
12236>>>>>        Object Statushelp_Array is an array
12238>>>>>        End_Object
12239>>>>>        
12239>>>>>        Object FieldMask_Array is an Field_Mask_array
12241>>>>>        End_Object
12242>>>>>        
12242>>>>>        
12242>>>>>        // keep track of all system/unknown files that must be set to
12242>>>>>        // default for smart file mode to work right.
12242>>>>>        Object System_File_obj is an Array
12244>>>>>        End_Object
12245>>>>>        
12245>>>>>        // used during Request_Validate
12245>>>>>        Property Handle[] pDDsWithFindReqErrors
12246>>>>>        
12246>>>>>        // Apply SQL filters in constrained finds
12246>>>>>        Property Boolean pbUseDDSQLFilters False
12247>>>>>        // If pbUseDDSQLFilters is true, this determines if the table global filter should be applied as well
12247>>>>>        Property Boolean pbApplyGlobalSQLFilters False
12248>>>>>        // Filter which will get applied before each DDO constrained find. If "", no filter is applied
12248>>>>>        Property String psSQLFilter ""
12249>>>>>        
12249>>>>>        // Old values for SQL Filters which are pushed and popped by StoreSQLDefaultFilters and RestoreSQLDefaultFilters
12249>>>>>        Property String psOldFilter ""
12250>>>>>        Property Boolean pbOldFilterActive
12251>>>>>        Property Boolean pbOldFilterEq
12252>>>>>        
12252>>>>>        // used to point to the composite child object that provides the SQL
12252>>>>>        // interfaces for a driver. This can be used with DAW drivers. Other drivers may require
12252>>>>>        // that you sub-class your DD and create a different object based on a custom class
12252>>>>>        Property Handle phoSQLHelper (Create(Self,RefClass(cDAWSQLDriverHelper)))
12253>>>>>        
12253>>>>>        
12253>>>>>        Property Handle pbInResync False
12254>>>>>        
12254>>>>>        Property Integer piPrimaryIndex -1      // Indicates the unique index used by the webapp view state system (-1 defaults to the primary key or recnum for embedded).
12255>>>>>        
12255>>>>>        Set Smart_FileMode_State to True  // extended DSOs should default to true
12256>>>>>        
12256>>>>>        Send Define_Fields // Developer Hook - define all field rules
12257>>>>>    End_Procedure
12258>>>>>    
12258>>>>>    // Returns 1 to indicate that this is a DD class.
12258>>>>>    Function Extended_DSO_State Returns Integer
12260>>>>>        Function_Return 1
12261>>>>>    End_Function
12262>>>>>    
12262>>>>>    
12262>>>>>    // Used to set up all XDS functions and rules. Called by construct_object
12262>>>>>    // and considered a bit more user friendly.
12262>>>>>    Procedure Define_Fields
12264>>>>>    End_Procedure
12265>>>>>    
12265>>>>>    
12265>>>>>    
12265>>>>>    // This message has been augmented to create a local recordbuffer for a
12265>>>>>    // file. We cannot do this earlier because we need the file to count the
12265>>>>>    // number of necessary fields.
12265>>>>>    Procedure Set Main_File Integer iFile
12267>>>>>        Integer iCurrent_File iMaster
12267>>>>>        Get piMasterTable to iMaster
12268>>>>>        If iMaster Begin
12270>>>>>            // is an alias condition
12270>>>>>            Forward Set Main_File to iFile
12272>>>>>            Send ReDefineAliasItems to (Record_Buffer(Self)) iFile
12273>>>>>        End
12273>>>>>>
12273>>>>>        Else If iFile Begin
12276>>>>>            Get Main_File to iCurrent_File
12277>>>>>            If (iCurrent_File and iCurrent_File <> iFile) Begin
12279>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_CANNOT_CHANGE_MAIN_FILE
12280>>>>>                Procedure_Return
12281>>>>>            End
12281>>>>>>
12281>>>>>            Forward Set Main_File to iFile
12283>>>>>            Send Create_Items to (Record_Buffer(Self)) iFile
12284>>>>>            Send Create_Items to (Field_Attributes(Self))
12285>>>>>        End
12285>>>>>>
12285>>>>>    End_Procedure
12286>>>>>    
12286>>>>>    // This procedure will update the Key_Fields property to include or
12286>>>>>    // excluded the fieldnumber passed in the list of fieldnumbers which make
12286>>>>>    // up an keyvalue.
12286>>>>>    Procedure Set Key_Field_State Integer iField Integer iState
12288>>>>>        String  sKeys
12288>>>>>        Set Key_Field_State of Record_Buffer iField to iState
12289>>>>>        Get Key_Fields to sKeys
12290>>>>>        Set Key_Fields to (Overstrike(If(iState, "X", " "), sKeys, iField))
12291>>>>>    End_Procedure
12292>>>>>    
12292>>>>>    // Will return TRUE if the field passed has been defined as a key.
12292>>>>>    Function Key_Field_State Integer iField Returns Integer
12294>>>>>        Integer iState
12294>>>>>        Get Key_Field_State of Record_Buffer iField to iState
12295>>>>>        Function_Return iState
12296>>>>>    End_Function
12297>>>>>    
12297>>>>>    // Returns complete key value.
12297>>>>>    Function Key_Value Returns String
12299>>>>>        String  sKeys
12299>>>>>        String  sKey_Value
12299>>>>>        String  sValue
12299>>>>>        Integer iField
12299>>>>>        Get Key_Fields to sKeys
12300>>>>>        Move "" to sKey_Value
12301>>>>>        Repeat
12301>>>>>>
12301>>>>>            Move (Pos( "X",sKeys)) to iField
12302>>>>>            If iField Begin
12304>>>>>                Get Field_Current_Value iField to sValue
12305>>>>>                Append sKey_Value sValue
12306>>>>>                Move (Overstrike(" ", sKeys, iField)) to sKeys
12307>>>>>            End
12307>>>>>>
12307>>>>>        Until not iField
12309>>>>>        Function_Return sKey_Value
12310>>>>>    End_Function
12311>>>>>    
12311>>>>>    // This procedure will be called whenever the Data_Set changes its
12311>>>>>    // Current_Record property, or after a Save, Delete or Clear operation.
12311>>>>>    // We send this message to the Record_Buffer object to update its values.
12311>>>>>    Procedure New_Current_Record Integer iOld Integer iNew
12313>>>>>        // does nothing, but exists if developer is using this for some purpose. Is called after
12313>>>>>        // OnNewCurrentRecord (if recnum based table)
12313>>>>>    End_Procedure
12314>>>>>    
12314>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
12316>>>>>        Integer iObj
12316>>>>>        Integer iOldst
12316>>>>>        Integer iFoc
12316>>>>>        Integer iIsExt
12316>>>>>        Forward Send OnNewCurrentRecord riOld riNew
12318>>>>>        Move (Record_Buffer(Self)) to iObj
12319>>>>>        If iObj Begin
12321>>>>>            Send OnNewCurrentRecord of iObj riOld riNew
12322>>>>>            // must also refresh all defined extended fields
12322>>>>>            Send ExtendedFieldsRefresh (IsNullRowId(riNew)) // pass bCleared (true if a clear)
12323>>>>>            Get Focus of Desktop to iFoc
12324>>>>>            Get Extended_DEO_State of iFoc to iIsExt     // if focus is deo item
12325>>>>>            If iIsExt Begin                               // disable the state so
12327>>>>>                Get Entry_Refresh_State of iFoc to iOldSt // value will come
12328>>>>>                Set Entry_Refresh_State of iFoc to True   // from Local buffer.
12329>>>>>            End
12329>>>>>>
12329>>>>>            Set Existing_Key_Value to (Key_Value(Self))
12330>>>>>            If iIsExt ;                Set Entry_Refresh_State of iFoc to iOldSt
12333>>>>>            // Only set defaults when the record is new
12333>>>>>            If (IsNullRowId(riNew)) ;                Send Prepare_Default_Values
12336>>>>>        End
12336>>>>>>
12336>>>>>    End_Procedure
12337>>>>>    
12337>>>>>    // Shuts off change mode and sends initialize_default_values which is
12337>>>>>    // a user hook routine.
12337>>>>>    Procedure Prepare_Default_Values
12339>>>>>        Integer iOldState
12339>>>>>        Get Change_disabled_State to iOldState
12340>>>>>        Set Change_disabled_State to True
12341>>>>>        Send Private_Field_Defaults
12342>>>>>        // set defaults if this is the main DDO or the DDO is
12342>>>>>        // flagged as supporting saving new records when foreign (a parent)
12342>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self)) ;            Send Field_Defaults
12345>>>>>        Send AssignDynamicDefaults
12346>>>>>        Set Change_disabled_State to iOldState
12347>>>>>    End_Procedure
12348>>>>>    
12348>>>>>    // Set all checkbox fields to default to False data value.
12348>>>>>    Procedure Private_Field_Defaults
12350>>>>>        Integer iField
12350>>>>>        Repeat
12350>>>>>>
12350>>>>>            Get Next_Validation_Type of (Field_Attributes(Self)) ;                FA_VALIDATION_TYPE_CHECKBOX iField to iField
12351>>>>>            If (iField = 0) ;                Procedure_Return
12354>>>>>            Set Field_Select_State  iField to False
12355>>>>>            Set Field_Changed_State iField to True
12356>>>>>        Loop
12357>>>>>>
12357>>>>>    End_Procedure
12358>>>>>    
12358>>>>>    // Will be called after a clear operation to let the application
12358>>>>>    // programmer set the default values for the record. This should be done
12358>>>>>    // by sending SET Field_Current_Value.
12358>>>>>    Procedure Field_Defaults
12360>>>>>    End_Procedure
12361>>>>>    
12361>>>>>    // Pass type and string value and see if this is valid data for this
12361>>>>>    // type. Currently we check for numbers and dates. Return non-zero
12361>>>>>    // if invalid.
12361>>>>>    Function IsDataInvalid Integer iType String sValue Returns Integer
12363>>>>>        Date    dVal
12363>>>>>        DateTime dtVal
12363>>>>>        Number  nVal
12363>>>>>        Integer bOK
12363>>>>>        Boolean bInvalid
12363>>>>>        
12363>>>>>        Move False to bInvalid
12364>>>>>        If (iType=DF_BCD or iType=DF_DATE or iType=DF_DATETIME) Begin
12366>>>>>            If (iType=DF_DATE) Begin
12368>>>>>                MoveTrapErr sValue to dVal
12369>>>>>                Move (Err) to bInvalid
12370>>>>>            End
12370>>>>>>
12370>>>>>            Else If (iType=DF_DATETIME) Begin
12373>>>>>                MoveTrapErr sValue to dtVal
12374>>>>>                Move (Err) to bInvalid
12375>>>>>//          Move (not(IsDateValid(dtVal))) to bInvalid //jjt-uncomment when working
12375>>>>>            End
12375>>>>>>
12375>>>>>            Else Begin
12376>>>>>                MoveTrapErr sValue to nVal // this may gen an error.
12377>>>>>                Move (Err) to bInvalid
12378>>>>>            End
12378>>>>>>
12378>>>>>            Move False to Err
12379>>>>>        End
12379>>>>>>
12379>>>>>        Function_Return bInvalid
12380>>>>>    End_Function
12381>>>>>    
12381>>>>>    // Return 1 if the passed DEO is part of the DDs list of connected DEOs
12381>>>>>    // First check if server of DEO is this DD. If so, we are owned. If not
12381>>>>>    // we must check the DD's UI DEO list.
12381>>>>>    // The passed object MUST be a valid DEO or an error will occur.
12381>>>>>    Function IsDEOOwned Integer iDEO Returns Integer
12383>>>>>        Integer iMax iCount
12383>>>>>        // if DEOs server is same as current DD it is owned. This is the
12383>>>>>        // fast check
12383>>>>>        If (Server(iDEO)=Self) ;            Function_Return 1
12386>>>>>        // else see if the DEO is in the DD's DEO list
12386>>>>>        Get Data_Set_User_Interface_Count to iMax
12387>>>>>        Decrement iMax
12388>>>>>        For iCount from 0 to iMax
12394>>>>>>
12394>>>>>            If (Data_Set_User_Interface(Self,iCount)=iDEO) ;                Function_Return 1
12397>>>>>        Loop
12398>>>>>>
12398>>>>>        Function_Return 0
12399>>>>>    End_Function
12400>>>>>    
12400>>>>>    // This procedure changes the field value of the given field in the
12400>>>>>    // record-buffer object.
12400>>>>>    // It also sends Field_Value_Changed to notify every the attached DEOs.
12400>>>>>    // This has been optimized so this message is only sent when data is
12400>>>>>    // actually changed.
12400>>>>>    Procedure Set Field_Current_Value Integer iField String sValue
12402>>>>>        Integer iObj
12402>>>>>        String sOldVal
12402>>>>>        Integer iChanged
12402>>>>>        Integer iType
12402>>>>>        Integer iFile
12402>>>>>        Integer iFocObj
12402>>>>>        Integer iCrnt
12402>>>>>        Integer bInvalid
12402>>>>>        Integer iIdentity
12402>>>>>        Address pData
12402>>>>>        Integer iLen
12402>>>>>        
12402>>>>>        Get Main_File to iFile
12403>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12406>>>>>        
12406>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12406>>>>>        // that you will use the underlying fields instead
12406>>>>>        If (iType = DF_OVERLAP) Begin
12408>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12409>>>>>            Procedure_Return
12410>>>>>        End
12410>>>>>>
12410>>>>>        
12410>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
12412>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
12413>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
12414>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
12415>>>>>            // will gen error if ext. field does not exist
12415>>>>>            Set Field_Current_Pointer_Value iField iLen to pData
12416>>>>>            Procedure_Return
12417>>>>>        End
12417>>>>>>
12417>>>>>        
12417>>>>>        
12417>>>>>        // If date or number, force conversion so any error is detected before
12417>>>>>        // the buffer is updated. We don't want the record buffer to contain
12417>>>>>        // invalid data
12417>>>>>        Get IsDataInvalid iType sValue to bInvalid
12418>>>>>        If bInvalid ;         // If an error occurred we have            Procedure_Return  // a bad number or a bad date. Do no more!
12421>>>>>        
12421>>>>>        Move (Record_Buffer(Self)) to iObj
12422>>>>>        Get Value of iObj iField to sOldVal
12423>>>>>        
12423>>>>>        Set Value of iObj iField to sValue
12424>>>>>        
12424>>>>>        // Augmented to handle non DF databases JJT
12424>>>>>        // Some tables may use some field other then recnum for their record identity.
12424>>>>>        // This will be dfrecnum or some other numeric field. When this happens the DD have
12424>>>>>        // to field buffers for the same value. When an update occurs from the DD to the DB buffer
12424>>>>>        // an update can occur twice. If the values are the same, this does not matter. Else the highest
12424>>>>>        // field value will get the update (not recnum). So if someone changes recnum but not its real field
12424>>>>>        // finding may not work right. The DD is updated when a record is found and the API keeps the two values
12424>>>>>        // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
12424>>>>>        // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
12424>>>>>        // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
12424>>>>>        //
12424>>>>>        // if field is recnum and record identity is not 0, we must also update the other field.
12424>>>>>        If (iField=0) Begin
12426>>>>>            Get_Attribute DF_FILE_RECORD_IDENTITY of iFile to iIdentity
12429>>>>>            If (iIdentity>0) ;                Set Value of iObj iIdentity to sValue
12432>>>>>        End
12432>>>>>>
12432>>>>>        
12432>>>>>        // When data-sets are working they should not update the
12432>>>>>        // DEOs.
12432>>>>>        
12432>>>>>        // prior to vdf7, we stopped all operation modes of non-zero. We now allow
12432>>>>>        // validates to pass through and we have a new operation mode for this. This
12432>>>>>        // should be ok, since we already allowed navigation validation through - we just
12432>>>>>        // stopped request_validate validations.
12432>>>>>        If (Operation_Mode=0 or Operation_Mode=MODE_VALIDATING) Begin
12434>>>>>            If (iType=DF_BCD) ;                Move (Number(sValue)<>Number(sOldVal)) to iChanged
12437>>>>>            Else If (iType=DF_DATE) ;                Move (Date(sValue)<>Date(sOldVal)) to iChanged
12441>>>>>            Else If (iType=DF_DATETIME) ;                Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to iChanged
12445>>>>>            Else ;                Move (sValue<>sOldVal) to iChanged
12447>>>>>            // if changed, notify all DEOs of this change
12447>>>>>            If iChanged ;                Send Field_Value_Changed iField sValue
12450>>>>>            Else Begin
12451>>>>>                // If here the set value did not change the contents of the DD.
12451>>>>>                // However, it is possible that the current focus DEO may contain
12451>>>>>                // a different value than the one we are setting. In such a case
12451>>>>>                // we must re-synchronize the DEO. Only the one DEO can be affected
12451>>>>>                // because it is the current focus deo/item that can contain a value
12451>>>>>                // that is not yet updated in the DD. This fixes a bug where the
12451>>>>>                // iexit was setting a value which was different from what was in
12451>>>>>                // the DEO but was the same as the old DD value (iExit is called
12451>>>>>                // before the DD is re-synched with the DEO). This could happen
12451>>>>>                // also by sending this message directly with a different value in
12451>>>>>                // the DEO focus item.
12451>>>>>                Get Focus of Desktop to iFocObj
12452>>>>>                // similar logic to Get Field_Current_Value. We check that the DEO
12452>>>>>                // is extended, that entry_refresh is not disabled and that the
12452>>>>>                // DEO's server is this DD.
12452>>>>>                If ( Extended_DEO_State(iFocObj) and ;                    (Entry_Refresh_State(iFocObj)=0)) Begin
12454>>>>>                    Get Current_item of iFocObj to iCrnt
12455>>>>>                    // If Focus DEO has same file and field and it is not checkbox
12455>>>>>                    // we must set its value. Set local value directly sets the value
12455>>>>>                    // in the DEO item. If we used value we'd get recursion!
12455>>>>>                    If ( Data_File(iFocObj,iCrnt)=iFile and ;                        Data_Field(iFocObj,iCrnt)=iField and ;                        IsDEOOwned(Self,iFocObj) and ;                        Checkbox_item_State(iFocObj,iCrnt)=0 ) ;                        Send File_Field_Value_Changed to iFocObj iFile iField sValue True
12458>>>>>                    //Set Local_Value of iFocObj iCrnt to sValue
12458>>>>>                End
12458>>>>>>
12458>>>>>            End
12458>>>>>>
12458>>>>>        End
12458>>>>>>
12458>>>>>    End_Procedure
12459>>>>>    
12459>>>>>    // Sets Field_Current_Value and Sets Field_Changed_State for passed field.
12459>>>>>    Procedure Set Field_Changed_Value Integer iField String sValue
12461>>>>>        Set Field_Changed_State iField to True
12462>>>>>        Set Field_Current_Value iField to sValue
12463>>>>>    End_Procedure
12464>>>>>    
12464>>>>>    
12464>>>>>    // This should only be set by a DEO that is changing a NoPut value. This should only happen when NoEnter=F
12464>>>>>    // for indexed findable noput deos. With foreign-field noputs we may store the value and update them
12464>>>>>    // for finds but we don't want them for saves. The cDDBuffer class handles this but it needs to
12464>>>>>    // know if this was a DEO NoPut update. DDOs have always allowed you to directly update foreign NoPut
12464>>>>>    // fields when the change did not come from a DEO.
12464>>>>>    Procedure Set Field_NoPutValueChangedByDeo Integer iField Boolean bChange
12466>>>>>        Set Item_ChangedByDeo of Record_Buffer iField to bChange
12467>>>>>    End_Procedure
12468>>>>>    
12468>>>>>    Procedure Set File_Field_NoPutValueChangedByDeo Integer iFile Integer iField Boolean bChange
12470>>>>>        Integer iDSO
12470>>>>>        Get Data_set iFile to iDSO
12471>>>>>        If iDSO Begin
12473>>>>>            Set Field_NoPutValueChangedByDeo of iDSO iField to bChange
12474>>>>>        End
12474>>>>>>
12474>>>>>    End_Procedure
12475>>>>>    
12475>>>>>    // Returns the value from the record buffer for the field of which the
12475>>>>>    // fieldnumber has been passed.
12475>>>>>    // If the file/field requested is the focus file/field the use the DEO's
12475>>>>>    // value.
12475>>>>>    Function Field_Current_Value Integer iField Returns String
12477>>>>>        Integer iType
12477>>>>>        Integer iFile
12477>>>>>        String  sValue
12477>>>>>        Integer iFoc
12477>>>>>        Integer iCrnt
12477>>>>>        Integer iFldSize iVoid
12477>>>>>        UChar[] UCData
12478>>>>>        
12478>>>>>        Get Focus of desktop to iFoc
12479>>>>>        Get Main_File to iFile
12480>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12483>>>>>        
12483>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12483>>>>>        // that you will use the underlying fields instead
12483>>>>>        If (iType=DF_OVERLAP) Begin
12485>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12486>>>>>            Function_Return ''
12487>>>>>        End
12487>>>>>>
12487>>>>>        
12487>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if overlap, text or binary direct to pointer
12489>>>>>            Get Field_Current_UCAValue iField to UCData
12490>>>>>            
12490>>>>>            // we assume a string is passed here. If we return to a string the
12490>>>>>            // pointer message will convert this to a string. Check that max string
12490>>>>>            // length is not larger than Max_Argument_Size has been removed.
12490>>>>>            Move (SizeOfArray(UCData)) to iFldSize
12491>>>>>            Move (UCharArrayToString(UCData)) to sValue
12492>>>>>            // This function has always returned the value as a 0 delimited string.
12492>>>>>            // Therefore trim at first zero. This means that you should not use this method
12492>>>>>            // with Binary types as embedded zeros will cause a truncation.
12492>>>>>            Move (CString(sValue)) to sValue
12493>>>>>            Function_Return sValue
12494>>>>>        End
12494>>>>>>
12494>>>>>        
12494>>>>>        // This was extended to also make sure that the focus's server
12494>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12494>>>>>        // file/field being the right file/field but for a different view.
12494>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12494>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12494>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12494>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12494>>>>>        // DEO field, so the buffer is always correct.
12494>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12496>>>>>            Get Current_item of iFoc to iCrnt
12497>>>>>            If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;                IsDEOOwned(Self,iFoc) and ;                (Checkbox_item_State(iFoc,iCrnt)=0) ) Begin
12499>>>>>                Get Data_Value of iFoc iCrnt to sValue
12500>>>>>            End
12500>>>>>>
12500>>>>>            Else Begin
12501>>>>>                Get Value of (Record_Buffer(Self)) iField to sValue
12502>>>>>            End
12502>>>>>>
12502>>>>>        End
12502>>>>>>
12502>>>>>        Else Begin
12503>>>>>            Get Value of (Record_Buffer(Self)) iField to sValue
12504>>>>>        End
12504>>>>>>
12504>>>>>        
12504>>>>>        // cast value to the proper datatype
12504>>>>>        If (iType=DF_BCD) Begin
12506>>>>>            Function_Return (Number(sValue))
12507>>>>>        End
12507>>>>>>
12507>>>>>        Else If (iType=DF_DATE) Begin
12510>>>>>            Function_Return (Date(sValue))
12511>>>>>        End
12511>>>>>>
12511>>>>>        Else If (iType=DF_DATETIME) Begin
12514>>>>>            Function_Return (Cast(sValue,DateTime))
12515>>>>>        End
12515>>>>>>
12515>>>>>        // else return as string
12515>>>>>        Function_Return sValue
12516>>>>>    End_Function
12517>>>>>    
12517>>>>>    // This sets a default value without setting the DSO's changed_State
12517>>>>>    Procedure Set Field_Default_Value Integer iField String sValue
12519>>>>>        Integer iOldState
12519>>>>>        Get Change_disabled_State to iOldState
12520>>>>>        Set Change_disabled_State to True
12521>>>>>        Set Field_Changed_Value iField to sValue
12522>>>>>        Set Change_disabled_State to iOldState
12523>>>>>    End_Procedure
12524>>>>>    
12524>>>>>    Procedure Set File_Field_default_Value Integer iFile Integer iField String sValue
12526>>>>>        Integer iDSO
12526>>>>>        Get Data_set iFile to iDSO
12527>>>>>        If iDSO ;            Set Field_default_Value of iDSO iField to sValue
12530>>>>>    End_Procedure
12531>>>>>    
12531>>>>>    // Methods to set and get the value of a field. When set all DSOs and
12531>>>>>    // DEOs are notified.
12531>>>>>    Procedure Set File_Field_Current_Value Integer iFile Integer iField String sValue
12533>>>>>        Integer iDSO
12533>>>>>        Get Data_set iFile to iDSO
12534>>>>>        If iDSO ;            Set Field_Current_Value of iDSO iField to sValue
12537>>>>>    End_Procedure
12538>>>>>    
12538>>>>>    Procedure Set File_Field_Changed_Value Integer iFile Integer iField String sValue
12540>>>>>        Integer iDSO
12540>>>>>        Get Data_set iFile to iDSO
12541>>>>>        If iDSO ;            Set Field_Changed_Value of iDSO iField to sValue
12544>>>>>    End_Procedure
12545>>>>>    
12545>>>>>    Function File_Field_Current_Value Integer iFile Integer iField Returns String
12547>>>>>        Integer iDSO
12547>>>>>        String sValue
12547>>>>>        Get Data_set iFile to iDSO
12548>>>>>        If iDSO ;            Get Field_Current_Value of iDSO iField to sValue
12551>>>>>        Function_Return sValue
12552>>>>>    End_Function
12553>>>>>    
12553>>>>>    // This procedure will notify every attached DEO that the value of a
12553>>>>>    // field has been changed. Every DEO needs to update its value to reflect
12553>>>>>    // the new value.
12553>>>>>    Procedure Field_Value_Changed Integer iField String sValue
12555>>>>>        Integer iMax
12555>>>>>        Integer iCount
12555>>>>>        Integer iDEO
12555>>>>>        Integer iMain_File
12555>>>>>        Integer iNoChange
12555>>>>>        Get Change_Disabled_State to iNoChange
12556>>>>>        Get Main_File to iMain_File
12557>>>>>        Get Data_Set_User_Interface_Count to iMax
12558>>>>>        Decrement iMax
12559>>>>>        For iCount from 0 to iMax
12565>>>>>>
12565>>>>>            Get Data_Set_User_Interface iCount to iDEO
12566>>>>>            If (Extended_DEO_State(iDEO) ) Begin
12568>>>>>                Send File_Field_Value_Changed to iDEO iMain_File iField sValue iNoChange
12569>>>>>            End
12569>>>>>>
12569>>>>>        Loop
12570>>>>>>
12570>>>>>    End_Procedure
12571>>>>>    
12571>>>>>    // Gets/Sets Field_Changed_State of the passed field. Will Set Changed_
12571>>>>>    // state if appropriate (if change_disabled_state is false)
12571>>>>>    Function Field_Changed_State Integer iField Returns Integer
12573>>>>>        Function_Return ;            (Item_Changed_State(Record_Buffer(Self), iField))
12574>>>>>    End_Function
12575>>>>>    
12575>>>>>    
12575>>>>>    // Handle NoPut here. If the field is noput set the field_changed_State but do not set the
12575>>>>>    // DD's changed_state. As of 17.0, we changed the rule so that noput DEOs always update the DD.
12575>>>>>    // They set the field_Current_value and they set the field_changed_state. If noput they will
12575>>>>>    // not set changed_state. This now makes windows and web consistent.
12575>>>>>    Procedure Set Field_Changed_State Integer iField Integer iState
12577>>>>>        Boolean bNoPut bOldSt bIsCommitted
12577>>>>>        
12577>>>>>        Get Field_Option iField DD_NOPUT to bNoPut
12578>>>>>        If not bNoPut Begin // if not noput, see if this is a committed and therefore noput
12580>>>>>            Get IsCommitted to bIsCommitted
12581>>>>>            If bIsCommitted Begin
12583>>>>>                Get IsFieldCommitted iField to bNoPut
12584>>>>>            End
12584>>>>>>
12584>>>>>        End
12584>>>>>>
12584>>>>>        
12584>>>>>        If bNoPut Begin
12586>>>>>            Get Change_disabled_State to bOldSt
12587>>>>>            Set Change_disabled_State to True
12588>>>>>        End
12588>>>>>>
12588>>>>>        
12588>>>>>        Set Item_Changed_State of (Record_Buffer(Self)) iField to iState
12589>>>>>        // the cDDBuffer class item_changed_state does not attempt to set
12589>>>>>        // changed_state, so we do it here. This will allow for future
12589>>>>>        // greater flexibilities.
12589>>>>>        If (iState) Begin
12591>>>>>            Set Changed_State of (Record_Buffer(Self)) to True
12592>>>>>        End
12592>>>>>>
12592>>>>>        If bNoPut Begin
12594>>>>>            Set Change_disabled_State to bOldSt
12595>>>>>        End
12595>>>>>>
12595>>>>>        
12595>>>>>    End_Procedure
12596>>>>>    
12596>>>>>    // As above, but passes both file and field
12596>>>>>    Function File_Field_Changed_State Integer iFile Integer iField Returns Integer
12598>>>>>        Integer iDSO
12598>>>>>        Get Data_Set iFile to iDSO
12599>>>>>        If iDSO ;            Function_Return (Field_Changed_State(iDSO, iField))
12602>>>>>    End_Function
12603>>>>>    
12603>>>>>    Procedure Set File_Field_Changed_State Integer iFile Integer iField Integer iState
12605>>>>>        Integer iDSO
12605>>>>>        Get Data_Set iFile to iDSO
12606>>>>>        If iDSO ;            Set Field_Changed_State of iDSO iField to iState
12609>>>>>    End_Procedure
12610>>>>>    
12610>>>>>    // This simulates entering a value into a field from a keyboard. Pass the
12610>>>>>    // Field and DD Options and the value. It is up to you to pass the proper
12610>>>>>    // DD options. This is normally sent by File_Field_Entry and you are
12610>>>>>    // advised to use that message and not this one.
12610>>>>>    Procedure Set Field_Entry Integer iField Integer iOpts Integer bShowErr String sValue
12612>>>>>        Integer iFile
12612>>>>>        Integer iType
12612>>>>>        Integer bChanged
12612>>>>>        Integer bInvalid
12612>>>>>        Integer hObj
12612>>>>>        String sOldVal
12612>>>>>        Address pData
12612>>>>>        Integer iLen
12612>>>>>        
12612>>>>>        Get Main_File to iFile
12613>>>>>        
12613>>>>>        // if No-enter or Displayonly, this shouldn't be changed. We will
12613>>>>>        // let NoPut through, since a user might need it for finding.
12613>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
12616>>>>>        
12616>>>>>        // Force a caplsock if required
12616>>>>>        If (iOpts iand DD_CAPSLOCK) ;            Move (Uppercase(sValue)) to sValue
12619>>>>>        
12619>>>>>        // If date or number, force conversion so any error is detected before
12619>>>>>        // the buffer is updated. We don't want the record buffer to contain
12619>>>>>        // invalid data
12619>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12622>>>>>        
12622>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12622>>>>>        // that you will use the underlying fields instead
12622>>>>>        If (iType = DF_OVERLAP) Begin
12624>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12625>>>>>            Procedure_Return
12626>>>>>        End
12626>>>>>>
12626>>>>>        
12626>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
12628>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
12629>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
12630>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
12631>>>>>            // will gen error if ext. field does not exist
12631>>>>>            Set Field_Pointer_Entry iField iOpts iLen bShowErr to pData
12632>>>>>            Procedure_Return
12633>>>>>        End
12633>>>>>>
12633>>>>>        
12633>>>>>        Get IsDataInvalid iType sValue to bInvalid
12634>>>>>        If bInvalid Begin     // If an error occurred we have
12636>>>>>            If bShowErr ;                Send Data_set_error iField (If(iType=DF_DATE or iType=DF_DATETIME, DFERR_ENTER_VALID_DATE, DFERR_BAD_ENTRY)) ;                (" ("-sValue-")")
12639>>>>>            Procedure_Return  // a bad number or a bad date. Do no more!
12640>>>>>        End
12640>>>>>>
12640>>>>>        // update the value only if the value is changed.
12640>>>>>        Move (Record_Buffer(Self)) to hObj
12641>>>>>        Get Value of hObj iField to sOldVal
12642>>>>>        If (iType=DF_BCD) ;            Move (Number(sValue)<>Number(sOldVal)) to bChanged
12645>>>>>        Else If (iType=DF_DATE) ;            Move (Date(sValue)<>Date(sOldVal)) to bChanged
12649>>>>>        Else If (iType=DF_DATETIME) ;            Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to bChanged
12653>>>>>        Else ;            Move (sValue<>sOldVal) to bChanged
12655>>>>>        
12655>>>>>        // if changed or force put, update the value.
12655>>>>>        If ( bChanged or (iOpts iand DD_FORCEPUT) ) ;            Set Field_Current_Value iField to sValue
12658>>>>>        
12658>>>>>        // Set changed state if changed. This is an improvement on DEOs which would set changed-state for
12658>>>>>        // a no-put. Set Field_Changed_State will not set Changed_state if it is noput
12658>>>>>        If ( bChanged) Begin
12660>>>>>            Set Field_Changed_State iField to True
12661>>>>>            // if noput (but not noenter) we must tell the DDO that this should not be
12661>>>>>            // updated during a save.
12661>>>>>            If (iOpts iand DD_NOPUT) Begin
12663>>>>>                Set Field_NoPutValueChangedByDeo iField to True
12664>>>>>            End
12664>>>>>>
12664>>>>>        End
12664>>>>>>
12664>>>>>        
12664>>>>>        // perform autofinds if needed. Note that required checking will occur as
12664>>>>>        // part of validation.
12664>>>>>        // We will only autofind if the field value is changed. This is consistent with
12664>>>>>        // DEOs which do not autofind on unchanged values. This provides optimizations
12664>>>>>        // when a parent record is already loaded.
12664>>>>>        If (bChanged or Field_Changed_state(Self,iField)) Begin
12666>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
12666>>>>>            // testing is important and make sure we test for exact bit match. Must first
12666>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
12666>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Send File_Field_AutoFind iFile iField GE
12669>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) ;                Send File_Field_AutoFind iFile iField EQ
12673>>>>>        End
12673>>>>>>
12673>>>>>        
12673>>>>>    End_Procedure
12674>>>>>    
12674>>>>>    // This returns file-field options for a Field_Entry type of environment.
12674>>>>>    // It will strip autofind from main-file DDs but leave foreign field alone.
12674>>>>>    // This is needed for Field_entry. Otherwise adding a field value to an autofind
12674>>>>>    // for save or find causes an autofind to trigger first which either causes the
12674>>>>>    // wrong rec to save or for a double find.
12674>>>>>    Function File_Field_Entry_Options Integer iFile Integer iField Returns Integer
12676>>>>>        Integer iOpts
12676>>>>>        // this will get the appropriate field and foreign field opts
12676>>>>>        Get File_Field_Options iFile iField to iOpts
12677>>>>>        // If the main file (not foreign) we will strip autofind. Autofind should not
12677>>>>>        // be an automatic part of main file entry while it should with foreign fields.
12677>>>>>        If (iFile=Main_File(Self)) Begin
12679>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
12679>>>>>            // testing is important and make sure we test for exact bit match. Must first
12679>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
12679>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Move (iOpts - DD_AUTOFIND_GE) to iOpts
12682>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND)  ;                Move (iOpts - DD_AUTOFIND)    to iOpts
12686>>>>>        End
12686>>>>>>
12686>>>>>        Function_Return iOpts
12687>>>>>    End_Function
12688>>>>>    
12688>>>>>    // This simulates entering a value into a field from a keyboard. The DD
12688>>>>>    // receiving this message determines if it is Main or Foreign (just like
12688>>>>>    // server). It will do an uppercase, will respect No_Enter and DisplayOnly
12688>>>>>    // and will do a autofind if required. It does not do a field validation.
12688>>>>>    Procedure Set File_Field_Entry Integer iFile Integer iField Integer bShowErr String sValue
12690>>>>>        Integer iOpts
12690>>>>>        Integer hDD
12690>>>>>        Get Data_Set iFile to hDD
12691>>>>>        If hDD Begin
12693>>>>>            // this will get the appropriate field and foreign field opts
12693>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
12694>>>>>            Set Field_Entry of hDD iField iOpts bShowErr to sValue
12695>>>>>        End
12695>>>>>>
12695>>>>>    End_Procedure
12696>>>>>    
12696>>>>>    // return object ID of extended field, 0 if none
12696>>>>>    Function Field_Object Integer iField Returns Integer
12698>>>>>        Integer hoFlds hoField
12698>>>>>        Boolean bAutoAssign
12698>>>>>        Get Field_Objects to hoFlds
12699>>>>>        If hoFlds Begin
12701>>>>>            Get Field_Object of hoFlds iField to hoField
12702>>>>>        End
12702>>>>>>
12702>>>>>        If not hoField Begin
12704>>>>>            Send DefineExtendedField iField // will create field_objects and Field_Object as needed
12705>>>>>            Get Field_Objects to hoFlds
12706>>>>>            Get Field_Object of hoFlds iField to hoField
12707>>>>>        End
12707>>>>>>
12707>>>>>        Function_Return hoField
12708>>>>>    End_Function
12709>>>>>    
12709>>>>>    // This is the same as Field_entry except the value is passed via a
12709>>>>>    // pointer. If data-type is extended (text/binary) it will use and an
12709>>>>>    // extended field object to handle this. If date/number/string we will
12709>>>>>    // convert this to a string and use Field_Entry. It is the caller's
12709>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
12709>>>>>    // If an extended Field object is needed and not defined, an error is
12709>>>>>    // returned. If pointer is null, assume empty string passed (this is a
12709>>>>>    // change as of 8.3 - it used to ignore null pointers)
12709>>>>>    Procedure Set Field_Pointer_Entry Integer iField Integer iOpts Integer iLen Integer bShowErr Address pData
12711>>>>>        Integer hFld
12711>>>>>        String  sValue
12711>>>>>        Integer iFile
12711>>>>>        Integer iType
12711>>>>>        
12711>>>>>        Get Main_file to iFile
12712>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12715>>>>>        
12715>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12715>>>>>        // that you will use the underlying fields instead
12715>>>>>        If (iType = DF_OVERLAP) ;            Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_OVERLAP_ERROR
12718>>>>>        Else If (iType=DF_TEXT or iType=DF_BINARY) Begin
12721>>>>>            Get Field_Object iField to hFld // the object that handles this large text
12722>>>>>            If hFld ;                Set Field_pEntry of hFld iOpts iLen bShowErr to pData
12725>>>>>            Else ;                Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_FIELD_NOT_DEFINED
12727>>>>>        End
12727>>>>>>
12727>>>>>        Else Begin
12728>>>>>            // if number,date or string convert the pointer data to
12728>>>>>            // string data and do a normal entry with it.
12728>>>>>            Move (PointerToString(pData)) to sValue
12729>>>>>            Set Field_Entry iField iOpts bShowErr to sValue
12730>>>>>        End
12730>>>>>>
12730>>>>>    End_Procedure
12731>>>>>    
12731>>>>>    // This is the same as File_Field_entry except the value is passed via a
12731>>>>>    // pointer. See Field_Pointer_Entry for more on this
12731>>>>>    Procedure Set File_Field_Pointer_Entry Integer iFile Integer iField Integer iLen Integer bShowErr Address pData
12733>>>>>        Integer iOpts
12733>>>>>        Integer hDD
12733>>>>>        Get Data_Set iFile to hDD
12734>>>>>        If hDD Begin
12736>>>>>            // this will get the appropriate field and foreign field opts
12736>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
12737>>>>>            Set Field_Pointer_Entry of hDD iField iOpts iLen bShowErr to pData
12738>>>>>        End
12738>>>>>>
12738>>>>>    End_Procedure
12739>>>>>    
12739>>>>>    // This is the same as Field_Current_Value except the value is passed via
12739>>>>>    // a pointer. If data-type is extended (text/binary) it will use and an
12739>>>>>    // extended field object to handle this. If date/number/string we will
12739>>>>>    // convert this to a string and use Field_Entry. It is the caller's
12739>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
12739>>>>>    // If an extended Field object is needed and not defined, an error is
12739>>>>>    // returned. If pointer is null, assume empty string passed (this is a
12739>>>>>    // change as of 8.3 - it used to ignore null pointers)
12739>>>>>    Procedure Set Field_Current_Pointer_Value Integer iField Integer iLen Address pData
12741>>>>>        Integer hFld
12741>>>>>        String  sValue
12741>>>>>        Integer iFile iType iCrnt
12741>>>>>        Handle iFocObj
12741>>>>>        Boolean bChanged
12741>>>>>        
12741>>>>>        Get Main_file to iFile
12742>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12745>>>>>        
12745>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12745>>>>>        // that you will use the underlying fields instead
12745>>>>>        If (iType = DF_OVERLAP) Begin
12747>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12748>>>>>            Procedure_Return
12749>>>>>        End
12749>>>>>>
12749>>>>>        
12749>>>>>        If (iType<>DF_TEXT and iType<>DF_BINARY) Begin
12751>>>>>            // if number,date or string convert the pointer data to
12751>>>>>            // string data and do a normal entry with it.
12751>>>>>            Move (PointerToString(pData)) to sValue  // create string from pointer data
12752>>>>>            Set Field_Current_Value iField to sValue
12753>>>>>            Procedure_Return
12754>>>>>        End
12754>>>>>>
12754>>>>>        
12754>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12755>>>>>        If not hFld Begin
12757>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12758>>>>>            Procedure_Return
12759>>>>>        End
12759>>>>>>
12759>>>>>        
12759>>>>>        Get Is_pValueChanged of hFld iLen pData to bChanged
12760>>>>>        If bChanged Begin
12762>>>>>            Set Field_pValue of hFld iLen to pData
12763>>>>>            Send Field_Pointer_Value_Changed iField pData
12764>>>>>        End
12764>>>>>>
12764>>>>>        Else Begin
12765>>>>>            // If here the set value did not change the contents of the DD.
12765>>>>>            // However, it is possible that the current focus DEO may contain
12765>>>>>            // a different value than the one we are setting. In such a case
12765>>>>>            // we must re-synchronize the DEO. Only the one DEO can be affected
12765>>>>>            // because it is the current focus deo/item that can contain a value
12765>>>>>            // that is not yet updated in the DD. This fixes a bug where the
12765>>>>>            // iexit was setting a value which was different from what was in
12765>>>>>            // the DEO but was the same as the old DD value (iExit is called
12765>>>>>            // before the DD is re-synched with the DEO). This could happen
12765>>>>>            // also by sending this message directly with a different value in
12765>>>>>            // the DEO focus item.
12765>>>>>            Get Focus of Desktop to iFocObj
12766>>>>>            // similar logic to Get Field_Pointer_Current_Value. We check that the DEO
12766>>>>>            // is extended, that entry_refresh is not disabled and that the
12766>>>>>            // DEO's server is this DD.
12766>>>>>            If ( Extended_DEO_State(iFocObj) and (Entry_Refresh_State(iFocObj)=0)) Begin
12768>>>>>                // If Focus DEO has same file and field and it is not checkbox
12768>>>>>                // we must set its value. Set local value directly sets the value
12768>>>>>                // in the DEO item. If we used value we'd get recursion!
12768>>>>>                Get Current_item of iFocObj to iCrnt
12769>>>>>                If ( Data_File(iFocObj,iCrnt)=iFile and ;                    Data_Field(iFocObj,iCrnt)=iField and ;                    IsDEOOwned(Self,iFocObj) ) Begin
12771>>>>>                    Send File_Field_Pointer_Value_Changed to iFocObj iFile iField pData True
12772>>>>>                End
12772>>>>>>
12772>>>>>            End
12772>>>>>>
12772>>>>>        End
12772>>>>>>
12772>>>>>    End_Procedure
12773>>>>>    
12773>>>>>    // This is never called but it needed for the compiler. Required for apps DDs that don't compile in a DEO interface
12773>>>>>    Procedure File_Field_Pointer_Value_Changed Integer iFile Integer iField Address pValue Integer iChangeDisabled
12775>>>>>    End_Procedure
12776>>>>>    
12776>>>>>    Procedure Field_Pointer_Value_Changed Integer iField Address pValue
12778>>>>>        Integer iMax
12778>>>>>        Integer iCount
12778>>>>>        Integer iDEO
12778>>>>>        Integer iMain_File
12778>>>>>        Integer iNoChange
12778>>>>>        Get Change_Disabled_State to iNoChange
12779>>>>>        Get Main_File to iMain_File
12780>>>>>        Get Data_Set_User_Interface_Count to iMax
12781>>>>>        Decrement iMax
12782>>>>>        For iCount from 0 to iMax
12788>>>>>>
12788>>>>>            Get Data_Set_User_Interface iCount to iDEO
12789>>>>>            If (Extended_DEO_State(iDEO) ) Begin
12791>>>>>                Send File_Field_Pointer_Value_Changed to iDEO iMain_File iField pValue iNoChange
12792>>>>>            End
12792>>>>>>
12792>>>>>        Loop
12793>>>>>>
12793>>>>>    End_Procedure
12794>>>>>    
12794>>>>>    // This is the same as File_Field_Current_Value except the value is passed
12794>>>>>    // via a pointer. See Field_current_Pointer_Value for more on this
12794>>>>>    Procedure Set File_Field_Current_Pointer_Value Integer iFile Integer iField Integer iLen Address pData
12796>>>>>        Integer hDD
12796>>>>>        Get Data_Set iFile to hDD
12797>>>>>        If hDD ;            Set Field_Current_Pointer_Value of hDD iField iLen to pData
12800>>>>>    End_Procedure
12801>>>>>    
12801>>>>>    // This returns the data pointer to the extended field. At this point
12801>>>>>    // this is the data. Be careful if you change the data, be even more
12801>>>>>    // careful if you change the pointer (don't do it!!!!)
12801>>>>>    Function Field_Current_Pointer_Value Integer iField Returns Address
12803>>>>>        Integer hFld
12803>>>>>        Handle iFoc
12803>>>>>        
12803>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12804>>>>>        If not hFld Begin
12806>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12807>>>>>            Function_Return 0
12808>>>>>        End
12808>>>>>>
12808>>>>>        
12808>>>>>        
12808>>>>>        // This was extended to also make sure that the focus's server
12808>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12808>>>>>        // file/field being the right file/field but for a different view.
12808>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12808>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12808>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12808>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12808>>>>>        // DEO field, so the buffer is always correct.
12808>>>>>        Get Focus of Desktop to iFoc
12809>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12811>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
12813>>>>>                Send Update_Focus_Field
12814>>>>>            End
12814>>>>>>
12814>>>>>        End
12814>>>>>>
12814>>>>>        
12814>>>>>        Function_Return (FieldPointer(hFld))
12815>>>>>    End_Function
12816>>>>>    
12816>>>>>    
12816>>>>>    Function Field_Current_UCAValue Integer iField Returns UChar[]
12818>>>>>        Integer hFld
12818>>>>>        Handle iFoc
12818>>>>>        UChar[] Data
12819>>>>>        
12819>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12820>>>>>        If not hFld Begin
12822>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12823>>>>>            Function_Return 0
12824>>>>>        End
12824>>>>>>
12824>>>>>        
12824>>>>>        
12824>>>>>        // This was extended to also make sure that the focus's server
12824>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12824>>>>>        // file/field being the right file/field but for a different view.
12824>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12824>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12824>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12824>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12824>>>>>        // DEO field, so the buffer is always correct.
12824>>>>>        Get Focus of Desktop to iFoc
12825>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12827>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
12829>>>>>                Send Update_Focus_Field
12830>>>>>            End
12830>>>>>>
12830>>>>>        End
12830>>>>>>
12830>>>>>        Get FieldArray of hFld to Data
12831>>>>>        Function_Return Data
12832>>>>>    End_Function
12833>>>>>    
12833>>>>>    Function File_Field_Current_Pointer_Value Integer iFile Integer iField Returns Address
12835>>>>>        Address pValue
12835>>>>>        Integer hDD
12835>>>>>        Get Data_Set iFile to hDD
12836>>>>>        If hDD Begin
12838>>>>>            Get Field_Current_Pointer_Value of hDD iField to pValue // return pointer to first byte of
12839>>>>>            Function_Return pValue                                  // data
12840>>>>>        End
12840>>>>>>
12840>>>>>    End_Function
12841>>>>>    
12841>>>>>    Procedure Set Field_Current_UCAValue Integer iField UChar[] Data
12843>>>>>        Set Field_Current_Pointer_Value iField (SizeOfArray(Data)) to (AddressOf(Data))
12844>>>>>    End_Procedure
12845>>>>>    
12845>>>>>    Procedure Set File_Field_Current_UCAValue Integer iFile Integer iField UChar[] Data
12847>>>>>        Integer hDD
12847>>>>>        Get Data_Set iFile to hDD
12848>>>>>        If hDD Begin
12850>>>>>            Set Field_Current_UCAValue of hDD iField to Data
12851>>>>>        End
12851>>>>>>
12851>>>>>    End_Procedure
12852>>>>>    
12852>>>>>    Function File_Field_Current_UCAValue Integer iFile Integer iField Returns UChar[]
12854>>>>>        UChar[] UCValue
12855>>>>>        Handle hDD
12855>>>>>        Get Data_Set iFile to hDD
12856>>>>>        If hDD Begin
12858>>>>>            Get Field_Current_UCAValue of hDD iField to UCValue // return pointer to first byte of
12859>>>>>            Function_Return UCValue                              // data
12860>>>>>        End
12860>>>>>>
12860>>>>>    End_Function
12861>>>>>    
12861>>>>>    // Create an extended field object for the passed field. .
12861>>>>>    // If field already exists, do nothing. This should only be used with
12861>>>>>    // text and binary fields.
12861>>>>>    Procedure DefineExtendedField Integer iField
12863>>>>>        Integer hFlds
12863>>>>>        Get Field_Objects to hFlds // this may not be created yet.
12864>>>>>        If not hFlds Begin         // if not created, create extended-fields wrapper
12866>>>>>            Object ExtendedFieldObjects is a FieldObjects
12868>>>>>                Move Self to hFlds
12869>>>>>            End_Object
12870>>>>>            Set Field_Objects to hFlds
12871>>>>>        End
12871>>>>>>
12871>>>>>        Send DefineFieldObject to hFlds iField
12872>>>>>    End_Procedure
12873>>>>>    
12873>>>>>    // create extended DD fields for all text and binary files
12873>>>>>    Procedure DefineAllExtendedFields
12875>>>>>        Integer iCount iType iField iFile
12875>>>>>        Get Main_file to iFile
12876>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iCount
12879>>>>>        For iField from 1 to iCount
12885>>>>>>
12885>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12888>>>>>            If (iType=DF_TEXT or iType=DF_BINARY) ; // if text or binary                Send DefineExtendedField iField
12891>>>>>        Loop
12892>>>>>>
12892>>>>>    End_Procedure
12893>>>>>    
12893>>>>>    // Update Extended fields to FileBuffer.  DD-Fields ---> FileBuffer
12893>>>>>    // Private
12893>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
12895>>>>>        Integer hFlds
12895>>>>>        Get Field_Objects to hFlds
12896>>>>>        If hFlds ;            Send ExtendedFieldsUpdate to hFlds bSave
12899>>>>>    End_Procedure
12900>>>>>    
12900>>>>>    // Refresh Extended field from FileBuffer.  DD-Fields <--- FileBuffer
12900>>>>>    // Private
12900>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
12902>>>>>        Integer hFlds
12902>>>>>        Get Field_Objects to hFlds
12903>>>>>        If hFlds ;            Send ExtendedFieldsRefresh to hFlds bCleared
12906>>>>>    End_Procedure
12907>>>>>    
12907>>>>>    // This procedure can be used to set the Item_Options of a field. This can
12907>>>>>    // be passed any number of arguments.
12907>>>>>    // Support the following special first parameters:
12907>>>>>    //      DD_CLEAR_FIELD_OPTIONS     - clear all following passed otpions
12907>>>>>    //      DD_CLEAR_ALL_FIELD_OPTIONS - clear all options
12907>>>>>    Procedure Set Field_Options Integer iField Integer iArg1 // plus unknown arguments
12909>>>>>        Integer iObj
12909>>>>>        Integer iOptions
12909>>>>>        Integer iOption
12909>>>>>        Integer iArg
12909>>>>>        Integer iClear
12909>>>>>        Integer iType
12909>>>>>        Move (Record_Buffer(Self)) to iObj
12910>>>>>        Get Item_Options of iObj iField to iOptions
12911>>>>>        //
12911>>>>>        For iArg from 2 to Num_Arguments
12917>>>>>>
12917>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
12918>>>>>            
12918>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
12921>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
12925>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
12929>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
12931>>>>>        Loop
12932>>>>>>
12932>>>>>        //
12932>>>>>        //Get_Attribute DF_FIELD_TYPE of (Main_File(self)) iField to iType
12932>>>>>        //If (iType=DF_TEXT or iType=DF_BINARY) ;            // if text of binary
12932>>>>>        //    Move (iOptions iOR DD_DISPLAYONLY) to iOptions // make sure DO is set
12932>>>>>        
12932>>>>>        Set Item_Options of iObj iField to iOptions
12933>>>>>    End_Procedure
12934>>>>>    
12934>>>>>    // This function returns all the item_options which have been set for
12934>>>>>    // a field. The value from the Record_Buffer object will be binary or'ed
12934>>>>>    // with constand Default_Item_Options and the DD_AUTOCLEAR constants when
12934>>>>>    // the Autoclear_State of the field has been set.
12934>>>>>    // Keep in mind that Autoclear is *not* kept in the Item_Options
12934>>>>>    // property.
12934>>>>>    Function Field_Options Integer iField Returns Integer
12936>>>>>        Function_Return (Item_Options(Record_Buffer(Self), iField))
12937>>>>>    End_Function
12938>>>>>    
12938>>>>>    Function Field_Option Integer iField Integer iOption Returns Integer
12940>>>>>        Integer iOptions
12940>>>>>        Integer iState
12940>>>>>        Get Item_Options of (Record_Buffer(Self)) iField to iOptions
12941>>>>>        // All bits must match for it to be True (e.g., displayonly requires noput & noenter)
12941>>>>>        Move ((iOptions iand iOption)=iOption) to iState
12942>>>>>        Function_Return iState
12943>>>>>    End_Function
12944>>>>>    
12944>>>>>    
12944>>>>>    Procedure Set Foreign_Field_Options Integer iField Integer iArg1 // Integer iOption
12946>>>>>        Integer iObj
12946>>>>>        Integer iOptions
12946>>>>>        Integer iOption
12946>>>>>        Integer iArg
12946>>>>>        Integer iClear
12946>>>>>        
12946>>>>>        
12946>>>>>        Move (Record_Buffer(Self)) to iObj
12947>>>>>        Get Aux_Value of iObj iField to iOptions
12948>>>>>        //
12948>>>>>        For iArg from 2 to Num_Arguments
12954>>>>>>
12954>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
12955>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
12958>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
12962>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
12966>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
12968>>>>>        Loop
12969>>>>>>
12969>>>>>        //
12969>>>>>        Set Aux_Value of iObj iField to iOptions
12970>>>>>    End_Procedure
12971>>>>>    
12971>>>>>    Function Foreign_Field_Options Integer iField Returns Integer
12973>>>>>        Integer iOpts
12973>>>>>        Get ForeignFieldOptions of Record_Buffer iField to iOpts
12974>>>>>        Function_Return iOpts
12975>>>>>    End_Function
12976>>>>>    
12976>>>>>    Procedure Set Foreign_Field_Option Integer iField Integer iOption Integer bSet
12978>>>>>        If bSet Begin
12980>>>>>            Set Foreign_Field_Options iField to iOption
12981>>>>>        End
12981>>>>>>
12981>>>>>        Else Begin
12982>>>>>            Set Foreign_Field_Options iField to DD_CLEAR_FIELD_OPTIONS iOption
12983>>>>>        End
12983>>>>>>
12983>>>>>    End_Procedure
12984>>>>>    
12984>>>>>    Function Foreign_Field_Option Integer iField Integer iOption Returns Integer
12986>>>>>        Integer iOptions
12986>>>>>        Integer iState
12986>>>>>        Get Foreign_Field_Options iField to iOptions
12987>>>>>        Move ((iOptions iand iOption)=iOption) to iState
12988>>>>>        Function_Return iState
12989>>>>>    End_Function
12990>>>>>    
12990>>>>>    // This procedure is being used by DEOs when they need to copy the item-
12990>>>>>    // options from the Data_Set. When the filenumber being passed is not
12990>>>>>    // equal to the Main_File of this Data_Set, then the Foreign_Field_Options
12990>>>>>    // will be applied.
12990>>>>>    Function File_Field_Options Integer iFile Integer iField Returns Integer
12992>>>>>        Integer iDSO
12992>>>>>        Integer iMain_File
12992>>>>>        Integer iOpts
12992>>>>>        Integer iRB
12992>>>>>        Integer iType
12992>>>>>        Get Main_File to iMain_File
12993>>>>>        If (iFile <> iMain_File) ;            Get Data_Set iFile to iDSO
12996>>>>>        Else ;            Move Self to iDSO
12998>>>>>        If iDSO Begin
13000>>>>>            Get Field_Options of iDSO iField to iOpts
13001>>>>>            // we consider the item to be foreign if the DDO main file is different than the one
13001>>>>>            // passed and we do not allow foreign (parent) new records to be saved.
13001>>>>>            If (iFile<>iMain_File and Allow_Foreign_New_Save_State(iDSO)=0) ; // Add Foreign_Field_Options                Move (iOpts ior Foreign_Field_Options(iDSO, iField)) to iOpts
13004>>>>>            Function_Return iOpts
13005>>>>>        End
13005>>>>>>
13005>>>>>    End_Function
13006>>>>>    
13006>>>>>    
13006>>>>>    // Procedure to set the message to be sent on item entry.
13006>>>>>    Procedure Set Field_Entry_msg Integer iField Integer iMsg
13008>>>>>        Set Item_Entry_MSG of (Record_Buffer(Self)) iField to iMsg
13009>>>>>    End_Procedure
13010>>>>>    
13010>>>>>    // Function to return the message to be sent on item entry.
13010>>>>>    Function Field_Entry_msg Integer iField Returns Integer
13012>>>>>        Function_Return (Item_Entry_MSG(Record_Buffer(Self), iField))
13013>>>>>    End_Function
13014>>>>>    
13014>>>>>    
13014>>>>>    // Procedure to send the message to be sent on item exit.
13014>>>>>    Procedure Set Field_Exit_msg Integer iField Integer iMsg
13016>>>>>        Set Item_Exit_MSG of (Record_Buffer(Self)) iField to iMsg
13017>>>>>    End_Procedure
13018>>>>>    
13018>>>>>    // Function to return the message to be set on item exit.
13018>>>>>    Function Field_Exit_msg Integer iField Returns Integer
13020>>>>>        Function_Return (Item_Exit_MSG(Record_Buffer(Self), iField))
13021>>>>>    End_Function
13022>>>>>    
13022>>>>>    // Procedure to set the message to be sent on item validation.
13022>>>>>    Procedure Set Field_Validate_msg Integer iField Integer iMsg
13024>>>>>        Set Item_Validate_MSG of (Record_Buffer(Self)) iField to iMsg
13025>>>>>    End_Procedure
13026>>>>>    
13026>>>>>    // Function to return the message to be set on item validation.
13026>>>>>    Function Field_Validate_msg Integer iField Returns Integer
13028>>>>>        Function_Return (Item_Validate_MSG(Record_Buffer(Self), iField))
13029>>>>>    End_Function
13030>>>>>    
13030>>>>>    
13030>>>>>    // Used to Get/Set the Prompt_Object for a Field.
13030>>>>>    Procedure Set Field_Prompt_Object Integer iField Integer iObj
13032>>>>>        Set Prompt_Object of (Record_Buffer(Self)) iField to iObj
13033>>>>>    End_Procedure
13034>>>>>    
13034>>>>>    Function Field_Prompt_Object Integer iField Returns Integer
13036>>>>>        Integer iObj
13036>>>>>        Get Prompt_Object of (Record_Buffer(Self)) iField to iObj
13037>>>>>        If (iObj = 0) ;            Get Prompt_Object of (Field_Attributes(Self)) iField to iObj
13040>>>>>        Function_Return iObj
13041>>>>>    End_Function
13042>>>>>    
13042>>>>>    Procedure Set Field_Zoom_Object Integer iField Integer iObj
13044>>>>>        Set Zoom_Object of (Record_Buffer(Self)) iField to iObj
13045>>>>>    End_Procedure
13046>>>>>    
13046>>>>>    Function Field_Zoom_Object Integer iField Returns Integer
13048>>>>>        Function_Return (Zoom_Object(Record_Buffer(Self), iField))
13049>>>>>    End_Function
13050>>>>>    
13050>>>>>    
13050>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoObj
13052>>>>>        Set Field_WebPrompt_Object of FieldMask_Array iField to hoObj
13053>>>>>    End_Procedure
13054>>>>>    
13054>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
13056>>>>>        Handle hoPrompt
13056>>>>>        Get Field_WebPrompt_Object of FieldMask_Array iField to hoPrompt
13057>>>>>        Function_Return hoPrompt
13058>>>>>    End_Function
13059>>>>>    
13059>>>>>    
13059>>>>>    // Used to Get/Set the Prompt_Object for a Field.
13059>>>>>    Function File_Field_Prompt_Object Integer iFile Integer iField Returns Integer
13061>>>>>        Integer iObj
13061>>>>>        Get File_Field_Property iFile iField GET_Field_Prompt_Object to iObj
13062>>>>>        Function_Return iObj
13063>>>>>    End_Function
13064>>>>>    
13064>>>>>    Function File_Field_Zoom_Object Integer iFile Integer iField Returns Integer
13066>>>>>        Integer iObj
13066>>>>>        Get File_Field_Property iFile iField GET_Field_Zoom_Object to iObj
13067>>>>>        Function_Return iObj
13068>>>>>    End_Function
13069>>>>>    
13069>>>>>    Function File_Field_WebPrompt_Object Integer iFile Integer iField Returns Handle
13071>>>>>        Handle hoPrompt
13071>>>>>        Get File_Field_Property iFile iField GET_Field_WebPrompt_Object to hoPrompt
13072>>>>>        Function_Return hoPrompt
13073>>>>>    End_Function
13074>>>>>    
13074>>>>>    // Return the extended validation type for this field.
13074>>>>>    Function Field_Validation_Type Integer iField Returns Integer
13076>>>>>        Integer iType
13076>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField ;            to iType
13077>>>>>        Function_Return iType
13078>>>>>    End_Function
13079>>>>>    
13079>>>>>    // Procedure to define a valid value range for a field.
13079>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
13081>>>>>        Set Field_Value_Range of (Field_Attributes(Self)) iField ;            to sMin sMax
13082>>>>>    End_Procedure
13083>>>>>    
13083>>>>>    
13083>>>>>    // Procedure to define a validate table for a field.
13083>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
13085>>>>>        Set Field_Value_Table of (Field_Attributes(Self)) iField ;            to iObj
13086>>>>>    End_Procedure
13087>>>>>    
13087>>>>>    // This provides a callback to the calling object (iObj) by passing this
13087>>>>>    // object the message iMsg for each item in the table. Note this works for
13087>>>>>    // all extended validation types (range, check, etc.)
13087>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
13089>>>>>        Send Field_Fill_list to (Field_Attributes(Self)) ;            iField iObj iMsg
13090>>>>>    End_Procedure
13091>>>>>    
13091>>>>>    Procedure File_Field_Fill_List Integer iFile Integer iField ;            Integer iObj Integer iMsg
13093>>>>>        Integer iDSO
13093>>>>>        Get Data_set iFile to iDSO
13094>>>>>        If iDSO ;            Send Field_Fill_list to iDSO iField iObj iMsg
13097>>>>>    End_Procedure
13098>>>>>    
13098>>>>>    // Returns the ID if any of the validation table for this object.
13098>>>>>    Function Field_Table_Object Integer iField Returns Integer
13100>>>>>        Integer iRval
13100>>>>>        Get Field_Table_Object of (Field_Attributes(Self)) iField to iRVal
13101>>>>>        Function_Return iRVal
13102>>>>>    End_Function
13103>>>>>    
13103>>>>>    Function File_Field_Table_Object Integer iFile Integer iField Returns Integer
13105>>>>>        Integer iDSO
13105>>>>>        Get Data_set iFile to iDSO
13106>>>>>        If iDSO ;            Function_Return (Field_Table_Object(iDSO,iField))
13109>>>>>    End_Function
13110>>>>>    
13110>>>>>    // Returns code description value for the passed string for the
13110>>>>>    // passed validation table object. Normally use field_value_description
13110>>>>>    Function Validation_Table_Description Integer iObj String sVal Returns String
13112>>>>>        String sDesc
13112>>>>>        If iObj ;            Get Find_Code_Description of iObj sVal to sDesc
13115>>>>>        Function_Return sDesc
13116>>>>>    End_Function
13117>>>>>    
13117>>>>>    // Returns the description value for the field's code value. This only
13117>>>>>    // works if you have a validation table - else it returns the field value
13117>>>>>    Function Field_Current_Description Integer iField Returns String
13119>>>>>        String sDesc
13119>>>>>        String sVal
13119>>>>>        Integer iObj
13119>>>>>        Get Field_Current_Value iField to sVal
13120>>>>>        Get Field_Table_Object iField to iObj
13121>>>>>        If iObj Begin
13123>>>>>            Get Validation_Table_Description iObj sVal to sDesc
13124>>>>>            If (sDesc="") ;                Move sVal to sDesc // if desc is blank, use value
13127>>>>>        End
13127>>>>>>
13127>>>>>        Else ;            Move sVal to sDesc
13129>>>>>        Function_Return sDesc
13130>>>>>    End_Function
13131>>>>>    
13131>>>>>    Function File_Field_Current_Description Integer iFile Integer iField Returns String
13133>>>>>        Integer iDSO
13133>>>>>        Get Data_set iFile to iDSO
13134>>>>>        If iDSO ;            Function_Return (Field_Current_Description(iDSO,iField))
13137>>>>>    End_Function
13138>>>>>    
13138>>>>>    // Required Messaging to Support Checkbox items in DEOs
13138>>>>>    //  Defines a field as a two item field and defines True and False values
13138>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
13140>>>>>        Set Field_CheckBox_Values of (Field_Attributes(Self)) iField ;            to sTrue sFalse
13141>>>>>    End_Procedure
13142>>>>>    
13142>>>>>    //    Returns a field's select_State based on the pased value
13142>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
13144>>>>>        Function_Return (Field_Value_Select_State(Field_Attributes(Self),iField,sValue))
13145>>>>>    End_Function
13146>>>>>    
13146>>>>>    //    Returns a field's select_State based on the DD buffer contents
13146>>>>>    Function Field_Select_State Integer iField Returns Integer
13148>>>>>        String sValue
13148>>>>>        Get Field_Current_Value iField to sValue
13149>>>>>        Function_Return (Field_Value_Select_State(Self,iField,sValue))
13150>>>>>    End_Function
13151>>>>>    
13151>>>>>    //   Returns a file/field' select_State based on contents of DD buffer
13151>>>>>    Function File_Field_Select_State Integer iFile Integer iField Returns Integer
13153>>>>>        Integer iDSO
13153>>>>>        Get Data_set iFile to iDSO
13154>>>>>        If iDSO ;            Function_Return (Field_Select_State(iDSO,iField))
13157>>>>>    End_Function
13158>>>>>    
13158>>>>>    //   Returns a file/field' select_State based on passed value
13158>>>>>    Function File_Field_Value_Select_State Integer iFile Integer iField ;            String sValue Returns Integer
13160>>>>>        Integer iDSO
13160>>>>>        Get Data_set iFile to iDSO
13161>>>>>        If iDSO ;            Function_Return (Field_Value_Select_State(iDSO,iField,sValue))
13164>>>>>    End_Function
13165>>>>>    
13165>>>>>    // get the actual database value that corresponds to the boolean value
13165>>>>>    // passed.
13165>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
13167>>>>>        Function_Return (Field_Checkbox_Value(Field_Attributes(Self),iField,iState))
13168>>>>>    End_Function
13169>>>>>    
13169>>>>>    Function File_Field_CheckBox_Value Integer iFile Integer iField Integer iState Returns String
13171>>>>>        Integer iDSO
13171>>>>>        Get Data_set iFile to iDSO
13172>>>>>        If iDSO ;            Function_Return (Field_Checkbox_Value(iDSO,iField,iState))
13175>>>>>    End_Function
13176>>>>>    
13176>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
13176>>>>>    Procedure Set Field_Select_State Integer iField Integer iState
13178>>>>>        String sValue
13178>>>>>        Get Field_Checkbox_Value iField iState to sValue
13179>>>>>        Set Field_Current_Value iField to sValue
13180>>>>>    End_Procedure
13181>>>>>    
13181>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
13181>>>>>    // if needed (set Field_Current_Value does this). First finds proper file
13181>>>>>    // DSO
13181>>>>>    Procedure Set File_Field_Select_State Integer iFile Integer iField Integer iState
13183>>>>>        Integer iDSO
13183>>>>>        Get Data_set iFile to iDSO
13184>>>>>        If iDSO ;            Set Field_Select_State of iDSO iField to iState
13187>>>>>    End_Procedure
13188>>>>>    
13188>>>>>    // Procedure to define a check string for a field.
13188>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
13190>>>>>        Set Field_Value_Check of (Field_Attributes(Self)) iField ;            to sCheck
13191>>>>>    End_Procedure
13192>>>>>    
13192>>>>>    // This function will be called indirectly by DEOs when an item is being
13192>>>>>    // entered, exited or needs validation. The first argument holds the
13192>>>>>    // fieldnumber for the field and the second holds the id of the message
13192>>>>>    // which can be send to retrieve the message which needs to be send for
13192>>>>>    // this Field/Event combination. The value of the second argument can be
13192>>>>>    // GET_Field_Entry_MSG, GET_Field_Exit_MSG or GET_Field_Validate_MSG.
13192>>>>>    Function Exec_Field_Message Integer iField Integer iMsg_ID Returns Integer
13194>>>>>        Integer iMsg
13194>>>>>        Integer iResult
13194>>>>>        String  sValue
13194>>>>>        Get iMsg_ID iField to iMsg
13195>>>>>        If iMsg Begin
13197>>>>>            Get Field_Current_Value iField to sValue
13198>>>>>            Get iMsg iField sValue to iResult
13199>>>>>        End
13199>>>>>>
13199>>>>>        Function_Return iResult
13200>>>>>    End_Function
13201>>>>>    
13201>>>>>    
13201>>>>>    // This function will be called from within DEOs when an item is being
13201>>>>>    // entered, exited or needs validation. The first argument holds the
13201>>>>>    // file number, the second argument holds the field and the third
13201>>>>>    // holds the id of the message  which can be send to retrieve the message
13201>>>>>    // which needs to be send for this File/Field/Event combination.
13201>>>>>    // The value of the second argument can be  GET_Field_Entry_MSG,
13201>>>>>    // GET_Field_Exit_MSG or GET_Field_Validate_MSG.
13201>>>>>    // This will redirect to the proper data-set object.
13201>>>>>    Function Exec_File_Field_Message Integer iFile Integer iField Integer iMsg_ID Returns Integer
13203>>>>>        Integer iDSO
13203>>>>>        Integer iResult
13203>>>>>        Get Data_set iFile to iDSO
13204>>>>>        If iDSO ;            Get Exec_Field_Message of iDSO iField iMsg_ID to iResult
13207>>>>>        Function_Return iResult
13208>>>>>    End_Function
13209>>>>>    
13209>>>>>    // Find the data-set whose main_file is the same as File#. The message
13209>>>>>    // Which_data_set includes updating parent files, we will throw those out.
13209>>>>>    // This has been augmented to search down the DDO tree if we do not find
13209>>>>>    // the DD with our quick C Which_Data_set search
13209>>>>>    Function Data_Set Integer iFile Returns Integer
13211>>>>>        Integer iTmp
13211>>>>>        Integer iDSO
13211>>>>>        Get Main_File to iTmp
13212>>>>>        If (iTmp = iFile) ;            Function_Return Self
13215>>>>>        Get Which_Data_Set iFile to iDSO
13216>>>>>        If iDSO Begin
13218>>>>>            // check that DS's main-file is the File (and not a parent file)
13218>>>>>            Get Main_File of iDSO to iTmp
13219>>>>>            If (iTmp = iFile) ;                Function_Return iDSO
13222>>>>>        End
13222>>>>>>
13222>>>>>        
13222>>>>>        // This really should have succeeded by now. If not we need to do a
13222>>>>>        // downward sweep looking for DD. This will be a slower process since it
13222>>>>>        // involves flex level DDO structure traversal. We should very rarely ever
13222>>>>>        // get to this point. If we do, it takes longer!
13222>>>>>        
13222>>>>>        // Unlike other traversals we will mark and check in a single
13222>>>>>        // step.
13222>>>>>        // This Mark_Id creates a sequence Id for this clear. This way
13222>>>>>        // DSOs only get cleared one time during this process.
13222>>>>>        Send IncrementCurrentMarkId
13223>>>>>        Get Private.Data_set iFile to iDSO // this does the recursive downward search
13224>>>>>        Function_Return iDSO
13225>>>>>    End_Function
13226>>>>>    
13226>>>>>    Function Private.Data_Set Integer iFile Returns Integer
13228>>>>>        Integer iMax
13228>>>>>        Integer iDSO hDD
13228>>>>>        Integer iCount
13228>>>>>        
13228>>>>>        If (iFile=Main_file(Self)) ;            Function_Return Self
13231>>>>>        
13231>>>>>        // We are only looking at sequence ID.
13231>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
13232>>>>>        
13232>>>>>        // recurse Down first, since we already tried upward direction.
13232>>>>>        Get Data_Set_Client_Count to iMax
13233>>>>>        Decrement iMax
13234>>>>>        For iCount from 0 to iMax
13240>>>>>>
13240>>>>>            Get Data_Set_Client iCount to iDSO
13241>>>>>            // If already cleared during this sequence...do nothing
13241>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
13243>>>>>                Get Private.Data_Set of iDSO iFile to hDD
13244>>>>>                If hDD ;                    Function_Return hDD // when found...get out
13247>>>>>            End
13247>>>>>>
13247>>>>>        Loop
13248>>>>>>
13248>>>>>        // recurse up server list next. We do this 2nd because it is
13248>>>>>        // the less likely path for success.
13248>>>>>        Get Data_Set_Server_Count to iMax
13249>>>>>        Decrement iMax
13250>>>>>        For iCount from 0 to iMax
13256>>>>>>
13256>>>>>            Get Data_Set_Server iCount to iDSO
13257>>>>>            // If already cleared during this sequence...do nothing
13257>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
13259>>>>>                Get Private.Data_Set of iDSO iFile to hDD
13260>>>>>                If hDD ;                    Function_Return hDD // when found...get out
13263>>>>>            End
13263>>>>>>
13263>>>>>        Loop
13264>>>>>>
13264>>>>>        Function_Return 0 // if here, our traversal has failed.
13265>>>>>    End_Function
13266>>>>>    
13266>>>>>    // These methods can be used to set/get a field property in a flexible
13266>>>>>    // way. The first two argument are the file- and fieldnumber followed by
13266>>>>>    // the ID of the message that should be send. The last argument should
13266>>>>>    // be the value to set or the variable to store the value in.
13266>>>>>    Procedure Set File_Field_Property Integer iFile Integer iField Integer iMsg String sValue
13268>>>>>        Integer iDSO
13268>>>>>        Get Data_Set iFile to iDSO
13269>>>>>        If iDSO Begin
13271>>>>>            Set iMsg of iDSO iField to sValue
13272>>>>>            Procedure_Return sValue
13273>>>>>        End
13273>>>>>>
13273>>>>>    End_Procedure
13274>>>>>    
13274>>>>>    Function File_Field_Property Integer iFile Integer iField Integer iMsg Returns Integer
13276>>>>>        Integer iDSO
13276>>>>>        String  sValue
13276>>>>>        Get Data_Set iFile to iDSO
13277>>>>>        If iDSO Begin
13279>>>>>            Get iMsg of iDSO iField to sValue
13280>>>>>            Function_Return sValue
13281>>>>>        End
13281>>>>>>
13281>>>>>    End_Function
13282>>>>>    
13282>>>>>    // This procedure will return the number of fields in the object
13282>>>>>    Function Field_Count Returns Integer
13284>>>>>        Function_Return (Item_Count(Record_Buffer(Self)) - 1)
13285>>>>>    End_Function
13286>>>>>    
13286>>>>>    // This procedure will clear all flags in the visited_fields string so
13286>>>>>    // that all field will be validated on the next requests.
13286>>>>>    Procedure Clear_Visited_Fields
13288>>>>>        // this clears field visitation marks
13288>>>>>        Set Visited_Fields to (Repeat(" ", Field_Count(Self)))
13289>>>>>    End_Procedure
13290>>>>>    
13290>>>>>    // Private.Initialize_Visited
13290>>>>>    // This procedure will be called when validations (and perhaps other
13290>>>>>    // events) is requested. It clears the visited marks and then proceeds
13290>>>>>    // to clear the marks up the server tree.
13290>>>>>    // This is passed two parameters: Up_and_down, If true upward and downward
13290>>>>>    // initialize. If Clear_Fields also clear the field string
13290>>>>>    Procedure Private.Initialize_Visited Integer Up_and_Down Integer Clear_Fields
13292>>>>>        Integer iMax
13292>>>>>        Integer iDSO
13292>>>>>        Integer iCount
13292>>>>>        
13292>>>>>        // recurse up server list first. Only recurse up
13292>>>>>        Get Data_Set_Server_Count to iMax
13293>>>>>        Decrement iMax
13294>>>>>        For iCount from 0 to iMax
13300>>>>>>
13300>>>>>            Get Data_Set_Server iCount to iDSO
13301>>>>>            // If already cleared during this sequence...do nothing
13301>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                Send Private.Initialize_Visited to iDSO False Clear_Fields
13304>>>>>        Loop
13305>>>>>>
13305>>>>>        
13305>>>>>        If Clear_Fields ;            Send Clear_Visited_Fields // clear all markers in this object
13308>>>>>        // this clears the visited mark for the entire object
13308>>>>>        Set Visited_State to False
13309>>>>>        Set DownDelete_State to False
13310>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
13311>>>>>        
13311>>>>>        // If Up_and_Down recurse Down server list
13311>>>>>        If Up_and_Down Begin
13313>>>>>            Get Data_Set_Client_Count to iMax
13314>>>>>            Decrement iMax // **EK** This line was missing
13315>>>>>            For iCount from 0 to iMax
13321>>>>>>
13321>>>>>                Get Data_Set_Client iCount to iDSO
13322>>>>>                // If already cleared during this sequence...do nothing
13322>>>>>                If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                    Send Private.Initialize_Visited to iDSO True Clear_Fields
13325>>>>>            Loop
13326>>>>>>
13326>>>>>        End
13326>>>>>>
13326>>>>>    End_Procedure
13327>>>>>    
13327>>>>>    
13327>>>>>    // Clears Visited marks and (maybe) field visited marks in all required
13327>>>>>    // DSOs. If Up_and_Down is TRUE DSOs are marked up and Down (delete style)
13327>>>>>    // propagation. If False, DSOs are marked up (save style). This does not
13327>>>>>    // have a mode to mark ALL DSOs in a structure. (Not needed so far).
13327>>>>>    // If Clear_Fields is T the field string marker is also cleared.
13327>>>>>    // The method of using the global integer DD_Current_Mark_ID is an opt-
13327>>>>>    // imizer. This is private - do not tamper with it!
13327>>>>>    // Note that Intialize_Visited does not always Clear all DDOs in the structure. When
13327>>>>>    // Up_and_Down is true, it is marking all DDOs that will participate in a cascade delete
13327>>>>>    // which may not be all DDOs in the structure. If you want to initialize all DDOs use InitializeAllVisited
13327>>>>>    Procedure Initialize_Visited Integer Up_and_Down Integer Clear_Fields
13329>>>>>        Send IncrementCurrentMarkId
13330>>>>>        Send Private.Initialize_Visited Up_and_Down Clear_Fields
13331>>>>>    End_Procedure
13332>>>>>    
13332>>>>>    Procedure InitializeAllVisited2
13334>>>>>        Integer iMax iCount
13334>>>>>        Handle hoDSO
13334>>>>>        
13334>>>>>        Set Visited_State to False
13335>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id // marks this as visited
13336>>>>>        
13336>>>>>        // recurse up server list.
13336>>>>>        Get Data_Set_Server_Count to iMax
13337>>>>>        For iCount from 0 to (iMax-1)
13343>>>>>>
13343>>>>>            Get Data_Set_Server iCount to hoDSO
13344>>>>>            // If already cleared during this sequence...do nothing
13344>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 of hoDSO
13347>>>>>        Loop
13348>>>>>>
13348>>>>>        
13348>>>>>        // recurse down client list.
13348>>>>>        Get Data_Set_Client_Count to iMax
13349>>>>>        For iCount from 0 to (iMax-1)
13355>>>>>>
13355>>>>>            Get Data_Set_Client iCount to hoDSO
13356>>>>>            // If already cleared during this sequence...do nothing
13356>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 to hoDSO
13359>>>>>        Loop
13360>>>>>>
13360>>>>>    End_Procedure
13361>>>>>    
13361>>>>>    // clears visited flag for *all* ddos in the structure.
13361>>>>>    Procedure InitializeAllVisited
13363>>>>>        Send IncrementCurrentMarkId
13364>>>>>        Send InitializeAllVisited2
13365>>>>>    End_Procedure
13366>>>>>    
13366>>>>>    
13366>>>>>    // Internal recursive message to check file connections. Called from
13366>>>>>    // Valid_connections only. Private message
13366>>>>>    Function Private.Valid_Structure Integer Up_And_Down Returns Integer
13368>>>>>        Integer iRval iCount iMax
13368>>>>>        Handle iDSO iPDSO
13368>>>>>        Integer iPMax iPCount iPMain
13368>>>>>        Boolean bUpDown bNull bCascadeNull bDown
13368>>>>>        
13368>>>>>        // Check Current Connections
13368>>>>>        Get Valid_Servers to iRval           // always check servers
13369>>>>>        If (iRval=0 and Up_and_Down) ;       // check Clients if required            Get Valid_Clients to iRval
13372>>>>>        Set Visited_State to True
13373>>>>>        
13373>>>>>        // Ask Server data-sets to check their server connections
13373>>>>>        If not iRval Begin // check up
13375>>>>>            Get Data_Set_Server_Count to iMax
13376>>>>>            Decrement iMax
13377>>>>>            For iCount from 0 to iMax
13383>>>>>>
13383>>>>>                Get Data_Set_Server iCount to iDSO
13384>>>>>                If not (Visited_state(iDSO)) ;                    Get Private.Valid_Structure of iDSO False to iRVal
13387>>>>>            Until iRval
13389>>>>>        End
13389>>>>>>
13389>>>>>        
13389>>>>>        // If required, Ask Clients to check their server and client connections
13389>>>>>        //
13389>>>>>        If (iRval=0 and Up_and_Down) Begin // check down
13391>>>>>            Get Data_Set_Client_Count to iMax
13392>>>>>            Decrement iMax
13393>>>>>            For iCount from 0 to iMax
13399>>>>>>
13399>>>>>                Get Data_Set_Client iCount to iDSO
13400>>>>>                If not (Visited_state(iDSO)) Begin
13402>>>>>                    Get Data_Set_Server_Count of iDSO to iPMax
13403>>>>>                    // test if all deletable parents for a non parent null allowed/cascade delete null
13403>>>>>                    For iPCount from 0 to (iPMax-1)
13409>>>>>>
13409>>>>>                        Get Data_Set_Server of iDSO iPCount to iPDSO
13410>>>>>                        Get DownDelete_State of iPDSO to bDown
13411>>>>>                        If (bDown) Begin
13413>>>>>                            Get Main_File of iPDSO to iPMain
13414>>>>>                            Get IsNullParentAllowed of iDSO iPMain to bNull
13415>>>>>                            Get IsCascadeDeleteNull of iDSO iPMain to bCascadeNull
13416>>>>>                            Move (not(bNull) or not(bCascadeNull)) to bUpDown
13417>>>>>                        End
13417>>>>>>
13417>>>>>                    Until bUpDown
13419>>>>>                    Get Private.Valid_Structure of iDSO bUpDown to iRVal
13420>>>>>                End
13420>>>>>>
13420>>>>>            Until iRval
13422>>>>>        End
13422>>>>>>
13422>>>>>        
13422>>>>>        Function_Return iRVal
13423>>>>>        
13423>>>>>    End_Function
13424>>>>>    
13424>>>>>    // Validate data-set updating connections against required connections
13424>>>>>    // Pass: Up_and_down=T if we should check Server and Client connections
13424>>>>>    //                  =F is we only check servers
13424>>>>>    // Ret: 0 if ok, Missing File# if not ok.
13424>>>>>    // Up_And_Down should be true when testing for cascade delete structures and
13424>>>>>    // false when testing for save / delete-no-cascade structures
13424>>>>>    Function Valid_Structure Integer Up_And_Down Returns Integer
13426>>>>>        Send Initialize_Visited Up_and_Down False // False=don't clear field marks
13427>>>>>        If (Up_And_Down) Begin
13429>>>>>            Send MarkDDOsForCascadeDelete
13430>>>>>        End
13430>>>>>>
13430>>>>>        Function_Return (Private.Valid_Structure(Self,Up_and_Down))
13431>>>>>    End_Function
13432>>>>>    
13432>>>>>    // mark all DDOs which are part of this deletes cascade delete tree
13432>>>>>    // mark this and all clients as Downward deletable. This includes
13432>>>>>    // cacscade delete and cascade set to null (not for cascade_delete_state=F)
13432>>>>>    Procedure MarkDDOsForCascadeDelete
13434>>>>>        Integer iMax  iCount
13434>>>>>        Boolean bDown
13434>>>>>        Handle hoDDO
13434>>>>>        Set DownDelete_State to True
13435>>>>>        Get Data_Set_Client_Count to iMax
13436>>>>>        For iCount from 0 to (iMax-1)
13442>>>>>>
13442>>>>>            Get Data_Set_Client iCount to hoDDO
13443>>>>>            Get DownDelete_State of hoDDO to bDown
13444>>>>>            If not bDown Begin // circular DDO test - never do this
13446>>>>>                Send MarkDDOsForCascadeDelete of hoDDO
13447>>>>>            End
13447>>>>>>
13447>>>>>        Loop
13448>>>>>>
13448>>>>>    End_Procedure
13449>>>>>    
13449>>>>>    
13449>>>>>    // This function will execute the validation message for each field within
13449>>>>>    // this object. If DoAllFG is true all items are validated. If false
13449>>>>>    // only unvisited items are checked.
13449>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
13449>>>>>    // do something with the possible cascade of errors
13449>>>>>    // if the err returns DFERR_ENTER_VALID_REC_ID we will not continue
13449>>>>>    // the validation (the other fields will be bad). This works best if the
13449>>>>>    // findreq appears as one of the first fields in the file (which is almost
13449>>>>>    // always the case
13449>>>>>    Function Validate_Fields Integer DoAllFg Integer bNoStop Returns Integer
13451>>>>>        Integer iRetval
13451>>>>>        Integer iMax
13451>>>>>        Integer iCount
13451>>>>>        Integer iFile
13451>>>>>        Integer iErr
13451>>>>>        String  sVS
13451>>>>>        Get Visited_Fields to sVS
13452>>>>>        Get Field_Count to iMax
13453>>>>>        Get Main_File to iFile
13454>>>>>        For iCount from 1 to iMax
13460>>>>>>
13460>>>>>            If (DoAllFG or Mid(sVS, 1, iCount)=" ") Begin
13462>>>>>                Get Validate_Field iCount to iErr
13463>>>>>                If iErr Begin
13465>>>>>                    Move iErr to iRetVal
13466>>>>>                    // error occurred. If not no-stop or the error is
13466>>>>>                    // a findreq error - we are done.
13466>>>>>                    If (not(bNoStop) or iRetVal=DFERR_ENTER_VALID_REC_ID) ;                        Function_Return iRetVal
13469>>>>>                End
13469>>>>>>
13469>>>>>            End
13469>>>>>>
13469>>>>>        Loop
13470>>>>>>
13470>>>>>        Function_Return iRetval
13471>>>>>    End_Function
13472>>>>>    
13472>>>>>    // 17.0 - added support for null-parents. If null parents allowed, req lets it through
13472>>>>>    Function Validate_Required Integer iField Returns Integer
13474>>>>>        Boolean bNull bErr
13474>>>>>        
13474>>>>>        Move (trim(Field_Current_Value(Self,iField))='') to bErr
13475>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTRY_REQUIRED ""
13478>>>>>        Function_Return bErr
13479>>>>>    End_Function
13480>>>>>    
13480>>>>>    // return true if we should skip validation for this field. This can happen with Null allowed parents.
13480>>>>>    // if this is foreign, new and has no changes and is null allowed we will skip.
13480>>>>>    Function SkipValidate Integer iField Returns Boolean
13482>>>>>        Boolean bSkip bFieldChanged bEmpty
13482>>>>>        String sValue
13482>>>>>        
13482>>>>>        If (OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(changed_state(Self))) Begin
13484>>>>>            // We must also check field_changed_state and only skip if this is not changed.
13484>>>>>            Get Field_Changed_State iField to bFieldChanged
13485>>>>>            // Retain and remember may set field_changed_state to true even when empty. If this field is changed
13485>>>>>            // but its value is empty we assume it is a candidate for Null checking, so we will set field-changed to false
13485>>>>>            If bFieldChanged Begin
13487>>>>>                Get Field_Current_Value iField to sValue
13488>>>>>                Get IsEmptyField iField sValue to bEmpty
13489>>>>>                If bEmpty Begin
13491>>>>>                    Move False to bFieldChanged
13492>>>>>                End
13492>>>>>>
13492>>>>>            End
13492>>>>>>
13492>>>>>            If (not(bFieldChanged)) Begin
13494>>>>>                // we must find the child that points to this DD, starting with operation_origin. If a child
13494>>>>>                // is found, it will be in array position 1 (0 is self, 1 is child)
13494>>>>>                Get IsNullParentOrAncestor to bSkip
13495>>>>>            End
13495>>>>>>
13495>>>>>        End
13495>>>>>>
13495>>>>>        Function_Return bSkip
13496>>>>>    End_Function
13497>>>>>    
13497>>>>>    
13497>>>>>    // This will tell us if this DD can be treated as either a null parent
13497>>>>>    // or an ancestor of a null parent. This should only be called for a DD
13497>>>>>    // that is a candidate for this meaning that it does not have a change.
13497>>>>>    // We will test if its child allows this parent to be null or if this
13497>>>>>    // is in the path of an allowed null parent. We assume that parents of
13497>>>>>    // null parents will also be null. This is used to test if validations are
13497>>>>>    // needed.
13497>>>>>    Function IsNullParentOrAncestor Returns Boolean
13499>>>>>        Handle[] hoDDs
13500>>>>>        Integer i iSize iMain
13500>>>>>        Boolean bNullAllowed
13500>>>>>        // gets an array where 0 is self, 1 is parent, 2 is grandparent, and the
13500>>>>>        // last item is the operation_origin.
13500>>>>>        Send DDOServerPath of operation_origin Self (&hoDDs)
13501>>>>>        Move (SizeOfArray(hoDDs)) to iSize
13502>>>>>        If (iSize) Begin
13504>>>>>            // see if the immediate child allows this to be null.
13504>>>>>            Get Main_File to iMain
13505>>>>>            Get IsNullParentAllowed of hoDDs[1] iMain to bNullAllowed
13506>>>>>            
13506>>>>>            // if null not allowed, see if this is an ancestor to a null allowed
13506>>>>>            // parent where all DDs in this path are unchanged. For example:
13506>>>>>            // G.DD <- P.DD <- C.DD where we C.DD allows P.DD to be null and we
13506>>>>>            // want to test if G.DD needs validation
13506>>>>>            Move 1 to i
13507>>>>>            While (not(bNullAllowed) and (i+1<iSize) and not(changed_state(hoDDs[i])) )
13511>>>>>                Get Main_File of hoDDs[i] to iMain
13512>>>>>                Get IsNullParentAllowed of hoDDs[i+1] iMain to bNullAllowed
13513>>>>>                Increment i
13514>>>>>            Loop
13515>>>>>>
13515>>>>>            
13515>>>>>        End
13515>>>>>>
13515>>>>>        Function_Return bNullAllowed
13516>>>>>    End_Function
13517>>>>>    
13517>>>>>    
13517>>>>>    Function Validate_FindReq Integer iField Returns Integer
13519>>>>>        Integer bErr iOpts
13519>>>>>        // if no current record, we have not found the required record.
13519>>>>>        Move (not(HasRecord(Self))) to bErr
13520>>>>>        // We also need to check if the field is changed. If the field is changed and this
13520>>>>>        // is an autofind field, this indicates that an autofind was attempted and failed. We
13520>>>>>        // can't jut rely on current_record because a failed autofind restores the old current
13520>>>>>        // record. For this to work, DEOs must set the DD field's changed_state to true on
13520>>>>>        // no-put fields (dd_deomx.pkg was changed to do this).
13520>>>>>        If (not(bErr) and field_changed_state(Self,iField)) Begin
13522>>>>>            Get Field_Options iField to iOpts
13523>>>>>            Move ( ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) or ;                ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ) ;                to bErr
13524>>>>>        End
13524>>>>>>
13524>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTER_VALID_REC_ID ""
13527>>>>>        Function_Return bErr
13528>>>>>    End_Function
13529>>>>>    
13529>>>>>    // This function will be called to validate a field.
13529>>>>>    // mark field currently being validated
13529>>>>>    // Altered to Check DD options (required, findreq)
13529>>>>>    Function Validate_Field Integer iField Returns Integer
13531>>>>>        Integer iResult
13531>>>>>        Integer iMsg
13531>>>>>        Integer iObj
13531>>>>>        String  sValue
13531>>>>>        Integer iFile
13531>>>>>        Integer iOpts iMain
13531>>>>>        Boolean bSkipValidate
13531>>>>>        Handle[] hoDDs
13532>>>>>        
13532>>>>>        Set Current_Validate_Field to iField
13533>>>>>        
13533>>>>>        // test if we should skip validation on this field
13533>>>>>        Get SkipValidate iField to bSkipValidate
13534>>>>>        
13534>>>>>        If (not(bSkipValidate)) Begin
13536>>>>>            
13536>>>>>            Move (Record_Buffer(Self)) to iObj
13537>>>>>            Get Main_File to iFile
13538>>>>>            
13538>>>>>            // Check for DD option failures: required, find_required
13538>>>>>            // "File_field" gets regular and foreign fields as needed
13538>>>>>            //Get File_Field_Options iFile iField to iOpts
13538>>>>>            Get Field_Options iField to iOpts  // get reg options
13539>>>>>            // if this is not the DDO that started the validation, we will assume that
13539>>>>>            // this is foreign. Operation_origin is set in Request_Validate
13539>>>>>            // If foreign (as defined above) and we do not allow new saves when
13539>>>>>            // foreign, we will consider this to be foreign and add foreign options
13539>>>>>            If (Operation_Origin<>Self and ;                Allow_Foreign_New_Save_State(Self)=0)  ;                Move (iOpts ior Foreign_Field_Options(Self, iField)) to iOpts
13542>>>>>            
13542>>>>>            
13542>>>>>            // Check for FindReq first. If it fails, set iResult to DFERR_ENTER_VALID_REC_ID so
13542>>>>>            // the calling function knows that a findreq failed. Always do this validation first
13542>>>>>            If (iOpts iand DD_FINDREQ) ;                Get Validate_FindReq  iField to iResult
13545>>>>>            If iResult Begin
13547>>>>>                Send AddDDHasFindReqError
13548>>>>>                Move DFERR_ENTER_VALID_REC_ID to iResult
13549>>>>>            End
13549>>>>>>
13549>>>>>            Else Begin
13550>>>>>                
13550>>>>>                If (iOpts iand DD_REQUIRED) ;                    Get Validate_Required iField to iResult
13553>>>>>                
13553>>>>>                If (iResult=0) Begin
13555>>>>>                    // First execute the user defined validation message
13555>>>>>                    Get Item_Validate_MSG of iObj iField to iMsg
13556>>>>>                    If iMsg Begin
13558>>>>>                        Get Field_Current_Value iField to sValue
13559>>>>>                        Get iMsg iField sValue to iResult
13560>>>>>                    End
13560>>>>>>
13560>>>>>                End
13560>>>>>>
13560>>>>>                
13560>>>>>                // Check for keys
13560>>>>>                If (iResult=0 and Key_Field_State(Self, iField)) ;                    Get Validate_Key_Field iField to iResult
13563>>>>>                
13563>>>>>                // Do extended validations
13563>>>>>                If (iResult=0) ;                    Get Validate_Field of (Field_Attributes(Self)) iField to iResult
13566>>>>>            End
13566>>>>>>
13566>>>>>        End
13566>>>>>>
13566>>>>>        
13566>>>>>        Set Current_Validate_Field to 0
13567>>>>>        // Mark this field being validated
13567>>>>>        Get Visited_Fields to sValue
13568>>>>>        Set Visited_Fields to (Overstrike("X", sValue, iField))
13569>>>>>        
13569>>>>>        Function_Return iResult
13570>>>>>        
13570>>>>>    End_Function
13571>>>>>    
13571>>>>>    
13571>>>>>    // This function will be called to validate a field.
13571>>>>>    Function File_Field_Validate_Field Integer iFile Integer iField Returns Integer
13573>>>>>        Integer iDSO
13573>>>>>        Integer iResult
13573>>>>>        Integer hOldOrigin
13573>>>>>        Get Data_Set iFile to iDSO
13574>>>>>        If not iDSO ;            Function_Return 0
13577>>>>>        
13577>>>>>        // This function is only called by the DEOs.
13577>>>>>        // It is possible for validate_item when called as part of
13577>>>>>        // request_validate to get called more than once
13577>>>>>        // when a field is foreign (it is attached to both its DDO and the
13577>>>>>        // child-main ddo). This makes sure the validation is only called once.
13577>>>>>        // (vdf7 change: previously we set OpMode to Mode_Saving and checked that, now we have
13577>>>>>        // a mode just for request_validate).
13577>>>>>        If (Operation_Mode=MODE_VALIDATING and ;         // if from request_validate            Mid(Visited_Fields(iDSO), 1, iField)="X" ) ; // and already marked            Function_Return 0                         // skip it
13580>>>>>        
13580>>>>>        Move Operation_origin to hOldOrigin
13581>>>>>        
13581>>>>>        // if from request_validate operation_origin will be set and should not
13581>>>>>        // be reset here.
13581>>>>>        If (OPERATION_ORIGIN=0) Begin
13583>>>>>            Move Self to Operation_Origin
13584>>>>>        End
13584>>>>>>
13584>>>>>        
13584>>>>>        Get Validate_Field of iDSO iField to iResult
13585>>>>>        Move hOldOrigin to Operation_Origin
13586>>>>>        Function_Return iResult
13587>>>>>    End_Function
13588>>>>>    
13588>>>>>    // This function will be called to check if a key has been changed.
13588>>>>>    Function Validate_Key_Field Integer iField Returns Integer
13590>>>>>        String  sOld_Value
13590>>>>>        String  sNew_Value
13590>>>>>        String  sKeys
13590>>>>>        Integer iState
13590>>>>>        Boolean bMultiKeys
13590>>>>>        Get Protect_Key_State to iState
13591>>>>>        If iState Begin
13593>>>>>            Get Key_Value to sNew_Value
13594>>>>>            // Only check existing records.
13594>>>>>            If (HasRecord(Self)) Begin
13596>>>>>                Get Existing_Key_Value to sOld_Value
13597>>>>>                If (sNew_Value <> sOld_Value) Begin
13599>>>>>                    // we have an error. If there is only one key field we know
13599>>>>>                    // where the field is and we can report that field. If we have
13599>>>>>                    // multiple key fields, we don't really know where the offending key change
13599>>>>>                    // is, so we will not report a field.
13599>>>>>                    Get Key_Fields to sKeys
13600>>>>>                    Move (Pos("X",sKeys)<>RightPos("X",sKeys)) to bMultiKeys
13601>>>>>                    Send Data_set_Error (If(bMultiKeys, -1, iField)) 0 DD_TEXT_NO_KEY_CHANGE_ALLOWED
13602>>>>>                    Function_Return 1
13603>>>>>                End
13603>>>>>>
13603>>>>>            End
13603>>>>>>
13603>>>>>        End
13603>>>>>>
13603>>>>>    End_Function
13604>>>>>    
13604>>>>>    
13604>>>>>    // During request_validate process tell us if this DD has had a find_request error. This
13604>>>>>    // is handled by the DD that originated the request_validate. Very private
13604>>>>>    Function DDHasFindReqError Returns Boolean
13606>>>>>        Handle[] DDsWithFindReqErrors
13607>>>>>        Integer iIndex
13607>>>>>        If (OPERATION_ORIGIN) Begin
13609>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13610>>>>>            Move (SearchArray(Self,DDsWithFindReqErrors)) to iIndex
13611>>>>>            Function_Return (iIndex<>-1)
13612>>>>>        End
13612>>>>>>
13612>>>>>    End_Function
13613>>>>>    
13613>>>>>    // During a request_validate a find_request error has occurred. Add this DD
13613>>>>>    // to list of DDs that have this error. This is handled by the DD that
13613>>>>>    // originated the request_validate.  Very private
13613>>>>>    Procedure AddDDHasFindReqError
13615>>>>>        Handle[] DDsWithFindReqErrors
13616>>>>>        If (OPERATION_ORIGIN) Begin
13618>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13619>>>>>            Move Self to DDsWithFindReqErrors[SizeOfArray(DDsWithFindReqErrors)]
13620>>>>>            Set pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13621>>>>>        End
13621>>>>>>
13621>>>>>    End_Procedure
13622>>>>>    
13622>>>>>    // This function will execute the validation message for each field of the
13622>>>>>    // data set and all of its parents in parent first order.
13622>>>>>    // Pass: DoALLFg bNoStop
13622>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
13622>>>>>    // do something with the possible cascade of errors
13622>>>>>    Function Validate_Data_Sets Integer DoAllFg Integer bNoStop Returns Integer
13624>>>>>        Integer iDSO
13624>>>>>        Integer iRetval
13624>>>>>        Integer iCount
13624>>>>>        Integer iMax
13624>>>>>        Integer bErr
13624>>>>>        Boolean bDDHasFindReqError
13624>>>>>        // ShowLn "Validate_Data_Sets in Data_Set in " (Name(self))
13624>>>>>        // Validate if not foreign, or foreign new saves allowed, or
13624>>>>>        // foreign validation is supported (it normally is)
13624>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self) or ;            Validate_Foreign_File_State(Self)) Begin
13626>>>>>            
13626>>>>>            If (bNoStop) Begin
13628>>>>>                // if do all, it is possible that this DD as a find-req error. If so there is no
13628>>>>>                // need to look for more errors in this DD or its parents. This makes the do all checking
13628>>>>>                // a little more intelligent and doesn't return a bunch of errors when it is not needed
13628>>>>>                Get DDHasFindReqError to bDDHasFindReqError
13629>>>>>            End
13629>>>>>>
13629>>>>>            
13629>>>>>            If (not(bDDHasFindReqError)) Begin
13631>>>>>                Get Data_Set_Server_Count to iMax
13632>>>>>                Decrement iMax
13633>>>>>                For iCount from 0 to iMax
13639>>>>>>
13639>>>>>                    Get Data_Set_Server iCount to iDSO
13640>>>>>                    If not (Visited_state(iDSO)) Begin
13642>>>>>                        Get Validate_Data_Sets of iDSO DoAllFg bNoStop to bErr
13643>>>>>                        If bErr Begin
13645>>>>>                            Move bErr to iRetVal
13646>>>>>                            If bNoStop ;                                Move 0 to bErr
13649>>>>>                        End
13649>>>>>>
13649>>>>>                    End
13649>>>>>>
13649>>>>>                Until bErr
13651>>>>>                If not bErr Begin
13653>>>>>                    Get Validate_Fields DoAllFg bNoStop to bErr
13654>>>>>                    If bErr ;                        Move bErr to iRetVal
13657>>>>>                End
13657>>>>>>
13657>>>>>            End
13657>>>>>>
13657>>>>>        End
13657>>>>>>
13657>>>>>        Set Visited_State to True
13658>>>>>        Function_Return iRetval
13659>>>>>    End_Function
13660>>>>>    
13660>>>>>    // This tests the DDO and all "up" DDOs to see if a switched parent / commit test even needs to be
13660>>>>>    // tested. This is called by the top ValidateSwitchedCommittedParents to see if a switch parent test
13660>>>>>    // even needs to be applied before it has to refinds records.
13660>>>>>    // Return true is there is nothing to test (i.e., the shortcut worked).
13660>>>>>    Function IsCommittedRecursiveUpParentChangeAllowed Returns Boolean
13662>>>>>        Boolean bAllowed bCommitted bVisited bHasRecord
13662>>>>>        Integer iServers iSrvr iParent
13662>>>>>        Handle hoSrvr
13662>>>>>        
13662>>>>>        
13662>>>>>        // optimization. We only test committed parents if one parent does not allow changing committed records.
13662>>>>>        // This avoids extra finds and relates when not needed
13662>>>>>        Set Visited_State to True
13663>>>>>        Get Data_Set_Server_Count to iServers
13664>>>>>        Get IsCommitted to bCommitted
13665>>>>>        Move 0 to iSrvr
13666>>>>>        Move True to bAllowed
13667>>>>>        While (iSrvr<iServers and bAllowed)
13671>>>>>            Get Data_Set_Server iSrvr to hoSrvr
13672>>>>>            Get Main_File of hoSrvr to iParent
13673>>>>>            // if committed and parent change not allowed, we are done
13673>>>>>            If (bCommitted) Begin
13675>>>>>                Get IsCommittedParentChangeAllowed iParent to bAllowed
13676>>>>>            End
13676>>>>>>
13676>>>>>            // if still allowed, check all parents
13676>>>>>            If (bAllowed) Begin
13678>>>>>                Get Visited_State of hoSrvr to bVisited
13679>>>>>                If not bVisited Begin
13681>>>>>                    Get IsCommittedRecursiveUpParentChangeAllowed of hoSrvr to bAllowed
13682>>>>>                End
13682>>>>>>
13682>>>>>            End
13682>>>>>>
13682>>>>>            Increment iSrvr
13683>>>>>        Loop
13684>>>>>>
13684>>>>>        Function_Return bAllowed
13685>>>>>    End_Function
13686>>>>>    
13686>>>>>    
13686>>>>>    // special validate-save check for changed committed parent. If the record is committed
13686>>>>>    // and it has a switched parent and this is not allowed, we have an error. This should rarely happen because the
13686>>>>>    // DEOs should guard aginst this. This is a recursive routine that requires special attention the first time through.
13686>>>>>    // When called from the we must refind the original record and all original parents. This way we can compare these parent
13686>>>>>    // rowids to the DD row id (if different, they've changed). At the end we must restore the DD records. Because this takes time
13686>>>>>    // we only even do this if this is committed and there is a chance that there are changed parents
13686>>>>>    
13686>>>>>    Function ValidateSwitchedCommittedParents Boolean bTop Returns Boolean
13688>>>>>        Integer iServers iSrvr iMain iParent iPMain
13688>>>>>        Handle hoSrvr
13688>>>>>        RowID riCrnt riParent riPCrnt
13688>>>>>        Boolean bChanged bCommitted bAllowed bErr bParentChanged bVisited
13688>>>>>        Boolean bHasRecord bPHasRecord bFound
13688>>>>>        
13688>>>>>        
13688>>>>>        // Shortcut optimization. This tests for any committed DDO with a parent that doesn't allow a switch
13688>>>>>        // return true if there is any reason to actually test any DDO up the tree for a parent change
13688>>>>>        If bTop Begin
13690>>>>>            // init visited nodes, these will be tested and set in IsCommittedRecursiveUpParentChangeAllowed
13690>>>>>            Send Initialize_Visited False False //false=up only, true=clear fields
13691>>>>>            Get IsCommittedRecursiveUpParentChangeAllowed to bAllowed
13692>>>>>            If bAllowed Begin
13694>>>>>                Function_Return False // if all are allowed, we have nothing to test - its ok
13695>>>>>            End
13695>>>>>>
13695>>>>>        End
13695>>>>>>
13695>>>>>        
13695>>>>>        Get Main_File to iMain
13696>>>>>        Get CurrentRowId to riCrnt
13697>>>>>        Get Data_Set_Server_Count to iServers
13698>>>>>        Get HasRecord to bHasRecord
13699>>>>>        
13699>>>>>        If (bHasRecord and (bTop or not(IsSameRowID(GetRowID(iMain),riCrnt))) ) Begin
13701>>>>>            // this refinds the main record and, most importantly, relates all original parents on up
13701>>>>>            // We now have the original parents which we can test to see if they are changed.
13701>>>>>            Get ReadByRowIdEx iMain riCrnt to bFound
13702>>>>>            If not bFound Begin
13704>>>>>                Error DFERR_CANT_REFIND_RECORD
13705>>>>>>
13705>>>>>                Function_Return True
13706>>>>>            End
13706>>>>>>
13706>>>>>        End
13706>>>>>>
13706>>>>>        
13706>>>>>        If (bTop) Begin
13708>>>>>            // If at start, init visited nodes, these will be tested and set during recursive calls to this function
13708>>>>>            Send Initialize_Visited False False // false=up only, true=clear fields
13709>>>>>        End
13709>>>>>>
13709>>>>>        
13709>>>>>        Set Visited_State to True
13710>>>>>        Get IsCommitted to bCommitted
13711>>>>>        If bCommitted Begin
13713>>>>>            // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
13713>>>>>            // First see any any of the parents are changed.
13713>>>>>            Get Parent_Changed_State to bChanged
13714>>>>>            If bChanged Begin
13716>>>>>                // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
13716>>>>>                Move 0 to iSrvr
13717>>>>>                While (iSrvr<iServers and not(bErr))
13721>>>>>                    Get Data_Set_Server iSrvr to hoSrvr
13722>>>>>                    Get Main_File of hoSrvr to iParent
13723>>>>>                    Get CurrentRowId of hoSrvr to riParent
13724>>>>>                    Move (not(IsSameRowID(GetRowID(iParent),riParent))) to bParentChanged // is parent changed?
13725>>>>>                    If bParentChanged Begin
13727>>>>>                        Get IsCommittedParentChangeAllowed iParent to bAllowed // is changing committed parent allowed?
13728>>>>>                        If not bAllowed Begin
13730>>>>>                            Move True to bErr
13731>>>>>                            If bErr Begin
13733>>>>>                                Send Data_Set_Error of hoSrvr -1 0 DD_CANNOT_SWITCH_PARENT
13734>>>>>                            End
13734>>>>>>
13734>>>>>                        End
13734>>>>>>
13734>>>>>                    End
13734>>>>>>
13734>>>>>                    Increment iSrvr
13735>>>>>                Loop
13736>>>>>>
13736>>>>>            End
13736>>>>>>
13736>>>>>        End
13736>>>>>>
13736>>>>>        
13736>>>>>        // no error in immediate we must continue this check up the parent tree.
13736>>>>>        Move 0 to iSrvr
13737>>>>>        While (iSrvr<iServers and not(bErr))
13741>>>>>            Get Data_Set_Server iSrvr to hoSrvr
13742>>>>>            Get Visited_State of hoSrvr to bVisited
13743>>>>>            If (not(bVisited)) Begin
13745>>>>>                
13745>>>>>                // if new record, we need to refind parent records from here since you cannot
13745>>>>>                // have done a find/relate on a new record.
13745>>>>>                If (not(bHasRecord)) Begin
13747>>>>>                    Get HasRecord of hoSrvr to bPHasRecord
13748>>>>>                    If (bPHasRecord) Begin
13750>>>>>                        Get Main_File of hoSrvr to iPMain
13751>>>>>                        Get CurrentRowId of hoSrvr to riPCrnt
13752>>>>>                        If (not(IsNullRowID(riPCrnt))) Begin
13754>>>>>                            Get ReadByRowIdEx of hoSrvr iPMain riPCrnt to bFound
13755>>>>>                            If not bFound Begin
13757>>>>>                                Error DFERR_CANT_REFIND_RECORD
13758>>>>>>
13758>>>>>                                Function_Return True
13759>>>>>                            End
13759>>>>>>
13759>>>>>                        End
13759>>>>>>
13759>>>>>                    End
13759>>>>>>
13759>>>>>                End
13759>>>>>>
13759>>>>>                
13759>>>>>                Get ValidateSwitchedCommittedParents of hoSrvr False to bErr // call recursively up the parent tree
13760>>>>>            End
13760>>>>>>
13760>>>>>            Increment iSrvr
13761>>>>>        Loop
13762>>>>>>
13762>>>>>        
13762>>>>>        If bTop Begin // if back to the top, make sure our buffers are correct.
13764>>>>>            Send Refind_Records
13765>>>>>        End
13765>>>>>>
13765>>>>>        
13765>>>>>        Function_Return bErr
13766>>>>>    End_Function
13767>>>>>    
13767>>>>>    Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
13769>>>>>        
13769>>>>>        Handle hoBuff hoDSO
13769>>>>>        Boolean bCommit bIsFind bVisited bIsForeign
13769>>>>>        Integer iMax iCount iItems iOpts iChanges
13769>>>>>        
13769>>>>>        
13769>>>>>        Move record_buffer to hoBuff
13770>>>>>        Move (OPERATION_MODE<>MODE_SAVING) to bIsFind
13771>>>>>        
13771>>>>>        // first recurse to all parent ddos
13771>>>>>        Get Data_Set_Server_Count to iMax
13772>>>>>        Decrement iMax
13773>>>>>        For iCount from 0 to iMax
13779>>>>>>
13779>>>>>            Get Data_Set_Server iCount to hoDSO
13780>>>>>            Get Visited_State of hoDSO to bVisited
13781>>>>>            If not (bVisited) Begin
13783>>>>>                Send Entry_Update_Data_Sets to hoDSO iFile iAll
13784>>>>>            End
13784>>>>>>
13784>>>>>        Loop
13785>>>>>>
13785>>>>>        
13785>>>>>        // if find, we only do this if the main file is the same as the find file
13785>>>>>        If (not(bIsFind) or iFile=Main_File(Self)) Begin
13787>>>>>            If (not(bIsFind)) Begin
13789>>>>>                // if a save, we care if it is committed.
13789>>>>>                Get IsCommitted to bCommit
13790>>>>>            End
13790>>>>>>
13790>>>>>            
13790>>>>>            // pass if Find (True) or save (False). We only care about commit on saves
13790>>>>>            // The setting of bIsForeign is an approximation. Foreign is really a DEO and and not
13790>>>>>            // a DD concept - in fact, at this point we don't really know. For example, a save in a header/dtl
13790>>>>>            // detail DEO (ordrdtl grid)has header DEOs that are not really foreign. This test errs on the side
13790>>>>>            // of assuming it's foreign. This would cause problems with incorrect parent NoPuts except we also
13790>>>>>            // set a flag, Field_NoPutValueChangedByDeo, when a field is changed via a NoPut DEO. The DD will still update
13790>>>>>            // foreign NoPuts unless this field flag is set.
13790>>>>>            Move (OPERATION_ORIGIN<>Self and Allow_Foreign_New_Save_State(Self)=0) to bIsForeign
13791>>>>>            Send Entry_Update of hoBuff bIsFind (If(bCommit,1,0) + If(bIsForeign,2,0))
13792>>>>>            
13792>>>>>            // also move data from extended dd fields to buffer
13792>>>>>            Send ExtendedFieldsUpdate (not(bIsFind))
13793>>>>>        End
13793>>>>>>
13793>>>>>        Set Visited_State to True
13794>>>>>        
13794>>>>>    End_Procedure
13795>>>>>    
13795>>>>>    // is this field NoPut based passed Commit and Foreign flags.
13795>>>>>    Function FieldNoPut Integer iField Boolean bIsCommited Boolean bIsForeign Returns Boolean
13797>>>>>        Boolean bNoPut
13797>>>>>        // this uses runtime logic - the same use for moving DD Buffer to Field Buffer
13797>>>>>        Get IsFieldDDNoPut of Record_Buffer iField (If(bIsCommited,1,0) + If(bIsForeign,2,0)) to bNoPut
13798>>>>>        Function_Return bNoPut
13799>>>>>    End_Function
13800>>>>>    
13800>>>>>    
13800>>>>>    // Check that Server data-sets exist for all required server file numbers
13800>>>>>    Function Valid_Servers Returns Integer
13802>>>>>        Integer iRval
13802>>>>>        Integer iCount
13802>>>>>        Integer iMax
13802>>>>>        Integer iDSO
13802>>>>>        Integer iPos
13802>>>>>        Integer iFile
13802>>>>>        String  sFiles
13802>>>>>        
13802>>>>>        // First assemble a string of all server file#s in ','##',' format
13802>>>>>        Move ',' to sFiles
13803>>>>>        Get Data_Set_Server_Count to iMax
13804>>>>>        Decrement iMax
13805>>>>>        For iCount from 0 to iMax
13811>>>>>>
13811>>>>>            Get Data_Set_Server iCount to iDSO
13812>>>>>            Move ( sFiles + String(Main_file(iDSO)) + ",") to sFiles
13813>>>>>        Loop
13814>>>>>>
13814>>>>>        
13814>>>>>        // Make sure each required File exists
13814>>>>>        Get Server_File_Count to iMax
13815>>>>>        Decrement iMax
13816>>>>>        For iCount from 0 to iMax
13822>>>>>>
13822>>>>>            Get Server_File iCount to iFile
13823>>>>>            Move (Pos ( ','+String(iFile)+',' , sFiles)) to iPos
13824>>>>>            If (iPos = 0) ;                Move iFile to iRVal
13827>>>>>        Until iRval
13829>>>>>        Function_Return iRVal
13830>>>>>    End_Function
13831>>>>>    
13831>>>>>    
13831>>>>>    // Check that Client data-sets exist for all required Client file numbers
13831>>>>>    Function Valid_Clients Returns Integer
13833>>>>>        Integer iRval
13833>>>>>        Integer iCount
13833>>>>>        Integer iMax
13833>>>>>        Integer iDSO
13833>>>>>        Integer iPos
13833>>>>>        Integer iFile
13833>>>>>        String  sFiles
13833>>>>>        
13833>>>>>        // First assemble a string of all Client file#s in ','##',' format
13833>>>>>        Move ',' to sFiles
13834>>>>>        Get Data_Set_Client_Count to iMax
13835>>>>>        Decrement iMax
13836>>>>>        For iCount from 0 to iMax
13842>>>>>>
13842>>>>>            Get Data_Set_Client iCount to iDSO
13843>>>>>            Move ( sFiles + String(Main_file(iDSO))+",") to sFiles
13844>>>>>        Loop
13845>>>>>>
13845>>>>>        
13845>>>>>        // Make sure each required File exists
13845>>>>>        Get Client_File_Count to iMax
13846>>>>>        Decrement iMax
13847>>>>>        For iCount from 0 to iMax
13853>>>>>>
13853>>>>>            Get Client_File iCount to iFile
13854>>>>>            Move (Pos( ','+String(iFile)+',', sFiles)) to iPos
13855>>>>>            If (iPos = 0) ;                Move iFile to iRVal
13858>>>>>        Until iRval
13860>>>>>        Function_Return iRVal
13861>>>>>    End_Function
13862>>>>>    
13862>>>>>    
13862>>>>>    // Validates save updating connections. If error returns file# that is
13862>>>>>    // expected and missing. If no error Set Validated_Save_connectio_State
13862>>>>>    // indicating that the connection validation has occurred and is ok
13862>>>>>    Function Validate_Save_Structure Integer ForceFg Returns Integer
13864>>>>>        Integer iRval
13864>>>>>        Integer iMode
13864>>>>>        If not ForceFg Begin
13866>>>>>            Get Validate_Save_Structure_Mode to iMode
13867>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and ;                Save_Structure_Validated_state(Self)=0 ) ) ;                to ForceFg
13868>>>>>        End
13868>>>>>>
13868>>>>>        If ForceFg Begin
13870>>>>>            Get Valid_Structure False to iRval
13871>>>>>            If (iRVal = 0) ;                Set Save_Structure_Validated_State to True
13874>>>>>        End
13874>>>>>>
13874>>>>>        Function_Return iRVal
13875>>>>>    End_Function
13876>>>>>    
13876>>>>>    // Validates Delete Structure. If cascade_state is true this must check
13876>>>>>    // up and down the tree. If no cascade_state just check up the tree.  If
13876>>>>>    // Ok, set Validated_Delete_no_Cascade_Connection_State and and or
13876>>>>>    // Validated_Delete_Cascade_Connection_State
13876>>>>>    // Pass: ForceFg - if TRUE force the validation.
13876>>>>>    Function Validate_Delete_Structure Integer ForceFg Returns Integer
13878>>>>>        Integer iCascade
13878>>>>>        Integer iMode
13878>>>>>        Integer iSt
13878>>>>>        Integer iRval
13878>>>>>        Get Cascade_delete_State to iCascade
13879>>>>>        If not ForceFg Begin
13881>>>>>            Get Validate_Delete_Structure_Mode to iMode
13882>>>>>            If (iMode=DD_VALIDATE_STRUCTURE_ONCE and iCascade );                Get Cascade_Delete_Structure_Validated_state to iSt
13885>>>>>            Else ;                Get No_Cascade_Delete_Structure_Validated_state to iSt
13887>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and iSt=0) ) to ForceFg
13888>>>>>        End
13888>>>>>>
13888>>>>>        
13888>>>>>        If ForceFg Begin
13890>>>>>            Get Valid_Structure iCascade to iRval
13891>>>>>            If (iRval = 0) Begin
13893>>>>>                Set No_Cascade_Delete_Structure_Validated_State to True
13894>>>>>                If iCascade ;                    Set Cascade_Delete_Structure_Validated_State to True
13897>>>>>            End
13897>>>>>>
13897>>>>>        End
13897>>>>>>
13897>>>>>        Function_Return iRval
13898>>>>>    End_Function
13899>>>>>    
13899>>>>>    
13899>>>>>    // This procedure will be called whenever the Data_Set wants its DEOs to
13899>>>>>    // write their values to the record buffer. The value of OPERATION_MODE
13899>>>>>    // determines if this is for finding an record or before saving a record.
13899>>>>>    // We use this event to tell our Record_Buffer to update the
13899>>>>>    // global record buffer.
13899>>>>>    // Modified to visit all server DSOs
13899>>>>>    // Note that this is only sent to the DSO starting the operation.
13899>>>>>    // We must manually send this to all server data-sets ourselves
13899>>>>>    // Note that during a DSO save this will get passed iFile=0 and iAll=3
13899>>>>>    // Changed to Support EntryUpdateLocalState (private)
13899>>>>>    // as of 17.0, EntryUpdateLocalState is True which means that entry_updates
13899>>>>>    // for finds now through the DD Buffer (saves always did).
13899>>>>>    Procedure Request_Entry_Update Integer iFile Integer iAll
13901>>>>>        If ((Operation_Mode=MODE_SAVING and iAll=3) or (EntryUpdateLocalState(Self)) ) Begin //3=dso save
13903>>>>>            If (OPERATION_MODE=MODE_WAITING) Begin
13905>>>>>                // we will only not be in an operation if we are doing a find with EntryUpdateLocalState
13905>>>>>                // set to true. In such a case make this a finding. I am not this is actually needed
13905>>>>>                Send Update_Focus_Field_For_Operation MODE_FINDING
13906>>>>>            End
13906>>>>>>
13906>>>>>            Else Begin
13907>>>>>                // if here we already have an operation_mode so there is no need to do anything special
13907>>>>>                Send Update_Focus_Field // Make sure buffer has latest focus item changes
13908>>>>>            End
13908>>>>>>
13908>>>>>            Send Initialize_Visited False False // Clear up, do not clear fields
13909>>>>>            Send Entry_Update_Data_Sets iFile iAll
13910>>>>>        End
13910>>>>>>
13910>>>>>        Forward Send Request_Entry_Update iFile iAll
13912>>>>>    End_Procedure
13913>>>>>    
13913>>>>>    
13913>>>>>    
13913>>>>>    // Forces the focus field to get update its value with the data-set.
13913>>>>>    // This insures that the DSO and DEO contain the same values.
13913>>>>>    Procedure Update_Focus_Field
13915>>>>>        Integer iFocObj
13915>>>>>        Get Focus of desktop to iFocObj
13916>>>>>        If (Extended_DEO_State(iFocObj)) ;            Send Update_Focus_Field to iFocObj
13919>>>>>    End_Procedure
13920>>>>>    
13920>>>>>    // very internal. Used to set Operation_mode and Operation_origin before the
13920>>>>>    // update. A developer can use this in the DEO to know what state the update is in.
13920>>>>>    // This was created because a DEO value change will trigger an OnChange event and you
13920>>>>>    // can look at this and know that this is part of a DD operation.
13920>>>>>    // This is *only* called by the DD operations in this class and the change is made for as
13920>>>>>    // small of a period as possible.
13920>>>>>    Procedure Update_Focus_Field_For_Operation Integer iOperationMode
13922>>>>>        Integer iOldMode iOldOrigin
13922>>>>>        
13922>>>>>        Move OPERATION_MODE to iOldMode
13923>>>>>        Move OPERATION_ORIGIN to iOldOrigin
13924>>>>>        Move iOperationMode to OPERATION_MODE
13925>>>>>        Move Self to OPERATION_ORIGIN
13926>>>>>        Send Update_Focus_Field
13927>>>>>        Move iOldMode to OPERATION_MODE
13928>>>>>        Move iOldOrigin to OPERATION_ORIGIN
13929>>>>>    End_Procedure
13930>>>>>    
13930>>>>>    
13930>>>>>    // Augment to validate all field values that do not get
13930>>>>>    // validated as part of the item validation process. The advantage
13930>>>>>    // of item validation (over only field validation) is that an error
13930>>>>>    // returns you to the offending item.
13930>>>>>    Function Request_Validate Returns Integer
13932>>>>>        Integer iRetval iOldOrigin iOldMode iRetVal2
13932>>>>>        Handle[] DDsWithFindReqErrors
13933>>>>>        
13933>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13935>>>>>            Send Update_Focus_Field_For_Operation MODE_VALIDATING // added 12.1/15.1
13936>>>>>        End
13936>>>>>>
13936>>>>>        Move Operation_Origin to iOldOrigin
13937>>>>>        Move Self to Operation_Origin
13938>>>>>        Move Operation_Mode to iOldMode
13939>>>>>        // clear all find req DD markers at the origin of the validate request. When request validates occur
13939>>>>>        // they will get added to this array and can be tested to see of such an error has occurred.
13939>>>>>        Set pDDsWithFindReqErrors to DDsWithFindReqErrors
13940>>>>>        // Prior to VDF7, we set this to Mode_Saving. We now have a special mode just for request_validate.
13940>>>>>        // We do this because:
13940>>>>>        //   1) because it is useful (more detail never hurts) and
13940>>>>>        //   2) we will allow set_field_current_value to update when mode_validation is set
13940>>>>>        Move MODE_VALIDATING to Operation_Mode
13941>>>>>        Send Initialize_Visited False True //false=up only, true=clear fields
13942>>>>>        Forward Get Request_Validate to iRetval // normal deo validate
13944>>>>>        // If DEO validation failed, do not validate other fields unless Validate_All_Fields is set
13944>>>>>        If ( (iRetval=0 or (Validate_All_Fields_State(Self))) and Validate_DEOs_Only_State(Self)=0) Begin
13946>>>>>            Get Validate_Data_Sets False (Validate_All_Fields_State(Self)) to iRetval2
13947>>>>>            Move (iRetval or iRetVal2) to iRetval
13948>>>>>        End
13948>>>>>>
13948>>>>>        
13948>>>>>        If (iRetval=0) Begin
13950>>>>>            Get ValidateSwitchedCommittedParents True to iRetval
13951>>>>>        End
13951>>>>>>
13951>>>>>        
13951>>>>>        Move iOldMode   to Operation_Mode
13952>>>>>        Move iOldOrigin to Operation_Origin
13953>>>>>        Function_Return iRetval
13954>>>>>    End_Function
13955>>>>>    
13955>>>>>    Function Request_Validate_All Returns Integer
13957>>>>>        Integer bOld iRetVal
13957>>>>>        Get Validate_All_Fields_State to bOld
13958>>>>>        Set Validate_All_Fields_State to True
13959>>>>>        Get request_validate to iretVal
13960>>>>>        Set Validate_All_Fields_State to bOld
13961>>>>>        Function_Return iRetval
13962>>>>>    End_Function
13963>>>>>    
13963>>>>>    
13963>>>>>    
13963>>>>>    // Like Item_find except entry-update is forced through the DD, not DEO
13963>>>>>    Procedure File_Field_Find Integer iFindMode Integer iFile Integer iField ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
13965>>>>>        Integer bOld
13965>>>>>        Get EntryUpdateLocalState to bOld
13966>>>>>        Set EntryUpdateLocalState to True
13967>>>>>        Send Item_Find iFindMode iFile iField bEntUpdt bShowErr bDfrd
13968>>>>>        Set EntryUpdateLocalState to bOld
13969>>>>>    End_Procedure
13970>>>>>    
13970>>>>>    // Autofind for requestd file, field and mode.
13970>>>>>    //    If mode not passed, EQ is assummed
13970>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iFindMode
13972>>>>>        Integer eMode
13972>>>>>        If iFile  Begin
13974>>>>>            // if no 3rd argument, default to autofind
13974>>>>>            Move (If(Num_Arguments<3,EQ,iFindMode)) to eMode
13975>>>>>            Send File_Field_Find eMode iFile iField True False False
13976>>>>>        End
13976>>>>>>
13976>>>>>    End_Procedure
13977>>>>>    
13977>>>>>    // Autofind in default mode (does not set changed states). Can be used
13977>>>>>    // within Clear and Clear_all to autofind parents. Parent values can be
13977>>>>>    // maintained using retainAll option
13977>>>>>    Procedure File_Field_Default_AutoFind Integer iFile Integer iField
13979>>>>>        Integer iOldState
13979>>>>>        Handle  hoDD
13979>>>>>        Get Data_set iFile to hoDD
13980>>>>>        If hoDD Begin
13982>>>>>            Get Change_disabled_State of hoDD to iOldState
13983>>>>>            Set Change_disabled_State of hoDD to True
13984>>>>>            Send File_Field_AutoFind  of hoDD iFile iField EQ
13985>>>>>            Set Change_disabled_State of hoDD to iOldState
13986>>>>>            Set changed_state to False
13987>>>>>        End
13987>>>>>>
13987>>>>>    End_Procedure
13988>>>>>    
13988>>>>>    // File_Index_find
13988>>>>>    // Like item_find except you pass the index you want to find with and
13988>>>>>    // ent-update occurs through DDO buffers not deo buffers.
13988>>>>>    // This is currently private and is only used by web-applications
13988>>>>>    Procedure File_Index_Find Integer iFindMode Integer iFile Integer iIndex ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
13990>>>>>        Integer bOld
13990>>>>>        RowID riRec
13990>>>>>        Integer wasChanged hDD iOldStat
13990>>>>>        Boolean bOk
13990>>>>>        
13990>>>>>        Get Data_Set iFile to hDD
13991>>>>>        If (hDD=0) Begin
13993>>>>>            Error DFERR_PROGRAM C_$CannotFindDD
13994>>>>>>
13994>>>>>            Procedure_Return
13995>>>>>        End
13995>>>>>>
13995>>>>>        
13995>>>>>        Get EntryUpdateLocalState to bOld
13996>>>>>        Set EntryUpdateLocalState to True
13997>>>>>        
13997>>>>>        //  'hold' buffer to prepare for entry_update
13997>>>>>        Move (getRowId(iFile)) to riRec
13998>>>>>        Get_Attribute DF_FILE_STATUS of iFile to iOldStat
14001>>>>>        Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
14004>>>>>        
14004>>>>>        If bEntUpdt Begin
14006>>>>>            Send Request_Entry_Update to hDD iFile 1  //entUpdt all DEOs as required
14007>>>>>            
14007>>>>>            //
14007>>>>>            // we really only need to know if any segment of the index changed
14007>>>>>            // but since we don't have field-changed flags, we look at the
14007>>>>>            // whole recbuf - this is consistent with 2.3b and 3.0 non-dataset
14007>>>>>            // behavior.
14007>>>>>            //
14007>>>>>            Move (iOldStat<>DF_FILE_INACTIVE) to wasChanged
14008>>>>>            If not wasChanged ;                Get_Attribute DF_FILE_CHANGED of iFile to wasChanged
14013>>>>>            If not wasChanged ;                Constrained_Clear iFindMode iFile by iIndex
14018>>>>>            
14018>>>>>        End
14018>>>>>>
14018>>>>>        Move False to Err
14019>>>>>        If bDfrd ;            Send Request_Read iFindMode iFile iIndex
14022>>>>>        Else ;            Send Request_Find iFindMode iFile iIndex
14024>>>>>        If (not(Found) and  not(err)) Begin
14026>>>>>            // refind original record (or leave it cleared if not record)
14026>>>>>            Move (FindByRowId(iFile,riRec)) to bOk
14027>>>>>            
14027>>>>>            If bShowErr ;                Error (If(iFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
14030>>>>>            Move False to Err
14031>>>>>        End
14031>>>>>>
14031>>>>>        Set EntryUpdateLocalState to bOld
14032>>>>>    End_Procedure
14033>>>>>    
14033>>>>>    // This does a refind of all records based on the contents of the
14033>>>>>    // refine_record_id property.
14033>>>>>    // This would be used after clearing the DDs and loading the local rencum
14033>>>>>    // buffer with recnums. This can be used by remote DEOs (BPOs).
14033>>>>>    //
14033>>>>>    // Find all existing records. This must be done in bottom-up, breadth
14033>>>>>    // first order. i.e., Start with the passed DD, find it and then find for
14033>>>>>    // parents. Only find if the record is non-zero and it is different than
14033>>>>>    // the current_record.
14033>>>>>    // This order will allow us to support changed parents.
14033>>>>>    // Don't use this if you do not understand what it does.
14033>>>>>    // Private.Find_Records is a helper. We will keep this private because
14033>>>>>    // it is rather specialized and only used by WebApp.
14033>>>>>    Procedure Find_Records
14035>>>>>        Send Initialize_Visited False False // Clear up, do not clear fields
14036>>>>>        Send Private.Find_Records           // refind all records in upward sweep
14037>>>>>    End_Procedure
14038>>>>>    
14038>>>>>    
14038>>>>>    Procedure Private.Find_Records
14040>>>>>        Integer hPrnt
14040>>>>>        Integer iMax
14040>>>>>        Integer iCount
14040>>>>>        RowID riRec
14040>>>>>        Integer iRec iMain
14040>>>>>        // works with both recId and rowId. Only one should ever be set.
14040>>>>>        // find(clear) record, if needed
14040>>>>>        Get Main_File to iMain
14041>>>>>        // assume that either prFindRowId or Find_record_id has a value - never both
14041>>>>>        // also assume Find_record_id only has values when you are using a recnum table
14041>>>>>        Get prFindRowId to riRec
14042>>>>>        If not (IsNullRowId(riRec)) Begin
14044>>>>>            If not (IsSameRowId(riRec, CurrentRowId(Self) ) ) Begin
14046>>>>>                Send FindByRowId iMain riRec // find an Relate all parents
14047>>>>>            End
14047>>>>>>
14047>>>>>            Set prFindRowId to (NullRowId())  // reset refind rec back to zero.
14048>>>>>        End
14048>>>>>>
14048>>>>>        Else Begin
14049>>>>>            // if this has a recnum, it better be a recnum table or an error will occur.
14049>>>>>            // This is not being tested for a recnum table on purpose. If someone is setting Find_record_id
14049>>>>>            // on a non-recnum table, they doing something wrong. An Error will be a good thing.
14049>>>>>            Get Find_Record_Id to iRec
14050>>>>>            If iRec Begin
14052>>>>>                If (iRec<>Current_record(Self)) Begin
14054>>>>>                    Send Find_By_Recnum iMain iRec // find an Relate all parents
14055>>>>>                End
14055>>>>>>
14055>>>>>                Set Find_record_id to 0 // reset refind rec back to zero.
14056>>>>>            End
14056>>>>>>
14056>>>>>        End
14056>>>>>>
14056>>>>>        Set Visited_State to True
14057>>>>>        
14057>>>>>        // recurse and do the same to all parent files
14057>>>>>        // in almost all cases, there will be no new finding here since the relate has
14057>>>>>        // found the records. If the record is different than the relate, we have
14057>>>>>        // a switched parent state (should_save will be set appropriately).
14057>>>>>        Get Data_Set_Server_Count to iMax
14058>>>>>        Decrement iMax
14059>>>>>        For iCount from 0 to iMax
14065>>>>>>
14065>>>>>            Get Data_Set_Server iCount to hPrnt
14066>>>>>            If not (Visited_state(hPrnt)) ;                Send Private.Find_Records to hPrnt
14069>>>>>        Loop
14070>>>>>>
14070>>>>>    End_Procedure
14071>>>>>    
14071>>>>>    // This Mark_Id creates a sequence Id for this clear. This way
14071>>>>>    // DDOs only get cleared one time during this process.
14071>>>>>    Procedure IncrementCurrentMarkId
14073>>>>>        If (DD_Current_Mark_ID>65536) Begin
14075>>>>>            Move 0 to DD_Current_Mark_id
14076>>>>>        End
14076>>>>>>
14076>>>>>        Increment DD_Current_Mark_id
14077>>>>>    End_Procedure
14078>>>>>    
14078>>>>>    
14078>>>>>    // private use by new webapp framework as of 18.2.
14078>>>>>    // pass bStart as True if this is the start of the resynch.
14078>>>>>    Function ReSyncRecords Boolean bStart Returns Handle
14080>>>>>        RowID riRowId riCrnt
14080>>>>>        Boolean bOk bOldReSync bVisited
14080>>>>>        Handle hoOtherDDO hoBadDDO hoBadPrntDDO
14080>>>>>        Integer iMax iCount iMain
14080>>>>>
14080>>>>>        If bStart Begin
14082>>>>>            Send InitializeAllVisited
14083>>>>>        End
14083>>>>>>
14083>>>>>        
14083>>>>>        // we want depth first traversal. Make sure children are handled before parents
14083>>>>>        // Recursively traverse Children, Find by RowId, Recursively traverse Parents
14083>>>>>        // Use visited_state logic to avoid multiple visits caused by diamond DDO strutures
14083>>>>>        
14083>>>>>        //mark first so we don't visit this coming back up.
14083>>>>>        Set Visited_State to True
14084>>>>>        
14084>>>>>        // traverse downward first
14084>>>>>        Get Data_Set_Client_Count to iMax
14085>>>>>        For iCount from 0 to (iMax-1)
14091>>>>>>
14091>>>>>            Get Data_Set_Client iCount to hoOtherDDO
14092>>>>>            Get Visited_State of hoOtherDDO to bVisited
14093>>>>>            If not bVisited Begin
14095>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
14096>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
14098>>>>>                    Move hoBadPrntDDO to hoBadDDO
14099>>>>>                End
14099>>>>>>
14099>>>>>            End
14099>>>>>>
14099>>>>>        Loop
14100>>>>>>
14100>>>>>        
14100>>>>>        // Find record for DD. It might already be correct if child has already
14100>>>>>        // related it in. If not correct after a relate, this has been switched by this
14100>>>>>        // user or switched by another user, in which case it will be swtitched back
14100>>>>>        // (DDOs have always worked this way).
14100>>>>>        Get prFindRowId to riRowId
14101>>>>>        Get Main_File to iMain
14102>>>>>        Get CurrentRowId to riCrnt
14103>>>>>        If ( not(IsSameRowId(riRowID, riCrnt)) ) Begin
14105>>>>>            Get pbInReSync to bOldReSync
14106>>>>>            Set pbInReSync to True
14107>>>>>            
14107>>>>>            If (IsNullRowId(riRowID)) Begin
14109>>>>>                Send Clear
14110>>>>>            End
14110>>>>>>
14110>>>>>            Else Begin
14111>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
14112>>>>>                If not bOk Begin
14114>>>>>                    Move Self to hoBadDDO
14115>>>>>                End
14115>>>>>>
14115>>>>>            End
14115>>>>>>
14115>>>>>            Set pbInReSync to bOldReSync
14116>>>>>        End
14116>>>>>>
14116>>>>>        
14116>>>>>        // finally traverse to parents
14116>>>>>        Get Data_Set_Server_Count to iMax
14117>>>>>        For iCount from 0 to (iMax-1)
14123>>>>>>
14123>>>>>            Get Data_Set_Server iCount to hoOtherDDO
14124>>>>>            Get Visited_State of hoOtherDDO to bVisited
14125>>>>>            If not bVisited Begin
14127>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
14128>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
14130>>>>>                    Move hoBadPrntDDO to hoBadDDO
14131>>>>>                End
14131>>>>>>
14131>>>>>            End
14131>>>>>>
14131>>>>>        Loop
14132>>>>>>
14132>>>>>        
14132>>>>>        If bStart Begin
14134>>>>>            Send InitializeAllVisited
14135>>>>>            Send ResetChangedStates
14136>>>>>        End
14136>>>>>>
14136>>>>>        
14136>>>>>        Function_Return hoBadDDO
14137>>>>>    End_Function
14138>>>>>    
14138>>>>>
14138>>>>>    Procedure ResetChangedStates
14140>>>>>        Boolean bVisited
14140>>>>>        Handle hoOtherDDO
14140>>>>>        Integer iMax iCount
14140>>>>>        tDDChangedInfo DDChangedInfo
14140>>>>>        tDDChangedInfo DDChangedInfo
14140>>>>>                
14140>>>>>        // we want depth first traversal.
14140>>>>>        //mark first so we don't visit this coming back up.
14140>>>>>        Set Visited_State to True
14141>>>>>        
14141>>>>>        // traverse downward first
14141>>>>>        Get Data_Set_Client_Count to iMax
14142>>>>>        For iCount from 0 to (iMax-1)
14148>>>>>>
14148>>>>>            Get Data_Set_Client iCount to hoOtherDDO
14149>>>>>            Get Visited_State of hoOtherDDO to bVisited
14150>>>>>            If not bVisited Begin
14152>>>>>                Send ResetChangedStates of hoOtherDDO
14153>>>>>            End
14153>>>>>>
14153>>>>>        Loop
14154>>>>>>
14154>>>>>        
14154>>>>>        // Set changed states for this DDO
14154>>>>>        Get pDDChangedInfo to DDChangedInfo
14155>>>>>        Set Changed_State to False // clears changed_state and parent_changed_states            
14156>>>>>        Set Changed_State to DDChangedInfo.bChanged            
14157>>>>>        For iCount from 0 to (SizeOfArray(DDChangedInfo.ParentChanged)-1)
14163>>>>>>
14163>>>>>            Send SetParentDDOSwitched DDChangedInfo.ParentChanged[iCount].iTable DDChangedInfo.ParentChanged[iCount].bSwitched
14164>>>>>        Loop
14165>>>>>>
14165>>>>>        
14165>>>>>        // finally traverse to parents
14165>>>>>        Get Data_Set_Server_Count to iMax
14166>>>>>        For iCount from 0 to (iMax-1)
14172>>>>>>
14172>>>>>            Get Data_Set_Server iCount to hoOtherDDO
14173>>>>>            Get Visited_State of hoOtherDDO to bVisited
14174>>>>>            If not bVisited Begin
14176>>>>>                Send ResetChangedStates of hoOtherDDO
14177>>>>>            End
14177>>>>>>
14177>>>>>        Loop
14178>>>>>>
14178>>>>>        
14178>>>>>    End_Procedure
14179>>>>>
14179>>>>>    // private use by new webapp framework (pre 18.2)
14179>>>>>    Function ReSyncRecord Returns Boolean
14181>>>>>        RowID riRowId
14181>>>>>        Boolean bOk bOldReSync
14181>>>>>        Handle hPrnt
14181>>>>>        Integer iMax iCount iMain
14181>>>>>        
14181>>>>>        Get pbInReSync to bOldReSync
14182>>>>>        
14182>>>>>        Get prFindRowId to riRowId
14183>>>>>        Get Main_File to iMain
14184>>>>>        If not (IsSameRowId(riRowID, CurrentRowId(Self) ) ) Begin
14186>>>>>            If (IsNullRowId(riRowID)) Begin
14188>>>>>                Set pbInReSync to True
14189>>>>>                Send Clear
14190>>>>>                Set pbInReSync to bOldReSync
14191>>>>>            End
14191>>>>>>
14191>>>>>            Else Begin
14192>>>>>                Set pbInReSync to True
14193>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
14194>>>>>                Set pbInReSync to bOldReSync
14195>>>>>                If not bOk Begin
14197>>>>>                    Function_Return False
14198>>>>>                End
14198>>>>>>
14198>>>>>            End
14198>>>>>>
14198>>>>>            
14198>>>>>            // check that the relate found all the parent records we expect.
14198>>>>>            // This should be correct unless a parent has been switched. Constrained
14198>>>>>            // parents, by definition, should already be correct. See **Note** below
14198>>>>>            Get Data_Set_Server_Count to iMax
14199>>>>>            For iCount from 0 to (iMax-1)
14205>>>>>>
14205>>>>>                Get Data_Set_Server iCount to hPrnt
14206>>>>>                If (Constrain_File(Self)<>Main_File(hPrnt) and ;                    not (IsSameRowID(prFindRowId(hPrnt),CurrentRowId(hPrnt)))) Begin
14208>>>>>                    // the parent is either wrong or not processed yet. Either way
14208>>>>>                    // make it right.
14208>>>>>                    Get ReSyncRecord of hPrnt to bOk
14209>>>>>                    If not bOk Begin
14211>>>>>                        Function_Return False
14212>>>>>                    End
14212>>>>>>
14212>>>>>                End
14212>>>>>>
14212>>>>>            Loop
14213>>>>>>
14213>>>>>        End
14213>>>>>>
14213>>>>>        
14213>>>>>        Function_Return True
14214>>>>>    End_Function
14215>>>>>    
14215>>>>>    // **Note** - dealing with changed parents and diamonds during a resync.
14215>>>>>    // If there is not a relates-to contraint between DD and child it is possible
14215>>>>>    // that the child find's relate will change the just found parent DD.
14215>>>>>    // Assuming this is not a structure bug, it means the parent is changed parent and that
14215>>>>>    // change must occur after the child record has been found and related. Therefore we add
14215>>>>>    // check after each child find to see if an parent is incorrect. If it is, either it is a
14215>>>>>    // switched parent or we haven't processed it yet. If the record is fine it
14215>>>>>    // just does nothing. For example (where *=relates-to):
14215>>>>>    //     W
14215>>>>>    //   */  \*
14215>>>>>    //   X    Y
14215>>>>>    //    \  /*
14215>>>>>    //     Z
14215>>>>>    // Assume you found a Z and changed its parent X.
14215>>>>>    // The refind order can be: WXZY or WYZX
14215>>>>>    // If WXZY the refound parent will be lost because Z will relate after the X
14215>>>>>    // find and replace it with the original parent. To control this we add this check
14215>>>>>    // after child Z has done its work. We only need to do this when child DDOs exist
14215>>>>>    // that are not constrained. This can change the order that DDOs are resynced but it
14215>>>>>    // should not matter.
14215>>>>>    
14215>>>>>    
14215>>>>>    
14215>>>>>    // Private use by new webapp framework
14215>>>>>    Procedure ReSyncClearAll
14217>>>>>        Boolean bOldReSync
14217>>>>>        Get pbInReSync to bOldReSync
14218>>>>>        // we need this to stop RememberLast and retains. We don't want those during a resyc clear
14218>>>>>        Set pbInReSync to True
14219>>>>>        Send Clear_All
14220>>>>>        Set pbInReSync to bOldReSync
14221>>>>>    End_Procedure
14222>>>>>    
14222>>>>>    // returns table name for error display. By default it returns the logical name
14222>>>>>    // can be augmented to return other information
14222>>>>>    Function ErrorMessageTableName Integer iTable Returns String
14224>>>>>        String sTable
14224>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTable
14227>>>>>        Function_Return sTable
14228>>>>>    End_Function
14229>>>>>    
14229>>>>>    
14229>>>>>    // Augmented to test updating connections.
14229>>>>>    // If error report it.
14229>>>>>    Procedure Request_Save
14231>>>>>        Integer iRval
14231>>>>>        String sTable
14231>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14233>>>>>            Send Update_Focus_Field_For_Operation MODE_SAVING // added in 12.1/15.1
14234>>>>>            Get Validate_Save_Structure False to iRval
14235>>>>>            If iRval Begin
14237>>>>>                Get ErrorMessageTableName iRval to sTable
14238>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
14239>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_INVALID_SAVE_STRUCTURE sTable
14240>>>>>                Procedure_Return
14241>>>>>            End
14241>>>>>>
14241>>>>>        End
14241>>>>>>
14241>>>>>        Forward Send Request_Save
14243>>>>>    End_Procedure
14244>>>>>    
14244>>>>>    // Augmented to test updating connections.
14244>>>>>    // If error report it.
14244>>>>>    Procedure Request_Delete
14246>>>>>        Integer iRval
14246>>>>>        String sTable
14246>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14248>>>>>            Send Update_Focus_Field_For_Operation MODE_DELETING // added to 12.1/15.1
14249>>>>>            Get Validate_Delete_Structure False to iRval
14250>>>>>            If iRval Begin
14252>>>>>                Get ErrorMessageTableName iRval to sTable
14253>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
14254>>>>>                Send data_Set_Error -1 DFERR_PROGRAM DD_INVALID_DELETE_STRUCTURE sTable
14255>>>>>                Procedure_Return
14256>>>>>            End
14256>>>>>>
14256>>>>>        End
14256>>>>>>
14256>>>>>        Forward Send Request_Delete
14258>>>>>    End_Procedure
14259>>>>>    
14259>>>>>    // Set status-line help for the passed field. This could have been named
14259>>>>>    // Set Field_Status_Help but this keeps this message interface consistent
14259>>>>>    // with the rest of DF for windows.
14259>>>>>    Procedure Set Status_Help Integer iField String sVal
14261>>>>>        Set Value of (StatusHelp_Array(Self)) iField to sVal
14262>>>>>    End_Procedure
14263>>>>>    
14263>>>>>    // Get status-line help for the passed field. This could have been named
14263>>>>>    // Get Field_Status_Help but this keeps this message interface consistent
14263>>>>>    // with the rest of DF for windows.
14263>>>>>    Function Status_Help Integer iField Returns String
14265>>>>>        String sHelp
14265>>>>>        Integer iObj
14265>>>>>        Move (StatusHelp_Array(Self)) to iObj
14266>>>>>        If (Item_Count(iObj)>iField) Begin
14268>>>>>            Get value of iObj iField to sHelp
14269>>>>>            If (sHelp = '0') ;                Move '' to shelp
14272>>>>>        End
14272>>>>>>
14272>>>>>        Function_Return shelp
14273>>>>>    End_Function
14274>>>>>    
14274>>>>>    // Get status-line help for the passed file and field. This is called
14274>>>>>    // by DEOs (or any other object) that needs help for a particular file
14274>>>>>    // and field.
14274>>>>>    Function File_Field_Status_Help Integer iFile Integer iField Returns String
14276>>>>>        Integer iDSO
14276>>>>>        String sValue
14276>>>>>        Get Data_set iFile to iDSO
14277>>>>>        If iDSO ;            Get Status_Help of iDSO iField to sValue
14280>>>>>        Function_Return sValue
14281>>>>>    End_Function
14282>>>>>    
14282>>>>>    // Allows user to set a mask type. Legal value is any of the current mask
14282>>>>>    // window types. 0 Means undefined.
14282>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
14284>>>>>        Set Field_Mask_Type of (FieldMask_Array(Self)) iField to iType
14285>>>>>    End_Procedure
14286>>>>>    
14286>>>>>    Function Field_Mask_Type Integer iField Returns Integer
14288>>>>>        Function_Return (Field_Mask_Type(FieldMask_Array(Self),iField))
14289>>>>>    End_Function
14290>>>>>    
14290>>>>>    Function File_Field_Mask_Type Integer iFile Integer iField Returns Integer
14292>>>>>        Integer iDSO
14292>>>>>        Get Data_set iFile to iDSO
14293>>>>>        If iDSO ;            Function_Return (Field_Mask_Type(iDSO,iField))
14296>>>>>    End_Function
14297>>>>>    
14297>>>>>    // If TRUE the value returned by DEO will contain mask characters.
14297>>>>>    // Currently not supported.
14297>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
14299>>>>>        Set Field_Mask_Value_State of (FieldMask_Array(Self)) iField to iState
14300>>>>>    End_Procedure
14301>>>>>    
14301>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
14303>>>>>        Function_Return (Field_Mask_Value_State(FieldMask_Array(Self),iField))
14304>>>>>    End_Function
14305>>>>>    
14305>>>>>    Function File_Field_Mask_Value_State Integer iFile Integer iField Returns Integer
14307>>>>>        Integer iDSO
14307>>>>>        Get Data_set iFile to iDSO
14308>>>>>        If iDSO ;            Function_Return (Field_Mask_Value_State(iDSO,iField))
14311>>>>>    End_Function
14312>>>>>    
14312>>>>>    // Allows user to set a mask strinng. Legal value is any of the current
14312>>>>>    // masks. Note an empty string with a valid mask type implies that the
14312>>>>>    // system should figure it out by itself.
14312>>>>>    Procedure Set Field_Mask Integer iField String sMask
14314>>>>>        Set Field_Mask of (FieldMask_Array(Self)) iField to sMask
14315>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Mask_Changed iField sMask
14318>>>>>    End_Procedure
14319>>>>>    
14319>>>>>    Function Field_Mask Integer iField Returns String
14321>>>>>        Function_Return (Field_Mask(FieldMask_Array(Self),iField))
14322>>>>>    End_Function
14323>>>>>    
14323>>>>>    Function File_Field_Mask Integer iFile Integer iField Returns String
14325>>>>>        Integer iDSO
14325>>>>>        String sValue
14325>>>>>        Get Data_set iFile to iDSO
14326>>>>>        If iDSO ;            Get Field_Mask of iDSO iField to sValue
14329>>>>>        Function_Return sValue
14330>>>>>    End_Function
14331>>>>>    
14331>>>>>    // Short for field. This is normally used by grid headers.
14331>>>>>    Procedure Set Field_Label_Short Integer iField String sName
14333>>>>>        Set Field_Label_Short of (FieldMask_Array(Self)) iField to sName
14334>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 0 sName
14337>>>>>    End_Procedure
14338>>>>>    
14338>>>>>    Function Field_Label_Short Integer iField Returns String
14340>>>>>        Function_Return (Field_Label_Short(FieldMask_Array(Self),iField))
14341>>>>>    End_Function
14342>>>>>    
14342>>>>>    Function File_Field_Label_Short Integer iFile Integer iField Returns String
14344>>>>>        Integer iDSO
14344>>>>>        String sValue
14344>>>>>        Get Data_set iFile to iDSO
14345>>>>>        If iDSO ;            Get Field_Label_Short of iDSO iField to sValue
14348>>>>>        Function_Return sValue
14349>>>>>    End_Function
14350>>>>>    
14350>>>>>    // Full Name for field. This is normally used by form labels
14350>>>>>    Procedure Set Field_Label_Long Integer iField String sName
14352>>>>>        Set Field_Label_Long of (FieldMask_Array(Self)) iField to sName
14353>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 1 sName
14356>>>>>    End_Procedure
14357>>>>>    
14357>>>>>    Function Field_Label_Long Integer iField Returns String
14359>>>>>        Function_Return (Field_Label_Long(FieldMask_Array(Self),iField))
14360>>>>>    End_Function
14361>>>>>    
14361>>>>>    Function File_Field_Label_Long Integer iFile Integer iField Returns String
14363>>>>>        Integer iDSO
14363>>>>>        String sValue
14363>>>>>        Get Data_set iFile to iDSO
14364>>>>>        If iDSO ;            Get Field_Label_Long of iDSO iField to sValue
14367>>>>>        Function_Return sValue
14368>>>>>    End_Function
14369>>>>>    
14369>>>>>    // This is not really a DD attribute (it is in the API) but it is
14369>>>>>    // appropriate to be accessed from the DD
14369>>>>>    Function Field_Label_Tag Integer iField Returns String
14371>>>>>        String sName
14371>>>>>        Integer iFile
14371>>>>>        Get Main_File to iFile
14372>>>>>        If iFile ;            Get_Attribute DF_FIELD_NAME of iFile iField to sName
14377>>>>>        Function_Return sName
14378>>>>>    End_Function
14379>>>>>    
14379>>>>>    Function SmartCase String sName Returns String
14381>>>>>        Integer iPos iNewPos
14381>>>>>        String sRight
14381>>>>>        Move (Replaces("_",lowercase(sName)," ")) to sName
14382>>>>>        Move (Trim (Replaces(".",sName," "))) to sName
14383>>>>>        Move 1 to iPos
14384>>>>>        Repeat
14384>>>>>>
14384>>>>>            Move (mid(sName,255,iPos+1)) to sRight
14385>>>>>            Move (left(sName,iPos-1) + Uppercase(mid(sName,1,iPos)) + sRight) to sName
14386>>>>>            Move (Pos( " ", sRight)) to iNewPos
14387>>>>>            If (iNewPos = 0) ;                Break
14390>>>>>            Add (iNewPos+1) to iPos
14391>>>>>        Loop
14392>>>>>>
14392>>>>>        Function_Return sName
14393>>>>>    End_Function
14394>>>>>    
14394>>>>>    Enumeration_List
14394>>>>>        Define DD_LABEL_SHORT
14394>>>>>        Define DD_LABEL_LONG
14394>>>>>        Define DD_LABEL_TAG
14394>>>>>    End_Enumeration_List
14394>>>>>    
14394>>>>>    // Handy function to get the label for a field. Three "types" are
14394>>>>>    // supported:
14394>>>>>    // DD_LABEL_SHORT  use short, if none use long, if none use smart tag
14394>>>>>    // DD_LABEL_LONG   use long, if none use smart tag
14394>>>>>    // DD_LABEL_TAG    use smart tag
14394>>>>>    // If you want an explicit field name use oneof the other messages.
14394>>>>>    Function Field_Label Integer iField Integer iType Returns String
14396>>>>>        Integer iServer
14396>>>>>        String sValue
14396>>>>>        If (iType = DD_LABEL_SHORT) ;  // 0 = Short            Get Field_Label_Short iField to sValue
14399>>>>>        If (iType = DD_LABEL_LONG or (iType=DD_LABEL_SHORT and sValue='')) ;            Get Field_Label_Long iField to sValue
14402>>>>>        If (iType = DD_LABEL_TAG or sValue="") Begin
14404>>>>>            Get Field_Label_Tag iField to sValue
14405>>>>>            Get SmartCase sValue to sValue
14406>>>>>        End
14406>>>>>>
14406>>>>>        Function_Return sValue
14407>>>>>    End_Function
14408>>>>>    
14408>>>>>    Function File_Field_Label Integer iFile Integer iField Integer iType Returns String
14410>>>>>        Integer iDSO
14410>>>>>        String sValue
14410>>>>>        Get Data_set iFile to iDSO
14411>>>>>        If iDSO ;            Get Field_Label of iDSO iField iType to sValue
14414>>>>>        Function_Return sValue
14415>>>>>    End_Function
14416>>>>>    
14416>>>>>    // Normally this will not be used by a running program. However, it
14416>>>>>    // could be possible to create classes dynamically at runtime, in which
14416>>>>>    // case these messages could be useful. No File_Field is provided. If the
14416>>>>>    // person knows enough to create dynamic classes they can find the DD.
14416>>>>>    Procedure Set Field_Class_Name Integer iField String sName
14418>>>>>        Set Field_Class_Name of (FieldMask_Array(Self)) iField to sName
14419>>>>>    End_Procedure
14420>>>>>    
14420>>>>>    Function Field_Class_Name Integer iField Returns String
14422>>>>>        Function_Return (Field_Class_Name(FieldMask_Array(Self),iField))
14423>>>>>    End_Function
14424>>>>>    
14424>>>>>    // This procedure should be used to set a specific error number and
14424>>>>>    // message for a particular field. This can be used with the Field_error
14424>>>>>    // message to generate this error during a validation.
14424>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
14426>>>>>        Set Field_Error of (Field_Attributes(Self)) iField to iErr sMsg
14427>>>>>    End_Procedure
14428>>>>>    
14428>>>>>    // Used to retreive the error number and message for a particular field
14428>>>>>    Function Field_Error_Number Integer iField Returns Integer
14430>>>>>        Function_Return (Field_Error_Number(Field_Attributes(Self),iField))
14431>>>>>    End_Function
14432>>>>>    
14432>>>>>    Function Field_Error_Message Integer iField Returns String
14434>>>>>        Function_Return (Field_Error_Message(Field_Attributes(Self),iField))
14435>>>>>    End_Function
14436>>>>>    
14436>>>>>    // This procedure is used to declare an error on a standard field
14436>>>>>    // validation violation like Range or Check.
14436>>>>>    // Can pass 1 to 4 params:
14436>>>>>    // iField -                  Standard usage. Generates field as defined
14436>>>>>    //                           for this field. If field=-1, General error
14436>>>>>    // iField SDefault           If no field error mess (or field=-1) use
14436>>>>>    //                           the default message
14436>>>>>    // iField sDefault sParam1 {sParam2} Replace occurances of @PARAM1 and
14436>>>>>    //                           @PARAM2 in text with these values
14436>>>>>    Procedure Field_Error Integer iField String sDefault ;            String sParam1 String sParam2
14438>>>>>        Integer iErr
14438>>>>>        String  sMess
14438>>>>>        If (iField >= 0) Begin
14440>>>>>            Get Field_Error_Number  iField to iErr
14441>>>>>            Get Field_Error_Message iField to sMess
14442>>>>>        End
14442>>>>>>
14442>>>>>        If (sMess="" and Num_Arguments>1) ;            Move sDefault to sMess
14445>>>>>        If (Num_Arguments = 4) ;            Send Data_Set_Error iField iErr sMess sParam1 sParam2
14448>>>>>        Else If (Num_Arguments = 3) ;            Send Data_Set_Error iField iErr sMess sParam1
14452>>>>>        Else ;            Send Data_Set_Error iField iErr sMess
14454>>>>>    End_Procedure
14455>>>>>    
14455>>>>>    // Procedure Data_Set_Error
14455>>>>>    // This procedure is used to declare a data-set error. Pass error number
14455>>>>>    // and optional error message text.
14455>>>>>    // If iErr is 0, use the default error number.
14455>>>>>    // sParam1 and sParam2 are optional. If passed they are used as text
14455>>>>>    // replacements for @PARAM1 and @PARAM2.
14455>>>>>    // We pass iField (even though we don't use it) so that augmentations
14455>>>>>    // could support error logging down to a field level. If a non-field error
14455>>>>>    // is required the developer should pass negative values (e.g., -1)
14455>>>>>    // This will redirect errors locally if not already redirected
14455>>>>>    //
14455>>>>>    // Altered to additionally support %1 %2 replacements as well as
14455>>>>>    // replacements for @PARAM1 and @PARAM2. (vdf8.2)
14455>>>>>    Procedure Data_set_error Integer iField Integer iErr String sMess ;            String sParam1 String sParam2
14457>>>>>        Integer iOldField
14457>>>>>        Get Current_validate_field to iOldField
14458>>>>>        If (iField <> 0) ;            Set Current_Validate_field to iField
14461>>>>>        
14461>>>>>        If (iErr = 0) ; // if no error is passes, used a default error            Move DD_DEFAULT_ERROR_NUMBER to iErr
14464>>>>>        
14464>>>>>        If (sMess > "") Begin
14466>>>>>            
14466>>>>>            // Support message replacements.. Up to two values
14466>>>>>            // altered to support @Param1/2 and %1 %2 messages
14466>>>>>            If (Num_Arguments>3) Begin
14468>>>>>                Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
14469>>>>>                If (Num_Arguments>4) Begin
14471>>>>>                    Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
14472>>>>>                    Move (SFormat(sMess,sParam1,sParam2)) to sMess
14473>>>>>                End
14473>>>>>>
14473>>>>>                Else Begin
14474>>>>>                    Move (SFormat(sMess,sParam1)) to sMess
14475>>>>>                End
14475>>>>>>
14475>>>>>            End
14475>>>>>>
14475>>>>>            Move Self to ghoErrorSource
14476>>>>>            Error iErr sMess
14477>>>>>>
14477>>>>>            Move 0 to ghoErrorSource
14478>>>>>        End
14478>>>>>>
14478>>>>>        Else ;            Send Operation_Not_Allowed iErr
14480>>>>>        Set Current_validate_field to iOldField
14481>>>>>        Move True to Err // make sure Err is still set
14482>>>>>    End_Procedure
14483>>>>>    
14483>>>>>    // Augment to support Error_Report_Mode. Allows errors without error mess
14483>>>>>    // This will redirect errors locally if not already redirected
14483>>>>>    Procedure Operation_Not_Allowed Integer iErr
14485>>>>>        Integer bOK
14485>>>>>        Move Self to ghoErrorSource
14486>>>>>        Forward Send Operation_Not_Allowed iErr
14488>>>>>        Move 0 to ghoErrorSource
14489>>>>>    End_Procedure
14490>>>>>    
14490>>>>>    // Local error handler. When errors are redirected to the DD this proce-
14490>>>>>    // dure handles the errors. If error_report_mode is NO-report it sets
14490>>>>>    // the err indicator and returns. Else it redirects the error to the
14490>>>>>    // main error handler first moving its ID to ghoErrorSource. This way the
14490>>>>>    // handler knows who sent this message and will get additional error info
14490>>>>>    // by calling Get Extended_error_message
14490>>>>>    Procedure Error_Report Integer iError Integer iLine String ErrMsg
14492>>>>>        Integer hoErrId
14492>>>>>        Integer bRedirect
14492>>>>>        If (Error_Processing_State(Self)) ;  // this prevents recursion            Procedure_Return
14495>>>>>        Set Error_Processing_State to True
14496>>>>>        
14496>>>>>        // if no report mode, just set the err indicator to true.
14496>>>>>        If (Error_Report_Mode(Self)=DD_ERROR_NO_REPORT) ;            Move True to Err
14499>>>>>        Else Begin
14500>>>>>            Get Old_error_object_id to hoErrId  // the original error handler
14501>>>>>            If hoErrId Begin
14503>>>>>                Move (ghoErrorSource=0) to bRedirect
14504>>>>>                If bRedirect ;                    Move Self to ghoErrorSource // error handler can use this
14507>>>>>                Move hoErrID to Error_object_id
14508>>>>>                Send Error_Report to hoErrId iError iLine ErrMsg
14509>>>>>                Move Self to Error_object_id
14510>>>>>                If bRedirect ;                    Move 0 to ghoErrorSource
14513>>>>>            End
14513>>>>>>
14513>>>>>            Else ;                Send error_report of desktop iError iLine ErrMsg
14515>>>>>            //else forward send error_report iError iLine ErrMsg
14515>>>>>        End
14515>>>>>>
14515>>>>>        Set Error_Processing_State to False
14516>>>>>    End_Procedure
14517>>>>>    
14517>>>>>    // This is called (by the system error handler) to get additional informa-
14517>>>>>    // tion about the error. Returns a multi line string with each line
14517>>>>>    // separated by a "\n". Return the file number, name, and if possible
14517>>>>>    // the field number and name.
14517>>>>>    Function Extended_Error_Message Returns String
14519>>>>>        String sExtMess
14519>>>>>        String sFile
14519>>>>>        Integer iFile iField
14519>>>>>        Get main_file to iFile
14520>>>>>        Get Current_Validate_Field to iField
14521>>>>>        Get ErrorMessageTableName iFile to sFile
14522>>>>>        Move (DD_FILE_TEXT* String(iFile) * "-" * sFile) to sExtMess
14523>>>>>        If (iField > 0) ;            Append sExtMess "\n" ;            (DD_FIELD_TEXT* String(iField) * "-" * Field_Label(Self,iField,DD_LABEL_LONG))
14527>>>>>        Set Current_Validate_Field to 0
14528>>>>>        Function_Return sExtMess
14529>>>>>    End_Function
14530>>>>>    
14530>>>>>    Function Extended_Error_File Returns Integer
14532>>>>>        Function_Return (Main_File(Self))
14533>>>>>    End_Function
14534>>>>>    
14534>>>>>    Function Extended_Error_Field Returns Integer
14536>>>>>        Function_Return (Current_Validate_Field(Self))
14537>>>>>    End_Function
14538>>>>>    
14538>>>>>    
14538>>>>>    // The following messages are used to control smart file mode exception
14538>>>>>    // handling. The message "Send Add_system_File file# Fg" allows you to
14538>>>>>    // add system files (or any other files not known to the dso structure)
14538>>>>>    // within define_fields. This allows you to not have to augment the msg
14538>>>>>    // reset_filemodes_for_lock. The only truly public messages here are
14538>>>>>    // Add_system_file and Remove_system_File (which s/b rarely used).
14538>>>>>    
14538>>>>>    // Adds a system file for smart_file_mode handling. A second optional
14538>>>>>    // parameter may be passed to determine of the sys file should only be
14538>>>>>    // locked during a new save (and not during a delete or a save of an
14538>>>>>    // existing record). It is expected that this will be the only public
14538>>>>>    // message used to control smart filemode. All of the remaining sys file
14538>>>>>    // messages are considered advanced.
14538>>>>>    Procedure Add_System_File Integer iFile Integer iLock_Mode
14540>>>>>        Integer iobj iCnt iMode
14540>>>>>        If (Num_arguments = 1) ;            Move DD_Lock_on_All to iMode
14543>>>>>        Else ;            Move iLock_Mode     to iMode
14545>>>>>        Move (system_file_obj(Self)) to iObj
14546>>>>>        Get Item_Count  of iObj to iCnt
14547>>>>>        Set Array_Value of iObj iCnt to iFile
14548>>>>>        Increment iCnt
14549>>>>>        Set Array_Value of iObj iCnt to iMode
14550>>>>>    End_Procedure
14551>>>>>    
14551>>>>>    // Return number of system files
14551>>>>>    Function System_File_Count Returns Integer
14553>>>>>        Function_Return (Item_Count(System_File_Obj(Self))/2)
14554>>>>>    End_Function
14555>>>>>    
14555>>>>>    // Returns system file number for passed item.
14555>>>>>    Function System_File_Number Integer iItem Returns Integer
14557>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2))
14558>>>>>    End_Function
14559>>>>>    
14559>>>>>    // Returns system flag to determine if file is only used during a new
14559>>>>>    // save (and not during an exiting save or a delete).
14559>>>>>    Function System_File_Lock_Mode Integer iItem Returns Integer
14561>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2+1))
14562>>>>>    End_Function
14563>>>>>    
14563>>>>>    // Removes a system_file for smart_file_Mode handling. This remvoes the
14563>>>>>    // first occurance of the file (S/b the only occurance). We assume that
14563>>>>>    // this will be rarely used.
14563>>>>>    Procedure Remove_System_File Integer iFile
14565>>>>>        Integer iobj iCnt iItmCnt
14565>>>>>        Get System_file_Count to iItmCnt
14566>>>>>        Decrement iItmCnt
14567>>>>>        For iCnt from 0 to iItmCnt
14573>>>>>>
14573>>>>>            If (System_File_Number(Self,iCnt)=iFile) Begin
14575>>>>>                Move (system_file_obj(Self)) to iObj
14576>>>>>                Move (iCnt*2) to iCnt
14577>>>>>                Send Delete_Item to iObj iCnt
14578>>>>>                Send Delete_Item to iObj iCnt
14579>>>>>                Procedure_Return
14580>>>>>            End
14580>>>>>>
14580>>>>>        Loop
14581>>>>>>
14581>>>>>    End_Procedure
14582>>>>>    
14582>>>>>    // These set messages, add_client_file, add_server_file and add_system_file
14582>>>>>    // were added to more easily support visual DD class modeling. They do the
14582>>>>>    // same thing the Send counterpart messages do
14582>>>>>    
14582>>>>>    Procedure Set Add_Client_File Integer iFile
14584>>>>>        Send Add_Client_File iFile
14585>>>>>    End_Procedure
14586>>>>>    
14586>>>>>    Procedure Set Add_Server_File Integer iFile
14588>>>>>        Send Add_Server_File iFile
14589>>>>>    End_Procedure
14590>>>>>    
14590>>>>>    Procedure Set Add_System_File Integer iFile Integer iLock_Mode
14592>>>>>        // allow no arguments because the old message allowed this
14592>>>>>        If (Num_arguments=1) Begin
14594>>>>>            Send Add_System_File iFile
14595>>>>>        End
14595>>>>>>
14595>>>>>        Else Begin
14596>>>>>            Send Add_System_File iFile iLock_Mode
14597>>>>>        End
14597>>>>>>
14597>>>>>    End_Procedure
14598>>>>>    
14598>>>>>    // The Set Field_Auto_Increment method replaces the need to use the Define_Auto_Incrmement
14598>>>>>    // command. This models more easily and it supports multiple auto-increment fields
14598>>>>>    Procedure Set Field_Auto_Increment Integer iField Integer iSysFile Integer iSysField
14600>>>>>        Integer[] AutoIncFields
14601>>>>>        tDDFileField[] SysFileFields
14601>>>>>        tDDFileField[] SysFileFields
14602>>>>>        Integer iIndex
14602>>>>>        
14602>>>>>        If (iField=0 or (iSysFile<>0 and iSysField=0)) Begin
14604>>>>>            Error DFERR_PROGRAM "Auto-increment source or destination field is 0"
14605>>>>>>
14605>>>>>            Procedure_Return
14606>>>>>        End
14606>>>>>>
14606>>>>>        // setting the sysfile to 0 is valid. It can be used to clear an existing sysfile
14606>>>>>        If (iSysFile=0) Begin
14608>>>>>            Move 0 to iSysField
14609>>>>>        End
14609>>>>>>
14609>>>>>        Get pAutoIncrementFields to AutoIncFields
14610>>>>>        Get pAutoIncrementSysFileFields to SysFileFields
14611>>>>>        // the destination field array is a list of fields that have auto-incr info. There
14611>>>>>        // can only be zero or one entry per field arranged in no defined order.
14611>>>>>        // see if field is already defined. If not add this to the end.
14611>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
14612>>>>>        If (iIndex=-1) Begin
14614>>>>>            Move (SizeOfArray(SysFileFields)) to iIndex
14615>>>>>        End
14615>>>>>>
14615>>>>>        Move iField    to AutoIncFields[iIndex]
14616>>>>>        Move iSysFile  to SysFileFields[iIndex].iFile
14617>>>>>        Move iSysField to SysFileFields[iIndex].iField
14618>>>>>        Set pAutoIncrementFields to AutoIncFields
14619>>>>>        Set pAutoIncrementSysFileFields to SysFileFields
14620>>>>>    End_Procedure
14621>>>>>    
14621>>>>>    // Get auto-increment system file/field value for a field. There really should be no
14621>>>>>    // reason to ever need this. Field is returned byref
14621>>>>>    Function Field_Auto_Increment Integer iField Integer ByRef iSysField Returns Integer
14623>>>>>        Integer iSysFile
14623>>>>>        Integer[] AutoIncFields
14624>>>>>        tDDFileField[] SysFileFields
14624>>>>>        tDDFileField[] SysFileFields
14625>>>>>        Integer iIndex
14625>>>>>        
14625>>>>>        Get pAutoIncrementFields to AutoIncFields
14626>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
14627>>>>>        If (iIndex>-1) Begin
14629>>>>>            Get pAutoIncrementSysFileFields to SysFileFields
14630>>>>>            Move SysFileFields[iIndex].iFile to iSysFile
14631>>>>>            Move SysFileFields[iIndex].iField to iSysField
14632>>>>>        End
14632>>>>>>
14632>>>>>        Else Begin
14633>>>>>            Move 0 to iSysFile
14634>>>>>            Move 0 to iSysField
14635>>>>>        End
14635>>>>>>
14635>>>>>        Function_Return iSysFile
14636>>>>>    End_Function
14637>>>>>    
14637>>>>>    
14637>>>>>    // Augmented to set any system files defined via the Add_System_file
14637>>>>>    // message. This allows us to hide this procedure for the vast majority
14637>>>>>    // of cases.
14637>>>>>    Procedure Reset_Filemodes_For_Lock
14639>>>>>        Boolean bNewRec
14639>>>>>        Integer  iItmCnt iCnt iMode iFile
14639>>>>>        Integer iMain iMaster iOpts
14639>>>>>        Handle hoDD
14639>>>>>        
14639>>>>>        Forward Send Reset_Filemodes_for_lock
14641>>>>>        
14641>>>>>        Get System_File_Count to iItmCnt
14642>>>>>        If iItmCnt Begin
14644>>>>>            Move (not(HasRecord(Self))) to bNewRec
14645>>>>>            Decrement iItmCnt
14646>>>>>            For iCnt from 0 to iItmCnt
14652>>>>>>
14652>>>>>                Get System_File_Number         iCnt to iFile
14653>>>>>                Get System_File_Lock_Mode iCnt to iMode
14654>>>>>                If ( (iMode=DD_Lock_on_All) or ;                    (Operation_Mode=MODE_DELETING and (iMode iand DD_Lock_on_Delete) ) or ;                    (Operation_Mode=MODE_SAVING and ( (iMode iand DD_Lock_on_Save) or ;                    ( (iMode iand DD_Lock_on_New_Save) and bNewRec) ) ) ) Begin
14656>>>>>                    Set_Attribute DF_FILE_MODE of iFile to DF_FILEMODE_DEFAULT
14659>>>>>                End
14659>>>>>>
14659>>>>>            Loop
14660>>>>>>
14660>>>>>        End
14660>>>>>>
14660>>>>>        
14660>>>>>        // augment to support DD magnaged alias tables.
14660>>>>>        // If an alias, set the alias to the proper alias no locks only if
14660>>>>>        // the master file is actually part of this DDO structure. This allows you
14660>>>>>        // to use alias files without the master being present (or even open). This will work without needing
14660>>>>>        // to set the Master|Alias DF_FILE_ALIAS attributes. If the file is master and part of the DDO structure
14660>>>>>        // it will already have its No_locks attribute cleared. If not part of the DD, its not needed.
14660>>>>>        //
14660>>>>>        Get MasterForAlias to iMaster
14661>>>>>        If iMaster Begin
14663>>>>>            Get Main_File to iMain
14664>>>>>            Get Data_Set iMaster to hoDD // is the master in the DD structure
14665>>>>>            If hoDD Begin
14667>>>>>                Get_Attribute DF_FILE_MODE of iMain to iOpts
14670>>>>>                Set_Attribute DF_FILE_MODE of iMain to (iOpts ior DF_FILEMODE_NO_LOCKS)
14673>>>>>                // note this will be reset to what it was when the transaction ends
14673>>>>>            End
14673>>>>>>
14673>>>>>        End
14673>>>>>>
14673>>>>>        
14673>>>>>    End_Procedure
14674>>>>>    
14674>>>>>    // Augmented to handle auto-increment fields if defined. The value from
14674>>>>>    // the auto-incre sys file is incremented, saved and moved to the new
14674>>>>>    // record. As of 17.0 this is no longer in Creating, which is called after
14674>>>>>    // AutoIncrement.
14674>>>>>    Procedure AutoIncrement
14676>>>>>        Integer iSrcFile iSrcField i iAutoFields
14676>>>>>        Integer iDestFile iDestField
14676>>>>>        Number nNum
14676>>>>>        Integer[] AutoIncFields
14677>>>>>        tDDFileField[] AutoIncSysFileFields
14677>>>>>        tDDFileField[] AutoIncSysFileFields
14678>>>>>        Handle hoOwner
14678>>>>>        
14678>>>>>        Forward Send AutoIncrement
14680>>>>>        
14680>>>>>        // this supports the older Define_Auto_Increment logic. Only one is supported
14680>>>>>        // this is exists for backwards compatibility
14680>>>>>        Get Auto_Increment_Source_File to iSrcFile
14681>>>>>        If iSrcFile Begin // do we have auto increment?
14683>>>>>            Get Auto_Increment_Source_Field  to iSrcField
14684>>>>>            Get Auto_Increment_Dest_Field    to iDestField
14685>>>>>            If (iSrcField and iDestField) Begin  // just in case of error
14687>>>>>                Get Main_file to iDestFile
14688>>>>>                Get_Field_Value iSrcFile iSrcField to nNum
14691>>>>>                Move (nNum+1) to nNum
14692>>>>>                Set_Field_Value iSrcFile  iSrcField  to nNum
14695>>>>>                Set_Field_Value iDestFile iDestField to nNum
14698>>>>>                // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
14698>>>>>                // if the DD is not a parent file, it is a sysfile and we must save it
14698>>>>>                Get Which_Data_Set iSrcFile to hoOwner
14699>>>>>                If not hoOwner Begin
14701>>>>>                    SaveRecord iSrcFile
14702>>>>>                End
14702>>>>>>
14702>>>>>            End
14702>>>>>>
14702>>>>>        End
14702>>>>>>
14702>>>>>        // this supports the newer set syntax which support multiple fields. It is expected that you will
14702>>>>>        // use one syntax of the other, not both. If you use the old syntax, you cannot use the new one
14702>>>>>        Else Begin
14703>>>>>            Get pAutoIncrementFields to AutoIncFields
14704>>>>>            Move (SizeOfArray(AutoIncFields)) to iAutoFields
14705>>>>>            If (iAutoFields>0) Begin
14707>>>>>                Get pAutoIncrementSysFileFields to AutoIncSysFileFields
14708>>>>>                Get Main_file to iDestFile
14709>>>>>                For i from 0 to (iAutoFields-1)
14715>>>>>>
14715>>>>>                    // it is legal to set the sysfile to 0, this means it has been cleared and is not used
14715>>>>>                    If (AutoIncSysFileFields[i].iFile>0) Begin
14717>>>>>                        // we assume both the fields are valid and that they've already been tested when added
14717>>>>>                        Get_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
14720>>>>>                        Move (nNum+1) to nNum
14721>>>>>                        Set_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
14724>>>>>                        Set_Field_Value iDestFile AutoIncFields[i] to nNum
14727>>>>>                        // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
14727>>>>>                        // if the DD is not a parent file, it is a sysfile and we must save it
14727>>>>>                        Get Which_Data_Set AutoIncSysFileFields[i].iFile to hoOwner
14728>>>>>                        If not hoOwner Begin
14730>>>>>                            SaveRecord AutoIncSysFileFields[i].iFile
14731>>>>>                        End
14731>>>>>>
14731>>>>>                    End
14731>>>>>>
14731>>>>>                Loop
14732>>>>>>
14732>>>>>            End
14732>>>>>>
14732>>>>>        End
14732>>>>>>
14732>>>>>        
14732>>>>>    End_Procedure
14733>>>>>    
14733>>>>>    // Augmented to fix a bug in the data-set C code. When a record is saved
14733>>>>>    // as part of a delete operation OnNewCurrentRecord is not called. It
14733>>>>>    // should be. We will do this in flex code for now.
14733>>>>>    Procedure Save_Main_File
14735>>>>>        RowID riRec
14735>>>>>        Integer iRec iMain
14735>>>>>        Boolean bRecnumTable bChanged
14735>>>>>        
14735>>>>>        Get Main_File to iMain
14736>>>>>        Get_Attribute DF_FILE_CHANGED of iMain to bChanged
14739>>>>>        If bChanged Begin
14741>>>>>            Send OnSaveRecord // OnSaveRecord sent if there is something to save
14742>>>>>        End
14742>>>>>>
14742>>>>>        
14742>>>>>        Forward Send Save_Main_File
14744>>>>>        
14744>>>>>        If (Operation_Mode = MODE_DELETING) Begin  // during a delete the crnt
14746>>>>>            Get CurrentRowId to riRec             // rec of parents do not change
14747>>>>>            Send OnNewCurrentRecord riRec riRec  // so old and new are the same.
14748>>>>>            // for backwards compatibility reasons, we also send new_current_record if appropriate
14748>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of iMain to bRecnumTable
14751>>>>>            If (bRecnumTable) Begin
14753>>>>>                Get_Field_Value iMain 0 to iRec
14756>>>>>                Send New_Current_Record iRec iRec
14757>>>>>            End
14757>>>>>>
14757>>>>>        End
14757>>>>>>
14757>>>>>    End_Procedure
14758>>>>>    
14758>>>>>    // Augmented to not clear if a system-file. The auto-latching of views
14758>>>>>    // may cause a sys file DD to get cleared. This corrects this. This really
14758>>>>>    // belongs in Data_set (C) but we will not risk this for now.
14758>>>>>    Procedure Clear_Main_File
14760>>>>>        Integer iFile iIsSys
14760>>>>>        Get Main_File to iFile
14761>>>>>        If iFile Begin
14763>>>>>            Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to iIsSys
14766>>>>>            If iIsSys ;                Procedure_Return
14769>>>>>        End
14769>>>>>>
14769>>>>>        Forward Send Clear_main_file
14771>>>>>    End_Procedure
14772>>>>>    
14772>>>>>    // Executes a request_find on the mainfile. This is easier that having to
14772>>>>>    // pass file number all the time. Useful for batch operations.
14772>>>>>    // If Index is 0, use find_by_recnum (it handles a recnum of 0 better)
14772>>>>>    Procedure Find Integer iMode Integer iIndex
14774>>>>>        Integer iFile
14774>>>>>        Integer iRec
14774>>>>>        Get Main_file to iFile
14775>>>>>        If (iIndex<>0 or iMode<>EQ) ;            Send request_find iMode iFile iIndex
14778>>>>>        Else Begin
14779>>>>>            // this would never happen with row ID
14779>>>>>            Get_Field_Value iFile 0 to iRec // get recnum value
14782>>>>>            Send find_by_recnum iFile iRec
14783>>>>>        End
14783>>>>>>
14783>>>>>    End_Procedure
14784>>>>>    
14784>>>>>    // So many people make the mistake of using requeset_clear and request_
14784>>>>>    // clear_all that will support these are alteratives to clear and
14784>>>>>    // clear_all. The preferred messages remain Clear and Clear_all.
14784>>>>>    // This would not work if you nested DEOs within DSOs (no-one does).
14784>>>>>    Procedure Request_Clear
14786>>>>>        Send Clear
14787>>>>>    End_Procedure
14788>>>>>    
14788>>>>>    Procedure Request_Clear_All
14790>>>>>        Send Clear_All
14791>>>>>    End_Procedure
14792>>>>>    
14792>>>>>    // we want changed_state to always go through the
14792>>>>>    // Record_buffer object. From there it is sent to
14792>>>>>    // here. So if state or RB does not match we must
14792>>>>>    // send to the RB object...it will delegate to here
14792>>>>>    
14792>>>>>    Procedure Set Changed_State Integer bState
14794>>>>>        Integer hRB
14794>>>>>        Move (record_buffer(Self)) to hRB
14795>>>>>        If (hRB and changed_state(hRB)<>bState) ;            Set changed_state of hRB to bState
14798>>>>>        Else ;            Forward Set changed_state to bState
14801>>>>>    End_Procedure
14802>>>>>    
14802>>>>>    // this lets us use the new attach logic
14802>>>>>    
14802>>>>>    // This is a smarter attach than the normal attach command. It only attaches data from a parent
14802>>>>>    // if 1) the DDO parent is connected to the structure and 2) if there is a record to attach. It will
14802>>>>>    // not attach empty records into a child. This should make the finding (and saving) more sensible when
14802>>>>>    // partial DD structures are used. For example, often a report does not all of the parent DDOs - however if
14802>>>>>    // they are not provided, finding can get messed up because blank data is being moved into the child before a
14802>>>>>    // find. This has been a problem since 3.0. This should just make it go away.
14802>>>>>    // as of 17.0, we get the related field info through the local DSO if needed
14802>>>>>    
14802>>>>>    // as if 18.1 this is only called when there is an attachable relationship. This gives us a chance to do any
14802>>>>>    // customizations and to cancel the attach. We've left this to the flex level so we can fine tune attaches.
14802>>>>>    Function ShouldFieldAttach Integer iField Handle hoRelDD Returns Boolean
14804>>>>>        Boolean bDoAttach bChanged
14804>>>>>        Integer iFile iStat iRelFile iType
14804>>>>>        String sValue
14804>>>>>        
14804>>>>>        Get Main_File to iFile
14805>>>>>        Get Main_File of hoRelDD to iRelFile
14806>>>>>        
14806>>>>>        // before we attach check if Find mode and relfile is new and unchanged..if so skip.
14806>>>>>        // If operation_mode is 0, this is probably a Find (item_find sends attach_main_file for some reason).
14806>>>>>        Move True to bDoAttach
14807>>>>>        If (Operation_mode=MODE_FINDING or OPERATION_MODE=0) Begin
14809>>>>>            // we can test the file status to see if we have a record or not. If we have a record, we attach
14809>>>>>            Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
14812>>>>>            If (iStat=DF_FILE_INACTIVE) Begin
14814>>>>>                // if no record, we need to look for changes. We can't just look at the file's changed state because the DD
14814>>>>>                // may have set defaults, which have been moved to the buffer. We should be able to check the DD's changed state
14814>>>>>                // because this is not set with default values. When doing a find entry_update this should be ok. If this were
14814>>>>>                // a save, this would cause problems (but this is not a save). Prior to 17.0 this was not an issue with windows
14814>>>>>                // applications because find entry_updates were done at the DEO level (unlike web applications).
14814>>>>>                Get Changed_State of hoRelDD to bChanged
14815>>>>>                Move bChanged to bDoAttach
14816>>>>>                
14816>>>>>                // special Triumph workaround for Item_Find with blank inner segment. They were counting on the item_find attach_main_file
14816>>>>>                // which would slip through the "no-attach on find when parent is empty optimization". This was needed to force a string segment
14816>>>>>                // that was "" to get filled with spaces from the parent field. The child field was set to "" because of a constrained_clear
14816>>>>>                // in Item_find. This workaround is as narrow as possible. If an item_find attach_main_file (operation_mode=0) and this is
14816>>>>>                // an empty parent (bOk was just set to False), and the field is DF_Ascii and the child value is empty (no trailing spaces)
14816>>>>>                // then force an attach. Since the parent should be "", we can just Set_Field_value to "", which fills the field buffer.
14816>>>>>                // There is no real logic as to why this is being done other than to make it work like it used to with the least
14816>>>>>                // amount of side-effects.
14816>>>>>                If (not(bDoAttach) and OPERATION_MODE=0) Begin
14818>>>>>                    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
14821>>>>>                    If (iType=DF_ASCII) Begin
14823>>>>>                        Get_Field_Value iFile iField to sValue
14826>>>>>                        // if no spaces, this probably was cleared via constrained_clear in Item_Find. We should update
14826>>>>>                        If (Ascii(Left(sValue,1))=0) Begin
14828>>>>>                            Set_Field_Value iFile iField to ""
14831>>>>>                        End
14831>>>>>>
14831>>>>>                    End
14831>>>>>>
14831>>>>>                End
14831>>>>>>
14831>>>>>                
14831>>>>>            End
14831>>>>>>
14831>>>>>        End
14831>>>>>>
14831>>>>>        Function_Return bDoAttach
14832>>>>>    End_Function
14833>>>>>    
14833>>>>>    // Notify all DEOs that a mask has changed.
14833>>>>>    //        this message is sent by set Field_Mask
14833>>>>>    Procedure Field_Mask_Changed Integer iField String sMask
14835>>>>>        Integer i iDEOs iDEO
14835>>>>>        Integer iMain_File
14835>>>>>        Get Main_File to iMain_File
14836>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14837>>>>>        Decrement iDEOs
14838>>>>>        For i from 0 to iDEOs
14844>>>>>>
14844>>>>>            Get Data_Set_User_Interface i to iDEO
14845>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Mask_Changed to iDEO ;                iMain_File iField sMask
14848>>>>>        Loop
14849>>>>>>
14849>>>>>    End_Procedure
14850>>>>>    
14850>>>>>    // Notify all DEOs that a label has changed.
14850>>>>>    //   This message is sent by Set Field_Label_long & Field_Label_Short
14850>>>>>    Procedure Field_label_Changed Integer iField Boolean bLong String sLabel
14852>>>>>        Integer i iDEOs iDEO
14852>>>>>        Integer iMain_File
14852>>>>>        Get Main_File to iMain_File
14853>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14854>>>>>        Decrement iDEOs
14855>>>>>        For i from 0 to iDEOs
14861>>>>>>
14861>>>>>            Get Data_Set_User_Interface i to iDEO
14862>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Label_Changed to iDEO ;                iMain_File iField bLong sLabel
14865>>>>>        Loop
14866>>>>>>
14866>>>>>    End_Procedure
14867>>>>>    
14867>>>>>    // Notify all DEOs that a field option has changed.
14867>>>>>    //   This message is sent by Set Field_Option
14867>>>>>    Procedure Field_Option_Changed Integer iField Integer iOptions Boolean bClear
14869>>>>>        Integer i iDEOs iDEO
14869>>>>>        Integer iMain_File
14869>>>>>        Get Main_File to iMain_File
14870>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14871>>>>>        Decrement iDEOs
14872>>>>>        For i from 0 to iDEOs
14878>>>>>>
14878>>>>>            Get Data_Set_User_Interface i to iDEO
14879>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Option_Changed of iDEO ;                iMain_File iField iOptions bClear
14882>>>>>        Loop
14883>>>>>>
14883>>>>>    End_Procedure
14884>>>>>    
14884>>>>>    
14884>>>>>    //   Set, clear or toggle a field option
14884>>>>>    //   Multiple options can be passed as an expression
14884>>>>>    //   (e.g. Set Field_option 2 (dd_Retain IOR dd_NoEnter).
14884>>>>>    //   Unlike set Field_options this notifies DEOs of changes
14884>>>>>    // supports setting and clearing. e.g.:
14884>>>>>    //    Set Field_Option Field Customer.Name DD_NoEnter to True
14884>>>>>    // This new syntax is now the recommended syntax but the older syntax without
14884>>>>>    // the last parameter is supported (where true is the default). The old syntax is
14884>>>>>    // only supported for compatibility. This means that Field_Option_Clear should
14884>>>>>    // also be replaced with Field_Option
14884>>>>>    Procedure Set Field_Option Integer iField Integer iOption Boolean bSet
14886>>>>>        Boolean bSetTrue
14886>>>>>        Move (If(num_arguments>2, bSet, True)) to bSetTrue // support for old deprecated syntax
14887>>>>>        If bSetTrue Begin
14889>>>>>            Set Field_options iField to iOption
14890>>>>>        End
14890>>>>>>
14890>>>>>        Else Begin
14891>>>>>            Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOption
14892>>>>>        End
14892>>>>>>
14892>>>>>        If (Data_Set_User_Interface_Count(Self)) Begin
14894>>>>>            Send Field_Option_Changed iField iOption (not(bSetTrue))
14895>>>>>        End
14895>>>>>>
14895>>>>>    End_Procedure
14896>>>>>    
14896>>>>>    Procedure Set File_Field_Option Integer iFile Integer iField Integer iOption Boolean bSet
14898>>>>>        Handle hoDD
14898>>>>>        Boolean bSetTrue
14898>>>>>        Move (If(num_arguments>3, bSet, True)) to bSetTrue // support for old deprecated syntax
14899>>>>>        Get Data_set iFile to hoDD
14900>>>>>        If hoDD Begin
14902>>>>>            Set Field_Option of hoDD iField iOption to bSetTrue
14903>>>>>        End
14903>>>>>>
14903>>>>>        
14903>>>>>    End_Procedure
14904>>>>>    
14904>>>>>    Procedure Set Field_Option_Clear Integer iField Integer iOptions
14906>>>>>        Set Field_Option iField iOptions to False
14907>>>>>    End_Procedure
14908>>>>>    
14908>>>>>    Procedure Set File_Field_Option_Clear Integer iFile Integer iField Integer iOptions
14910>>>>>        Set File_Field_Option iFile iField iOptions to False
14911>>>>>    End_Procedure
14912>>>>>    
14912>>>>>    Procedure Set Field_Option_Toggle Integer iField Integer iOption
14914>>>>>        Integer iOldOption
14914>>>>>        Get Field_Options iField to iOldOption
14915>>>>>        // if old and new have overlapping bits, we assume clear
14915>>>>>        Set Field_Option iField iOption to ((iOldOption iand iOption)=0)
14916>>>>>    End_Procedure
14917>>>>>    
14917>>>>>    Procedure Set File_Field_Option_Toggle Integer iFile Integer iField Integer iOption
14919>>>>>        Handle hoDD
14919>>>>>        Get Data_set iFile to hoDD
14920>>>>>        If hoDD ;            Set Field_Option_Toggle of hoDD iField to iOption
14923>>>>>    End_Procedure
14924>>>>>    
14924>>>>>    // This returns the main index for a field. This replaces the DSO message Field_Main_index which
14924>>>>>    // should no longer be used by DDOs. The old message has the problem that the DDO or DSO using
14924>>>>>    // this message may not be the owner of the field. So augmenting the owner DDO did not insure that
14924>>>>>    // all requests for this index would go through it. Now you can augment Field_Index and always
14924>>>>>    // be sure that any DDO requesting an index for a file (via file_field_index) will always go to
14924>>>>>    // the owner object.
14924>>>>>    Function Field_Index Integer iField Returns Integer
14926>>>>>        Integer iFile iIndex iOrder
14926>>>>>        // ordering takes precendence
14926>>>>>        Get ordering to iOrder
14927>>>>>        If (iOrder>=0);            Move iOrder to iIndex  //ordering takes precedence over main index
14930>>>>>        Else Begin
14931>>>>>            Get Main_file to iFile
14932>>>>>            Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex // main index field
14935>>>>>            If (iIndex=0 and iField>0) ; // If field is not recnum and there is no index, the                Move -1 to iIndex        // field has no main index
14938>>>>>        End
14938>>>>>>
14938>>>>>        Function_Return iIndex
14939>>>>>    End_Function
14940>>>>>    
14940>>>>>    // In all cases, this message should be sent instead of Field_Main_Index. If
14940>>>>>    // augmentation was used in Field_Main_Index, use Field_Index to insure the owner object
14940>>>>>    // is called.
14940>>>>>    
14940>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
14942>>>>>        Integer iIndex
14942>>>>>        Handle hoDD
14942>>>>>        Get Data_set iFile to hoDD
14943>>>>>        If (hoDD) ;            Get Field_Index of hoDD iField to iIndex
14946>>>>>        Else ;            Move -1 to iIndex
14948>>>>>        Function_Return iIndex
14949>>>>>    End_Function
14950>>>>>    
14950>>>>>    // 12/1 change: Make sure all of the major DD operations update the DD with the value in
14950>>>>>    // the focus field. After the actual find, save, clar or delete, the DD buffer contains information that
14950>>>>>    // is not yet reflected in the DEOs (before refresh is called) we want to make sure that we
14950>>>>>    // don't try to get data from the DEO. Get Field_Current_Value now checks if operation_mode is
14950>>>>>    // non-zero. If it is, it always gets from the DD buffer.
14950>>>>>    
14950>>>>>    Procedure Clear
14952>>>>>        Boolean bOpOk
14952>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14953>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14955>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARING
14956>>>>>        End
14956>>>>>>
14956>>>>>        If (bOpOk) Begin
14958>>>>>            Send OnPreFind DDFindClear
14959>>>>>        End
14959>>>>>>
14959>>>>>        Forward Send Clear
14961>>>>>        If (bOpOk) Begin
14963>>>>>            Send DefaultParentAutofinds
14964>>>>>            Send OnPostFind DDFindClear True
14965>>>>>        End
14965>>>>>>
14965>>>>>    End_Procedure
14966>>>>>    
14966>>>>>    Procedure Clear_All
14968>>>>>        Boolean bOpOk
14968>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14969>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14971>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARINGALL
14972>>>>>        End
14972>>>>>>
14972>>>>>        Forward Send clear_all
14974>>>>>        If (bOpOk) Begin
14976>>>>>            Send DefaultParentAutofinds
14977>>>>>        End
14977>>>>>>
14977>>>>>    End_Procedure
14978>>>>>    
14978>>>>>    Procedure Request_Assign Integer iFile
14980>>>>>        Handle hoDD
14980>>>>>        Boolean bFound
14980>>>>>        Boolean bOpOk
14980>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14981>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14983>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
14984>>>>>        End
14984>>>>>>
14984>>>>>        
14984>>>>>        If (bOpOk) Begin
14986>>>>>            If (num_arguments=0 or iFile=0) Begin
14988>>>>>                Move Self to hoDD
14989>>>>>            End
14989>>>>>>
14989>>>>>            Else Begin
14990>>>>>                Get Data_Set iFile to hoDD
14991>>>>>            End
14991>>>>>>
14991>>>>>            If hoDD Begin
14993>>>>>                Send OnPreFind of hoDD DDFindRequestAssign
14994>>>>>            End
14994>>>>>>
14994>>>>>        End
14994>>>>>>
14994>>>>>        
14994>>>>>        If (num_arguments=0) Begin
14996>>>>>            Forward Send Request_Assign
14998>>>>>        End
14998>>>>>>
14998>>>>>        Else Begin
14999>>>>>            Forward Send Request_Assign iFile
15001>>>>>        End
15001>>>>>>
15001>>>>>        
15001>>>>>        If (bOpOk) Begin
15003>>>>>            If (hoDD) Begin
15005>>>>>                Move (Found) to bFound
15006>>>>>                Send OnPostFind of hoDD DDFindRequestAssign bFound
15007>>>>>                Move bFound to Found
15008>>>>>            End
15008>>>>>>
15008>>>>>        End
15008>>>>>>
15008>>>>>    End_Procedure
15009>>>>>    
15009>>>>>    
15009>>>>>    Procedure Find_By_Recnum Integer iFile Integer iRecord
15011>>>>>        Handle hoDD
15011>>>>>        Boolean bFound
15011>>>>>        Boolean bOpOk
15011>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15012>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15013>>>>>        
15013>>>>>        If (bOpOk) Begin
15015>>>>>            Get Data_Set iFile to hoDD
15016>>>>>            If hoDD Begin
15018>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15019>>>>>            End
15019>>>>>>
15019>>>>>        End
15019>>>>>>
15019>>>>>        
15019>>>>>        Forward Send Find_By_Recnum iFile iRecord
15021>>>>>        
15021>>>>>        If (bOpOk) Begin
15023>>>>>            If (hoDD) Begin
15025>>>>>                Move (Found) to bFound
15026>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15027>>>>>                Move bFound to Found
15028>>>>>            End
15028>>>>>>
15028>>>>>        End
15028>>>>>>
15028>>>>>    End_Procedure
15029>>>>>    
15029>>>>>    Procedure FindByRowId Integer iFile RowID riRowId
15031>>>>>        Handle hoDD
15031>>>>>        Boolean bFound
15031>>>>>        Boolean bOpOk
15031>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15032>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15033>>>>>        
15033>>>>>        If (bOpOk) Begin
15035>>>>>            Get Data_Set iFile to hoDD
15036>>>>>            If hoDD Begin
15038>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15039>>>>>            End
15039>>>>>>
15039>>>>>        End
15039>>>>>>
15039>>>>>        
15039>>>>>        Forward Send FindByRowId iFile riRowId
15041>>>>>        
15041>>>>>        If (bOpOk) Begin
15043>>>>>            If (hoDD) Begin
15045>>>>>                Move (Found) to bFound
15046>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15047>>>>>                Move bFound to Found
15048>>>>>            End
15048>>>>>>
15048>>>>>        End
15048>>>>>>
15048>>>>>    End_Procedure
15049>>>>>    
15049>>>>>    Function FindByRowIdEx Integer iFile RowID riRowId Returns Boolean
15051>>>>>        Handle hoDD
15051>>>>>        Boolean bFound bSuccess
15051>>>>>        Boolean bOpOk
15051>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15052>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15053>>>>>        
15053>>>>>        If (bOpOk) Begin
15055>>>>>            Get Data_Set iFile to hoDD
15056>>>>>            If hoDD Begin
15058>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15059>>>>>            End
15059>>>>>>
15059>>>>>        End
15059>>>>>>
15059>>>>>        
15059>>>>>        Forward Get FindByRowIdEx iFile riRowId to bSuccess
15061>>>>>        
15061>>>>>        If (bOpOk) Begin
15063>>>>>            If (hoDD) Begin
15065>>>>>                Move (Found) to bFound
15066>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15067>>>>>                Move bFound to Found
15068>>>>>            End
15068>>>>>>
15068>>>>>        End
15068>>>>>>
15068>>>>>        Function_Return bSuccess
15069>>>>>    End_Function
15070>>>>>    
15070>>>>>    Function FindByRowIdExNoAutoFill Integer iFile RowID riRowId Returns Boolean
15072>>>>>        Handle hoDD
15072>>>>>        Boolean bFound bSuccess
15072>>>>>        Boolean bOpOk
15072>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15073>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15074>>>>>        
15074>>>>>        If (bOpOk) Begin
15076>>>>>            Get Data_Set iFile to hoDD
15077>>>>>            If hoDD Begin
15079>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15080>>>>>            End
15080>>>>>>
15080>>>>>        End
15080>>>>>>
15080>>>>>        
15080>>>>>        Forward Get FindByRowIdExNoAutoFill iFile riRowId to bSuccess
15082>>>>>        
15082>>>>>        If (bOpOk) Begin
15084>>>>>            If (hoDD) Begin
15086>>>>>                Move (Found) to bFound
15087>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15088>>>>>                Move bFound to Found
15089>>>>>            End
15089>>>>>>
15089>>>>>        End
15089>>>>>>
15089>>>>>        Function_Return bSuccess
15090>>>>>    End_Function
15091>>>>>    
15091>>>>>    
15091>>>>>    Procedure Request_Find Integer eFindMode Integer iFile Integer iIndex
15093>>>>>        Handle hoDD
15093>>>>>        Boolean bFound
15093>>>>>        Boolean bOpOk
15093>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15094>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
15096>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
15097>>>>>        End
15097>>>>>>
15097>>>>>        
15097>>>>>        If (bOpOk) Begin
15099>>>>>            Get Data_Set iFile to hoDD
15100>>>>>            If hoDD Begin
15102>>>>>                Send OnPreFind of hoDD DDFindRequestFind
15103>>>>>            End
15103>>>>>>
15103>>>>>        End
15103>>>>>>
15103>>>>>        
15103>>>>>        Forward Send Request_Find eFindMode iFile iIndex
15105>>>>>        
15105>>>>>        If (bOpOk) Begin
15107>>>>>            If (hoDD) Begin
15109>>>>>                Move (Found) to bFound
15110>>>>>                Send OnPostFind of hoDD DDFindRequestFind bFound
15111>>>>>                Move bFound to Found
15112>>>>>            End
15112>>>>>>
15112>>>>>        End
15112>>>>>>
15112>>>>>    End_Procedure
15113>>>>>    
15113>>>>>    Procedure OnPreFind Integer eMessage
15115>>>>>    End_Procedure
15116>>>>>    
15116>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
15118>>>>>    End_Procedure
15119>>>>>    
15119>>>>>    
15119>>>>>    
15119>>>>>    Procedure Request_Superfind Integer eFindMode Integer iFile Integer iField
15121>>>>>        Boolean bInSuperFind
15121>>>>>        // we need to set pbInSuperFind so Entry_update in the DEOs will know that
15121>>>>>        // they should perform an entry_update. Superfind entry_updates have never gone through
15121>>>>>        // the DD's field buffer.
15121>>>>>        Get pbInSuperFind to bInSuperFind
15122>>>>>        Set pbInSuperFind to True
15123>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
15125>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
15126>>>>>        End
15126>>>>>>
15126>>>>>        Forward Send Request_Superfind eFindMode iFile iField
15128>>>>>        Set pbInSuperFind to bInSuperFind
15129>>>>>    End_Procedure
15130>>>>>    
15130>>>>>    // Augmented to return true if a non-constrained parent DD has a change. This way
15130>>>>>    // Should_Save_row only filters changes in a consrained parent.
15130>>>>>    
15130>>>>>    Function Should_Save_Row Returns Boolean
15132>>>>>        Boolean bShouldSaveRow bShouldSave bRelatesToConstraint
15132>>>>>        Integer iServers iServer iServerFile
15132>>>>>        Handle hoServerDD
15132>>>>>        Forward Get Should_Save_Row to bShouldSaveRow // will be true if this DD is changed or has a changed parent.
15134>>>>>        Get Should_Save to bShouldSave // will be true if there is a change anywhere up the entire save structure
15135>>>>>        If (not(bShouldSaveRow) and bShouldSave) Begin
15137>>>>>            // If here we have a changed in an server but not the this DD. We need a further refinement. If the server
15137>>>>>            // change is in a constrained server, we don't consider this a change because you can switch rows without losing
15137>>>>>            // data (with RT changes made for 17.0).
15137>>>>>            Get Data_Set_Server_Count to iServers
15138>>>>>            For iServer from 0 to (iServers-1)
15144>>>>>>
15144>>>>>                Get Data_Set_Server iServer to hoServerDD
15145>>>>>                Get Should_Save of hoServerDD to bShouldSave
15146>>>>>                If bShouldSave Begin
15148>>>>>                    Get Main_File of hoServerDD to iServerFile
15149>>>>>                    Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
15150>>>>>                    If not bRelatesToConstraint Begin
15152>>>>>                        Function_Return True
15153>>>>>                    End
15153>>>>>>
15153>>>>>                End
15153>>>>>>
15153>>>>>            Loop
15154>>>>>>
15154>>>>>        End
15154>>>>>>
15154>>>>>        Function_Return bShouldSaveRow
15155>>>>>    End_Function
15156>>>>>    
15156>>>>>    // returns true if any relates-to constraining server needs a save. Normally there will be
15156>>>>>    // one or zero related-to parents. If Should_Save_Row returns false it is possible that there
15156>>>>>    // is a change up the relates-to constrained branch. If so, this will return True. This can be
15156>>>>>    // used to better determine the changed status of your DDO sructure
15156>>>>>    Function ShouldSaveConstrainedToServer Returns Boolean
15158>>>>>        Boolean bShouldSave bRelatesToConstraint
15158>>>>>        Integer iServers iServer iServerFile
15158>>>>>        Handle hoServerDD
15158>>>>>        Get Data_Set_Server_Count to iServers
15159>>>>>        For iServer from 0 to (iServers-1)
15165>>>>>>
15165>>>>>            Get Data_Set_Server iServer to hoServerDD
15166>>>>>            Get Main_File of hoServerDD to iServerFile
15167>>>>>            Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
15168>>>>>            If bRelatesToConstraint Begin
15170>>>>>                Get Should_Save of hoServerDD to bShouldSave
15171>>>>>                If bShouldSave Begin
15173>>>>>                    Function_Return True
15174>>>>>                End
15174>>>>>>
15174>>>>>            End
15174>>>>>>
15174>>>>>        Loop
15175>>>>>>
15175>>>>>        Function_Return False
15176>>>>>    End_Function
15177>>>>>    
15177>>>>>    Function FindServerInformationElement Integer iFile Returns Integer
15179>>>>>        tDDServerInformation[] ServerInformation
15179>>>>>        tDDServerInformation[] ServerInformation
15180>>>>>        tDDServerInformation ServerSearch
15180>>>>>        tDDServerInformation ServerSearch
15180>>>>>        Integer iIndex
15180>>>>>        Move iFile to ServerSearch.iParent
15181>>>>>        Get pServerInformation to ServerInformation
15182>>>>>        Function_Return (SearchArray(ServerSearch,ServerInformation))
15183>>>>>    End_Function
15184>>>>>    
15184>>>>>    Procedure AddServerData Integer iFile Integer eParam Boolean bValue
15186>>>>>        tDDServerInformation[] ServerInformation
15186>>>>>        tDDServerInformation[] ServerInformation
15187>>>>>        Integer iIndex
15187>>>>>        Handle hoDDO
15187>>>>>        
15187>>>>>        Get pServerInformation to ServerInformation
15188>>>>>        Get FindServerInformationElement iFile to iIndex
15189>>>>>        If (iIndex=-1) Begin
15191>>>>>            Move (SizeOfArray(ServerInformation)) to iIndex
15192>>>>>            Move iFile to ServerInformation[iIndex].iParent
15193>>>>>            // defaults must always be false!
15193>>>>>            Move False to ServerInformation[iIndex].bParentNoSwitchIfCommitted
15194>>>>>            Move False to ServerInformation[iIndex].bAllowNullParent
15195>>>>>            Move False to ServerInformation[iIndex].bNoCascadeDelete
15196>>>>>            Move False to ServerInformation[iIndex].bCascadeDeleteNullTheParent
15197>>>>>        End
15197>>>>>>
15197>>>>>        
15197>>>>>        If (eParam=0) Begin
15199>>>>>            If (bValue<>ServerInformation[iIndex].bAllowNullParent) Begin
15201>>>>>                Move bValue to ServerInformation[iIndex].bAllowNullParent
15202>>>>>                Send AdjustDeleteValidateStructure iFile
15203>>>>>            End
15203>>>>>>
15203>>>>>        End
15203>>>>>>
15203>>>>>        Else If (eParam=1) Begin
15206>>>>>            Move bValue to ServerInformation[iIndex].bParentNoSwitchIfCommitted
15207>>>>>        End
15207>>>>>>
15207>>>>>        Else If (eParam=2) Begin
15210>>>>>            Move bValue to ServerInformation[iIndex].bNoCascadeDelete
15211>>>>>        End
15211>>>>>>
15211>>>>>        Else Begin // (3)
15212>>>>>            If (bValue<>ServerInformation[iIndex].bCascadeDeleteNullTheParent) Begin
15214>>>>>                Move bValue to ServerInformation[iIndex].bCascadeDeleteNullTheParent
15215>>>>>                Send AdjustDeleteValidateStructure iFile
15216>>>>>            End
15216>>>>>>
15216>>>>>        End
15216>>>>>>
15216>>>>>        Set pServerInformation to ServerInformation
15217>>>>>    End_Procedure
15218>>>>>    
15218>>>>>    Function GetServerData Integer iFile Integer eParam Returns Boolean
15220>>>>>        Boolean bValue
15220>>>>>        tDDServerInformation[] ServerInformation
15220>>>>>        tDDServerInformation[] ServerInformation
15221>>>>>        Integer iIndex
15221>>>>>        Get pServerInformation to ServerInformation
15222>>>>>        Get FindServerInformationElement iFile to iIndex
15223>>>>>        // when not found in array, we want to make sure that we return false. Therefore
15223>>>>>        // false should always be the default.
15223>>>>>        If (iIndex<>-1) Begin
15225>>>>>            If (eParam=0) Begin
15227>>>>>                Move ServerInformation[iIndex].bAllowNullParent to bValue
15228>>>>>            End
15228>>>>>>
15228>>>>>            Else If (eParam=1) Begin
15231>>>>>                Move ServerInformation[iIndex].bParentNoSwitchIfCommitted to bValue
15232>>>>>            End
15232>>>>>>
15232>>>>>            Else If (eParam=2) Begin
15235>>>>>                Move ServerInformation[iIndex].bNoCascadeDelete to bValue
15236>>>>>            End
15236>>>>>>
15236>>>>>            Else Begin
15237>>>>>                Move ServerInformation[iIndex].bCascadeDeleteNullTheParent to bValue
15238>>>>>            End
15238>>>>>>
15238>>>>>        End
15238>>>>>>
15238>>>>>        Function_Return bValue
15239>>>>>    End_Function
15240>>>>>    
15240>>>>>    Procedure AdjustDeleteValidateStructure2
15242>>>>>        Integer iCount i
15242>>>>>        Handle hoDDO
15242>>>>>        Boolean bVisited
15242>>>>>        Set Visited_State to True
15243>>>>>        Set Cascade_Delete_Structure_Validated_State to False
15244>>>>>        Get Data_Set_Server_Count to iCount
15245>>>>>        For i from 0 to (iCount-1)
15251>>>>>>
15251>>>>>            Get Data_Set_Server i to hoDDO
15252>>>>>            Get Visited_State of hoDDO to bVisited
15253>>>>>            If (not(bVisited)) Begin
15255>>>>>                Send AdjustDeleteValidateStructure2 of hoDDO
15256>>>>>            End
15256>>>>>>
15256>>>>>        Loop
15257>>>>>>
15257>>>>>    End_Procedure
15258>>>>>    
15258>>>>>    // This is called in the unlikely case that NullParent/CascadeNull are set dynamically. It
15258>>>>>    // tells the parent DDO to recheck its validate-delete structure and it tells all ancestors of
15258>>>>>    // this parent to do the same. If called while DDOs are being created (via a class setting) there
15258>>>>>    // will not be a connected parent for iFile, which is fine.
15258>>>>>    Procedure AdjustDeleteValidateStructure Integer iFile
15260>>>>>        Handle hoDDO
15260>>>>>        Get Which_Data_Set iFile to hoDDO
15261>>>>>        If hoDDO Begin
15263>>>>>            Send Initialize_Visited of hoDDO False False
15264>>>>>            Send AdjustDeleteValidateStructure2 of hoDDO
15265>>>>>        End
15265>>>>>>
15265>>>>>    End_Procedure
15266>>>>>    
15266>>>>>    // Used to add a null parent to the list of parents that allow this
15266>>>>>    Procedure Set ParentNullAllowed Integer iParent Boolean bAllowed
15268>>>>>        Send AddServerData iParent 0 bAllowed
15269>>>>>    End_Procedure
15270>>>>>    
15270>>>>>    // returns true if null parent allowed for this parent file
15270>>>>>    Function ParentNullAllowed Integer iParent Returns Boolean
15272>>>>>        Boolean bValue
15272>>>>>        Get GetServerData iParent 0 to bValue
15273>>>>>        Function_Return bValue
15274>>>>>    End_Function
15275>>>>>    
15275>>>>>    // returns true if null parent allowed for this parent file. This is the function
15275>>>>>    // that can be used for augmentation. This is the methid that is called by the runtime
15275>>>>>    // to determine if a null parent is allowed
15275>>>>>    Function IsNullParentAllowed Integer iServer Returns Boolean
15277>>>>>        Boolean bAllowed
15277>>>>>        Get ParentNullAllowed iServer to bAllowed
15278>>>>>        Function_Return bAllowed
15279>>>>>    End_Function
15280>>>>>    
15280>>>>>    Procedure Set ParentNoSwitchIfCommitted Integer iParent Boolean bAllowed
15282>>>>>        Send AddServerData iParent 1 bAllowed
15283>>>>>    End_Procedure
15284>>>>>    
15284>>>>>    Function ParentNoSwitchIfCommitted Integer iParent Returns Boolean
15286>>>>>        Boolean bValue
15286>>>>>        Get GetServerData iParent 1 to bValue
15287>>>>>        Function_Return bValue
15288>>>>>    End_Function
15289>>>>>    
15289>>>>>    
15289>>>>>    Procedure Set CascadeDeleteAllowed Integer iParent Boolean bAllowed
15291>>>>>        Send AddServerData iParent 2 (not(bAllowed))
15292>>>>>    End_Procedure
15293>>>>>    
15293>>>>>    Function CascadeDeleteAllowed Integer iParent Returns Boolean
15295>>>>>        Boolean bValue
15295>>>>>        Get GetServerData iParent 2 to bValue // note that False=allowed
15296>>>>>        Function_Return (not(bValue))
15297>>>>>    End_Function
15298>>>>>    
15298>>>>>    Function IsCascadeDeleteAllowed Integer iServer Returns Boolean
15300>>>>>        Boolean bAllowed
15300>>>>>        Get CascadeDeleteAllowed iServer to bAllowed
15301>>>>>        Function_Return bAllowed
15302>>>>>    End_Function
15303>>>>>    
15303>>>>>    Procedure Set CascadeDeleteNull Integer iParent Boolean bAllowed
15305>>>>>        Send AddServerData iParent 3 bAllowed
15306>>>>>    End_Procedure
15307>>>>>    
15307>>>>>    Function CascadeDeleteNull Integer iParent Returns Boolean
15309>>>>>        Boolean bValue
15309>>>>>        Get GetServerData iParent 3 to bValue
15310>>>>>        Function_Return bValue
15311>>>>>    End_Function
15312>>>>>    
15312>>>>>    Function IsCascadeDeleteNull Integer iServer Returns Boolean
15314>>>>>        Boolean bAllowed
15314>>>>>        Get CascadeDeleteNull iServer to bAllowed
15315>>>>>        Function_Return bAllowed
15316>>>>>    End_Function
15317>>>>>    
15317>>>>>    // return an array with the server path from this DD to passed top. The top will be
15317>>>>>    // in 0 and its child in 1, grand-child in 2, etc. If empty, no path was found. To start
15317>>>>>    // this process the byref hoDDs array MUST be empty
15317>>>>>    Procedure DDOServerPath Handle hoTop Handle[] ByRef hoDDs
15319>>>>>        Handle hoServer
15319>>>>>        Integer iServers iServer
15319>>>>>        If (hoTop=Self) Begin
15321>>>>>            Move Self to hoDDs[SizeOfArray(hoDDs)]
15322>>>>>            Procedure_Return
15323>>>>>        End
15323>>>>>>
15323>>>>>        Get Data_Set_Server_Count to iServers
15324>>>>>        For iServer from 0 to (iServers-1)
15330>>>>>>
15330>>>>>            Get Data_Set_Server iServer to hoServer
15331>>>>>            Send DDOServerPath of hoServer hoTop (&hoDDs)
15332>>>>>            If (SizeOfArray(hoDDs)) Begin
15334>>>>>                Move Self to hoDDs[SizeOfArray(hoDDs)]
15335>>>>>                Procedure_Return
15336>>>>>            End
15336>>>>>>
15336>>>>>        Loop
15337>>>>>>
15337>>>>>    End_Procedure
15338>>>>>    
15338>>>>>    // returns True if the value passed can be considered empty for this field.
15338>>>>>    Function IsEmptyField Integer iField String sValue Returns Boolean
15340>>>>>        Integer iFile iDataType iValidationType
15340>>>>>        Number nNum
15340>>>>>        Boolean bInvalid bChecked
15340>>>>>        Get Main_File to iFile
15341>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iDataType
15344>>>>>        Get IsDataInvalid iDataType sValue to bInvalid
15345>>>>>        If bInvalid Begin
15347>>>>>            Function_Return True
15348>>>>>        End
15348>>>>>>
15348>>>>>        
15348>>>>>        // DDs set checkbox fields to the False value as default. We must test its select_state
15348>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField to iValidationType
15349>>>>>        If (iValidationType=FA_VALIDATION_TYPE_CHECKBOX) Begin
15351>>>>>            Get Field_Select_State iField to bChecked
15352>>>>>            If not bChecked Begin
15354>>>>>                Function_Return True
15355>>>>>            End
15355>>>>>>
15355>>>>>        End
15355>>>>>>
15355>>>>>        
15355>>>>>        If ((iDataType=DF_BCD or iDataType=DF_DATE) and (Number(sValue)=0)) Begin
15357>>>>>            Move "" to sValue
15358>>>>>        End
15358>>>>>>
15358>>>>>        Else If (iDataType=DF_DATETIME and IsNullDateTime(cast(sValue,DateTime))) Begin
15361>>>>>            Move "" to sValue
15362>>>>>        End
15362>>>>>>
15362>>>>>        Function_Return (sValue="")
15363>>>>>    End_Function
15364>>>>>    
15364>>>>>    
15364>>>>>    // is the record committed
15364>>>>>    Function IsCommitted Returns Boolean
15366>>>>>        Boolean bHasRecord
15366>>>>>        Get HasRecord to bHasRecord
15367>>>>>        Function_Return bHasRecord
15368>>>>>    End_Function
15369>>>>>    
15369>>>>>    // is the field committed. It assumes the record is already committed
15369>>>>>    Function IsFieldCommitted Integer iField Returns Boolean
15371>>>>>        Boolean bIsCommitted
15371>>>>>        Get Field_Option iField DD_COMMIT to bIsCommitted
15372>>>>>        Function_Return bIsCommitted
15373>>>>>    End_Function
15374>>>>>    
15374>>>>>    // is a parent change allowed for this parent server.
15374>>>>>    Function IsCommittedParentChangeAllowed Integer iServer Returns Boolean
15376>>>>>        Boolean bNoSwitch
15376>>>>>        Get ParentNoSwitchIfCommitted iServer to bNoSwitch
15377>>>>>        Function_Return (not(bNoSwitch))
15378>>>>>    End_Function
15379>>>>>    
15379>>>>>    // Are we allowed to find with this file when it is used as a parent?
15379>>>>>    // Check all child DDOs and see if any are committed and do not allow switching parents when committed.
15379>>>>>    //  The rules for each child are switching is ok If:
15379>>>>>    // 1. the child is not committed,
15379>>>>>    // 2. it has a relates-to constraint (Find will change child which is ok)
15379>>>>>    // 3. if IsCommittedParentChangeAllowed allowed.
15379>>>>>    //
15379>>>>>    Function AllowParentFind Returns Boolean
15381>>>>>        Integer iClients iClient iMain
15381>>>>>        Handle hoChild
15381>>>>>        Boolean bIsCommitted
15381>>>>>        Get Data_Set_Client_Count to iClients
15382>>>>>        For iClient from 0 to (iClients-1)
15388>>>>>>
15388>>>>>            Get Data_Set_Client iClient to hoChild
15389>>>>>            Get IsCommitted of hoChild to bIsCommitted
15390>>>>>            If bIsCommitted Begin
15392>>>>>                Get Main_File to iMain
15393>>>>>                Get IsRelatesToConstrained of hoChild iMain to bIsCommitted
15394>>>>>                If not bIsCommitted Begin
15396>>>>>                    Get IsCommittedParentChangeAllowed of hoChild iMain to bIsCommitted
15397>>>>>                    If (not(bIsCommitted)) Begin
15399>>>>>                        Function_Return False
15400>>>>>                    End
15400>>>>>>
15400>>>>>                End
15400>>>>>>
15400>>>>>            End
15400>>>>>>
15400>>>>>        Loop
15401>>>>>>
15401>>>>>        Function_Return True
15402>>>>>    End_Function
15403>>>>>    
15403>>>>>    // aumgented to do nothing if there is no index (instead of annoying error message) and
15403>>>>>    // to do nothing if a find is not allowed because it is a no switch parent of a committed child.
15403>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
15405>>>>>        
15405>>>>>        Integer iIndex iMain
15405>>>>>        Handle  hoOwner
15405>>>>>        Boolean bOk
15405>>>>>        
15405>>>>>        Get File_Field_Index iFile iField to iIndex
15406>>>>>        If (iIndex=-1)  Begin
15408>>>>>            Procedure_Return
15409>>>>>        End
15409>>>>>>
15409>>>>>        Get Main_File to iMain
15410>>>>>        If (iMain<>iFile) Begin
15412>>>>>            Get Which_Data_Set iFile to hoOwner
15413>>>>>            If hoOwner Begin
15415>>>>>                Get AllowParentFind of hoOwner to bOk
15416>>>>>                If not bOk Begin
15418>>>>>                    Procedure_Return
15419>>>>>                End
15419>>>>>>
15419>>>>>            End
15419>>>>>>
15419>>>>>        End
15419>>>>>>
15419>>>>>        
15419>>>>>        If not bDeferred Begin
15421>>>>>            Send Refind_Records // make sure the buffers are correct before the find
15422>>>>>        End
15422>>>>>>
15422>>>>>        
15422>>>>>        Forward Send Item_Find eFindMode iFile iField bDoEntryUpdate bShowFindErr bDeferred
15424>>>>>    End_Procedure
15425>>>>>    
15425>>>>>    
15425>>>>>    Function Field_CommitNoEnterOnIndex Integer iField Returns Boolean
15427>>>>>        Function_Return False
15428>>>>>    End_Function
15429>>>>>    
15429>>>>>    // Return the committed options for this field based on the committed status or this record,
15429>>>>>    // the committed status of the field and whether, if committed, it should be noput or noput+noenter
15429>>>>>    Function File_Field_Committed_Options Integer iFile Integer iField Returns Integer
15431>>>>>        Boolean bIsCommitted bNoEnter
15431>>>>>        Integer iNewOpts iIndex
15431>>>>>        Handle hoOwner
15431>>>>>        
15431>>>>>        Get Which_Data_Set iFile to hoOwner
15432>>>>>        If not hoOwner ;            Function_Return 0
15435>>>>>        
15435>>>>>        Get File_Field_Index iFile iField to iIndex
15436>>>>>        Get IsCommitted of hoOwner to bIsCommitted
15437>>>>>        If bIsCommitted Begin
15439>>>>>            Get IsFieldCommitted of hoOwner iField to bIsCommitted
15440>>>>>            If bIsCommitted Begin
15442>>>>>                Move True to bNoEnter
15443>>>>>                If (iIndex<>-1) Begin
15445>>>>>                    Get Field_CommitNoEnterOnIndex iField to bNoEnter
15446>>>>>                End
15446>>>>>>
15446>>>>>                // if committed, it is noput and, if non-indexed, also noenter
15446>>>>>                Move (If(bNoEnter,DD_DISPLAYONLY,DD_NOPUT)) to iNewOpts
15447>>>>>            End
15447>>>>>>
15447>>>>>        End
15447>>>>>>
15447>>>>>        // if a finding parent field, we want to know if you are allowed to switch parents as we will assume
15447>>>>>        // that this field is used for finding.
15447>>>>>        If (hoOwner<>Self and iIndex>-1) Begin
15449>>>>>            Get AllowParentFind of hoOwner to bIsCommitted
15450>>>>>            If not bIsCommitted Begin
15452>>>>>                Move DD_DISPLAYONLY to iNewOpts
15453>>>>>            End
15453>>>>>>
15453>>>>>        End
15453>>>>>>
15453>>>>>        
15453>>>>>        Function_Return iNewOpts
15454>>>>>    End_Function
15455>>>>>    
15455>>>>>    // Returns the current field-field options based on regular options, foreign field status
15455>>>>>    // plus committed record status
15455>>>>>    Function File_Field_DynamicEntryOptions Integer iFile Integer iField Returns Integer
15457>>>>>        Integer iCOpts iFOpts
15457>>>>>        If (iFile=0) Begin
15459>>>>>            Function_Return 0
15460>>>>>        End
15460>>>>>>
15460>>>>>        Get File_Field_Options iFile iField to iFOpts            // regular options (handles regular and foreign)
15461>>>>>        Get File_Field_Committed_Options iFile iField to iCOpts  // possible NoPut, NoEnter additions
15462>>>>>        Function_Return (iFOpts ior iCOpts)
15463>>>>>    End_Function
15464>>>>>    
15464>>>>>    Function DDRememberedFieldIndex Integer iField Returns Integer
15466>>>>>        tDDRemembered[] DefaultValues
15466>>>>>        tDDRemembered[] DefaultValues
15467>>>>>        tDDRemembered SearchItem
15467>>>>>        tDDRemembered SearchItem
15467>>>>>        Integer iIndex
15467>>>>>        Get pDDDefaults to DefaultValues
15468>>>>>        Move iField to SearchItem.iField
15469>>>>>        Move (SearchArray(SearchItem,DefaultValues)) to iIndex
15470>>>>>        Function_Return iIndex
15471>>>>>    End_Function
15472>>>>>    
15472>>>>>    // Interface used to set or clear a dynamic default (remembered) value for a DD field. If the
15472>>>>>    // value passed is empty ("" or as empty as defined by the data-type) it is cleared. If the value
15472>>>>>    // is DD_RememberLast, it will use the last value before a clear as the default, else it uses the
15472>>>>>    // passed value as the default
15472>>>>>    Procedure Set Field_RememberedValue Integer iField String sValue
15474>>>>>        tDDRemembered[] DefaultValues
15474>>>>>        tDDRemembered[] DefaultValues
15475>>>>>        Integer iIndex
15475>>>>>        Boolean bNull
15475>>>>>        Get DDRememberedFieldIndex iField to iIndex
15476>>>>>        Get pDDDefaults to DefaultValues
15477>>>>>        If (sValue<>DD_RememberLast) Begin // if it is rememberlast, we know it is not null
15479>>>>>            Get IsEmptyField iField sValue to bNull
15480>>>>>        End
15480>>>>>>
15480>>>>>        If (not(bNull)) Begin
15482>>>>>            If (iIndex=-1) Begin
15484>>>>>                Move (SizeOfArray(DefaultValues)) to iIndex
15485>>>>>                Move iField to DefaultValues[iIndex].iField
15486>>>>>            End
15486>>>>>>
15486>>>>>            Move sValue to DefaultValues[iIndex].sDefault
15487>>>>>            Set pDDDefaults to DefaultValues
15488>>>>>        End
15488>>>>>>
15488>>>>>        Else If  (iIndex<>-1) Begin
15491>>>>>            Set pDDDefaults to (RemoveFromArray(DefaultValues,iIndex))
15492>>>>>        End
15492>>>>>>
15492>>>>>    End_Procedure
15493>>>>>    
15493>>>>>    // get the remembered value as per rules above
15493>>>>>    Function Field_RememberedValue Integer iField Returns String
15495>>>>>        tDDRemembered[] DefaultValues
15495>>>>>        tDDRemembered[] DefaultValues
15496>>>>>        Integer iIndex
15496>>>>>        Get DDRememberedFieldIndex iField to iIndex
15497>>>>>        If (iIndex<>-1) Begin
15499>>>>>            Get pDDDefaults to DefaultValues
15500>>>>>            Function_Return DefaultValues[iIndex].sDefault
15501>>>>>        End
15501>>>>>>
15501>>>>>        Function_Return ''
15502>>>>>    End_Function
15503>>>>>    
15503>>>>>    Procedure AssignDynamicDefaults
15505>>>>>        Integer iField iFields iFile
15505>>>>>        tDDRemembered[] DefaultValues
15505>>>>>        tDDRemembered[] DefaultValues
15506>>>>>        Boolean bMain
15506>>>>>        String sValue
15506>>>>>        
15506>>>>>        Get Main_File to iFile
15507>>>>>        Get pDDDefaults to DefaultValues
15508>>>>>        Move (SizeOfArray(DefaultValues)) to iFields
15509>>>>>        For iField from 0 to (iFields-1)
15515>>>>>>
15515>>>>>            If ( DefaultValues[iField].sDefault<>"") Begin
15517>>>>>                If (DefaultValues[iField].sDefault=DD_RememberLast) Begin
15519>>>>>                    Move DefaultValues[iField].sLastValue to sValue
15520>>>>>                End
15520>>>>>>
15520>>>>>                Else Begin
15521>>>>>                    Move DefaultValues[iField].sDefault to sValue
15522>>>>>                End
15522>>>>>>
15522>>>>>                Set Field_Changed_Value DefaultValues[iField].iField to sValue
15523>>>>>            End
15523>>>>>>
15523>>>>>        Loop
15524>>>>>>
15524>>>>>    End_Procedure
15525>>>>>    
15525>>>>>    // Clears all remembered defaults for this DD.
15525>>>>>    Procedure ClearRememberedDefaults
15527>>>>>        tDDRemembered[] DefaultValues
15527>>>>>        tDDRemembered[] DefaultValues
15528>>>>>        Set pDDDefaults to DefaultValues
15529>>>>>    End_Procedure
15530>>>>>    
15530>>>>>    Procedure PrivateClearAllRememberedDefaults
15532>>>>>        Integer iCount iMax
15532>>>>>        Handle hoDD
15532>>>>>        Boolean bVisisted
15532>>>>>        
15532>>>>>        Set Visited_State to True
15533>>>>>        
15533>>>>>        Get Data_Set_Server_Count to iMax
15534>>>>>        Decrement iMax
15535>>>>>        For iCount from 0 to iMax
15541>>>>>>
15541>>>>>            Get Data_Set_Server iCount to hoDD
15542>>>>>            Get Visited_State of hoDD to bVisisted
15543>>>>>            If not (bVisisted) Begin
15545>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
15546>>>>>            End
15546>>>>>>
15546>>>>>        Loop
15547>>>>>>
15547>>>>>        
15547>>>>>        Send ClearRememberedDefaults
15548>>>>>        
15548>>>>>        Get Data_Set_Client_Count to iMax
15549>>>>>        Decrement iMax
15550>>>>>        For iCount from 0 to iMax
15556>>>>>>
15556>>>>>            Get Data_Set_Client iCount to hoDD
15557>>>>>            Get Visited_State of hoDD to bVisisted
15558>>>>>            If not (bVisisted) Begin
15560>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
15561>>>>>            End
15561>>>>>>
15561>>>>>        Loop
15562>>>>>>
15562>>>>>        
15562>>>>>    End_Procedure
15563>>>>>    
15563>>>>>    // Clears all remembered defaults for all DDs in this structure.
15563>>>>>    Procedure ClearAllRememberedDefaults
15565>>>>>        Send InitializeAllVisited
15566>>>>>        Send PrivateClearAllRememberedDefaults
15567>>>>>    End_Procedure
15568>>>>>    
15568>>>>>    // This is called after a clear or clear all is sent to this DD. It does autofinds as needed
15568>>>>>    // for any parent DDs. It does this if the parent is not a relates to contraining parent, if
15568>>>>>    // a field has an index, it has a changed value and it is autofind or autofind_ge.
15568>>>>>    Procedure DefaultParentAutofinds
15570>>>>>        Integer i iServers iField iFields iFile iIndex iOpts
15570>>>>>        Boolean bDoAutoFind bRelates bIsEmptyField
15570>>>>>        String sValue
15570>>>>>        Handle hoServer
15570>>>>>        Get Data_Set_Server_Count to iServers
15571>>>>>        For i from 0 to (iServers-1)
15577>>>>>>
15577>>>>>            Get Data_Set_Server i to hoServer
15578>>>>>            Get Main_File of hoServer to iFile
15579>>>>>            Get IsRelatesToConstrained iFile to bRelates
15580>>>>>            // never autofind on a relates-to constraining parent
15580>>>>>            If not (bRelates) Begin
15582>>>>>                
15582>>>>>                Get Field_Count of hoServer to iFields
15583>>>>>                Move False to bDoAutoFind
15584>>>>>                Move 1 to iField
15585>>>>>                While (not(bDoAutoFind) and (iField<=iFields))
15589>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
15592>>>>>                    If (iIndex>0) Begin
15594>>>>>                        Get Field_Changed_State of hoServer iField to bDoAutoFind
15595>>>>>                        If bDoAutoFind Begin
15597>>>>>                            Get Field_Current_Value of hoServer iField to sValue
15598>>>>>                            Get IsEmptyField of hoServer iField sValue to bIsEmptyField
15599>>>>>                            Move (not(bIsEmptyField)) to bDoAutoFind
15600>>>>>                            If bDoAutoFind Begin
15602>>>>>                                Get File_Field_Options iFile iField to iOpts
15603>>>>>                                // if this is a retain or retainall we don't do this because we want
15603>>>>>                                // to maintain backwards compatibility
15603>>>>>                                Move ( (iOpts iand DD_AUTOFIND or iOpts iand DD_AUTOFIND_GE) and ;                                    not( iOpts iand DD_RETAIN or iOpts iand DD_RETAINALL) ) to bDoAutoFind
15604>>>>>                                If bDoAutoFind Begin
15606>>>>>                                    Send File_Field_Default_AutoFind iFile iField
15607>>>>>                                    Set Changed_State to False // clears parent changed state
15608>>>>>                                End
15608>>>>>>
15608>>>>>                            End
15608>>>>>>
15608>>>>>                        End
15608>>>>>>
15608>>>>>                    End
15608>>>>>>
15608>>>>>                    Increment iField
15609>>>>>                Loop
15610>>>>>>
15610>>>>>                
15610>>>>>                // Only check for grandparent autofinds if this parent did not do a an autofind
15610>>>>>                // Doing an autofind on an autofind parent's parent is just too confusing
15610>>>>>                If not bDoAutoFind Begin
15612>>>>>                    Send DefaultParentAutofinds of hoServer
15613>>>>>                End
15613>>>>>>
15613>>>>>            End
15613>>>>>>
15613>>>>>        Loop
15614>>>>>>
15614>>>>>    End_Procedure
15615>>>>>    
15615>>>>>    // Set this DD to be an alias, passing the file number of the alias
15615>>>>>    // This can only be called once per instance and the Main_File must already have been set
15615>>>>>    // most likely in a superclass.
15615>>>>>    // This sets Main_File to the alias, stores the original master file (accessed via MasterForAlias).
15615>>>>>    // It also clears all existing relatonships. Normally we expect the alias class to set
15615>>>>>    // sets pbUseDDRelates and pbNoCascadeDeleteStrict to true. We don't do that automatically so that
15615>>>>>    // the Studio's property panel will show the correct values. When an alias is defined using the
15615>>>>>    // studio it will set these two properties.
15615>>>>>    // This means you must set any required relationships yourself
15615>>>>>    Procedure Set Alias_File Integer iTable
15617>>>>>        Integer iMain iMaster iFieldsM iFieldsA
15617>>>>>        Get Main_File to iMain
15618>>>>>        Get MasterForAlias to iMaster
15619>>>>>        
15619>>>>>        If (iTable=0 and iMaster) Begin
15621>>>>>            Error DFERR_PROGRAM "Cannot unset alias table"
15622>>>>>>
15622>>>>>            Procedure_Return
15623>>>>>        End
15623>>>>>>
15623>>>>>        If (iTable=iMain) Begin
15625>>>>>            Error DFERR_PROGRAM "Cannot set alias table to self"
15626>>>>>>
15626>>>>>            Procedure_Return
15627>>>>>        End
15627>>>>>>
15627>>>>>        If (iMaster) Begin
15629>>>>>            Error DFERR_PROGRAM "Cannot redefine alias table"
15630>>>>>>
15630>>>>>            Procedure_Return
15631>>>>>        End
15631>>>>>>
15631>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iMain to iFieldsM
15634>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iFieldsA
15637>>>>>        If (iFieldsA<>iFieldsM) Begin
15639>>>>>            Error DFERR_PROGRAM "Alias and Master file are not based on the same table"
15640>>>>>>
15640>>>>>            Procedure_Return
15641>>>>>        End
15641>>>>>>
15641>>>>>        
15641>>>>>        Set piMasterTable to iMain
15642>>>>>        Set Main_File to iTable
15643>>>>>        Send DefineAsAlias
15644>>>>>    End_Procedure
15645>>>>>    
15645>>>>>    Procedure DefineAsAlias
15647>>>>>        Integer i iFile
15647>>>>>        
15647>>>>>        // We expect he developer to set these properties to True
15647>>>>>        //Set pbUseDDRelates to True
15647>>>>>        //Set pbNoCascadeDeleteStrict to True
15647>>>>>        
15647>>>>>        Send ClearDDRelates
15648>>>>>        Get Client_File_Count to i
15649>>>>>        While i
15653>>>>>            Decrement i
15654>>>>>            Get Client_File i to iFile
15655>>>>>            Send Remove_Client_File iFile
15656>>>>>        Loop
15657>>>>>>
15657>>>>>        Get Server_File_Count to i
15658>>>>>        While i
15662>>>>>            Decrement i
15663>>>>>            Get Server_File i to iFile
15664>>>>>            Send Remove_Server_File iFile
15665>>>>>        Loop
15666>>>>>>
15666>>>>>    End_Procedure
15667>>>>>    
15667>>>>>    Function MasterForAlias Returns Integer
15669>>>>>        Integer iMaster
15669>>>>>        Get piMasterTable to iMaster
15670>>>>>        Function_Return iMaster
15671>>>>>    End_Function
15672>>>>>    
15672>>>>>    Function IsAlias Returns Boolean
15674>>>>>        Integer iMaster
15674>>>>>        Get piMasterTable to iMaster
15675>>>>>        Function_Return (iMaster<>0)
15676>>>>>    End_Function
15677>>>>>    
15677>>>>>    
15677>>>>>    Procedure OnSaveRecord
15679>>>>>    End_Procedure
15680>>>>>    
15680>>>>>    Procedure StoreDefaultSQLFilters
15682>>>>>        Handle hoSQLHelper
15682>>>>>        Get phoSQLHelper to hoSQLHelper
15683>>>>>        Send StoreDefaultSQLFilters of hoSQLHelper
15684>>>>>    End_Procedure
15685>>>>>    
15685>>>>>    Procedure RestoreDefaultSQLFilters
15687>>>>>        Handle hoSQLHelper
15687>>>>>        Get phoSQLHelper to hoSQLHelper
15688>>>>>        Send RestoreDefaultSQLFilters of hoSQLHelper
15689>>>>>    End_Procedure
15690>>>>>    
15690>>>>>    Procedure ApplySQLFilterStr String sFilter
15692>>>>>        Handle hoSQLHelper
15692>>>>>        Get phoSQLHelper to hoSQLHelper
15693>>>>>        Send ApplySQLFilterStr of hoSQLHelper sFilter
15694>>>>>    End_Procedure
15695>>>>>    
15695>>>>>    
15695>>>>>    Procedure ApplySQLFilter
15697>>>>>        String sNewFilter sOldFilter
15697>>>>>        Boolean bApplyGlobalSQLFilters bOldFilterActive
15697>>>>>        Handle hoSQLHelper
15697>>>>>        Get phoSQLHelper to hoSQLHelper
15698>>>>>        Get psSQLFilter to sNewFilter
15699>>>>>        // if we have am active  table filter we can either ignore it or and it to the where clause
15699>>>>>        // pbApplyGlobalSQLFilters determines what to do.
15699>>>>>        Get pbApplyGlobalSQLFilters to bApplyGlobalSQLFilters
15700>>>>>        Get pbOldFilterActive to bOldFilterActive
15701>>>>>        If (bApplyGlobalSQLFilters and bOldFilterActive) Begin
15703>>>>>            Get psOldFilter to sOldFilter
15704>>>>>            Get SQLStrAppend sOldFilter sNewFilter to sNewFilter
15705>>>>>        End
15705>>>>>>
15705>>>>>        Send ApplySQLFilterStr of hoSQLHelper sNewFilter
15706>>>>>    End_Procedure
15707>>>>>    
15707>>>>>    Procedure Data_Set_PreFind
15709>>>>>        Boolean bUseDDSQLFilters
15709>>>>>        String sOldDDFilter
15709>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
15710>>>>>        If bUseDDSQLFilters Begin
15712>>>>>            
15712>>>>>            Send StoreDefaultSQLFilters
15713>>>>>            
15713>>>>>            // this can get called during cascade deletes. In such a case we will
15713>>>>>            // never explicitly not apply an SQL filters because it could violate relational integrity
15713>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
15715>>>>>                Get psSQLFilter to sOldDDFilter
15716>>>>>                Set psSQLFilter to "" // make sure there is no filter applied
15717>>>>>            End
15717>>>>>>
15717>>>>>            
15717>>>>>            Send ApplySQLFilter
15718>>>>>            
15718>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
15720>>>>>                Set psSQLFilter to sOldDDFilter
15721>>>>>            End
15721>>>>>>
15721>>>>>        End
15721>>>>>>
15721>>>>>    End_Procedure
15722>>>>>    
15722>>>>>    Procedure Data_Set_PostFind
15724>>>>>        Boolean bUseDDSQLFilters
15724>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
15725>>>>>        If bUseDDSQLFilters Begin
15727>>>>>            Send RestoreDefaultSQLFilters
15728>>>>>        End
15728>>>>>>
15728>>>>>    End_Procedure
15729>>>>>    
15729>>>>>    
15729>>>>>    // returns active constraints in atConstraintDef array.
15729>>>>>    // Should be called after constraints are built
15729>>>>>    // typically right after Rebuild_Constraints
15729>>>>>    
15729>>>>>    Function DDOConstraints Returns tConstraintDef[]
15731>>>>>        tConstraintDef[] Constraints
15731>>>>>        tConstraintDef[] Constraints
15732>>>>>        Integer i iCount i1
15732>>>>>        Get DATA_SET_CONSTRAINT_COUNT to iCount
15733>>>>>        For i from 0 to (iCount-1)
15739>>>>>>
15739>>>>>            Get DATA_SET_CONSTRAINT_INFO i 0 to i1 // type / mode
15740>>>>>            Move (Hi(i1)) to  Constraints[i].eType
15741>>>>>            Move (Low(i1)) to  Constraints[i].eMode
15742>>>>>            Get DATA_SET_CONSTRAINT_INFO i 1 to i1 // file / field
15743>>>>>            Move (Hi(i1)) to  Constraints[i].iFile
15744>>>>>            Move (Low(i1)) to  Constraints[i].iField
15745>>>>>            Get DATA_SET_CONSTRAINT_INFO i 2 to i1 // other file /field
15746>>>>>            Move (Hi(i1)) to  Constraints[i].iOtherFile
15747>>>>>            Move (Low(i1)) to  Constraints[i].iOtherField
15748>>>>>            Get DATA_SET_CONSTRAINT_INFO_Value i  to Constraints[i].sValue
15749>>>>>        Loop
15750>>>>>>
15750>>>>>        Function_Return Constraints
15751>>>>>    End_Function
15752>>>>>    
15752>>>>>    // returns constraint finding information about the current find. This tells us what kinds
15752>>>>>    // of constraint find "expressions" are used. This will actually do a cosntrained find
15752>>>>>    // initialization much like Establish_Find_Direction, which means it can change the values in
15752>>>>>    // the file buffer to assist with a jump-in.
15752>>>>>    Function DDOConstraintFindMeta Integer eMode Integer iOrder Returns tDDOConstraintFindMeta
15754>>>>>        tDDOConstraintFindMeta FindMeta
15754>>>>>        tDDOConstraintFindMeta FindMeta
15754>>>>>        Integer i
15754>>>>>        Get Data_Set_Constraint_Exps eMode iOrder to i
15755>>>>>        Move (Hi(i)) to FindMeta.iJumpInSegments
15756>>>>>        Move (i iand CONST_EXP_JUMPOUT) to FindMeta.bJumpOut
15757>>>>>        Move (i iand CONST_EXP_PRE_RELATE) to FindMeta.bPreRelate
15758>>>>>        Move (i iand CONST_EXP_POST_RELATE) to FindMeta.bPostRelate
15759>>>>>        Function_Return FindMeta
15760>>>>>    End_Function
15761>>>>>    
15761>>>>>    // this tells you if the current find or read requires a relate to evaluate the DF constraint.
15761>>>>>    // If false you could use this to set no_relate_state to false for the find/read process and then
15761>>>>>    // restore it when complete. Be careful using this.
15761>>>>>    Function DDOConstraintNeedsRelate Integer iOrder Returns Boolean
15763>>>>>        tDDOConstraintFindMeta FindMeta
15763>>>>>        tDDOConstraintFindMeta FindMeta
15763>>>>>        Get DDOConstraintFindMeta (GE) iOrder to FindMeta
15764>>>>>        Function_Return FindMeta.bPostRelate
15765>>>>>    End_Function
15766>>>>>    
15766>>>>>    // returns true if this table supports SQL filter interface
15766>>>>>    Function SupportsSQLFilters Returns Boolean
15768>>>>>        Boolean bSupports
15768>>>>>        Handle hoSQLHelper
15768>>>>>        Get phoSQLHelper to hoSQLHelper
15769>>>>>        Get SupportsSQLFilters of hoSQLHelper to bSupports
15770>>>>>        Function_Return bSupports
15771>>>>>    End_Function
15772>>>>>    
15772>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
15772>>>>>    
15772>>>>>    // Creates an SQL Like Filter for this field and search target
15772>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
15774>>>>>        String sFilter
15774>>>>>        Handle hoSQLHelper
15774>>>>>        Get phoSQLHelper to hoSQLHelper
15775>>>>>        Get SQLStrLike of hoSQLHelper iField sSearch to sFilter
15776>>>>>        Function_Return sFilter
15777>>>>>    End_Function
15778>>>>>    
15778>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15778>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
15780>>>>>        Handle hoSQLHelper
15780>>>>>        Get phoSQLHelper to hoSQLHelper
15781>>>>>        Get SQLStrAppend of hoSQLHelper sOrigFilter sFilter to sFilter
15782>>>>>        Function_Return sFilter
15783>>>>>    End_Function
15784>>>>>    
15784>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15784>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
15786>>>>>        Handle hoSQLHelper
15786>>>>>        Get phoSQLHelper to hoSQLHelper
15787>>>>>        Get SQLStrAppendOr of hoSQLHelper sOrigFilter sFilter to sFilter
15788>>>>>        Function_Return sFilter
15789>>>>>    End_Function
15790>>>>>
15790>>>>>    // returns the name of the File and Field suitable for an SQL where statement
15790>>>>>    Function SQLStrFileFieldName Integer iField Returns String
15792>>>>>        String sName
15792>>>>>        Handle hoSQLHelper
15792>>>>>        Get phoSQLHelper to hoSQLHelper
15793>>>>>        Get SQLStrFileFieldName of hoSQLHelper iField to sName
15794>>>>>        Function_Return sName
15795>>>>>    End_Function
15796>>>>>
15796>>>>>    // returns the name of the Field suitable for an SQL where statement
15796>>>>>    Function SQLStrFieldName Integer iField Returns String
15798>>>>>        String sName
15798>>>>>        Handle hoSQLHelper
15798>>>>>        Get phoSQLHelper to hoSQLHelper
15799>>>>>        Get SQLStrFieldName of hoSQLHelper iField to sName
15800>>>>>        Function_Return sName
15801>>>>>    End_Function
15802>>>>>
15802>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement
15802>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
15804>>>>>        String sName
15804>>>>>        Handle hoSQLHelper
15804>>>>>        Get phoSQLHelper to hoSQLHelper
15805>>>>>        Get SQLStrSchemaFileFieldName of hoSQLHelper iField to sName
15806>>>>>        Function_Return sName
15807>>>>>    End_Function
15808>>>>>    
15808>>>>>    //  returns the name of a file suitable for a SQL statement
15808>>>>>    Function SQLStrFileName Integer iField Returns String
15810>>>>>        String sName
15810>>>>>        Handle hoSQLHelper
15810>>>>>        Get phoSQLHelper to hoSQLHelper
15811>>>>>        Get SQLStrFileName of hoSQLHelper iField to sName
15812>>>>>        Function_Return sName
15813>>>>>    End_Function
15814>>>>>    
15814>>>>>    // creates escaped SQL string by replacing single quote with two single quotes
15814>>>>>    Function SQLEscapedStr String sSQL Returns String
15816>>>>>        Handle hoSQLHelper
15816>>>>>        Get phoSQLHelper to hoSQLHelper
15817>>>>>        Get SQLEscapedStr of hoSQLHelper sSQL to sSQL
15818>>>>>        Function_Return sSQL
15819>>>>>    End_Function
15820>>>>>    
15820>>>>>    // Returns:
15820>>>>>    //       The record id string based on piPrimaryIndex.
15820>>>>>    Function PrimaryRecordId Returns String
15822>>>>>        Integer iIndex iFile iSegments iSegment iField
15822>>>>>        String sVal sId
15822>>>>>        
15822>>>>>        Get Main_File to iFile
15823>>>>>        Get piPrimaryIndex to iIndex
15824>>>>>        
15824>>>>>        If (iIndex < 0) Begin
15826>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
15829>>>>>        End
15829>>>>>>
15829>>>>>        
15829>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
15832>>>>>        For iSegment from 1 to iSegments
15838>>>>>>
15838>>>>>            Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
15841>>>>>            
15841>>>>>            Get_Field_Value iFile iField to sVal
15844>>>>>            Move (Trim(sVal)) to sVal
15845>>>>>            
15845>>>>>            //  Encode join sign for multi segment indexes
15845>>>>>            If (iSegments > 1) Begin
15847>>>>>                Move (Replaces("_", sVal, "~5F~")) to sVal
15848>>>>>            End
15848>>>>>>
15848>>>>>            
15848>>>>>            If (iSegment = 1) Begin
15850>>>>>                Move sVal to sId
15851>>>>>            End
15851>>>>>>
15851>>>>>            Else Begin
15852>>>>>                Move (sId + "_" + sVal) to sId
15853>>>>>            End
15853>>>>>>
15853>>>>>            
15853>>>>>        Loop
15854>>>>>>
15854>>>>>        
15854>>>>>        Function_Return sId
15855>>>>>    End_Function
15856>>>>>    
15856>>>>>    
15856>>>>>    // Finds a record on the global buffer based on the record id.
15856>>>>>    //
15856>>>>>    // Params:
15856>>>>>    //       sRecordId   Record id generated by PrimaryRecordId.
15856>>>>>    Function FindByPrimaryRecordId String sRecordId Returns Boolean
15858>>>>>        Integer iIndex iFile iSegments iSegment iField
15858>>>>>        String[] aValues
15859>>>>>        String sVal
15859>>>>>        Boolean bTrapped
15859>>>>>        
15859>>>>>        Get Main_File to iFile
15860>>>>>        Get piPrimaryIndex to iIndex
15861>>>>>        
15861>>>>>        If (iIndex < 0) Begin
15863>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
15866>>>>>        End
15866>>>>>>
15866>>>>>        
15866>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
15869>>>>>        
15869>>>>>        If (iSegments > 1) Begin
15871>>>>>            Move (StrSplitToArray(sRecordId, "_")) to aValues
15872>>>>>        End
15872>>>>>>
15872>>>>>        Else Begin
15873>>>>>            Move sRecordId to aValues[0]
15874>>>>>        End
15874>>>>>>
15874>>>>>        
15874>>>>>        If (iSegments = SizeOfArray(aValues)) Begin
15876>>>>>            Clear iFile
15877>>>>>            
15877>>>>>            Send Ignore_Error of Error_Object_Id 56
15878>>>>>            Send Ignore_Error of Error_Object_Id 11
15879>>>>>            
15879>>>>>            For iSegment from 1 to iSegments
15885>>>>>>
15885>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
15888>>>>>                
15888>>>>>                Move aValues[iSegment - 1] to sVal
15889>>>>>                If (iSegments > 1) Begin
15891>>>>>                    Move (Replaces("~5F~", sVal, "_")) to sVal
15892>>>>>                End
15892>>>>>>
15892>>>>>                
15892>>>>>                Set_Field_Value iFile iField to sVal
15895>>>>>            Loop
15896>>>>>>
15896>>>>>            Send Trap_Error of Error_Object_Id 56
15897>>>>>            Send Trap_Error of Error_Object_Id 11
15898>>>>>            
15898>>>>>            Vfind iFile iIndex EQ
15900>>>>>            
15900>>>>>            Function_Return (Found)
15901>>>>>        End
15901>>>>>>
15901>>>>>        
15901>>>>>        Function_Return False
15902>>>>>    End_Function
15903>>>>>    
15903>>>>>    // Converts a RecordId to a RowId by finding it on the global buffer.
15903>>>>>    //
15903>>>>>    // Params:
15903>>>>>    //       sRecordId   Record id based on piPrimaryIndex.
15903>>>>>    //       rRowId      (ByRef) Will be filled with the rowid.
15903>>>>>    // Returns:
15903>>>>>    //       True if the record id was valid.
15903>>>>>    Function RecordIdToRowId String sRecordId RowID ByRef rRowId Returns Boolean
15905>>>>>        Boolean bFound
15905>>>>>        
15905>>>>>        Get FindByPrimaryRecordId sRecordId to bFound
15906>>>>>        If (bFound) Begin
15908>>>>>            Move (GetRowID(Main_File(Self))) to rRowId
15909>>>>>        End
15909>>>>>>
15909>>>>>        Else Begin
15910>>>>>            Move (NullRowID()) to rRowId
15911>>>>>        End
15911>>>>>>
15911>>>>>        
15911>>>>>        Function_Return bFound
15912>>>>>    End_Function
15913>>>>>    
15913>>>>>    // Converts a RowId into a record ID. Note that it performs a find on the global buffer.
15913>>>>>    //
15913>>>>>    // Params:
15913>>>>>    //       riRowId     RowID.
15913>>>>>    // Returns:
15913>>>>>    //       Record id based on piPrimaryIndex.
15913>>>>>    Function RowIdToRecordId RowID riRowId Returns String
15915>>>>>        Boolean bFound
15915>>>>>        String sRecId
15915>>>>>        
15915>>>>>        If (not(IsNullRowID(riRowId))) Begin
15917>>>>>            Move (FindByRowID(Main_File(Self), riRowId)) to bFound
15918>>>>>            
15918>>>>>            If (bFound) Begin
15920>>>>>                Get PrimaryRecordId to sRecId
15921>>>>>            End
15921>>>>>>
15921>>>>>        End
15921>>>>>>
15921>>>>>        
15921>>>>>        Function_Return sRecId
15922>>>>>    End_Function
15923>>>>>End_Class
15924>>>>>
15924>>>>>// This message will be send as a notification message from an
15924>>>>>// Extended_Data_Set whenever a fieldvalue has been changed.
15924>>>>>// It has been defined FOR cUIObject or Desktop  here so that attached
15924>>>>>// DEO which do not know anything about Extended_Data_Sets don't get
15924>>>>>// frustrated.
15924>>>>>// All focusable objects and DEOs must understand this. This should be
15924>>>>>// changed at some point in the future.
15924>>>>>Function Extended_DEO_State for cUIObject Returns Integer
15926>>>>>End_Function
15927>>>>>
15927>>>>>
15927>>>>>// this command is now obsolete. use Set Field_auto_increment
15927>>>>>
15927>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
15927>>>>>// *** The Database Update Framework Include file for Languages ***
15927>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
15927>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
15927>>>>>//
15927>>>>>Use LanguageText.Pkg
15927>>>>>
15927>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
15927>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
15927>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
15927>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
15927>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
15927>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
15927>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
15927>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
15927>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
15927>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
15927>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
15927>>>>>    Define CS_DUF_CopyingData               for "Copying data"
15927>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
15927>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
15927>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
15927>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
15927>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
15927>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
15927>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
15927>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
15927>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
15927>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
15927>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
15927>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
15927>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
15927>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
15927>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
15927>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
15927>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
15927>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
15927>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
15927>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
15927>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
15927>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
15927>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
15927>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
15927>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>>>
15927>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
15927>>>>>// StatPnl.pkg - creates the standard status_panel object.
15927>>>>>//
15927>>>>>//
15927>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
15927>>>>>// invoke the standard status panel. The standard has always been that the package name
15927>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
15927>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
15927>>>>>// prior revisions has been replace with status panel that is part of the application.
15927>>>>>// This should work much better and faster than the old sentinel based solution.
15927>>>>>// While the way this operates has changed, the interface has not and therefore this should work
15927>>>>>// with most applications.
15927>>>>>//
15927>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
15927>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
15927>>>>>// a cleaner more robust interface.
15927>>>>>//
15927>>>>>//
15927>>>>>// Compatibility Note:
15927>>>>>//
15927>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
15927>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
15927>>>>>//
15927>>>>>// If for some reason you application will not work using this as a replacement for the old status
15927>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
15927>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
15927>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
15927>>>>>//
15927>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
15927>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
15927>>>>>//
15927>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
15927>>>>>// can still access the new object via the ghoStatusPanel handle.
15927>>>>>//
15927>>>>>//
15927>>>>>// Creating your own Status Panel objects
15927>>>>>//
15927>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
15927>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
15927>>>>>// with a different file and object name and direct your status panel request to the new object.
15927>>>>>//
15927>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
15927>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
15927>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
15927>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
15927>>>>>// e.g.
15927>>>>>//       Procedure UpdateStatusBar
15927>>>>>//           Send DoAdvance of oProgressBar
15927>>>>>//           Send ProcessEvents
15927>>>>>//       End_Procedure
15927>>>>>//
15927>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
15927>>>>>// messages this will be done for you.
15927>>>>>//
15927>>>>>// the standard Interface for status panels are:
15927>>>>>//
15927>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
15927>>>>>// Send Start_StatusPanel      - start the status panel
15927>>>>>// Send Stop_StatusPanel       - stop the status panel
15927>>>>>// Send Update_StatusPanel     - update the status panel's action area
15927>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
15927>>>>>//
15927>>>>>// Get/Set Caption_Text - updates the caption bar
15927>>>>>// Get/Set Title_Text   - updates the title area
15927>>>>>// Get/Set Message_Text - updates the Message area
15927>>>>>// Get/Set Action_Text  - updates the action area
15927>>>>>// Get/Set Button_Text  - updates the button area
15927>>>>>//
15927>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
15927>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
15927>>>>>//
15927>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
15927>>>>>Use cProcessStatusPanel.pkg
Including file: cProcessStatusPanel.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cProcessStatusPanel.pkg)
15927>>>>>>>// cProcessStatusPanel.pkg
15927>>>>>>>//
15927>>>>>>>// Class used to create StatusPanels.
15927>>>>>>>//
15927>>>>>>>// This class does not provide any of the inner objects that make up a status panel. Instead an
15927>>>>>>>// interface is provided that is used to update the various areas of status panel. At this level,
15927>>>>>>>// those areas (title area, message area, action area, button area) are logical. You create the
15927>>>>>>>// physical objects at the object level and then bind these objects to the interface.
15927>>>>>>>// Take a look at StatPnl.pkg to see how this is used.
15927>>>>>>>//
15927>>>>>>>// the standard Interface for status panels are:
15927>>>>>>>//
15927>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
15927>>>>>>>// Send Start_StatusPanel      - start the status panel
15927>>>>>>>// Send Stop_StatusPanel       - stop the status panel
15927>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
15927>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
15927>>>>>>>//
15927>>>>>>>// Get/Set Caption_Text - updates the caption bar
15927>>>>>>>// Get/Set Title_Text   - updates the title area
15927>>>>>>>// Get/Set Message_Text - updates the Message area
15927>>>>>>>// Get/Set Action_Text  - updates the action area
15927>>>>>>>// Get/Set Button_Text  - updates the button area
15927>>>>>>>//
15927>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
15927>>>>>>>// Send EnableCancelButton - code must be provided in the cancel button object to enable/disable cancel button
15927>>>>>>>//
15927>>>>>>>
15927>>>>>>>Use cStatusPanel.pkg
Including file: cStatusPanel.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cStatusPanel.pkg)
15927>>>>>>>>>// This is an abstract class that can be used to create status panels. The interface at this level
15927>>>>>>>>>// is very simple. You can start, stop, request a cancel and allow the object to paint.
15927>>>>>>>>>//
15927>>>>>>>>>// Look at cProcessStatusPanel.pkg to see how this is used.
15927>>>>>>>>>
15927>>>>>>>>>Use Windows.pkg
15927>>>>>>>>>
15927>>>>>>>>>
15927>>>>>>>>>
15927>>>>>>>>>
15927>>>>>>>>>Class cStatusPanel is a FloatingPanel
15928>>>>>>>>>    
15928>>>>>>>>>    Procedure Construct_Object
15930>>>>>>>>>        Forward Send Construct_object
15932>>>>>>>>>        
15932>>>>>>>>>        Property Boolean pbCancel False
15933>>>>>>>>>        
15933>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True // kills sysmenu as long as there is no icon
15934>>>>>>>>>        Set Icon to '' // this must be cleared so there will be no icon
15935>>>>>>>>>        Set locate_mode to CENTER_ON_PANEL
15936>>>>>>>>>        Set Border_Style  to Border_Dialog
15937>>>>>>>>>        // should be scoped so it will not try to change the focus if there is no focusable button inside
15937>>>>>>>>>        Set Scope_State to True
15938>>>>>>>>>        
15938>>>>>>>>>        On_Key KEXIT_APPLICATION Send Close_Panel
15939>>>>>>>>>    End_Procedure
15940>>>>>>>>>    
15940>>>>>>>>>    // this is private and required. Never send this.
15940>>>>>>>>>    Procedure Deactivate_Group
15942>>>>>>>>>        If (Active_State(Self)) Begin
15944>>>>>>>>>            Send SuspendGUI of Desktop False
15945>>>>>>>>>        End
15945>>>>>>>>>>
15945>>>>>>>>>        Forward Send Deactivate_Group
15947>>>>>>>>>    End_Procedure
15948>>>>>>>>>    
15948>>>>>>>>>    // Send this message to stop the panel
15948>>>>>>>>>    Procedure Deactivate
15950>>>>>>>>>        If (Active_State(Self)) Begin
15952>>>>>>>>>            Send SuspendGUI of Desktop False
15953>>>>>>>>>        End
15953>>>>>>>>>>
15953>>>>>>>>>        Forward Send Deactivate
15955>>>>>>>>>    End_Procedure
15956>>>>>>>>>    
15956>>>>>>>>>    // Send this message to start the panel
15956>>>>>>>>>    Procedure Activate
15958>>>>>>>>>        If not (Active_State(Self)) Begin
15960>>>>>>>>>            Set pbCancel to False
15961>>>>>>>>>            Send SuspendGUI of Desktop True
15962>>>>>>>>>        End
15962>>>>>>>>>>
15962>>>>>>>>>        Forward Send Activate
15964>>>>>>>>>    End_Procedure
15965>>>>>>>>>    
15965>>>>>>>>>    // This allows the panel to paint when used in a tight loop, which is what status panels are
15965>>>>>>>>>    // used for. Any time you update the panel or wish to check for a cancel, you should call this.
15965>>>>>>>>>    Procedure ProcessEvents
15967>>>>>>>>>        If (Active_State(Self)) Begin
15969>>>>>>>>>            Send PumpMsgQueue of Desktop
15970>>>>>>>>>        End
15970>>>>>>>>>>
15970>>>>>>>>>    End_Procedure
15971>>>>>>>>>    
15971>>>>>>>>>    // note close panel does not actually close the panel. It just sets pbCancel to True, informing the
15971>>>>>>>>>    // process using this that it wants to close. It is then up the process close the panel.
15971>>>>>>>>>    Procedure Close_Panel
15973>>>>>>>>>        Set pbCancel to True
15974>>>>>>>>>    End_Procedure
15975>>>>>>>>>    
15975>>>>>>>>>End_Class
15976>>>>>>>
15976>>>>>>>
15976>>>>>>>
15976>>>>>>>Class cProcessStatusPanel is a cStatusPanel
15977>>>>>>>    
15977>>>>>>>    Procedure Construct_Object
15979>>>>>>>        Forward Send Construct_object
15981>>>>>>>        // determines if panel can be canceled
15981>>>>>>>        Property Boolean Allow_Cancel_State True
15982>>>>>>>    End_Procedure
15983>>>>>>>    
15983>>>>>>>    // Any of the properties that change the text of a status panel must also send
15983>>>>>>>    // ProcessEvents which allows the panel to process painting messages. The ProcessEvents
15983>>>>>>>    // is essential when using status panels within a tight loop
15983>>>>>>>    
15983>>>>>>>    Procedure Set Caption_text String sText
15985>>>>>>>        Set Label to sText
15986>>>>>>>        Send ProcessEvents
15987>>>>>>>    End_Procedure
15988>>>>>>>    
15988>>>>>>>    Function Caption_Text Returns String
15990>>>>>>>        Function_Return (Label(Self))
15991>>>>>>>    End_Function
15992>>>>>>>    
15992>>>>>>>    Procedure Set Message_Text String sText
15994>>>>>>>        Send ProcessEvents
15995>>>>>>>    End_Procedure
15996>>>>>>>    
15996>>>>>>>    Function Message_Text Returns String
15998>>>>>>>    End_Function
15999>>>>>>>    
15999>>>>>>>    Procedure Set Action_Text String sText
16001>>>>>>>        Send ProcessEvents
16002>>>>>>>    End_Procedure
16003>>>>>>>    
16003>>>>>>>    Function Action_Text Returns String
16005>>>>>>>    End_Function
16006>>>>>>>    
16006>>>>>>>    Procedure Set Button_Text String sText
16008>>>>>>>        Send ProcessEvents
16009>>>>>>>    End_Procedure
16010>>>>>>>    
16010>>>>>>>    Function Button_Text Returns String
16012>>>>>>>    End_Function
16013>>>>>>>    
16013>>>>>>>    Procedure Set Title_Text String sText
16015>>>>>>>        Send ProcessEvents
16016>>>>>>>    End_Procedure
16017>>>>>>>    
16017>>>>>>>    Function Title_Text Returns String
16019>>>>>>>    End_Function
16020>>>>>>>    
16020>>>>>>>    // initializes values for caption, title & message
16020>>>>>>>    Procedure Initialize_StatusPanel String sCaption String sTitle String sMessage
16022>>>>>>>        Set Caption_text to sCaption
16023>>>>>>>        Set Title_Text   to sTitle
16024>>>>>>>        Set Message_Text to sMessage
16025>>>>>>>    End_Procedure
16026>>>>>>>    
16026>>>>>>>    // update the status panel's action area
16026>>>>>>>    Procedure Update_StatusPanel String sAction
16028>>>>>>>        Set Action_Text to sAction
16029>>>>>>>    End_Procedure
16030>>>>>>>    
16030>>>>>>>    // stop the status panel
16030>>>>>>>    Procedure Close_Panel
16032>>>>>>>        If (Allow_cancel_state(Self)) Begin
16034>>>>>>>            Forward Send Close_Panel
16036>>>>>>>        End
16036>>>>>>>>
16036>>>>>>>    End_Procedure
16037>>>>>>>    
16037>>>>>>>    // Code must be provided in the cancel button object to enable/disable cancel button
16037>>>>>>>    Procedure EnableCancelButton Boolean bEnable
16039>>>>>>>    End_Procedure
16040>>>>>>>    
16040>>>>>>>    // check for cancel (if cancel or pbCancel is set, close the panel)
16040>>>>>>>    Function Check_StatusPanel Returns Integer
16042>>>>>>>        Boolean bCancel
16042>>>>>>>        If (Active_state(Self)) Begin
16044>>>>>>>            Send ProcessEvents
16045>>>>>>>            Get pbCancel to bCancel
16046>>>>>>>            If bCancel Begin
16048>>>>>>>                Send Stop_StatusPanel // the old status panel removed this when canceled.
16049>>>>>>>            End
16049>>>>>>>>
16049>>>>>>>        End
16049>>>>>>>>
16049>>>>>>>        Function_Return (If(bCancel, MSG_CANCEL, 0)) // the old check status panel returns msg_cancel
16050>>>>>>>    End_Function
16051>>>>>>>    
16051>>>>>>>    // start the status panel
16051>>>>>>>    Procedure Start_StatusPanel
16053>>>>>>>        If not (Active_state(Self)) Begin
16055>>>>>>>            Send EnableCancelButton (Allow_cancel_state(Self))
16056>>>>>>>            Send Activate
16057>>>>>>>        End
16057>>>>>>>>
16057>>>>>>>    End_Procedure
16058>>>>>>>    
16058>>>>>>>    // stop the status panel
16058>>>>>>>    Procedure Stop_StatusPanel
16060>>>>>>>        If (Active_state(Self)) Begin
16062>>>>>>>            Send Deactivate
16063>>>>>>>        End
16063>>>>>>>>
16063>>>>>>>    End_Procedure
16064>>>>>>>    
16064>>>>>>>End_Class
16065>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJSkinFramework.pkg)
16065>>>>>>>Use windows.pkg
16065>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJComSkinFramework.pkg)
16065>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
16065>>>>>>>>>Use FlexCom20.pkg
Including file: FlexCOM20.pkg    (C:\Program Files\DataFlex 23.0\Pkg\FlexCOM20.pkg)
16065>>>>>>>>>>>// Full Flexcom support for automation (cComAutomationObject),
16065>>>>>>>>>>>// activeX (cComActiveXControl and document objects (cComDocumentObject)
16065>>>>>>>>>>>Use FlexCOM20_Base.pkg // defines basic flexcom symbols and class cComAutomationObject
Including file: FlexCOM20_Base.pkg    (C:\Program Files\DataFlex 23.0\Pkg\FlexCOM20_Base.pkg)
16065>>>>>>>>>>>>>// Flexcom support for automation (cComAutomationObject).
16065>>>>>>>>>>>>>// If you want activeX and document objects use FlexCom20.pkg
16065>>>>>>>>>>>>>Use VdfBase.pkg
16065>>>>>>>>>>>>>Use ComTypes.pkg
Including file: ComTypes.pkg    (C:\Program Files\DataFlex 23.0\Pkg\ComTypes.pkg)
16065>>>>>>>>>>>>>>>Use Variant.pkg
16065>>>>>>>>>>>>>>>
16065>>>>>>>>>>>>>>>
16065>>>>>>>>>>>>>
16065>>>>>>>>>>>>>
16065>>>>>>>>>>>>>
16065>>>>>>>>>>>>>//Enumerations for the peAutoCreate property
16065>>>>>>>>>>>>>//acNoAutoCreate - Do not automatically instantiate the COM object upon VDF object creation.
16065>>>>>>>>>>>>>//You must manually instantiate the COM object using CreateComObject. This is the default
16065>>>>>>>>>>>>>//for cComAutomation.
16065>>>>>>>>>>>>>Define acNoAutoCreate for 0
16065>>>>>>>>>>>>>//acAutoCreate - Automatically instantiate the COM object upon VDF object creation.
16065>>>>>>>>>>>>>//You won't need to manually instantiate the COM object. This is the default
16065>>>>>>>>>>>>>//for cComActiveXControl
16065>>>>>>>>>>>>>Define acAutoCreate for 1
16065>>>>>>>>>>>>>//acDeferredAutoCreate - Automatically instantiate the COM object during Page_Object,
16065>>>>>>>>>>>>>//and automatically destroy the COM object during Page_Delete. Use this setting only
16065>>>>>>>>>>>>>//if acAutoCreate causes problems.
16065>>>>>>>>>>>>>Define acDeferredAutoCreate for 2
16065>>>>>>>>>>>>>
16065>>>>>>>>>>>>>Class cComAutomationObject is a DFComAutomationObject
16066>>>>>>>>>>>>>    Procedure Construct_Object
16068>>>>>>>>>>>>>        Forward Send Construct_Object
16070>>>>>>>>>>>>>        Send RegisterComEvents
16071>>>>>>>>>>>>>    End_Procedure
16072>>>>>>>>>>>>>    
16072>>>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
16072>>>>>>>>>>>>>    Procedure RegisterComEvents
16074>>>>>>>>>>>>>    End_Procedure
16075>>>>>>>>>>>>>    
16075>>>>>>>>>>>>>    // Attach the DF object to com automation object via progId.
16075>>>>>>>>>>>>>    // returns: Boolean bSuccess if Ok, If not ok, pcComObject is set to null
16075>>>>>>>>>>>>>    Function AttachActiveObject Returns Boolean
16077>>>>>>>>>>>>>        String sProgId
16077>>>>>>>>>>>>>        Variant vComObject
16077>>>>>>>>>>>>>        Boolean bSuccess
16077>>>>>>>>>>>>>        Get psProgID to sProgId
16078>>>>>>>>>>>>>        Get ComActiveObject sProgId to vComObject
16079>>>>>>>>>>>>>        Set pvComObject to vComObject
16080>>>>>>>>>>>>>        Move (not(IsNullComObject(vComObject))) to bSuccess // success of variant is not null
16081>>>>>>>>>>>>>        Function_Return bSuccess
16082>>>>>>>>>>>>>    End_Function
16083>>>>>>>>>>>>>    
16083>>>>>>>>>>>>>    // returns true if the control is created.
16083>>>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
16085>>>>>>>>>>>>>        Variant vComObject
16085>>>>>>>>>>>>>        Get pvComObject to vComObject
16086>>>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16087>>>>>>>>>>>>>    End_Function
16088>>>>>>>>>>>>>    
16088>>>>>>>>>>>>>End_Class
16089>>>>>>>>>>>>>
16089>>>>>>>>>>>>>
16089>>>>>>>>>>>
16089>>>>>>>>>>>Use Windows.pkg
16089>>>>>>>>>>>
16089>>>>>>>>>>>Class cComDocumentObject is a DFComDocumentObject
16090>>>>>>>>>>>
16090>>>>>>>>>>>
16090>>>>>>>>>>>    Procedure Construct_Object
16092>>>>>>>>>>>        Forward Send Construct_Object
16094>>>>>>>>>>>        Send RegisterComEvents
16095>>>>>>>>>>>        Send Define_Standard_Object_Mixin
16096>>>>>>>>>>>        Send Define_Shadow_Mixin
16097>>>>>>>>>>>    End_Procedure
16098>>>>>>>>>>>
16098>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
16099>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
16100>>>>>>>>>>>
16100>>>>>>>>>>>    
16100>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
16100>>>>>>>>>>>    Procedure RegisterComEvents
16102>>>>>>>>>>>    End_Procedure
16103>>>>>>>>>>>    
16103>>>>>>>>>>>    // returns true if the control is created.
16103>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
16105>>>>>>>>>>>        Variant vComObject
16105>>>>>>>>>>>        Get pvComObject to vComObject
16106>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16107>>>>>>>>>>>    End_Function
16108>>>>>>>>>>>
16108>>>>>>>>>>>
16108>>>>>>>>>>>End_Class
16109>>>>>>>>>>>
16109>>>>>>>>>>>Class cComActiveXControl is a DFComActiveXControl
16110>>>>>>>>>>>
16110>>>>>>>>>>>    Procedure Construct_Object
16112>>>>>>>>>>>        Forward Send Construct_Object
16114>>>>>>>>>>>        Send RegisterComEvents
16115>>>>>>>>>>>
16115>>>>>>>>>>>
16115>>>>>>>>>>>        Send Define_Standard_Object_Mixin
16116>>>>>>>>>>>        Send Define_Single_Item_Navigate_Mixin
16117>>>>>>>>>>>        Send Define_Dflabel_Mixin
16118>>>>>>>>>>>
16118>>>>>>>>>>>        // internal: set true object is notified that the OCX value has changed.
16118>>>>>>>>>>>        Property Boolean pbPrivateControlChanging False
16119>>>>>>>>>>>        // Class sets this true when making a local (externally triggered) change. This is
16119>>>>>>>>>>>        // set when a Set Value change is made to prevent recursion
16119>>>>>>>>>>>        Property Boolean pbPrivateControlRefresh False
16120>>>>>>>>>>>        
16120>>>>>>>>>>>        // added to eumlate a single item form support
16120>>>>>>>>>>>        Property Boolean pbPrivateItem_Changed_State False
16121>>>>>>>>>>>        
16121>>>>>>>>>>>        // This keeps track of value, even when control is not created
16121>>>>>>>>>>>        Property String psPrivateValue ''
16122>>>>>>>>>>>        
16122>>>>>>>>>>>        // If set true, then the control will attempt to bind the value property in the object to the
16122>>>>>>>>>>>        // comValue in the control. It will try to keep these values in synch at all times. This allows a
16122>>>>>>>>>>>        // control to be used as a Form style value control. the default is true. Even when true if the
16122>>>>>>>>>>>        // get/set ComValue methods are not set up to do anything, this will do nothing.
16122>>>>>>>>>>>        Property Boolean pbBindValue True
16123>>>>>>>>>>>        
16123>>>>>>>>>>>    End_Procedure
16124>>>>>>>>>>>    
16124>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
16124>>>>>>>>>>>    Procedure RegisterComEvents
16126>>>>>>>>>>>    End_Procedure
16127>>>>>>>>>>>
16127>>>>>>>>>>>    
16127>>>>>>>>>>>    // returns true if the control is created.
16127>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
16129>>>>>>>>>>>        Variant vComObject
16129>>>>>>>>>>>        Get pvComObject to vComObject
16130>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16131>>>>>>>>>>>    End_Function
16132>>>>>>>>>>>    
16132>>>>>>>>>>>
16132>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
16133>>>>>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
16134>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
16135>>>>>>>>>>>
16135>>>>>>>>>>>    // added to eumlate a single item form support
16135>>>>>>>>>>>    Function Item_Count Returns Integer
16137>>>>>>>>>>>        Function_Return 1
16138>>>>>>>>>>>    End_Function
16139>>>>>>>>>>>    
16139>>>>>>>>>>>    // added to eumlate a single item form support
16139>>>>>>>>>>>    Procedure Set Item_Changed_State Integer iItem Integer iState
16141>>>>>>>>>>>        Set pbPrivateItem_changed_state to iState
16142>>>>>>>>>>>        If (iState and changed_state(Self)=False) ;            Set changed_state to True
16145>>>>>>>>>>>    End_Procedure
16146>>>>>>>>>>>    
16146>>>>>>>>>>>    Function Item_Changed_State Integer iItem Returns Integer
16148>>>>>>>>>>>        Function_Return (pbPrivateItem_changed_state(Self))
16149>>>>>>>>>>>    End_Function
16150>>>>>>>>>>>    
16150>>>>>>>>>>>    
16150>>>>>>>>>>>    // augment to set the label's appearance
16150>>>>>>>>>>>    Procedure Shadow_Display
16152>>>>>>>>>>>        Forward Send Shadow_display
16154>>>>>>>>>>>        Send Label_Shadow_Display
16155>>>>>>>>>>>    End_Procedure
16156>>>>>>>>>>>    
16156>>>>>>>>>>>    // Created to simulate get/Set value.
16156>>>>>>>>>>>    Procedure Set Value Integer iItem String sVal
16158>>>>>>>>>>>        If not (pbPrivateControlChanging(Self)) ;            Send OnRefreshControl sVal
16161>>>>>>>>>>>        Set psPrivateValue to sVal
16162>>>>>>>>>>>        Send OnChange
16163>>>>>>>>>>>        //Set changed_state to True
16163>>>>>>>>>>>        Set item_changed_state 0 to True
16164>>>>>>>>>>>    End_Procedure
16165>>>>>>>>>>>    
16165>>>>>>>>>>>    Function Value Integer iItem Returns String
16167>>>>>>>>>>>        Function_Return (psPrivateValue(Self))
16168>>>>>>>>>>>        //function_return (Controlvalue(self))
16168>>>>>>>>>>>    End_Function
16169>>>>>>>>>>>    
16169>>>>>>>>>>>    Procedure OnChange
16171>>>>>>>>>>>    End_Procedure
16172>>>>>>>>>>>    
16172>>>>>>>>>>>    
16172>>>>>>>>>>>    // It is expected that the sub-class will provide functionality
16172>>>>>>>>>>>    // for these messages. This gets and sets the value of the actual
16172>>>>>>>>>>>    // window control. These should only be used to synchronize the window
16172>>>>>>>>>>>    // control and the DF side. Do not use for any other purpose.
16172>>>>>>>>>>>    Procedure Set ControlValue String sVal
16174>>>>>>>>>>>    End_Procedure
16175>>>>>>>>>>>    
16175>>>>>>>>>>>    Function ControlValue Returns String
16177>>>>>>>>>>>    End_Function
16178>>>>>>>>>>>    
16178>>>>>>>>>>>    Procedure OnCreate
16180>>>>>>>>>>>        // if we are binding value to comValue, do so upon creation
16180>>>>>>>>>>>        If (pbBindValue(Self)) ;            Set ControlValue to (Value(Self))
16183>>>>>>>>>>>        Forward Send OnCreate
16185>>>>>>>>>>>    End_Procedure
16186>>>>>>>>>>>    
16186>>>>>>>>>>>    // Notification that the control is about to be activated in place. The COM component is
16186>>>>>>>>>>>    // created but OnCreate is not yet fired (this happens after the InPlaceActivate).
16186>>>>>>>>>>>    Procedure OnBeforeInPlaceActivate
16188>>>>>>>>>>>        Forward Send OnBeforeInPlaceActivate
16190>>>>>>>>>>>    End_Procedure
16191>>>>>>>>>>>    
16191>>>>>>>>>>>    // Notification that the control's value has been changed
16191>>>>>>>>>>>    // externally by the program (via set value). Use to synchronize
16191>>>>>>>>>>>    // OCX control value.
16191>>>>>>>>>>>    Procedure OnRefreshControl String sVal
16193>>>>>>>>>>>        Boolean bOld
16193>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlChanging(Self)=0 and IsComObjectCreated(Self)) Begin
16195>>>>>>>>>>>            Get pbPrivateControlRefresh to bOld
16196>>>>>>>>>>>            Set pbPrivateControlRefresh to True
16197>>>>>>>>>>>            Set ControlValue to sval
16198>>>>>>>>>>>            Set pbPrivateControlRefresh to bOld
16199>>>>>>>>>>>        End
16199>>>>>>>>>>>>
16199>>>>>>>>>>>    End_Procedure
16200>>>>>>>>>>>    
16200>>>>>>>>>>>    // notification that the control has changed its value. Used to
16200>>>>>>>>>>>    // synchronize the object with the change.
16200>>>>>>>>>>>    Procedure OnControlValueChanged
16202>>>>>>>>>>>        String sVal
16202>>>>>>>>>>>        Boolean bOld
16202>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlRefresh(Self)=0) Begin
16204>>>>>>>>>>>            Get pbPrivateControlChanging to bOld
16205>>>>>>>>>>>            Set pbPrivateControlChanging to True
16206>>>>>>>>>>>            Get ControlValue to sVal
16207>>>>>>>>>>>            Set Value to sVal
16208>>>>>>>>>>>            Set Item_Changed_State 0 to True
16209>>>>>>>>>>>            Set pbPrivateControlChanging to bOld
16210>>>>>>>>>>>        End
16210>>>>>>>>>>>>
16210>>>>>>>>>>>    End_Procedure
16211>>>>>>>>>>>    
16211>>>>>>>>>>>    Procedure Delete_Data
16213>>>>>>>>>>>        Forward Send Delete_Data
16215>>>>>>>>>>>        Set Value to ''
16216>>>>>>>>>>>        Set Changed_state to False
16217>>>>>>>>>>>        Set Item_changed_state 0 to False
16218>>>>>>>>>>>    End_Procedure
16219>>>>>>>>>>>
16219>>>>>>>>>>>
16219>>>>>>>>>>>End_Class
16220>>>>>>>>>>>
16220>>>>>>>>>>>
16220>>>>>>>>>
16220>>>>>>>>>// Changes to Imported package
16220>>>>>>>>>//     OLEXTPxx to XTPxx
16220>>>>>>>>>//     OLExtpxx to xtpxx
16220>>>>>>>>>//     OLESkinFramework to SkinFramework
16220>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
16220>>>>>>>>>//     cCom classes to cCJ
16220>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
16220>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
16220>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
16220>>>>>>>>>//     Use statements as noted below (classes moved to these files)
16220>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
16220>>>>>>>>>
16220>>>>>>>>>// These have been extracted from this class and moved into seperate packages
16220>>>>>>>>>// because other Codejock classes use these.
16220>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
Including file: cCJColorManager.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJColorManager.pkg)
16220>>>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.CommandBars.Unicode.x64.v20.0.0.ocx
16220>>>>>>>>>>>Use FlexCom20.pkg
16220>>>>>>>>>>>
16220>>>>>>>>>>>Define XTPColorManagerColor for Integer
16220>>>>>>>>>>>    Define STDCOLOR_BACKGROUND for 1
16220>>>>>>>>>>>    Define STDCOLOR_ACTIVECAPTION for 2
16220>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTION for 3
16220>>>>>>>>>>>    Define STDCOLOR_MENU for 4
16220>>>>>>>>>>>    Define STDCOLOR_WINDOW for 5
16220>>>>>>>>>>>    Define STDCOLOR_WINDOWFRAME for 6
16220>>>>>>>>>>>    Define STDCOLOR_MENUTEXT for 7
16220>>>>>>>>>>>    Define STDCOLOR_WINDOWTEXT for 8
16220>>>>>>>>>>>    Define STDCOLOR_CAPTIONTEXT for 9
16220>>>>>>>>>>>    Define STDCOLOR_ACTIVEBORDER for 10
16220>>>>>>>>>>>    Define STDCOLOR_INACTIVEBORDER for 11
16220>>>>>>>>>>>    Define STDCOLOR_APPWORKSPACE for 12
16220>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHT for 13
16220>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHTTEXT for 14
16220>>>>>>>>>>>    Define STDCOLOR_BTNFACE for 15
16220>>>>>>>>>>>    Define STDCOLOR_BTNSHADOW for 16
16220>>>>>>>>>>>    Define STDCOLOR_GRAYTEXT for 17
16220>>>>>>>>>>>    Define STDCOLOR_BTNTEXT for 18
16220>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTIONTEXT for 19
16220>>>>>>>>>>>    Define STDCOLOR_BTNHIGHLIGHT for 20
16220>>>>>>>>>>>    Define STDCOLOR_3DDKSHADOW for 21
16220>>>>>>>>>>>    Define STDCOLOR_3DLIGHT for 22
16220>>>>>>>>>>>    Define STDCOLOR_INFOTEXT for 23
16220>>>>>>>>>>>    Define STDCOLOR_INFOBK for 24
16220>>>>>>>>>>>    Define STDCOLOR_HOTLIGHT for 26
16220>>>>>>>>>>>    Define STDCOLOR_GRADIENTACTIVECAPTION for 27
16220>>>>>>>>>>>    Define STDCOLOR_GRADIENTINACTIVECAPTION for 28
16220>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_FACE for 30
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT for 31
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_BORDER for 32
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED for 33
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED for 36
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED_BORDER for 37
16220>>>>>>>>>>>    Define XPCOLOR_ICONSHADDOW for 34
16220>>>>>>>>>>>    Define XPCOLOR_GRAYTEXT for 35
16220>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_GRIPPER for 38
16220>>>>>>>>>>>    Define XPCOLOR_SEPARATOR for 39
16220>>>>>>>>>>>    Define XPCOLOR_DISABLED for 40
16220>>>>>>>>>>>    Define XPCOLOR_MENUBAR_FACE for 41
16220>>>>>>>>>>>    Define XPCOLOR_MENUBAR_EXPANDED for 42
16220>>>>>>>>>>>    Define XPCOLOR_MENUBAR_BORDER for 43
16220>>>>>>>>>>>    Define XPCOLOR_MENUBAR_TEXT for 44
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_TEXT for 45
16220>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_TEXT for 46
16220>>>>>>>>>>>    Define XPCOLOR_PUSHED_TEXT for 47
16220>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_BACK for 48
16220>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_TEXT for 49
16220>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED_BORDER for 50
16220>>>>>>>>>>>    Define XPCOLOR_3DFACE for 51
16220>>>>>>>>>>>    Define XPCOLOR_3DSHADOW for 52
16220>>>>>>>>>>>    Define XPCOLOR_FRAME for 54
16220>>>>>>>>>>>    Define XPCOLOR_SPLITTER_FACE for 55
16220>>>>>>>>>>>    Define XPCOLOR_LABEL for 56
16220>>>>>>>>>>>    Define XPCOLOR_STATICFRAME for 57
16220>>>>>>>>>>>
16220>>>>>>>>>>>Define XTPCurrentSystemTheme for Integer
16220>>>>>>>>>>>    // No known theme in use
16220>>>>>>>>>>>    Define xtpSystemThemeUnknown for 0
16220>>>>>>>>>>>    // Blue theme in use
16220>>>>>>>>>>>    Define xtpSystemThemeBlue for 1
16220>>>>>>>>>>>    // Olive theme in use
16220>>>>>>>>>>>    Define xtpSystemThemeOlive for 2
16220>>>>>>>>>>>    // Silver theme in use
16220>>>>>>>>>>>    Define xtpSystemThemeSilver for 3
16220>>>>>>>>>>>    // Silver theme in use
16220>>>>>>>>>>>    Define xtpSystemThemeRoyale for 4
16220>>>>>>>>>>>    // Silver theme in use
16220>>>>>>>>>>>    Define xtpSystemThemeAero for 5
16220>>>>>>>>>>>    // Use OS theme.
16220>>>>>>>>>>>    Define xtpSystemThemeAuto for 6
16220>>>>>>>>>>>
16220>>>>>>>>>>>
16220>>>>>>>>>>>// CLSID: {C0DE2200-DE43-4B56-BCEB-E14B825CF245}
16220>>>>>>>>>>>Class cCJIColorManager is a Mixin
16221>>>>>>>>>>>
16221>>>>>>>>>>>    Function ComSystemTheme Returns XTPCurrentSystemTheme
16223>>>>>>>>>>>        XTPCurrentSystemTheme retVal
16223>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to retVal
16224>>>>>>>>>>>        Function_Return retVal
16225>>>>>>>>>>>    End_Function
16226>>>>>>>>>>>
16226>>>>>>>>>>>    Procedure Set ComSystemTheme XTPCurrentSystemTheme value
16228>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to value
16229>>>>>>>>>>>    End_Procedure
16230>>>>>>>>>>>
16230>>>>>>>>>>>    Function ComEnableLunaBlueForRoyaleTheme Returns Boolean
16232>>>>>>>>>>>        Boolean retVal
16232>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to retVal
16233>>>>>>>>>>>        Function_Return retVal
16234>>>>>>>>>>>    End_Function
16235>>>>>>>>>>>
16235>>>>>>>>>>>    Procedure Set ComEnableLunaBlueForRoyaleTheme Boolean value
16237>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to value
16238>>>>>>>>>>>    End_Procedure
16239>>>>>>>>>>>
16239>>>>>>>>>>>    Function ComColor XTPColorManagerColor llIndex Returns OLE_COLOR
16241>>>>>>>>>>>        Handle hDispatchDriver
16241>>>>>>>>>>>        OLE_COLOR retVal
16241>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16242>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16243>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16244>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_I4 to retVal
16245>>>>>>>>>>>        Function_Return retVal
16246>>>>>>>>>>>    End_Function
16247>>>>>>>>>>>
16247>>>>>>>>>>>    Procedure ComSetColor XTPColorManagerColor llIndex OLE_COLOR llColor
16249>>>>>>>>>>>        Handle hDispatchDriver
16249>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16250>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16251>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16252>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llColor
16253>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
16254>>>>>>>>>>>    End_Procedure
16255>>>>>>>>>>>
16255>>>>>>>>>>>    Function ComGetCurrentSystemTheme Returns XTPCurrentSystemTheme
16257>>>>>>>>>>>        Handle hDispatchDriver
16257>>>>>>>>>>>        XTPCurrentSystemTheme retVal
16257>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16258>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
16259>>>>>>>>>>>        Function_Return retVal
16260>>>>>>>>>>>    End_Function
16261>>>>>>>>>>>End_Class
16262>>>>>>>>>>>
16262>>>>>>>>>>>// CoClass
16262>>>>>>>>>>>// CLSID: {C0DE2200-F3FE-46E7-BB64-DB033F439F8B}
16262>>>>>>>>>>>Class cCJColorManager is a cComAutomationObject
16263>>>>>>>>>>>    Import_Class_Protocol cCJIColorManager
16264>>>>>>>>>>>
16264>>>>>>>>>>>    Procedure Construct_Object
16266>>>>>>>>>>>        Forward Send Construct_Object
16268>>>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
16269>>>>>>>>>>>    End_Procedure
16270>>>>>>>>>>>End_Class
16271>>>>>>>>>>>
16271>>>>>>>>>
16271>>>>>>>>>
16271>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
16271>>>>>>>>>    Define xtpSkinApplyMetrics for 1
16271>>>>>>>>>    Define xtpSkinApplyFrame for 2
16271>>>>>>>>>    Define xtpSkinApplyColors for 4
16271>>>>>>>>>    Define xtpSkinApplyMenus for 8
16271>>>>>>>>>
16271>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
16271>>>>>>>>>// Dispatch interface for SkinFramework Control
16271>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
16272>>>>>>>>>
16272>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
16274>>>>>>>>>        SkinFrameworkApplyOptions retVal
16274>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
16275>>>>>>>>>        Function_Return retVal
16276>>>>>>>>>    End_Function
16277>>>>>>>>>
16277>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
16279>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
16280>>>>>>>>>    End_Procedure
16281>>>>>>>>>
16281>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
16283>>>>>>>>>        Boolean retVal
16283>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
16284>>>>>>>>>        Function_Return retVal
16285>>>>>>>>>    End_Function
16286>>>>>>>>>
16286>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
16288>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
16289>>>>>>>>>    End_Procedure
16290>>>>>>>>>
16290>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
16292>>>>>>>>>        Boolean retVal
16292>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
16293>>>>>>>>>        Function_Return retVal
16294>>>>>>>>>    End_Function
16295>>>>>>>>>
16295>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
16297>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
16298>>>>>>>>>    End_Procedure
16299>>>>>>>>>
16299>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
16301>>>>>>>>>        Handle hDispatchDriver
16301>>>>>>>>>        Boolean retVal
16301>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16302>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16303>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
16304>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
16305>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
16306>>>>>>>>>        Function_Return retVal
16307>>>>>>>>>    End_Function
16308>>>>>>>>>
16308>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
16310>>>>>>>>>        Handle hDispatchDriver
16310>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16311>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16312>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16313>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
16314>>>>>>>>>    End_Procedure
16315>>>>>>>>>
16315>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
16317>>>>>>>>>        Handle hDispatchDriver
16317>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16318>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16319>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16320>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
16321>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
16322>>>>>>>>>    End_Procedure
16323>>>>>>>>>
16323>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
16325>>>>>>>>>        Handle hDispatchDriver
16325>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16326>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16327>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16328>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
16329>>>>>>>>>    End_Procedure
16330>>>>>>>>>
16330>>>>>>>>>    Procedure ComRemoveAllWindows
16332>>>>>>>>>        Handle hDispatchDriver
16332>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16333>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
16334>>>>>>>>>    End_Procedure
16335>>>>>>>>>
16335>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
16337>>>>>>>>>        Handle hDispatchDriver
16337>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16338>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16339>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
16340>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
16341>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
16342>>>>>>>>>    End_Procedure
16343>>>>>>>>>
16343>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
16345>>>>>>>>>        Handle hDispatchDriver
16345>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16346>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16347>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
16348>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
16349>>>>>>>>>    End_Procedure
16350>>>>>>>>>
16350>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
16352>>>>>>>>>        Handle hDispatchDriver
16352>>>>>>>>>        Variant retVal
16352>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16353>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16354>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
16355>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
16356>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
16357>>>>>>>>>        Function_Return retVal
16358>>>>>>>>>    End_Function
16359>>>>>>>>>
16359>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
16361>>>>>>>>>        Handle hDispatchDriver
16361>>>>>>>>>        Variant retVal
16361>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16362>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16363>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
16364>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
16365>>>>>>>>>        Function_Return retVal
16366>>>>>>>>>    End_Function
16367>>>>>>>>>
16367>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
16369>>>>>>>>>        Handle hDispatchDriver
16369>>>>>>>>>        OLE_COLOR retVal
16369>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16370>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16371>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16372>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
16373>>>>>>>>>        Function_Return retVal
16374>>>>>>>>>    End_Function
16375>>>>>>>>>
16375>>>>>>>>>    Procedure ComExcludeModule String llModuleName
16377>>>>>>>>>        Handle hDispatchDriver
16377>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16378>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16379>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
16380>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
16381>>>>>>>>>    End_Procedure
16382>>>>>>>>>
16382>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
16384>>>>>>>>>        Handle hDispatchDriver
16384>>>>>>>>>        Variant retVal
16384>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16385>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16386>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
16387>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
16388>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
16389>>>>>>>>>        Function_Return retVal
16390>>>>>>>>>    End_Function
16391>>>>>>>>>
16391>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
16393>>>>>>>>>        Handle hDispatchDriver
16393>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16394>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16395>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16396>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
16397>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
16398>>>>>>>>>    End_Procedure
16399>>>>>>>>>
16399>>>>>>>>>    Procedure ComAboutBox
16401>>>>>>>>>        Handle hDispatchDriver
16401>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16402>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
16403>>>>>>>>>    End_Procedure
16404>>>>>>>>>End_Class
16405>>>>>>>>>
16405>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
16405>>>>>>>>>// Event interface for SkinFramework Control
16405>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
16406>>>>>>>>>
16406>>>>>>>>>    Procedure RegisterComEvents
16408>>>>>>>>>    End_Procedure
16409>>>>>>>>>End_Class
16410>>>>>>>>>
16410>>>>>>>>>// CoClass
16410>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
16410>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
16410>>>>>>>>>// SkinFramework Control
16410>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
16411>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
16412>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
16413>>>>>>>>>
16413>>>>>>>>>    Procedure Construct_Object
16415>>>>>>>>>        Forward Send Construct_Object
16417>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
16418>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
16419>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
16420>>>>>>>>>        Set peAutoCreate to acAutoCreate
16421>>>>>>>>>    End_Procedure
16422>>>>>>>>>End_Class
16423>>>>>>>>>
16423>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
16423>>>>>>>>>// SkinFramework Global Settings
16423>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
16424>>>>>>>>>
16424>>>>>>>>>    Function ComLicense Returns String
16426>>>>>>>>>        String retVal
16426>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
16427>>>>>>>>>        Function_Return retVal
16428>>>>>>>>>    End_Function
16429>>>>>>>>>
16429>>>>>>>>>    Procedure Set ComLicense String value
16431>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
16432>>>>>>>>>    End_Procedure
16433>>>>>>>>>
16433>>>>>>>>>    Function ComTitle Returns String
16435>>>>>>>>>        String retVal
16435>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
16436>>>>>>>>>        Function_Return retVal
16437>>>>>>>>>    End_Function
16438>>>>>>>>>
16438>>>>>>>>>    Procedure Set ComTitle String value
16440>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
16441>>>>>>>>>    End_Procedure
16442>>>>>>>>>
16442>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
16442>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
16444>>>>>>>>>        Boolean retVal
16444>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
16445>>>>>>>>>        Function_Return retVal
16446>>>>>>>>>    End_Function
16447>>>>>>>>>
16447>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
16447>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
16449>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
16450>>>>>>>>>    End_Procedure
16451>>>>>>>>>
16451>>>>>>>>>    Function ComVersion Returns String
16453>>>>>>>>>        Handle hDispatchDriver
16453>>>>>>>>>        String retVal
16453>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16454>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
16455>>>>>>>>>        Function_Return retVal
16456>>>>>>>>>    End_Function
16457>>>>>>>>>
16457>>>>>>>>>    Function ComUnicode Returns Boolean
16459>>>>>>>>>        Handle hDispatchDriver
16459>>>>>>>>>        Boolean retVal
16459>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16460>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
16461>>>>>>>>>        Function_Return retVal
16462>>>>>>>>>    End_Function
16463>>>>>>>>>
16463>>>>>>>>>    Function ComOcxPath Returns String
16465>>>>>>>>>        Handle hDispatchDriver
16465>>>>>>>>>        String retVal
16465>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16466>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
16467>>>>>>>>>        Function_Return retVal
16468>>>>>>>>>    End_Function
16469>>>>>>>>>End_Class
16470>>>>>>>>>
16470>>>>>>>>>// CoClass
16470>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
16470>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
16470>>>>>>>>>// SkinFramework Global Settings
16470>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
16471>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
16472>>>>>>>>>
16472>>>>>>>>>    Procedure Construct_Object
16474>>>>>>>>>        Forward Send Construct_Object
16476>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
16477>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
16478>>>>>>>>>    End_Procedure
16479>>>>>>>>>End_Class
16480>>>>>>>>>
16480>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
16480>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
16481>>>>>>>>>
16481>>>>>>>>>    Function ComColorScheme Returns String
16483>>>>>>>>>        String retVal
16483>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
16484>>>>>>>>>        Function_Return retVal
16485>>>>>>>>>    End_Function
16486>>>>>>>>>
16486>>>>>>>>>    Procedure Set ComColorScheme String value
16488>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
16489>>>>>>>>>    End_Procedure
16490>>>>>>>>>
16490>>>>>>>>>    Function ComFontSize Returns String
16492>>>>>>>>>        String retVal
16492>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
16493>>>>>>>>>        Function_Return retVal
16494>>>>>>>>>    End_Function
16495>>>>>>>>>
16495>>>>>>>>>    Procedure Set ComFontSize String value
16497>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
16498>>>>>>>>>    End_Procedure
16499>>>>>>>>>
16499>>>>>>>>>    Function ComIniFileName Returns String
16501>>>>>>>>>        String retVal
16501>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
16502>>>>>>>>>        Function_Return retVal
16503>>>>>>>>>    End_Function
16504>>>>>>>>>
16504>>>>>>>>>    Procedure Set ComIniFileName String value
16506>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
16507>>>>>>>>>    End_Procedure
16508>>>>>>>>>End_Class
16509>>>>>>>>>
16509>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
16509>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
16510>>>>>>>>>
16510>>>>>>>>>    Function ComName Returns String
16512>>>>>>>>>        String retVal
16512>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
16513>>>>>>>>>        Function_Return retVal
16514>>>>>>>>>    End_Function
16515>>>>>>>>>
16515>>>>>>>>>    Procedure Set ComName String value
16517>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
16518>>>>>>>>>    End_Procedure
16519>>>>>>>>>
16519>>>>>>>>>    Function ComPath Returns String
16521>>>>>>>>>        String retVal
16521>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
16522>>>>>>>>>        Function_Return retVal
16523>>>>>>>>>    End_Function
16524>>>>>>>>>
16524>>>>>>>>>    Procedure Set ComPath String value
16526>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
16527>>>>>>>>>    End_Procedure
16528>>>>>>>>>
16528>>>>>>>>>    Function ComCount Returns Integer
16530>>>>>>>>>        Handle hDispatchDriver
16530>>>>>>>>>        Integer retVal
16530>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16531>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
16532>>>>>>>>>        Function_Return retVal
16533>>>>>>>>>    End_Function
16534>>>>>>>>>
16534>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
16536>>>>>>>>>        Handle hDispatchDriver
16536>>>>>>>>>        Variant retVal
16536>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16537>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16538>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16539>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
16540>>>>>>>>>        Function_Return retVal
16541>>>>>>>>>    End_Function
16542>>>>>>>>>
16542>>>>>>>>>    Function Com_NewEnum Returns Variant
16544>>>>>>>>>        Handle hDispatchDriver
16544>>>>>>>>>        Variant retVal
16544>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16545>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
16546>>>>>>>>>        Function_Return retVal
16547>>>>>>>>>    End_Function
16548>>>>>>>>>End_Class
16549>>>>>>>>>
16549>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
16549>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
16550>>>>>>>>>
16550>>>>>>>>>    Function ComCount Returns Integer
16552>>>>>>>>>        Handle hDispatchDriver
16552>>>>>>>>>        Integer retVal
16552>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16553>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
16554>>>>>>>>>        Function_Return retVal
16555>>>>>>>>>    End_Function
16556>>>>>>>>>
16556>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
16558>>>>>>>>>        Handle hDispatchDriver
16558>>>>>>>>>        Variant retVal
16558>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16559>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16560>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16561>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
16562>>>>>>>>>        Function_Return retVal
16563>>>>>>>>>    End_Function
16564>>>>>>>>>
16564>>>>>>>>>    Function Com_NewEnum Returns Variant
16566>>>>>>>>>        Handle hDispatchDriver
16566>>>>>>>>>        Variant retVal
16566>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16567>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
16568>>>>>>>>>        Function_Return retVal
16569>>>>>>>>>    End_Function
16570>>>>>>>>>End_Class
16571>>>>>>>>>
16571>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
16571>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
16572>>>>>>>>>
16572>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
16574>>>>>>>>>        Handle hDispatchDriver
16574>>>>>>>>>        OLE_COLOR retVal
16574>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16575>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16576>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16577>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
16578>>>>>>>>>        Function_Return retVal
16579>>>>>>>>>    End_Function
16580>>>>>>>>>End_Class
16581>>>>>>>Use cApplication.pkg
16581>>>>>>>
16581>>>>>>>Struct tSkinInformation
16581>>>>>>>    String sName     // description of the skin
16581>>>>>>>    String sSkinfile // file path. Can be relative or full
16581>>>>>>>    String sSkinIni  // section name
16581>>>>>>>End_Struct
16581>>>>>>>
16581>>>>>>>
16581>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
16582>>>>>>>    
16582>>>>>>>    Procedure Construct_Object
16584>>>>>>>        Forward Send Construct_Object
16586>>>>>>>        
16586>>>>>>>        Property String psSkinFile ""
16587>>>>>>>        Property String psSkinIni ""
16588>>>>>>>        Property Boolean pbLoadPreference False
16589>>>>>>>        
16589>>>>>>>        Set peAutoCreate to acAutoCreate
16590>>>>>>>        
16590>>>>>>>        Move Self to ghoSkinFramework
16591>>>>>>>    End_Procedure
16592>>>>>>>    
16592>>>>>>>    // return the default skin path, which is the programs directory.
16592>>>>>>>    // This requires an application object.
16592>>>>>>>    // If you want to different skin path, override this.
16592>>>>>>>    Function SkinPath Returns String
16594>>>>>>>        String sPath sPaths
16594>>>>>>>        Handle hoWorkspace
16594>>>>>>>        If ghoApplication Begin
16596>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
16597>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
16598>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
16599>>>>>>>        End
16599>>>>>>>>
16599>>>>>>>        Else Begin
16600>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16601>>>>>>>>
16601>>>>>>>        End
16601>>>>>>>>
16601>>>>>>>        Function_Return sPath
16602>>>>>>>    End_Function
16603>>>>>>>    
16603>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
16603>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
16603>>>>>>>    Function SkinQFile Returns String
16605>>>>>>>        String sFile sPath sSep
16605>>>>>>>        Boolean bQualified
16605>>>>>>>        Get psSkinFile to sFile
16606>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
16608>>>>>>>            Get SkinPath to sPath
16609>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
16610>>>>>>>            Move (sPath - sSep - sFile) to sFile
16611>>>>>>>        End
16611>>>>>>>>
16611>>>>>>>        Function_Return sFile
16612>>>>>>>    End_Function
16613>>>>>>>    
16613>>>>>>>    // defines the default VDF window class mapping.
16613>>>>>>>    Procedure OnAddVDFWindowClasses
16615>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
16616>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
16617>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
16618>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
16619>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
16620>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
16621>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
16622>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
16623>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
16624>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
16625>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
16626>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
16627>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
16628>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
16629>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
16630>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
16631>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
16632>>>>>>>        // External class
16632>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
16633>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
16634>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
16635>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
16636>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
16637>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
16638>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
16639>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
16640>>>>>>>    End_Procedure
16641>>>>>>>    
16641>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
16641>>>>>>>    Procedure OnAddCustomWindowClasses
16643>>>>>>>    End_Procedure
16644>>>>>>>    
16644>>>>>>>    // called when object is created during end_construct_object.
16644>>>>>>>    Procedure OnCreate
16646>>>>>>>        Integer iOpts
16646>>>>>>>        Boolean bUseWindowsFont
16646>>>>>>>        Forward Send OnCreate
16648>>>>>>>        
16648>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
16648>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
16648>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
16649>>>>>>>        If bUseWindowsFont Begin
16651>>>>>>>            Get ComApplyOptions to iOpts
16652>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
16653>>>>>>>        End
16653>>>>>>>>
16653>>>>>>>        
16653>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
16653>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
16653>>>>>>>        // and this was the suggested workaround.
16653>>>>>>>        Set ComAutoApplyNewThreads to False
16654>>>>>>>        
16654>>>>>>>        Send OnAddVDFWindowClasses
16655>>>>>>>        Send OnAddCustomWindowClasses
16656>>>>>>>        
16656>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
16656>>>>>>>        If (pbLoadPreference(Self)) Begin
16658>>>>>>>            Send LoadSkinPreference
16659>>>>>>>        End
16659>>>>>>>>
16659>>>>>>>        // if a skin file name exists, we apply the skin.
16659>>>>>>>        If (psSkinFile(Self)<>"") Begin
16661>>>>>>>            Send ApplySkin
16662>>>>>>>        End
16662>>>>>>>>
16662>>>>>>>    End_Procedure
16663>>>>>>>    
16663>>>>>>>    // called by framework as part of application exit.
16663>>>>>>>    Procedure Broadcast_Notify_Exit_Application
16665>>>>>>>        Send Notify_Exit_Application
16666>>>>>>>    End_Procedure
16667>>>>>>>    
16667>>>>>>>    Procedure Notify_Exit_Application
16669>>>>>>>        If (pbLoadPreference(Self)) Begin
16671>>>>>>>            Send SaveSkinPreference
16672>>>>>>>        End
16672>>>>>>>>
16672>>>>>>>    End_Procedure
16673>>>>>>>    
16673>>>>>>>    Procedure NotifyPreApplySkin
16675>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
16677>>>>>>>    End_Procedure
16678>>>>>>>    
16678>>>>>>>    Procedure NotifyPostApplySkin
16680>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
16682>>>>>>>    End_Procedure
16683>>>>>>>    
16683>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
16683>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
16683>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
16685>>>>>>>        tSkinInformation[] Skins
16685>>>>>>>        tSkinInformation[] Skins
16686>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
16686>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
16686>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
16686>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
16686>>>>>>>        Integer iPos iDfltLen
16686>>>>>>>        Boolean bUseRelativePath
16686>>>>>>>        
16686>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
16687>>>>>>>        
16687>>>>>>>        Get SkinPath to sDefaultPath
16688>>>>>>>        If (sPath="") Begin
16690>>>>>>>            Move sDefaultPath to sPath
16691>>>>>>>        End
16691>>>>>>>>
16691>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
16692>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
16693>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
16694>>>>>>>        
16694>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
16695>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
16697>>>>>>>            
16697>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
16698>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
16699>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
16700>>>>>>>            
16700>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
16701>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
16702>>>>>>>            
16702>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
16708>>>>>>>>
16708>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
16709>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
16710>>>>>>>                
16710>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
16711>>>>>>>                
16711>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
16717>>>>>>>>
16717>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
16718>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
16719>>>>>>>                    
16719>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
16720>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
16721>>>>>>>                    If bUseRelativePath Begin
16723>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
16724>>>>>>>                        If iPos Begin
16726>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
16727>>>>>>>                            While (Left(sSkinFile,1)=sSep)
16731>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
16732>>>>>>>                            Loop
16733>>>>>>>>
16733>>>>>>>                        End
16733>>>>>>>>
16733>>>>>>>                    End
16733>>>>>>>>
16733>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
16734>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
16735>>>>>>>                    
16735>>>>>>>                    Increment iArrayItem
16736>>>>>>>                Loop
16737>>>>>>>>
16737>>>>>>>            Loop
16738>>>>>>>>
16738>>>>>>>            
16738>>>>>>>            Send Destroy of hSkinDescriptions
16739>>>>>>>            Send Destroy of hSkinDescription
16740>>>>>>>            Send Destroy of hSkinIniFile
16741>>>>>>>            
16741>>>>>>>        End
16741>>>>>>>>
16741>>>>>>>        Function_Return Skins
16742>>>>>>>    End_Function
16743>>>>>>>    
16743>>>>>>>    // Save the skin preference. This requires an application object.
16743>>>>>>>    // Only do this if the application object allows it.
16743>>>>>>>    // This is called during startup if pbLoadPreference is True
16743>>>>>>>    // Suitable for override
16743>>>>>>>    Procedure SaveSkinPreference
16745>>>>>>>        String sSkin sIni
16745>>>>>>>        If ghoApplication Begin
16747>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
16749>>>>>>>                Get psSkinFile to sSkin
16750>>>>>>>                Get psSkinIni to sIni
16751>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
16752>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
16753>>>>>>>            End
16753>>>>>>>>
16753>>>>>>>        End
16753>>>>>>>>
16753>>>>>>>        Else Begin
16754>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16755>>>>>>>>
16755>>>>>>>        End
16755>>>>>>>>
16755>>>>>>>    End_Procedure
16756>>>>>>>    
16756>>>>>>>    // Load the skin preference. This requires an application object.
16756>>>>>>>    // Only do this if the application object allows it.
16756>>>>>>>    // This is called during startup if pbLoadPreference is True
16756>>>>>>>    // Suitable for override
16756>>>>>>>    Procedure LoadSkinPreference
16758>>>>>>>        String sSkin sIni
16758>>>>>>>        Boolean bExists
16758>>>>>>>        If ghoApplication Begin
16760>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
16762>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
16763>>>>>>>                If bExists Begin
16765>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
16766>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
16767>>>>>>>                    Set psSkinFile to sSkin
16768>>>>>>>                    Set psSkinIni to sIni
16769>>>>>>>                End
16769>>>>>>>>
16769>>>>>>>            End
16769>>>>>>>>
16769>>>>>>>        End
16769>>>>>>>>
16769>>>>>>>        Else Begin
16770>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16771>>>>>>>>
16771>>>>>>>        End
16771>>>>>>>>
16771>>>>>>>    End_Procedure
16772>>>>>>>    
16772>>>>>>>    // Can be called to apply the current skin.
16772>>>>>>>    Procedure ApplySkin
16774>>>>>>>        Boolean bOk
16774>>>>>>>        String sSkin sIni
16774>>>>>>>        If (IsComObjectCreated(Self)) Begin
16776>>>>>>>            Get SkinQFile to sSkin
16777>>>>>>>            Get psSkinIni to sIni
16778>>>>>>>            
16778>>>>>>>            Send NotifyPreApplySkin
16779>>>>>>>            // when skins are used we don't want to use built in Visual Styles
16779>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
16780>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
16781>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
16783>>>>>>>                // if not ok, no skin was appied. Enable visual styles
16783>>>>>>>                Send EnableVisualStyles of Desktop True
16784>>>>>>>            End
16784>>>>>>>>
16784>>>>>>>            Send NotifyPostApplySkin
16785>>>>>>>        End
16785>>>>>>>>
16785>>>>>>>    End_Procedure
16786>>>>>>>    
16786>>>>>>>    
16786>>>>>>>End_Class
16787>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cProgressBar.pkg)
16787>>>>>>>Use Windows.pkg
16787>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cWinControl.pkg)
16787>>>>>>>>>Use Windows.pkg
16787>>>>>>>>>
16787>>>>>>>>>// Key State Masks for Mouse Messages
16787>>>>>>>>>
16787>>>>>>>>>Define MK_LBUTTON  for |CI$0001
16787>>>>>>>>>Define MK_RBUTTON  for |CI$0002
16787>>>>>>>>>Define MK_SHIFT    for |CI$0004
16787>>>>>>>>>Define MK_CONTROL  for |CI$0008
16787>>>>>>>>>Define MK_MBUTTON  for |CI$0010
16787>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
16787>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
16787>>>>>>>>>
16787>>>>>>>>>Enum_List // Mouse Key Flags
16787>>>>>>>>>    Define mkLeft    for MK_LBUTTON
16787>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
16787>>>>>>>>>    Define mkRight   for MK_RBUTTON
16787>>>>>>>>>    Define mkX1      for MK_XBUTTON1
16787>>>>>>>>>    Define mkX2      for MK_XBUTTON2
16787>>>>>>>>>    Define mkShift   for MK_SHIFT
16787>>>>>>>>>    Define mkControl for MK_CONTROL
16787>>>>>>>>>End_Enum_List
16787>>>>>>>>>
16787>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
16787>>>>>>>>>    Define mbLeft
16787>>>>>>>>>    Define mbMiddle
16787>>>>>>>>>    Define mbRight
16787>>>>>>>>>    Define mbX1
16787>>>>>>>>>    Define mbX2
16787>>>>>>>>>End_Enum_List
16787>>>>>>>>>
16787>>>>>>>>>Class cWinControl is a DfBaseControl
16788>>>>>>>>>    Procedure Construct_Object
16790>>>>>>>>>        Forward Send Construct_Object
16792>>>>>>>>>        Property Integer private_pbEnabled True
16793>>>>>>>>>        Property Integer private_pbVisible True
16794>>>>>>>>>    End_Procedure
16795>>>>>>>>>    
16795>>>>>>>>>    Procedure End_Construct_Object
16797>>>>>>>>>        Forward Send End_Construct_Object
16799>>>>>>>>>        
16799>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
16800>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
16801>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
16802>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
16803>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
16804>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
16805>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
16806>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
16807>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
16808>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
16809>>>>>>>>>    End_Procedure
16810>>>>>>>>>    
16810>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
16812>>>>>>>>>        //Intentionally cancelled
16812>>>>>>>>>    End_Procedure
16813>>>>>>>>>    
16813>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
16815>>>>>>>>>        //Intentionally cancelled
16815>>>>>>>>>    End_Procedure
16816>>>>>>>>>    
16816>>>>>>>>>    Procedure DoRecreateWindow
16818>>>>>>>>>        // Recreates the window
16818>>>>>>>>>        If (Window_Handle(Self)) Begin
16820>>>>>>>>>            // attempt to do this without disturbing the focus tree.
16820>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
16821>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
16822>>>>>>>>>        End
16822>>>>>>>>>>
16822>>>>>>>>>    End_Procedure
16823>>>>>>>>>    
16823>>>>>>>>>    Procedure DoUpdateWindow
16825>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
16825>>>>>>>>>        Handle hWnd
16825>>>>>>>>>        
16825>>>>>>>>>        Get Window_Handle to hWnd
16826>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
16829>>>>>>>>>    End_Procedure
16830>>>>>>>>>    
16830>>>>>>>>>    Procedure Page Integer iState
16832>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
16833>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
16834>>>>>>>>>        Forward Send Page iState
16836>>>>>>>>>    End_Procedure
16837>>>>>>>>>    
16837>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
16839>>>>>>>>>        Integer x y eButton
16839>>>>>>>>>        
16839>>>>>>>>>        Move (Hi(lParam))  to y
16840>>>>>>>>>        Move (Low(lParam)) to x
16841>>>>>>>>>        
16841>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
16842>>>>>>>>>    End_Procedure
16843>>>>>>>>>    
16843>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
16845>>>>>>>>>        Integer x y eButton
16845>>>>>>>>>        
16845>>>>>>>>>        Move (Hi(lParam))  to y
16846>>>>>>>>>        Move (Low(lParam)) to x
16847>>>>>>>>>        
16847>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
16848>>>>>>>>>    End_Procedure
16849>>>>>>>>>    
16849>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
16851>>>>>>>>>        Integer x y eButton
16851>>>>>>>>>        
16851>>>>>>>>>        Move (Hi(lParam))  to y
16852>>>>>>>>>        Move (Low(lParam)) to x
16853>>>>>>>>>        
16853>>>>>>>>>        Send OnMouseUp mbRight x y wParam
16854>>>>>>>>>    End_Procedure
16855>>>>>>>>>    
16855>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
16857>>>>>>>>>        Integer x y eButton fKeys
16857>>>>>>>>>        
16857>>>>>>>>>        Move (Hi(lParam))  to y
16858>>>>>>>>>        Move (Low(lParam)) to x
16859>>>>>>>>>        
16859>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
16860>>>>>>>>>    End_Procedure
16861>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
16863>>>>>>>>>        Integer x y eButton
16863>>>>>>>>>        
16863>>>>>>>>>        Move (Hi(lParam))  to y
16864>>>>>>>>>        Move (Low(lParam)) to x
16865>>>>>>>>>        
16865>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
16866>>>>>>>>>    End_Procedure
16867>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
16869>>>>>>>>>        Integer x y eButton
16869>>>>>>>>>        
16869>>>>>>>>>        Move (Hi(lParam))  to y
16870>>>>>>>>>        Move (Low(lParam)) to x
16871>>>>>>>>>        
16871>>>>>>>>>        Send OnMouseDown mbRight x y wParam
16872>>>>>>>>>    End_Procedure
16873>>>>>>>>>    
16873>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
16875>>>>>>>>>        Integer x y eButton
16875>>>>>>>>>        
16875>>>>>>>>>        Move (Hi(lParam))  to y
16876>>>>>>>>>        Move (Low(lParam)) to x
16877>>>>>>>>>        
16877>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
16878>>>>>>>>>    End_Procedure
16879>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
16881>>>>>>>>>        Integer x y eButton
16881>>>>>>>>>        
16881>>>>>>>>>        Move (Hi(lParam))  to y
16882>>>>>>>>>        Move (Low(lParam)) to x
16883>>>>>>>>>        
16883>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
16884>>>>>>>>>    End_Procedure
16885>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
16887>>>>>>>>>        Integer x y eButton
16887>>>>>>>>>        
16887>>>>>>>>>        Move (Hi(lParam))  to y
16888>>>>>>>>>        Move (Low(lParam)) to x
16889>>>>>>>>>        
16889>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
16890>>>>>>>>>    End_Procedure
16891>>>>>>>>>    
16891>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
16893>>>>>>>>>        Integer x y eButton
16893>>>>>>>>>        
16893>>>>>>>>>        Move (Hi(lParam))  to y
16894>>>>>>>>>        Move (Low(lParam)) to x
16895>>>>>>>>>        
16895>>>>>>>>>        Send OnMouseMove x y wParam
16896>>>>>>>>>    End_Procedure
16897>>>>>>>>>    
16897>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
16899>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16899>>>>>>>>>        //String sButton
16899>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16899>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16899>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16899>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16899>>>>>>>>>        
16899>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16899>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16899>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16899>>>>>>>>>    End_Procedure
16900>>>>>>>>>    
16900>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
16902>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16902>>>>>>>>>        //String sButton
16902>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16902>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16902>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16902>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16902>>>>>>>>>        
16902>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16902>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16902>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16902>>>>>>>>>    End_Procedure
16903>>>>>>>>>    
16903>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
16905>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16905>>>>>>>>>        //String sButton
16905>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16905>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16905>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16905>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16905>>>>>>>>>        
16905>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16905>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16905>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16905>>>>>>>>>    End_Procedure
16906>>>>>>>>>    
16906>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
16908>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16908>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16908>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16908>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16908>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16908>>>>>>>>>        
16908>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16908>>>>>>>>>    End_Procedure
16909>>>>>>>>>    
16909>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
16911>>>>>>>>>        Handle hWnd
16911>>>>>>>>>        
16911>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
16913>>>>>>>>>            Set private_pbEnabled to bEnabled
16914>>>>>>>>>            Get Window_Handle to hWnd
16915>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
16918>>>>>>>>>        End
16918>>>>>>>>>>
16918>>>>>>>>>    End_Procedure
16919>>>>>>>>>    Function pbEnabled Returns Boolean
16921>>>>>>>>>        Function_Return (private_pbEnabled(Self))
16922>>>>>>>>>    End_Function
16923>>>>>>>>>    
16923>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
16925>>>>>>>>>        Handle  hWnd
16925>>>>>>>>>        Integer iVoid
16925>>>>>>>>>        
16925>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
16927>>>>>>>>>            Set private_pbVisible to bVisible
16928>>>>>>>>>            Get Window_Handle to hWnd
16929>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
16932>>>>>>>>>        End
16932>>>>>>>>>>
16932>>>>>>>>>    End_Procedure
16933>>>>>>>>>    Function pbVisible Returns Boolean
16935>>>>>>>>>        Function_Return (private_pbVisible(Self))
16936>>>>>>>>>    End_Function
16937>>>>>>>>>    
16937>>>>>>>>>End_Class
16938>>>>>>>Use CommCtrl.pkg
16938>>>>>>>
16938>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
16938>>>>>>>Class cProgressBar is a cWinControl
16939>>>>>>>    
16939>>>>>>>    Procedure Construct_Object
16941>>>>>>>        Forward Send Construct_Object
16943>>>>>>>        Property Integer private_piMinimum
16944>>>>>>>        Property Integer private_piMaximum   100
16945>>>>>>>        Property Integer private_piAdvanceBy 10
16946>>>>>>>        Property Integer private_piPosition
16947>>>>>>>        Property Integer private_pbVertical  False
16948>>>>>>>        Property Integer private_pbSmooth    False
16949>>>>>>>        Property Integer private_piBackColor clDefault
16950>>>>>>>        Property Integer private_piBarColor  clDefault
16951>>>>>>>        
16951>>>>>>>        Send Define_ToolTip_Support_Mixin
16952>>>>>>>        
16952>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
16953>>>>>>>        Set Focus_Mode to NonFocusable
16954>>>>>>>        Set Skip_State to True
16955>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
16956>>>>>>>    End_Procedure
16957>>>>>>>    
16957>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
16958>>>>>>>    
16958>>>>>>>    Procedure Set piMinimum Integer iMin
16960>>>>>>>        Integer iMax
16960>>>>>>>        
16960>>>>>>>        Set private_piMinimum to iMin
16961>>>>>>>        Get private_piMaximum to iMax
16962>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
16963>>>>>>>    End_Procedure
16964>>>>>>>    Function piMinimum Returns Integer
16966>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
16969>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
16971>>>>>>>    End_Function
16972>>>>>>>    
16972>>>>>>>    Procedure Set piMaximum Integer iMax
16974>>>>>>>        Integer iMin
16974>>>>>>>        
16974>>>>>>>        Set private_piMaximum to iMax
16975>>>>>>>        Get private_piMinimum to iMin
16976>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
16977>>>>>>>    End_Procedure
16978>>>>>>>    Function piMaximum Returns Integer
16980>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
16983>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
16985>>>>>>>    End_Function
16986>>>>>>>    
16986>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
16988>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
16989>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
16990>>>>>>>    End_Procedure
16991>>>>>>>    Function piAdvanceBy Returns Integer
16993>>>>>>>        Function_Return (private_piAdvanceBy(Self))
16994>>>>>>>    End_Function
16995>>>>>>>    
16995>>>>>>>    Procedure Set piPosition Integer iPos
16997>>>>>>>        Set private_piPosition to iPos
16998>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
16999>>>>>>>    End_Procedure
17000>>>>>>>    
17000>>>>>>>    Function piPosition Returns Integer
17002>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
17005>>>>>>>        Else;            Function_Return (private_piPosition(Self))
17007>>>>>>>    End_Function
17008>>>>>>>    
17008>>>>>>>    Procedure Set pbVertical Boolean bVertical
17010>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
17012>>>>>>>            Set private_pbVertical to bVertical
17013>>>>>>>            Send DoRecreateWindow
17014>>>>>>>        End
17014>>>>>>>>
17014>>>>>>>    End_Procedure
17015>>>>>>>    
17015>>>>>>>    Function pbVertical Returns Boolean
17017>>>>>>>        Function_Return (private_pbVertical(Self))
17018>>>>>>>    End_Function
17019>>>>>>>    
17019>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
17021>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
17023>>>>>>>            Set private_pbSmooth to bSmooth
17024>>>>>>>            Send DoRecreateWindow
17025>>>>>>>        End
17025>>>>>>>>
17025>>>>>>>    End_Procedure
17026>>>>>>>    Function pbSmooth Returns Boolean
17028>>>>>>>        Function_Return (private_pbSmooth(Self))
17029>>>>>>>    End_Function
17030>>>>>>>    
17030>>>>>>>    Procedure Set piBackColor Integer rgbColor
17032>>>>>>>        Set private_piBackColor to rgbColor
17033>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
17034>>>>>>>    End_Procedure
17035>>>>>>>    Function piBackColor Returns Integer
17037>>>>>>>        Function_Return (private_piBackColor(Self))
17038>>>>>>>    End_Function
17039>>>>>>>    
17039>>>>>>>    Procedure Set piBarColor Integer rgbColor
17041>>>>>>>        Set private_piBarColor to rgbColor
17042>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
17043>>>>>>>    End_Procedure
17044>>>>>>>    Function piBarColor Returns Integer
17046>>>>>>>        Function_Return (private_piBarColor(Self))
17047>>>>>>>    End_Function
17048>>>>>>>    
17048>>>>>>>    Procedure DoAdvance
17050>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
17051>>>>>>>    End_Procedure
17052>>>>>>>    
17052>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
17054>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
17055>>>>>>>    End_Procedure
17056>>>>>>>    
17056>>>>>>>    Procedure private_DoInitWindow
17058>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
17059>>>>>>>        Set piBackColor to (private_piBackColor(Self))
17060>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
17061>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
17062>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
17063>>>>>>>        Set piPosition  to (private_piPosition(Self))
17064>>>>>>>    End_Procedure
17065>>>>>>>    
17065>>>>>>>    Procedure Page_Object Integer iState
17067>>>>>>>        Handle hWnd
17067>>>>>>>        
17067>>>>>>>        Get Window_Handle to hWnd
17068>>>>>>>        If (hWnd=0 and iState) Begin
17070>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
17071>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
17072>>>>>>>            Forward Send Page_Object True
17074>>>>>>>        End
17074>>>>>>>>
17074>>>>>>>        Else ;            Forward Send Page_Object iState
17077>>>>>>>        
17077>>>>>>>        // Handle tooltip support....
17077>>>>>>>        If (iState = 0) Begin
17079>>>>>>>            Send RequestDeleteToolTip
17080>>>>>>>        End
17080>>>>>>>>
17080>>>>>>>        Else Begin
17081>>>>>>>            Send RequestAddToolTip
17082>>>>>>>        End
17082>>>>>>>>
17082>>>>>>>    End_Procedure
17083>>>>>>>    
17083>>>>>>>    Procedure Page Integer iState
17085>>>>>>>        Forward Send Page iState
17087>>>>>>>        If (iState =1);            Send private_DoInitWindow
17090>>>>>>>    End_Procedure
17091>>>>>>>    
17091>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
17091>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
17091>>>>>>>    // is implemented in a mixin class.
17091>>>>>>>    Procedure RequestAddToolTip
17093>>>>>>>        Send AddToolTip
17094>>>>>>>    End_Procedure
17095>>>>>>>    
17095>>>>>>>    
17095>>>>>>>    // Called by Page_Object. Handles tooltip removal.
17095>>>>>>>    Procedure RequestDeleteToolTip
17097>>>>>>>        Send DeleteToolTip
17098>>>>>>>    End_Procedure
17099>>>>>>>End_Class
17100>>>>>Use Windows.pkg
17100>>>>>Use DUFLanguageConstants.inc
17100>>>>>Use Statpnl.pkg
Including file: Statpnl.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Statpnl.pkg)
17100>>>>>>>// creates the standard status_panel object.
17100>>>>>>>//
17100>>>>>>>// This is the default Status Panel object used by any of the DataFlex classes that
17100>>>>>>>// invoke the standard status panel. The standard has always been that the package name
17100>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
17100>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
17100>>>>>>>// prior revisions has been replace with status panel that is part of the application.
17100>>>>>>>// This should work much better and faster than the old sentinel based solution.
17100>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
17100>>>>>>>// with most applications.
17100>>>>>>>//
17100>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
17100>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
17100>>>>>>>// a cleaner more robust interface.
17100>>>>>>>//
17100>>>>>>>//
17100>>>>>>>// Compatibility Note:
17100>>>>>>>//
17100>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
17100>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
17100>>>>>>>//
17100>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
17100>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
17100>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
17100>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
17100>>>>>>>//
17100>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
17100>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
17100>>>>>>>//
17100>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
17100>>>>>>>// can still access the new object via the ghoStatusPanel handle.
17100>>>>>>>//
17100>>>>>>>//
17100>>>>>>>// Creating your own Status Panel objects
17100>>>>>>>//
17100>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
17100>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
17100>>>>>>>// with a different file and object name and direct your status panel request to the new object.
17100>>>>>>>//
17100>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
17100>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
17100>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
17100>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
17100>>>>>>>// e.g.
17100>>>>>>>//       Procedure UpdateStatusBar
17100>>>>>>>//           Send DoAdvance of oProgressBar
17100>>>>>>>//           Send ProcessEvents
17100>>>>>>>//       End_Procedure
17100>>>>>>>//
17100>>>>>>>// Of course, if you use the standard interfaces in status bar and your forward send these
17100>>>>>>>// messages this will be done for you.
17100>>>>>>>//
17100>>>>>>>// the standard Interface for status panels are:
17100>>>>>>>//
17100>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
17100>>>>>>>// Send Start_StatusPanel      - start the status panel
17100>>>>>>>// Send Stop_StatusPanel       - stop the status panel
17100>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
17100>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
17100>>>>>>>//
17100>>>>>>>// Get/Set Caption_Text - updates the caption bar
17100>>>>>>>// Get/Set Title_Text   - updates the title area
17100>>>>>>>// Get/Set Message_Text - updates the Message area
17100>>>>>>>// Get/Set Action_Text  - updates the action area
17100>>>>>>>// Get/Set Button_Text  - updates the button area
17100>>>>>>>//
17100>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
17100>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
17100>>>>>>>//
17100>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
17100>>>>>>>
17100>>>>>>>Use cProcessStatusPanel.pkg
17100>>>>>>>
17100>>>>>>>
17100>>>>>>>Global_Variable Handle ghoStatusPanel // will contain the ID of the global StatusPanel object
17100>>>>>>>
17100>>>>>>>
17100>>>>>>>Object Status_Panel is a cProcessStatusPanel
17102>>>>>>>    
17102>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout your applicaton to access this object
17103>>>>>>>    
17103>>>>>>>    Set Size to 80 166
17104>>>>>>>    
17104>>>>>>>    Object oTitleTxt is a TextBox
17106>>>>>>>        Set location to 10 10
17107>>>>>>>        Set Auto_Size_State to False
17108>>>>>>>        Set size to 20 150
17109>>>>>>>        Set Justification_Mode to JMode_Center
17110>>>>>>>    End_Object
17111>>>>>>>    
17111>>>>>>>    Object oMessageTxt is a TextBox
17113>>>>>>>        Set location to 25 10
17114>>>>>>>        Set Auto_Size_State to False
17115>>>>>>>        Set size to 20 150
17116>>>>>>>    End_Object
17117>>>>>>>    
17117>>>>>>>    Object oActionTxt is a TextBox
17119>>>>>>>        Set location to 45 10
17120>>>>>>>    End_Object
17121>>>>>>>    
17121>>>>>>>    Object oStopButton is a Button
17123>>>>>>>        Set Location to 60 58
17124>>>>>>>        Set Label to C_$Cancel
17125>>>>>>>        
17125>>>>>>>        Procedure OnClick
17128>>>>>>>            Send Close_panel
17129>>>>>>>        End_Procedure
17130>>>>>>>        
17130>>>>>>>    End_Object
17131>>>>>>>    
17131>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
17131>>>>>>>    // objects defined within this instance of the status panel.
17131>>>>>>>    
17131>>>>>>>    // note: all of the messages that change text should be forwarded
17131>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
17131>>>>>>>    
17131>>>>>>>    Procedure Set Message_Text String sText
17134>>>>>>>        Set Label of oMessageTxt to sText
17135>>>>>>>        Forward Set Message_Text to sText
17137>>>>>>>    End_Procedure
17138>>>>>>>    
17138>>>>>>>    Function Message_Text Returns String
17141>>>>>>>        Function_Return (Label(oMessageTxt))
17142>>>>>>>    End_Function
17143>>>>>>>    
17143>>>>>>>    Procedure Set Action_Text String sText
17146>>>>>>>        Set Label of oActionTxt to sText
17147>>>>>>>        Forward Set Action_Text to sText
17149>>>>>>>    End_Procedure
17150>>>>>>>    
17150>>>>>>>    Function Action_Text Returns String
17153>>>>>>>        Function_Return (Label(oActionTxt))
17154>>>>>>>    End_Function
17155>>>>>>>    
17155>>>>>>>    Procedure Set Button_Text String sText
17158>>>>>>>        Set Label of oStopButton to sText
17159>>>>>>>        Forward Set Button_Text to sText
17161>>>>>>>    End_Procedure
17162>>>>>>>    
17162>>>>>>>    Function Button_Text Returns String
17165>>>>>>>        Function_Return (Label(oStopButton))
17166>>>>>>>    End_Function
17167>>>>>>>    
17167>>>>>>>    Procedure Set Title_Text String sText
17170>>>>>>>        Set Label of oTitleTxt to sText
17171>>>>>>>        Forward Set Title_Text to sText
17173>>>>>>>    End_Procedure
17174>>>>>>>    
17174>>>>>>>    Function Title_Text Returns String
17177>>>>>>>        Function_Return (Label(oTitleTxt))
17178>>>>>>>    End_Function
17179>>>>>>>    
17179>>>>>>>    // gets called when status panel is activated passing whether a button
17179>>>>>>>    // should appear
17179>>>>>>>    Procedure EnableCancelButton Boolean bEnable
17182>>>>>>>        Set Enabled_State of oStopButton to bEnable
17183>>>>>>>    End_Procedure
17184>>>>>>>    
17184>>>>>>>End_Object
17185>>>>>>>
17185>>>>>
17185>>>>>
17185>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
17185>>>>>
17185>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
17185>>>>>
17185>>>>>Object Status_Panel is a cProcessStatusPanel
17187>>>>>    Set Size to 152 222
17188>>>>>    Set Border_Style to Border_Dialog
17189>>>>>    Set Icon to "Default.ico"
17190>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
17191>>>>>
17191>>>>>    Property Boolean Cancel_Button_Visible_State True
17193>>>>>
17193>>>>>    Procedure Activate
17196>>>>>        Integer iSizeBefore
17196>>>>>        Get GuiSize to iSizeBefore
17197>>>>>        Forward Send Activate
17199>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
17200>>>>>    End_Procedure
17201>>>>>
17201>>>>>    Procedure End_Construct_Object
17204>>>>>        Forward Send End_Construct_Object
17206>>>>>        Set Label of oTitleTxt      to ""
17207>>>>>        Set Label of oTableNameTxt  to ""
17208>>>>>        Set Label of oMessageTxt    to ""
17209>>>>>        Set Label of oActionTxt     to ""
17210>>>>>    End_Procedure
17211>>>>>
17211>>>>>    Object oTitleTxt is a TextBox
17213>>>>>        Set Location to 5 21
17214>>>>>        Set Size to 8 179
17215>>>>>        Set Auto_Size_State to False
17216>>>>>        Set Justification_Mode  to jMode_Center
17217>>>>>        Set Label to "This is the Title Text"
17218>>>>>    End_Object
17219>>>>>
17219>>>>>    Object oTableNameTxt is a TextBox
17221>>>>>        Set Size to 19 204
17222>>>>>        Set Location to 18 9
17223>>>>>        Set Auto_Size_State to False
17224>>>>>        Set Justification_Mode to JMode_Left
17225>>>>>        Set Label to "This is the TableName Text"
17226>>>>>    End_Object
17227>>>>>
17227>>>>>    Object oMessageTxt is a TextBox
17229>>>>>        Set Location to 39 9
17230>>>>>        Set Size to 19 204
17231>>>>>        Set Auto_Size_State to False
17232>>>>>        Set Justification_Mode to JMode_Left
17233>>>>>        Set Label to "This is the Message text"
17234>>>>>    End_Object
17235>>>>>
17235>>>>>    Object oActionTxt is a TextBox
17237>>>>>        Set Size to 16 204
17238>>>>>        Set Location to 60 9
17239>>>>>        Set Auto_Size_State to False
17240>>>>>        Set Justification_Mode to JMode_Left
17241>>>>>        Set Label to "This is the Action Text"
17242>>>>>    End_Object
17243>>>>>
17243>>>>>    Object oStopButton is a Button
17245>>>>>        Set Location to 123 82
17246>>>>>        Set Label to C_$Cancel
17247>>>>>
17247>>>>>        Procedure OnClick 
17250>>>>>            Integer iRetval
17250>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
17251>>>>>            If (iRetval = MBR_Yes) Begin
17253>>>>>                Send Exit_Application
17254>>>>>            End
17254>>>>>>
17254>>>>>        End_Procedure
17255>>>>>
17255>>>>>    End_Object
17256>>>>>
17256>>>>>    Object oPercentage_tb is a TextBox
17258>>>>>        Set Location to 74 196
17259>>>>>        Set Size to 10 25
17260>>>>>//        Set Label to "% Done"
17260>>>>>    End_Object
17261>>>>>
17261>>>>>    Object oCopyRight is a TextBox
17263>>>>>        Set Location to 140 21
17264>>>>>        Set Size to 9 197
17265>>>>>        Set FontPointHeight to 8
17266>>>>>        Set Auto_Size_State to False
17267>>>>>        Set Justification_Mode  to jMode_Center
17268>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
17269>>>>>    End_Object
17270>>>>>
17270>>>>>    Object oProgressBar is a cProgressBar
17272>>>>>        Set Size to 10 179
17273>>>>>        Set Location to 83 22
17274>>>>>        Set pbVisible to True // default
17275>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
17276>>>>>    End_Object
17277>>>>>
17277>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
17280>>>>>        Set pbVisible of ghoProgressBar to bVisible
17281>>>>>    End_Procedure
17282>>>>>
17282>>>>>    Function Progress_Bar_Visible_State Returns Boolean
17285>>>>>        Boolean bVisible
17285>>>>>        Get pbVisible of ghoProgressBar to bVisible
17286>>>>>        Function_Return (bVisible)
17287>>>>>    End_Function
17288>>>>>
17288>>>>>    Object oProgressBarOverall is a cProgressBar
17290>>>>>        Set Size to 10 179
17291>>>>>        Set Location to 107 22
17292>>>>>        Set pbVisible to True // default
17293>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
17294>>>>>    End_Object
17295>>>>>
17295>>>>>    Object oOverallProgress_tb is a TextBox
17297>>>>>        Set Size to 10 65
17298>>>>>        Set Location to 95 24
17299>>>>>        Set Label to "Overall Progress"
17300>>>>>    End_Object
17301>>>>>
17301>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
17304>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
17305>>>>>    End_Procedure
17306>>>>>
17306>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
17309>>>>>        Boolean bVisible
17309>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
17310>>>>>        Function_Return (bVisible)
17311>>>>>    End_Function
17312>>>>>
17312>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
17312>>>>>    // objects defined within this instance of the status panel.
17312>>>>>
17312>>>>>    // note: all of the messages that change text should be forwarded
17312>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
17312>>>>>
17312>>>>>    Procedure Set Message_Text String sText
17315>>>>>        Set Label of oMessageTxt to sText
17316>>>>>        Forward Set Message_Text to sText
17318>>>>>    End_Procedure
17319>>>>>
17319>>>>>    Function Message_Text Returns String
17322>>>>>        Function_Return (Label(oMessageTxt))
17323>>>>>    End_Function
17324>>>>>
17324>>>>>    Procedure Set Action_Text String sText
17327>>>>>        Set Label of oActionTxt to sText
17328>>>>>        Forward Set Action_Text to sText
17330>>>>>    End_Procedure
17331>>>>>
17331>>>>>    Function Action_Text Returns String
17334>>>>>        Function_Return (Label(oActionTxt))
17335>>>>>    End_Function
17336>>>>>
17336>>>>>    Procedure Set Button_Text String sText
17339>>>>>        Set Label of oStopButton to sText
17340>>>>>        Forward Set Button_Text to sText
17342>>>>>    End_Procedure
17343>>>>>
17343>>>>>    Function Button_Text Returns String
17346>>>>>        Function_Return (Label(oStopButton))
17347>>>>>    End_Function
17348>>>>>
17348>>>>>    Procedure Set Title_Text String sText
17351>>>>>        Set Label of oTitleTxt to sText
17352>>>>>        Forward Set Title_Text to sText
17354>>>>>    End_Procedure
17355>>>>>
17355>>>>>    Function Title_Text Returns String
17358>>>>>        Function_Return (Label(oTitleTxt))
17359>>>>>    End_Function
17360>>>>>
17360>>>>>    Procedure Set TableName_Text String sText
17363>>>>>        Set Label of oTableNameTxt to sText
17364>>>>>    End_Procedure
17365>>>>>
17365>>>>>    Function TableName_Text Returns String
17368>>>>>        Function_Return (Label(oTableNameTxt))
17369>>>>>    End_Function
17370>>>>>
17370>>>>>    Procedure Set License_Text String sText
17373>>>>>//        Set Label of oLicense_txt to sText
17373>>>>>    End_Procedure
17374>>>>>
17374>>>>>    // gets called when status panel is activated passing whether a button
17374>>>>>    // should appear
17374>>>>>    Procedure EnableCancelButton Boolean bEnable
17377>>>>>        Boolean bVisible
17377>>>>>        Get Cancel_Button_Visible_State to bVisible
17378>>>>>        If (bEnable = False) Begin
17380>>>>>            Set Visible_State of oStopButton to bVisible
17381>>>>>        End
17381>>>>>>
17381>>>>>        Set Enabled_State of oStopButton to bEnable
17382>>>>>    End_Procedure
17383>>>>>
17383>>>>>    Procedure Reset_StatusPanel
17386>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
17387>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
17388>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
17389>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
17390>>>>>    End_Procedure
17391>>>>>
17391>>>>>//    Object oProgressBar is a cProgressBar
17391>>>>>//        Move Self to ghoProgressBar
17391>>>>>//        Set Location to 1 25
17391>>>>>//        Set Size to 9 173
17391>>>>>//        Set piMinimum        to 0
17391>>>>>//        Set piMaximum        to 2000
17391>>>>>//        Set piAdvanceBy      to 100
17391>>>>>//        Set pbSmooth to True
17391>>>>>//
17391>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
17391>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
17391>>>>>//        // color will show correctly.
17391>>>>>//        Procedure Page Integer iPageObject
17391>>>>>//            Handle hWin
17391>>>>>//            Forward Send Page iPageObject
17391>>>>>//            If (ghoSkinFramework <> 0) Begin
17391>>>>>//                Get Window_Handle to hWin
17391>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
17391>>>>>//            End
17391>>>>>//        End_Procedure
17391>>>>>//    End_Object
17391>>>>>
17391>>>>>End_Object
17392>>>>>
17392>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
17392>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
17392>>>>>//
17392>>>>>Use VdfBase.pkg
17392>>>>>Use cApplication.pkg
17392>>>>>Use seq_chnl.pkg
17392>>>>>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fh.pkg)
17392>>>>>>>// This code is part of VDF GUIdance
17392>>>>>>>// Visit us @ http://www.vdf-guidance.com
17392>>>>>>>// e-Mail us @ info@vdf-guidance.com
17392>>>>>>>// VDF GUIdance is a mutual project of
17392>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
17392>>>>>>>// Wil van Antwerpen  - Antwise Solutions
17392>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
17392>>>>>>>//
17392>>>>>>>//
17392>>>>>>>// *** Windows 32bit file handling wrapper class ***
17392>>>>>>>//
17392>>>>>>>
17392>>>>>>>
17392>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
Including file: File_dlg.pkg    (C:\Program Files\DataFlex 23.0\Pkg\File_dlg.pkg)
17392>>>>>>>>>Use Windows.pkg
17392>>>>>>>>>Use GlobalFunctionsProcedures.pkg
17392>>>>>>>>>
17392>>>>>>>>>
17392>>>>>>>>>// Unicode support, wide version of GetOpenFileName - Gets called directly from Show_Dialog.
17392>>>>>>>>>External_Function GetOpenFileNameW "GetOpenFileNameW" Comdlg32.DLL Pointer OpenStruct Returns Integer
17393>>>>>>>>>
17393>>>>>>>>>// Unicode support, wide version of GetSaveFileName
17393>>>>>>>>>External_Function GetSaveFileNameW "GetSaveFileNameW" Comdlg32.DLL Pointer OpenStruct Returns Integer
17394>>>>>>>>>
17394>>>>>>>>>Struct TOpenFileName
17394>>>>>>>>>    DWord    lStructSize          // length, in bytes, of the structure.
17394>>>>>>>>>    Integer  iMissingAlignment1
17394>>>>>>>>>    Handle   hwndOwner            // Handle to the window that owns the dialog box.
17394>>>>>>>>>    Handle   hInstance            // handle to a memory object containing a dialog box template.
17394>>>>>>>>>    Pointer  lpstrFilter          // pointer to a buffer containing pairs of null-terminated filter strings.
17394>>>>>>>>>    Pointer  lpstrCustomFilter    // Pointer to a static buffer that contains a pair of null-terminated filter strings for preserving the filter pattern chosen by the user.
17394>>>>>>>>>    DWord    nMaxCustFilter       // size, in chars, of the buffer identified by lpstrCustomFilter.
17394>>>>>>>>>    DWord    nFilterIndex         // index of the currently selected filter
17394>>>>>>>>>    Pointer  lpstrFile            // Pointer to a buffer that contains the file name(s)
17394>>>>>>>>>    DWord    nMaxFile             // Size, in CHARs, of the buffer pointed to by lpstrFile.
17394>>>>>>>>>    Integer  iMissingAlignment2
17394>>>>>>>>>    Pointer  lpstrFileTitle       // Pointer to a buffer that receives the file name and extension
17394>>>>>>>>>    DWord    nMaxFileTitle        // size, in CHARs, of the buffer pointed to by lpstrFileTitle
17394>>>>>>>>>    Integer  iMissingAlignment3
17394>>>>>>>>>    Pointer  lpstrInitialDir      // Pointer to a NULL terminated string that can specify the initial directory.
17394>>>>>>>>>    Pointer  lpstrTitle           // Pointer to a string to be placed in the title bar of the dialog box.
17394>>>>>>>>>    DWord    ofnFlags             // set of bit flags you can use to initialize the dialog box.
17394>>>>>>>>>    Short    nFileOffset          // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name in the string pointed to by lpstrFile.
17394>>>>>>>>>    Short    nFileExtension       // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name extension in the string pointed to by lpstrFile.
17394>>>>>>>>>    Pointer  lpstrDefExt          // Pointer to a buffer that contains the default extension.
17394>>>>>>>>>    Longptr  lCustData            // Specifies application-defined data that the system passes to the hook procedure identified by the lpfnHook member.
17394>>>>>>>>>    Pointer  lpfnHook             // Pointer to a hook procedure.
17394>>>>>>>>>    Pointer  lpTemplateName       // Pointer to a null-terminated string that names a dialog template resource in the module identified by the hInstance member.
17394>>>>>>>>>    Pointer  lpvReserved          // Reserved
17394>>>>>>>>>    DWord    dwReserved           // Reserved
17394>>>>>>>>>    DWord    FlagsEx              // A set of bit flags you can use to initialize the dialog box.
17394>>>>>>>>>End_Struct
17394>>>>>>>>>
17394>>>>>>>>>Define OFN_READONLY               for |CI$000001
17394>>>>>>>>>Define OFN_OVERWRITEPROMPT        for |CI$000002
17394>>>>>>>>>Define OFN_HIDEREADONLY           for |CI$000004
17394>>>>>>>>>Define OFN_NOCHANGEDIR            for |CI$000008
17394>>>>>>>>>Define OFN_NOVALIDATE             for |CI$000100
17394>>>>>>>>>Define OFN_ALLOWMULTISELECT       for |CI$000200
17394>>>>>>>>>Define OFN_EXTENSIONDIFFERENT     for |CI$000400
17394>>>>>>>>>Define OFN_PATHMUSTEXIST          for |CI$000800
17394>>>>>>>>>Define OFN_FILEMUSTEXIST          for |CI$001000
17394>>>>>>>>>Define OFN_CREATEPROMPT           for |CI$002000
17394>>>>>>>>>Define OFN_SHAREAWARE             for |CI$004000
17394>>>>>>>>>Define OFN_NOREADONLYRETURN       for |CI$008000
17394>>>>>>>>>Define OFN_NOTESTFILECREATE       for |CI$010000
17394>>>>>>>>>Define OFN_EXPLORER               for |CI$080000     // new look commdlg
17394>>>>>>>>>
17394>>>>>>>>>Class AbstractFileDialog is a cObject
17395>>>>>>>>>    
17395>>>>>>>>>    Procedure Construct_Object
17397>>>>>>>>>        Forward Send Construct_Object
17399>>>>>>>>>        
17399>>>>>>>>>        Property String  Filter_String
17400>>>>>>>>>        Property String  Initial_Folder
17401>>>>>>>>>        Property String  File_Name
17402>>>>>>>>>        Property String  File_Title
17403>>>>>>>>>        Property String  Dialog_Caption
17404>>>>>>>>>        Property Integer Filter_Index          1
17405>>>>>>>>>        Property Integer HideReadOnly_State    False
17406>>>>>>>>>        Property Integer TickReadOnly_State    False
17407>>>>>>>>>        Property Integer AllowReadOnly_State   True
17408>>>>>>>>>        Property Integer FileMustExist_State   True
17409>>>>>>>>>        Property Integer PathMustExist_State   True
17410>>>>>>>>>        Property Integer CreatePrompt_State    True
17411>>>>>>>>>        Property Integer ShowFileTitle_State   False
17412>>>>>>>>>        Property Integer OverwritePrompt_State False
17413>>>>>>>>>        Property Integer NoChangeDir_State     False
17414>>>>>>>>>        
17414>>>>>>>>>        Property Boolean Private_MultiSelect_State False
17415>>>>>>>>>        
17415>>>>>>>>>        Property String[] Private_Selected_Files
17416>>>>>>>>>        
17416>>>>>>>>>        Property Integer PrivateExternal_msg
17417>>>>>>>>>        
17417>>>>>>>>>        //Set Focus_Mode To No_Activate
17417>>>>>>>>>    End_Procedure
17418>>>>>>>>>    
17418>>>>>>>>>    Function OwnerHandle Returns Handle
17420>>>>>>>>>        Handle hWnd
17420>>>>>>>>>        Handle hoObj
17420>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
17421>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
17422>>>>>>>>>        Function_Return hWnd
17423>>>>>>>>>    End_Function
17424>>>>>>>>>    
17424>>>>>>>>>    
17424>>>>>>>>>    Function Show_Dialog Returns Integer // bool
17426>>>>>>>>>        Handle hWnd
17426>>>>>>>>>        Integer bOK iFilter iFlags bHideRO bTickRO bFileExist bPathExist iMsg
17426>>>>>>>>>        Integer icInitDir bCreatePrompt bOverwritePrompt bAllowReadOnly
17426>>>>>>>>>        Integer iPos iCount
17426>>>>>>>>>        Integer bNoChangeDir
17426>>>>>>>>>        Pointer lpsFileTitle lpsFileName lpsFilter lpsInitDir
17426>>>>>>>>>        Pointer lpsTitle lpsDefExt
17426>>>>>>>>>        WString sFileName sFileTitle sFilter sInitDir sTitle sDefExt
17426>>>>>>>>>        Pointer lpOpenFileData
17426>>>>>>>>>        Boolean bMultiSelect
17426>>>>>>>>>        String[] sFiles
17427>>>>>>>>>        TOpenFileName OpenFileData
17427>>>>>>>>>        TOpenFileName OpenFileData
17427>>>>>>>>>        
17427>>>>>>>>>        //Delegate Get Container_Handle To hWnd
17427>>>>>>>>>        Get OwnerHandle to hWnd
17428>>>>>>>>>        
17428>>>>>>>>>        If (ShowFileTitle_State(Self)) Begin
17430>>>>>>>>>            Get File_Title to sFileName
17431>>>>>>>>>        End
17431>>>>>>>>>>
17431>>>>>>>>>        
17431>>>>>>>>>        Get private_MultiSelect_State to bMultiSelect
17432>>>>>>>>>        
17432>>>>>>>>>        Get Initial_Folder        to sInitDir
17433>>>>>>>>>        Get Dialog_Caption        to sTitle
17434>>>>>>>>>        Get Filter_String         to sFilter
17435>>>>>>>>>        Get HideReadOnly_State    to bHideRO
17436>>>>>>>>>        Get TickReadOnly_State    to bTickRO
17437>>>>>>>>>        Get FileMustExist_State   to bFileExist
17438>>>>>>>>>        Get PathMustExist_State   to bPathExist
17439>>>>>>>>>        Get CreatePrompt_State    to bCreatePrompt
17440>>>>>>>>>        Get OverwritePrompt_State to bOverwritePrompt
17441>>>>>>>>>        Get AllowReadOnly_State   to bAllowReadOnly
17442>>>>>>>>>        Get NoChangeDir_State     to bNoChangeDir
17443>>>>>>>>>        Get Filter_Index          to iFilter
17444>>>>>>>>>        
17444>>>>>>>>>        Move (sFilter + Character(0) + Character(0)) to sFilter
17445>>>>>>>>>        Move (Replaces('|', sFilter, Character(0))) to sFilter
17446>>>>>>>>>        
17446>>>>>>>>>        Append sInitDir   (character(0))
17447>>>>>>>>>        Append sFileTitle (Repeat(character(0),32000))
17448>>>>>>>>>        Append sFileName  (Repeat(character(0),32000))
17449>>>>>>>>>        Append sTitle     (Repeat(character(0),255))
17450>>>>>>>>>        Append sDefExt    (character(0))
17451>>>>>>>>>        
17451>>>>>>>>>        Move (AddressOf(sInitDir))   to lpsInitDir
17452>>>>>>>>>        Move (AddressOf(sFileName))  to lpsFileName
17453>>>>>>>>>        Move (AddressOf(sFileTitle)) to lpsFileTitle
17454>>>>>>>>>        Move (AddressOf(sTitle))     to lpsTitle
17455>>>>>>>>>        Move (AddressOf(sDefExt))    to lpsDefExt
17456>>>>>>>>>        Move (AddressOf(sFilter))    to lpsFilter
17457>>>>>>>>>        
17457>>>>>>>>>        
17457>>>>>>>>>        If (bMultiSelect) Begin
17459>>>>>>>>>            Move (OFN_EXPLORER + OFN_ALLOWMULTISELECT) to iFlags  // Multi-select!
17460>>>>>>>>>        End
17460>>>>>>>>>>
17460>>>>>>>>>        
17460>>>>>>>>>        If bFileExist ;            Move (iFlags + OFN_FILEMUSTEXIST)    to iFlags
17463>>>>>>>>>        If bPathExist ;            Move (iFlags + OFN_PATHMUSTEXIST)    to iFlags
17466>>>>>>>>>        If bHideRO ;            Move (iFlags + OFN_HIDEREADONLY)     to iFlags
17469>>>>>>>>>        If bTickRO ;            Move (iFlags + OFN_READONLY)         to iFlags
17472>>>>>>>>>        If bCreatePrompt ;            Move (iFlags + OFN_CREATEPROMPT)     to iFlags
17475>>>>>>>>>        If bOverwritePrompt ;            Move (iFlags + OFN_OVERWRITEPROMPT)  to iFlags
17478>>>>>>>>>        If not bAllowReadOnly ;            Move (iFlags + OFN_NOREADONLYRETURN) to iFlags
17481>>>>>>>>>        If bNoChangeDir ;            Move (iFlags + OFN_NOCHANGEDIR)      to iFlags
17484>>>>>>>>>        
17484>>>>>>>>>        Move (SizeOfType(TOpenFileName)) to OpenFileData.lStructSize
17485>>>>>>>>>        Move hWnd         to OpenFileData.hWndOwner
17486>>>>>>>>>        Move iFilter      to OpenFileData.nFilterIndex
17487>>>>>>>>>        Move lpsFileName  to OpenFileData.lpstrFile
17488>>>>>>>>>        
17488>>>>>>>>>        If (sInitDir <> '') Begin
17490>>>>>>>>>            Move lpsInitDir    to OpenFileData.lpstrInitialDir
17491>>>>>>>>>        End
17491>>>>>>>>>>
17491>>>>>>>>>        
17491>>>>>>>>>        If (sTitle <> '') Begin
17493>>>>>>>>>            Move lpsTitle      to OpenFileData.lpstrTitle
17494>>>>>>>>>        End
17494>>>>>>>>>>
17494>>>>>>>>>        
17494>>>>>>>>>        Move 32000             to OpenFileData.nMaxFileTitle
17495>>>>>>>>>        Move 32000             to OpenFileData.nMaxFile
17496>>>>>>>>>        Move lpsFileTitle      to OpenFileData.lpstrFileTitle
17497>>>>>>>>>        Move iFlags            to OpenFileData.ofnFlags
17498>>>>>>>>>        Move lpsFilter         to OpenFileData.lpstrFilter
17499>>>>>>>>>        Move lpsDefExt         to OpenFileData.lpstrDefExt
17500>>>>>>>>>        
17500>>>>>>>>>        Move (AddressOf(OpenFileData)) to lpOpenFileData
17501>>>>>>>>>        
17501>>>>>>>>>        Get PrivateExternal_msg to iMsg
17502>>>>>>>>>        If (iMsg = Get_GetOpenFileNameW) ;            Move (GetOpenFileNameW (lpOpenFileData)) to bOK
17505>>>>>>>>>        If (iMsg = Get_GetSaveFileNameW) ;            Move (GetSaveFileNameW (lpOpenFileData)) to bOK
17508>>>>>>>>>        
17508>>>>>>>>>        If bOK Begin
17510>>>>>>>>>            Move OpenFileData.ofnFlags     to iFlags
17511>>>>>>>>>            Move OpenFileData.nFilterIndex to iFilter
17512>>>>>>>>>            Move OpenFileData.nFileOffset  to icInitDir
17513>>>>>>>>>            
17513>>>>>>>>>            Move (CString(Left(sFileName, icInitDir))) to sInitDir    // Trim trailing null
17514>>>>>>>>>            Set Initial_Folder     to sInitDir
17515>>>>>>>>>            
17515>>>>>>>>>            Set TickReadOnly_State to (iFlags iand OFN_READONLY)
17516>>>>>>>>>            Set Filter_Index       to iFilter
17517>>>>>>>>>
17517>>>>>>>>>            Set File_Name          to (CString( sFileName ))
17518>>>>>>>>>            Set File_Title         to (CString( sFileTitle ))
17519>>>>>>>>>            
17519>>>>>>>>>            If (bMultiSelect) Begin
17521>>>>>>>>>                // If this is a multi-files dialog then parse out the array of selected files....
17521>>>>>>>>>                If (Right(sInitDir, 1) = "\") ;                    Move (Left(sInitDir, Length(sInitDir)-1)) to sInitDir     // Trim trailing :\". This is only there if 1 file was selected!
17524>>>>>>>>>                
17524>>>>>>>>>                // Get the null delimited string of file names into the sFiles array....
17524>>>>>>>>>                Move 0 to iCount
17525>>>>>>>>>                Move (Right(sFileName, Length(sFileName) - icInitDir)) to sFileName    // Strip the path info (we already have it)
17526>>>>>>>>>                
17526>>>>>>>>>                Repeat
17526>>>>>>>>>>
17526>>>>>>>>>                    // Get the next filename....
17526>>>>>>>>>                    Move (Pos(Character(0), sFileName)) to iPos   // Filenames are null delimeted
17527>>>>>>>>>                    
17527>>>>>>>>>                    If (iPos > 1) Begin
17529>>>>>>>>>                        Move (sInitDir + "\" + CString(Left(sFileName, iPos))) to sFiles[iCount]
17530>>>>>>>>>                        Move (Right(sFileName, Length(sFileName) - iPos)) to sFileName
17531>>>>>>>>>                        Increment iCount
17532>>>>>>>>>                    End
17532>>>>>>>>>>
17532>>>>>>>>>                Until (iPos <= 1)
17534>>>>>>>>>            End
17534>>>>>>>>>>
17534>>>>>>>>>            Else Begin
17535>>>>>>>>>                Move (CString(sFileName)) to sFiles[0]
17536>>>>>>>>>            End
17536>>>>>>>>>>
17536>>>>>>>>>            
17536>>>>>>>>>            Set private_Selected_Files to sFiles
17537>>>>>>>>>        End
17537>>>>>>>>>>
17537>>>>>>>>>        Function_Return (bOK)
17538>>>>>>>>>    End_Function
17539>>>>>>>>>End_Class
17540>>>>>>>>>
17540>>>>>>>>>Class OpenDialog is an AbstractFileDialog
17541>>>>>>>>>    Procedure Construct_Object
17543>>>>>>>>>        Forward Send Construct_Object
17545>>>>>>>>>        Set PrivateExternal_msg to get_GetOpenFileNameW
17546>>>>>>>>>    End_Procedure
17547>>>>>>>>>    
17547>>>>>>>>>    Procedure Set MultiSelect_State Boolean bState
17549>>>>>>>>>        Set private_MultiSelect_State to bState
17550>>>>>>>>>    End_Procedure
17551>>>>>>>>>    
17551>>>>>>>>>    Function MultiSelect_State Returns Boolean
17553>>>>>>>>>        Boolean bState
17553>>>>>>>>>        Get private_MultiSelect_State to bState
17554>>>>>>>>>        Function_Return bState
17555>>>>>>>>>    End_Function
17556>>>>>>>>>    
17556>>>>>>>>>    Function Selected_Files Returns String[]
17558>>>>>>>>>        String[] sFiles
17559>>>>>>>>>        Get private_Selected_Files to sFiles
17560>>>>>>>>>        Function_Return sFiles
17561>>>>>>>>>    End_Function
17562>>>>>>>>>End_Class
17563>>>>>>>>>
17563>>>>>>>>>Class SaveAsDialog is an AbstractFileDialog
17564>>>>>>>>>    Procedure Construct_Object
17566>>>>>>>>>        Forward Send Construct_Object
17568>>>>>>>>>        Set FileMustExist_State   to False
17569>>>>>>>>>        Set CreatePrompt_State    to False
17570>>>>>>>>>        Set ShowFileTitle_State   to True
17571>>>>>>>>>        Set OverwritePrompt_State to True
17572>>>>>>>>>        Set HideReadOnly_State    to True
17573>>>>>>>>>        Set PrivateExternal_msg to get_GetSaveFileNameW
17574>>>>>>>>>    End_Procedure
17575>>>>>>>>>End_Class
17576>>>>>>>>>
17576>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\cvFileDialogs.pkg)
17576>>>>>>>>>//***************************************************************************
17576>>>>>>>>>//*
17576>>>>>>>>>//* Class:        cvSaveAsDialog
17576>>>>>>>>>//* Package Name: cvFileDialogs.pkg
17576>>>>>>>>>//*
17576>>>>>>>>>//***************************************************************************
17576>>>>>>>>>
17576>>>>>>>>>Use File_dlg.pkg
17576>>>>>>>>>
17576>>>>>>>>>// *WvA: 13-01-1999 Created
17576>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
17576>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
17576>>>>>>>>>// file_name.
17576>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
17577>>>>>>>>>
17577>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
17579>>>>>>>>>        Forward Send Construct_Object iImage_Id
17581>>>>>>>>>        Set HideReadOnly_State to True
17582>>>>>>>>>    End_Procedure
17583>>>>>>>>>
17583>>>>>>>>>    Function SelectedFileName Returns String
17585>>>>>>>>>        String sFileName
17585>>>>>>>>>        Move "" to sFileName
17586>>>>>>>>>        If (Show_Dialog(Self)) Begin
17588>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
17589>>>>>>>>>        End
17589>>>>>>>>>>
17589>>>>>>>>>        Function_Return sFileName
17590>>>>>>>>>    End_Function
17591>>>>>>>>>End_Class
17592>>>>>>>>>
17592>>>>>>>>>// *WvA: 13-01-1999 Created
17592>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
17592>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
17592>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
17592>>>>>>>>>//                   file-open dialog
17592>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
17594>>>>>>>>>    String sSelectedFile
17594>>>>>>>>>    Integer hoOpenFileDialog
17594>>>>>>>>>
17594>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
17596>>>>>>>>>
17596>>>>>>>>>        Set Dialog_Caption    to sCaptionText
17597>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
17598>>>>>>>>>        Set Initial_Folder    to sInitialFolder
17599>>>>>>>>>
17599>>>>>>>>>        Move Self       to hoOpenFileDialog
17600>>>>>>>>>    End_Object
17601>>>>>>>>>
17601>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
17602>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
17603>>>>>>>>>    Function_Return sSelectedFile
17604>>>>>>>>>End_Function
17605>>>>>>>>>
17605>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
17606>>>>>>>>>
17606>>>>>>>>>    Procedure Construct_Object
17608>>>>>>>>>        Forward Send Construct_Object
17610>>>>>>>>>        Set HideReadOnly_State to True
17611>>>>>>>>>    End_Procedure
17612>>>>>>>>>
17612>>>>>>>>>    Function SelectedFileName Returns String
17614>>>>>>>>>        String sFileName
17614>>>>>>>>>        Move "" to sFileName
17615>>>>>>>>>        If (Show_Dialog(Self)) Begin
17617>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
17618>>>>>>>>>        End
17618>>>>>>>>>>
17618>>>>>>>>>        Function_Return sFileName
17619>>>>>>>>>    End_Function
17620>>>>>>>>>
17620>>>>>>>>>End_Class
17621>>>>>>>>>
17621>>>>>>>>>// Added optional default filename as suggested by Nils
17621>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
17623>>>>>>>>>    String sSelectedFile
17623>>>>>>>>>    Integer hoDialog
17623>>>>>>>>>
17623>>>>>>>>>    Move "" to sSelectedFile
17624>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
17625>>>>>>>>>    If (hoDialog) Begin
17627>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
17627>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
17628>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
17629>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
17630>>>>>>>>>        If (Num_Arguments = 4) Begin
17632>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
17633>>>>>>>>>        End
17633>>>>>>>>>>
17633>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
17634>>>>>>>>>        Send Destroy of hoDialog
17635>>>>>>>>>    End
17635>>>>>>>>>>
17635>>>>>>>>>    Function_Return sSelectedFile
17636>>>>>>>>>End_Function
17637>>>>>>>Use Seq_chnl.pkg
17637>>>>>>>
17637>>>>>>>Use windows.pkg
17637>>>>>>>Use Dll.pkg
17637>>>>>>>
17637>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.pkg)
17637>>>>>>>>>// This code is part of VDF GUIdance
17637>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
17637>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
17637>>>>>>>>>// VDF GUIdance is a mutual project of
17637>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
17637>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
17637>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
17637>>>>>>>>>//
17637>>>>>>>>>//
17637>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
17637>>>>>>>>>// Unicode variant
17637>>>>>>>>>
17637>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh20\vwin32fhW.h)
17637>>>>>>>>>>>//TH-Header
17637>>>>>>>>>>>//*****************************************************************************************
17637>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
17637>>>>>>>>>>>// All rights reserved.
17637>>>>>>>>>>>//
17637>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
17637>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
17637>>>>>>>>>>>// $Authors     : Wil van Antwerpen
17637>>>>>>>>>>>// $Created     : 19.02.2004  19:25
17637>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
17637>>>>>>>>>>>//
17637>>>>>>>>>>>// Contents:
17637>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
17637>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
17637>>>>>>>>>>>//*****************************************************************************************
17637>>>>>>>>>>>//TH-RevisionStart
17637>>>>>>>>>>>//TH-RevisionEnd
17637>>>>>>>>>>>
17637>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
17637>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
17637>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
17637>>>>>>>>>>>
17637>>>>>>>>>>>
17637>>>>>>>>>>>Define vMax_Path     For |CI260
17637>>>>>>>>>>>Define vMinChar      For |CI$80
17637>>>>>>>>>>>Define vMaxChar      For |CI$7F
17637>>>>>>>>>>>Define vMinShort     For |CI$8000
17637>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
17637>>>>>>>>>>>Define vMinLong      For |CI$80000000
17637>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
17637>>>>>>>>>>>Define vMaxByte      For |CI$FF
17637>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
17637>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
17637>>>>>>>>>>>
17637>>>>>>>>>>>
17637>>>>>>>>>>>
17637>>>>>>>>>>>// For FindFirstFile
17637>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
17637>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
17637>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
17637>>>>>>>>>>>
17637>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
17637>>>>>>>>>>>// the API-call ShellExecute is used.
17637>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
17637>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
17637>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
17637>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
17637>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
17637>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
17637>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
17637>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
17637>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
17637>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
17637>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
17637>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
17637>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
17637>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
17637>>>>>>>>>>>
17637>>>>>>>>>>>
17637>>>>>>>>>>>// C-Structure
17637>>>>>>>>>>>//typedef struct _browseinfo {
17637>>>>>>>>>>>//    HWND hwndOwner;
17637>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
17637>>>>>>>>>>>//    LPSTR pszDisplayName;
17637>>>>>>>>>>>//    LPCSTR lpszTitle;
17637>>>>>>>>>>>//    UINT ulFlags;
17637>>>>>>>>>>>//    BFFCALLBACK lpfn;
17637>>>>>>>>>>>//    LPARAM lParam;
17637>>>>>>>>>>>//    int iImage;
17637>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
17637>>>>>>>>>>>
17637>>>>>>>>>>>//declare C structure struct_browseinfo
17637>>>>>>>>>>>//as documented in MSDN under Windows Shell API
17637>>>>>>>>>>>Struct tvBrowseInfo
17637>>>>>>>>>>>  Handle    hWndOwner
17637>>>>>>>>>>>  Pointer   pIDLRoot
17637>>>>>>>>>>>  Pointer   pszDisplayName
17637>>>>>>>>>>>  Pointer   lpszTitle
17637>>>>>>>>>>>  DWord     ulFlags
17637>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
17637>>>>>>>>>>>  Pointer   lpfnCallback
17637>>>>>>>>>>>  LongPtr   lParam
17637>>>>>>>>>>>  DWord     iImage
17637>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
17637>>>>>>>>>>>End_Struct // tvBrowseInfo
17637>>>>>>>>>>>
17637>>>>>>>>>>>// Browsing for directory.
17637>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
17637>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
17637>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
17637>>>>>>>>>>>                                            // The callback function can set the status text by
17637>>>>>>>>>>>                                            // sending messages to the dialog box.
17637>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
17637>>>>>>>>>>>
17637>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
17637>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
17637>>>>>>>>>>>
17637>>>>>>>>>>>// message from browser
17637>>>>>>>>>>>//Define BFFM_INITIALIZED        1
17637>>>>>>>>>>>//Define BFFM_SELCHANGED         2
17637>>>>>>>>>>>
17637>>>>>>>>>>>// messages to browser
17637>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
17637>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
17637>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
17637>>>>>>>>>>>
17637>>>>>>>>>>>
17637>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
17638>>>>>>>>>>>
17638>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
17639>>>>>>>>>>>
17639>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
17640>>>>>>>>>>>
17640>>>>>>>>>>>
17640>>>>>>>>>>>
17640>>>>>>>>>>>
17640>>>>>>>>>>>Struct tvSecurity_attributes
17640>>>>>>>>>>>  DWord   nLength
17640>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
17640>>>>>>>>>>>  Pointer lpDescriptor
17640>>>>>>>>>>>  Integer bInheritHandle
17640>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
17640>>>>>>>>>>>End_Struct // tvSecurity_attributes
17640>>>>>>>>>>>
17640>>>>>>>>>>>//nLength:
17640>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
17640>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
17640>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
17640>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
17640>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
17640>>>>>>>>>>>//
17640>>>>>>>>>>>//lpSecurityDescriptor:
17640>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
17640>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
17640>>>>>>>>>>>// descriptor of the calling process.
17640>>>>>>>>>>>//
17640>>>>>>>>>>>//bInheritHandle:
17640>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
17640>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
17640>>>>>>>>>>>
17640>>>>>>>>>>>
17640>>>>>>>>>>>// BOOL CreateDirectory(
17640>>>>>>>>>>>//    LPCTSTR lpPathName,
17640>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
17640>>>>>>>>>>>//   );
17640>>>>>>>>>>>//
17640>>>>>>>>>>>// lpPathName
17640>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
17640>>>>>>>>>>>//  to be created.
17640>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
17640>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
17640>>>>>>>>>>>// lpSecurityAttributes
17640>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
17640>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
17640>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
17640>>>>>>>>>>>// Returns:
17640>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
17640>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
17640>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
17641>>>>>>>>>>>
17641>>>>>>>>>>>
17641>>>>>>>>>>>// lpPathName
17641>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
17641>>>>>>>>>>>//  to be removed.
17641>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
17641>>>>>>>>>>>// Returns:
17641>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
17641>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
17641>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
17642>>>>>>>>>>>
17642>>>>>>>>>>>
17642>>>>>>>>>>>
17642>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
17642>>>>>>>>>>>// executable file or a document file.
17642>>>>>>>>>>>//
17642>>>>>>>>>>>// Operation can be one of the following:
17642>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
17642>>>>>>>>>>>//            The file can be an executable file or a document file.
17642>>>>>>>>>>>//            The file can be a folder to open.
17642>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
17642>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
17642>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
17642>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
17642>>>>>>>>>>>//
17642>>>>>>>>>>>// Return Values:
17642>>>>>>>>>>>//
17642>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
17642>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
17642>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
17642>>>>>>>>>>>//
17642>>>>>>>>>>>// The following table lists these error values:
17642>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
17642>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
17642>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
17642>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
17642>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
17642>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
17642>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
17642>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
17642>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
17642>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
17642>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
17642>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
17642>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
17642>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
17642>>>>>>>>>>>
17642>>>>>>>>>>>
17642>>>>>>>>>>>
17642>>>>>>>>>>>// Code to open the program that is associated with the selected file.
17642>>>>>>>>>>>//
17642>>>>>>>>>>>// External function call used in Procedure DoStartDocument
17642>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
17643>>>>>>>>>>>
17643>>>>>>>>>>>
17643>>>>>>>>>>>
17643>>>>>>>>>>>
17643>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
17643>>>>>>>>>>>Define vFO_COPY                For |CI$0002
17643>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
17643>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
17643>>>>>>>>>>>
17643>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
17643>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
17643>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
17643>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
17643>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
17643>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
17643>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
17643>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
17643>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
17643>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
17643>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
17643>>>>>>>>>>>
17643>>>>>>>>>>>Struct tvShFileOpStruct
17643>>>>>>>>>>>  Handle   hWnd
17643>>>>>>>>>>>  UInteger wFunc
17643>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
17643>>>>>>>>>>>  Pointer  pFrom
17643>>>>>>>>>>>  Pointer  pTo
17643>>>>>>>>>>>  Short    fFlags
17643>>>>>>>>>>>  Integer  fAnyOperationsAborted
17643>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
17643>>>>>>>>>>>  Pointer  hNameMappings
17643>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
17643>>>>>>>>>>>End_Struct // tvShFileOpStruct
17643>>>>>>>>>>>
17643>>>>>>>>>>>// hwnd
17643>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
17643>>>>>>>>>>>
17643>>>>>>>>>>>// wFunc
17643>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
17643>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
17643>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
17643>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
17643>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
17643>>>>>>>>>>>
17643>>>>>>>>>>>// pFrom
17643>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
17643>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
17643>>>>>>>>>>>
17643>>>>>>>>>>>// pTo
17643>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
17643>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
17643>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
17643>>>>>>>>>>>//   double null-terminated.
17643>>>>>>>>>>>
17643>>>>>>>>>>>// fAnyOperationsAborted
17643>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
17643>>>>>>>>>>>//   were completed or FALSE otherwise.
17643>>>>>>>>>>>
17643>>>>>>>>>>>
17643>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
17643>>>>>>>>>>>// This can be a file or a folder.
17643>>>>>>>>>>>// With thanks to Andrew S Kaplan
17643>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
17644>>>>>>>>>>>
17644>>>>>>>>>>>
17644>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
17644>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
17645>>>>>>>>>>>
17645>>>>>>>>>>>
17645>>>>>>>>>>>
17645>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17645>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
17645>>>>>>>>>>>//   Pointer lpPathName ;
17645>>>>>>>>>>>//   Pointer lpPrefixString ;
17645>>>>>>>>>>>//   Integer uUnique ;
17645>>>>>>>>>>>//   Pointer lpTempFileName ;
17645>>>>>>>>>>>//   Returns Integer
17645>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
17645>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
17646>>>>>>>>>>>
17646>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
17647>>>>>>>>>>>
17647>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
17648>>>>>>>>>>>
17648>>>>>>>>>>>// from:
17648>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
17648>>>>>>>>>>>//
17648>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
17648>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
17648>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
17648>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
17648>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
17648>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
17648>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
17648>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
17648>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
17648>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
17648>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
17648>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
17648>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
17648>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
17648>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
17648>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
17648>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
17648>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
17648>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
17648>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
17648>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
17648>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
17648>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
17648>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
17648>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
17648>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
17648>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
17648>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
17648>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
17648>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
17648>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
17648>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
17648>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
17648>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
17648>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
17648>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
17648>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
17648>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
17648>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
17648>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
17648>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
17648>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
17648>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
17648>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
17648>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
17648>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
17648>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
17648>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
17648>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
17648>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
17648>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
17648>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
17648>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
17648>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
17648>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
17648>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
17648>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
17648>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
17648>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
17648>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
17648>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
17648>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
17648>>>>>>>>>>>
17648>>>>>>>>>>>
17648>>>>>>>>>>>//HRESULT SHGetFolderPath(
17648>>>>>>>>>>>//    HWND hwndOwner,
17648>>>>>>>>>>>//    int nFolder,
17648>>>>>>>>>>>//    HANDLE hToken,
17648>>>>>>>>>>>//    DWORD dwFlags,
17648>>>>>>>>>>>//    LPTSTR pszPath
17648>>>>>>>>>>>//);
17648>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
17648>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
17648>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
17648>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
17648>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
17648>>>>>>>>>>>//
17648>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
17649>>>>>>>>>>>
17649>>>>>>>>>>>
17649>>>>>>>>>>>
17649>>>>>>>>>>>Struct tvWin32FindData
17649>>>>>>>>>>> Dword            dwFileAttributes
17649>>>>>>>>>>> Dword            ftCreationLowDateTime
17649>>>>>>>>>>> Dword            ftCreationHighDateTime
17649>>>>>>>>>>> dword            ftLastAccessLowDateTime
17649>>>>>>>>>>> Dword            ftLastAccessHighDateTime
17649>>>>>>>>>>> Dword            ftLastWriteLowDateTime
17649>>>>>>>>>>> Dword            ftLastWriteHighDateTime
17649>>>>>>>>>>> Dword            nFileSizeHigh
17649>>>>>>>>>>> Dword            nFileSizeLow
17649>>>>>>>>>>> Dword            dwReserved0
17649>>>>>>>>>>> Dword            dwReserved1
17649>>>>>>>>>>> Short[vMax_Path] cFileName
17649>>>>>>>>>>> Short[14]        cAlternateFileName
17649>>>>>>>>>>>End_Struct
17649>>>>>>>>>>>
17649>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17649>>>>>>>>>>>// lpFileName      : address of name of file to search for
17649>>>>>>>>>>>// lpFindFileData  : address of returned information
17649>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
17650>>>>>>>>>>>
17650>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17650>>>>>>>>>>>// hFindFile       : handle of search
17650>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
17650>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
17651>>>>>>>>>>>
17651>>>>>>>>>>>
17651>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17651>>>>>>>>>>>//  hFindFile      : file search handle
17651>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
17652>>>>>>>>>>>
17652>>>>>>>>>>>
17652>>>>>>>>>>>
17652>>>>>>>>>>>Struct tvFileTime
17652>>>>>>>>>>>  DWord dwLowDateTime
17652>>>>>>>>>>>  DWord dwHighDateTime
17652>>>>>>>>>>>End_Struct
17652>>>>>>>>>>>
17652>>>>>>>>>>>
17652>>>>>>>>>>>Struct tvSystemTime
17652>>>>>>>>>>>  UShort wYear
17652>>>>>>>>>>>  UShort wMonth
17652>>>>>>>>>>>  UShort wDayOfWeek
17652>>>>>>>>>>>  UShort wDay
17652>>>>>>>>>>>  UShort wHour
17652>>>>>>>>>>>  UShort wMinute
17652>>>>>>>>>>>  UShort wSecond
17652>>>>>>>>>>>  UShort wMilliSeconds
17652>>>>>>>>>>>End_Struct
17652>>>>>>>>>>>
17652>>>>>>>>>>>
17652>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17652>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
17652>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
17652>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
17653>>>>>>>>>>>
17653>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17653>>>>>>>>>>>// This function formats the time in a picture-string passed
17653>>>>>>>>>>>//
17653>>>>>>>>>>>// Picture      Meaning
17653>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
17653>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
17653>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
17653>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
17653>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
17653>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
17653>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
17653>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
17653>>>>>>>>>>>//    t         One character time marker string, such as A or P
17653>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
17653>>>>>>>>>>>//
17653>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
17653>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
17653>>>>>>>>>>>
17653>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
17654>>>>>>>>>>>
17654>>>>>>>>>>>
17654>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17654>>>>>>>>>>>// This function formats the date in a picture-string passed
17654>>>>>>>>>>>//
17654>>>>>>>>>>>// Picture      Meaning
17654>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
17654>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
17654>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
17654>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
17654>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
17654>>>>>>>>>>>//              value associated with the specified locale.
17654>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
17654>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
17654>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
17654>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
17654>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
17654>>>>>>>>>>>//              associated with the specified locale.
17654>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
17654>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
17654>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
17654>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
17654>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
17654>>>>>>>>>>>//              does not have an associated era or period string.
17654>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
17654>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
17654>>>>>>>>>>>
17654>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
17655>>>>>>>>>>>
17655>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
17655>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
17655>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
17655>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
17655>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
17655>>>>>>>>>>>
17655>>>>>>>>>>>//  Date Flags for GetDateFormatW.
17655>>>>>>>>>>>//
17655>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
17655>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
17655>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
17655>>>>>>>>>>>
17655>>>>>>>>>>>
17655>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>>// **WvA: 20-02-2004
17656>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
17656>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
17656>>>>>>>>>>>// incorrectly into an unsigned integer.
17656>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
17656>>>>>>>>>>>// It does smell a bit fishy though
17656>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
17656>>>>>>>>>>>
17656>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
17656>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
17656>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
17656>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
17656>>>>>>>>>>>
17656>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
17656>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
17656>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
17656>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>> // Courtesy Of Steve Walter,
17656>>>>>>>>>>> // USA Software, Inc
17656>>>>>>>>>>> // Format a disk
17656>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
17656>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
17657>>>>>>>>>>>
17657>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
17657>>>>>>>>>>>
17657>>>>>>>>>>>// SHCreateDirectoryEx
17657>>>>>>>>>>>
17657>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
17657>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
17657>>>>>>>>>>>//
17657>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
17657>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
17657>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
17657>>>>>>>>>>>//
17657>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
17657>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
17657>>>>>>>>>>>//        ERROR_CANCELLED.
17657>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
17657>>>>>>>>>>>
17657>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
17657>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
17657>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
17657>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
17657>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
17657>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
17657>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
17657>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
17657>>>>>>>>>>>
17657>>>>>>>>>>>//        int SHCreateDirectoryEx(
17657>>>>>>>>>>>//            HWND hwnd,
17657>>>>>>>>>>>//            LPCTSTR pszPath,
17657>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
17657>>>>>>>>>>>//        );
17657>>>>>>>>>>>
17657>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
17658>>>>>>>>>>>
17658>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
17659>>>>>>>>>
17659>>>>>>>>>
17659>>>>>>>>>
17659>>>>>>>>>// Does the directory exist? - No = false, Yes = True
17659>>>>>>>>>// This also works with UNC path encoding and wildcards
17659>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
17661>>>>>>>>>    Boolean bFolderExists
17661>>>>>>>>>    Boolean bStop
17661>>>>>>>>>    String  sFolder sTmp
17661>>>>>>>>>    Integer iCh
17661>>>>>>>>>
17661>>>>>>>>>    If (sFolderName = "") Begin
17663>>>>>>>>>        Function_Return False
17664>>>>>>>>>    End
17664>>>>>>>>>>
17664>>>>>>>>>
17664>>>>>>>>>    Move True  to bFolderExists
17665>>>>>>>>>    Move False to bStop
17666>>>>>>>>>    Move "dir:" to sFolder
17667>>>>>>>>>    Append sFolder sFolderName
17668>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
17669>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
17671>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
17672>>>>>>>>>>
17672>>>>>>>>>        Function_Return False
17673>>>>>>>>>    End
17673>>>>>>>>>>
17673>>>>>>>>>    Direct_Input channel iCh sFolder
17675>>>>>>>>>    Repeat
17675>>>>>>>>>>
17675>>>>>>>>>        Readln channel iCh sTmp
17677>>>>>>>>>        Move (SeqEof) to bStop
17678>>>>>>>>>        If (Trim(sTmp)="") Begin
17680>>>>>>>>>            Move False to bFolderExists
17681>>>>>>>>>        End
17681>>>>>>>>>>
17681>>>>>>>>>        Else Begin
17682>>>>>>>>>            Move True to bFolderExists
17683>>>>>>>>>            Move True to bStop
17684>>>>>>>>>        End
17684>>>>>>>>>>
17684>>>>>>>>>    Until (bStop)
17686>>>>>>>>>    Close_Input channel iCh
17688>>>>>>>>>    Send Seq_Release_Channel iCh
17689>>>>>>>>>    Function_Return bFolderExists
17690>>>>>>>>>End_Function
17691>>>>>>>>>
17691>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
17691>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
17693>>>>>>>>>    String  sPath
17693>>>>>>>>>    WString sFolder sTitle
17693>>>>>>>>>    Pointer lpItemIdList
17693>>>>>>>>>    Integer iFolderSelected iRetval
17693>>>>>>>>>    tvBrowseInfo BrowseInfo
17693>>>>>>>>>    tvBrowseInfo BrowseInfo
17693>>>>>>>>>
17693>>>>>>>>>    Move "" to sPath
17694>>>>>>>>>    If (sDialogTitle<>"") Begin
17696>>>>>>>>>        Move sDialogTitle to sTitle
17697>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
17697>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
17697>>>>>>>>>        // These chars are correctly shown if no toansi is used.
17697>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
17697>>>>>>>>>        // selected it will always be valid.
17697>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
17698>>>>>>>>>    End
17698>>>>>>>>>>
17698>>>>>>>>>
17698>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
17699>>>>>>>>>
17699>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
17699>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
17699>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
17700>>>>>>>>>
17700>>>>>>>>>    // null 128 chars into var (make space)
17700>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17701>>>>>>>>>
17701>>>>>>>>>    // select folder
17701>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
17702>>>>>>>>>    // get selected folder name
17702>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
17703>>>>>>>>>
17703>>>>>>>>>    // release memory resources that are used by the ItemIdList
17703>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
17704>>>>>>>>>
17704>>>>>>>>>    If (iFolderSelected<>0) Begin
17706>>>>>>>>>        Move (CString(sFolder)) to sPath
17707>>>>>>>>>    End
17707>>>>>>>>>>
17707>>>>>>>>>    Function_Return  sPath
17708>>>>>>>>>End_Function
17709>>>>>>>>>
17709>>>>>>>>>// returns 0 if the folder is created.
17709>>>>>>>>>//         1 if the API-call returned an error.
17709>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
17711>>>>>>>>>    Integer  iRetval bFolderCreated
17711>>>>>>>>>    WString  sFolder
17711>>>>>>>>>    tvSecurity_attributes SA
17711>>>>>>>>>    tvSecurity_attributes SA
17711>>>>>>>>>
17711>>>>>>>>>    Move False to bFolderCreated
17712>>>>>>>>>    If (sNewFolder <> "") Begin
17714>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
17715>>>>>>>>>        Move  0                                  to SA.lpDescriptor
17716>>>>>>>>>        Move  1                                  to SA.bInheritHandle
17717>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
17718>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
17719>>>>>>>>>    End
17719>>>>>>>>>>
17719>>>>>>>>>
17719>>>>>>>>>    If (bFolderCreated=false) Begin
17721>>>>>>>>>        Move 1 to iRetVal
17722>>>>>>>>>    End
17722>>>>>>>>>>
17722>>>>>>>>>    Function_Return iRetVal
17723>>>>>>>>>End_Function
17724>>>>>>>>>
17724>>>>>>>>>// **WvA: 03-02-2002 Function created.
17724>>>>>>>>>// With this function one can remove a directory.
17724>>>>>>>>>// returns 0 if the folder is removed.
17724>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
17724>>>>>>>>>//         2 if the folder did not exist
17724>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
17724>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
17726>>>>>>>>>    Boolean bRemoved
17726>>>>>>>>>    WString sPath
17726>>>>>>>>>    Integer iRetval
17726>>>>>>>>>
17726>>>>>>>>>    Move 0     to iRetVal
17727>>>>>>>>>    Move False to bRemoved
17728>>>>>>>>>    Move (Trim(sFolder)) to sFolder
17729>>>>>>>>>    If (sFolder="") Begin
17731>>>>>>>>>        Move 3 to iRetVal
17732>>>>>>>>>    End
17732>>>>>>>>>>
17732>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
17734>>>>>>>>>        Move 2 to iRetVal
17735>>>>>>>>>    End
17735>>>>>>>>>>
17735>>>>>>>>>    If (iRetVal=0) Begin
17737>>>>>>>>>        // null MAX_PATH chars into var (make space)
17737>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
17738>>>>>>>>>        //
17738>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
17739>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
17740>>>>>>>>>    End
17740>>>>>>>>>>
17740>>>>>>>>>
17740>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
17742>>>>>>>>>        Move 1 to iRetVal
17743>>>>>>>>>    End
17743>>>>>>>>>>
17743>>>>>>>>>    Function_Return iRetVal
17744>>>>>>>>>End_Function
17745>>>>>>>>>
17745>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
17745>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
17745>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
17745>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
17747>>>>>>>>>    Handle  hInstance hWnd
17747>>>>>>>>>    // remove any leading/trailing spaces in the string
17747>>>>>>>>>    Move (Trim(sDocument)) to sDocument
17748>>>>>>>>>    Move (Trim(sPath))     to sPath
17749>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
17749>>>>>>>>>    Append sOperation   (Character(0))
17750>>>>>>>>>    Append sDocument    (Character(0))
17751>>>>>>>>>    Append sParameters  (Character(0))
17752>>>>>>>>>    Append sPath        (Character(0))
17753>>>>>>>>>
17753>>>>>>>>>    Get Window_Handle to hWnd
17754>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
17755>>>>>>>>>    If (hInstance <= 32) Begin
17757>>>>>>>>>        Send vDDE_Error_Handler hInstance
17758>>>>>>>>>    End
17758>>>>>>>>>>
17758>>>>>>>>>End_Procedure
17759>>>>>>>>>
17759>>>>>>>>>Class cShellFileOperations is a Array
17760>>>>>>>>>
17760>>>>>>>>>    Procedure Construct_Object
17762>>>>>>>>>        Forward Send Construct_Object
17764>>>>>>>>>        Property Integer piDeleteFlags        0
17765>>>>>>>>>        Property Integer piCopyFlags          0
17766>>>>>>>>>        Property Integer piMoveFlags          0
17767>>>>>>>>>        Property Integer piRenameFlags        0
17768>>>>>>>>>
17768>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
17769>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
17770>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
17771>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
17772>>>>>>>>>    End_Procedure
17773>>>>>>>>>
17773>>>>>>>>>    // This function uses the shell API to perform a file operation on the
17773>>>>>>>>>    // files supplied.
17773>>>>>>>>>    //
17773>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
17775>>>>>>>>>        Integer  iRetVal
17775>>>>>>>>>        Integer  iUserAbort
17775>>>>>>>>>        WString  wsSource wsDestination
17775>>>>>>>>>        tvShFileOpStruct FOS
17775>>>>>>>>>        tvShFileOpStruct FOS
17775>>>>>>>>>
17775>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
17776>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
17777>>>>>>>>>
17777>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
17779>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
17780>>>>>>>>>        End
17780>>>>>>>>>>
17780>>>>>>>>>
17780>>>>>>>>>        Move eOperation            to FOS.wFunc
17781>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
17782>>>>>>>>>        Move iFlags                to FOS.fFlags
17783>>>>>>>>>
17783>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
17784>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
17785>>>>>>>>>        If (iUserAbort <> 0) Begin
17787>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
17788>>>>>>>>>        End
17788>>>>>>>>>>
17788>>>>>>>>>        Function_Return (iRetVal)
17789>>>>>>>>>    End_Function
17790>>>>>>>>>
17790>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
17792>>>>>>>>>        Integer  iRetVal
17792>>>>>>>>>        Integer  iFlags
17792>>>>>>>>>
17792>>>>>>>>>        Get piDeleteFlags to iFlags
17793>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
17794>>>>>>>>>        Function_Return iRetVal
17795>>>>>>>>>    End_Function
17796>>>>>>>>>
17796>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
17798>>>>>>>>>        Integer  iRetVal
17798>>>>>>>>>        Integer  iFlags
17798>>>>>>>>>
17798>>>>>>>>>        Get piCopyFlags to iFlags
17799>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
17800>>>>>>>>>        Function_Return iRetVal
17801>>>>>>>>>    End_Function
17802>>>>>>>>>
17802>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
17804>>>>>>>>>        Integer  iRetVal
17804>>>>>>>>>        Integer  iFlags
17804>>>>>>>>>
17804>>>>>>>>>        Get piMoveFlags to iFlags
17805>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
17806>>>>>>>>>        Function_Return iRetVal
17807>>>>>>>>>    End_Function
17808>>>>>>>>>
17808>>>>>>>>>    // Rename a file or folder
17808>>>>>>>>>    // Returns a nonzero value if the operation failed.
17808>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
17810>>>>>>>>>        Integer  iRetVal
17810>>>>>>>>>        Integer  iFlags
17810>>>>>>>>>
17810>>>>>>>>>        Get piRenameFlags to iFlags
17811>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
17812>>>>>>>>>        Function_Return iRetVal
17813>>>>>>>>>    End_Function
17814>>>>>>>>>
17814>>>>>>>>>
17814>>>>>>>>>    //Example:
17814>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
17814>>>>>>>>>    //                                          mode.
17814>>>>>>>>>
17814>>>>>>>>>End_Class
17815>>>>>>>>>
17815>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
17817>>>>>>>>>End_Object
17818>>>>>>>>>
17818>>>>>>>>>// Restore to the old way of working with the shell file operations.
17818>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
17818>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
17818>>>>>>>>>Procedure vWin32fhCompatibilityMode
17820>>>>>>>>>    Integer hoSFO
17820>>>>>>>>>    Integer iFlags
17820>>>>>>>>>
17820>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
17821>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
17822>>>>>>>>>
17822>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
17823>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
17824>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
17825>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
17826>>>>>>>>>End_Procedure
17827>>>>>>>>>
17827>>>>>>>>>// Delete a file or folder
17827>>>>>>>>>// Returns a nonzero value if the operation failed.
17827>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
17829>>>>>>>>>    Integer  iRetVal
17829>>>>>>>>>
17829>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
17830>>>>>>>>>    Function_Return iRetVal
17831>>>>>>>>>End_Function
17832>>>>>>>>>
17832>>>>>>>>>// Copy a file or folder
17832>>>>>>>>>// Returns a nonzero value if the operation failed.
17832>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
17834>>>>>>>>>    Integer  iRetVal
17834>>>>>>>>>
17834>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17835>>>>>>>>>    Function_Return iRetVal
17836>>>>>>>>>End_Function
17837>>>>>>>>>
17837>>>>>>>>>// Move a file or folder
17837>>>>>>>>>// Returns a nonzero value if the operation failed.
17837>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
17839>>>>>>>>>    Integer  iRetVal
17839>>>>>>>>>
17839>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17840>>>>>>>>>    Function_Return iRetVal
17841>>>>>>>>>End_Function
17842>>>>>>>>>
17842>>>>>>>>>// Rename a file or folder
17842>>>>>>>>>// Returns a nonzero value if the operation failed.
17842>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
17844>>>>>>>>>    Integer  iRetVal
17844>>>>>>>>>
17844>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17845>>>>>>>>>    Function_Return iRetVal
17846>>>>>>>>>End_Function
17847>>>>>>>>>
17847>>>>>>>>>Function vGetWindowsDirectory Returns String
17849>>>>>>>>>    WString wDirectory
17849>>>>>>>>>    Integer iRetVal
17849>>>>>>>>>
17849>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
17850>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
17851>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
17853>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
17854>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
17855>>>>>>>>>    End
17855>>>>>>>>>>
17855>>>>>>>>>    Function_Return (CString(wDirectory))
17856>>>>>>>>>End_Function
17857>>>>>>>>>
17857>>>>>>>>>Function vGetTempPath Returns String
17859>>>>>>>>>    Integer iRetVal
17859>>>>>>>>>    WString wTempPath
17859>>>>>>>>>
17859>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
17860>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
17861>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
17863>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
17864>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
17865>>>>>>>>>    End
17865>>>>>>>>>>
17865>>>>>>>>>    Function_Return (CString(wTempPath))
17866>>>>>>>>>End_Function
17867>>>>>>>>>
17867>>>>>>>>>// Courtesy of Marco Kuipers
17867>>>>>>>>>Function vMakeTempFile Returns String
17869>>>>>>>>>    Integer iRetval
17869>>>>>>>>>    String  sTempPath
17869>>>>>>>>>    String  sTempFileName
17869>>>>>>>>>    String  sPrefixString
17869>>>>>>>>>    WString wsTempFileName
17869>>>>>>>>>
17869>>>>>>>>>    Get vGetTempPath to sTempPath
17870>>>>>>>>>    If (sTempPath = "") Begin
17872>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
17873>>>>>>>>>        If (sTempPath<>"") Begin
17875>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
17876>>>>>>>>>        End
17876>>>>>>>>>>
17876>>>>>>>>>    End
17876>>>>>>>>>>
17876>>>>>>>>>
17876>>>>>>>>>    If (sTempPath = "") Begin
17878>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
17878>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
17878>>>>>>>>>        Get_Current_Directory to sTempPath
17879>>>>>>>>>    End
17879>>>>>>>>>>
17879>>>>>>>>>
17879>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
17880>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
17882>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
17883>>>>>>>>>>
17883>>>>>>>>>    End
17883>>>>>>>>>>
17883>>>>>>>>>
17883>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
17884>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
17885>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
17886>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
17888>>>>>>>>>    //Get ShowLastError to iRetval
17888>>>>>>>>>        Move "" to sTempFileName
17889>>>>>>>>>    End
17889>>>>>>>>>>
17889>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
17890>>>>>>>>>    Function_Return sTempFileName
17891>>>>>>>>>End_Function
17892>>>>>>>>>
17892>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
17892>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
17892>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
17892>>>>>>>>>// does not take care of that.
17892>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
17894>>>>>>>>>    Integer iRetVal
17894>>>>>>>>>    String  sTempFileName
17894>>>>>>>>>    WString wTempFileName
17894>>>>>>>>>
17894>>>>>>>>>    Move (sPath+Character(0))   to sPath
17895>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
17896>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
17897>>>>>>>>>
17897>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
17898>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
17899>>>>>>>>>    Function_Return sTempFileName
17900>>>>>>>>>End_Function
17901>>>>>>>>>
17901>>>>>>>>>//
17901>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
17901>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
17901>>>>>>>>>//
17901>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
17903>>>>>>>>>    Integer iVoid
17903>>>>>>>>>    Handle  hWnd
17903>>>>>>>>>    String  sFolder
17903>>>>>>>>>    WString wFolder
17903>>>>>>>>>
17903>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
17904>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
17905>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
17906>>>>>>>>>    Move (CString(wFolder)) to sFolder
17907>>>>>>>>>    Function_Return sFolder
17908>>>>>>>>>End_Function
17909>>>>>>>>>
17909>>>>>>>>>// Courtesy Of Vincent Oorsprong
17909>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
17911>>>>>>>>>    String  sFileDateTime
17911>>>>>>>>>    WString wFormattedTime wFormattedDate
17911>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
17911>>>>>>>>>    tvFileTime   FileTime
17911>>>>>>>>>    tvFileTime   FileTime
17911>>>>>>>>>    tvSystemTime SystemTime
17911>>>>>>>>>    tvSystemTime SystemTime
17911>>>>>>>>>
17911>>>>>>>>>    Move "" to sFileDateTime
17912>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
17913>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
17914>>>>>>>>>
17914>>>>>>>>>    Move 0 to SystemTime.wYear
17915>>>>>>>>>
17915>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
17916>>>>>>>>>    If (iSuccess = 1) Begin
17918>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
17919>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
17920>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
17921>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
17922>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
17923>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
17924>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
17925>>>>>>>>>    End
17925>>>>>>>>>>
17925>>>>>>>>>    Function_Return sFileDateTime
17926>>>>>>>>>End_Function
17927>>>>>>>>>
17927>>>>>>>>>// **WvA:
17927>>>>>>>>>// A windows replacement for the standard function FileExists.
17927>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
17927>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
17927>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
17927>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
17927>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
17929>>>>>>>>>    String  sDirSep
17929>>>>>>>>>    Handle  hFindFile
17929>>>>>>>>>    Integer iVoid
17929>>>>>>>>>    tvWin32FindData FindData
17929>>>>>>>>>    tvWin32FindData FindData
17929>>>>>>>>>
17929>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
17930>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
17931>>>>>>>>>
17931>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
17933>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
17933>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
17934>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
17938>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
17939>>>>>>>>>        Loop
17940>>>>>>>>>>
17940>>>>>>>>>
17940>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17941>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
17942>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
17943>>>>>>>>>    End
17943>>>>>>>>>>
17943>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
17944>>>>>>>>>End_Function
17945>>>>>>>>>
17945>>>>>>>>>
17945>>>>>>>>>//
17945>>>>>>>>>// Returns the amount of files in the folder (if it exists)
17945>>>>>>>>>// Returns -1 if folder doesn't exist.
17945>>>>>>>>>// The files "." and ".." are not counted.
17945>>>>>>>>>//
17945>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
17947>>>>>>>>>    Boolean bFound
17947>>>>>>>>>    Handle  hFindFile
17947>>>>>>>>>    Integer iCount  iVoid
17947>>>>>>>>>    Integer iSuccess
17947>>>>>>>>>    String  sFileName
17947>>>>>>>>>    tvWin32FindData FindData
17947>>>>>>>>>    tvWin32FindData FindData
17947>>>>>>>>>
17947>>>>>>>>>    Move -1 to iCount
17948>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
17949>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
17950>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17951>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
17952>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
17953>>>>>>>>>    If (bFound) Begin
17955>>>>>>>>>        Move 0 to iCount
17956>>>>>>>>>    End
17956>>>>>>>>>>
17956>>>>>>>>>    While (bFound)
17960>>>>>>>>>        Increment iCount
17961>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
17962>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
17964>>>>>>>>>            Decrement iCount
17965>>>>>>>>>        End
17965>>>>>>>>>>
17965>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
17966>>>>>>>>>        Move (iSuccess<>0) to bFound
17967>>>>>>>>>    Loop
17968>>>>>>>>>>
17968>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
17969>>>>>>>>>    Function_Return iCount
17970>>>>>>>>>End_Function
17971>>>>>>>>>
17971>>>>>>>>>// Create the folder, including intermediate directories.
17971>>>>>>>>>// Don't panic if the folder already exists.
17971>>>>>>>>>// Michael Mullan June 2009.
17971>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
17973>>>>>>>>>    String  sFolder
17973>>>>>>>>>    Integer iRetval iFolderCreated
17973>>>>>>>>>    tvSecurity_attributes SA
17973>>>>>>>>>    tvSecurity_attributes SA
17973>>>>>>>>>
17973>>>>>>>>>    Move 0 to iFolderCreated
17974>>>>>>>>>
17974>>>>>>>>>    // null MAX_PATH chars into var (make space)
17974>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17975>>>>>>>>>    If (sNewFolder <> "") Begin
17977>>>>>>>>>
17977>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
17978>>>>>>>>>        Move  0  to SA.lpDescriptor
17979>>>>>>>>>        Move  1  to SA.bInheritHandle
17980>>>>>>>>>
17980>>>>>>>>>        //
17980>>>>>>>>>        Move (sNewFolder+"") to sFolder
17981>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
17982>>>>>>>>>    End
17982>>>>>>>>>>
17982>>>>>>>>>
17982>>>>>>>>>    If (iFolderCreated <> 0) Begin
17984>>>>>>>>>        Move 1 to iRetVal
17985>>>>>>>>>        Case Begin
17985>>>>>>>>>            Case (iFolderCreated = 161)
17987>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
17988>>>>>>>>>>
17988>>>>>>>>>                Case Break
17989>>>>>>>>>            Case (iFolderCreated = 206)
17992>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
17993>>>>>>>>>>
17993>>>>>>>>>                Case Break
17994>>>>>>>>>            Case (iFolderCreated = 3)
17997>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
17998>>>>>>>>>>
17998>>>>>>>>>                Case Break
17999>>>>>>>>>            Case (iFolderCreated = 80)
18002>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
18003>>>>>>>>>                Case Break
18004>>>>>>>>>            Case (iFolderCreated = 183)
18007>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
18008>>>>>>>>>                Case Break
18009>>>>>>>>>            Case (iFolderCreated = 1223)
18012>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
18013>>>>>>>>>>
18013>>>>>>>>>                Case Break
18014>>>>>>>>>            Case Else
18014>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
18015>>>>>>>>>>
18015>>>>>>>>>        Case End
18015>>>>>>>>>    End
18015>>>>>>>>>>
18015>>>>>>>>>    Function_Return iRetVal
18016>>>>>>>>>End_Function
18017>>>>>>>>>
18017>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
18019>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
18019>>>>>>>>>    Integer iFileSize iVoid
18019>>>>>>>>>    Handle  hFindFile
18019>>>>>>>>>    tvWin32FindData FindData
18019>>>>>>>>>    tvWin32FindData FindData
18019>>>>>>>>>
18019>>>>>>>>>    Move (sFileName+"") to sFileName
18020>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
18021>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
18022>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
18024>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
18025>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
18026>>>>>>>>>    End
18026>>>>>>>>>>
18026>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
18027>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
18028>>>>>>>>>
18028>>>>>>>>>    Function_Return iFileSize
18029>>>>>>>>>End_Function
18030>>>>>>>>>
18030>>>>>>>>>//
18030>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
18030>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
18030>>>>>>>>>//
18030>>>>>>>>>//=============================================================================
18030>>>>>>>>>// Verifies that a path is a valid directory.
18030>>>>>>>>>//
18030>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
18030>>>>>>>>>//
18030>>>>>>>>>// Parameters:
18030>>>>>>>>>//      sPath - Address of the path to verify.
18030>>>>>>>>>//=============================================================================
18030>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
18032>>>>>>>>>    Integer iResult
18032>>>>>>>>>    Boolean bRetVal
18032>>>>>>>>>
18032>>>>>>>>>    Move false to bRetVal
18033>>>>>>>>>    Move (sPath - Character (0)) to sPath
18034>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
18035>>>>>>>>>    If (iResult<>0) Begin
18037>>>>>>>>>        Move True to bRetVal
18038>>>>>>>>>    End
18038>>>>>>>>>>
18038>>>>>>>>>
18038>>>>>>>>>    Function_Return bRetVal
18039>>>>>>>>>End_Function
18040>>>>>>>>>
18040>>>>>>>
18040>>>>>>>//
18040>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
18040>>>>>>>// If sStopChar has no occurences in the string an empty string is
18040>>>>>>>// returned.
18040>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
18042>>>>>>>    String  sRetVal
18042>>>>>>>    String  sChar
18042>>>>>>>    Integer iLength
18042>>>>>>>    Integer iPos
18042>>>>>>>    Boolean bStopChar
18042>>>>>>>    Move "" to sRetval
18043>>>>>>>    Move (Length(sFrom)) to iLength
18044>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
18046>>>>>>>        Move iLength   to iPos
18047>>>>>>>        Move (False)   to bStopChar
18048>>>>>>>        While Not bStopChar
18052>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
18053>>>>>>>            Decrement iPos
18054>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
18056>>>>>>>                Move (True) to bStopChar
18057>>>>>>>            End
18057>>>>>>>>
18057>>>>>>>            Else Begin
18058>>>>>>>                Move (sChar+sRetVal) to sRetVal
18059>>>>>>>            End
18059>>>>>>>>
18059>>>>>>>        Loop
18060>>>>>>>>
18060>>>>>>>    End
18060>>>>>>>>
18060>>>>>>>    Function_Return sRetVal
18061>>>>>>>End_Function
18062>>>>>>>
18062>>>>>>>// Pre:  sFileName contains the complete path of the file.
18062>>>>>>>// Post: returns the complete path of the file.
18062>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
18062>>>>>>>Function ParseFolderName Global String sFileName Returns String
18064>>>>>>>    String sFile
18064>>>>>>>    String sFolderName
18064>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
18064>>>>>>>
18064>>>>>>>    Move "" to sFolderName
18065>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
18066>>>>>>>    If sDirSep In sFileName Begin
18068>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
18069>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
18070>>>>>>>    End
18070>>>>>>>>
18070>>>>>>>    Else If ":" In sFileName Begin
18073>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
18074>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
18075>>>>>>>    End
18075>>>>>>>>
18075>>>>>>>    Function_Return sFolderName
18076>>>>>>>End_Function
18077>>>>>>>
18077>>>>>>>// Pre:  sFileName contains the complete path of the file.
18077>>>>>>>// post: The returned filename has it's path removed, but will have a extension
18077>>>>>>>Function ParseFileName Global String sFileName Returns String
18079>>>>>>>    String sFolderName
18079>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
18079>>>>>>>
18079>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
18080>>>>>>>    Get ParseFolderName sFileName to sFolderName
18081>>>>>>>    If (sFolderName <> "") Begin
18083>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
18084>>>>>>>    End
18084>>>>>>>>
18084>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
18085>>>>>>>    Function_Return sFilename
18086>>>>>>>End_Function
18087>>>>>>>
18087>>>>>>>// Pre:  sFileName may contain the complete path of the file.
18087>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
18087>>>>>>>//       return "bak" as the extension and not "gif"
18087>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
18087>>>>>>>//       such as "html" or "java"
18087>>>>>>>Function ParseFileExtension Global String sFileName Returns String
18089>>>>>>>    String  sFileExtension
18089>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
18090>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
18091>>>>>>>    Function_Return sFileExtension
18092>>>>>>>End_Function
18093>>>>>>>
18093>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
18093>>>>>>>
18093>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
18095>>>>>>>    String sMessage
18095>>>>>>>    Case Begin
18095>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
18097>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
18098>>>>>>>            Case Break
18099>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
18102>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
18103>>>>>>>            Case Break
18104>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
18107>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
18108>>>>>>>            Case Break
18109>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
18112>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
18113>>>>>>>            Case Break
18114>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
18117>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
18118>>>>>>>            Case Break
18119>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
18122>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
18123>>>>>>>            Case Break
18124>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
18127>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
18128>>>>>>>            Case Break
18129>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
18132>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
18133>>>>>>>            Case Break
18134>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
18137>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
18138>>>>>>>            Case Break
18139>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
18142>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
18143>>>>>>>            Case Break
18144>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
18147>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
18148>>>>>>>            Case Break
18149>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
18152>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
18153>>>>>>>            Case Break
18154>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
18157>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
18158>>>>>>>            Case Break
18159>>>>>>>        Case Else
18159>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
18160>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
18161>>>>>>>            Case Break
18162>>>>>>>    Case End
18162>>>>>>>    Function_Return sMessage
18163>>>>>>>End_Function
18164>>>>>>>
18164>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
18166>>>>>>>    String sMessage
18166>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
18167>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
18168>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
18169>>>>>>>End_Procedure
18170>>>>>>>
18170>>>>>>>
18170>>>>>>>// This function informs the user that he entered a yet unknown folder and
18170>>>>>>>// asks if he/she wants to create the folder (Yes/No)
18170>>>>>>>// Choice: "Yes" - this creates the folder
18170>>>>>>>//                 if successful, the function returns false
18170>>>>>>>//                 else it will be true.
18170>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
18170>>>>>>>//                 For example: to stop a save
18170>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
18170>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
18170>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
18172>>>>>>>    Integer bIsNotValid
18172>>>>>>>    Integer iUsers_Choice
18172>>>>>>>    String  sMessage
18172>>>>>>>
18172>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
18174>>>>>>>        Move "The folder '" to sMessage
18175>>>>>>>        Append sMessage sFolderName
18176>>>>>>>        Append sMessage "' does not yet exist,\n"
18177>>>>>>>        Append sMessage "Do you want to create it now?"
18178>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
18179>>>>>>>        Case Begin
18179>>>>>>>            Case (iUsers_Choice = MBR_Yes)
18181>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
18182>>>>>>>                If bIsNotValid Begin
18184>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
18185>>>>>>>                    Append sMessage sFolderName "'.\n\n"
18187>>>>>>>                    Send Info_Box sMessage "Info"
18188>>>>>>>                End
18188>>>>>>>>
18188>>>>>>>                Case Break
18189>>>>>>>            Case (iUsers_Choice = MBR_No)
18192>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
18193>>>>>>>                Case Break
18194>>>>>>>        Case End
18194>>>>>>>    End
18194>>>>>>>>
18194>>>>>>>    Function_Return bIsNotValid
18195>>>>>>>End_Function
18196>>>>>>>
18196>>>>>>>// **WvA
18196>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
18196>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
18196>>>>>>>// The folder may contain a drive letter or UNC encoding.
18196>>>>>>>Function vFolderFormat Global String sFolderName Returns String
18198>>>>>>>    String sDirSep
18198>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
18199>>>>>>>    Move (Trim(sFolderName)) to sFolderName
18200>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
18202>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
18203>>>>>>>    End
18203>>>>>>>>
18203>>>>>>>    Function_Return sFolderName
18204>>>>>>>End_Function
18205>>>>>>>
18205>>>>>>>//
18205>>>>>>>// Gets the parent path of the currently supplied path
18205>>>>>>>// Returns "" when we are at the root folder.
18205>>>>>>>//
18205>>>>>>>Function vParentPath Global String sPath Returns String
18207>>>>>>>    String sStrip sDirSep
18207>>>>>>>
18207>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
18208>>>>>>>    Move (Trim(sPath)) to sPath
18209>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
18211>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
18212>>>>>>>    End
18212>>>>>>>>
18212>>>>>>>    If (Pos(sDirSep, sPath)) Begin
18214>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
18215>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
18216>>>>>>>    End
18216>>>>>>>>
18216>>>>>>>    Else Begin
18217>>>>>>>        Move "" to sPath
18218>>>>>>>    End
18218>>>>>>>>
18218>>>>>>>    Function_Return sPath
18219>>>>>>>End_Function
18220>>>>>Use DUFLanguageConstants.inc
18220>>>>>
18220>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
18220>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
18220>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
18220>>>>>
18220>>>>>Struct tDUFIntFile
18220>>>>>    Integer iID
18220>>>>>    String sIntFileName
18220>>>>>    String sIntLineText
18220>>>>>End_Struct
18220>>>>>
18220>>>>>Struct tDbVersionInfo
18220>>>>>    Number nVersionNumber
18220>>>>>    Handle hObject
18220>>>>>End_Struct
18220>>>>>
18220>>>>>Struct tDbUpdateError
18220>>>>>    Number nUpdateVersion
18220>>>>>    Integer iError
18220>>>>>    String  sOrgErrorText
18220>>>>>    String  sErrorText
18220>>>>>    Integer iErrorLine
18220>>>>>    Boolean bError  
18220>>>>>    Handle  hTable 
18220>>>>>    String  sTableRootName
18220>>>>>    Integer iField
18220>>>>>    Boolean bShortFormat
18220>>>>>End_Struct
18220>>>>>
18220>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
18220>>>>>//  DF_FILE_IS_MASTER if master
18220>>>>>//  DF_FILE_IS_ALIAS if alias
18220>>>>>Struct tDbUpdateHandlerMasterAlias
18220>>>>>    Handle hTable
18220>>>>>    Integer iMode
18220>>>>>End_Struct
18220>>>>>
18220>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
18220>>>>>Enumeration_List
18220>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
18220>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
18220>>>>>End_Enumeration_List
18220>>>>>
18220>>>>>    Define DATAFLEX_ID for "DATAFLEX"
18220>>>>>
18220>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
18220>>>>>// communicate with the object from anywhere in a program.
18220>>>>>    Global_Variable Handle ghoDbUpdateHandler
18220>>>>>    Move 0 to ghoDbUpdateHandler
18221>>>>>
18221>>>>>// NOTE: If the DbVersion table should _not_ be used and you
18221>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
18221>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
18221>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
18221>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
18221>>>>>//    Declare_Datafile DbVersion
18221>>>>>//#ENDIF
18221>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
18221>>>>>//****************************************************************************
18221>>>>>// $Module type: Class
18221>>>>>// $Module name: cDbUpdateLogFile
18221>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18221>>>>>// Web-site    : http://www.rdctools.com
18221>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
18221>>>>>//
18221>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
18221>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
18221>>>>>//               that this class is to change; each developer can decide if the errors instead
18221>>>>>//               should be saved to a database table, or something entirely different.
18221>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
18221>>>>>//
18221>>>>>// $Rev History:
18221>>>>>//    2016-10-05  Module header created
18221>>>>>//****************************************************************************
18221>>>>>Use UI
18221>>>>>Use vWin32fh.pkg
18221>>>>>
18221>>>>>
18221>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
18221>>>>>
18221>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
18221>>>>>
18221>>>>>Class cDbUpdateLogFile is a cObject
18222>>>>>
18222>>>>>    Procedure Construct_Object
18224>>>>>        Forward Send Construct_Object
18226>>>>>
18226>>>>>        // Error handling:
18226>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
18227>>>>>        Property Integer piChannel -1
18228>>>>>
18228>>>>>        // This property is set by the cDbUpdateHandler object,
18228>>>>>        // when the update process starts.
18228>>>>>        Property DateTime pdtUpdateStart
18229>>>>>
18229>>>>>        // Gets set to False if the log contains data
18229>>>>>        Property Boolean pbEmptyLogFile True
18230>>>>>
18230>>>>>        // Gets set to True after the error log header text
18230>>>>>        // has been written.
18230>>>>>        Property Boolean pbHeaderWritten False
18231>>>>>
18231>>>>>        // If all activities should be logged- not just errors.
18231>>>>>        Property Boolean pbVerboseState False
18232>>>>>
18232>>>>>        // File name for the error log where all errors
18232>>>>>        // after a run is written to (appended).
18232>>>>>        // It is saved in the Data folder.
18232>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
18233>>>>>        // If this property is set to "" in object code, the
18233>>>>>        // "shell" command parameter will be used to let Windows decide
18233>>>>>        // with which program to open the logfile.
18233>>>>>        Property String psEditorProgram ""
18234>>>>>
18234>>>>>        Property Boolean pbUseDataTableLog False
18235>>>>>
18235>>>>>        // If true an error will be written to file immediately when
18235>>>>>        // it occurs. This can be handy if a large update generates a lots
18235>>>>>        // of errors and the application crasches before finished, thus
18235>>>>>        // the errors will not be written.
18235>>>>>        Property Boolean pbQuickWrite True
18236>>>>>    End_Procedure
18237>>>>>
18237>>>>>    Procedure End_Construct_Object
18239>>>>>        Forward Send End_Construct_Object
18241>>>>>
18241>>>>>    End_Procedure
18242>>>>>
18242>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
18244>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
18244>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
18246>>>>>        Boolean bShortFormat
18246>>>>>        Integer iSize
18246>>>>>        Handle hCurrentTable
18246>>>>>        Integer iCurrentField           
18246>>>>>        String sOrgErrorText sTableRootName
18246>>>>>        
18246>>>>>        Move False to bShortFormat
18247>>>>>        If (num_arguments > 5) Begin
18249>>>>>            Move bShortFormatIn to bShortFormat
18250>>>>>        End
18250>>>>>>
18250>>>>>        // Only do once.
18250>>>>>        If (pbHeaderWritten(Self) = False) Begin
18252>>>>>            Send WriteHeaderData
18253>>>>>            Set pbHeaderWritten to True
18254>>>>>        End
18254>>>>>>
18254>>>>>
18254>>>>>        Get Private.phCurrentTable to hCurrentTable  
18255>>>>>        Get Private.piCurrentField to iCurrentField  
18256>>>>>        If (iError > 0) Begin
18258>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
18261>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
18262>>>>>        End
18262>>>>>>
18262>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
18263>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
18264>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
18265>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
18266>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
18267>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
18268>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
18269>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
18270>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
18271>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
18272>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
18273>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
18274>>>>>
18274>>>>>        If (bError = False) Begin
18276>>>>>            Move False to DbUpdateErrorArray[iSize].bError
18277>>>>>        End
18277>>>>>>
18277>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
18278>>>>>
18278>>>>>        If (pbUseDataTableLog(Self) = True) Begin
18280>>>>>            If (pbQuickWrite(Self) = True) Begin
18282>>>>>                Send OnWriteRow_DataTable
18283>>>>>                // If we are writing error for error flush the
18283>>>>>                // error array when latest error has been written.
18283>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
18284>>>>>            End
18284>>>>>>
18284>>>>>            Procedure_Return
18285>>>>>        End
18285>>>>>>
18285>>>>>        Else Begin
18286>>>>>            If (pbQuickWrite(Self) = True) Begin
18288>>>>>                Send WriteErrorLog
18289>>>>>                // Flush the error log array
18289>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
18290>>>>>            End
18290>>>>>>
18290>>>>>        End
18290>>>>>>
18290>>>>>    End_Procedure   
18291>>>>>    
18291>>>>>    Function FetchErrorDescription Integer iError Returns String
18293>>>>>        String sErrorText         
18293>>>>>        Move "" to sErrorText
18294>>>>>        If (iError > 0) Begin
18296>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
18297>>>>>        End
18297>>>>>>
18297>>>>>        Function_Return sErrorText
18298>>>>>    End_Function
18299>>>>>
18299>>>>>    // Hook procedure for writing header text prior starting the update work to
18299>>>>>    // a database table. This does nothing by default.
18299>>>>>    // Don't forget to Open your "error log table" first (!) as all
18299>>>>>    // tables have been closed at this stage. Put anything
18299>>>>>    // you want to indicate that the update process is just started.
18299>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
18301>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
18303>>>>>    End_Procedure
18304>>>>>
18304>>>>>    Procedure OnWriteRow_DataTable
18306>>>>>        tDbUpdateError[] DbUpdateErrorArray
18306>>>>>        tDbUpdateError[] DbUpdateErrorArray
18307>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
18308>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
18310>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
18312>>>>>        End
18312>>>>>>
18312>>>>>    End_Procedure
18313>>>>>
18313>>>>>    Function psLogTextFileWithPath Returns String
18315>>>>>        String sPath sFileName sFullFileName
18315>>>>>        
18315>>>>>        Get psDataPathFirstPart to sPath
18316>>>>>        Get psLogTextFile to sFileName
18317>>>>>        Move (sPath + sFileName) to sFullFileName
18318>>>>>        Function_Return sFullFileName
18319>>>>>    End_Function                     
18320>>>>>    
18320>>>>>    Procedure WriteHeaderData
18322>>>>>        String sFileName
18322>>>>>        Integer iCh iSize
18322>>>>>        Boolean bQuickWrite
18322>>>>>        DateTime dtUpdateStart
18322>>>>>
18322>>>>>        Move (CurrentDateTime()) to dtUpdateStart
18323>>>>>        If (pbUseDataTableLog(Self) = True) Begin
18325>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
18326>>>>>            Procedure_Return
18327>>>>>        End
18327>>>>>>
18327>>>>>
18327>>>>>        Get piChannel to iCh
18328>>>>>        If (iCh < 0) Begin
18330>>>>>            Get Seq_New_Channel to iCh
18331>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
18333>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
18334>>>>>>
18334>>>>>                Procedure_Return
18335>>>>>            End
18335>>>>>>
18335>>>>>            Set piChannel to iCh
18336>>>>>        End
18336>>>>>>
18336>>>>>
18336>>>>>        Get psLogTextFileWithPath to sFileName
18337>>>>>        Get vWin32_APIFileSize sFileName to iSize
18338>>>>>        Get pbQuickWrite to bQuickWrite
18339>>>>>        
18339>>>>>        If (bQuickWrite = True) Begin
18341>>>>>            Append_Output channel iCh sFileName
18343>>>>>                If (bQuickWrite = True) Begin
18345>>>>>                    If (iSize = 0) Begin
18347>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
18350>>>>>                        Set pbEmptyLogFile to False
18351>>>>>                    End
18351>>>>>>
18351>>>>>                    Writeln channel iCh
18353>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
18356>>>>>                End
18356>>>>>>
18356>>>>>            Close_Output channel iCh
18358>>>>>        End
18358>>>>>>
18358>>>>>    End_Procedure
18359>>>>>
18359>>>>>    // Returns the first datapath found in the psDataPath property.
18359>>>>>    // The returned path always ends with a "\"
18359>>>>>    Function psDataPathFirstPart Returns String
18361>>>>>        String sDataPath
18361>>>>>        Integer iCount
18361>>>>>
18361>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
18362>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
18363>>>>>        If (iCount > 1) Begin
18365>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
18366>>>>>        End
18366>>>>>>
18366>>>>>        If (sDataPath <> "") Begin
18368>>>>>            Get vFolderFormat sDataPath to sDataPath
18369>>>>>        End
18369>>>>>>
18369>>>>>
18369>>>>>        Function_Return sDataPath
18370>>>>>    End_Function
18371>>>>>
18371>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
18371>>>>>    Procedure WriteErrorLog
18373>>>>>        tDbUpdateError[] aDbUpdateErrorArray
18373>>>>>        tDbUpdateError[] aDbUpdateErrorArray
18374>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
18374>>>>>        Integer iCount iSize iCh iError iErrorLine iField
18374>>>>>        Boolean bUseDataTable bQuickWrite
18374>>>>>        DateTime dtUpdateStart dtUpdateEnd
18374>>>>>        TimeSpan tsElapsed
18374>>>>>        Number nVersion                                  
18374>>>>>        Handle hTable
18374>>>>>
18374>>>>>        If (pbHeaderWritten(Self) = False) Begin
18376>>>>>            Send WriteHeaderData
18377>>>>>            Set pbHeaderWritten to True
18378>>>>>        End
18378>>>>>>
18378>>>>>
18378>>>>>        Get pbUseDataTableLog to bUseDataTable
18379>>>>>        If (bUseDataTable = True) Begin
18381>>>>>            Send OnWriteRow_DataTable
18382>>>>>            Procedure_Return
18383>>>>>        End
18383>>>>>>
18383>>>>>
18383>>>>>        Get piChannel to iCh
18384>>>>>        If (iCh < 0) Begin
18386>>>>>            Get Seq_New_Channel to iCh
18387>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
18389>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
18390>>>>>>
18390>>>>>                Procedure_Return
18391>>>>>            End
18391>>>>>>
18391>>>>>            Set piChannel to iCh
18392>>>>>        End
18392>>>>>>
18392>>>>>
18392>>>>>        Get psLogTextFileWithPath to sFileName
18393>>>>>
18393>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
18394>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
18395>>>>>        Decrement iSize
18396>>>>>
18396>>>>>        Get pdtUpdateStart to dtUpdateStart
18397>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
18399>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
18400>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
18401>>>>>        End
18401>>>>>>
18401>>>>>        Get pbQuickWrite to bQuickWrite
18402>>>>>
18402>>>>>        Append_Output channel iCh sFileName
18404>>>>>        If (bQuickWrite = True and iSize < 0) Begin
18406>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
18409>>>>>        End
18409>>>>>>
18409>>>>>        Else If (bQuickWrite = False) Begin
18412>>>>>            Writeln channel iCh
18414>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
18417>>>>>        End   
18417>>>>>>
18417>>>>>        If (iSize >= 0) Begin
18419>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
18421>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
18424>>>>>            End
18424>>>>>>
18424>>>>>        End
18424>>>>>>
18424>>>>>
18424>>>>>        For iCount from 0 to iSize  
18430>>>>>>
18430>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
18431>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
18432>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
18433>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
18434>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
18435>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
18436>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
18437>>>>>            
18437>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
18438>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
18440>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
18441>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
18442>>>>>            End
18442>>>>>>
18442>>>>>            Else Begin
18443>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
18444>>>>>                Move (sVersion + "   " + sErrorText) to sText
18445>>>>>            End
18445>>>>>>
18445>>>>>            Writeln channel iCh sText
18448>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
18450>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
18451>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
18452>>>>>                Writeln channel iCh sOrgErrorText
18455>>>>>            End
18455>>>>>>
18455>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
18457>>>>>                Writeln channel iCh
18459>>>>>            End
18459>>>>>>
18459>>>>>        Loop
18460>>>>>>
18460>>>>>        Close_Output channel iCh
18462>>>>>
18462>>>>>        Send Seq_Release_Channel iCh
18463>>>>>        Set piChannel to -1
18464>>>>>
18464>>>>>    End_Procedure
18465>>>>>
18465>>>>>    // The character to pad is optional. If nothing, spaces are used.
18465>>>>>    // Example:
18465>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
18465>>>>>    //  or:
18465>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
18465>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
18465>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
18467>>>>>        String sChar
18467>>>>>
18467>>>>>        If (Num_Arguments >= 3) Begin
18469>>>>>            Move sOptChar to sChar
18470>>>>>        End
18470>>>>>>
18470>>>>>        Else Begin
18471>>>>>            Move " " to sChar
18472>>>>>        End
18472>>>>>>
18472>>>>>
18472>>>>>        While (Length(sString) < iLength)
18476>>>>>            Move (sChar + sString) to sString
18477>>>>>        Loop
18478>>>>>>
18478>>>>>
18478>>>>>        Function_Return sString
18479>>>>>    End_Function
18480>>>>>
18480>>>>>    Procedure ShowErrorLog
18482>>>>>        String sPath sFileName sEditorProgram
18482>>>>>        Boolean bExists
18482>>>>>
18482>>>>>        Get psLogTextFileWithPath to sFileName
18483>>>>>        Get vFilePathExists sFileName to bExists
18484>>>>>        If (bExists = True) Begin
18486>>>>>            Get psEditorProgram to sEditorProgram
18487>>>>>            If (sEditorProgram <> "") Begin
18489>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
18490>>>>>            End
18490>>>>>>
18490>>>>>            Else Begin
18491>>>>>                Runprogram Shell Background sFileName
18492>>>>>            End
18492>>>>>>
18492>>>>>        End
18492>>>>>>
18492>>>>>        Else Begin
18493>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
18494>>>>>        End
18494>>>>>>
18494>>>>>    End_Procedure
18495>>>>>
18495>>>>>End_Class
18496>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
18496>>>>>//****************************************************************************
18496>>>>>// $Module type: Class
18496>>>>>// $Module name: cDbUpdateVersion
18496>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18496>>>>>// Web-site    : http://www.rdctools.com
18496>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
18496>>>>>//
18496>>>>>// Description : Child class to cDbUpdateHandler.
18496>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
18496>>>>>//               Set the pnVersionNumber to a version number.
18496>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
18496>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
18496>>>>>//               Place your code in the "OnUpdate" event that alters the database.
18496>>>>>//
18496>>>>>// $Rev History:
18496>>>>>//    2016-09-27  Module header created
18496>>>>>//****************************************************************************
18496>>>>>Use UI
18496>>>>>Use DUFLanguageConstants.inc
18496>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
18496>>>>>>>
18496>>>>>>>//****************************************************************************
18496>>>>>>>// $Module type: Class
18496>>>>>>>// $Module name: cDbUpdateFunctionLibrary
18496>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18496>>>>>>>// Web-site    : http://www.rdctools.com
18496>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
18496>>>>>>>//
18496>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
18496>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
18496>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
18496>>>>>>>//               with the help of Sql-scripts.
18496>>>>>>>//
18496>>>>>>>// $Rev History:
18496>>>>>>>//    2014-09-05  Module header created
18496>>>>>>>//
18496>>>>>>>//****************************************************************************
18496>>>>>>>//
18496>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
18496>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
18496>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
18496>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
18496>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
18496>>>>>>>//
18496>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
18496>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
18496>>>>>>>
18496>>>>>>>
18496>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
18496>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
18496>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
18496>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
18496>>>>>>>//
18496>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
18496>>>>>>>>>//****************************************************************************
18496>>>>>>>>>// $Module type: Class
18496>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
18496>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18496>>>>>>>>>// Web-site    : http://www.rdctools.com
18496>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
18496>>>>>>>>>//
18496>>>>>>>>>// Description : The class consists of the baseis for the cDbUpdateFunctionLibrary class
18496>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
18496>>>>>>>>>//
18496>>>>>>>>>// $Rev History:
18496>>>>>>>>>//    2023-11-06  Module header created
18496>>>>>>>>>//
18496>>>>>>>>>//****************************************************************************
18496>>>>>>>>>Use cApplication.pkg
18496>>>>>>>>>Use seq_chnl.pkg
18496>>>>>>>>>Use GlobalFunctionsProcedures.pkg
18496>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
18496>>>>>>>>>Use Dfcursor.pkg
Including file: Dfcursor.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfcursor.pkg)
18496>>>>>>>>>>>//  create a desktop object named Cursor_control that understands
18496>>>>>>>>>>>//   Send Cursor_Wait to (cursor_Control(self))
18496>>>>>>>>>>>//            creates hourclass cursor
18496>>>>>>>>>>>//   Send Cursor_ready to (cursor_Control(self))
18496>>>>>>>>>>>//            restores regular cursor
18496>>>>>>>>>>>//
18496>>>>>>>>>>>Use Cursor.pkg
Including file: Cursor.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Cursor.pkg)
18496>>>>>>>>>>>>>Use Windows.pkg
18496>>>>>>>>>>>>>Use WinUser.pkg
18496>>>>>>>>>>>>>
18496>>>>>>>>>>>>>// Standard Cursor IDs
18496>>>>>>>>>>>>>
18496>>>>>>>>>>>>>
18496>>>>>>>>>>>>>
18496>>>>>>>>>>>>>
18496>>>>>>>>>>>>>
18496>>>>>>>>>>>>>Class CursorShape is a DFBaseToolPanel //BasicPanel
18497>>>>>>>>>>>>>    
18497>>>>>>>>>>>>>    Procedure Construct_Object
18499>>>>>>>>>>>>>        Forward Send Construct_Object
18501>>>>>>>>>>>>>        
18501>>>>>>>>>>>>>        Property Handle ClassCursorHandle 0
18502>>>>>>>>>>>>>        Set Visible_State to False
18503>>>>>>>>>>>>>        Set Size to 1 1
18504>>>>>>>>>>>>>    End_Procedure
18505>>>>>>>>>>>>>    
18505>>>>>>>>>>>>>    Procedure Set Cursor Integer CursorType
18507>>>>>>>>>>>>>        Handle CursorID hWnd
18507>>>>>>>>>>>>>        Longptr retval lpCursorType
18507>>>>>>>>>>>>>        Get Window_Handle to hWnd
18508>>>>>>>>>>>>>        If (CursorType = 0) Begin
18510>>>>>>>>>>>>>            Send Release_Mouse_Capture
18511>>>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, ClassCursorHandle(Self))) to retval
18512>>>>>>>>>>>>>            Set ClassCursorHandle to 0
18513>>>>>>>>>>>>>            Send Page_Object False
18514>>>>>>>>>>>>>        End
18514>>>>>>>>>>>>>>
18514>>>>>>>>>>>>>        Else Begin
18515>>>>>>>>>>>>>            Send Page_Object True
18516>>>>>>>>>>>>>            Get Window_Handle to hWnd
18517>>>>>>>>>>>>>            If (ClassCursorHandle(Self) = 0) ;                Set ClassCursorHandle to (GetClassLongPtr(hWnd, GCL_HCURSOR))
18520>>>>>>>>>>>>>            
18520>>>>>>>>>>>>>            Move CursorType to lpCursorType    // Move to Longptr type to avoid conversion from integer to pointer in the next line
18521>>>>>>>>>>>>>            Move (LoadCursorW(0,lpCursorType)) to CursorID
18522>>>>>>>>>>>>>            
18522>>>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, CursorID )) to retval
18523>>>>>>>>>>>>>            Move (SetCursor(CursorID)) to retval
18524>>>>>>>>>>>>>            Send Set_Mouse_Capture
18525>>>>>>>>>>>>>        End
18525>>>>>>>>>>>>>>
18525>>>>>>>>>>>>>    End_Procedure
18526>>>>>>>>>>>>>    
18526>>>>>>>>>>>>>    Procedure Mouse_Up
18528>>>>>>>>>>>>>        Handle retval
18528>>>>>>>>>>>>>        Send Set_Mouse_Capture
18529>>>>>>>>>>>>>        Move (SetCursor(GetClassLongPtr(Window_Handle(Self), GCL_HCURSOR))) to retval
18530>>>>>>>>>>>>>    End_Procedure
18531>>>>>>>>>>>>>    
18531>>>>>>>>>>>>>    Procedure Cursor_Wait
18533>>>>>>>>>>>>>        Set cursor to IDC_WAIT
18534>>>>>>>>>>>>>    End_Procedure
18535>>>>>>>>>>>>>    
18535>>>>>>>>>>>>>    Procedure Cursor_Ready
18537>>>>>>>>>>>>>        Set cursor to 0
18538>>>>>>>>>>>>>    End_Procedure
18539>>>>>>>>>>>>>    
18539>>>>>>>>>>>>>    
18539>>>>>>>>>>>>>End_Class
18540>>>>>>>>>>>
18540>>>>>>>>>>>Object Cursor_Control is a CursorShape
18542>>>>>>>>>>>End_Object
18543>>>>>>>>>>>
18543>>>>>>>>>Use DUFStatusPanel.pkg
18543>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
18543>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
18543>>>>>>>>>>>//
18543>>>>>>>>>>>// We need to create a mixin class for the library.
18543>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
18543>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
18543>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
18543>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
18543>>>>>>>>>>>//
18543>>>>>>>>>>>Use VdfBase.pkg
18543>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 23.0\Pkg\WinUuid.pkg)
18543>>>>>>>>>>>>>Use Unicode.Pkg
18543>>>>>>>>>>>>>
18543>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
18544>>>>>>>>>>>>>
18544>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
18545>>>>>>>>>>>>>
18545>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
18546>>>>>>>>>>>>>
18546>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
18547>>>>>>>>>>>>>
18547>>>>>>>>>>>>>
18547>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
18547>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
18549>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
18549>>>>>>>>>>>>>    Integer iRetval iOffset iChar
18549>>>>>>>>>>>>>    String sUUID
18549>>>>>>>>>>>>>    
18549>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
18550>>>>>>>>>>>>>    
18550>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
18551>>>>>>>>>>>>>    
18551>>>>>>>>>>>>>    If (iRetval = 0) Begin
18553>>>>>>>>>>>>>        Move 0 to pUUIDStr
18554>>>>>>>>>>>>>        
18554>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
18555>>>>>>>>>>>>>        If (iRetval = 0) Begin
18557>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
18558>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
18559>>>>>>>>>>>>>            
18559>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
18560>>>>>>>>>>>>>        End
18560>>>>>>>>>>>>>>
18560>>>>>>>>>>>>>    End
18560>>>>>>>>>>>>>>
18560>>>>>>>>>>>>>    
18560>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
18561>>>>>>>>>>>>>    
18561>>>>>>>>>>>>>    Function_Return sUUID
18562>>>>>>>>>>>>>End_Function
18563>>>>>>>>>>>>>
18563>>>>>>>>>>>>>
18563>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
18563>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
18565>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
18565>>>>>>>>>>>>>    Integer iRetval iOffset iChar
18565>>>>>>>>>>>>>    String sUUID
18565>>>>>>>>>>>>>    
18565>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
18566>>>>>>>>>>>>>    
18566>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
18567>>>>>>>>>>>>>    
18567>>>>>>>>>>>>>    If (iRetval = 0) Begin
18569>>>>>>>>>>>>>        Move 0 to pUUIDStr
18570>>>>>>>>>>>>>        
18570>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
18571>>>>>>>>>>>>>        If (iRetval = 0) Begin
18573>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
18574>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
18575>>>>>>>>>>>>>            
18575>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
18576>>>>>>>>>>>>>        End
18576>>>>>>>>>>>>>>
18576>>>>>>>>>>>>>    End
18576>>>>>>>>>>>>>>
18576>>>>>>>>>>>>>    
18576>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
18577>>>>>>>>>>>>>    
18577>>>>>>>>>>>>>    Function_Return sUUID
18578>>>>>>>>>>>>>End_Function
18579>>>>>>>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cli.pkg)
18579>>>>>>>>>>>>>//                                                              
18579>>>>>>>>>>>>>//   CLI specific functionality. There are several connectivity kits     
18579>>>>>>>>>>>>>//   based on  SQL/92 CLI. Those are:                                    
18579>>>>>>>>>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
18579>>>>>>>>>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
18579>>>>>>>>>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
18579>>>>>>>>>>>>>//                                                                       
18579>>>>>>>>>>>>>//   This package defines the common functionality for all CLI based     
18579>>>>>>>>>>>>>//   drivers.                                                            
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
18579>>>>>>>>>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
18579>>>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
18579>>>>>>>>>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
18579>>>>>>>>>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
18579>>>>>>>>>>>>>Define DF_FILE_TABLE_NAME               for 609
18579>>>>>>>>>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
18579>>>>>>>>>>>>>Define DF_FILE_SQL_FILTER               for 611
18579>>>>>>>>>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
18579>>>>>>>>>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
18579>>>>>>>>>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
18579>>>>>>>>>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
18579>>>>>>>>>>>>>Define DF_FILE_DATABASE_ID              for 622
18579>>>>>>>>>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
18579>>>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
18579>>>>>>>>>>>>>Define DF_FILE_BLOCK_SIZE               for 628
18579>>>>>>>>>>>>>Define DF_FILE_JIT_BINDING              for 630
18579>>>>>>>>>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
18579>>>>>>>>>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
18579>>>>>>>>>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
18579>>>>>>>>>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
18579>>>>>>>>>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_FIELD_STORE_TIME              for 702
18579>>>>>>>>>>>>>Define DF_FIELD_TIME                    for 703
18579>>>>>>>>>>>>>Define DF_FIELD_IS_NULL                 for 704
18579>>>>>>>>>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
18579>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
18579>>>>>>>>>>>>>Define DF_FIELD_FETCH_STATE             for 708
18579>>>>>>>>>>>>>Define DF_FIELD_READ_ONLY               for 710
18579>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
18579>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
18579>>>>>>>>>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
18579>>>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN           for 716
18579>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
18579>>>>>>>>>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
18579>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
18579>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
18579>>>>>>>>>>>>>Define DF_FIELD_IS_IDENTITY             for 722
18579>>>>>>>>>>>>>Define DF_FIELD_SQL_COLUMN_NAME         for 723
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_INDEX_NAME                    for 801
18579>>>>>>>>>>>>>Define DF_INDEX_UNIQUE                  for 802
18579>>>>>>>>>>>>>Define DF_INDEX_ON_BACKEND              for 804
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_INDEX_CLUSTERED               for 806
18579>>>>>>>>>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
18579>>>>>>>>>>>>>Define DF_INDEX_SQL_TYPE                for 810
18579>>>>>>>>>>>>>Define DF_INDEX_NUMBER                  for 812
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
18579>>>>>>>>>>>>>Define DF_DATABASE_ID                            for 1002
18579>>>>>>>>>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
18579>>>>>>>>>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
18579>>>>>>>>>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
18579>>>>>>>>>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
18579>>>>>>>>>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
18579>>>>>>>>>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
18579>>>>>>>>>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
18579>>>>>>>>>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
18579>>>>>>>>>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
18579>>>>>>>>>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
18579>>>>>>>>>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
18579>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
18579>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
18579>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
18579>>>>>>>>>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
18579>>>>>>>>>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
18579>>>>>>>>>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
18579>>>>>>>>>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
18579>>>>>>>>>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
18579>>>>>>>>>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
18579>>>>>>>>>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
18579>>>>>>>>>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
18579>>>>>>>>>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
18579>>>>>>>>>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
18579>>>>>>>>>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
18579>>>>>>>>>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
18579>>>>>>>>>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
18579>>>>>>>>>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
18579>>>>>>>>>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
18579>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
18579>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
18579>>>>>>>>>>>>>Define DF_DATABASE_TRIM_VARCHAR_VALUES           for 1084
18579>>>>>>>>>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE              for 1085
18579>>>>>>>>>>>>>Define DF_DATABASE_ODBC_DRIVER_NAME              for 1087
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
18579>>>>>>>>>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
18579>>>>>>>>>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
18579>>>>>>>>>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
18579>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
18579>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
18579>>>>>>>>>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
18579>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
18579>>>>>>>>>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
18579>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
18579>>>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
18579>>>>>>>>>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
18579>>>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
18579>>>>>>>>>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
18579>>>>>>>>>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
18579>>>>>>>>>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
18579>>>>>>>>>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
18579>>>>>>>>>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
18579>>>>>>>>>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
18579>>>>>>>>>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
18579>>>>>>>>>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
18579>>>>>>>>>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
18579>>>>>>>>>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
18579>>>>>>>>>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
18579>>>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
18579>>>>>>>>>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
18579>>>>>>>>>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
18579>>>>>>>>>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
18579>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
18579>>>>>>>>>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
18579>>>>>>>>>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
18579>>>>>>>>>>>>>Define DF_DRIVER_TRIM_VARCHAR_VALUES             for 1184
18579>>>>>>>>>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_DRIVER_NAME    for 1187 
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
18579>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Replacement for logical column number that indicates all columns
18579>>>>>>>>>>>>>Define DF_ALL_COLUMNS for -1
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
18579>>>>>>>>>>>>>Define RIM_NONE            for 0
18579>>>>>>>>>>>>>Define RIM_IDENTITY_COLUMN for 1
18579>>>>>>>>>>>>>Define RIM_DISPENSER_TABLE for 2
18579>>>>>>>>>>>>>Define RIM_EXTERNAL        for 3
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible DF_FIELD_READ_ONLY values
18579>>>>>>>>>>>>>Define RO_NO            for 0
18579>>>>>>>>>>>>>Define RO_IGNORECHANGE  for 1
18579>>>>>>>>>>>>>Define RO_ACCEPTCHANGE  for 2
18579>>>>>>>>>>>>>Define RO_ERRORONCHANGE for 3
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
18579>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNICODE     for 11
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible SQL Column type values
18579>>>>>>>>>>>>>//      SQL Server specific types defined in mssqldrv.pkg
18579>>>>>>>>>>>>>//      DB2 specific typesm defined in db2_drv.pkg
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define SQL_UNKNOWN_TYPE   for    0
18579>>>>>>>>>>>>>Define SQL_CHAR           for    1
18579>>>>>>>>>>>>>Define SQL_NUMERIC        for    2
18579>>>>>>>>>>>>>Define SQL_DECIMAL        for    3
18579>>>>>>>>>>>>>Define SQL_INTEGER        for    4
18579>>>>>>>>>>>>>Define SQL_SMALLINT       for    5
18579>>>>>>>>>>>>>Define SQL_FLOAT          for    6
18579>>>>>>>>>>>>>Define SQL_REAL           for    7
18579>>>>>>>>>>>>>Define SQL_DOUBLE         for    8
18579>>>>>>>>>>>>>Define SQL_DATETIME       for    9
18579>>>>>>>>>>>>>Define SQL_VARCHAR        for   12
18579>>>>>>>>>>>>>Define SQL_TYPE_DATE      for   91
18579>>>>>>>>>>>>>Define SQL_TYPE_TIME      for   92
18579>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>Define SQL_DATE           for    9
18579>>>>>>>>>>>>>Define SQL_INTERVAL       for   10
18579>>>>>>>>>>>>>Define SQL_TIME           for   10
18579>>>>>>>>>>>>>Define SQL_TIMESTAMP      for   11
18579>>>>>>>>>>>>>Define SQL_LONGVARCHAR    for  (-1)
18579>>>>>>>>>>>>>Define SQL_BINARY         for  (-2)
18579>>>>>>>>>>>>>Define SQL_VARBINARY      for  (-3)
18579>>>>>>>>>>>>>Define SQL_LONGVARBINARY  for  (-4)
18579>>>>>>>>>>>>>Define SQL_BIGINT         for  (-5)
18579>>>>>>>>>>>>>Define SQL_TINYINT        for  (-6)
18579>>>>>>>>>>>>>Define SQL_BIT            for  (-7)
18579>>>>>>>>>>>>>Define SQL_WCHAR          for  (-8)
18579>>>>>>>>>>>>>Define SQL_WVARCHAR       for  (-9)
18579>>>>>>>>>>>>>Define SQL_WLONGVARCHAR   for (-10)
18579>>>>>>>>>>>>>Define SQL_GUID           for (-11)
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible DF_INDEX_SQL_TYPE values
18579>>>>>>>>>>>>>Define DF_INDEX_CLIENT      for  1
18579>>>>>>>>>>>>>Define DF_INDEX_SERVER      for  2
18579>>>>>>>>>>>>>Define DF_INDEX_SERVER_ONLY for  3
18579>>>>>>>>>>>>>Define DF_INDEX_TEMPORARY   for  4
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
18579>>>>>>>>>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
18579>>>>>>>>>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
18579>>>>>>>>>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Driver level attributes
18579>>>>>>>>>>>>>Define DRVR_TOKEN_BASE                       for 1000
18579>>>>>>>>>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
18579>>>>>>>>>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
18579>>>>>>>>>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
18579>>>>>>>>>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
18579>>>>>>>>>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
18579>>>>>>>>>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
18579>>>>>>>>>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
18579>>>>>>>>>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
18579>>>>>>>>>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
18579>>>>>>>>>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
18579>>>>>>>>>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
18579>>>>>>>>>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
18579>>>>>>>>>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
18579>>>>>>>>>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
18579>>>>>>>>>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
18579>>>>>>>>>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
18579>>>>>>>>>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
18579>>>>>>>>>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
18579>>>>>>>>>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Error Number constants
18579>>>>>>>>>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
18579>>>>>>>>>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
18579>>>>>>>>>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
18579>>>>>>>>>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
18579>>>>>>>>>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
18579>>>>>>>>>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
18579>>>>>>>>>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
18579>>>>>>>>>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
18579>>>>>>>>>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
18579>>>>>>>>>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
18579>>>>>>>>>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
18579>>>>>>>>>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
18579>>>>>>>>>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
18579>>>>>>>>>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
18579>>>>>>>>>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
18579>>>>>>>>>>>>>Define CLIERR_SQL_ERROR                           for 12304
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
18579>>>>>>>>>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
18579>>>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
18579>>>>>>>>>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
18579>>>>>>>>>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
18579>>>>>>>>>>>>>Define CLIERR_FIELDREADONLY                       for 12315
18579>>>>>>>>>>>>>Define CLIERR_DBPROPERROR                         for 12316
18579>>>>>>>>>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
18579>>>>>>>>>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
18579>>>>>>>>>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
18579>>>>>>>>>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
18579>>>>>>>>>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
18579>>>>>>>>>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
18579>>>>>>>>>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
18579>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
18579>>>>>>>>>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
18579>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
18579>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
18579>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
18579>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
18579>>>>>>>>>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
18579>>>>>>>>>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
18579>>>>>>>>>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
18579>>>>>>>>>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
18579>>>>>>>>>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
18579>>>>>>>>>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
18579>>>>>>>>>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
18579>>>>>>>>>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
18579>>>>>>>>>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
18579>>>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
18579>>>>>>>>>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
18579>>>>>>>>>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
18579>>>>>>>>>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
18579>>>>>>>>>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
18579>>>>>>>>>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
18579>>>>>>>>>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Call driver Function identifiers
18579>>>>>>>>>>>>>Define CLI_CONSTRAINT             for 10000
18579>>>>>>>>>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
18579>>>>>>>>>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
18579>>>>>>>>>>>>>Define CLI_BROWSECONNECT          for 10003
18579>>>>>>>>>>>>>Define CLI_DATASOURCES            for 10004
18579>>>>>>>>>>>>>Define CLI_CKREVISION             for 10005
18579>>>>>>>>>>>>>Define CLI_INITDATASOURCES        for 10006
18579>>>>>>>>>>>>>Define CLI_ENUMERATE_TABLES       for 10007
18579>>>>>>>>>>>>>Define CLI_TABLENAME              for 10008
18579>>>>>>>>>>>>>Define CLI_TABLESCHEMA            for 10009
18579>>>>>>>>>>>>>Define CLI_TABLETYPE              for 10010
18579>>>>>>>>>>>>>Define CLI_TABLECOMMENT           for 10011
18579>>>>>>>>>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
18579>>>>>>>>>>>>>Define CLI_COLUMNNAME             for 10013
18579>>>>>>>>>>>>>Define CLI_DUMPSTATUS             for 10014
18579>>>>>>>>>>>>>Define CLI_READCONFIGURATION      for 10015
18579>>>>>>>>>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
18579>>>>>>>>>>>>>Define CLI_GETDBATTRIBUTE         for 10017
18579>>>>>>>>>>>>>Define CLI_GETREGNAME             for 10018
18579>>>>>>>>>>>>>Define CLI_GETSERIALNUM           for 10019
18579>>>>>>>>>>>>>Define CLI_GETMAXUSERS            for 10020
18579>>>>>>>>>>>>>Define CLI_BCP                    for 10021
18579>>>>>>>>>>>>>Define CLI_DROPINDICES            for 10022
18579>>>>>>>>>>>>>Define CLI_CREATEINDICES          for 10023
18579>>>>>>>>>>>>>Define CLI_REDIRECTCONNECTION     for 10024
18579>>>>>>>>>>>>>Define CLI_CREATECONNECTIONID     for 10025
18579>>>>>>>>>>>>>Define CLI_DELETECONNECTIONID     for 10026
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Init data source types
18579>>>>>>>>>>>>>Define SQL_FETCH_ALL     for  2
18579>>>>>>>>>>>>>Define SQL_FETCH_USER    for 31
18579>>>>>>>>>>>>>Define SQL_FETCH_SYSTEM  for 32
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Dummy strings used in the commands
18579>>>>>>>>>>>>>String  CLI$StrDummy 255
18579>>>>>>>>>>>>>Integer CLI$IntDummy
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>//   Setup a constraint for a file.                                    
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// Set or get an attribute at driver level. These attributes, when set,
18579>>>>>>>>>>>>>// will be set for the remainder of the session or until set again. To 
18579>>>>>>>>>>>>>// permanently set driver level attributes change the driver           
18579>>>>>>>>>>>>>// configuration file.                                                 
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>// An instance of this class can be used as a broker object to
18579>>>>>>>>>>>>>// call several CLI releated methods.                         
18579>>>>>>>>>>>>>
18579>>>>>>>>>>>>>//Class cCLIHandler is a cObject
18579>>>>>>>>>>>>>Class cCLIHandler is an Array
18580>>>>>>>>>>>>>    
18580>>>>>>>>>>>>>    Procedure Construct_Object 
18582>>>>>>>>>>>>>        Forward Send Construct_object 
18584>>>>>>>>>>>>>        
18584>>>>>>>>>>>>>        Property String  psDriverID        ""
18585>>>>>>>>>>>>>    End_Procedure
18586>>>>>>>>>>>>>    
18586>>>>>>>>>>>>>    
18586>>>>>>>>>>>>>    
18586>>>>>>>>>>>>>    // The revsion of a CLI Connectivity Kit
18586>>>>>>>>>>>>>    Function CKRevision Returns String
18588>>>>>>>>>>>>>        String  sDriverID
18588>>>>>>>>>>>>>        String  sRevision
18588>>>>>>>>>>>>>        String  sVoid
18588>>>>>>>>>>>>>        Integer iRetval
18588>>>>>>>>>>>>>        
18588>>>>>>>>>>>>>        Get psDriverID to sDriverID
18589>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18591>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRevision
18592>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
18597>>>>>>>>>>>>>        End
18597>>>>>>>>>>>>>>
18597>>>>>>>>>>>>>        
18597>>>>>>>>>>>>>        Function_Return sRevision
18598>>>>>>>>>>>>>    End_Function
18599>>>>>>>>>>>>>    
18599>>>>>>>>>>>>>    
18599>>>>>>>>>>>>>    
18599>>>>>>>>>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
18599>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
18599>>>>>>>>>>>>>    //
18599>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
18601>>>>>>>>>>>>>        Integer iPartRev
18601>>>>>>>>>>>>>        Integer iCurrentPart
18601>>>>>>>>>>>>>        Integer iSeparatorPos
18601>>>>>>>>>>>>>        
18601>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
18604>>>>>>>>>>>>>        
18604>>>>>>>>>>>>>        Move 0 to iCurrentPart
18605>>>>>>>>>>>>>        Repeat
18605>>>>>>>>>>>>>>
18605>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
18606>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
18608>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
18609>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
18610>>>>>>>>>>>>>                Increment iCurrentPart
18611>>>>>>>>>>>>>            End
18611>>>>>>>>>>>>>>
18611>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
18614>>>>>>>>>>>>>                Move sRevision to iPartRev
18615>>>>>>>>>>>>>                Move "" to sRevision
18616>>>>>>>>>>>>>                Increment iCurrentPart
18617>>>>>>>>>>>>>            End
18617>>>>>>>>>>>>>>
18617>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
18619>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
18621>>>>>>>>>>>>>        
18621>>>>>>>>>>>>>        Function_Return iPartRev
18622>>>>>>>>>>>>>    End_Function
18623>>>>>>>>>>>>>    
18623>>>>>>>>>>>>>    
18623>>>>>>>>>>>>>    
18623>>>>>>>>>>>>>    // Returns the major revision of the CK
18623>>>>>>>>>>>>>    //
18623>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
18625>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
18626>>>>>>>>>>>>>    End_Function
18627>>>>>>>>>>>>>    
18627>>>>>>>>>>>>>    
18627>>>>>>>>>>>>>    
18627>>>>>>>>>>>>>    // Returns the minor revision of the CK
18627>>>>>>>>>>>>>    //
18627>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
18629>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
18630>>>>>>>>>>>>>    End_Function
18631>>>>>>>>>>>>>    
18631>>>>>>>>>>>>>    
18631>>>>>>>>>>>>>    
18631>>>>>>>>>>>>>    // Returns the release revision of the CK
18631>>>>>>>>>>>>>    //
18631>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
18633>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
18634>>>>>>>>>>>>>    End_Function
18635>>>>>>>>>>>>>    
18635>>>>>>>>>>>>>    
18635>>>>>>>>>>>>>    
18635>>>>>>>>>>>>>    // Returns the major revision of the CK
18635>>>>>>>>>>>>>    //
18635>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
18637>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
18638>>>>>>>>>>>>>    End_Function
18639>>>>>>>>>>>>>    
18639>>>>>>>>>>>>>    
18639>>>>>>>>>>>>>    
18639>>>>>>>>>>>>>    // Determines if the CK conforms to a passed minimal revsion.
18639>>>>>>>>>>>>>    //
18639>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
18641>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
18644>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
18647>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
18650>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
18653>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
18656>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
18660>>>>>>>>>>>>>            End
18660>>>>>>>>>>>>>>
18660>>>>>>>>>>>>>        End
18660>>>>>>>>>>>>>>
18660>>>>>>>>>>>>>        
18660>>>>>>>>>>>>>        Function_Return (False)
18661>>>>>>>>>>>>>    End_Function
18662>>>>>>>>>>>>>    
18662>>>>>>>>>>>>>    
18662>>>>>>>>>>>>>    
18662>>>>>>>>>>>>>    // Returns the Connectiivty Kit registration name.
18662>>>>>>>>>>>>>    //
18662>>>>>>>>>>>>>    Function RegistrationName Returns String
18664>>>>>>>>>>>>>        String  sRegistration
18664>>>>>>>>>>>>>        String  sDRiverId
18664>>>>>>>>>>>>>        String  sVoid
18664>>>>>>>>>>>>>        Integer iRetval
18664>>>>>>>>>>>>>        
18664>>>>>>>>>>>>>        Get psDriverID to sDriverID
18665>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18667>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRegistration
18668>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
18673>>>>>>>>>>>>>        End
18673>>>>>>>>>>>>>>
18673>>>>>>>>>>>>>        
18673>>>>>>>>>>>>>        Function_Return sRegistration
18674>>>>>>>>>>>>>    End_Function
18675>>>>>>>>>>>>>    
18675>>>>>>>>>>>>>    // Returns the Connectiivty Kit serial number.
18675>>>>>>>>>>>>>    //
18675>>>>>>>>>>>>>    Function SerialNumber Returns Integer
18677>>>>>>>>>>>>>        String  sDRiverId
18677>>>>>>>>>>>>>        String  sVoid
18677>>>>>>>>>>>>>        Integer iRetval
18677>>>>>>>>>>>>>        
18677>>>>>>>>>>>>>        Get psDriverID to sDriverID
18678>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18680>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
18685>>>>>>>>>>>>>        End
18685>>>>>>>>>>>>>>
18685>>>>>>>>>>>>>        
18685>>>>>>>>>>>>>        Function_Return iRetval
18686>>>>>>>>>>>>>    End_Function
18687>>>>>>>>>>>>>    
18687>>>>>>>>>>>>>    
18687>>>>>>>>>>>>>    // Returns the Connectiivty Kit maximum number of users.
18687>>>>>>>>>>>>>    //
18687>>>>>>>>>>>>>    Function MaxUsers Returns Integer
18689>>>>>>>>>>>>>        String  sDRiverId
18689>>>>>>>>>>>>>        String  sVoid
18689>>>>>>>>>>>>>        Integer iRetval
18689>>>>>>>>>>>>>        
18689>>>>>>>>>>>>>        Get psDriverID to sDriverID
18690>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18692>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
18697>>>>>>>>>>>>>        End
18697>>>>>>>>>>>>>>
18697>>>>>>>>>>>>>        
18697>>>>>>>>>>>>>        Function_Return iRetval
18698>>>>>>>>>>>>>    End_Function
18699>>>>>>>>>>>>>    
18699>>>>>>>>>>>>>    
18699>>>>>>>>>>>>>    
18699>>>>>>>>>>>>>    // Dump the current status of the drver in the passed disk file.
18699>>>>>>>>>>>>>    //
18699>>>>>>>>>>>>>    Procedure DumpStatus String sFileName
18701>>>>>>>>>>>>>        String  sVoid
18701>>>>>>>>>>>>>        String  sDriverID
18701>>>>>>>>>>>>>        Integer iVoid
18701>>>>>>>>>>>>>        
18701>>>>>>>>>>>>>        Get psDriverID to sDriverID
18702>>>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
18709>>>>>>>>>>>>>    End_Procedure
18710>>>>>>>>>>>>>    
18710>>>>>>>>>>>>>    
18710>>>>>>>>>>>>>    
18710>>>>>>>>>>>>>    // Reset all driver level configurable attributes to the
18710>>>>>>>>>>>>>    // default value and then reread the configuration.
18710>>>>>>>>>>>>>    //
18710>>>>>>>>>>>>>    Procedure ReadConfiguration
18712>>>>>>>>>>>>>        String  sVoid
18712>>>>>>>>>>>>>        String  sDriverID
18712>>>>>>>>>>>>>        Integer iVoid
18712>>>>>>>>>>>>>        
18712>>>>>>>>>>>>>        Get psDriverID to sDriverID
18713>>>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
18720>>>>>>>>>>>>>    End_Procedure
18721>>>>>>>>>>>>>    
18721>>>>>>>>>>>>>    
18721>>>>>>>>>>>>>    
18721>>>>>>>>>>>>>    // Convert a text to the corresponding
18721>>>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
18721>>>>>>>>>>>>>    //
18721>>>>>>>>>>>>>    Function TextToRIMValue String sText Returns Integer
18723>>>>>>>>>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
18726>>>>>>>>>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
18730>>>>>>>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
18734>>>>>>>>>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
18738>>>>>>>>>>>>>    End_Function
18739>>>>>>>>>>>>>    
18739>>>>>>>>>>>>>    
18739>>>>>>>>>>>>>    
18739>>>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
18739>>>>>>>>>>>>>    // corresponding text.
18739>>>>>>>>>>>>>    //
18739>>>>>>>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
18741>>>>>>>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
18744>>>>>>>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
18748>>>>>>>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
18752>>>>>>>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
18756>>>>>>>>>>>>>    End_Function
18757>>>>>>>>>>>>>    
18757>>>>>>>>>>>>>    
18757>>>>>>>>>>>>>    
18757>>>>>>>>>>>>>    // Convert a text to the corresponding
18757>>>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
18757>>>>>>>>>>>>>    //
18757>>>>>>>>>>>>>    Function TextToROValue String sText Returns Integer
18759>>>>>>>>>>>>>        If (sText = "No") ;            Function_Return RO_NO
18762>>>>>>>>>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
18766>>>>>>>>>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
18770>>>>>>>>>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
18774>>>>>>>>>>>>>    End_Function
18775>>>>>>>>>>>>>    
18775>>>>>>>>>>>>>    
18775>>>>>>>>>>>>>    
18775>>>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
18775>>>>>>>>>>>>>    // corresponding text.
18775>>>>>>>>>>>>>    //
18775>>>>>>>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
18777>>>>>>>>>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
18780>>>>>>>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
18784>>>>>>>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
18788>>>>>>>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
18792>>>>>>>>>>>>>    End_Function
18793>>>>>>>>>>>>>    
18793>>>>>>>>>>>>>    
18793>>>>>>>>>>>>>    
18793>>>>>>>>>>>>>    // Return the text f the last error geneated by the driver.
18793>>>>>>>>>>>>>    //
18793>>>>>>>>>>>>>    Function LastDriverError Returns String
18795>>>>>>>>>>>>>        String  sDriverID
18795>>>>>>>>>>>>>        String  sLastError
18795>>>>>>>>>>>>>        String  sLastErrorLength
18795>>>>>>>>>>>>>        Integer iLastErrorLength
18795>>>>>>>>>>>>>        Integer iVoid
18795>>>>>>>>>>>>>        
18795>>>>>>>>>>>>>        // Initialize
18795>>>>>>>>>>>>>        Move "" to sLastError
18796>>>>>>>>>>>>>        
18796>>>>>>>>>>>>>        Get psDriverID to sDriverID
18797>>>>>>>>>>>>>        If (sDriverID <> "") Begin
18799>>>>>>>>>>>>>            // Get the text of the last error
18799>>>>>>>>>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
18800>>>>>>>>>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
18805>>>>>>>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
18806>>>>>>>>>>>>>            
18806>>>>>>>>>>>>>            If (iLastErrorLength > 0) Begin
18808>>>>>>>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
18809>>>>>>>>>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
18814>>>>>>>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
18815>>>>>>>>>>>>>            End
18815>>>>>>>>>>>>>>
18815>>>>>>>>>>>>>        End
18815>>>>>>>>>>>>>>
18815>>>>>>>>>>>>>        
18815>>>>>>>>>>>>>        Function_Return sLastError
18816>>>>>>>>>>>>>    End_Function
18817>>>>>>>>>>>>>    
18817>>>>>>>>>>>>>    
18817>>>>>>>>>>>>>    
18817>>>>>>>>>>>>>    // Enumerate the tables in a database
18817>>>>>>>>>>>>>    //
18817>>>>>>>>>>>>>    Function EnumerateTables String sLogin Returns Integer
18819>>>>>>>>>>>>>        String  sDriver
18819>>>>>>>>>>>>>        String  sVoid
18819>>>>>>>>>>>>>        Integer iNumTables
18819>>>>>>>>>>>>>        Integer iVoid
18819>>>>>>>>>>>>>        
18819>>>>>>>>>>>>>        Get psDriverID to sDriver
18820>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
18827>>>>>>>>>>>>>        
18827>>>>>>>>>>>>>        Function_Return iNumTables
18828>>>>>>>>>>>>>    End_Function
18829>>>>>>>>>>>>>    
18829>>>>>>>>>>>>>    
18829>>>>>>>>>>>>>    
18829>>>>>>>>>>>>>    // Returns the name of the table enumerated at the given position
18829>>>>>>>>>>>>>    //
18829>>>>>>>>>>>>>    Function TableName Integer iIndex Returns String
18831>>>>>>>>>>>>>        String  sDriver
18831>>>>>>>>>>>>>        String  sTableName
18831>>>>>>>>>>>>>        String  sVoid
18831>>>>>>>>>>>>>        Integer iVoid
18831>>>>>>>>>>>>>        
18831>>>>>>>>>>>>>        Get psDriverID to sDriver
18832>>>>>>>>>>>>>        If (sDriver <> "") Begin
18834>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sTableName
18835>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
18840>>>>>>>>>>>>>        End
18840>>>>>>>>>>>>>>
18840>>>>>>>>>>>>>        
18840>>>>>>>>>>>>>        Function_Return sTableName
18841>>>>>>>>>>>>>    End_Function
18842>>>>>>>>>>>>>    
18842>>>>>>>>>>>>>    
18842>>>>>>>>>>>>>    
18842>>>>>>>>>>>>>    // Returns the name of the schema of the table enumerated at the given position
18842>>>>>>>>>>>>>    //
18842>>>>>>>>>>>>>    Function SchemaName Integer iIndex Returns String
18844>>>>>>>>>>>>>        String  sDriver
18844>>>>>>>>>>>>>        String  sSchemaName
18844>>>>>>>>>>>>>        String  sVoid
18844>>>>>>>>>>>>>        Integer iVoid
18844>>>>>>>>>>>>>        
18844>>>>>>>>>>>>>        Get psDriverID to sDriver
18845>>>>>>>>>>>>>        If (sDriver <> "") Begin
18847>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sSchemaName
18848>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
18853>>>>>>>>>>>>>        End
18853>>>>>>>>>>>>>>
18853>>>>>>>>>>>>>        
18853>>>>>>>>>>>>>        Function_Return sSchemaName
18854>>>>>>>>>>>>>    End_Function
18855>>>>>>>>>>>>>    
18855>>>>>>>>>>>>>    // Returns the type of the table enumerated at the given position.
18855>>>>>>>>>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
18855>>>>>>>>>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
18855>>>>>>>>>>>>>    Function TableType Integer iIndex Returns String
18857>>>>>>>>>>>>>        String  sDriver
18857>>>>>>>>>>>>>        String  sTableType
18857>>>>>>>>>>>>>        String  sVoid
18857>>>>>>>>>>>>>        Integer iVoid
18857>>>>>>>>>>>>>        
18857>>>>>>>>>>>>>        Get psDriverID to sDriver
18858>>>>>>>>>>>>>        If (sDriver <> "") Begin
18860>>>>>>>>>>>>>            Move (Repeat(" ", 25)) to sTableType
18861>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
18866>>>>>>>>>>>>>        End
18866>>>>>>>>>>>>>>
18866>>>>>>>>>>>>>        
18866>>>>>>>>>>>>>        Function_Return sTableType
18867>>>>>>>>>>>>>    End_Function
18868>>>>>>>>>>>>>    
18868>>>>>>>>>>>>>    
18868>>>>>>>>>>>>>    // Returns the comment of the table enumerated at the given position
18868>>>>>>>>>>>>>    //
18868>>>>>>>>>>>>>    Function TableComment Integer iIndex Returns String
18870>>>>>>>>>>>>>        String  sDriver
18870>>>>>>>>>>>>>        String  sTableComment
18870>>>>>>>>>>>>>        String  sVoid
18870>>>>>>>>>>>>>        Integer iVoid
18870>>>>>>>>>>>>>        
18870>>>>>>>>>>>>>        Get psDriverID to sDriver
18871>>>>>>>>>>>>>        If (sDriver <> "") Begin
18873>>>>>>>>>>>>>            Move (Repeat(" ", 1024)) to sTableComment
18874>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
18879>>>>>>>>>>>>>        End
18879>>>>>>>>>>>>>>
18879>>>>>>>>>>>>>        
18879>>>>>>>>>>>>>        Function_Return sTableComment
18880>>>>>>>>>>>>>    End_Function
18881>>>>>>>>>>>>>    
18881>>>>>>>>>>>>>    // Enumerate the columns in a table
18881>>>>>>>>>>>>>    //
18881>>>>>>>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
18883>>>>>>>>>>>>>        String  sDriver
18883>>>>>>>>>>>>>        Integer iNumColumns
18883>>>>>>>>>>>>>        Integer iVoid
18883>>>>>>>>>>>>>        
18883>>>>>>>>>>>>>        Get psDriverID to sDriver
18884>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
18891>>>>>>>>>>>>>        
18891>>>>>>>>>>>>>        Function_Return iNumColumns
18892>>>>>>>>>>>>>    End_Function
18893>>>>>>>>>>>>>    
18893>>>>>>>>>>>>>    
18893>>>>>>>>>>>>>    
18893>>>>>>>>>>>>>    // Returns the name of the column enumerated at the given position
18893>>>>>>>>>>>>>    //
18893>>>>>>>>>>>>>    Function ColumnName Integer iIndex Returns String
18895>>>>>>>>>>>>>        String  sDriver
18895>>>>>>>>>>>>>        String  sColumnName
18895>>>>>>>>>>>>>        String  sVoid
18895>>>>>>>>>>>>>        Integer iVoid
18895>>>>>>>>>>>>>        
18895>>>>>>>>>>>>>        Get psDriverID to sDriver
18896>>>>>>>>>>>>>        If (sDriver <> "") Begin
18898>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sColumnName
18899>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
18904>>>>>>>>>>>>>        End
18904>>>>>>>>>>>>>>
18904>>>>>>>>>>>>>        
18904>>>>>>>>>>>>>        Function_Return sColumnName
18905>>>>>>>>>>>>>    End_Function
18906>>>>>>>>>>>>>    
18906>>>>>>>>>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
18906>>>>>>>>>>>>>    //
18906>>>>>>>>>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
18908>>>>>>>>>>>>>        
18908>>>>>>>>>>>>>        Integer iDriverIndex
18908>>>>>>>>>>>>>        
18908>>>>>>>>>>>>>        String sSQLDate
18908>>>>>>>>>>>>>        Integer iOrgDateFmt
18908>>>>>>>>>>>>>        Integer iOrgDateSep
18908>>>>>>>>>>>>>        
18908>>>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18908>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18911>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18914>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18917>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18920>>>>>>>>>>>>>        
18920>>>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
18922>>>>>>>>>>>>>            // Return the dummy zero date
18922>>>>>>>>>>>>>            Get DriverIndex sDriver to iDriverIndex
18923>>>>>>>>>>>>>            If (iDriverIndex <> 0) Begin
18925>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
18928>>>>>>>>>>>>>            End
18928>>>>>>>>>>>>>>
18928>>>>>>>>>>>>>            Else Begin
18929>>>>>>>>>>>>>                Move '0001-01-01' to sSQLDate
18930>>>>>>>>>>>>>            End
18930>>>>>>>>>>>>>>
18930>>>>>>>>>>>>>        End
18930>>>>>>>>>>>>>>
18930>>>>>>>>>>>>>        Else Begin
18931>>>>>>>>>>>>>            Move dDFDate to sSQLDate
18932>>>>>>>>>>>>>        End
18932>>>>>>>>>>>>>>
18932>>>>>>>>>>>>>        
18932>>>>>>>>>>>>>        // Change date format back to original
18932>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18935>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18938>>>>>>>>>>>>>        
18938>>>>>>>>>>>>>        Function_Return sSQLDate
18939>>>>>>>>>>>>>    End_Function
18940>>>>>>>>>>>>>    
18940>>>>>>>>>>>>>    
18940>>>>>>>>>>>>>    
18940>>>>>>>>>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
18940>>>>>>>>>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
18942>>>>>>>>>>>>>        
18942>>>>>>>>>>>>>        Integer iDriverIndex
18942>>>>>>>>>>>>>        
18942>>>>>>>>>>>>>        Date dDFDate
18942>>>>>>>>>>>>>        String sDummyDateValue
18942>>>>>>>>>>>>>        Integer iOrgDateFmt
18942>>>>>>>>>>>>>        Integer iOrgDateSep
18942>>>>>>>>>>>>>        
18942>>>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18942>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18945>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18948>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18951>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18954>>>>>>>>>>>>>        
18954>>>>>>>>>>>>>        // We only need to convert if the date is the dummy zero date value
18954>>>>>>>>>>>>>        Get DriverIndex sDriver to iDriverIndex
18955>>>>>>>>>>>>>        If (iDriverIndex <> 0) Begin
18957>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
18960>>>>>>>>>>>>>        End
18960>>>>>>>>>>>>>>
18960>>>>>>>>>>>>>        Else Begin
18961>>>>>>>>>>>>>            Move '0001-01-01' to sDummyDateValue
18962>>>>>>>>>>>>>        End
18962>>>>>>>>>>>>>>
18962>>>>>>>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
18965>>>>>>>>>>>>>        Else ;            Move sSQLDate to dDFDate
18967>>>>>>>>>>>>>        
18967>>>>>>>>>>>>>        // Change date format back to original
18967>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18970>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18973>>>>>>>>>>>>>        
18973>>>>>>>>>>>>>        Function_Return dDFDate
18974>>>>>>>>>>>>>    End_Function
18975>>>>>>>>>>>>>    
18975>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
18977>>>>>>>>>>>>>        
18977>>>>>>>>>>>>>        String  sCurrentDriver
18977>>>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
18977>>>>>>>>>>>>>        
18977>>>>>>>>>>>>>        Move 0 to iDriver
18978>>>>>>>>>>>>>        
18978>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
18981>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
18987>>>>>>>>>>>>>>
18987>>>>>>>>>>>>>            
18987>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
18990>>>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
18992>>>>>>>>>>>>>                Move iCount to iDriver
18993>>>>>>>>>>>>>            End
18993>>>>>>>>>>>>>>
18993>>>>>>>>>>>>>        Loop
18994>>>>>>>>>>>>>>
18994>>>>>>>>>>>>>        
18994>>>>>>>>>>>>>        Function_Return iDriver
18995>>>>>>>>>>>>>        
18995>>>>>>>>>>>>>    End_Function
18996>>>>>>>>>>>>>    
18996>>>>>>>>>>>>>    
18996>>>>>>>>>>>>>    // Redirect an exisitng connection. The existing connection
18996>>>>>>>>>>>>>    // will point to another database but all tables will stay
18996>>>>>>>>>>>>>    // open!
18996>>>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
18998>>>>>>>>>>>>>        String  sDriver
18998>>>>>>>>>>>>>        String  sVoid
18998>>>>>>>>>>>>>        Integer iResult
18998>>>>>>>>>>>>>        Integer iVoid
18998>>>>>>>>>>>>>        
18998>>>>>>>>>>>>>        Get psDriverID to sDriver
18999>>>>>>>>>>>>>        If (sDriver <> "") Begin
19001>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
19006>>>>>>>>>>>>>        End
19006>>>>>>>>>>>>>>
19006>>>>>>>>>>>>>        Function_Return iResult
19007>>>>>>>>>>>>>    End_Function
19008>>>>>>>>>>>>>    
19008>>>>>>>>>>>>>    // Redirect a connection of a connection ID
19008>>>>>>>>>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
19008>>>>>>>>>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
19008>>>>>>>>>>>>>    //
19008>>>>>>>>>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
19008>>>>>>>>>>>>>    // to the new connection (Server/Database specified in sConnectString)
19008>>>>>>>>>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
19008>>>>>>>>>>>>>    //
19008>>>>>>>>>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
19008>>>>>>>>>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
19008>>>>>>>>>>>>>    //
19008>>>>>>>>>>>>>    // Returns:
19008>>>>>>>>>>>>>    //     0 when the redirection was successful.
19008>>>>>>>>>>>>>    //     1 if the connection ID does not exist or can not be found.
19008>>>>>>>>>>>>>    //     2 login into the new connection failed.
19008>>>>>>>>>>>>>    //
19008>>>>>>>>>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
19010>>>>>>>>>>>>>        String  sDriver
19010>>>>>>>>>>>>>        String  sVoid
19010>>>>>>>>>>>>>        Integer iResult
19010>>>>>>>>>>>>>        
19010>>>>>>>>>>>>>        Integer iOption
19010>>>>>>>>>>>>>        
19010>>>>>>>>>>>>>        // iOption
19010>>>>>>>>>>>>>        // 0 = RedirectConnection
19010>>>>>>>>>>>>>        // 1 = RedirectIdConnectString
19010>>>>>>>>>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
19010>>>>>>>>>>>>>        If (bKeepLoggedIn) Begin
19012>>>>>>>>>>>>>            Move 2 to iOption
19013>>>>>>>>>>>>>        End
19013>>>>>>>>>>>>>>
19013>>>>>>>>>>>>>        Else Begin
19014>>>>>>>>>>>>>            Move 1 to iOption
19015>>>>>>>>>>>>>        End
19015>>>>>>>>>>>>>>
19015>>>>>>>>>>>>>        
19015>>>>>>>>>>>>>        Get psDriverID to sDriver
19016>>>>>>>>>>>>>        If (sDriver <> "") Begin
19018>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
19023>>>>>>>>>>>>>        End
19023>>>>>>>>>>>>>>
19023>>>>>>>>>>>>>        Function_Return iResult
19024>>>>>>>>>>>>>    End_Function
19025>>>>>>>>>>>>>    
19025>>>>>>>>>>>>>    
19025>>>>>>>>>>>>>    // Create a DataFlex side connection id that can be used later on.
19025>>>>>>>>>>>>>    //
19025>>>>>>>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
19027>>>>>>>>>>>>>        String  sDriver
19027>>>>>>>>>>>>>        Integer iResult
19027>>>>>>>>>>>>>        Integer iOptions
19027>>>>>>>>>>>>>        
19027>>>>>>>>>>>>>        Get psDriverID to sDriver
19028>>>>>>>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
19031>>>>>>>>>>>>>        Else ;            Move iOpt to iOptions
19033>>>>>>>>>>>>>        If (sDriver <> "") Begin
19035>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
19040>>>>>>>>>>>>>        End
19040>>>>>>>>>>>>>>
19040>>>>>>>>>>>>>        Function_Return iResult
19041>>>>>>>>>>>>>    End_Function
19042>>>>>>>>>>>>>    
19042>>>>>>>>>>>>>    
19042>>>>>>>>>>>>>    
19042>>>>>>>>>>>>>    // Delete a DataFlex side connection id.
19042>>>>>>>>>>>>>    //
19042>>>>>>>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
19044>>>>>>>>>>>>>        String  sDriver
19044>>>>>>>>>>>>>        Integer iResult
19044>>>>>>>>>>>>>        String sVoid
19044>>>>>>>>>>>>>        
19044>>>>>>>>>>>>>        Get psDriverID to sDriver
19045>>>>>>>>>>>>>        If (sDriver <> "") Begin
19047>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
19052>>>>>>>>>>>>>        End
19052>>>>>>>>>>>>>>
19052>>>>>>>>>>>>>        Function_Return iResult
19053>>>>>>>>>>>>>    End_Function
19054>>>>>>>>>>>>>    
19054>>>>>>>>>>>>>End_Class
19055>>>>>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files\DataFlex 23.0\Pkg\sql.pkg)
19055>>>>>>>>>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
19055>>>>>>>>>>>>>// Connectivty Kits.                                              
19055>>>>>>>>>>>>>Use CLI.pkg
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Global storage for results
19055>>>>>>>>>>>>>Integer SQLResult
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Embedded SQL function constants
19055>>>>>>>>>>>>>Define FUNC_SQLCONNECT             for 1000000
19055>>>>>>>>>>>>>Define FUNC_SQLFILECONNECT         for 1000001
19055>>>>>>>>>>>>>Define FUNC_SQLDISCONNECT          for 1000002
19055>>>>>>>>>>>>>Define FUNC_SQLOPEN                for 1000003
19055>>>>>>>>>>>>>Define FUNC_SQLCLOSE               for 1000004
19055>>>>>>>>>>>>>Define FUNC_SQLPREPARE             for 1000005
19055>>>>>>>>>>>>>Define FUNC_SQLEXECUTE             for 1000006
19055>>>>>>>>>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
19055>>>>>>>>>>>>>Define FUNC_SQLFETCH               for 1000008
19055>>>>>>>>>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
19055>>>>>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
19055>>>>>>>>>>>>>Define FUNC_SQLBINDFILE            for 1000011
19055>>>>>>>>>>>>>Define FUNC_SQLGETDATA             for 1000012
19055>>>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
19055>>>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
19055>>>>>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
19055>>>>>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
19055>>>>>>>>>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
19055>>>>>>>>>>>>>Define FUNC_SQLSETPROCARG          for 1000018
19055>>>>>>>>>>>>>Define FUNC_SQLCALL                for 1000019
19055>>>>>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
19055>>>>>>>>>>>>>Define FUNC_SQLGETPROCARG          for 1000021
19055>>>>>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
19055>>>>>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
19055>>>>>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
19055>>>>>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
19055>>>>>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
19055>>>>>>>>>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
19055>>>>>>>>>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Embedded SQL statement attribute constants
19055>>>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
19055>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
19055>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
19055>>>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
19055>>>>>>>>>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
19055>>>>>>>>>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
19055>>>>>>>>>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
19055>>>>>>>>>>>>>Define SQL_CURSOR_DYNAMIC           for 2
19055>>>>>>>>>>>>>Define SQL_CURSOR_STATIC            for 3
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Embedded SQL column attribute constants
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
19055>>>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Types used for conversion with ConvertToXml
19055>>>>>>>>>>>>>Define esqlTime      for 8
19055>>>>>>>>>>>>>Define esqlDatetime  for 9
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
19055>>>>>>>>>>>>>Integer giLastSQLhdbc
19055>>>>>>>>>>>>>Integer giLastSQLhstmt
19055>>>>>>>>>>>>>
19055>>>>>>>>>>>>>Move -1 to giLastSQLhdbc
19056>>>>>>>>>>>>>Move -1 to giLastSQLhstmt
19057>>>>>>>>>>>>>
19057>>>>>>>>>>>>>Struct tSQLColumn
19057>>>>>>>>>>>>>    Integer iSQLType
19057>>>>>>>>>>>>>    Integer iSQLSize
19057>>>>>>>>>>>>>    Integer iSQLPrecision
19057>>>>>>>>>>>>>    Integer iVariableDataType
19057>>>>>>>>>>>>>End_Struct
19057>>>>>>>>>>>>>
19057>>>>>>>>>>>>>// Statement object for embedded sql                           
19057>>>>>>>>>>>>>//   An object is created for each statement. These will be children    
19057>>>>>>>>>>>>>//   of cSQLConnection objects which manage the create and destruction  
19057>>>>>>>>>>>>>//   of these.                                                          
19057>>>>>>>>>>>>>
19057>>>>>>>>>>>>>Class cSQLStatement is a cObject
19058>>>>>>>>>>>>>    
19058>>>>>>>>>>>>>    Procedure Construct_object
19060>>>>>>>>>>>>>        Forward Send Construct_object
19062>>>>>>>>>>>>>        
19062>>>>>>>>>>>>>        Property Handle  phCLIStatementHandle   0
19063>>>>>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
19064>>>>>>>>>>>>>        Property String  psDriverID             ""
19065>>>>>>>>>>>>>        
19065>>>>>>>>>>>>>        Property Integer piLastColumn      0
19066>>>>>>>>>>>>>        Property Integer piLastArgument    0
19067>>>>>>>>>>>>>        Property Integer piBindFile        0
19068>>>>>>>>>>>>>        
19068>>>>>>>>>>>>>        Property Integer piColumnCount     0
19069>>>>>>>>>>>>>        
19069>>>>>>>>>>>>>        // True if there is at least 1 column with a variable length data type
19069>>>>>>>>>>>>>        Property Integer piHasVariableDataType  0
19070>>>>>>>>>>>>>        
19070>>>>>>>>>>>>>        // Max size of buffer for variable length data. Default 16000
19070>>>>>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000
19071>>>>>>>>>>>>>        
19071>>>>>>>>>>>>>        // Allocated buffer for SQLGetData.
19071>>>>>>>>>>>>>        Property WString psVariableBuffer  ""
19072>>>>>>>>>>>>>        
19072>>>>>>>>>>>>>        // Allocated size of psVariableBuffer
19072>>>>>>>>>>>>>        Property Integer piVariableBufferLength 0
19073>>>>>>>>>>>>>        
19073>>>>>>>>>>>>>        // Stores column properties of a result set.
19073>>>>>>>>>>>>>        Property tSQLColumn[] paSQLColumns
19074>>>>>>>>>>>>>        
19074>>>>>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
19074>>>>>>>>>>>>>        //   0    = Fetch returned no data.
19074>>>>>>>>>>>>>        //   <> 0 = Row fetched
19074>>>>>>>>>>>>>        Property Integer piFetchResult     0
19075>>>>>>>>>>>>>        
19075>>>>>>>>>>>>>        
19075>>>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
19076>>>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
19077>>>>>>>>>>>>>        
19077>>>>>>>>>>>>>    End_Procedure
19078>>>>>>>>>>>>>    
19078>>>>>>>>>>>>>    // Store basic information about the statement.
19078>>>>>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
19080>>>>>>>>>>>>>        
19080>>>>>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
19081>>>>>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
19082>>>>>>>>>>>>>        Set psDriverID             to sDrvrId
19083>>>>>>>>>>>>>        
19083>>>>>>>>>>>>>    End_Procedure
19084>>>>>>>>>>>>>    
19084>>>>>>>>>>>>>    
19084>>>>>>>>>>>>>    // Destroy the cSQLStatement object
19084>>>>>>>>>>>>>    Procedure DestroySQLStatement
19086>>>>>>>>>>>>>        Send Destroy
19087>>>>>>>>>>>>>    End_Procedure
19088>>>>>>>>>>>>>    
19088>>>>>>>>>>>>>    // Handle an error that has occurred while checking properties.
19088>>>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
19090>>>>>>>>>>>>>        Integer iErrHandle
19090>>>>>>>>>>>>>        Integer iErrNum
19090>>>>>>>>>>>>>        String  sLocationInfo
19090>>>>>>>>>>>>>        
19090>>>>>>>>>>>>>        // Get the DataFlex statement identifier
19090>>>>>>>>>>>>>        Move Self to iErrHandle
19091>>>>>>>>>>>>>        
19091>>>>>>>>>>>>>        // Determine error number
19091>>>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
19094>>>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
19098>>>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
19102>>>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
19104>>>>>>>>>>>>>        
19104>>>>>>>>>>>>>        // Create location ifnormation
19104>>>>>>>>>>>>>        Move "[" to sLocationInfo
19105>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
19107>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
19108>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
19109>>>>>>>>>>>>>        End
19109>>>>>>>>>>>>>>
19109>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
19110>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
19111>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
19112>>>>>>>>>>>>>        
19112>>>>>>>>>>>>>        // Generate the error
19112>>>>>>>>>>>>>        Error iErrNum sLocationInfo
19113>>>>>>>>>>>>>>
19113>>>>>>>>>>>>>    End_Procedure
19114>>>>>>>>>>>>>    
19114>>>>>>>>>>>>>    // Handle general error not related to the properties
19114>>>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
19116>>>>>>>>>>>>>        Integer iErrHandle
19116>>>>>>>>>>>>>        String  sLocationInfo
19116>>>>>>>>>>>>>        
19116>>>>>>>>>>>>>        // Get the DataFlex statement identifier
19116>>>>>>>>>>>>>        Move Self to iErrHandle
19117>>>>>>>>>>>>>        
19117>>>>>>>>>>>>>        // Create location information
19117>>>>>>>>>>>>>        Move "[" to sLocationInfo
19118>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
19120>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
19121>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
19122>>>>>>>>>>>>>        End
19122>>>>>>>>>>>>>>
19122>>>>>>>>>>>>>        If (sErrtext <> "") Begin
19124>>>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
19125>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
19126>>>>>>>>>>>>>        End
19126>>>>>>>>>>>>>>
19126>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
19127>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
19128>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
19129>>>>>>>>>>>>>        
19129>>>>>>>>>>>>>        // Generate the error
19129>>>>>>>>>>>>>        Error iErrNum sLocationInfo
19130>>>>>>>>>>>>>>
19130>>>>>>>>>>>>>    End_Procedure
19131>>>>>>>>>>>>>    
19131>>>>>>>>>>>>>    // Handle an illegal attribute error
19131>>>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
19133>>>>>>>>>>>>>        Integer bReport
19133>>>>>>>>>>>>>        
19133>>>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
19136>>>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
19139>>>>>>>>>>>>>    End_Procedure
19140>>>>>>>>>>>>>    
19140>>>>>>>>>>>>>    // Check if a column number is legal
19140>>>>>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
19142>>>>>>>>>>>>>        Integer bLegal
19142>>>>>>>>>>>>>        Integer iNumColumns
19142>>>>>>>>>>>>>        
19142>>>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19143>>>>>>>>>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
19146>>>>>>>>>>>>>        Else ;            Move DFFALSE to bLegal
19148>>>>>>>>>>>>>        
19148>>>>>>>>>>>>>        Function_Return bLegal
19149>>>>>>>>>>>>>    End_Function
19150>>>>>>>>>>>>>    
19150>>>>>>>>>>>>>    
19150>>>>>>>>>>>>>    
19150>>>>>>>>>>>>>    // Close a statement and free all alllocated resources
19150>>>>>>>>>>>>>    Procedure SQLClose
19152>>>>>>>>>>>>>        Integer ihdbc
19152>>>>>>>>>>>>>        Integer ihstmt
19152>>>>>>>>>>>>>        Integer iVoid
19152>>>>>>>>>>>>>        String  sDrvrId
19152>>>>>>>>>>>>>        String  sEmpty
19152>>>>>>>>>>>>>        
19152>>>>>>>>>>>>>        // Initialize
19152>>>>>>>>>>>>>        Move "" to sEmpty
19153>>>>>>>>>>>>>        
19153>>>>>>>>>>>>>        // Get the cli handles
19153>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19154>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19155>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19156>>>>>>>>>>>>>        
19156>>>>>>>>>>>>>        // Free the CLI handle
19156>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19158>>>>>>>>>>>>>            // Call the driver function to close
19158>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
19163>>>>>>>>>>>>>            
19163>>>>>>>>>>>>>            Move -1 to giLastSQLhstmt
19164>>>>>>>>>>>>>            // Free the DataFlex handle
19164>>>>>>>>>>>>>            Send DestroySQLStatement
19165>>>>>>>>>>>>>        End
19165>>>>>>>>>>>>>>
19165>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
19167>>>>>>>>>>>>>    End_Procedure
19168>>>>>>>>>>>>>    
19168>>>>>>>>>>>>>    // Prepare a statement for execution
19168>>>>>>>>>>>>>    Procedure SQLPrepare String sStatement
19170>>>>>>>>>>>>>        Integer ihdbc
19170>>>>>>>>>>>>>        Integer ihstmt
19170>>>>>>>>>>>>>        Integer iVoid
19170>>>>>>>>>>>>>        String  sDrvrId
19170>>>>>>>>>>>>>        
19170>>>>>>>>>>>>>        // Get the cli handles
19170>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19171>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19172>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19173>>>>>>>>>>>>>        
19173>>>>>>>>>>>>>        // Prepare
19173>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19175>>>>>>>>>>>>>            // Call the driver function to prepare
19175>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
19180>>>>>>>>>>>>>            Set piLastArgument to 0
19181>>>>>>>>>>>>>
19181>>>>>>>>>>>>>        End
19181>>>>>>>>>>>>>>
19181>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
19183>>>>>>>>>>>>>    End_Procedure
19184>>>>>>>>>>>>>    
19184>>>>>>>>>>>>>    Procedure SQLGetStatementAttributes
19186>>>>>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
19186>>>>>>>>>>>>>        String sMaxValue
19186>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19186>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19187>>>>>>>>>>>>>        
19187>>>>>>>>>>>>>        Integer iSqlType
19187>>>>>>>>>>>>>        Integer iSQLSize
19187>>>>>>>>>>>>>        Integer iSQLprecision
19187>>>>>>>>>>>>>        Integer iVariableDataType
19187>>>>>>>>>>>>>        
19187>>>>>>>>>>>>>        String  sDrvrId
19187>>>>>>>>>>>>>        
19187>>>>>>>>>>>>>        Integer iHasVariableDataType
19187>>>>>>>>>>>>>        
19187>>>>>>>>>>>>>        Move 0 to iHasVariableDataType
19188>>>>>>>>>>>>>        
19188>>>>>>>>>>>>>        
19188>>>>>>>>>>>>>        // Get the cli handles
19188>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19189>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19190>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19191>>>>>>>>>>>>>        
19191>>>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19192>>>>>>>>>>>>>        
19192>>>>>>>>>>>>>        Set piColumnCount to iNumColumns
19193>>>>>>>>>>>>>        
19193>>>>>>>>>>>>>        // Fill columns array
19193>>>>>>>>>>>>>        For iCol from 1 to iNumColumns
19199>>>>>>>>>>>>>>
19199>>>>>>>>>>>>>            Move 0 to iVariableDataType
19200>>>>>>>>>>>>>            
19200>>>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
19201>>>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
19202>>>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
19203>>>>>>>>>>>>>            
19203>>>>>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
19205>>>>>>>>>>>>>                // text type
19205>>>>>>>>>>>>>                Move 1 to iVariableDataType
19206>>>>>>>>>>>>>            End
19206>>>>>>>>>>>>>>
19206>>>>>>>>>>>>>            Else Begin
19207>>>>>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
19209>>>>>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
19209>>>>>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
19211>>>>>>>>>>>>>                        
19211>>>>>>>>>>>>>                        Move 1 to iVariableDataType
19212>>>>>>>>>>>>>                    End
19212>>>>>>>>>>>>>>
19212>>>>>>>>>>>>>                End
19212>>>>>>>>>>>>>>
19212>>>>>>>>>>>>>            End
19212>>>>>>>>>>>>>>
19212>>>>>>>>>>>>>            
19212>>>>>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
19213>>>>>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
19214>>>>>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
19215>>>>>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
19216>>>>>>>>>>>>>            
19216>>>>>>>>>>>>>            If (not(iVariableDataType)) Begin
19218>>>>>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
19220>>>>>>>>>>>>>                    Move iSQLSize to iMaxSize
19221>>>>>>>>>>>>>                End
19221>>>>>>>>>>>>>>
19221>>>>>>>>>>>>>            End
19221>>>>>>>>>>>>>>
19221>>>>>>>>>>>>>            Else Begin
19222>>>>>>>>>>>>>                Move 1 to iHasVariableDataType
19223>>>>>>>>>>>>>            End
19223>>>>>>>>>>>>>>
19223>>>>>>>>>>>>>            
19223>>>>>>>>>>>>>        Loop
19224>>>>>>>>>>>>>>
19224>>>>>>>>>>>>>        
19224>>>>>>>>>>>>>        Set paSQLColumns   to aSQLColumns
19225>>>>>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
19226>>>>>>>>>>>>>        
19226>>>>>>>>>>>>>    End_Procedure
19227>>>>>>>>>>>>>    
19227>>>>>>>>>>>>>    // Execute a prepared statement
19227>>>>>>>>>>>>>    Procedure SQLExecute
19229>>>>>>>>>>>>>        Integer ihdbc
19229>>>>>>>>>>>>>        Integer ihstmt
19229>>>>>>>>>>>>>        Integer iVoid
19229>>>>>>>>>>>>>        String  sDrvrId
19229>>>>>>>>>>>>>        String  sEmpty
19229>>>>>>>>>>>>>        
19229>>>>>>>>>>>>>        // Initialize
19229>>>>>>>>>>>>>        Move "" to sEmpty
19230>>>>>>>>>>>>>        
19230>>>>>>>>>>>>>        // Get the cli handles
19230>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19231>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19232>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19233>>>>>>>>>>>>>        
19233>>>>>>>>>>>>>        // Execute
19233>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19235>>>>>>>>>>>>>            // Call the driver function to execute
19235>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
19240>>>>>>>>>>>>>            Send SQLGetStatementAttributes
19241>>>>>>>>>>>>>            Set piLastArgument to 0
19242>>>>>>>>>>>>>        End
19242>>>>>>>>>>>>>>
19242>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
19244>>>>>>>>>>>>>    End_Procedure
19245>>>>>>>>>>>>>    
19245>>>>>>>>>>>>>    
19245>>>>>>>>>>>>>    
19245>>>>>>>>>>>>>    // Prepare and execute a statement
19245>>>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
19247>>>>>>>>>>>>>        Integer ihdbc
19247>>>>>>>>>>>>>        Integer ihstmt
19247>>>>>>>>>>>>>        Integer iVoid
19247>>>>>>>>>>>>>        String  sDrvrId
19247>>>>>>>>>>>>>        
19247>>>>>>>>>>>>>        // Get the cli handles
19247>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19248>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19249>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19250>>>>>>>>>>>>>        
19250>>>>>>>>>>>>>        // ExecDirect
19250>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19252>>>>>>>>>>>>>            // Call the driver function to execdirect
19252>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
19257>>>>>>>>>>>>>            Send SQLGetStatementAttributes
19258>>>>>>>>>>>>>        End
19258>>>>>>>>>>>>>>
19258>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
19260>>>>>>>>>>>>>    End_Procedure
19261>>>>>>>>>>>>>    
19261>>>>>>>>>>>>>    // Fetch the next row
19261>>>>>>>>>>>>>    // Returns  : 0   = No more data
19261>>>>>>>>>>>>>    //<>0 = Success
19261>>>>>>>>>>>>>    Function SQLFetch Returns Integer
19263>>>>>>>>>>>>>        Integer ihdbc
19263>>>>>>>>>>>>>        Integer ihstmt
19263>>>>>>>>>>>>>        Integer iResult
19263>>>>>>>>>>>>>        String  sDrvrId
19263>>>>>>>>>>>>>        String  sEmpty
19263>>>>>>>>>>>>>        
19263>>>>>>>>>>>>>        // Initialize
19263>>>>>>>>>>>>>        Move "" to sEmpty
19264>>>>>>>>>>>>>        Move 0  to iResult
19265>>>>>>>>>>>>>        
19265>>>>>>>>>>>>>        // Get the cli handles
19265>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19266>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19267>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19268>>>>>>>>>>>>>        
19268>>>>>>>>>>>>>        // Fetch
19268>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19270>>>>>>>>>>>>>            Move False to Err
19271>>>>>>>>>>>>>            
19271>>>>>>>>>>>>>            // Call the driver function to fetch
19271>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19276>>>>>>>>>>>>>            
19276>>>>>>>>>>>>>            // If something went wrong, adjust the result
19276>>>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
19279>>>>>>>>>>>>>            
19279>>>>>>>>>>>>>            Set piLastcolumn to 0
19280>>>>>>>>>>>>>        End
19280>>>>>>>>>>>>>>
19280>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
19282>>>>>>>>>>>>>        
19282>>>>>>>>>>>>>        Function_Return iResult
19283>>>>>>>>>>>>>    End_Function
19284>>>>>>>>>>>>>    
19284>>>>>>>>>>>>>    // Fetch the next row and return an array with all column values
19284>>>>>>>>>>>>>    // Returns  : Array of strings with all column values
19284>>>>>>>>>>>>>    // Sets piFetchResult property
19284>>>>>>>>>>>>>    //   0    = No more data
19284>>>>>>>>>>>>>    //   <> 0 = Success
19284>>>>>>>>>>>>>    Function SQLFetchRowValues Returns String[]
19286>>>>>>>>>>>>>        
19286>>>>>>>>>>>>>        String[] asValues
19287>>>>>>>>>>>>>        
19287>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19287>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19288>>>>>>>>>>>>>        
19288>>>>>>>>>>>>>        Integer ihdbc
19288>>>>>>>>>>>>>        Integer ihstmt
19288>>>>>>>>>>>>>        Integer iResult iVoid
19288>>>>>>>>>>>>>        Integer iColCount iCol
19288>>>>>>>>>>>>>        String  sDrvrId
19288>>>>>>>>>>>>>        String  sEmpty
19288>>>>>>>>>>>>>        Longptr pResultWStr
19288>>>>>>>>>>>>>        WString wVariableResult
19288>>>>>>>>>>>>>        Integer iHasVariableDataType
19288>>>>>>>>>>>>>        Integer iLen
19288>>>>>>>>>>>>>        Integer iVariableBufferLength
19288>>>>>>>>>>>>>        
19288>>>>>>>>>>>>>        // Initialize
19288>>>>>>>>>>>>>        Move "" to sEmpty
19289>>>>>>>>>>>>>        Move 0  to iResult
19290>>>>>>>>>>>>>        
19290>>>>>>>>>>>>>        // Get the cli handles
19290>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19291>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19292>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19293>>>>>>>>>>>>>        
19293>>>>>>>>>>>>>        Get paSQLColumns to aSQLColumns
19294>>>>>>>>>>>>>        Get piColumnCount to iColCount
19295>>>>>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
19296>>>>>>>>>>>>>        
19296>>>>>>>>>>>>>        If (iHasVariableDataType) Begin
19298>>>>>>>>>>>>>            
19298>>>>>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
19299>>>>>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
19300>>>>>>>>>>>>>            
19300>>>>>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
19302>>>>>>>>>>>>>                // Allocate
19302>>>>>>>>>>>>>                Move (Repeat(' ', iLen)) to wVariableResult
19303>>>>>>>>>>>>>                
19303>>>>>>>>>>>>>                Set piVariableBufferLength to iLen
19304>>>>>>>>>>>>>                Set psVariableBuffer       to wVariableResult
19305>>>>>>>>>>>>>                
19305>>>>>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength
19306>>>>>>>>>>>>>            End
19306>>>>>>>>>>>>>>
19306>>>>>>>>>>>>>        End
19306>>>>>>>>>>>>>>
19306>>>>>>>>>>>>>        
19306>>>>>>>>>>>>>        // Fetch
19306>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19308>>>>>>>>>>>>>            Move (False) to Err
19309>>>>>>>>>>>>>            
19309>>>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19309>>>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
19309>>>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
19309>>>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19311>>>>>>>>>>>>>                // Setup function arguments
19311>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
19316>>>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
19317>>>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
19318>>>>>>>>>>>>>            End
19318>>>>>>>>>>>>>>
19318>>>>>>>>>>>>>            
19318>>>>>>>>>>>>>            // Call the driver function to fetch
19318>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
19323>>>>>>>>>>>>>            
19323>>>>>>>>>>>>>            // If something went wrong, adjust the result
19323>>>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
19326>>>>>>>>>>>>>            
19326>>>>>>>>>>>>>            If (iResult) Begin
19328>>>>>>>>>>>>>                For iCol from 1 to iColCount
19334>>>>>>>>>>>>>>
19334>>>>>>>>>>>>>                    
19334>>>>>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
19336>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sEmpty sEmpty iCol ;                            Result pResultWStr
19341>>>>>>>>>>>>>                            
19341>>>>>>>>>>>>>                        If (pResultWStr) Begin
19343>>>>>>>>>>>>>                            Move (CString(PointerToWString(pResultWStr))) to asValues[iCol - 1]
19344>>>>>>>>>>>>>                        End
19344>>>>>>>>>>>>>>
19344>>>>>>>>>>>>>                        Else Begin
19345>>>>>>>>>>>>>                            Move "" to asValues[iCol - 1]
19346>>>>>>>>>>>>>                        End
19346>>>>>>>>>>>>>>
19346>>>>>>>>>>>>>                        
19346>>>>>>>>>>>>>                    End
19346>>>>>>>>>>>>>>
19346>>>>>>>>>>>>>                    Else Begin
19347>>>>>>>>>>>>>                        Get psVariableBuffer       to wVariableResult
19348>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing iCol iVariableBufferLength (AddressOf(wVariableResult));                            Result iVoid
19353>>>>>>>>>>>>>                        
19353>>>>>>>>>>>>>                        Move (CString(wVariableResult)) to asValues[iCol - 1]
19354>>>>>>>>>>>>>                    End
19354>>>>>>>>>>>>>>
19354>>>>>>>>>>>>>                    
19354>>>>>>>>>>>>>                Loop
19355>>>>>>>>>>>>>>
19355>>>>>>>>>>>>>            End
19355>>>>>>>>>>>>>>
19355>>>>>>>>>>>>>        End
19355>>>>>>>>>>>>>>
19355>>>>>>>>>>>>>        Else Begin
19356>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
19357>>>>>>>>>>>>>        End
19357>>>>>>>>>>>>>>
19357>>>>>>>>>>>>>        
19357>>>>>>>>>>>>>        Set piFetchResult to iResult
19358>>>>>>>>>>>>>        
19358>>>>>>>>>>>>>        Function_Return asValues
19359>>>>>>>>>>>>>        
19359>>>>>>>>>>>>>    End_Function
19360>>>>>>>>>>>>>    
19360>>>>>>>>>>>>>    // Fetch a complete result set.
19360>>>>>>>>>>>>>    // Returns  : 2-dimensional array of strings with result set
19360>>>>>>>>>>>>>    // Sets piFetchResult property
19360>>>>>>>>>>>>>    //   0    = No more data
19360>>>>>>>>>>>>>    //   <> 0 = Success
19360>>>>>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][]
19362>>>>>>>>>>>>>        
19362>>>>>>>>>>>>>        String[][] asValues
19363>>>>>>>>>>>>>        
19363>>>>>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
19363>>>>>>>>>>>>>        String sDrvrId sEmpty sMax
19363>>>>>>>>>>>>>        Longptr pResultWStr
19363>>>>>>>>>>>>>        WString wResult
19363>>>>>>>>>>>>>        
19363>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19363>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19364>>>>>>>>>>>>>        WString  wVariableResult
19364>>>>>>>>>>>>>        Integer iHasVariableDataType
19364>>>>>>>>>>>>>        Integer iLen
19364>>>>>>>>>>>>>        Integer iVariableBufferLength
19364>>>>>>>>>>>>>        
19364>>>>>>>>>>>>>        // Initialize
19364>>>>>>>>>>>>>        Move "" to sEmpty
19365>>>>>>>>>>>>>        Move 0  to iResult
19366>>>>>>>>>>>>>        
19366>>>>>>>>>>>>>        // Get the cli handles
19366>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19367>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19368>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19369>>>>>>>>>>>>>        
19369>>>>>>>>>>>>>        // Fetch
19369>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19371>>>>>>>>>>>>>            Move False to Err
19372>>>>>>>>>>>>>            
19372>>>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19372>>>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
19372>>>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
19372>>>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19374>>>>>>>>>>>>>                // Setup function arguments
19374>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
19379>>>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
19380>>>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
19381>>>>>>>>>>>>>            End
19381>>>>>>>>>>>>>>
19381>>>>>>>>>>>>>            
19381>>>>>>>>>>>>>            Get piColumnCount to iColCount
19382>>>>>>>>>>>>>            If (iColCount) Begin
19384>>>>>>>>>>>>>                Get paSQLColumns to aSQLColumns
19385>>>>>>>>>>>>>                Get piHasVariableDataType to iHasVariableDataType
19386>>>>>>>>>>>>>                If (iHasVariableDataType) Begin
19388>>>>>>>>>>>>>                    Get piVariableBufferLength      to iVariableBufferLength
19389>>>>>>>>>>>>>                    Get piMaxVariableBufferLength   to iLen
19390>>>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
19392>>>>>>>>>>>>>                        // Allocate
19392>>>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to wVariableResult
19393>>>>>>>>>>>>>                        
19393>>>>>>>>>>>>>                        Set piVariableBufferLength to iLen
19394>>>>>>>>>>>>>                        Set psVariableBuffer       to wVariableResult
19395>>>>>>>>>>>>>                        
19395>>>>>>>>>>>>>                        Get piVariableBufferLength to iVariableBufferLength
19396>>>>>>>>>>>>>                    End
19396>>>>>>>>>>>>>>
19396>>>>>>>>>>>>>                    Else Begin
19397>>>>>>>>>>>>>                        Set psVariableBuffer       to wVariableResult
19398>>>>>>>>>>>>>                    End
19398>>>>>>>>>>>>>>
19398>>>>>>>>>>>>>                End
19398>>>>>>>>>>>>>>
19398>>>>>>>>>>>>>                
19398>>>>>>>>>>>>>                // Call the driver function to fetch
19398>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19403>>>>>>>>>>>>>                If (Err) ;                    Move 0 to iResult
19406>>>>>>>>>>>>>                
19406>>>>>>>>>>>>>                While (iResult <> 0)
19410>>>>>>>>>>>>>                    
19410>>>>>>>>>>>>>                    For iCol from 1 to (iColCount)
19416>>>>>>>>>>>>>>
19416>>>>>>>>>>>>>                        
19416>>>>>>>>>>>>>                        If (not(aSQLColumns[iCol].iVariableDataType)) Begin
19418>>>>>>>>>>>>>                            
19418>>>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback 0 ;                                Passing sEmpty sEmpty iCol ;                                Result pResultWStr
19423>>>>>>>>>>>>>                            
19423>>>>>>>>>>>>>                            If (pResultWStr) Begin
19425>>>>>>>>>>>>>                                Move (CString(PointerToWString(pResultWStr))) to asValues[iRow][iCol - 1]
19426>>>>>>>>>>>>>                            End
19426>>>>>>>>>>>>>>
19426>>>>>>>>>>>>>                            Else Begin
19427>>>>>>>>>>>>>                                Move "" to asValues[iRow][iCol - 1]
19428>>>>>>>>>>>>>                            End
19428>>>>>>>>>>>>>>
19428>>>>>>>>>>>>>                        End
19428>>>>>>>>>>>>>>
19428>>>>>>>>>>>>>                        Else Begin
19429>>>>>>>>>>>>>                            //Variable data
19429>>>>>>>>>>>>>                            Move wVariableResult to wResult
19430>>>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback 0 ;                                Passing iCol iVariableBufferLength (AddressOf(wResult)) ;                                Result iVoid
19435>>>>>>>>>>>>>                            
19435>>>>>>>>>>>>>                            Move (CString(wResult)) to asValues[iRow][iCol - 1]
19436>>>>>>>>>>>>>                        End
19436>>>>>>>>>>>>>>
19436>>>>>>>>>>>>>                    Loop
19437>>>>>>>>>>>>>>
19437>>>>>>>>>>>>>                    
19437>>>>>>>>>>>>>                    Increment iRow
19438>>>>>>>>>>>>>                    
19438>>>>>>>>>>>>>                    // Call the driver function to fetch
19438>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19443>>>>>>>>>>>>>                    If (Err) ;                        Move 0 to iResult
19446>>>>>>>>>>>>>                    
19446>>>>>>>>>>>>>                Loop
19447>>>>>>>>>>>>>>
19447>>>>>>>>>>>>>            End
19447>>>>>>>>>>>>>>
19447>>>>>>>>>>>>>        End
19447>>>>>>>>>>>>>>
19447>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
19449>>>>>>>>>>>>>        
19449>>>>>>>>>>>>>        Set piFetchResult to iResult
19450>>>>>>>>>>>>>        
19450>>>>>>>>>>>>>        Function_Return asValues
19451>>>>>>>>>>>>>    End_Function
19452>>>>>>>>>>>>>    
19452>>>>>>>>>>>>>    // Get the next column
19452>>>>>>>>>>>>>    Function SQLNextColumn Returns String
19454>>>>>>>>>>>>>        Integer iCol
19454>>>>>>>>>>>>>        String  sResult
19454>>>>>>>>>>>>>        
19454>>>>>>>>>>>>>        Get piLastColumn to iCol
19455>>>>>>>>>>>>>        Increment iCol
19456>>>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
19457>>>>>>>>>>>>>        Set piLastColumn to iCol
19458>>>>>>>>>>>>>        
19458>>>>>>>>>>>>>        Function_Return sResult
19459>>>>>>>>>>>>>    End_Function
19460>>>>>>>>>>>>>    
19460>>>>>>>>>>>>>    
19460>>>>>>>>>>>>>    // Returns the native type of a column
19460>>>>>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
19462>>>>>>>>>>>>>        Integer ihdbc
19462>>>>>>>>>>>>>        Integer ihstmt
19462>>>>>>>>>>>>>        String  sDrvrId
19462>>>>>>>>>>>>>        Integer iSQLType
19462>>>>>>>>>>>>>        Integer iColumns
19462>>>>>>>>>>>>>        
19462>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19462>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19463>>>>>>>>>>>>>        
19463>>>>>>>>>>>>>        // Get the cli handles
19463>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19464>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19465>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19466>>>>>>>>>>>>>        
19466>>>>>>>>>>>>>        // Get the value
19466>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19468>>>>>>>>>>>>>            
19468>>>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19469>>>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19470>>>>>>>>>>>>>            
19470>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19472>>>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
19473>>>>>>>>>>>>>            End
19473>>>>>>>>>>>>>>
19473>>>>>>>>>>>>>            Else Begin
19474>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
19475>>>>>>>>>>>>>            End
19475>>>>>>>>>>>>>>
19475>>>>>>>>>>>>>        End
19475>>>>>>>>>>>>>>
19475>>>>>>>>>>>>>        Else Begin
19476>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
19477>>>>>>>>>>>>>        End
19477>>>>>>>>>>>>>>
19477>>>>>>>>>>>>>        
19477>>>>>>>>>>>>>        Function_Return iSQLType
19478>>>>>>>>>>>>>    End_Function
19479>>>>>>>>>>>>>    
19479>>>>>>>>>>>>>    // Returns the size (max length) of a column
19479>>>>>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
19481>>>>>>>>>>>>>        Integer ihdbc
19481>>>>>>>>>>>>>        Integer ihstmt
19481>>>>>>>>>>>>>        String  sDrvrId
19481>>>>>>>>>>>>>        Integer iSQLSize
19481>>>>>>>>>>>>>        Integer iColumns
19481>>>>>>>>>>>>>        
19481>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19481>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19482>>>>>>>>>>>>>        
19482>>>>>>>>>>>>>        // Get the cli handles
19482>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19483>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19484>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19485>>>>>>>>>>>>>        
19485>>>>>>>>>>>>>        // Get the value
19485>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19487>>>>>>>>>>>>>            
19487>>>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19488>>>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19489>>>>>>>>>>>>>            
19489>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19491>>>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
19492>>>>>>>>>>>>>            End
19492>>>>>>>>>>>>>>
19492>>>>>>>>>>>>>            Else Begin
19493>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
19494>>>>>>>>>>>>>            End
19494>>>>>>>>>>>>>>
19494>>>>>>>>>>>>>        End
19494>>>>>>>>>>>>>>
19494>>>>>>>>>>>>>        Else Begin
19495>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
19496>>>>>>>>>>>>>        End
19496>>>>>>>>>>>>>>
19496>>>>>>>>>>>>>        
19496>>>>>>>>>>>>>        Function_Return iSQLSize
19497>>>>>>>>>>>>>    End_Function
19498>>>>>>>>>>>>>    
19498>>>>>>>>>>>>>    //  Returns 1 for variable length datatypes.
19498>>>>>>>>>>>>>    //  For example SQL Server varchar(max) or text type
19498>>>>>>>>>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
19498>>>>>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
19500>>>>>>>>>>>>>        Integer ihdbc
19500>>>>>>>>>>>>>        Integer ihstmt
19500>>>>>>>>>>>>>        String  sDrvrId
19500>>>>>>>>>>>>>        Integer iVariableDataType
19500>>>>>>>>>>>>>        Integer iColumns
19500>>>>>>>>>>>>>        
19500>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19500>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19501>>>>>>>>>>>>>        
19501>>>>>>>>>>>>>        // Get the cli handles
19501>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19502>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19503>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19504>>>>>>>>>>>>>        
19504>>>>>>>>>>>>>        // Get the value
19504>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19506>>>>>>>>>>>>>            
19506>>>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19507>>>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19508>>>>>>>>>>>>>            
19508>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19510>>>>>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
19511>>>>>>>>>>>>>            End
19511>>>>>>>>>>>>>>
19511>>>>>>>>>>>>>            Else Begin
19512>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
19513>>>>>>>>>>>>>            End
19513>>>>>>>>>>>>>>
19513>>>>>>>>>>>>>        End
19513>>>>>>>>>>>>>>
19513>>>>>>>>>>>>>        Else Begin
19514>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
19515>>>>>>>>>>>>>        End
19515>>>>>>>>>>>>>>
19515>>>>>>>>>>>>>        
19515>>>>>>>>>>>>>        Function_Return iVariableDataType
19516>>>>>>>>>>>>>    End_Function
19517>>>>>>>>>>>>>    
19517>>>>>>>>>>>>>    
19517>>>>>>>>>>>>>    // Return the value of a column in a fetched row of a given
19517>>>>>>>>>>>>>    // statement.
19517>>>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
19519>>>>>>>>>>>>>        Integer ihdbc
19519>>>>>>>>>>>>>        Integer ihstmt
19519>>>>>>>>>>>>>        String  sDrvrId sResult
19519>>>>>>>>>>>>>        Longptr pResultWStr
19519>>>>>>>>>>>>>        
19519>>>>>>>>>>>>>        Integer iVoid
19519>>>>>>>>>>>>>        Integer iColSize
19519>>>>>>>>>>>>>        Integer iColPrecision
19519>>>>>>>>>>>>>        String  sEmpty
19519>>>>>>>>>>>>>        Integer bLegalColumn
19519>>>>>>>>>>>>>        
19519>>>>>>>>>>>>>        // Initialize
19519>>>>>>>>>>>>>        Move "" to sResult
19520>>>>>>>>>>>>>        
19520>>>>>>>>>>>>>        // Get the cli handles
19520>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19521>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19522>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19523>>>>>>>>>>>>>        
19523>>>>>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19523>>>>>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
19523>>>>>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
19523>>>>>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19525>>>>>>>>>>>>>            // Setup function arguments
19525>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
19530>>>>>>>>>>>>>            Move ihstmt to giLastSQLhstmt
19531>>>>>>>>>>>>>            Move ihdbc to giLastSQLhdbc
19532>>>>>>>>>>>>>        End
19532>>>>>>>>>>>>>>
19532>>>>>>>>>>>>>        
19532>>>>>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19534>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result pResultWStr
19539>>>>>>>>>>>>>            
19539>>>>>>>>>>>>>            If (pResultWStr) Begin
19541>>>>>>>>>>>>>                Move (PointerToWString(pResultWStr)) to sResult
19542>>>>>>>>>>>>>            End
19542>>>>>>>>>>>>>>
19542>>>>>>>>>>>>>            Else Begin
19543>>>>>>>>>>>>>                Move "" to sResult
19544>>>>>>>>>>>>>            End
19544>>>>>>>>>>>>>>
19544>>>>>>>>>>>>>        End
19544>>>>>>>>>>>>>>
19544>>>>>>>>>>>>>        Else Begin
19545>>>>>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
19546>>>>>>>>>>>>>        End
19546>>>>>>>>>>>>>>
19546>>>>>>>>>>>>>        
19546>>>>>>>>>>>>>        Function_Return sResult
19547>>>>>>>>>>>>>        
19547>>>>>>>>>>>>>    End_Function
19548>>>>>>>>>>>>>    
19548>>>>>>>>>>>>>    // Add a file to the files used to place the statement result in.
19548>>>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
19550>>>>>>>>>>>>>        Integer ihdbc
19550>>>>>>>>>>>>>        Integer ihstmt
19550>>>>>>>>>>>>>        Integer iVoid
19550>>>>>>>>>>>>>        String  sDrvrId
19550>>>>>>>>>>>>>        String  sFileType
19550>>>>>>>>>>>>>        Integer bIsOpen
19550>>>>>>>>>>>>>        
19550>>>>>>>>>>>>>        // Get the cli handles
19550>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19551>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19552>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19553>>>>>>>>>>>>>        
19553>>>>>>>>>>>>>        // If a file number is not passed see if we can use the statement's
19553>>>>>>>>>>>>>        // default file number which is usually set with SetFileConnection
19553>>>>>>>>>>>>>        If (iFileNum = 0) Begin
19555>>>>>>>>>>>>>            Get piBindFile to iFileNum
19556>>>>>>>>>>>>>            If (iFileNum = 0) Begin
19558>>>>>>>>>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
19558>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
19559>>>>>>>>>>>>>                
19559>>>>>>>>>>>>>                Move 0 to SQLResult
19560>>>>>>>>>>>>>                Procedure_Return
19561>>>>>>>>>>>>>            End
19561>>>>>>>>>>>>>>
19561>>>>>>>>>>>>>        End
19561>>>>>>>>>>>>>>
19561>>>>>>>>>>>>>        
19561>>>>>>>>>>>>>        // Bind the file
19561>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19563>>>>>>>>>>>>>            // Chek if the file is open
19563>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
19566>>>>>>>>>>>>>            If (bIsOpen) Begin
19568>>>>>>>>>>>>>                // Check if the file has the correct type
19568>>>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
19571>>>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
19573>>>>>>>>>>>>>                    // Call the driver function to add a file to a statement
19573>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
19578>>>>>>>>>>>>>                End
19578>>>>>>>>>>>>>>
19578>>>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
19580>>>>>>>>>>>>>            End
19580>>>>>>>>>>>>>>
19580>>>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
19582>>>>>>>>>>>>>        End
19582>>>>>>>>>>>>>>
19582>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
19584>>>>>>>>>>>>>    End_Procedure
19585>>>>>>>>>>>>>    
19585>>>>>>>>>>>>>    
19585>>>>>>>>>>>>>    
19585>>>>>>>>>>>>>    // Get data of a column.                                  
19585>>>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
19587>>>>>>>>>>>>>        Integer ihdbc
19587>>>>>>>>>>>>>        Integer ihstmt
19587>>>>>>>>>>>>>        Integer iVoid
19587>>>>>>>>>>>>>        Integer iColSize
19587>>>>>>>>>>>>>        Integer iResult
19587>>>>>>>>>>>>>        String  sDrvrId
19587>>>>>>>>>>>>>        WString wResult
19587>>>>>>>>>>>>>        String  sEmpty
19587>>>>>>>>>>>>>        Integer bLegalColumn
19587>>>>>>>>>>>>>        
19587>>>>>>>>>>>>>        Integer iVariableBufferLength
19587>>>>>>>>>>>>>        
19587>>>>>>>>>>>>>        // Initialize
19587>>>>>>>>>>>>>        Move "" to sEmpty
19588>>>>>>>>>>>>>        Move 0 to iResult
19589>>>>>>>>>>>>>        
19589>>>>>>>>>>>>>        // Get the cli handles
19589>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19590>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19591>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19592>>>>>>>>>>>>>        
19592>>>>>>>>>>>>>        // Get the data
19592>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19594>>>>>>>>>>>>>            // Check if the column exists
19594>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19596>>>>>>>>>>>>>                If (iLen = 0) Begin
19598>>>>>>>>>>>>>                    Get SQLColumnValue iCol to wResult
19599>>>>>>>>>>>>>                End
19599>>>>>>>>>>>>>>
19599>>>>>>>>>>>>>                Else Begin
19600>>>>>>>>>>>>>                    // Add 1 for string terminator
19600>>>>>>>>>>>>>                    Move (iLen + 1) to iLen
19601>>>>>>>>>>>>>                    
19601>>>>>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
19602>>>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
19604>>>>>>>>>>>>>                        // Allocate
19604>>>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to wResult
19605>>>>>>>>>>>>>                        
19605>>>>>>>>>>>>>                        Set piVariableBufferLength to iLen
19606>>>>>>>>>>>>>                        Set psVariableBuffer       to wResult
19607>>>>>>>>>>>>>                    End
19607>>>>>>>>>>>>>>
19607>>>>>>>>>>>>>                    Else Begin
19608>>>>>>>>>>>>>                        Get psVariableBuffer       to wResult
19609>>>>>>>>>>>>>                    End
19609>>>>>>>>>>>>>>
19609>>>>>>>>>>>>>                    
19609>>>>>>>>>>>>>                    
19609>>>>>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19609>>>>>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
19609>>>>>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
19609>>>>>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19611>>>>>>>>>>>>>                        // Setup function arguments
19611>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
19616>>>>>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
19617>>>>>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
19618>>>>>>>>>>>>>                    End
19618>>>>>>>>>>>>>>
19618>>>>>>>>>>>>>                    
19618>>>>>>>>>>>>>                    Move False to Err
19619>>>>>>>>>>>>>                    // Call the driver function to get the data
19619>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing iCol iLen (AddressOf(wResult)) ;                        Result iResult
19624>>>>>>>>>>>>>                    
19624>>>>>>>>>>>>>                    // If something went wrong, adjust the result
19624>>>>>>>>>>>>>                    If (Err) Begin
19626>>>>>>>>>>>>>                        Move 0 to iResult
19627>>>>>>>>>>>>>                    End
19627>>>>>>>>>>>>>>
19627>>>>>>>>>>>>>                    
19627>>>>>>>>>>>>>                    // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
19627>>>>>>>>>>>>>                    If (iResult = -4) Begin
19629>>>>>>>>>>>>>                        Move (SizeOfWString(wResult)) to iResult
19630>>>>>>>>>>>>>                    End
19630>>>>>>>>>>>>>>
19630>>>>>>>>>>>>>                End
19630>>>>>>>>>>>>>>
19630>>>>>>>>>>>>>            End
19630>>>>>>>>>>>>>>
19630>>>>>>>>>>>>>            Else Begin
19631>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
19632>>>>>>>>>>>>>            End
19632>>>>>>>>>>>>>>
19632>>>>>>>>>>>>>        End
19632>>>>>>>>>>>>>>
19632>>>>>>>>>>>>>        Else Begin
19633>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
19634>>>>>>>>>>>>>        End
19634>>>>>>>>>>>>>>
19634>>>>>>>>>>>>>        
19634>>>>>>>>>>>>>        // Fill global result
19634>>>>>>>>>>>>>        If (iResult > 0) Begin
19636>>>>>>>>>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
19637>>>>>>>>>>>>>        End
19637>>>>>>>>>>>>>>
19637>>>>>>>>>>>>>        Else Begin
19638>>>>>>>>>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
19639>>>>>>>>>>>>>        End
19639>>>>>>>>>>>>>>
19639>>>>>>>>>>>>>        
19639>>>>>>>>>>>>>        Function_Return (CString(wResult))
19640>>>>>>>>>>>>>    End_Function
19641>>>>>>>>>>>>>
19641>>>>>>>>>>>>>    // SQLGetDataToUChar (SQLGetData returning uchar array)
19641>>>>>>>>>>>>>    // Use for binary data and for character data containing Unicode non-bmp characters
19641>>>>>>>>>>>>>    Function SQLGetDataToUChar Integer iCol Integer iLen Returns UChar[]
19643>>>>>>>>>>>>>        Integer ihdbc
19643>>>>>>>>>>>>>        Integer ihstmt
19643>>>>>>>>>>>>>        Integer iVoid
19643>>>>>>>>>>>>>        Integer iColSize
19643>>>>>>>>>>>>>        Integer iResult
19643>>>>>>>>>>>>>        String  sDrvrId
19643>>>>>>>>>>>>>        UChar[] uaResult
19644>>>>>>>>>>>>>        
19644>>>>>>>>>>>>>        Integer iSQLType
19644>>>>>>>>>>>>>        Integer iBinaryType
19644>>>>>>>>>>>>>        Integer iLenArray
19644>>>>>>>>>>>>>        Integer iResizeSize
19644>>>>>>>>>>>>>        
19644>>>>>>>>>>>>>        Move 0 to iResult
19645>>>>>>>>>>>>>        
19645>>>>>>>>>>>>>        // Get the cli handles
19645>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19646>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19647>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19648>>>>>>>>>>>>>        
19648>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19650>>>>>>>>>>>>>            // Check if the column exists
19650>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19652>>>>>>>>>>>>>                            
19652>>>>>>>>>>>>>                Get SQLColumnType iCol to iSQLType
19653>>>>>>>>>>>>>                If ( (iSQLType = SQL_BINARY) or (iSQLType = SQL_VARBINARY) or (iSQLType = SQL_LONGVARBINARY) ) Begin
19655>>>>>>>>>>>>>                    Move 1 to iBinaryType
19656>>>>>>>>>>>>>                End
19656>>>>>>>>>>>>>>
19656>>>>>>>>>>>>>                Else Begin
19657>>>>>>>>>>>>>                    Move 0 to iBinaryType 
19658>>>>>>>>>>>>>                End
19658>>>>>>>>>>>>>>
19658>>>>>>>>>>>>>    
19658>>>>>>>>>>>>>                If (iBinaryType) Begin
19660>>>>>>>>>>>>>                    Move (ResizeArray(uaResult,iLen)) to uaResult
19661>>>>>>>>>>>>>                End
19661>>>>>>>>>>>>>>
19661>>>>>>>>>>>>>                Else Begin
19662>>>>>>>>>>>>>                    // Character type
19662>>>>>>>>>>>>>                    // returned as wstring (2 bytes per character)
19662>>>>>>>>>>>>>                    // Add 1 for string terminator
19662>>>>>>>>>>>>>                    Move (iLen + 1) to iLen
19663>>>>>>>>>>>>>                    Move (iLen * 2) to iLenArray // wstring 2 bytes per char
19664>>>>>>>>>>>>>                    Move (ResizeArray(uaResult,iLenArray)) to uaResult
19665>>>>>>>>>>>>>                End
19665>>>>>>>>>>>>>>
19665>>>>>>>>>>>>>
19665>>>>>>>>>>>>>                // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19665>>>>>>>>>>>>>                // in the next FUNC_SQLCOLUMNVALUE call.
19665>>>>>>>>>>>>>                If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19667>>>>>>>>>>>>>                    // Setup function arguments
19667>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
19672>>>>>>>>>>>>>                    Move ihstmt to giLastSQLhstmt
19673>>>>>>>>>>>>>                    Move ihdbc to giLastSQLhdbc
19674>>>>>>>>>>>>>                End
19674>>>>>>>>>>>>>>
19674>>>>>>>>>>>>>                
19674>>>>>>>>>>>>>                Move False to Err
19675>>>>>>>>>>>>>                
19675>>>>>>>>>>>>>                // Call the driver function to get the data
19675>>>>>>>>>>>>>                // iResult will be the length of the data in bytes 
19675>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                    Callback Self ;                    Passing iCol iLen (AddressOf(uaResult[0])) ;                    Result iResult
19680>>>>>>>>>>>>>                
19680>>>>>>>>>>>>>                // If something went wrong, adjust the result
19680>>>>>>>>>>>>>                If (Err) Begin
19682>>>>>>>>>>>>>                    Move 0 to iResult
19683>>>>>>>>>>>>>                End
19683>>>>>>>>>>>>>>
19683>>>>>>>>>>>>>                
19683>>>>>>>>>>>>>                // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
19683>>>>>>>>>>>>>                If (iResult = -4) Begin
19685>>>>>>>>>>>>>                    Move (SizeOfArray(uaResult)) to iResult
19686>>>>>>>>>>>>>                End
19686>>>>>>>>>>>>>>
19686>>>>>>>>>>>>>                
19686>>>>>>>>>>>>>                If (iBinaryType) Begin
19688>>>>>>>>>>>>>                    If (iResult < iLen) Begin
19690>>>>>>>>>>>>>                        Move (ResizeArray(uaResult,iResult)) to uaResult
19691>>>>>>>>>>>>>                    End
19691>>>>>>>>>>>>>>
19691>>>>>>>>>>>>>                End
19691>>>>>>>>>>>>>>
19691>>>>>>>>>>>>>                Else Begin
19692>>>>>>>>>>>>>                    // Character data
19692>>>>>>>>>>>>>                    //   iResult has length of data in bytes (without zero terminator)
19692>>>>>>>>>>>>>                    //   uaResult will have data + zero terminator
19692>>>>>>>>>>>>>                    If (iResult < (iLenArray - 2) ) Begin
19694>>>>>>>>>>>>>                        // Received less than requested, strip off trailing zeroes.
19694>>>>>>>>>>>>>                        Move iResult to iResizeSize
19695>>>>>>>>>>>>>                    End
19695>>>>>>>>>>>>>>
19695>>>>>>>>>>>>>                    Else Begin
19696>>>>>>>>>>>>>                        // Strip off zero terminator
19696>>>>>>>>>>>>>                        Move (iLenArray - 2) to iResizeSize
19697>>>>>>>>>>>>>                    End
19697>>>>>>>>>>>>>>
19697>>>>>>>>>>>>>                    
19697>>>>>>>>>>>>>                    Move (ResizeArray(uaResult,iResizeSize)) to uaResult
19698>>>>>>>>>>>>>                    
19698>>>>>>>>>>>>>                End
19698>>>>>>>>>>>>>>
19698>>>>>>>>>>>>>            End
19698>>>>>>>>>>>>>>
19698>>>>>>>>>>>>>            Else Begin
19699>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
19700>>>>>>>>>>>>>            End
19700>>>>>>>>>>>>>>
19700>>>>>>>>>>>>>        End
19700>>>>>>>>>>>>>>
19700>>>>>>>>>>>>>        Else Begin
19701>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
19702>>>>>>>>>>>>>        End
19702>>>>>>>>>>>>>>
19702>>>>>>>>>>>>>        
19702>>>>>>>>>>>>>        // Fill global result
19702>>>>>>>>>>>>>        If (iResult > 0) Begin
19704>>>>>>>>>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
19705>>>>>>>>>>>>>        End
19705>>>>>>>>>>>>>>
19705>>>>>>>>>>>>>        Else Begin
19706>>>>>>>>>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
19707>>>>>>>>>>>>>        End
19707>>>>>>>>>>>>>>
19707>>>>>>>>>>>>>        
19707>>>>>>>>>>>>>        Function_Return uaResult
19708>>>>>>>>>>>>>
19708>>>>>>>>>>>>>    End_Function
19709>>>>>>>>>>>>>    
19709>>>>>>>>>>>>>    
19709>>>>>>>>>>>>>    // Map a column name to a number, if the name id not found no
19709>>>>>>>>>>>>>    // error is generated the returned number will be 0 (zero) in
19709>>>>>>>>>>>>>    // that case
19709>>>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
19711>>>>>>>>>>>>>        Integer ihdbc
19711>>>>>>>>>>>>>        Integer ihstmt
19711>>>>>>>>>>>>>        Integer iNumColumns
19711>>>>>>>>>>>>>        Integer iColCount
19711>>>>>>>>>>>>>        Integer iColNum
19711>>>>>>>>>>>>>        String  sDrvrId
19711>>>>>>>>>>>>>        String  sCurColName
19711>>>>>>>>>>>>>        
19711>>>>>>>>>>>>>        // Get the cli handles
19711>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19712>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19713>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19714>>>>>>>>>>>>>        
19714>>>>>>>>>>>>>        // Get the number by looping through the column names
19714>>>>>>>>>>>>>        Move 0 to iColNum
19715>>>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19716>>>>>>>>>>>>>        For iColCount from 1 to iNumColumns
19722>>>>>>>>>>>>>>
19722>>>>>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
19723>>>>>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
19726>>>>>>>>>>>>>            
19726>>>>>>>>>>>>>            If (iColNum) ;                Break
19729>>>>>>>>>>>>>        Loop
19730>>>>>>>>>>>>>>
19730>>>>>>>>>>>>>        
19730>>>>>>>>>>>>>        Function_Return iColNum
19731>>>>>>>>>>>>>    End_Function
19732>>>>>>>>>>>>>    
19732>>>>>>>>>>>>>    
19732>>>>>>>>>>>>>    // SQLStmtAttribute
19732>>>>>>>>>>>>>    // Moved to SQLGetStatementAttribute. 
19732>>>>>>>>>>>>>    // This function is still here for backward compatibility.
19732>>>>>>>>>>>>>
19732>>>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
19734>>>>>>>>>>>>>        String  sResult
19734>>>>>>>>>>>>>
19734>>>>>>>>>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
19735>>>>>>>>>>>>>        
19735>>>>>>>>>>>>>        Function_Return sResult
19736>>>>>>>>>>>>>    End_Function
19737>>>>>>>>>>>>>
19737>>>>>>>>>>>>> 
19737>>>>>>>>>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
19739>>>>>>>>>>>>>        Integer ihdbc
19739>>>>>>>>>>>>>        Integer ihstmt
19739>>>>>>>>>>>>>        String  sResult
19739>>>>>>>>>>>>>        String  sDrvrId
19739>>>>>>>>>>>>>        
19739>>>>>>>>>>>>>        // Initialize
19739>>>>>>>>>>>>>        Move "" to sResult
19740>>>>>>>>>>>>>        
19740>>>>>>>>>>>>>        // Get the cli handles
19740>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19741>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19742>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19743>>>>>>>>>>>>>        
19743>>>>>>>>>>>>>        // Get the attribute
19743>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
19746>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
19748>>>>>>>>>>>>>        
19748>>>>>>>>>>>>>        Function_Return sResult
19749>>>>>>>>>>>>>    End_Function
19750>>>>>>>>>>>>>
19750>>>>>>>>>>>>>    
19750>>>>>>>>>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
19752>>>>>>>>>>>>>
19752>>>>>>>>>>>>>        Integer ihdbc
19752>>>>>>>>>>>>>        Integer ihstmt
19752>>>>>>>>>>>>>        String  sDrvrId
19752>>>>>>>>>>>>>        
19752>>>>>>>>>>>>>        Integer iLen
19752>>>>>>>>>>>>>        Integer bLegalAttrib
19752>>>>>>>>>>>>>        Integer iVoid
19752>>>>>>>>>>>>>        Integer iAttribValue
19752>>>>>>>>>>>>>
19752>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19753>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19754>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19755>>>>>>>>>>>>>        
19755>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19757>>>>>>>>>>>>>            Case Begin
19757>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
19759>>>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
19760>>>>>>>>>>>>>                    Break
19761>>>>>>>>>>>>>                    
19761>>>>>>>>>>>>>                Case Else
19761>>>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
19762>>>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
19763>>>>>>>>>>>>>            Case End
19763>>>>>>>>>>>>>
19763>>>>>>>>>>>>>            If (bLegalAttrib) Begin
19765>>>>>>>>>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
19767>>>>>>>>>>>>>                    
19767>>>>>>>>>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
19768>>>>>>>>>>>>>                    Case Begin
19768>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
19770>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
19773>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
19776>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
19779>>>>>>>>>>>>>                            Break
19780>>>>>>>>>>>>>                            
19780>>>>>>>>>>>>>                        Case Else
19780>>>>>>>>>>>>>                            Move DFFALSE to bLegalAttrib
19781>>>>>>>>>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
19782>>>>>>>>>>>>>
19782>>>>>>>>>>>>>                    Case End
19782>>>>>>>>>>>>>                End
19782>>>>>>>>>>>>>>
19782>>>>>>>>>>>>>            End
19782>>>>>>>>>>>>>>
19782>>>>>>>>>>>>>
19782>>>>>>>>>>>>>            
19782>>>>>>>>>>>>>            If (bLegalAttrib) Begin
19784>>>>>>>>>>>>>                
19784>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
19789>>>>>>>>>>>>>                
19789>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
19794>>>>>>>>>>>>>            End
19794>>>>>>>>>>>>>>
19794>>>>>>>>>>>>>        End
19794>>>>>>>>>>>>>>
19794>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
19796>>>>>>>>>>>>>        
19796>>>>>>>>>>>>>        
19796>>>>>>>>>>>>>        
19796>>>>>>>>>>>>>    End_Procedure
19797>>>>>>>>>>>>>    
19797>>>>>>>>>>>>>    
19797>>>>>>>>>>>>>    
19797>>>>>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
19799>>>>>>>>>>>>>        String  sResult
19799>>>>>>>>>>>>>        Integer iLen
19799>>>>>>>>>>>>>        Integer bLegalAttrib
19799>>>>>>>>>>>>>        
19799>>>>>>>>>>>>>        // Initialize
19799>>>>>>>>>>>>>        Move ""     to sResult
19800>>>>>>>>>>>>>        
19800>>>>>>>>>>>>>        // Get the attribute
19800>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19802>>>>>>>>>>>>>            Case Begin
19802>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
19804>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
19807>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
19810>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
19813>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
19816>>>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
19817>>>>>>>>>>>>>                    Break
19818>>>>>>>>>>>>>                    
19818>>>>>>>>>>>>>                Case Else
19818>>>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
19819>>>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
19820>>>>>>>>>>>>>            Case End
19820>>>>>>>>>>>>>            
19820>>>>>>>>>>>>>            If (bLegalAttrib) Begin
19822>>>>>>>>>>>>>                // Setup function arguments
19822>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
19827>>>>>>>>>>>>>            End
19827>>>>>>>>>>>>>>
19827>>>>>>>>>>>>>        End
19827>>>>>>>>>>>>>>
19827>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
19829>>>>>>>>>>>>>        
19829>>>>>>>>>>>>>        Function_Return sResult
19830>>>>>>>>>>>>>    End_Function
19831>>>>>>>>>>>>>    
19831>>>>>>>>>>>>>    
19831>>>>>>>>>>>>>    
19831>>>>>>>>>>>>>    // Get a column's attribute
19831>>>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
19833>>>>>>>>>>>>>        Integer ihdbc
19833>>>>>>>>>>>>>        Integer ihstmt
19833>>>>>>>>>>>>>        String  sResult
19833>>>>>>>>>>>>>        String  sDrvrId
19833>>>>>>>>>>>>>        
19833>>>>>>>>>>>>>        // Initialize
19833>>>>>>>>>>>>>        Move "" to sResult
19834>>>>>>>>>>>>>        
19834>>>>>>>>>>>>>        // Get the cli handles
19834>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19835>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19836>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19837>>>>>>>>>>>>>        
19837>>>>>>>>>>>>>        // Get the attribute
19837>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
19840>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
19842>>>>>>>>>>>>>        
19842>>>>>>>>>>>>>        Function_Return sResult
19843>>>>>>>>>>>>>    End_Function
19844>>>>>>>>>>>>>    
19844>>>>>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
19846>>>>>>>>>>>>>        String  sResult
19846>>>>>>>>>>>>>        String  sEmpty
19846>>>>>>>>>>>>>        Integer bIsStringAttribute
19846>>>>>>>>>>>>>        Integer iLen
19846>>>>>>>>>>>>>        Integer iVoid
19846>>>>>>>>>>>>>        Integer bLegalAttrib
19846>>>>>>>>>>>>>        Integer bLegalColumn
19846>>>>>>>>>>>>>        
19846>>>>>>>>>>>>>        // Initialize
19846>>>>>>>>>>>>>        Move "" to sResult
19847>>>>>>>>>>>>>        Move "" to sEmpty
19848>>>>>>>>>>>>>        Move 0  to iLen
19849>>>>>>>>>>>>>        
19849>>>>>>>>>>>>>        // Get the attribute
19849>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19851>>>>>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
19852>>>>>>>>>>>>>            If (bLegalColumn) Begin
19854>>>>>>>>>>>>>                // Determine the atributes type
19854>>>>>>>>>>>>>                Case Begin
19854>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
19856>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
19859>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
19862>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
19865>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
19868>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
19871>>>>>>>>>>>>>                        Move DFFALSE to bIsStringAttribute
19872>>>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
19873>>>>>>>>>>>>>                        Break
19874>>>>>>>>>>>>>                        
19874>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
19877>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
19880>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
19883>>>>>>>>>>>>>                        Move DFTRUE to bIsStringAttribute
19884>>>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
19885>>>>>>>>>>>>>                        Break
19886>>>>>>>>>>>>>                        
19886>>>>>>>>>>>>>                    Case Else
19886>>>>>>>>>>>>>                        Move DFFALSE to bLegalAttrib
19887>>>>>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
19888>>>>>>>>>>>>>                Case End
19888>>>>>>>>>>>>>                
19888>>>>>>>>>>>>>                If (bLegalAttrib) Begin
19890>>>>>>>>>>>>>                    // Setup function arguments
19890>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
19895>>>>>>>>>>>>>                    
19895>>>>>>>>>>>>>                    If (bIsStringAttribute) Begin
19897>>>>>>>>>>>>>                        // Call the driver function to get the data length
19897>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
19902>>>>>>>>>>>>>                        
19902>>>>>>>>>>>>>                        If (iLen) Begin
19904>>>>>>>>>>>>>                            // Allocate
19904>>>>>>>>>>>>>                            Move (Repeat(' ', iLen)) to sResult
19905>>>>>>>>>>>>>                            
19905>>>>>>>>>>>>>                            // Call the driver function to get the name
19905>>>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
19910>>>>>>>>>>>>>                        End
19910>>>>>>>>>>>>>>
19910>>>>>>>>>>>>>                    End
19910>>>>>>>>>>>>>>
19910>>>>>>>>>>>>>                    Else Begin
19911>>>>>>>>>>>>>                        // get the attribute
19911>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
19916>>>>>>>>>>>>>                    End
19916>>>>>>>>>>>>>>
19916>>>>>>>>>>>>>                End
19916>>>>>>>>>>>>>>
19916>>>>>>>>>>>>>            End
19916>>>>>>>>>>>>>>
19916>>>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
19918>>>>>>>>>>>>>        End
19918>>>>>>>>>>>>>>
19918>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
19920>>>>>>>>>>>>>        
19920>>>>>>>>>>>>>        Function_Return sResult
19921>>>>>>>>>>>>>    End_Function
19922>>>>>>>>>>>>>    
19922>>>>>>>>>>>>>    
19922>>>>>>>>>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
19922>>>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
19924>>>>>>>>>>>>>        Integer ihdbc
19924>>>>>>>>>>>>>        Integer ihstmt
19924>>>>>>>>>>>>>        String  sDrvrId
19924>>>>>>>>>>>>>        Integer iVoid
19924>>>>>>>>>>>>>        String  sSchema
19924>>>>>>>>>>>>>        String  sEmpty
19924>>>>>>>>>>>>>        
19924>>>>>>>>>>>>>        // Initialize
19924>>>>>>>>>>>>>        Move "" to sEmpty
19925>>>>>>>>>>>>>        
19925>>>>>>>>>>>>>        // Get the cli handles
19925>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19926>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19927>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19928>>>>>>>>>>>>>        
19928>>>>>>>>>>>>>        // Call the procedure
19928>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19930>>>>>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
19933>>>>>>>>>>>>>            Else ;                Move "" to sSchema
19935>>>>>>>>>>>>>            
19935>>>>>>>>>>>>>            If (sSchema <> "") Begin
19937>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
19942>>>>>>>>>>>>>            End
19942>>>>>>>>>>>>>>
19942>>>>>>>>>>>>>            
19942>>>>>>>>>>>>>            // Call the procedure
19942>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
19947>>>>>>>>>>>>>            
19947>>>>>>>>>>>>>            Set piLastArgument to 0
19948>>>>>>>>>>>>>        End
19948>>>>>>>>>>>>>>
19948>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
19950>>>>>>>>>>>>>    End_Procedure
19951>>>>>>>>>>>>>    
19951>>>>>>>>>>>>>    // Pass the next argument
19951>>>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
19953>>>>>>>>>>>>>        Integer iArgnum
19953>>>>>>>>>>>>>        
19953>>>>>>>>>>>>>        Get piLastArgument to iArgnum
19954>>>>>>>>>>>>>        Increment iArgnum
19955>>>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
19956>>>>>>>>>>>>>        Set piLastArgument to iArgnum
19957>>>>>>>>>>>>>    End_Procedure
19958>>>>>>>>>>>>>    
19958>>>>>>>>>>>>>    
19958>>>>>>>>>>>>>    
19958>>>>>>>>>>>>>    // Set the next argument
19958>>>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
19960>>>>>>>>>>>>>        Integer ihdbc
19960>>>>>>>>>>>>>        Integer ihstmt
19960>>>>>>>>>>>>>        String  sDrvrId
19960>>>>>>>>>>>>>        Integer iVoid
19960>>>>>>>>>>>>>        String  sEmpty
19960>>>>>>>>>>>>>        
19960>>>>>>>>>>>>>        // Initialize
19960>>>>>>>>>>>>>        Move "" to sEmpty
19961>>>>>>>>>>>>>        
19961>>>>>>>>>>>>>        // Get the cli handles
19961>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19962>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19963>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19964>>>>>>>>>>>>>        
19964>>>>>>>>>>>>>        // Call the procedure
19964>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19966>>>>>>>>>>>>>            // Pass the information
19966>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
19971>>>>>>>>>>>>>            
19971>>>>>>>>>>>>>            // Pass the argument
19971>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
19976>>>>>>>>>>>>>        End
19976>>>>>>>>>>>>>>
19976>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
19978>>>>>>>>>>>>>    End_Procedure
19979>>>>>>>>>>>>>    
19979>>>>>>>>>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
19981>>>>>>>>>>>>>        Integer iParamNum 
19981>>>>>>>>>>>>>        Integer iType
19981>>>>>>>>>>>>>        
19981>>>>>>>>>>>>>        If (num_arguments < 2) Begin
19983>>>>>>>>>>>>>            Move typeString to iType
19984>>>>>>>>>>>>>        End
19984>>>>>>>>>>>>>>
19984>>>>>>>>>>>>>        Else Begin
19985>>>>>>>>>>>>>            Move iParamType to iType
19986>>>>>>>>>>>>>        End
19986>>>>>>>>>>>>>>
19986>>>>>>>>>>>>>        
19986>>>>>>>>>>>>>        Get piLastArgument to iParamNum
19987>>>>>>>>>>>>>        Increment iParamNum
19988>>>>>>>>>>>>>        Send SQLSetParameter iParamNum sParamValue iType
19989>>>>>>>>>>>>>        Set piLastArgument to iParamNum
19990>>>>>>>>>>>>>    End_Procedure
19991>>>>>>>>>>>>>
19991>>>>>>>>>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
19993>>>>>>>>>>>>>        
19993>>>>>>>>>>>>>        Integer ihdbc
19993>>>>>>>>>>>>>        Integer ihstmt
19993>>>>>>>>>>>>>        String  sDrvrId
19993>>>>>>>>>>>>>        Integer iVoid
19993>>>>>>>>>>>>>        String  sEmpty
19993>>>>>>>>>>>>>        Integer iType
19993>>>>>>>>>>>>>        
19993>>>>>>>>>>>>>        If (num_arguments < 3) Begin
19995>>>>>>>>>>>>>            Move typeString to iType
19996>>>>>>>>>>>>>        End
19996>>>>>>>>>>>>>>
19996>>>>>>>>>>>>>        Else Begin
19997>>>>>>>>>>>>>            Move iParamType to iType
19998>>>>>>>>>>>>>        End
19998>>>>>>>>>>>>>>
19998>>>>>>>>>>>>>        
19998>>>>>>>>>>>>>        Case Begin
19998>>>>>>>>>>>>>            Case (iType = typeDate )    
20000>>>>>>>>>>>>>
20000>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20002>>>>>>>>>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
20003>>>>>>>>>>>>>                End
20003>>>>>>>>>>>>>>
20003>>>>>>>>>>>>>                
20003>>>>>>>>>>>>>                Break
20004>>>>>>>>>>>>>
20004>>>>>>>>>>>>>            Case (iType = typeDatetime )    
20007>>>>>>>>>>>>>
20007>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20009>>>>>>>>>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
20010>>>>>>>>>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
20011>>>>>>>>>>>>>                End
20011>>>>>>>>>>>>>>
20011>>>>>>>>>>>>>
20011>>>>>>>>>>>>>                Break
20012>>>>>>>>>>>>>
20012>>>>>>>>>>>>>            Case (iType = typeNumber )    
20015>>>>>>>>>>>>>
20015>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20017>>>>>>>>>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
20018>>>>>>>>>>>>>                End
20018>>>>>>>>>>>>>>
20018>>>>>>>>>>>>>                
20018>>>>>>>>>>>>>                Break
20019>>>>>>>>>>>>>            
20019>>>>>>>>>>>>>            Case (iType = typeTime )    
20022>>>>>>>>>>>>>
20022>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20024>>>>>>>>>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
20025>>>>>>>>>>>>>                End
20025>>>>>>>>>>>>>>
20025>>>>>>>>>>>>>                
20025>>>>>>>>>>>>>                Break
20026>>>>>>>>>>>>>                
20026>>>>>>>>>>>>>            Case Else
20026>>>>>>>>>>>>>                    // sParamValue is a string type or a type that must be passed as a string
20026>>>>>>>>>>>>>                    Break
20027>>>>>>>>>>>>>                
20027>>>>>>>>>>>>>        Case End
20027>>>>>>>>>>>>>        
20027>>>>>>>>>>>>>        
20027>>>>>>>>>>>>>        // Initialize
20027>>>>>>>>>>>>>        Move "" to sEmpty
20028>>>>>>>>>>>>>        
20028>>>>>>>>>>>>>        // Get the cli handles
20028>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20029>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20030>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20031>>>>>>>>>>>>>        
20031>>>>>>>>>>>>>        // Call the procedure
20031>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20033>>>>>>>>>>>>>            // Pass the information
20033>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
20038>>>>>>>>>>>>>            
20038>>>>>>>>>>>>>            // Pass the argument
20038>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
20043>>>>>>>>>>>>>        End
20043>>>>>>>>>>>>>>
20043>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
20045>>>>>>>>>>>>>    End_Procedure
20046>>>>>>>>>>>>>    
20046>>>>>>>>>>>>>    
20046>>>>>>>>>>>>>    // Call a stored procedure
20046>>>>>>>>>>>>>    Procedure SQLCall
20048>>>>>>>>>>>>>        Integer ihdbc
20048>>>>>>>>>>>>>        Integer ihstmt
20048>>>>>>>>>>>>>        String  sDrvrId
20048>>>>>>>>>>>>>        Integer iVoid
20048>>>>>>>>>>>>>        String  sEmpty
20048>>>>>>>>>>>>>        
20048>>>>>>>>>>>>>        // Initialize
20048>>>>>>>>>>>>>        Move "" to sEmpty
20049>>>>>>>>>>>>>        
20049>>>>>>>>>>>>>        // Get the cli handles
20049>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20050>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20051>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20052>>>>>>>>>>>>>        
20052>>>>>>>>>>>>>        // Call the procedure
20052>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20054>>>>>>>>>>>>>            // Call the procedure
20054>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
20059>>>>>>>>>>>>>            
20059>>>>>>>>>>>>>            Send SQLGetStatementAttributes
20060>>>>>>>>>>>>>            Set piLastArgument to 0
20061>>>>>>>>>>>>>        End
20061>>>>>>>>>>>>>>
20061>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
20063>>>>>>>>>>>>>    End_Procedure
20064>>>>>>>>>>>>>    
20064>>>>>>>>>>>>>    
20064>>>>>>>>>>>>>    // Get the next argument
20064>>>>>>>>>>>>>    Function SQLGetNextArgument Returns String
20066>>>>>>>>>>>>>        Integer iArgnum
20066>>>>>>>>>>>>>        String  sResult
20066>>>>>>>>>>>>>        
20066>>>>>>>>>>>>>        Get piLastArgument to iArgnum
20067>>>>>>>>>>>>>        Increment iArgnum
20068>>>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
20069>>>>>>>>>>>>>        Set piLastArgument to iArgnum
20070>>>>>>>>>>>>>        
20070>>>>>>>>>>>>>        Function_Return sResult
20071>>>>>>>>>>>>>    End_Function
20072>>>>>>>>>>>>>    
20072>>>>>>>>>>>>>    
20072>>>>>>>>>>>>>    
20072>>>>>>>>>>>>>    // Get the specified argument from a procedure
20072>>>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
20074>>>>>>>>>>>>>        Integer ihdbc
20074>>>>>>>>>>>>>        Integer ihstmt
20074>>>>>>>>>>>>>        String  sDrvrId
20074>>>>>>>>>>>>>        Integer iVoid
20074>>>>>>>>>>>>>        String  sEmpty
20074>>>>>>>>>>>>>        String  sArgument
20074>>>>>>>>>>>>>        Integer iLen
20074>>>>>>>>>>>>>        
20074>>>>>>>>>>>>>        // Initialize
20074>>>>>>>>>>>>>        Move "" to sEmpty
20075>>>>>>>>>>>>>        Move "" to sArgument
20076>>>>>>>>>>>>>        
20076>>>>>>>>>>>>>        // Get the cli handles
20076>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20077>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20078>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20079>>>>>>>>>>>>>        
20079>>>>>>>>>>>>>        // Call the procedure
20079>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20081>>>>>>>>>>>>>            // Pass the information
20081>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
20086>>>>>>>>>>>>>            
20086>>>>>>>>>>>>>            // Get the length
20086>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
20091>>>>>>>>>>>>>            
20091>>>>>>>>>>>>>            If (iLen) Begin
20093>>>>>>>>>>>>>                // Allocate
20093>>>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sArgument
20094>>>>>>>>>>>>>                
20094>>>>>>>>>>>>>                // Pass the argument
20094>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
20099>>>>>>>>>>>>>            End
20099>>>>>>>>>>>>>>
20099>>>>>>>>>>>>>        End
20099>>>>>>>>>>>>>>
20099>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
20101>>>>>>>>>>>>>        
20101>>>>>>>>>>>>>        Function_Return sArgument
20102>>>>>>>>>>>>>    End_Function
20103>>>>>>>>>>>>>    
20103>>>>>>>>>>>>>    
20103>>>>>>>>>>>>>    // Get the return value of a stored function
20103>>>>>>>>>>>>>    Function SQLReturnValue Returns String
20105>>>>>>>>>>>>>        Integer ihdbc
20105>>>>>>>>>>>>>        Integer ihstmt
20105>>>>>>>>>>>>>        String  sDrvrId
20105>>>>>>>>>>>>>        Integer iVoid
20105>>>>>>>>>>>>>        String  sEmpty
20105>>>>>>>>>>>>>        String  sRetval
20105>>>>>>>>>>>>>        Integer iLen
20105>>>>>>>>>>>>>        
20105>>>>>>>>>>>>>        // Initialize
20105>>>>>>>>>>>>>        Move "" to sEmpty
20106>>>>>>>>>>>>>        Move "" to sRetval
20107>>>>>>>>>>>>>        
20107>>>>>>>>>>>>>        // Get the cli handles
20107>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20108>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20109>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20110>>>>>>>>>>>>>        
20110>>>>>>>>>>>>>        // Call the procedure
20110>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20112>>>>>>>>>>>>>            // Get the length
20112>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
20117>>>>>>>>>>>>>            
20117>>>>>>>>>>>>>            If (iLen) Begin
20119>>>>>>>>>>>>>                // Allocate
20119>>>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sRetval
20120>>>>>>>>>>>>>                
20120>>>>>>>>>>>>>                // Pass the argument
20120>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
20125>>>>>>>>>>>>>            End
20125>>>>>>>>>>>>>>
20125>>>>>>>>>>>>>        End
20125>>>>>>>>>>>>>>
20125>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
20127>>>>>>>>>>>>>        
20127>>>>>>>>>>>>>        Function_Return sRetval
20128>>>>>>>>>>>>>    End_Function
20129>>>>>>>>>>>>>    
20129>>>>>>>>>>>>>    
20129>>>>>>>>>>>>>    // Switch to the next set
20129>>>>>>>>>>>>>    // Returns : 0   = No more result sets
20129>>>>>>>>>>>>>    //     <>0 = Switched to next set
20129>>>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
20131>>>>>>>>>>>>>        Integer ihdbc
20131>>>>>>>>>>>>>        Integer ihstmt
20131>>>>>>>>>>>>>        String  sDrvrId
20131>>>>>>>>>>>>>        Integer iResult
20131>>>>>>>>>>>>>        String  sEmpty
20131>>>>>>>>>>>>>        
20131>>>>>>>>>>>>>        // Initialize
20131>>>>>>>>>>>>>        Move "" to sEmpty
20132>>>>>>>>>>>>>        Move 0  to iResult
20133>>>>>>>>>>>>>        
20133>>>>>>>>>>>>>        // Get the cli handles
20133>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20134>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20135>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20136>>>>>>>>>>>>>        
20136>>>>>>>>>>>>>        // Call the procedure
20136>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20138>>>>>>>>>>>>>            // Get the length
20138>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
20143>>>>>>>>>>>>>            
20143>>>>>>>>>>>>>            Send SQLGetStatementAttributes
20144>>>>>>>>>>>>>            Set piLastArgument to 0
20145>>>>>>>>>>>>>        End
20145>>>>>>>>>>>>>>
20145>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
20147>>>>>>>>>>>>>        
20147>>>>>>>>>>>>>        Function_Return iResult
20148>>>>>>>>>>>>>    End_Function
20149>>>>>>>>>>>>>    
20149>>>>>>>>>>>>>    
20149>>>>>>>>>>>>>    // Setup a file that will be acivated after a succesfull
20149>>>>>>>>>>>>>    //fetch on the statement
20149>>>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
20151>>>>>>>>>>>>>        Integer ihdbc
20151>>>>>>>>>>>>>        Integer ihstmt
20151>>>>>>>>>>>>>        String  sDrvrId
20151>>>>>>>>>>>>>        Integer iResult
20151>>>>>>>>>>>>>        Integer bIsOpen
20151>>>>>>>>>>>>>        Integer iVoid
20151>>>>>>>>>>>>>        String  sFileType
20151>>>>>>>>>>>>>        
20151>>>>>>>>>>>>>        // Check if file is open
20151>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
20154>>>>>>>>>>>>>        If (bIsOpen) Begin
20156>>>>>>>>>>>>>            // Get the cli handles
20156>>>>>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
20157>>>>>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
20158>>>>>>>>>>>>>            Get psDriverId            to sDrvrId
20159>>>>>>>>>>>>>            
20159>>>>>>>>>>>>>            // Call the procedure
20159>>>>>>>>>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20161>>>>>>>>>>>>>                // Check if the file has the correct type
20161>>>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
20164>>>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
20166>>>>>>>>>>>>>                    // Setup the buffer
20166>>>>>>>>>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
20171>>>>>>>>>>>>>                End
20171>>>>>>>>>>>>>>
20171>>>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
20173>>>>>>>>>>>>>            End
20173>>>>>>>>>>>>>>
20173>>>>>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
20175>>>>>>>>>>>>>        End
20175>>>>>>>>>>>>>>
20175>>>>>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
20177>>>>>>>>>>>>>    End_Procedure
20178>>>>>>>>>>>>>    
20178>>>>>>>>>>>>>    
20178>>>>>>>>>>>>>    
20178>>>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
20180>>>>>>>>>>>>>        Integer ihdbc
20180>>>>>>>>>>>>>        Integer ihstmt
20180>>>>>>>>>>>>>        String  sDrvrId
20180>>>>>>>>>>>>>        String  sMessage
20180>>>>>>>>>>>>>        Integer iVoid
20180>>>>>>>>>>>>>        
20180>>>>>>>>>>>>>        // Initialize
20180>>>>>>>>>>>>>        Move "" to sMessage
20181>>>>>>>>>>>>>        
20181>>>>>>>>>>>>>        // Get the cli handles
20181>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20182>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20183>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20184>>>>>>>>>>>>>        
20184>>>>>>>>>>>>>        // Call the procedure
20184>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20186>>>>>>>>>>>>>            // Setup function arguments
20186>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
20191>>>>>>>>>>>>>            
20191>>>>>>>>>>>>>            Move (Repeat(' ', 1024)) to sMessage
20192>>>>>>>>>>>>>            // Get the length
20192>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
20197>>>>>>>>>>>>>        End
20197>>>>>>>>>>>>>>
20197>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
20199>>>>>>>>>>>>>        
20199>>>>>>>>>>>>>        Function_Return sMessage
20200>>>>>>>>>>>>>    End_Function
20201>>>>>>>>>>>>>    
20201>>>>>>>>>>>>>    
20201>>>>>>>>>>>>>    
20201>>>>>>>>>>>>>    // Remove the component identifier from a diagnostic message
20201>>>>>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
20203>>>>>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
20207>>>>>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
20208>>>>>>>>>>>>>        Loop
20209>>>>>>>>>>>>>>
20209>>>>>>>>>>>>>        
20209>>>>>>>>>>>>>        Function_Return sDiagMessage
20210>>>>>>>>>>>>>    End_Function
20211>>>>>>>>>>>>>    
20211>>>>>>>>>>>>>    
20211>>>>>>>>>>>>>    
20211>>>>>>>>>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
20211>>>>>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
20213>>>>>>>>>>>>>        
20213>>>>>>>>>>>>>        Integer iType
20213>>>>>>>>>>>>>        String  sSQLDate
20213>>>>>>>>>>>>>        Integer iOrgDateFmt
20213>>>>>>>>>>>>>        Integer iOrgDateSep
20213>>>>>>>>>>>>>        
20213>>>>>>>>>>>>>        String sDriverId
20213>>>>>>>>>>>>>        String sDummyZeroDate
20213>>>>>>>>>>>>>        String sDummyZeroDateMssqlDatetime
20213>>>>>>>>>>>>>        
20213>>>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
20213>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
20216>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20219>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
20222>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
20225>>>>>>>>>>>>>        
20225>>>>>>>>>>>>>        // We only need to convert if the date is 0
20225>>>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
20227>>>>>>>>>>>>>            
20227>>>>>>>>>>>>>            If (num_arguments < 2) Begin
20229>>>>>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
20230>>>>>>>>>>>>>            End
20230>>>>>>>>>>>>>>
20230>>>>>>>>>>>>>            Else Begin
20231>>>>>>>>>>>>>                Move iSQLType to iType
20232>>>>>>>>>>>>>            End
20232>>>>>>>>>>>>>>
20232>>>>>>>>>>>>>            
20232>>>>>>>>>>>>>            
20232>>>>>>>>>>>>>            Get psDriverID to sDriverId
20233>>>>>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
20234>>>>>>>>>>>>>            
20234>>>>>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
20236>>>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20237>>>>>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
20238>>>>>>>>>>>>>            End
20238>>>>>>>>>>>>>>
20238>>>>>>>>>>>>>            Else Begin
20239>>>>>>>>>>>>>                Move sDummyZeroDate to sSQLDate
20240>>>>>>>>>>>>>            End
20240>>>>>>>>>>>>>>
20240>>>>>>>>>>>>>            
20240>>>>>>>>>>>>>        End
20240>>>>>>>>>>>>>>
20240>>>>>>>>>>>>>        Else Begin
20241>>>>>>>>>>>>>            Move dDFDate to sSQLDate
20242>>>>>>>>>>>>>        End
20242>>>>>>>>>>>>>>
20242>>>>>>>>>>>>>        
20242>>>>>>>>>>>>>        // Change date format back to original
20242>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
20245>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20248>>>>>>>>>>>>>        
20248>>>>>>>>>>>>>        Function_Return sSQLDate
20249>>>>>>>>>>>>>    End_Function
20250>>>>>>>>>>>>>    
20250>>>>>>>>>>>>>    
20250>>>>>>>>>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
20250>>>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
20252>>>>>>>>>>>>>        
20252>>>>>>>>>>>>>        Integer iType
20252>>>>>>>>>>>>>        Date    dDFDate
20252>>>>>>>>>>>>>        Integer iOrgDateFmt
20252>>>>>>>>>>>>>        Integer iOrgDateSep
20252>>>>>>>>>>>>>        
20252>>>>>>>>>>>>>        String  sDriverId
20252>>>>>>>>>>>>>        String  sDummyZeroDate
20252>>>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
20252>>>>>>>>>>>>>        
20252>>>>>>>>>>>>>        Get psDriverID to sDriverId
20253>>>>>>>>>>>>>        
20253>>>>>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
20254>>>>>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20255>>>>>>>>>>>>>        
20255>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
20258>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20261>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
20264>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
20267>>>>>>>>>>>>>        
20267>>>>>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
20268>>>>>>>>>>>>>        
20268>>>>>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
20270>>>>>>>>>>>>>            Move 0 to dDFDate
20271>>>>>>>>>>>>>        End
20271>>>>>>>>>>>>>>
20271>>>>>>>>>>>>>        Else Begin
20272>>>>>>>>>>>>>            Move sSQLDate to dDFDate
20273>>>>>>>>>>>>>        End
20273>>>>>>>>>>>>>>
20273>>>>>>>>>>>>>        
20273>>>>>>>>>>>>>        // Change date format back to original
20273>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
20276>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20279>>>>>>>>>>>>>        
20279>>>>>>>>>>>>>        Function_Return dDFDate
20280>>>>>>>>>>>>>    End_Function
20281>>>>>>>>>>>>>    
20281>>>>>>>>>>>>>End_Class
20282>>>>>>>>>>>>>
20282>>>>>>>>>>>>>
20282>>>>>>>>>>>>>// Connection object for embedded SQL                          
20282>>>>>>>>>>>>>// This provides the ability to create a connection for a driver.     
20282>>>>>>>>>>>>>// It will contain child statement objects                            
20282>>>>>>>>>>>>>
20282>>>>>>>>>>>>>Class cSQLConnection is a cObject
20283>>>>>>>>>>>>>    
20283>>>>>>>>>>>>>    Procedure Construct_object
20285>>>>>>>>>>>>>        Forward Send Construct_object
20287>>>>>>>>>>>>>        
20287>>>>>>>>>>>>>        Property Integer phCLIConnectionHandle       0
20288>>>>>>>>>>>>>        
20288>>>>>>>>>>>>>        Property String  psDriverID        ""
20289>>>>>>>>>>>>>        Property Integer piBindFile        0
20290>>>>>>>>>>>>>        
20290>>>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
20291>>>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
20292>>>>>>>>>>>>>        
20292>>>>>>>>>>>>>    End_Procedure
20293>>>>>>>>>>>>>    
20293>>>>>>>>>>>>>    
20293>>>>>>>>>>>>>    
20293>>>>>>>>>>>>>    // Store basic information about the connection
20293>>>>>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
20295>>>>>>>>>>>>>        
20295>>>>>>>>>>>>>        String sDummyZeroDate
20295>>>>>>>>>>>>>        Integer iDriverIndex
20295>>>>>>>>>>>>>        
20295>>>>>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
20296>>>>>>>>>>>>>        Set psDriverID            to sDrvrId
20297>>>>>>>>>>>>>        
20297>>>>>>>>>>>>>        Case Begin
20297>>>>>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
20299>>>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
20300>>>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
20301>>>>>>>>>>>>>                Break
20302>>>>>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
20305>>>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
20306>>>>>>>>>>>>>                Break
20307>>>>>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
20310>>>>>>>>>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
20311>>>>>>>>>>>>>                If (iDriverIndex <> 0) Begin
20313>>>>>>>>>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
20316>>>>>>>>>>>>>                End
20316>>>>>>>>>>>>>>
20316>>>>>>>>>>>>>                Else Begin
20317>>>>>>>>>>>>>                    Move '0001-01-01' to sDummyZeroDate
20318>>>>>>>>>>>>>                End
20318>>>>>>>>>>>>>>
20318>>>>>>>>>>>>>
20318>>>>>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
20319>>>>>>>>>>>>>                Break
20320>>>>>>>>>>>>>                
20320>>>>>>>>>>>>>        Case End
20320>>>>>>>>>>>>>        
20320>>>>>>>>>>>>>    End_Procedure
20321>>>>>>>>>>>>>    
20321>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
20323>>>>>>>>>>>>>        
20323>>>>>>>>>>>>>        String  sCurrentDriver
20323>>>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
20323>>>>>>>>>>>>>        
20323>>>>>>>>>>>>>        Move 0 to iDriver
20324>>>>>>>>>>>>>        
20324>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
20327>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
20333>>>>>>>>>>>>>>
20333>>>>>>>>>>>>>            
20333>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
20336>>>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
20338>>>>>>>>>>>>>                Move iCount to iDriver
20339>>>>>>>>>>>>>            End
20339>>>>>>>>>>>>>>
20339>>>>>>>>>>>>>        Loop
20340>>>>>>>>>>>>>>
20340>>>>>>>>>>>>>        
20340>>>>>>>>>>>>>        Function_Return iDriver
20341>>>>>>>>>>>>>        
20341>>>>>>>>>>>>>    End_Function
20342>>>>>>>>>>>>>
20342>>>>>>>>>>>>>    
20342>>>>>>>>>>>>>    // Destroy the SQLConnection object
20342>>>>>>>>>>>>>    Procedure DestroySQLConnection
20344>>>>>>>>>>>>>        Send Destroy
20345>>>>>>>>>>>>>    End_Procedure
20346>>>>>>>>>>>>>    
20346>>>>>>>>>>>>>    
20346>>>>>>>>>>>>>    // Connect to a database server
20346>>>>>>>>>>>>>    // Returns : 1 Succesfully connected
20346>>>>>>>>>>>>>    //           0 Not connected
20346>>>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
20348>>>>>>>>>>>>>        Integer ihdbc
20348>>>>>>>>>>>>>        String  sEmpty
20348>>>>>>>>>>>>>        
20348>>>>>>>>>>>>>        // Initialize
20348>>>>>>>>>>>>>        Move "" to sEmpty
20349>>>>>>>>>>>>>        Move 0  to ihdbc
20350>>>>>>>>>>>>>        
20350>>>>>>>>>>>>>        Move False to Err
20351>>>>>>>>>>>>>        
20351>>>>>>>>>>>>>        // Call the driver function to connect
20351>>>>>>>>>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
20356>>>>>>>>>>>>>        
20356>>>>>>>>>>>>>        // If there was an error, make result invalid
20356>>>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
20359>>>>>>>>>>>>>        
20359>>>>>>>>>>>>>        // Check result and store it
20359>>>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
20362>>>>>>>>>>>>>        
20362>>>>>>>>>>>>>        // Return success status
20362>>>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20363>>>>>>>>>>>>>    End_Function
20364>>>>>>>>>>>>>    
20364>>>>>>>>>>>>>    
20364>>>>>>>>>>>>>    // Use a connection of an already open file
20364>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
20366>>>>>>>>>>>>>        Integer ihdbc
20366>>>>>>>>>>>>>        Integer bIsOpen
20366>>>>>>>>>>>>>        String  sDrvrId
20366>>>>>>>>>>>>>        String  sEmpty
20366>>>>>>>>>>>>>        
20366>>>>>>>>>>>>>        // Initialize
20366>>>>>>>>>>>>>        Move "" to sEmpty
20367>>>>>>>>>>>>>        Move 0  to ihdbc
20368>>>>>>>>>>>>>        
20368>>>>>>>>>>>>>        // Check if file is open
20368>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
20371>>>>>>>>>>>>>        If (bIsOpen) Begin
20373>>>>>>>>>>>>>            // Fill the driver id, assume longest is 255 characters
20373>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDrvrId
20374>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
20377>>>>>>>>>>>>>            
20377>>>>>>>>>>>>>            Move False to Err
20378>>>>>>>>>>>>>            
20378>>>>>>>>>>>>>            // Call the driver function to connect
20378>>>>>>>>>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
20383>>>>>>>>>>>>>            
20383>>>>>>>>>>>>>            // If there was an error, make result invalid
20383>>>>>>>>>>>>>            If (Err) ;                Move 0 to ihdbc
20386>>>>>>>>>>>>>            
20386>>>>>>>>>>>>>            // Check result and store it
20386>>>>>>>>>>>>>            If (ihdbc <> 0) Begin
20388>>>>>>>>>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
20388>>>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
20391>>>>>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
20392>>>>>>>>>>>>>                
20392>>>>>>>>>>>>>                // Set filenum so it can be used for fetching
20392>>>>>>>>>>>>>                Set piBindFile to iFileNum
20393>>>>>>>>>>>>>            End
20393>>>>>>>>>>>>>>
20393>>>>>>>>>>>>>        End
20393>>>>>>>>>>>>>>
20393>>>>>>>>>>>>>        
20393>>>>>>>>>>>>>        // Return success status
20393>>>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20394>>>>>>>>>>>>>    End_Function
20395>>>>>>>>>>>>>    
20395>>>>>>>>>>>>>    
20395>>>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
20395>>>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
20395>>>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
20395>>>>>>>>>>>>>    // The connectstring must be an exact match, but can be case insensitive
20395>>>>>>>>>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
20395>>>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
20395>>>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
20395>>>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
20397>>>>>>>>>>>>>        Integer ihdbc
20397>>>>>>>>>>>>>        String  sEmpty
20397>>>>>>>>>>>>>        Integer iFileNum
20397>>>>>>>>>>>>>        
20397>>>>>>>>>>>>>        // Initialize
20397>>>>>>>>>>>>>        Move "" to sEmpty
20398>>>>>>>>>>>>>        Move 0  to ihdbc
20399>>>>>>>>>>>>>        
20399>>>>>>>>>>>>>        Move False to Err
20400>>>>>>>>>>>>>        
20400>>>>>>>>>>>>>        // Call the driver function
20400>>>>>>>>>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
20400>>>>>>>>>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
20400>>>>>>>>>>>>>        Move 0 to iFileNum
20401>>>>>>>>>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
20406>>>>>>>>>>>>>        
20406>>>>>>>>>>>>>        // If there was an error, make result invalid
20406>>>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
20409>>>>>>>>>>>>>        
20409>>>>>>>>>>>>>        // Check result and store it
20409>>>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
20412>>>>>>>>>>>>>        
20412>>>>>>>>>>>>>        // Return success status
20412>>>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20413>>>>>>>>>>>>>    End_Function
20414>>>>>>>>>>>>>    
20414>>>>>>>>>>>>>    
20414>>>>>>>>>>>>>    // Disconnect from an embedded SQL server and free allocated
20414>>>>>>>>>>>>>    // resources
20414>>>>>>>>>>>>>    Procedure SQLDisconnect
20416>>>>>>>>>>>>>        Integer ihdbc
20416>>>>>>>>>>>>>        Integer iVoid
20416>>>>>>>>>>>>>        String  sDrvrId
20416>>>>>>>>>>>>>        String  sEmpty
20416>>>>>>>>>>>>>        
20416>>>>>>>>>>>>>        // Initialize
20416>>>>>>>>>>>>>        Move "" to sEmpty
20417>>>>>>>>>>>>>        
20417>>>>>>>>>>>>>        // Get the cli handle
20417>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20418>>>>>>>>>>>>>        Get psDriverId to sDrvrId
20419>>>>>>>>>>>>>        
20419>>>>>>>>>>>>>        // Free the CLI handle
20419>>>>>>>>>>>>>        If (ihdbc <> 0) Begin
20421>>>>>>>>>>>>>            // Call the driver function to disconnect
20421>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
20426>>>>>>>>>>>>>            
20426>>>>>>>>>>>>>            Move -1 to giLastSQLhdbc
20427>>>>>>>>>>>>>            
20427>>>>>>>>>>>>>            // Free the DataFlex handle
20427>>>>>>>>>>>>>            Send DestroySQLConnection
20428>>>>>>>>>>>>>        End
20428>>>>>>>>>>>>>>
20428>>>>>>>>>>>>>    End_Procedure
20429>>>>>>>>>>>>>    
20429>>>>>>>>>>>>>    // Create a cSQLStatement object
20429>>>>>>>>>>>>>    Function CreateSQLStatement Returns Handle
20431>>>>>>>>>>>>>        
20431>>>>>>>>>>>>>        Handle hoSQLStatement
20431>>>>>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
20432>>>>>>>>>>>>>        
20432>>>>>>>>>>>>>        // If the connection has a default Bind File, assign it to the
20432>>>>>>>>>>>>>        // statement object. The default is set when you open a file with a
20432>>>>>>>>>>>>>        // SetFileConnection command.
20432>>>>>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
20433>>>>>>>>>>>>>        
20433>>>>>>>>>>>>>        Function_Return hoSQLStatement
20434>>>>>>>>>>>>>    End_Function
20435>>>>>>>>>>>>>    
20435>>>>>>>>>>>>>    
20435>>>>>>>>>>>>>    // Open a statement for use
20435>>>>>>>>>>>>>    Function SQLOpen Returns Handle
20437>>>>>>>>>>>>>        Handle  hoSQLStatement
20437>>>>>>>>>>>>>        Integer ihdbc
20437>>>>>>>>>>>>>        Integer ihstmt
20437>>>>>>>>>>>>>        Integer iVoid
20437>>>>>>>>>>>>>        String  sDrvrId
20437>>>>>>>>>>>>>        String  sEmpty
20437>>>>>>>>>>>>>        String  sDummyZeroDate
20437>>>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
20437>>>>>>>>>>>>>        
20437>>>>>>>>>>>>>        // Initialize
20437>>>>>>>>>>>>>        Move "" to sEmpty
20438>>>>>>>>>>>>>        
20438>>>>>>>>>>>>>        // Get the cli handle to the connection
20438>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20439>>>>>>>>>>>>>        Get psDriverId  to sDrvrId
20440>>>>>>>>>>>>>        
20440>>>>>>>>>>>>>        // Allocate a new handle and populate it
20440>>>>>>>>>>>>>        If (ihdbc <> 0) Begin
20442>>>>>>>>>>>>>            // Create a new cSQLStatement object
20442>>>>>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
20443>>>>>>>>>>>>>            
20443>>>>>>>>>>>>>            // Call the driver function to allocate a cli statement handle
20443>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
20448>>>>>>>>>>>>>            
20448>>>>>>>>>>>>>            // If unsuccessful destroy hoSQLStatement
20448>>>>>>>>>>>>>            If (ihstmt = 0) Begin
20450>>>>>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
20451>>>>>>>>>>>>>                Move 0 to hoSQLStatement
20452>>>>>>>>>>>>>            End
20452>>>>>>>>>>>>>>
20452>>>>>>>>>>>>>            Else Begin
20453>>>>>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
20454>>>>>>>>>>>>>                
20454>>>>>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
20454>>>>>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
20455>>>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20456>>>>>>>>>>>>>                
20456>>>>>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
20457>>>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
20458>>>>>>>>>>>>>                
20458>>>>>>>>>>>>>            End
20458>>>>>>>>>>>>>>
20458>>>>>>>>>>>>>        End
20458>>>>>>>>>>>>>>
20458>>>>>>>>>>>>>        
20458>>>>>>>>>>>>>        Function_Return hoSQLStatement
20459>>>>>>>>>>>>>    End_Function
20460>>>>>>>>>>>>>    
20460>>>>>>>>>>>>>End_Class
20461>>>>>>>>>>>>>
20461>>>>>>>>>>>>>// Manager for embedded SQL handles.                           
20461>>>>>>>>>>>>>// We want to be able to use multiple drivers and multiple            
20461>>>>>>>>>>>>>// connections within a driver and multiple statements within a       
20461>>>>>>>>>>>>>// connection. To allow this we have placed our own handle logic on   
20461>>>>>>>>>>>>>// top of the driver handle logic. This way we can handle the         
20461>>>>>>>>>>>>>// situation where two driver handles may be equal.                   
20461>>>>>>>>>>>>>
20461>>>>>>>>>>>>>Class cSQLHandleManager is a cObject
20462>>>>>>>>>>>>>    
20462>>>>>>>>>>>>>    Procedure Construct_object
20464>>>>>>>>>>>>>        Forward Send Construct_object
20466>>>>>>>>>>>>>        
20466>>>>>>>>>>>>>        Property String  psDefaultDriver      ""
20467>>>>>>>>>>>>>        Property String  psDefaultConnection  ""
20468>>>>>>>>>>>>>        
20468>>>>>>>>>>>>>    End_Procedure
20469>>>>>>>>>>>>>    
20469>>>>>>>>>>>>>    // Create a cSQLConnection object
20469>>>>>>>>>>>>>    Function CreateSQLConnection Returns Handle
20471>>>>>>>>>>>>>        Handle hoSQLConnection
20471>>>>>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
20472>>>>>>>>>>>>>        Function_Return hoSQLConnection
20473>>>>>>>>>>>>>    End_Function
20474>>>>>>>>>>>>>    
20474>>>>>>>>>>>>>    
20474>>>>>>>>>>>>>    // Store default connection information
20474>>>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
20476>>>>>>>>>>>>>        Set psDefaultDriver      to sDriver
20477>>>>>>>>>>>>>        Set psDefaultConnection  to sConnect
20478>>>>>>>>>>>>>    End_Procedure
20479>>>>>>>>>>>>>    
20479>>>>>>>>>>>>>    
20479>>>>>>>>>>>>>    // Make a connection to an embedded SQL server
20479>>>>>>>>>>>>>    // Returns : The DataFlex handle to the connection
20479>>>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
20481>>>>>>>>>>>>>        Handle hoSQLConnection
20481>>>>>>>>>>>>>        Integer bOK
20481>>>>>>>>>>>>>        
20481>>>>>>>>>>>>>        // Check arguments
20481>>>>>>>>>>>>>        If (sDrvrID = "" and sConnect = "") Begin
20483>>>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
20484>>>>>>>>>>>>>            Get psDefaultConnection  to sConnect
20485>>>>>>>>>>>>>        End
20485>>>>>>>>>>>>>>
20485>>>>>>>>>>>>>        
20485>>>>>>>>>>>>>        // Create a cSQLConnection object
20485>>>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20486>>>>>>>>>>>>>        // Connect to the database
20486>>>>>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
20487>>>>>>>>>>>>>        
20487>>>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20487>>>>>>>>>>>>>        If (not(bOK)) Begin
20489>>>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20490>>>>>>>>>>>>>            Move 0 to hoSQLConnection
20491>>>>>>>>>>>>>        End
20491>>>>>>>>>>>>>>
20491>>>>>>>>>>>>>        
20491>>>>>>>>>>>>>        Function_Return hoSQLConnection
20492>>>>>>>>>>>>>    End_Function
20493>>>>>>>>>>>>>    
20493>>>>>>>>>>>>>    
20493>>>>>>>>>>>>>    
20493>>>>>>>>>>>>>    // Make an existing connection available for use with Embedded SQL.
20493>>>>>>>>>>>>>    // The connection is identified by the number of a file
20493>>>>>>>>>>>>>    // that is open for that connection.
20493>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
20495>>>>>>>>>>>>>        Handle hoSQLConnection
20495>>>>>>>>>>>>>        Integer bOK
20495>>>>>>>>>>>>>        
20495>>>>>>>>>>>>>        // Create a cSQLConnection object
20495>>>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20496>>>>>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
20497>>>>>>>>>>>>>        
20497>>>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20497>>>>>>>>>>>>>        If (not(bOK)) Begin
20499>>>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20500>>>>>>>>>>>>>            Move 0 to hoSQLConnection
20501>>>>>>>>>>>>>        End
20501>>>>>>>>>>>>>>
20501>>>>>>>>>>>>>        
20501>>>>>>>>>>>>>        Function_Return hoSQLConnection
20502>>>>>>>>>>>>>    End_Function
20503>>>>>>>>>>>>>    
20503>>>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
20503>>>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
20503>>>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
20503>>>>>>>>>>>>>    // The connectstrings must be an exact match, but can be case insensitive
20503>>>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
20503>>>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
20503>>>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
20505>>>>>>>>>>>>>        Handle hoSQLConnection
20505>>>>>>>>>>>>>        Integer bOK
20505>>>>>>>>>>>>>        
20505>>>>>>>>>>>>>        // Check arguments
20505>>>>>>>>>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
20507>>>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
20508>>>>>>>>>>>>>            Get psDefaultConnection  to sConnectString
20509>>>>>>>>>>>>>        End
20509>>>>>>>>>>>>>>
20509>>>>>>>>>>>>>        
20509>>>>>>>>>>>>>        // Create a cSQLConnection object
20509>>>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20510>>>>>>>>>>>>>        // Connect to the database
20510>>>>>>>>>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
20511>>>>>>>>>>>>>        
20511>>>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20511>>>>>>>>>>>>>        If (not(bOK)) Begin
20513>>>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20514>>>>>>>>>>>>>            Move 0 to hoSQLConnection
20515>>>>>>>>>>>>>        End
20515>>>>>>>>>>>>>>
20515>>>>>>>>>>>>>        
20515>>>>>>>>>>>>>        Function_Return hoSQLConnection
20516>>>>>>>>>>>>>    End_Function
20517>>>>>>>>>>>>>    
20517>>>>>>>>>>>>>    
20517>>>>>>>>>>>>>End_Class
20518>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\MSSqldrv.pkg)
20518>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
20518>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
20518>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>Use Cli.pkg
20518>>>>>>>>>>>>>Use SQL.pkg
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>//   Driver Indentification
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>//   Error number constants
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>// SQL Server spcific types.
20518>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
20518>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
20518>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
20518>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>// SQL Server spcific types.
20518>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
20518>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
20518>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
20518>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
20518>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
20518>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
20518>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
20518>>>>>>>>>>>>>//
20518>>>>>>>>>>>>>//     Setup a constraint for a file.
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>
20518>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
20519>>>>>>>>>>>>>    
20519>>>>>>>>>>>>>    Procedure Construct_Object
20521>>>>>>>>>>>>>        Forward Send Construct_Object
20523>>>>>>>>>>>>>        
20523>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
20524>>>>>>>>>>>>>    End_Procedure
20525>>>>>>>>>>>>>    
20525>>>>>>>>>>>>>    
20525>>>>>>>>>>>>>    
20525>>>>>>>>>>>>>    //   Extract the list from the out connect string.
20525>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
20527>>>>>>>>>>>>>        String  sItem
20527>>>>>>>>>>>>>        Integer iStart
20527>>>>>>>>>>>>>        Integer iEnd
20527>>>>>>>>>>>>>        
20527>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
20530>>>>>>>>>>>>>        
20530>>>>>>>>>>>>>        Send Delete_Data to hoStore
20531>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
20532>>>>>>>>>>>>>        While (iStart > 0)
20536>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
20537>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
20540>>>>>>>>>>>>>            Else Begin
20541>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
20542>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
20543>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
20546>>>>>>>>>>>>>                
20546>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
20549>>>>>>>>>>>>>                
20549>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
20552>>>>>>>>>>>>>            End
20552>>>>>>>>>>>>>>
20552>>>>>>>>>>>>>        Loop
20553>>>>>>>>>>>>>>
20553>>>>>>>>>>>>>        
20553>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
20554>>>>>>>>>>>>>    End_Procedure
20555>>>>>>>>>>>>>    
20555>>>>>>>>>>>>>    
20555>>>>>>>>>>>>>    
20555>>>>>>>>>>>>>    //   Call the driver's browse connect function
20555>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
20557>>>>>>>>>>>>>        String  sDriver
20557>>>>>>>>>>>>>        String  sOutConnStr
20557>>>>>>>>>>>>>        Integer iArg
20557>>>>>>>>>>>>>        Integer iRetval
20557>>>>>>>>>>>>>        
20557>>>>>>>>>>>>>        Get psDriverID to sDriver
20558>>>>>>>>>>>>>        If (sDriver <> "") Begin
20560>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
20561>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
20566>>>>>>>>>>>>>        End
20566>>>>>>>>>>>>>>
20566>>>>>>>>>>>>>        
20566>>>>>>>>>>>>>        Function_Return sOutConnStr
20567>>>>>>>>>>>>>    End_Function// BrowseConnect
20568>>>>>>>>>>>>>    
20568>>>>>>>>>>>>>    
20568>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
20570>>>>>>>>>>>>>        String  sDriver
20570>>>>>>>>>>>>>        String  sOutConnStr
20570>>>>>>>>>>>>>        Integer iArg
20570>>>>>>>>>>>>>        Integer iRetval
20570>>>>>>>>>>>>>        
20570>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
20571>>>>>>>>>>>>>        
20571>>>>>>>>>>>>>        Get psDriverID to sDriver
20572>>>>>>>>>>>>>        If (sDriver <> "") Begin
20574>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
20575>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
20580>>>>>>>>>>>>>        End
20580>>>>>>>>>>>>>>
20580>>>>>>>>>>>>>        
20580>>>>>>>>>>>>>        Function_Return sOutConnStr
20581>>>>>>>>>>>>>    End_Function// BrowseConnect
20582>>>>>>>>>>>>>    
20582>>>>>>>>>>>>>    
20582>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
20584>>>>>>>>>>>>>        
20584>>>>>>>>>>>>>        String  sServerList
20584>>>>>>>>>>>>>        Integer iNumServers
20584>>>>>>>>>>>>>        Integer iDriver
20584>>>>>>>>>>>>>        Integer iClientVersion
20584>>>>>>>>>>>>>        String  sDriver
20584>>>>>>>>>>>>>        
20584>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
20585>>>>>>>>>>>>>        
20585>>>>>>>>>>>>>        If (iDriver) Begin
20587>>>>>>>>>>>>>            
20587>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
20590>>>>>>>>>>>>>            
20590>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
20591>>>>>>>>>>>>>            
20591>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
20592>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
20594>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
20595>>>>>>>>>>>>>            End
20595>>>>>>>>>>>>>>
20595>>>>>>>>>>>>>            Else Begin
20596>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
20597>>>>>>>>>>>>>            End
20597>>>>>>>>>>>>>>
20597>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
20598>>>>>>>>>>>>>        End
20598>>>>>>>>>>>>>>
20598>>>>>>>>>>>>>        
20598>>>>>>>>>>>>>        Function_Return iNumServers
20599>>>>>>>>>>>>>        
20599>>>>>>>>>>>>>    End_Function
20600>>>>>>>>>>>>>    
20600>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
20600>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
20600>>>>>>>>>>>>>    //   This may take a long time.
20600>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
20600>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
20602>>>>>>>>>>>>>        
20602>>>>>>>>>>>>>        Integer iNumServers
20602>>>>>>>>>>>>>        Integer iNetworkLocal
20602>>>>>>>>>>>>>        
20602>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
20603>>>>>>>>>>>>>        
20603>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
20604>>>>>>>>>>>>>        
20604>>>>>>>>>>>>>        Function_Return iNumServers
20605>>>>>>>>>>>>>        
20605>>>>>>>>>>>>>    End_Function
20606>>>>>>>>>>>>>    
20606>>>>>>>>>>>>>    
20606>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
20606>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
20606>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
20606>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
20608>>>>>>>>>>>>>        
20608>>>>>>>>>>>>>        Integer iNumServers
20608>>>>>>>>>>>>>        Integer iNetworkLocal
20608>>>>>>>>>>>>>        
20608>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
20609>>>>>>>>>>>>>        
20609>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
20610>>>>>>>>>>>>>        
20610>>>>>>>>>>>>>        Function_Return iNumServers
20611>>>>>>>>>>>>>        
20611>>>>>>>>>>>>>    End_Function
20612>>>>>>>>>>>>>    
20612>>>>>>>>>>>>>    
20612>>>>>>>>>>>>>    
20612>>>>>>>>>>>>>    //   Enumerate database in a given server.
20612>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
20614>>>>>>>>>>>>>        Integer hoSQL
20614>>>>>>>>>>>>>        String  sConnect
20614>>>>>>>>>>>>>        String  sDatabase
20614>>>>>>>>>>>>>        Integer hdbc
20614>>>>>>>>>>>>>        Integer hstmt
20614>>>>>>>>>>>>>        Integer iFetchResult
20614>>>>>>>>>>>>>        
20614>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
20617>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
20620>>>>>>>>>>>>>        
20620>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
20623>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
20625>>>>>>>>>>>>>        
20625>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
20627>>>>>>>>>>>>>            Move Current_Object to hoSQL
20628>>>>>>>>>>>>>        End_Object
20629>>>>>>>>>>>>>        
20629>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
20631>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
20632>>>>>>>>>>>>>            If (hdbc <> 0) Begin
20634>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
20635>>>>>>>>>>>>>                If (hstmt <> 0) Begin
20637>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
20637>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
20637>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
20637>>>>>>>>>>>>>                    //   stay the same.
20637>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
20638>>>>>>>>>>>>>                    Send SQLCall to hstmt
20639>>>>>>>>>>>>>                    Repeat
20639>>>>>>>>>>>>>>
20639>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
20640>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
20642>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
20643>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
20644>>>>>>>>>>>>>                        End
20644>>>>>>>>>>>>>>
20644>>>>>>>>>>>>>                    Until (iFetchResult = 0)
20646>>>>>>>>>>>>>                    
20646>>>>>>>>>>>>>                    Send SQLClose to hstmt
20647>>>>>>>>>>>>>                End
20647>>>>>>>>>>>>>>
20647>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
20648>>>>>>>>>>>>>            End
20648>>>>>>>>>>>>>>
20648>>>>>>>>>>>>>        End
20648>>>>>>>>>>>>>>
20648>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
20649>>>>>>>>>>>>>        
20649>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
20650>>>>>>>>>>>>>    End_Function
20651>>>>>>>>>>>>>    
20651>>>>>>>>>>>>>    
20651>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
20653>>>>>>>>>>>>>        
20653>>>>>>>>>>>>>        String  sSqlServerClientVersionName
20653>>>>>>>>>>>>>        
20653>>>>>>>>>>>>>        
20653>>>>>>>>>>>>>        Case Begin
20653>>>>>>>>>>>>>
20653>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
20655>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
20656>>>>>>>>>>>>>                Case Break
20657>>>>>>>>>>>>>            
20657>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
20660>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
20661>>>>>>>>>>>>>                Case Break
20662>>>>>>>>>>>>>                
20662>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
20665>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
20666>>>>>>>>>>>>>                Case Break
20667>>>>>>>>>>>>>            
20667>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
20670>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
20671>>>>>>>>>>>>>                Case Break
20672>>>>>>>>>>>>>            
20672>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
20675>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
20676>>>>>>>>>>>>>                Case Break
20677>>>>>>>>>>>>>            
20677>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
20680>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
20681>>>>>>>>>>>>>                Case Break
20682>>>>>>>>>>>>>            
20682>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
20685>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
20686>>>>>>>>>>>>>                Case Break
20687>>>>>>>>>>>>>            
20687>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
20690>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
20691>>>>>>>>>>>>>                Case Break
20692>>>>>>>>>>>>>            
20692>>>>>>>>>>>>>            Case Else
20692>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
20693>>>>>>>>>>>>>                
20693>>>>>>>>>>>>>        Case End
20693>>>>>>>>>>>>>        
20693>>>>>>>>>>>>>        
20693>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
20694>>>>>>>>>>>>>        
20694>>>>>>>>>>>>>    End_Function
20695>>>>>>>>>>>>>
20695>>>>>>>>>>>>>
20695>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
20697>>>>>>>>>>>>>        
20697>>>>>>>>>>>>>        String  sSqlServerClientDriverName
20697>>>>>>>>>>>>>        
20697>>>>>>>>>>>>>        Case Begin
20697>>>>>>>>>>>>>
20697>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
20699>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
20700>>>>>>>>>>>>>                Case Break
20701>>>>>>>>>>>>>
20701>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
20704>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
20705>>>>>>>>>>>>>                Case Break
20706>>>>>>>>>>>>>                
20706>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
20709>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
20710>>>>>>>>>>>>>                Case Break
20711>>>>>>>>>>>>>            
20711>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
20714>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
20715>>>>>>>>>>>>>                Case Break
20716>>>>>>>>>>>>>            
20716>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
20719>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
20720>>>>>>>>>>>>>                Case Break
20721>>>>>>>>>>>>>            
20721>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
20724>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
20725>>>>>>>>>>>>>                Case Break
20726>>>>>>>>>>>>>            
20726>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
20729>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
20730>>>>>>>>>>>>>                Case Break
20731>>>>>>>>>>>>>            
20731>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
20734>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
20735>>>>>>>>>>>>>                Case Break
20736>>>>>>>>>>>>>            
20736>>>>>>>>>>>>>            Case Else
20736>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
20737>>>>>>>>>>>>>                
20737>>>>>>>>>>>>>        Case End
20737>>>>>>>>>>>>>        
20737>>>>>>>>>>>>>        
20737>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
20738>>>>>>>>>>>>>        
20738>>>>>>>>>>>>>    End_Function
20739>>>>>>>>>>>>>    
20739>>>>>>>>>>>>>    
20739>>>>>>>>>>>>>End_Class
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\db2_drv.pkg)
20740>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
20740>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
20740>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
20740>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>Use Cli.pkg
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// Driver attributes
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// Driver Indentification
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// Error number constants
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// Call driver function identifiers
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// DB2 specific data types
20740>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
20740>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
20740>>>>>>>>>>>>>Define SQL_XML            for   (-370)
20740>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
20740>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
20740>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
20740>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
20740>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// Extra DB2 commands
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
20740>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>
20740>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
20741>>>>>>>>>>>>>    
20741>>>>>>>>>>>>>    Procedure Construct_Object
20743>>>>>>>>>>>>>        Forward Send Construct_Object
20745>>>>>>>>>>>>>        
20745>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
20746>>>>>>>>>>>>>    End_Procedure
20747>>>>>>>>>>>>>    
20747>>>>>>>>>>>>>    
20747>>>>>>>>>>>>>    
20747>>>>>>>>>>>>>    // Reset the datasource list to the beginning
20747>>>>>>>>>>>>>    Procedure SeedDataSources
20749>>>>>>>>>>>>>        String  sDriver
20749>>>>>>>>>>>>>        String  sVoid
20749>>>>>>>>>>>>>        Integer iRetval
20749>>>>>>>>>>>>>        
20749>>>>>>>>>>>>>        Get psDriverID to sDriver
20750>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
20757>>>>>>>>>>>>>    End_Procedure
20758>>>>>>>>>>>>>    
20758>>>>>>>>>>>>>    
20758>>>>>>>>>>>>>    
20758>>>>>>>>>>>>>    // Call the driver's data sources function
20758>>>>>>>>>>>>>    Function DataSources Returns String
20760>>>>>>>>>>>>>        String  sDriver
20760>>>>>>>>>>>>>        String  sDataSource
20760>>>>>>>>>>>>>        String  sDescription
20760>>>>>>>>>>>>>        Integer iLength
20760>>>>>>>>>>>>>        Integer iRetval
20760>>>>>>>>>>>>>        
20760>>>>>>>>>>>>>        Get psDriverID to sDriver
20761>>>>>>>>>>>>>        If (sDriver <> "") Begin
20763>>>>>>>>>>>>>            Move 8192 to iLength
20764>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
20765>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
20766>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
20771>>>>>>>>>>>>>        End
20771>>>>>>>>>>>>>>
20771>>>>>>>>>>>>>        
20771>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
20774>>>>>>>>>>>>>        Else ;            Function_Return ""
20776>>>>>>>>>>>>>    End_Function
20777>>>>>>>>>>>>>    
20777>>>>>>>>>>>>>End_Class
20778>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\odbc_drv.pkg)
20778>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
20778>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
20778>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
20778>>>>>>>>>>>>>
20778>>>>>>>>>>>>>Use Cli.pkg
20778>>>>>>>>>>>>>
20778>>>>>>>>>>>>>// Driver Indentification
20778>>>>>>>>>>>>>
20778>>>>>>>>>>>>>// Error number constants
20778>>>>>>>>>>>>>
20778>>>>>>>>>>>>>// Call driver function identifiers
20778>>>>>>>>>>>>>
20778>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
20779>>>>>>>>>>>>>    
20779>>>>>>>>>>>>>    Procedure Construct_Object
20781>>>>>>>>>>>>>        Forward Send Construct_Object
20783>>>>>>>>>>>>>        
20783>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
20784>>>>>>>>>>>>>    End_Procedure
20785>>>>>>>>>>>>>    
20785>>>>>>>>>>>>>    
20785>>>>>>>>>>>>>    
20785>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
20785>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
20787>>>>>>>>>>>>>        String  sDriver
20787>>>>>>>>>>>>>        String  sVoid
20787>>>>>>>>>>>>>        Integer iRetval
20787>>>>>>>>>>>>>        
20787>>>>>>>>>>>>>        Get psDriverID to sDriver
20788>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
20795>>>>>>>>>>>>>    End_Procedure
20796>>>>>>>>>>>>>    
20796>>>>>>>>>>>>>    
20796>>>>>>>>>>>>>    // Call the driver's data sources function
20796>>>>>>>>>>>>>    Function DataSources Returns String
20798>>>>>>>>>>>>>        String  sDriver
20798>>>>>>>>>>>>>        String  sDataSource
20798>>>>>>>>>>>>>        String  sDescription
20798>>>>>>>>>>>>>        Integer iLength
20798>>>>>>>>>>>>>        Integer iRetval
20798>>>>>>>>>>>>>        
20798>>>>>>>>>>>>>        Get psDriverID to sDriver
20799>>>>>>>>>>>>>        If (sDriver <> "") Begin
20801>>>>>>>>>>>>>            Move 8192 to iLength
20802>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
20803>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
20804>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
20809>>>>>>>>>>>>>        End
20809>>>>>>>>>>>>>>
20809>>>>>>>>>>>>>        
20809>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
20812>>>>>>>>>>>>>        Else ;            Function_Return ""
20814>>>>>>>>>>>>>    End_Function
20815>>>>>>>>>>>>>    
20815>>>>>>>>>>>>>End_Class
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 23.0\Pkg\DFBTRDRV.PKG)
20816>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
20816>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
20816>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
20816>>>>>>>>>>>>>Use Ui
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Driver Indentification
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>// Driver attributes
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Call_Driver functions ID's
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to create all vars which may be needed
20816>>>>>>>>>>>>>// in other commands.
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
20816>>>>>>>>>>>>>// File must have been opened.
20816>>>>>>>>>>>>>// Filenumber needs to be passed.
20816>>>>>>>>>>>>>// To clear set the owner to "".
20816>>>>>>>>>>>>>// Examples:
20816>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
20816>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
20816>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
20816>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
20816>>>>>>>>>>>>>// To clear:
20816>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
20816>>>>>>>>>>>>>// options.
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to parse for Callback
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
20816>>>>>>>>>>>>>// File must have been opened.
20816>>>>>>>>>>>>>// Filenumber needs to be passed.
20816>>>>>>>>>>>>>// Examples:
20816>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
20816>>>>>>>>>>>>>// which will be tries when opening files.
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
20816>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
20816>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
20816>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to change the transaction type.
20816>>>>>>>>>>>>>// Valid types are:
20816>>>>>>>>>>>>>//     DFBTRTT_NONE
20816>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
20816>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to get the current transaction type.
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to set explicit_locking
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to get explicit locking
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
20816>>>>>>>>>>>>>//
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
20816>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
20816>>>>>>>>>>>>>
20816>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
20817>>>>>>>>>>>>>    
20817>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
20819>>>>>>>>>>>>>        Forward Send Construct_object iImage
20821>>>>>>>>>>>>>        
20821>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
20822>>>>>>>>>>>>>    End_Procedure
20823>>>>>>>>>>>>>    
20823>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
20823>>>>>>>>>>>>>    //
20823>>>>>>>>>>>>>    
20823>>>>>>>>>>>>>    Function CKRevision Returns String
20825>>>>>>>>>>>>>        String  sDriverID
20825>>>>>>>>>>>>>        String  sRevision
20825>>>>>>>>>>>>>        String  sVoid
20825>>>>>>>>>>>>>        Integer iRetval
20825>>>>>>>>>>>>>        
20825>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20825>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20825>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20825>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20826>>>>>>>>>>>>>        Get psDriverID to sDriverID
20827>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
20828>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
20833>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20834>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
20836>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20836>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
20837>>>>>>>>>>>>>        End
20837>>>>>>>>>>>>>>
20837>>>>>>>>>>>>>        Function_Return sRevision
20838>>>>>>>>>>>>>    End_Function
20839>>>>>>>>>>>>>    
20839>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
20841>>>>>>>>>>>>>        String  sDriverID
20841>>>>>>>>>>>>>        String  sVoid1
20841>>>>>>>>>>>>>        String  sVoid2
20841>>>>>>>>>>>>>        Integer iRetval
20841>>>>>>>>>>>>>        
20841>>>>>>>>>>>>>        Get psDriverID to sDriverID
20842>>>>>>>>>>>>>        
20842>>>>>>>>>>>>>        Move 0 to iRetval
20843>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20843>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20843>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
20843>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20844>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
20849>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20850>>>>>>>>>>>>>        
20850>>>>>>>>>>>>>        Function_Return iRetval
20851>>>>>>>>>>>>>    End_Function
20852>>>>>>>>>>>>>    
20852>>>>>>>>>>>>>    
20852>>>>>>>>>>>>>    
20852>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
20852>>>>>>>>>>>>>    //
20852>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
20852>>>>>>>>>>>>>    //
20852>>>>>>>>>>>>>    
20852>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
20854>>>>>>>>>>>>>        Integer iPartRev
20854>>>>>>>>>>>>>        Integer iCurrentPart
20854>>>>>>>>>>>>>        Integer iSeparatorPos
20854>>>>>>>>>>>>>        
20854>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
20857>>>>>>>>>>>>>        
20857>>>>>>>>>>>>>        Move 0 to iCurrentPart
20858>>>>>>>>>>>>>        Repeat
20858>>>>>>>>>>>>>>
20858>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
20859>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
20861>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
20862>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
20863>>>>>>>>>>>>>                Increment iCurrentPart
20864>>>>>>>>>>>>>            End
20864>>>>>>>>>>>>>>
20864>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
20867>>>>>>>>>>>>>                Move sRevision to iPartRev
20868>>>>>>>>>>>>>                Move "" to sRevision
20869>>>>>>>>>>>>>                Increment iCurrentPart
20870>>>>>>>>>>>>>            End
20870>>>>>>>>>>>>>>
20870>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
20872>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
20874>>>>>>>>>>>>>        
20874>>>>>>>>>>>>>        Function_Return iPartRev
20875>>>>>>>>>>>>>    End_Function
20876>>>>>>>>>>>>>    
20876>>>>>>>>>>>>>    
20876>>>>>>>>>>>>>    
20876>>>>>>>>>>>>>    //
20876>>>>>>>>>>>>>    //  Returns the major revision of the CK
20876>>>>>>>>>>>>>    //
20876>>>>>>>>>>>>>    
20876>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
20878>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
20879>>>>>>>>>>>>>    End_Function
20880>>>>>>>>>>>>>    
20880>>>>>>>>>>>>>    
20880>>>>>>>>>>>>>    
20880>>>>>>>>>>>>>    //  Returns the minor revision of the CK
20880>>>>>>>>>>>>>    //
20880>>>>>>>>>>>>>    
20880>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
20882>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
20883>>>>>>>>>>>>>    End_Function
20884>>>>>>>>>>>>>    
20884>>>>>>>>>>>>>    
20884>>>>>>>>>>>>>    //  Returns the release revision of the CK
20884>>>>>>>>>>>>>    //
20884>>>>>>>>>>>>>    
20884>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
20886>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
20887>>>>>>>>>>>>>    End_Function
20888>>>>>>>>>>>>>    
20888>>>>>>>>>>>>>    
20888>>>>>>>>>>>>>    //  Returns the major revision of the CK
20888>>>>>>>>>>>>>    //
20888>>>>>>>>>>>>>    
20888>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
20890>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
20891>>>>>>>>>>>>>    End_Function
20892>>>>>>>>>>>>>    
20892>>>>>>>>>>>>>    
20892>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
20892>>>>>>>>>>>>>    //
20892>>>>>>>>>>>>>    
20892>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
20894>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
20897>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
20900>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
20903>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
20906>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
20909>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
20913>>>>>>>>>>>>>            End
20913>>>>>>>>>>>>>>
20913>>>>>>>>>>>>>        End
20913>>>>>>>>>>>>>>
20913>>>>>>>>>>>>>        
20913>>>>>>>>>>>>>        Function_Return (False)
20914>>>>>>>>>>>>>    End_Function
20915>>>>>>>>>>>>>    
20915>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
20915>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
20915>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
20915>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
20915>>>>>>>>>>>>>    //
20915>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
20915>>>>>>>>>>>>>    //   in the following format:
20915>>>>>>>>>>>>>    //       <version>.<revision>.<type>
20915>>>>>>>>>>>>>    //   possible values for <type>:
20915>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
20915>>>>>>>>>>>>>    //         server using Workgroup authentication mode
20915>>>>>>>>>>>>>    //       C for client cache engine
20915>>>>>>>>>>>>>    //       D for DOS workstation
20915>>>>>>>>>>>>>    //       N for client Requester
20915>>>>>>>>>>>>>    //       S for NetWare server
20915>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
20915>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
20915>>>>>>>>>>>>>    //
20915>>>>>>>>>>>>>    //   example:
20915>>>>>>>>>>>>>    //       8.50.T
20915>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
20915>>>>>>>>>>>>>    //   32-bits Windows server.
20915>>>>>>>>>>>>>    //
20915>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
20915>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
20915>>>>>>>>>>>>>    //
20915>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
20915>>>>>>>>>>>>>    //   the functions will return "0.0.0"
20915>>>>>>>>>>>>>    
20915>>>>>>>>>>>>>    //  Returns the version information of the
20915>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
20915>>>>>>>>>>>>>    
20915>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
20917>>>>>>>>>>>>>        
20917>>>>>>>>>>>>>        String  sDriverID
20917>>>>>>>>>>>>>        String  sVersion
20917>>>>>>>>>>>>>        String  sVoid
20917>>>>>>>>>>>>>        Integer iRetval
20917>>>>>>>>>>>>>        
20917>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20917>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20917>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20917>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20918>>>>>>>>>>>>>        Get psDriverID to sDriverID
20919>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20920>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20925>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20926>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20928>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20928>>>>>>>>>>>>>            Move "0.0.0" to sVersion
20929>>>>>>>>>>>>>        End
20929>>>>>>>>>>>>>>
20929>>>>>>>>>>>>>        Function_Return sVersion
20930>>>>>>>>>>>>>    End_Function
20931>>>>>>>>>>>>>    
20931>>>>>>>>>>>>>    //           Pervasive.SQL Engine
20931>>>>>>>>>>>>>    
20931>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
20933>>>>>>>>>>>>>        
20933>>>>>>>>>>>>>        String  sDriverID
20933>>>>>>>>>>>>>        String  sVersion
20933>>>>>>>>>>>>>        String  sVoid
20933>>>>>>>>>>>>>        Integer iRetval
20933>>>>>>>>>>>>>        
20933>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20933>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20933>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20933>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20934>>>>>>>>>>>>>        Get psDriverID to sDriverID
20935>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20936>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20941>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20942>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20944>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20944>>>>>>>>>>>>>            Move "0.0.0" to sVersion
20945>>>>>>>>>>>>>        End
20945>>>>>>>>>>>>>>
20945>>>>>>>>>>>>>        Function_Return sVersion
20946>>>>>>>>>>>>>    End_Function
20947>>>>>>>>>>>>>    
20947>>>>>>>>>>>>>    //  Returns the version information of the
20947>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
20947>>>>>>>>>>>>>    
20947>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
20949>>>>>>>>>>>>>        
20949>>>>>>>>>>>>>        String  sDriverID
20949>>>>>>>>>>>>>        String  sVersion
20949>>>>>>>>>>>>>        String  sVoid
20949>>>>>>>>>>>>>        Integer iRetval
20949>>>>>>>>>>>>>        
20949>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20949>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20949>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20949>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20950>>>>>>>>>>>>>        Get psDriverID to sDriverID
20951>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20952>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20957>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20958>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20960>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20960>>>>>>>>>>>>>            Move "0.0.0" to sVersion
20961>>>>>>>>>>>>>        End
20961>>>>>>>>>>>>>>
20961>>>>>>>>>>>>>        Function_Return sVersion
20962>>>>>>>>>>>>>    End_Function
20963>>>>>>>>>>>>>    
20963>>>>>>>>>>>>>End_Class
20964>>>>>>>>>>>>>
20964>>>>>>>>>>>>>
20964>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
20964>>>>>>>>>>>>>//****************************************************************************
20964>>>>>>>>>>>>>// $Module type: Include file
20964>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
20964>>>>>>>>>>>>>//
20964>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
20964>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
20964>>>>>>>>>>>>>// E-mail      : support@rdctools.com
20964>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
20964>>>>>>>>>>>>>//
20964>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
20964>>>>>>>>>>>>>//
20964>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
20964>>>>>>>>>>>>>//
20964>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
20964>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
20964>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
20964>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
20964>>>>>>>>>>>>>// in the help folder for more details.
20964>>>>>>>>>>>>>//
20964>>>>>>>>>>>>>Use Winkern.pkg
20964>>>>>>>>>>>>>Use cIniFile.pkg
20964>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCryptographerEx.pkg)
20964>>>>>>>>>>>>>>>Use VdfBase.pkg
20964>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 23.0\Pkg\CryptographerConstants.pkg)
20964>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
20964>>>>>>>>>>>>>>>>>// Algorithm classes
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
20964>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Algorithm types
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
20964>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Generic sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// RSA sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// DSS sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// DES sub_ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
20964>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
20964>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
20964>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
20964>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
20964>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
20964>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
20964>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
20964>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Fortezza sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
20964>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// RC2 sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
20964>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
20964>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Hash sub ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
20964>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
20964>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
20964>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
20964>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
20964>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
20964>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// secure channel sub ids
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
20964>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
20964>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
20964>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// algorithm identifier definitions
20964>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
20964>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
20964>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
20964>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
20964>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
20964>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
20964>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
20964>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
20964>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
20964>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
20964>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
20964>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
20964>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
20964>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
20964>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
20964>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
20964>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
20964>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
20964>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
20964>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
20964>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
20964>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
20964>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
20964>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
20964>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
20964>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
20964>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
20964>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
20964>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
20964>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
20964>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
20964>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
20964>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
20964>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
20964>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
20964>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
20964>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
20964>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
20964>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
20964>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
20964>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
20964>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
20964>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
20964>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Providers
20964>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
20964>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
20964>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
20964>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
20964>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
20964>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
20964>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
20964>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
20964>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
20964>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
20964>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
20964>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
20964>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
20964>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
20964>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
20964>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
20964>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
20964>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
20964>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
20964>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
20964>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
20964>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
20964>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
20964>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
20964>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Provider types
20964>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
20964>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
20964>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
20964>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
20964>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
20964>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
20964>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
20964>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
20964>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
20964>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
20964>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
20964>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
20964>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
20964>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
20964>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
20964>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
20964>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
20964>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// KP_MODE
20964>>>>>>>>>>>>>>>>>// KP_MODE
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
20964>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
20964>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
20964>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
20964>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
20964>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
20964>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
20964>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
20964>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
20964>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
20964>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
20964>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
20964>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
20964>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
20964>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
20964>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
20964>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
20964>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
20964>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
20964>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
20964>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
20964>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
20964>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
20964>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
20964>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
20964>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
20964>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
20964>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
20964>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
20964>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
20964>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
20964>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
20964>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
20964>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
20964>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
20964>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
20964>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
20964>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
20964>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
20964>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
20964>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
20964>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
20964>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
20964>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
20964>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
20964>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
20964>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
20964>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// key BLOB types
20964>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
20964>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
20964>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
20964>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
20964>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
20964>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
20964>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
20964>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// KP_PADDING
20964>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
20964>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
20964>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
20964>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
20964>>>>>>>>>>>>>>>>>    UChar    bType
20964>>>>>>>>>>>>>>>>>    UChar    bVersion
20964>>>>>>>>>>>>>>>>>    UShort   reserved
20964>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
20964>>>>>>>>>>>>>>>>>End_Struct
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
20964>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
20964>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
20964>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
20964>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
20964>>>>>>>>>>>>>>>>>End_Struct
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
20964>>>>>>>>>>>>>>>>>Struct HMAC_INFO
20964>>>>>>>>>>>>>>>>>    UInteger HashAlgid
20964>>>>>>>>>>>>>>>>>    Pointer pbInnerString
20964>>>>>>>>>>>>>>>>>    DWord cbInnerString
20964>>>>>>>>>>>>>>>>>    Pointer pbOuterString
20964>>>>>>>>>>>>>>>>>    DWord cbOuterString
20964>>>>>>>>>>>>>>>>>End_Struct
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>Struct BLOBHEADER
20964>>>>>>>>>>>>>>>>>    UChar   bType
20964>>>>>>>>>>>>>>>>>    UChar   bVersion
20964>>>>>>>>>>>>>>>>>    Short   reserved
20964>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
20964>>>>>>>>>>>>>>>>>End_Struct
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>Struct CryptoBlob
20964>>>>>>>>>>>>>>>>>    BLOBHEADER  header
20964>>>>>>>>>>>>>>>>>    BLOBHEADER  header
20964>>>>>>>>>>>>>>>>>    Integer     cbKeySize
20964>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
20964>>>>>>>>>>>>>>>>>End_Struct
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>
20964>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
20964>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
20965>>>>>>>>>>>>>>>>>
20965>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
20965>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
20967>>>>>>>>>>>>>>>>>    
20967>>>>>>>>>>>>>>>>>    Boolean bResult
20967>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
20967>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
20967>>>>>>>>>>>>>>>>>
20967>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
20968>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
20969>>>>>>>>>>>>>>>>>    
20969>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
20970>>>>>>>>>>>>>>>>>
20970>>>>>>>>>>>>>>>>>    Function_Return bResult
20971>>>>>>>>>>>>>>>>>End_Function
20972>>>>>>>>>>>>>>>>>
20972>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
20973>>>>>>>>>>>>>>>>>
20973>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
20974>>>>>>>>>>>>>>>>>
20974>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
20975>>>>>>>>>>>>>>>>>
20975>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
20976>>>>>>>>>>>>>>>>>
20976>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
20977>>>>>>>>>>>>>>>>>
20977>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
20978>>>>>>>>>>>>>>>>>
20978>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
20979>>>>>>>>>>>>>>>>>
20979>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
20980>>>>>>>>>>>>>>>>>
20980>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
20981>>>>>>>>>>>>>>>>>    
20981>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
20982>>>>>>>>>>>>>>>>>
20982>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
20983>>>>>>>>>>>>>>>>>
20983>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
20984>>>>>>>>>>>>>>>>>
20984>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
20985>>>>>>>>>>>>>>>>>    
20985>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
20986>>>>>>>>>>>>>>>>>    
20986>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
20987>>>>>>>>>>>>>>>>>    
20987>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
20988>>>>>>>>>>>>>>>
20988>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
20989>>>>>>>>>>>>>>>    
20989>>>>>>>>>>>>>>>    Procedure Construct_Object
20991>>>>>>>>>>>>>>>        Forward Send Construct_Object
20993>>>>>>>>>>>>>>>        
20993>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
20994>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
20995>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
20996>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
20997>>>>>>>>>>>>>>>        
20997>>>>>>>>>>>>>>>        // Private properties
20997>>>>>>>>>>>>>>>        Property Handle     Private_phProv
20998>>>>>>>>>>>>>>>        
20998>>>>>>>>>>>>>>>        // Block cipher properties
20998>>>>>>>>>>>>>>>        Property UChar[]    paKey
20999>>>>>>>>>>>>>>>        Property UChar[]    paIV
21000>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
21001>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
21002>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
21003>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
21004>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
21005>>>>>>>>>>>>>>>    End_Procedure
21006>>>>>>>>>>>>>>>    
21006>>>>>>>>>>>>>>>    
21006>>>>>>>>>>>>>>>    // Acquire key container handle
21006>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
21008>>>>>>>>>>>>>>>        Integer iProvider
21008>>>>>>>>>>>>>>>        WString wProvider
21008>>>>>>>>>>>>>>>        Handle hProv
21008>>>>>>>>>>>>>>>        Boolean bOk
21008>>>>>>>>>>>>>>>        Pointer pProv
21008>>>>>>>>>>>>>>>        
21008>>>>>>>>>>>>>>>        Move 0 to hProv
21009>>>>>>>>>>>>>>>        Get piProvider to iProvider
21010>>>>>>>>>>>>>>>        Get psProvider to wProvider
21011>>>>>>>>>>>>>>>        
21011>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
21011>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
21013>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
21014>>>>>>>>>>>>>>>        End
21014>>>>>>>>>>>>>>>>
21014>>>>>>>>>>>>>>>        Else Begin
21015>>>>>>>>>>>>>>>            Move 0 to pProv
21016>>>>>>>>>>>>>>>        End
21016>>>>>>>>>>>>>>>>
21016>>>>>>>>>>>>>>>        
21016>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
21016>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
21017>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
21019>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
21020>>>>>>>>>>>>>>>        End
21020>>>>>>>>>>>>>>>>
21020>>>>>>>>>>>>>>>        
21020>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
21022>>>>>>>>>>>>>>>            // Fallback to original
21022>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
21023>>>>>>>>>>>>>>>            
21023>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
21025>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
21026>>>>>>>>>>>>>>>            End
21026>>>>>>>>>>>>>>>>
21026>>>>>>>>>>>>>>>        End
21026>>>>>>>>>>>>>>>>
21026>>>>>>>>>>>>>>>        Set Private_phProv to hProv
21027>>>>>>>>>>>>>>>        
21027>>>>>>>>>>>>>>>        Function_Return hProv
21028>>>>>>>>>>>>>>>    End_Function
21029>>>>>>>>>>>>>>>    
21029>>>>>>>>>>>>>>>    // Releases key container handle
21029>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
21031>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
21032>>>>>>>>>>>>>>>    End_Function
21033>>>>>>>>>>>>>>>    
21033>>>>>>>>>>>>>>>    // Creates hash object
21033>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
21035>>>>>>>>>>>>>>>        Integer iAlgorithm
21035>>>>>>>>>>>>>>>        Handle hHash
21035>>>>>>>>>>>>>>>        Boolean bOk
21035>>>>>>>>>>>>>>>        
21035>>>>>>>>>>>>>>>        Move 0 to hHash
21036>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
21037>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
21038>>>>>>>>>>>>>>>        
21038>>>>>>>>>>>>>>>        Function_Return hHash
21039>>>>>>>>>>>>>>>    End_Function
21040>>>>>>>>>>>>>>>    
21040>>>>>>>>>>>>>>>    // Destroys the hash object
21040>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
21042>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
21043>>>>>>>>>>>>>>>    End_Function
21044>>>>>>>>>>>>>>>    
21044>>>>>>>>>>>>>>>    // Adds data to hash object
21044>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
21046>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
21047>>>>>>>>>>>>>>>    End_Function
21048>>>>>>>>>>>>>>>    
21048>>>>>>>>>>>>>>>    // Generates session key
21048>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
21050>>>>>>>>>>>>>>>        Integer iAlgorithm
21050>>>>>>>>>>>>>>>        Handle hKey
21050>>>>>>>>>>>>>>>        Boolean bOk
21050>>>>>>>>>>>>>>>        
21050>>>>>>>>>>>>>>>        Move 0 to hKey
21051>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
21052>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
21053>>>>>>>>>>>>>>>        
21053>>>>>>>>>>>>>>>        Function_Return hKey
21054>>>>>>>>>>>>>>>    End_Function
21055>>>>>>>>>>>>>>>    
21055>>>>>>>>>>>>>>>    // Imports a plain text key
21055>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
21057>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
21057>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
21057>>>>>>>>>>>>>>>        Boolean   bSuccess
21057>>>>>>>>>>>>>>>        Handle    hKey
21057>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
21057>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
21058>>>>>>>>>>>>>>>        Integer iVoid
21058>>>>>>>>>>>>>>>        
21058>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
21059>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
21060>>>>>>>>>>>>>>>        
21060>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
21061>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
21062>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
21063>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
21064>>>>>>>>>>>>>>>        
21064>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
21065>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
21066>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
21067>>>>>>>>>>>>>>>        
21067>>>>>>>>>>>>>>>        Move 0 to hKey
21068>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
21069>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
21071>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
21072>>>>>>>>>>>>>>>        End
21072>>>>>>>>>>>>>>>>
21072>>>>>>>>>>>>>>>        
21072>>>>>>>>>>>>>>>        Function_Return hKey
21073>>>>>>>>>>>>>>>    End_Function
21074>>>>>>>>>>>>>>>    
21074>>>>>>>>>>>>>>>    // Destroys the key
21074>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
21076>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
21077>>>>>>>>>>>>>>>    End_Function
21078>>>>>>>>>>>>>>>    
21078>>>>>>>>>>>>>>>    // Retrieves key data
21078>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
21080>>>>>>>>>>>>>>>        Integer iBuffer iLen
21080>>>>>>>>>>>>>>>        Boolean bOk
21080>>>>>>>>>>>>>>>        
21080>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
21081>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
21082>>>>>>>>>>>>>>>        Function_Return iBuffer
21083>>>>>>>>>>>>>>>    End_Function
21084>>>>>>>>>>>>>>>    
21084>>>>>>>>>>>>>>>    // Retrieves a hash value
21084>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
21086>>>>>>>>>>>>>>>        UChar[] ucHash
21087>>>>>>>>>>>>>>>        Integer liResult
21087>>>>>>>>>>>>>>>        DWord   dwDataLen
21087>>>>>>>>>>>>>>>        
21087>>>>>>>>>>>>>>>        Move 0 to dwDataLen
21088>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
21089>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
21092>>>>>>>>>>>>>>>        
21092>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
21093>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
21094>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
21097>>>>>>>>>>>>>>>        
21097>>>>>>>>>>>>>>>        Function_Return ucHash
21098>>>>>>>>>>>>>>>    End_Function
21099>>>>>>>>>>>>>>>
21099>>>>>>>>>>>>>>>    // Encrypts data
21099>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
21101>>>>>>>>>>>>>>>        Handle hProv hHash hKey
21101>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
21101>>>>>>>>>>>>>>>        Boolean bOk
21101>>>>>>>>>>>>>>>        
21101>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21102>>>>>>>>>>>>>>>        If (hProv) Begin
21104>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
21105>>>>>>>>>>>>>>>            If (hHash) Begin
21107>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
21108>>>>>>>>>>>>>>>                If (bOk) Begin
21110>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
21111>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
21112>>>>>>>>>>>>>>>                End
21112>>>>>>>>>>>>>>>>
21112>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
21113>>>>>>>>>>>>>>>            End
21113>>>>>>>>>>>>>>>>
21113>>>>>>>>>>>>>>>            
21113>>>>>>>>>>>>>>>            If (hKey) Begin
21115>>>>>>>>>>>>>>>                //  First call to determine resulting data size
21115>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
21116>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
21117>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
21118>>>>>>>>>>>>>>>                
21118>>>>>>>>>>>>>>>                //  Reserve space in string
21118>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
21120>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
21121>>>>>>>>>>>>>>>                End
21121>>>>>>>>>>>>>>>>
21121>>>>>>>>>>>>>>>                
21121>>>>>>>>>>>>>>>                //  Call to really decrypt
21121>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
21122>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
21122>>>>>>>>>>>>>>>                //Move "" to sData
21122>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
21122>>>>>>>>>>>>>>>                //End
21122>>>>>>>>>>>>>>>                
21122>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21123>>>>>>>>>>>>>>>            End 
21123>>>>>>>>>>>>>>>>
21123>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21124>>>>>>>>>>>>>>>        End 
21124>>>>>>>>>>>>>>>>
21124>>>>>>>>>>>>>>>        Function_Return ucData
21125>>>>>>>>>>>>>>>    End_Function
21126>>>>>>>>>>>>>>>    
21126>>>>>>>>>>>>>>>    // Decrypts data
21126>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
21128>>>>>>>>>>>>>>>        Handle hProv hHash hKey
21128>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
21128>>>>>>>>>>>>>>>        Boolean bOk
21128>>>>>>>>>>>>>>>        
21128>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21129>>>>>>>>>>>>>>>        If (hProv) Begin
21131>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
21132>>>>>>>>>>>>>>>            If (hHash) Begin
21134>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
21135>>>>>>>>>>>>>>>                If (bOk) Begin
21137>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
21138>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
21139>>>>>>>>>>>>>>>                End
21139>>>>>>>>>>>>>>>>
21139>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
21140>>>>>>>>>>>>>>>            End
21140>>>>>>>>>>>>>>>>
21140>>>>>>>>>>>>>>>            
21140>>>>>>>>>>>>>>>            If (hKey) Begin
21142>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
21143>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
21144>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
21144>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
21146>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
21147>>>>>>>>>>>>>>>                End
21147>>>>>>>>>>>>>>>>
21147>>>>>>>>>>>>>>>                
21147>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21148>>>>>>>>>>>>>>>            End
21148>>>>>>>>>>>>>>>>
21148>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21149>>>>>>>>>>>>>>>        End
21149>>>>>>>>>>>>>>>>
21149>>>>>>>>>>>>>>>        Function_Return ucData
21150>>>>>>>>>>>>>>>    End_Function
21151>>>>>>>>>>>>>>>    
21151>>>>>>>>>>>>>>>    // Creates a key
21151>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
21153>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
21153>>>>>>>>>>>>>>>        CryptoBlob keyBlob
21153>>>>>>>>>>>>>>>        CryptoBlob keyBlob
21153>>>>>>>>>>>>>>>        Boolean bOk
21153>>>>>>>>>>>>>>>        Handle hKey
21153>>>>>>>>>>>>>>>        UChar[] aKey
21154>>>>>>>>>>>>>>>
21154>>>>>>>>>>>>>>>        Get paKey to aKey
21155>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
21156>>>>>>>>>>>>>>>        Get piKeyType to iType
21157>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
21158>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
21159>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
21160>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
21161>>>>>>>>>>>>>>>        
21161>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
21162>>>>>>>>>>>>>>>        For iByte from 0 to iLength
21168>>>>>>>>>>>>>>>>
21168>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
21169>>>>>>>>>>>>>>>        Loop
21170>>>>>>>>>>>>>>>>
21170>>>>>>>>>>>>>>>        
21170>>>>>>>>>>>>>>>        Move 0 to hKey
21171>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
21172>>>>>>>>>>>>>>>        Function_Return hKey
21173>>>>>>>>>>>>>>>    End_Function
21174>>>>>>>>>>>>>>>    
21174>>>>>>>>>>>>>>>    // Sets the key parameters
21174>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
21176>>>>>>>>>>>>>>>        Integer iPadding iMode
21176>>>>>>>>>>>>>>>        Boolean bOk
21176>>>>>>>>>>>>>>>        UChar[] aIV
21177>>>>>>>>>>>>>>>        
21177>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
21177>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
21177>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
21177>>>>>>>>>>>>>>>        //Loop
21177>>>>>>>>>>>>>>>
21177>>>>>>>>>>>>>>>        // Set initialization vector
21177>>>>>>>>>>>>>>>        Get paIV to aIV
21178>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
21179>>>>>>>>>>>>>>>        If (bOk) Begin
21181>>>>>>>>>>>>>>>            // Set padding
21181>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
21182>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
21183>>>>>>>>>>>>>>>            If (bOk) Begin
21185>>>>>>>>>>>>>>>                // Set move
21185>>>>>>>>>>>>>>>                Get piKeyMode to iMode
21186>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
21187>>>>>>>>>>>>>>>            End
21187>>>>>>>>>>>>>>>>
21187>>>>>>>>>>>>>>>        End
21187>>>>>>>>>>>>>>>>
21187>>>>>>>>>>>>>>>        Function_Return bOk        
21188>>>>>>>>>>>>>>>    End_Function
21189>>>>>>>>>>>>>>>    
21189>>>>>>>>>>>>>>>    // Encrypts using block cipher
21189>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
21191>>>>>>>>>>>>>>>        Handle hProv hKey
21191>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
21191>>>>>>>>>>>>>>>        Boolean bOk
21191>>>>>>>>>>>>>>>        
21191>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21192>>>>>>>>>>>>>>>        If (hProv) Begin
21194>>>>>>>>>>>>>>>            // Create key
21194>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
21195>>>>>>>>>>>>>>>            If (hKey) Begin
21197>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
21198>>>>>>>>>>>>>>>                If (bOk) Begin
21200>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
21200>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
21201>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
21202>>>>>>>>>>>>>>>                    
21202>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
21203>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
21204>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
21205>>>>>>>>>>>>>>>                End
21205>>>>>>>>>>>>>>>>
21205>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21206>>>>>>>>>>>>>>>            End
21206>>>>>>>>>>>>>>>>
21206>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21207>>>>>>>>>>>>>>>        End
21207>>>>>>>>>>>>>>>>
21207>>>>>>>>>>>>>>>        Function_Return ucData
21208>>>>>>>>>>>>>>>    End_Function
21209>>>>>>>>>>>>>>>    
21209>>>>>>>>>>>>>>>    // Decrypts using block cipher
21209>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
21211>>>>>>>>>>>>>>>        Handle hProv hKey
21211>>>>>>>>>>>>>>>        Integer iLen
21211>>>>>>>>>>>>>>>        Boolean bOk
21211>>>>>>>>>>>>>>>        
21211>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21212>>>>>>>>>>>>>>>        If (hProv) Begin
21214>>>>>>>>>>>>>>>            // Create key
21214>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
21215>>>>>>>>>>>>>>>            If (hKey) Begin
21217>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
21218>>>>>>>>>>>>>>>                If (bOk) Begin
21220>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
21221>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
21222>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
21223>>>>>>>>>>>>>>>                End
21223>>>>>>>>>>>>>>>>
21223>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21224>>>>>>>>>>>>>>>            End
21224>>>>>>>>>>>>>>>>
21224>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21225>>>>>>>>>>>>>>>        End
21225>>>>>>>>>>>>>>>>
21225>>>>>>>>>>>>>>>        Function_Return ucData
21226>>>>>>>>>>>>>>>    End_Function
21227>>>>>>>>>>>>>>>    
21227>>>>>>>>>>>>>>>    
21227>>>>>>>>>>>>>>>    //  Generates random data.
21227>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
21229>>>>>>>>>>>>>>>        Handle hProv
21229>>>>>>>>>>>>>>>        UChar[] uaResult
21230>>>>>>>>>>>>>>>        Boolean bRes
21230>>>>>>>>>>>>>>>        
21230>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21231>>>>>>>>>>>>>>>        
21231>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
21232>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
21233>>>>>>>>>>>>>>>        
21233>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
21234>>>>>>>>>>>>>>>        
21234>>>>>>>>>>>>>>>        Function_Return uaResult
21235>>>>>>>>>>>>>>>    End_Function
21236>>>>>>>>>>>>>>>    
21236>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
21236>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
21238>>>>>>>>>>>>>>>        String sResult
21238>>>>>>>>>>>>>>>        UChar[] ucData
21239>>>>>>>>>>>>>>>        Pointer pBase64
21239>>>>>>>>>>>>>>>        Integer iVoid
21239>>>>>>>>>>>>>>>        
21239>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
21240>>>>>>>>>>>>>>>        
21240>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
21241>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
21242>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21243>>>>>>>>>>>>>>>        
21243>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
21244>>>>>>>>>>>>>>>    End_Function
21245>>>>>>>>>>>>>>>    
21245>>>>>>>>>>>>>>>End_Class
21246>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
21246>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
21246>>>>>>>>>>>>>>>//>
21246>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
21246>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
21246>>>>>>>>>>>>>>>//>
21246>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
21246>>>>>>>>>>>>>>>//> strings.
21246>>>>>>>>>>>>>>>//>
21246>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
21246>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
21246>>>>>>>>>>>>>>>//>
21246>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
21246>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
21246>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
21246>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
21246>>>>>>>>>>>>>>>
21246>>>>>>>>>>>>>>>Use VdfBase.pkg
21246>>>>>>>>>>>>>>>
21246>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
21246>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
21247>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
21248>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
21249>>>>>>>>>>>>>>>
21249>>>>>>>>>>>>>>>// Structure
21249>>>>>>>>>>>>>>>Struct txxfBase64Buffer
21249>>>>>>>>>>>>>>>    Pointer pData
21249>>>>>>>>>>>>>>>    Integer iLength
21249>>>>>>>>>>>>>>>End_Struct 
21249>>>>>>>>>>>>>>>
21249>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
21249>>>>>>>>>>>>>>>
21249>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
21251>>>>>>>>>>>>>>>    Move Self to oBase64Functions
21252>>>>>>>>>>>>>>>
21252>>>>>>>>>>>>>>>
21252>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
21255>>>>>>>>>>>>>>>        Address pBase64
21255>>>>>>>>>>>>>>>        String sResult
21255>>>>>>>>>>>>>>>        Integer iVoid
21255>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
21256>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
21257>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21258>>>>>>>>>>>>>>>        Function_Return sResult
21259>>>>>>>>>>>>>>>    End_Function
21260>>>>>>>>>>>>>>>
21260>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
21263>>>>>>>>>>>>>>>        Address pBinary
21263>>>>>>>>>>>>>>>        String sBinary
21263>>>>>>>>>>>>>>>        Integer iVoid iLen
21263>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
21264>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
21265>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
21266>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
21267>>>>>>>>>>>>>>>        Function_Return sBinary
21268>>>>>>>>>>>>>>>    End_Function
21269>>>>>>>>>>>>>>>
21269>>>>>>>>>>>>>>>End_Object
21270>>>>>>>>>>>>>Use MSSqldrv.pkg
21270>>>>>>>>>>>>>Use db2_drv.pkg
21270>>>>>>>>>>>>>Use odbc_drv.pkg
21270>>>>>>>>>>>>>Use DFBtrDrv.pkg
21270>>>>>>>>>>>>>Use vWin32fh.pkg
21270>>>>>>>>>>>>>
21270>>>>>>>>>>>>>Use DUFLanguageConstants.inc
21270>>>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
21270>>>>>>>>>>>>>>>//
21270>>>>>>>>>>>>>>>// Use of Mertech drivers:
21270>>>>>>>>>>>>>>>// Put the line "Define Is$MertechDrivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
21270>>>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
21270>>>>>>>>>>>>>>>//          
21270>>>>>>>>>>>>>>>// You can configure conditional variables defined in your code in the Studio via the Conditionals 
21270>>>>>>>>>>>>>>>// tab page on the Configure Workspace dialog. The Is$MertechDrivers conditional has been 
21270>>>>>>>>>>>>>>>// set to "False" by default.
#REM DO ~ USE MERTECH.INC
21270>>>>>>>>>>>>>>>// MySQL Data Types
21270>>>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
21270>>>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
21270>>>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
21270>>>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
21270>>>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
21270>>>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
21270>>>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
21270>>>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
21270>>>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
21270>>>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
21270>>>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
21270>>>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
21270>>>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
21270>>>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
21270>>>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
21270>>>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
21270>>>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
21270>>>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
21270>>>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
21270>>>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
21270>>>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
21270>>>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
21270>>>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
21270>>>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
21270>>>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
21270>>>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
21270>>>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
21270>>>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
21270>>>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
21270>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>// Oracle Data Types
21270>>>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
21270>>>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
21270>>>>>>>>>>>>>>>Define eOracle_INT                                  for   3
21270>>>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
21270>>>>>>>>>>>>>>>Define eOracle_STRING                               for   5
21270>>>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
21270>>>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
21270>>>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
21270>>>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
21270>>>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
21270>>>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
21270>>>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
21270>>>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
21270>>>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
21270>>>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
21270>>>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
21270>>>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
21270>>>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
21270>>>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
21270>>>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
21270>>>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
21270>>>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
21270>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>// PostgreSQL Data Types
21270>>>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
21270>>>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
21270>>>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
21270>>>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
21270>>>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
21270>>>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
21270>>>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
21270>>>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
21270>>>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
21270>>>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
21270>>>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
21270>>>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
21270>>>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
21270>>>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
21270>>>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
21270>>>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
21270>>>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
21270>>>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
21270>>>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
21270>>>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
21270>>>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
21270>>>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
21270>>>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
21270>>>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
21270>>>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
21270>>>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
21270>>>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
21270>>>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
21270>>>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
21270>>>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
21270>>>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
21270>>>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
21270>>>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
21270>>>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
21270>>>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
21270>>>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
21270>>>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
21270>>>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
21270>>>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
21270>>>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
21270>>>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
21270>>>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
21270>>>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
21270>>>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
21270>>>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
21270>>>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
21270>>>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
21270>>>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
21270>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>// SQL Server Data Types
21270>>>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
21270>>>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
21270>>>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
21270>>>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
21270>>>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
21270>>>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
21270>>>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
21270>>>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
21270>>>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
21270>>>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
21270>>>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
21270>>>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
21270>>>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
21270>>>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
21270>>>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
21270>>>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
21270>>>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
21270>>>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
21270>>>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
21270>>>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
21270>>>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
21270>>>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
21270>>>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
21270>>>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
21270>>>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
21270>>>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
21270>>>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
21270>>>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
21270>>>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
21270>>>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
21270>>>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
21270>>>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
21270>>>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
21270>>>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
21270>>>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
21270>>>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
21270>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
21270>>>>>>>>>>>>>>>>>Use DUFLanguageConstants.inc
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
21270>>>>>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
21270>>>>>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
21270>>>>>>>>>>>>>>>>>
21270>>>>>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
21270>>>>>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSQLScriptArray
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
21271>>>>>>>>>>>>>>>>>    Integer iOrgArgumentSize
21271>>>>>>>>>>>>>>>>>    String[] sSQLScriptArray
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSqlErrorArray
21271>>>>>>>>>>>>>>>>>    String[]  sSqlErrorArray
21271>>>>>>>>>>>>>>>>>    String[]  sSqlStatementArray
21271>>>>>>>>>>>>>>>>>    Integer[] iSqlErrorArray
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSqlColumnNew
21271>>>>>>>>>>>>>>>>>    String  sBaseColumnName
21271>>>>>>>>>>>>>>>>>    String  sBaseTableName
21271>>>>>>>>>>>>>>>>>    String  sLabel
21271>>>>>>>>>>>>>>>>>    Integer iSqlType
21271>>>>>>>>>>>>>>>>>    Integer iSize
21271>>>>>>>>>>>>>>>>>    Integer iPrecision
21271>>>>>>>>>>>>>>>>>    Integer iDFType
21271>>>>>>>>>>>>>>>>>    Integer iDFNativeType
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tColumnType
21271>>>>>>>>>>>>>>>>>    String  sSQLType
21271>>>>>>>>>>>>>>>>>    Integer iSQLType
21271>>>>>>>>>>>>>>>>>    Boolean bCanEditSize
21271>>>>>>>>>>>>>>>>>    Integer iDefaultSize
21271>>>>>>>>>>>>>>>>>    Integer iMinSize
21271>>>>>>>>>>>>>>>>>    Number  nMaxSize
21271>>>>>>>>>>>>>>>>>    String  sDataFlexType
21271>>>>>>>>>>>>>>>>>    Integer iDataFlexType
21271>>>>>>>>>>>>>>>>>    Boolean bNativeDataType
21271>>>>>>>>>>>>>>>>>    String  sPrecision
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
21271>>>>>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
21271>>>>>>>>>>>>>>>>>// keywords.
21271>>>>>>>>>>>>>>>>>Struct tSQLKeyWords
21271>>>>>>>>>>>>>>>>>    Integer iSQLWord
21271>>>>>>>>>>>>>>>>>    Integer iSQLDbType
21271>>>>>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSQLRelation
21271>>>>>>>>>>>>>>>>>    Integer iFileNumber
21271>>>>>>>>>>>>>>>>>    Integer iFieldNumber
21271>>>>>>>>>>>>>>>>>    String  sFileName
21271>>>>>>>>>>>>>>>>>    String  sFieldName
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSQLLoggedInUser
21271>>>>>>>>>>>>>>>>>    String sUser
21271>>>>>>>>>>>>>>>>>    String sProgram
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
21271>>>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
21271>>>>>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
21271>>>>>>>>>>>>>>>>>// They can have slightly different SQL keywords.
21271>>>>>>>>>>>>>>>>>// Note: If a new type is added to the list,
21271>>>>>>>>>>>>>>>>>//       the struct array xxx must be adjusted
21271>>>>>>>>>>>>>>>>>//       so that it is filled with all SQL
21271>>>>>>>>>>>>>>>>>//       keywords for that new type.
21271>>>>>>>>>>>>>>>>>Enum_List
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
21271>>>>>>>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
21271>>>>>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
21271>>>>>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
21271>>>>>>>>>>>>>>>>>//    Define EN_DbTypeOracle
21271>>>>>>>>>>>>>>>>>//    Define EN_DbTypeDB2
21271>>>>>>>>>>>>>>>>>//    Define EN_DbTypePostgre
21271>>>>>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
21271>>>>>>>>>>>>>>>>>End_Enum_List
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
21271>>>>>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
21271>>>>>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
21271>>>>>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
21271>>>>>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
21271>>>>>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
21271>>>>>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
21271>>>>>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
21271>>>>>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
21271>>>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
21271>>>>>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
21271>>>>>>>>>>>>>>>>>Enum_List
21271>>>>>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
21271>>>>>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
21271>>>>>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
21271>>>>>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
21271>>>>>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
21271>>>>>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
21271>>>>>>>>>>>>>>>>>End_Enum_List
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
21271>>>>>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
21271>>>>>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// These are not defined pre DF 18:
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSQLIntTableInfo
21271>>>>>>>>>>>>>>>>>    String sDriverName
21271>>>>>>>>>>>>>>>>>    String sServerName
21271>>>>>>>>>>>>>>>>>    String sDatabaseName
21271>>>>>>>>>>>>>>>>>    String sSchemaName
21271>>>>>>>>>>>>>>>>>    Boolean bRecnumTable
21271>>>>>>>>>>>>>>>>>    Integer iPrimaryIndex
21271>>>>>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
21271>>>>>>>>>>>>>>>>>    String sTableCharacterFormat
21271>>>>>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
21271>>>>>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
21271>>>>>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
21271>>>>>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
21271>>>>>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
21271>>>>>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
21271>>>>>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
21271>>>>>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
21271>>>>>>>>>>>>>>>>>    String sFileIndexTablespace
21271>>>>>>>>>>>>>>>>>    String sFileLongTablespace
21271>>>>>>>>>>>>>>>>>    String sTableTablespace
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tSQLIntColumnInfo
21271>>>>>>>>>>>>>>>>>    Integer iFieldNumber
21271>>>>>>>>>>>>>>>>>    Integer iFieldIndex
21271>>>>>>>>>>>>>>>>>    Integer iFieldRelatedFile
21271>>>>>>>>>>>>>>>>>    Integer iFieldRelatedField
21271>>>>>>>>>>>>>>>>>    Integer iIndexNumber
21271>>>>>>>>>>>>>>>>>    Integer iIndexNumberSegments
21271>>>>>>>>>>>>>>>>>    Integer iIndexSegmentField1
21271>>>>>>>>>>>>>>>>>    Integer iIndexSegmentField2
21271>>>>>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
21271>>>>>>>>>>>>>>>>>    String  sIndexName
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIColumn
21271>>>>>>>>>>>>>>>>>    Integer iFieldNumber
21271>>>>>>>>>>>>>>>>>    String  sFieldName
21271>>>>>>>>>>>>>>>>>    Integer iType
21271>>>>>>>>>>>>>>>>>    String  sType
21271>>>>>>>>>>>>>>>>>    Integer iLength
21271>>>>>>>>>>>>>>>>>    Integer iPrecision
21271>>>>>>>>>>>>>>>>>    Integer iOptions
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLType
21271>>>>>>>>>>>>>>>>>    Boolean bAllowNULL
21271>>>>>>>>>>>>>>>>>    String  sDefaultValue
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIColumnCompare
21271>>>>>>>>>>>>>>>>>    Integer iFieldNumber
21271>>>>>>>>>>>>>>>>>    // FROM database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsFrom
21271>>>>>>>>>>>>>>>>>    String  sFieldNameFrom
21271>>>>>>>>>>>>>>>>>    Integer iTypeFrom
21271>>>>>>>>>>>>>>>>>    String  sTypeFrom
21271>>>>>>>>>>>>>>>>>    Integer iLengthFrom
21271>>>>>>>>>>>>>>>>>    Integer iPrecisionFrom
21271>>>>>>>>>>>>>>>>>    Integer iOptionsFrom
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
21271>>>>>>>>>>>>>>>>>    Boolean bAllowNULLFrom
21271>>>>>>>>>>>>>>>>>    String  sDefaultValueFrom
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
21271>>>>>>>>>>>>>>>>>    Boolean bCancelFrom
21271>>>>>>>>>>>>>>>>>    Boolean bErrorFrom
21271>>>>>>>>>>>>>>>>>    // TO database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsTo
21271>>>>>>>>>>>>>>>>>    Integer iFieldNumberTo
21271>>>>>>>>>>>>>>>>>    String  sFieldNameTo
21271>>>>>>>>>>>>>>>>>    Integer iTypeTo
21271>>>>>>>>>>>>>>>>>    String  sTypeTo
21271>>>>>>>>>>>>>>>>>    Integer iLengthTo
21271>>>>>>>>>>>>>>>>>    Integer iPrecisionTo
21271>>>>>>>>>>>>>>>>>    Integer iOptionsTo
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
21271>>>>>>>>>>>>>>>>>    Boolean bAllowNULLTo
21271>>>>>>>>>>>>>>>>>    String  sDefaultValueTo
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
21271>>>>>>>>>>>>>>>>>    Boolean bCancelTo
21271>>>>>>>>>>>>>>>>>    Boolean bErrorTo
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIRelation
21271>>>>>>>>>>>>>>>>>    Handle  hTableFrom
21271>>>>>>>>>>>>>>>>>    Integer iColumnFrom
21271>>>>>>>>>>>>>>>>>    Handle  hTableTo
21271>>>>>>>>>>>>>>>>>    Integer iColumnTo
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameFrom
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameTo
21271>>>>>>>>>>>>>>>>>    String  sFieldNameFrom
21271>>>>>>>>>>>>>>>>>    String  sFieldNameTo
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIRelationCompare
21271>>>>>>>>>>>>>>>>>    // Common:
21271>>>>>>>>>>>>>>>>>    Handle  hTableFrom
21271>>>>>>>>>>>>>>>>>    Integer iColumnFrom
21271>>>>>>>>>>>>>>>>>    Handle  hTableTo
21271>>>>>>>>>>>>>>>>>    Integer iColumnTo
21271>>>>>>>>>>>>>>>>>    // FROM database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsFrom
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameFrom_From
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameTo_From
21271>>>>>>>>>>>>>>>>>    String  sFieldNameFrom_From
21271>>>>>>>>>>>>>>>>>    String  sFieldNameTo_From
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange_From
21271>>>>>>>>>>>>>>>>>    Boolean bCancel_From
21271>>>>>>>>>>>>>>>>>    Boolean bError_From
21271>>>>>>>>>>>>>>>>>    // TO database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsTo
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameFrom_To
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameTo_To
21271>>>>>>>>>>>>>>>>>    String  sFieldNameFrom_To
21271>>>>>>>>>>>>>>>>>    String  sFieldNameTo_To
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange_To
21271>>>>>>>>>>>>>>>>>    Boolean bCancel_To
21271>>>>>>>>>>>>>>>>>    Boolean bError_To
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIIndexSegment
21271>>>>>>>>>>>>>>>>>    Integer iFieldNumber
21271>>>>>>>>>>>>>>>>>    String  sFieldName
21271>>>>>>>>>>>>>>>>>    Boolean bUppercase
21271>>>>>>>>>>>>>>>>>    Boolean bAscending
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIIndex
21271>>>>>>>>>>>>>>>>>    Integer iIndexNumber
21271>>>>>>>>>>>>>>>>>    Integer iPrimaryIndex
21271>>>>>>>>>>>>>>>>>    String  sSQLIndexName
21271>>>>>>>>>>>>>>>>>    Integer iSQLIndexType
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLClustered
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
21271>>>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
21271>>>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPIIndexCompare
21271>>>>>>>>>>>>>>>>>    // Common:
21271>>>>>>>>>>>>>>>>>    Integer iIndexNumber
21271>>>>>>>>>>>>>>>>>    // FROM database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsFrom
21271>>>>>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
21271>>>>>>>>>>>>>>>>>    String  sSQLIndexNameFrom
21271>>>>>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
21271>>>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
21271>>>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
21271>>>>>>>>>>>>>>>>>    Boolean bCancelFrom
21271>>>>>>>>>>>>>>>>>    Boolean bErrorFrom
21271>>>>>>>>>>>>>>>>>    // TO database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsTo
21271>>>>>>>>>>>>>>>>>    Integer iPrimaryIndexTo
21271>>>>>>>>>>>>>>>>>    String  sSQLIndexNameTo
21271>>>>>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
21271>>>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
21271>>>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
21271>>>>>>>>>>>>>>>>>    Boolean bCancelTo
21271>>>>>>>>>>>>>>>>>    Boolean bErrorTo
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPITableNameInfo
21271>>>>>>>>>>>>>>>>>    Integer iTableNumber
21271>>>>>>>>>>>>>>>>>    String  sRootName
21271>>>>>>>>>>>>>>>>>    String  sLogicalName
21271>>>>>>>>>>>>>>>>>    String  sDisplayName
21271>>>>>>>>>>>>>>>>>    String  sDriverID
21271>>>>>>>>>>>>>>>>>    Boolean bIsAlias
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQL
21271>>>>>>>>>>>>>>>>>    Boolean bIsSystemFile
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
21271>>>>>>>>>>>>>>>>>    Integer iTableNumber
21271>>>>>>>>>>>>>>>>>    // FROM
21271>>>>>>>>>>>>>>>>>    Boolean bExistsFrom
21271>>>>>>>>>>>>>>>>>    String  sRootNameFrom
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameFrom
21271>>>>>>>>>>>>>>>>>    String  sDisplayNameFrom
21271>>>>>>>>>>>>>>>>>    String  sDriverIDFrom
21271>>>>>>>>>>>>>>>>>    Boolean bIsAliasFrom
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLFrom
21271>>>>>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
21271>>>>>>>>>>>>>>>>>    // TO database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsTo
21271>>>>>>>>>>>>>>>>>    String  sRootNameTo
21271>>>>>>>>>>>>>>>>>    String  sLogicalNameTo
21271>>>>>>>>>>>>>>>>>    String  sDisplayNameTo
21271>>>>>>>>>>>>>>>>>    String  sDriverIDTo
21271>>>>>>>>>>>>>>>>>    Boolean bIsAliasTo
21271>>>>>>>>>>>>>>>>>    Boolean bIsSQLTo
21271>>>>>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPITable
21271>>>>>>>>>>>>>>>>>    Handle hTable
21271>>>>>>>>>>>>>>>>>    Boolean bFromTable
21271>>>>>>>>>>>>>>>>>    Boolean bToTable
21271>>>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
21271>>>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
21271>>>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
21271>>>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
21271>>>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
21271>>>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
21271>>>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
21271>>>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange
21271>>>>>>>>>>>>>>>>>    Boolean bCancel
21271>>>>>>>>>>>>>>>>>    Boolean bError
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPITableCompare
21271>>>>>>>>>>>>>>>>>    Handle hTable
21271>>>>>>>>>>>>>>>>>    // FROM database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsFrom
21271>>>>>>>>>>>>>>>>>    // TO database:
21271>>>>>>>>>>>>>>>>>    Boolean bExistsTo
21271>>>>>>>>>>>>>>>>>    // Both:
21271>>>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
21271>>>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
21271>>>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
21271>>>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
21271>>>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
21271>>>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
21271>>>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
21271>>>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
21271>>>>>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
21271>>>>>>>>>>>>>>>>>    Boolean bCancel         // User cancel
21271>>>>>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Struct tAPITableBooleans
21271>>>>>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
21271>>>>>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
21271>>>>>>>>>>>>>>>>>    Boolean bCompareIndexAscending
21271>>>>>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
21271>>>>>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
21271>>>>>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
21271>>>>>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
21271>>>>>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
21271>>>>>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
21271>>>>>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
21271>>>>>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
21271>>>>>>>>>>>>>>>>>Enum_List
21271>>>>>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
21271>>>>>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
21271>>>>>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
21271>>>>>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
21271>>>>>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
21271>>>>>>>>>>>>>>>>>End_Enum_List
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>>>>>
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
21271>>>>>>>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
21271>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>    Define MDSDB2    for "MDS_DB2"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
21271>>>>>>>>>>>>>// They can have slightly different SQL keywords.
21271>>>>>>>>>>>>>// Note: If a new type is added to the list,
21271>>>>>>>>>>>>>//       the struct array xxx must be adjusted
21271>>>>>>>>>>>>>//       so that it is filled with all SQL
21271>>>>>>>>>>>>>//       keywords for that new type.
21271>>>>>>>>>>>>>Enum_List  
21271>>>>>>>>>>>>>End_Enum_List
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
21271>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
21271>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
21271>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
21271>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
21271>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
21271>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
21271>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
21271>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
21271>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// SQLConnection.ini constants:
21271>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
21271>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
21271>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
21271>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
21271>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
21271>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// DF 19 ini-file settings:
21271>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
21271>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
21271>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
21271>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
21271>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
21271>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
21271>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
21271>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
21271>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
21271>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
21271>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
21271>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>// Database Update Framework extended settings:
21271>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
21271>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
21271>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
21271>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
21271>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
21271>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
21271>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
21271>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
21271>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
21271>>>>>>>>>>>>>
21271>>>>>>>>>>>>>Struct tSQLConnection
21271>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
21271>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
21271>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
21271>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
21271>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
21271>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
21271>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
21271>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
21271>>>>>>>>>>>>>    String sUserID                  // 9. User ID
21271>>>>>>>>>>>>>    String sPassword                // 10. Password
21271>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
21271>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
21271>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
21271>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
21271>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
21271>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
21271>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
21271>>>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
21271>>>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
21271>>>>>>>>>>>>>End_Struct
21271>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
21271>>>>>>>>>>>
21271>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
21272>>>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
21273>>>>>>>>>>>
21273>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
21275>>>>>>>>>>>        Handle hoSQLManagerMT
21275>>>>>>>>>>>
21275>>>>>>>>>>>        Property String private.psUseDatabase ""
21276>>>>>>>>>>>
21276>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
21276>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
21277>>>>>>>>>>>        Property Integer private.piCurrentField 0
21278>>>>>>>>>>>
21278>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
21279>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
21280>>>>>>>>>>>
21280>>>>>>>>>>>        Property Handle phoSQLManagerMT
21281>>>>>>>>>>>
21281>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
21282>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
21283>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
21284>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
21285>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
21286>>>>>>>>>>>
21286>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
21287>>>>>>>>>>>
21287>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
21288>>>>>>>>>>>        Property String[] paSQLFetchResults
21289>>>>>>>>>>>
21289>>>>>>>>>>>        // Error handling
21289>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
21290>>>>>>>>>>>        Property Boolean pbSqlError False
21291>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
21292>>>>>>>>>>>        Property Boolean pbProcessingError False
21293>>>>>>>>>>>
21293>>>>>>>>>>>        // Statistics on query
21293>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
21294>>>>>>>>>>>        Property TimeSpan ptsQueryExec
21295>>>>>>>>>>>        Property TimeSpan ptsFetchResults
21296>>>>>>>>>>>        Property Integer piColumns 0
21297>>>>>>>>>>>        Property Integer piRows 0
21298>>>>>>>>>>>        Property Integer piRowType 0
21299>>>>>>>>>>>        Property String[] paQueryMessages
21300>>>>>>>>>>>        Property String psSQLStatementString
21301>>>>>>>>>>>
21301>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
21302>>>>>>>>>>>
21302>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
21303>>>>>>>>>>>
21303>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
21303>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
21303>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
21303>>>>>>>>>>>        Property Integer piChunkMax 500
21304>>>>>>>>>>>
21304>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
21304>>>>>>>>>>>        Send SetupSQLKeywordArray
21305>>>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
21306>>>>>>>>>>>    End_Procedure
21307>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
21307>>>>>>>>>>>>
21307>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
21309>>>>>>>>>>>>    Integer iStart iEnd
21309>>>>>>>>>>>>    String sRetval
21309>>>>>>>>>>>>
21309>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
21310>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
21311>>>>>>>>>>>>    If (iStart = 0) Begin
21313>>>>>>>>>>>>        Function_Return ""
21314>>>>>>>>>>>>    End
21314>>>>>>>>>>>>>
21314>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
21315>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
21316>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
21318>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21319>>>>>>>>>>>>    End
21319>>>>>>>>>>>>>
21319>>>>>>>>>>>>    Else Begin
21320>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
21321>>>>>>>>>>>>    End
21321>>>>>>>>>>>>>
21321>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
21323>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21324>>>>>>>>>>>>        Decrement iEnd
21325>>>>>>>>>>>>    End
21325>>>>>>>>>>>>>
21325>>>>>>>>>>>>    If (iEnd <> 0) Begin
21327>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
21328>>>>>>>>>>>>    End
21328>>>>>>>>>>>>>
21328>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
21329>>>>>>>>>>>>
21329>>>>>>>>>>>>    Function_Return (Trim(sRetval))
21330>>>>>>>>>>>>End_Function
21331>>>>>>>>>>>>
21331>>>>>>>>>>>>
21331>>>>>>>>>>>
21331>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
21331>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
21333>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
21335>>>>>>>>>>>            Function_Return (EQ)
21336>>>>>>>>>>>        End
21336>>>>>>>>>>>>
21336>>>>>>>>>>>        Function_Return (GT)
21337>>>>>>>>>>>    End_Function
21338>>>>>>>>>>>
21338>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
21338>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
21340>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
21343>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
21346>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
21349>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
21352>>>>>>>>>>>
21352>>>>>>>>>>>        Function_Return (EQ)
21353>>>>>>>>>>>    End_Function
21354>>>>>>>>>>>
21354>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
21356>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
21356>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
21357>>>>>>>>>>>        Integer iSize
21357>>>>>>>>>>>
21357>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
21358>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
21359>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
21360>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
21361>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
21362>>>>>>>>>>>
21362>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
21363>>>>>>>>>>>    End_Procedure
21364>>>>>>>>>>>
21364>>>>>>>>>>>    // Creates a struct array with all SQL keywords
21364>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
21364>>>>>>>>>>>    // have slightly different wording.
21364>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
21364>>>>>>>>>>>    // needs to be done for every keyword group below.
21364>>>>>>>>>>>    Procedure SetupSQLKeywordArray
21366>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
21366>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
21368>>>>>>>>>>>
21368>>>>>>>>>>>        // This should only be called once; but in case it is
21368>>>>>>>>>>>        // we delete the array first.
21368>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
21369>>>>>>>>>>>
21369>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
21369>>>>>>>>>>>        //
21369>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
21370>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
21371>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
21372>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
21373>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
21374>>>>>>>>>>>
21374>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
21375>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
21376>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
21377>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
21378>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
21379>>>>>>>>>>>
21379>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
21380>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
21381>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
21382>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
21383>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
21384>>>>>>>>>>>
21384>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
21385>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
21386>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
21387>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
21388>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
21389>>>>>>>>>>>
21389>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
21390>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
21391>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
21392>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
21393>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
21394>>>>>>>>>>>
21394>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
21395>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
21396>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
21397>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
21398>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
21399>>>>>>>>>>>
21399>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
21400>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
21401>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
21402>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
21403>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
21404>>>>>>>>>>>
21404>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
21405>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
21406>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
21407>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
21408>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
21409>>>>>>>>>>>
21409>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
21410>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
21411>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
21412>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
21413>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
21414>>>>>>>>>>>
21414>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
21415>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
21416>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
21417>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
21418>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
21419>>>>>>>>>>>
21419>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
21420>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
21421>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
21422>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
21423>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
21424>>>>>>>>>>>
21424>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
21425>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
21426>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
21427>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
21428>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
21429>>>>>>>>>>>
21429>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
21430>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
21431>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
21432>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
21433>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
21434>>>>>>>>>>>
21434>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
21435>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
21436>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
21437>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
21438>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
21439>>>>>>>>>>>
21439>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
21440>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
21441>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
21442>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
21443>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
21444>>>>>>>>>>>
21444>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
21445>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
21446>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
21447>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
21448>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
21449>>>>>>>>>>>
21449>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
21450>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
21451>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
21452>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
21453>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
21454>>>>>>>>>>>
21454>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
21455>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
21456>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
21457>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
21458>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
21459>>>>>>>>>>>
21459>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
21460>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
21461>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
21462>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
21463>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
21464>>>>>>>>>>>
21464>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
21465>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
21466>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
21467>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
21468>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
21469>>>>>>>>>>>
21469>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
21470>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
21471>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
21472>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
21473>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
21474>>>>>>>>>>>
21474>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
21475>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
21476>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
21477>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
21478>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
21479>>>>>>>>>>>
21479>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
21480>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
21481>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
21482>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
21483>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
21484>>>>>>>>>>>
21484>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
21485>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
21486>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
21487>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
21488>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
21489>>>>>>>>>>>
21489>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
21490>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
21491>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
21492>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
21493>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
21494>>>>>>>>>>>
21494>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
21495>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
21496>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
21497>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
21498>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
21499>>>>>>>>>>>
21499>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
21500>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
21501>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
21502>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
21503>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
21504>>>>>>>>>>>
21504>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
21505>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
21506>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
21507>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
21508>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
21509>>>>>>>>>>>
21509>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
21510>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
21511>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
21512>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
21513>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
21514>>>>>>>>>>>
21514>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
21515>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
21516>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
21517>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
21518>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
21519>>>>>>>>>>>
21519>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
21520>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
21521>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
21522>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
21523>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
21524>>>>>>>>>>>
21524>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
21525>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
21526>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
21527>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
21528>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
21529>>>>>>>>>>>
21529>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
21530>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
21531>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
21532>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
21533>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
21534>>>>>>>>>>>
21534>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
21535>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
21536>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
21537>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
21538>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
21539>>>>>>>>>>>
21539>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
21540>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
21541>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
21542>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
21543>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
21544>>>>>>>>>>>
21544>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
21545>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
21546>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
21547>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
21548>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
21549>>>>>>>>>>>
21549>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
21550>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
21551>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
21552>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
21553>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
21554>>>>>>>>>>>
21554>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
21555>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
21556>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
21557>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
21558>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
21559>>>>>>>>>>>
21559>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
21560>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
21561>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
21562>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
21563>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
21564>>>>>>>>>>>
21564>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
21565>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
21566>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
21567>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
21568>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
21569>>>>>>>>>>>
21569>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
21570>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
21571>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
21572>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
21573>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
21574>>>>>>>>>>>
21574>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
21575>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
21576>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
21577>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
21578>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
21579>>>>>>>>>>>
21579>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
21580>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
21581>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
21582>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
21583>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
21584>>>>>>>>>>>
21584>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
21585>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
21586>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
21587>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
21588>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
21589>>>>>>>>>>>
21589>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
21589>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
21590>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
21591>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
21592>>>>>>>>>>>
21592>>>>>>>>>>>    End_Procedure
21593>>>>>>>>>>>
21593>>>>>>>>>>>End_Class
21594>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
21594>>>>>>>>>>>//****************************************************************************
21594>>>>>>>>>>>// $Module type: Class
21594>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
21594>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
21594>>>>>>>>>>>// Web-site    : http://www.rdctools.com
21594>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
21594>>>>>>>>>>>//
21594>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
21594>>>>>>>>>>>//
21594>>>>>>>>>>>// $Rev History:
21594>>>>>>>>>>>//    2015-08-11  Module header created
21594>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
21594>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
21594>>>>>>>>>>>//                Added better error handling.
21594>>>>>>>>>>>//                Added a decompose message for the connection string.
21594>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
21594>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
21594>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
21594>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
21594>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
21594>>>>>>>>>>>//****************************************************************************
21594>>>>>>>>>>>Use cli.pkg
21594>>>>>>>>>>>Use MSSqldrv.pkg
21594>>>>>>>>>>>Use db2_drv.pkg
21594>>>>>>>>>>>Use odbc_drv.pkg
21594>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
21594>>>>>>>>>>>>>//****************************************************************************
21594>>>>>>>>>>>>>// $Module type: Class
21594>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
21594>>>>>>>>>>>>>//
21594>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
21594>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
21594>>>>>>>>>>>>>// E-mail      : support@rdctools.com
21594>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
21594>>>>>>>>>>>>>//
21594>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
21594>>>>>>>>>>>>>//
21594>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
21594>>>>>>>>>>>>>//               properties of that object.
21594>>>>>>>>>>>>>//
21594>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
21594>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
21594>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
21594>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
21594>>>>>>>>>>>>>// in the help folder for more details.
21594>>>>>>>>>>>>>//
21594>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
21594>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
21594>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
21594>>>>>>>>>>>>>>>
21594>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
21595>>>>>>>>>>>>>>>    Procedure Construct_Object
21597>>>>>>>>>>>>>>>        Forward Send Construct_Object
21599>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
21600>>>>>>>>>>>>>>>    End_Procedure
21601>>>>>>>>>>>>>>>
21601>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
21603>>>>>>>>>>>>>>>        String sRetval
21603>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
21605>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
21606>>>>>>>>>>>>>>>        End                                        
21606>>>>>>>>>>>>>>>>
21606>>>>>>>>>>>>>>>        Else Begin
21607>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
21608>>>>>>>>>>>>>>>        End
21608>>>>>>>>>>>>>>>>
21608>>>>>>>>>>>>>>>            
21608>>>>>>>>>>>>>>>        Function_Return sRetval
21609>>>>>>>>>>>>>>>    End_Function
21610>>>>>>>>>>>>>>>
21610>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21612>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
21612>>>>>>>>>>>>>>>
21612>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21613>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
21614>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
21615>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
21617>>>>>>>>>>>>>>>            Move "" to sDatabase
21618>>>>>>>>>>>>>>>        End
21618>>>>>>>>>>>>>>>>
21618>>>>>>>>>>>>>>>        
21618>>>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
21618>>>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
21618>>>>>>>>>>>>>>>//            Function_Return sConnect
21618>>>>>>>>>>>>>>>//        End
21618>>>>>>>>>>>>>>>
21618>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
21620>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
21621>>>>>>>>>>>>>>>        End
21621>>>>>>>>>>>>>>>>
21621>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
21623>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
21624>>>>>>>>>>>>>>>        End
21624>>>>>>>>>>>>>>>>
21624>>>>>>>>>>>>>>>        Else Begin
21625>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
21626>>>>>>>>>>>>>>>        End
21626>>>>>>>>>>>>>>>>
21626>>>>>>>>>>>>>>>        Function_Return sConnect
21627>>>>>>>>>>>>>>>    End_Function
21628>>>>>>>>>>>>>>>
21628>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21630>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21630>>>>>>>>>>>>>>>        String sDriverID
21630>>>>>>>>>>>>>>>
21630>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21631>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
21633>>>>>>>>>>>>>>>            Function_Return True
21634>>>>>>>>>>>>>>>        End
21634>>>>>>>>>>>>>>>>
21634>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
21635>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
21637>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
21638>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
21640>>>>>>>>>>>>>>>        End
21640>>>>>>>>>>>>>>>>
21640>>>>>>>>>>>>>>>        Else Begin
21641>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
21643>>>>>>>>>>>>>>>        End
21643>>>>>>>>>>>>>>>>
21643>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
21644>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21645>>>>>>>>>>>>>>>    End_Function
21646>>>>>>>>>>>>>>>End_Class
21647>>>>>>>>>>>>>>>
21647>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
21648>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
21650>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
21651>>>>>>>>>>>>>>>    End_Function
21652>>>>>>>>>>>>>>>End_Class
21653>>>>>>>>>>>>>>>
21653>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
21654>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21656>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21656>>>>>>>>>>>>>>>        String sDriverID
21656>>>>>>>>>>>>>>>
21656>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21657>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
21658>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
21660>>>>>>>>>>>>>>>            Function_Return True
21661>>>>>>>>>>>>>>>        End
21661>>>>>>>>>>>>>>>>
21661>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
21662>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
21664>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
21666>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
21667>>>>>>>>>>>>>>>            End
21667>>>>>>>>>>>>>>>>
21667>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21670>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21671>>>>>>>>>>>>>>>            End
21671>>>>>>>>>>>>>>>>
21671>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
21673>>>>>>>>>>>>>>>        End
21673>>>>>>>>>>>>>>>>
21673>>>>>>>>>>>>>>>        Else Begin
21674>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
21676>>>>>>>>>>>>>>>        End
21676>>>>>>>>>>>>>>>>
21676>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
21677>>>>>>>>>>>>>>>
21677>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21678>>>>>>>>>>>>>>>    End_Function
21679>>>>>>>>>>>>>>>End_Class
21680>>>>>>>>>>>>>>>
21680>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
21681>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21683>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21683>>>>>>>>>>>>>>>        String sDriverID
21683>>>>>>>>>>>>>>>
21683>>>>>>>>>>>>>>>        Move False to Err
21684>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21685>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21687>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21688>>>>>>>>>>>>>>>        End
21688>>>>>>>>>>>>>>>>
21688>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21690>>>>>>>>>>>>>>>
21690>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21691>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21692>>>>>>>>>>>>>>>    End_Function
21693>>>>>>>>>>>>>>>End_Class
21694>>>>>>>>>>>>>>>
21694>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
21695>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21697>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21697>>>>>>>>>>>>>>>        String sDriverID
21697>>>>>>>>>>>>>>>
21697>>>>>>>>>>>>>>>        Move False to Err
21698>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21699>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21699>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21699>>>>>>>>>>>>>>>//        End
21699>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21701>>>>>>>>>>>>>>>
21701>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21702>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21703>>>>>>>>>>>>>>>    End_Function
21704>>>>>>>>>>>>>>>End_Class
21705>>>>>>>>>>>>>>>
21705>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
21706>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21708>>>>>>>>>>>>>>>        Function_Return ""
21709>>>>>>>>>>>>>>>    End_Function
21710>>>>>>>>>>>>>>>End_Class
21711>>>>>>>>>>>>>>>
21711>>>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
21712>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21714>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21714>>>>>>>>>>>>>>>        String sDriverID
21714>>>>>>>>>>>>>>>
21714>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21715>>>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
21715>>>>>>>>>>>>>>>        Move False to Err
21716>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
21718>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
21720>>>>>>>>>>>>>>>        End
21720>>>>>>>>>>>>>>>>
21720>>>>>>>>>>>>>>>        Else Begin
21721>>>>>>>>>>>>>>>            Login sServer "" "" sDriverID
21723>>>>>>>>>>>>>>>        End
21723>>>>>>>>>>>>>>>>
21723>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21724>>>>>>>>>>>>>>>
21724>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21725>>>>>>>>>>>>>>>    End_Function
21726>>>>>>>>>>>>>>>End_Class
21727>>>>>>>>>>>>>>>
21727>>>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
21728>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21730>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21730>>>>>>>>>>>>>>>        String sDriverID
21730>>>>>>>>>>>>>>>        Integer iPos
21730>>>>>>>>>>>>>>>
21730>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21731>>>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
21732>>>>>>>>>>>>>>>        If (iPos = 0) Begin
21734>>>>>>>>>>>>>>>            If (sDatabase <> "") Begin
21736>>>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
21737>>>>>>>>>>>>>>>            End
21737>>>>>>>>>>>>>>>>
21737>>>>>>>>>>>>>>>        End
21737>>>>>>>>>>>>>>>>
21737>>>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
21737>>>>>>>>>>>>>>>        Move False to Err
21738>>>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
21738>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21740>>>>>>>>>>>>>>>
21740>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21741>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21742>>>>>>>>>>>>>>>    End_Function
21743>>>>>>>>>>>>>>>End_Class
21744>>>>>>>>>>>>>>>
21744>>>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
21745>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21747>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21747>>>>>>>>>>>>>>>        String sDriverID
21747>>>>>>>>>>>>>>>
21747>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21748>>>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
21748>>>>>>>>>>>>>>>        Move False to Err
21749>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
21751>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
21753>>>>>>>>>>>>>>>        End
21753>>>>>>>>>>>>>>>>
21753>>>>>>>>>>>>>>>        Else Begin
21754>>>>>>>>>>>>>>>            Login sServer "" "" sDriverID
21756>>>>>>>>>>>>>>>        End
21756>>>>>>>>>>>>>>>>
21756>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21757>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21758>>>>>>>>>>>>>>>    End_Function
21759>>>>>>>>>>>>>>>End_Class
21760>>>>>>>>>>>>>>>
21760>>>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
21761>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21763>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21763>>>>>>>>>>>>>>>        String sDriverID
21763>>>>>>>>>>>>>>>
21763>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21764>>>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
21764>>>>>>>>>>>>>>>        Move False to Err
21765>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
21767>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
21769>>>>>>>>>>>>>>>        End
21769>>>>>>>>>>>>>>>>
21769>>>>>>>>>>>>>>>        Else Begin
21770>>>>>>>>>>>>>>>            Login sServer "" "" sDriverID
21772>>>>>>>>>>>>>>>        End
21772>>>>>>>>>>>>>>>>
21772>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21773>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21774>>>>>>>>>>>>>>>    End_Function
21775>>>>>>>>>>>>>>>End_Class
21776>>>>>>>>>>>>>>>
21776>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
21777>>>>>>>>>>>>>>>    Procedure Construct_Object
21779>>>>>>>>>>>>>>>        Forward Send Construct_Object
21781>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
21782>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
21783>>>>>>>>>>>>>>>    End_Procedure
21784>>>>>>>>>>>>>>>
21784>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
21786>>>>>>>>>>>>>>>        String sDriverID
21786>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
21786>>>>>>>>>>>>>>>
21786>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21787>>>>>>>>>>>>>>>        Case Begin
21787>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
21789>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
21790>>>>>>>>>>>>>>>                Case Break
21791>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
21794>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
21795>>>>>>>>>>>>>>>                Case Break
21796>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
21799>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
21800>>>>>>>>>>>>>>>                Case Break               
21801>>>>>>>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
21801>>>>>>>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
21801>>>>>>>>>>>>>>>//                Case Break
21801>>>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
21804>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
21805>>>>>>>>>>>>>>>                Case Break
21806>>>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
21809>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
21810>>>>>>>>>>>>>>>                Case Break
21811>>>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
21814>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
21815>>>>>>>>>>>>>>>                Case Break
21816>>>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
21819>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
21820>>>>>>>>>>>>>>>                Case Break
21821>>>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
21821>>>>>>>>>>>>>>>            Case Else
21821>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
21822>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
21823>>>>>>>>>>>>>>>        Case End
21823>>>>>>>>>>>>>>>
21823>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
21824>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
21825>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
21826>>>>>>>>>>>>>>>
21826>>>>>>>>>>>>>>>        Function_Return hoDriver
21827>>>>>>>>>>>>>>>    End_Function
21828>>>>>>>>>>>>>>>
21828>>>>>>>>>>>>>>>    Procedure DestroyDriver
21830>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
21832>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
21833>>>>>>>>>>>>>>>        End
21833>>>>>>>>>>>>>>>>
21833>>>>>>>>>>>>>>>    End_Procedure
21834>>>>>>>>>>>>>>>
21834>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21836>>>>>>>>>>>>>>>        String sConnect
21836>>>>>>>>>>>>>>>        Handle hoDriver
21836>>>>>>>>>>>>>>>
21836>>>>>>>>>>>>>>>        Get CreateDriver to hoDriver
21837>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
21838>>>>>>>>>>>>>>>        Send DestroyDriver
21839>>>>>>>>>>>>>>>        Function_Return sConnect
21840>>>>>>>>>>>>>>>    End_Function
21841>>>>>>>>>>>>>>>
21841>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21843>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21843>>>>>>>>>>>>>>>        Handle hoDriver
21843>>>>>>>>>>>>>>>
21843>>>>>>>>>>>>>>>        Get CreateDriver to hoDriver
21844>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
21845>>>>>>>>>>>>>>>        Send DestroyDriver
21846>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21847>>>>>>>>>>>>>>>    End_Function
21848>>>>>>>>>>>>>>>
21848>>>>>>>>>>>>>>>End_Class
21849>>>>>>>>>>>>>
21849>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cLoginEncryption.pkg)
21849>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
21849>>>>>>>>>>>>>>>
21849>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
21850>>>>>>>>>>>>>>>    
21850>>>>>>>>>>>>>>>    Procedure Construct_Object
21852>>>>>>>>>>>>>>>        Forward Send Construct_Object
21854>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
21854>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
21855>>>>>>>>>>>>>>>        
21855>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
21857>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
21858>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
21859>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
21860>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
21861>>>>>>>>>>>>>>>        End_Object
21862>>>>>>>>>>>>>>>    End_Procedure
21863>>>>>>>>>>>>>>>    
21863>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
21863>>>>>>>>>>>>>>>    // hidden mechanism desired.
21863>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
21865>>>>>>>>>>>>>>>        String sPassword
21865>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
21866>>>>>>>>>>>>>>>        Function_Return sPassword
21867>>>>>>>>>>>>>>>    End_Function
21868>>>>>>>>>>>>>>>    
21868>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
21868>>>>>>>>>>>>>>>    //
21868>>>>>>>>>>>>>>>    // Params:
21868>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
21868>>>>>>>>>>>>>>>    // Returns:
21868>>>>>>>>>>>>>>>    //   Base64 encoded hash.
21868>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
21870>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
21870>>>>>>>>>>>>>>>        UChar[] ucBinary
21871>>>>>>>>>>>>>>>        Pointer pBase64
21871>>>>>>>>>>>>>>>        Integer iVoid
21871>>>>>>>>>>>>>>>        
21871>>>>>>>>>>>>>>>        //  Encrypt Key
21871>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
21872>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
21874>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
21875>>>>>>>>>>>>>>>>
21875>>>>>>>>>>>>>>>        End
21875>>>>>>>>>>>>>>>>
21875>>>>>>>>>>>>>>>        
21875>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
21876>>>>>>>>>>>>>>>        
21876>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
21878>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
21879>>>>>>>>>>>>>>>>
21879>>>>>>>>>>>>>>>            Function_Return ""
21880>>>>>>>>>>>>>>>        End
21880>>>>>>>>>>>>>>>>
21880>>>>>>>>>>>>>>>        
21880>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
21880>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
21881>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
21882>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21883>>>>>>>>>>>>>>>        
21883>>>>>>>>>>>>>>>        Function_Return sBase64
21884>>>>>>>>>>>>>>>    End_Function
21885>>>>>>>>>>>>>>>    
21885>>>>>>>>>>>>>>>    
21885>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
21885>>>>>>>>>>>>>>>    //
21885>>>>>>>>>>>>>>>    // Params:
21885>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
21885>>>>>>>>>>>>>>>    // Returns:
21885>>>>>>>>>>>>>>>    //   Readable plain text password
21885>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
21887>>>>>>>>>>>>>>>        String sEncryptPassword
21887>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
21889>>>>>>>>>>>>>>>        Boolean bIsHex
21889>>>>>>>>>>>>>>>        Integer iLen iVoid
21889>>>>>>>>>>>>>>>        Pointer pBinary
21889>>>>>>>>>>>>>>>        
21889>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
21891>>>>>>>>>>>>>>>            //  Decode from Base64
21891>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
21892>>>>>>>>>>>>>>>            
21892>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
21893>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
21894>>>>>>>>>>>>>>>                        
21894>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
21895>>>>>>>>>>>>>>>            
21895>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
21895>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
21896>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
21897>>>>>>>>>>>>>>>        End
21897>>>>>>>>>>>>>>>>
21897>>>>>>>>>>>>>>>        
21897>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
21898>>>>>>>>>>>>>>>    End_Function
21899>>>>>>>>>>>>>>>End_Class
21900>>>>>>>>>>>>>
21900>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
21901>>>>>>>>>>>>>    Procedure Construct_Object
21903>>>>>>>>>>>>>        Forward Send Construct_Object
21905>>>>>>>>>>>>>
21905>>>>>>>>>>>>>        Property String Private_psIniFilePath
21906>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
21907>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
21908>>>>>>>>>>>>>
21908>>>>>>>>>>>>>        Property Boolean pbDFConnId False
21909>>>>>>>>>>>>>
21909>>>>>>>>>>>>>        // *** You really want to change this value! ***
21909>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
21909>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
21910>>>>>>>>>>>>>
21910>>>>>>>>>>>>>    End_Procedure
21911>>>>>>>>>>>>>
21911>>>>>>>>>>>>>    Procedure End_Construct_Object
21913>>>>>>>>>>>>>        Forward Send End_Construct_Object
21915>>>>>>>>>>>>>    End_Procedure
21916>>>>>>>>>>>>>
21916>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
21918>>>>>>>>>>>>>        String sIniFile
21918>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
21919>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
21920>>>>>>>>>>>>>        Get psIniFileName to sIniFile
21921>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
21922>>>>>>>>>>>>>    End_Procedure
21923>>>>>>>>>>>>>
21923>>>>>>>>>>>>>    Function psIniFilePath Returns String
21925>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
21926>>>>>>>>>>>>>    End_Function
21927>>>>>>>>>>>>>
21927>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
21929>>>>>>>>>>>>>        String sPath
21929>>>>>>>>>>>>>        Get psIniFilePath to sPath
21930>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
21931>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
21932>>>>>>>>>>>>>    End_Procedure
21933>>>>>>>>>>>>>
21933>>>>>>>>>>>>>    Function psIniFileName Returns String
21935>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
21936>>>>>>>>>>>>>    End_Function
21937>>>>>>>>>>>>>
21937>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
21937>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
21937>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
21937>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
21939>>>>>>>>>>>>>        String sIniFile sPath
21939>>>>>>>>>>>>>
21939>>>>>>>>>>>>>        Get psIniFilePath to sPath
21940>>>>>>>>>>>>>        Get psIniFileName to sIniFile
21941>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
21942>>>>>>>>>>>>>        Set psFileName to sIniFile
21943>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
21944>>>>>>>>>>>>>    End_Procedure
21945>>>>>>>>>>>>>
21945>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
21945>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
21945>>>>>>>>>>>>>    // Returns the value
21945>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
21947>>>>>>>>>>>>>        String sValue sIniFile sPath
21947>>>>>>>>>>>>>
21947>>>>>>>>>>>>>        Get psIniFilePath to sPath
21948>>>>>>>>>>>>>        Get psIniFileName to sIniFile
21949>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
21950>>>>>>>>>>>>>        Set psFileName to sIniFile
21951>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
21952>>>>>>>>>>>>>
21952>>>>>>>>>>>>>        Function_Return sValue
21953>>>>>>>>>>>>>    End_Function
21954>>>>>>>>>>>>>
21954>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
21954>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
21956>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
21959>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
21962>>>>>>>>>>>>>
21962>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
21965>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
21968>>>>>>>>>>>>>
21968>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
21971>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
21974>>>>>>>>>>>>>
21974>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
21977>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
21980>>>>>>>>>>>>>
21980>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
21983>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
21986>>>>>>>>>>>>>
21986>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
21989>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
21992>>>>>>>>>>>>>
21992>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
21995>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
21998>>>>>>>>>>>>>
21998>>>>>>>>>>>>>        Function_Return (EQ)
21999>>>>>>>>>>>>>    End_Function
22000>>>>>>>>>>>>>
22000>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
22002>>>>>>>>>>>>>        Handle hoSections
22002>>>>>>>>>>>>>        Integer iItems
22002>>>>>>>>>>>>>
22002>>>>>>>>>>>>>        Send ReadSections hoSections
22003>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
22004>>>>>>>>>>>>>        Function_Return iItems
22005>>>>>>>>>>>>>    End_Function
22006>>>>>>>>>>>>>
22006>>>>>>>>>>>>>    // The normal connection string looks something like this;
22006>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
22006>>>>>>>>>>>>>    // ...but the full connection string looks like this;
22006>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
22006>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
22006>>>>>>>>>>>>>//        String sSection
22006>>>>>>>>>>>>>//        Integer iCount
22006>>>>>>>>>>>>>//
22006>>>>>>>>>>>>>//        Move False to Err
22006>>>>>>>>>>>>>//        Get psIniSectionName to sSection
22006>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
22006>>>>>>>>>>>>>//        Increment iCount
22006>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
22006>>>>>>>>>>>>>//
22006>>>>>>>>>>>>>//        Function_Return (Err = False)
22006>>>>>>>>>>>>>//    End_Function
22006>>>>>>>>>>>>>
22006>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
22008>>>>>>>>>>>>>        Integer iCount
22008>>>>>>>>>>>>>        Boolean bExists
22008>>>>>>>>>>>>>        String sSection
22008>>>>>>>>>>>>>
22008>>>>>>>>>>>>>        Move False to Err
22009>>>>>>>>>>>>>        Move 1 to iCount
22010>>>>>>>>>>>>>        Get psIniSectionName to sSection
22011>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22012>>>>>>>>>>>>>        While (bExists = True)
22016>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
22017>>>>>>>>>>>>>            Increment iCount
22018>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22019>>>>>>>>>>>>>        Loop
22020>>>>>>>>>>>>>>
22020>>>>>>>>>>>>>        Function_Return (Err = False)
22021>>>>>>>>>>>>>    End_Function
22022>>>>>>>>>>>>>
22022>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
22024>>>>>>>>>>>>>        Integer iCount
22024>>>>>>>>>>>>>        String sSection
22024>>>>>>>>>>>>>        Boolean bExists
22024>>>>>>>>>>>>>
22024>>>>>>>>>>>>>        Move False to Err
22025>>>>>>>>>>>>>        Move 1 to iCount
22026>>>>>>>>>>>>>        Get psIniSectionName to sSection
22027>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
22028>>>>>>>>>>>>>        While (bExists = True)
22032>>>>>>>>>>>>>            If (iCount = iItem) Begin
22034>>>>>>>>>>>>>                Send DeleteSection sSection
22035>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
22035>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
22036>>>>>>>>>>>>>            End
22036>>>>>>>>>>>>>>
22036>>>>>>>>>>>>>            Increment iCount
22037>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
22038>>>>>>>>>>>>>        Loop
22039>>>>>>>>>>>>>>
22039>>>>>>>>>>>>>
22039>>>>>>>>>>>>>        Function_Return (Err = False)
22040>>>>>>>>>>>>>    End_Function
22041>>>>>>>>>>>>>
22041>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
22041>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
22041>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
22043>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22043>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22044>>>>>>>>>>>>>        tSQLConnection   SQLConnection
22044>>>>>>>>>>>>>        tSQLConnection   SQLConnection
22044>>>>>>>>>>>>>        Integer iIndex
22044>>>>>>>>>>>>>
22044>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
22045>>>>>>>>>>>>>        If (iIndex = -1) Begin
22047>>>>>>>>>>>>>            Move True to SQLConnection.bError
22048>>>>>>>>>>>>>            Function_Return SQLConnection
22049>>>>>>>>>>>>>        End
22049>>>>>>>>>>>>>>
22049>>>>>>>>>>>>>
22049>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22050>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
22051>>>>>>>>>>>>>
22051>>>>>>>>>>>>>        Function_Return SQLConnection
22052>>>>>>>>>>>>>    End_Function
22053>>>>>>>>>>>>>
22053>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
22053>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
22055>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22055>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22056>>>>>>>>>>>>>        Integer iRetval iCount iSize
22056>>>>>>>>>>>>>        String sValue
22056>>>>>>>>>>>>>        Boolean bExists
22056>>>>>>>>>>>>>
22056>>>>>>>>>>>>>        Move -1 to iRetval
22057>>>>>>>>>>>>>
22057>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22058>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22059>>>>>>>>>>>>>        Decrement iSize
22060>>>>>>>>>>>>>        For iCount from 0 to iSize
22066>>>>>>>>>>>>>>
22066>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
22067>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
22068>>>>>>>>>>>>>            If (bExists) Begin
22070>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
22071>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
22072>>>>>>>>>>>>>            End
22072>>>>>>>>>>>>>>
22072>>>>>>>>>>>>>        Loop
22073>>>>>>>>>>>>>>
22073>>>>>>>>>>>>>
22073>>>>>>>>>>>>>        Function_Return iRetval
22074>>>>>>>>>>>>>    End_Function
22075>>>>>>>>>>>>>
22075>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
22075>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
22075>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
22077>>>>>>>>>>>>>        Integer iCount iSize iItems
22077>>>>>>>>>>>>>        String sValue
22077>>>>>>>>>>>>>        Boolean bExists
22077>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22077>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22078>>>>>>>>>>>>>
22078>>>>>>>>>>>>>        Move 0 to iItems
22079>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22080>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22081>>>>>>>>>>>>>        Decrement iSize
22082>>>>>>>>>>>>>        For iCount from 0 to iSize
22088>>>>>>>>>>>>>>
22088>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
22089>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
22090>>>>>>>>>>>>>            If (bExists) Begin
22092>>>>>>>>>>>>>                Increment iItems
22093>>>>>>>>>>>>>            End
22093>>>>>>>>>>>>>>
22093>>>>>>>>>>>>>        Loop
22094>>>>>>>>>>>>>>
22094>>>>>>>>>>>>>
22094>>>>>>>>>>>>>        Function_Return (iItems > 1)
22095>>>>>>>>>>>>>    End_Function
22096>>>>>>>>>>>>>
22096>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
22096>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
22098>>>>>>>>>>>>>        Boolean bOK
22098>>>>>>>>>>>>>        Integer iSize iCount
22098>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22098>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22099>>>>>>>>>>>>>        tSQLConnection SQLConnection
22099>>>>>>>>>>>>>        tSQLConnection SQLConnection
22099>>>>>>>>>>>>>        String sConnectionString
22099>>>>>>>>>>>>>
22099>>>>>>>>>>>>>        Move False to Err
22100>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
22101>>>>>>>>>>>>>
22101>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22102>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22103>>>>>>>>>>>>>        Decrement iSize
22104>>>>>>>>>>>>>        // Set all current connection to inactive.
22104>>>>>>>>>>>>>        For iCount from 0 to iSize
22110>>>>>>>>>>>>>>
22110>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
22111>>>>>>>>>>>>>        Loop
22112>>>>>>>>>>>>>>
22112>>>>>>>>>>>>>
22112>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
22113>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
22114>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
22115>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
22116>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
22117>>>>>>>>>>>>>
22117>>>>>>>>>>>>>        Function_Return (bOK = True)
22118>>>>>>>>>>>>>    End_Function
22119>>>>>>>>>>>>>
22119>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
22119>>>>>>>>>>>>>    // Returns True if successful.
22119>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
22121>>>>>>>>>>>>>        Boolean bOK
22121>>>>>>>>>>>>>        Integer iItem iSize iCount
22121>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22121>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22122>>>>>>>>>>>>>
22122>>>>>>>>>>>>>        Move False to Err
22123>>>>>>>>>>>>>        Move -1 to iItem
22124>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22125>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22126>>>>>>>>>>>>>        Decrement iSize
22127>>>>>>>>>>>>>        // Set all current connection to inactive.
22127>>>>>>>>>>>>>        For iCount from 0 to iSize
22133>>>>>>>>>>>>>>
22133>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
22134>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
22136>>>>>>>>>>>>>                Move iCount to iItem
22137>>>>>>>>>>>>>            End
22137>>>>>>>>>>>>>>
22137>>>>>>>>>>>>>        Loop
22138>>>>>>>>>>>>>>
22138>>>>>>>>>>>>>
22138>>>>>>>>>>>>>        If (iItem <> -1) Begin
22140>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
22141>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
22142>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
22143>>>>>>>>>>>>>        End
22143>>>>>>>>>>>>>>
22143>>>>>>>>>>>>>
22143>>>>>>>>>>>>>        Function_Return (bOK = True)
22144>>>>>>>>>>>>>    End_Function
22145>>>>>>>>>>>>>
22145>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
22147>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22147>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22148>>>>>>>>>>>>>        String sSection sValue
22148>>>>>>>>>>>>>        Integer iCount
22148>>>>>>>>>>>>>        Boolean bExists
22148>>>>>>>>>>>>>
22148>>>>>>>>>>>>>        Get psIniSectionName to sSection
22149>>>>>>>>>>>>>        Get SectionExists sSection to bExists
22150>>>>>>>>>>>>>        If (bExists = False) Begin
22152>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
22153>>>>>>>>>>>>>        End
22153>>>>>>>>>>>>>>
22153>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
22154>>>>>>>>>>>>>        If (bExists = True) Begin
22156>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
22157>>>>>>>>>>>>>>
22157>>>>>>>>>>>>>        End
22157>>>>>>>>>>>>>>
22157>>>>>>>>>>>>>
22157>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
22158>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22159>>>>>>>>>>>>>
22159>>>>>>>>>>>>>        While (bExists = True)                 
22163>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
22163>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
22163>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
22163>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
22163>>>>>>>>>>>>>
22163>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
22164>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
22165>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
22166>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
22167>>>>>>>>>>>>>
22167>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
22167>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
22168>>>>>>>>>>>>>            If (sValue = "99") Begin
22170>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
22171>>>>>>>>>>>>>            End
22171>>>>>>>>>>>>>>
22171>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
22172>>>>>>>>>>>>>
22172>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
22173>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
22174>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
22176>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
22177>>>>>>>>>>>>>            End
22177>>>>>>>>>>>>>>
22177>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
22179>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
22180>>>>>>>>>>>>>            End
22180>>>>>>>>>>>>>>
22180>>>>>>>>>>>>>
22180>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
22181>>>>>>>>>>>>>
22181>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
22182>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
22183>>>>>>>>>>>>>
22183>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
22184>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
22185>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
22187>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
22188>>>>>>>>>>>>>            End
22188>>>>>>>>>>>>>>
22188>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
22189>>>>>>>>>>>>>
22189>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
22189>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
22190>>>>>>>>>>>>>
22190>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
22191>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
22192>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
22193>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
22194>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
22195>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
22196>>>>>>>>>>>>>
22196>>>>>>>>>>>>>            Increment iCount
22197>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22198>>>>>>>>>>>>>        Loop
22199>>>>>>>>>>>>>>
22199>>>>>>>>>>>>>
22199>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
22199>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
22201>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
22202>>>>>>>>>>>>>        End
22202>>>>>>>>>>>>>>
22202>>>>>>>>>>>>>
22202>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
22203>>>>>>>>>>>>>    End_Function
22204>>>>>>>>>>>>>
22204>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
22206>>>>>>>>>>>>>        Integer iCount iSize
22206>>>>>>>>>>>>>        Boolean bOK
22206>>>>>>>>>>>>>        String sSection sValue
22206>>>>>>>>>>>>>
22206>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
22206>>>>>>>>>>>>>        Move 0 to iCount
22207>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
22208>>>>>>>>>>>>>        If (bOK = False) Begin
22210>>>>>>>>>>>>>            Function_Return False
22211>>>>>>>>>>>>>        End
22211>>>>>>>>>>>>>>
22211>>>>>>>>>>>>>
22211>>>>>>>>>>>>>        Move False to Err
22212>>>>>>>>>>>>>        Get psIniSectionName to sSection
22213>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
22213>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
22214>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22215>>>>>>>>>>>>>        Decrement iSize
22216>>>>>>>>>>>>>
22216>>>>>>>>>>>>>        For iCount from 0 to iSize
22222>>>>>>>>>>>>>>
22222>>>>>>>>>>>>>            // DF 19 compatible settings:
22222>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
22223>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
22224>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
22225>>>>>>>>>>>>>            
22225>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
22226>>>>>>>>>>>>>
22226>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
22227>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
22229>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
22230>>>>>>>>>>>>>            End
22230>>>>>>>>>>>>>>
22230>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
22231>>>>>>>>>>>>>
22231>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
22233>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
22234>>>>>>>>>>>>>            End
22234>>>>>>>>>>>>>>
22234>>>>>>>>>>>>>
22234>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
22235>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
22236>>>>>>>>>>>>>
22236>>>>>>>>>>>>>            // The Database Update Framework extended settings:
22236>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
22237>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
22238>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
22239>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
22240>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
22241>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
22242>>>>>>>>>>>>>        Loop
22243>>>>>>>>>>>>>>
22243>>>>>>>>>>>>>
22243>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
22244>>>>>>>>>>>>>    End_Function
22245>>>>>>>>>>>>>
22245>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
22245>>>>>>>>>>>>>    //
22245>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
22245>>>>>>>>>>>>>    // corresponding to the passed iDbType.
22245>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
22247>>>>>>>>>>>>>        String sRetval
22247>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
22249>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
22250>>>>>>>>>>>>>        End
22250>>>>>>>>>>>>>>
22250>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
22252>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
22253>>>>>>>>>>>>>        End
22253>>>>>>>>>>>>>>
22253>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
22255>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
22256>>>>>>>>>>>>>        End
22256>>>>>>>>>>>>>>
22256>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
22258>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
22259>>>>>>>>>>>>>        End
22259>>>>>>>>>>>>>>
22259>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
22261>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
22262>>>>>>>>>>>>>        End
22262>>>>>>>>>>>>>>
22262>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
22264>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
22265>>>>>>>>>>>>>        End
22265>>>>>>>>>>>>>>
22265>>>>>>>>>>>>>        Function_Return sRetval
22266>>>>>>>>>>>>>    End_Function
22267>>>>>>>>>>>>>
22267>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
22267>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
22267>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
22269>>>>>>>>>>>>>        Integer iRetval
22269>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
22271>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22272>>>>>>>>>>>>>        End
22272>>>>>>>>>>>>>>
22272>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
22274>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
22275>>>>>>>>>>>>>        End
22275>>>>>>>>>>>>>>
22275>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
22277>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
22278>>>>>>>>>>>>>        End
22278>>>>>>>>>>>>>>
22278>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
22280>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
22281>>>>>>>>>>>>>        End
22281>>>>>>>>>>>>>>
22281>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
22283>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
22284>>>>>>>>>>>>>        End
22284>>>>>>>>>>>>>>
22284>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
22286>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
22287>>>>>>>>>>>>>        End
22287>>>>>>>>>>>>>>
22287>>>>>>>>>>>>>        Function_Return iRetval
22288>>>>>>>>>>>>>    End_Function
22289>>>>>>>>>>>>>
22289>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
22289>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
22289>>>>>>>>>>>>>    // the SQL Connection program's grid.
22289>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
22291>>>>>>>>>>>>>        String sRetval
22291>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
22293>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
22294>>>>>>>>>>>>>        End
22294>>>>>>>>>>>>>>
22294>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
22296>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
22297>>>>>>>>>>>>>        End
22297>>>>>>>>>>>>>>
22297>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
22299>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
22300>>>>>>>>>>>>>        End
22300>>>>>>>>>>>>>>
22300>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
22302>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
22303>>>>>>>>>>>>>        End
22303>>>>>>>>>>>>>>
22303>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
22305>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
22306>>>>>>>>>>>>>        End
22306>>>>>>>>>>>>>>
22306>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
22308>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
22309>>>>>>>>>>>>>        End
22309>>>>>>>>>>>>>>
22309>>>>>>>>>>>>>        Function_Return sRetval
22310>>>>>>>>>>>>>    End_Function
22311>>>>>>>>>>>>>
22311>>>>>>>>>>>>>    // Pass a driver id and the function will return
22311>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
22311>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
22311>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
22313>>>>>>>>>>>>>        Integer iRetval
22313>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
22315>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22316>>>>>>>>>>>>>        End
22316>>>>>>>>>>>>>>
22316>>>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
22318>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22319>>>>>>>>>>>>>        End
22319>>>>>>>>>>>>>>
22319>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
22321>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22322>>>>>>>>>>>>>        End
22322>>>>>>>>>>>>>>
22322>>>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
22324>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
22325>>>>>>>>>>>>>        End
22325>>>>>>>>>>>>>>
22325>>>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
22327>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
22328>>>>>>>>>>>>>        End
22328>>>>>>>>>>>>>>
22328>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
22330>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
22331>>>>>>>>>>>>>        End
22331>>>>>>>>>>>>>>
22331>>>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
22333>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
22334>>>>>>>>>>>>>        End
22334>>>>>>>>>>>>>>
22334>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
22336>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
22337>>>>>>>>>>>>>        End
22337>>>>>>>>>>>>>>
22337>>>>>>>>>>>>>        Function_Return iRetval
22338>>>>>>>>>>>>>    End_Function
22339>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
22339>>>>>>>>>>>>>>
22339>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
22341>>>>>>>>>>>>>>    Integer iStart iEnd
22341>>>>>>>>>>>>>>    String sRetval
22341>>>>>>>>>>>>>>
22341>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
22342>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
22343>>>>>>>>>>>>>>    If (iStart = 0) Begin
22345>>>>>>>>>>>>>>        Function_Return ""
22346>>>>>>>>>>>>>>    End
22346>>>>>>>>>>>>>>>
22346>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
22347>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
22348>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
22350>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
22351>>>>>>>>>>>>>>    End
22351>>>>>>>>>>>>>>>
22351>>>>>>>>>>>>>>    Else Begin
22352>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
22353>>>>>>>>>>>>>>    End
22353>>>>>>>>>>>>>>>
22353>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
22355>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
22356>>>>>>>>>>>>>>        Decrement iEnd
22357>>>>>>>>>>>>>>    End
22357>>>>>>>>>>>>>>>
22357>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
22359>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
22360>>>>>>>>>>>>>>    End
22360>>>>>>>>>>>>>>>
22360>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
22361>>>>>>>>>>>>>>
22361>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
22362>>>>>>>>>>>>>>End_Function
22363>>>>>>>>>>>>>>
22363>>>>>>>>>>>>>>
22363>>>>>>>>>>>>>
22363>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
22365>>>>>>>>>>>>>        String sConnect
22365>>>>>>>>>>>>>        Handle hoDriver
22365>>>>>>>>>>>>>
22365>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
22366>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
22367>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
22368>>>>>>>>>>>>>        Send Destroy of hoDriver
22369>>>>>>>>>>>>>
22369>>>>>>>>>>>>>        Function_Return sConnect
22370>>>>>>>>>>>>>    End_Function
22371>>>>>>>>>>>>>
22371>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
22371>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
22373>>>>>>>>>>>>>        String sConnect
22373>>>>>>>>>>>>>
22373>>>>>>>>>>>>>        Case Begin
22373>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
22375>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
22376>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22378>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22379>>>>>>>>>>>>>                End
22379>>>>>>>>>>>>>>
22379>>>>>>>>>>>>>                Case Break
22380>>>>>>>>>>>>>
22380>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
22383>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
22385>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
22386>>>>>>>>>>>>>                End
22386>>>>>>>>>>>>>>
22386>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
22389>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22390>>>>>>>>>>>>>                End
22390>>>>>>>>>>>>>>
22390>>>>>>>>>>>>>
22390>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22392>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22393>>>>>>>>>>>>>                End
22393>>>>>>>>>>>>>>
22393>>>>>>>>>>>>>                Case Break
22394>>>>>>>>>>>>>
22394>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
22397>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22398>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22400>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22401>>>>>>>>>>>>>                End
22401>>>>>>>>>>>>>>
22401>>>>>>>>>>>>>                Case Break
22402>>>>>>>>>>>>>
22402>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
22405>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22406>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22408>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22409>>>>>>>>>>>>>                End
22409>>>>>>>>>>>>>>
22409>>>>>>>>>>>>>                Case Break
22410>>>>>>>>>>>>>
22410>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
22413>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22414>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22416>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22417>>>>>>>>>>>>>                End
22417>>>>>>>>>>>>>>
22417>>>>>>>>>>>>>                Case Break
22418>>>>>>>>>>>>>
22418>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
22421>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22422>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22424>>>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22425>>>>>>>>>>>>>                End
22425>>>>>>>>>>>>>>
22425>>>>>>>>>>>>>                Case Break
22426>>>>>>>>>>>>>
22426>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
22429>>>>>>>>>>>>>                Break
22430>>>>>>>>>>>>>
22430>>>>>>>>>>>>>            Case Else
22430>>>>>>>>>>>>>                Move "" to sConnect
22431>>>>>>>>>>>>>        Case End
22431>>>>>>>>>>>>>
22431>>>>>>>>>>>>>        Function_Return sConnect
22432>>>>>>>>>>>>>    End_Function
22433>>>>>>>>>>>>>
22433>>>>>>>>>>>>>    // Use Base64
22433>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
22435>>>>>>>>>>>>>        String sRetval
22435>>>>>>>>>>>>>        Handle hoLoginEncryption
22435>>>>>>>>>>>>>
22435>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
22436>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
22437>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
22438>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
22439>>>>>>>>>>>>>          
22439>>>>>>>>>>>>>        Function_Return sRetval
22440>>>>>>>>>>>>>    End_Function
22441>>>>>>>>>>>>>
22441>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
22443>>>>>>>>>>>>>        String sRetval
22443>>>>>>>>>>>>>        Handle hoLoginEncryption
22443>>>>>>>>>>>>>
22443>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
22444>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
22445>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
22446>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
22447>>>>>>>>>>>>>
22447>>>>>>>>>>>>>        Function_Return sRetval
22448>>>>>>>>>>>>>    End_Function
22449>>>>>>>>>>>>>
22449>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
22449>>>>>>>>>>>>>    Function ApplicationPath Returns String
22451>>>>>>>>>>>>>        String sApplicationFileName sPath
22451>>>>>>>>>>>>>        Integer iNumChars iRetval
22451>>>>>>>>>>>>>
22451>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
22452>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
22453>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
22454>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
22455>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
22456>>>>>>>>>>>>>
22456>>>>>>>>>>>>>        Function_Return sPath
22457>>>>>>>>>>>>>    End_Function
22458>>>>>>>>>>>>>
22458>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
22458>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
22458>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
22458>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
22460>>>>>>>>>>>>>        Boolean bExists
22460>>>>>>>>>>>>>        Handle hoPaths hoIniFile
22460>>>>>>>>>>>>>        String[] asWorkSpaceFiles
22461>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
22461>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
22461>>>>>>>>>>>>>        
22461>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
22462>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
22463>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
22464>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
22465>>>>>>>>>>>>>        If (bExists = True) Begin
22467>>>>>>>>>>>>>            Function_Return sProgramsPath
22468>>>>>>>>>>>>>        End                      
22468>>>>>>>>>>>>>>
22468>>>>>>>>>>>>>    
22468>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
22469>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
22471>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
22472>>>>>>>>>>>>>        End                                              
22472>>>>>>>>>>>>>>
22472>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
22473>>>>>>>>>>>>>        
22473>>>>>>>>>>>>>        Move False to bExists
22474>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
22475>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
22476>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
22477>>>>>>>>>>>>>        Decrement iSize       
22478>>>>>>>>>>>>>        
22478>>>>>>>>>>>>>        For iCount from 0 to iSize
22484>>>>>>>>>>>>>>
22484>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
22485>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
22486>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
22487>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
22488>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
22494>>>>>>>>>>>>>>
22494>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
22495>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
22496>>>>>>>>>>>>>                // Check if there are more than one path specified;
22496>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
22497>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
22499>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
22500>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
22506>>>>>>>>>>>>>>
22506>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
22507>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
22508>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
22509>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
22510>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
22511>>>>>>>>>>>>>                        If (bExists = True) Begin
22513>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
22514>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
22515>>>>>>>>>>>>>                            Move iSize to iCount
22516>>>>>>>>>>>>>                        End                                                    
22516>>>>>>>>>>>>>>
22516>>>>>>>>>>>>>                    Loop
22517>>>>>>>>>>>>>>
22517>>>>>>>>>>>>>                End
22517>>>>>>>>>>>>>>
22517>>>>>>>>>>>>>                Else Begin
22518>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
22519>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
22520>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
22521>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
22522>>>>>>>>>>>>>                    If (bExists = True) Begin
22524>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
22525>>>>>>>>>>>>>                        Move iSize to iCount
22526>>>>>>>>>>>>>                    End                                                    
22526>>>>>>>>>>>>>>
22526>>>>>>>>>>>>>                End
22526>>>>>>>>>>>>>>
22526>>>>>>>>>>>>>            Loop
22527>>>>>>>>>>>>>>
22527>>>>>>>>>>>>>            If (bExists = False) Begin
22529>>>>>>>>>>>>>                Move "" to sPath    
22530>>>>>>>>>>>>>            End
22530>>>>>>>>>>>>>>
22530>>>>>>>>>>>>>            Send Destroy of hoIniFile          
22531>>>>>>>>>>>>>        Loop        
22532>>>>>>>>>>>>>>
22532>>>>>>>>>>>>>        Send Destroy of hoPaths
22533>>>>>>>>>>>>>        
22533>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
22533>>>>>>>>>>>>>        If (sPath = "") Begin
22535>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
22536>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
22537>>>>>>>>>>>>>        End                  
22537>>>>>>>>>>>>>>
22537>>>>>>>>>>>>>        
22537>>>>>>>>>>>>>        Function_Return sPath    
22538>>>>>>>>>>>>>    End_Function
22539>>>>>>>>>>>>>    
22539>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
22539>>>>>>>>>>>>>    // with one or more .ws file names.
22539>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
22539>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
22539>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
22539>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
22541>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
22543>>>>>>>>>>>>>        String sFile sHomePath sDirSep
22543>>>>>>>>>>>>>        Integer iCh iSize
22543>>>>>>>>>>>>>        Boolean bExists      
22543>>>>>>>>>>>>>        Handle hoIniFile 
22543>>>>>>>>>>>>>        
22543>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
22544>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
22545>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
22547>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
22548>>>>>>>>>>>>>        End                                              
22548>>>>>>>>>>>>>>
22548>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
22549>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
22550>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
22551>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
22552>>>>>>>>>>>>>        
22552>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
22552>>>>>>>>>>>>>        // read the name of the .ws file name.
22552>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
22553>>>>>>>>>>>>>        If (bExists = True) Begin
22555>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
22556>>>>>>>>>>>>>            If (iCh < 0) Begin
22558>>>>>>>>>>>>>                Function_Return asSWSFiles
22559>>>>>>>>>>>>>            End                                 
22559>>>>>>>>>>>>>>
22559>>>>>>>>>>>>>            
22559>>>>>>>>>>>>>            Repeat
22559>>>>>>>>>>>>>>
22559>>>>>>>>>>>>>                Readln channel iCh sFile
22561>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
22563>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
22564>>>>>>>>>>>>>                End
22564>>>>>>>>>>>>>>
22564>>>>>>>>>>>>>            Until (SeqEof = True)
22566>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
22567>>>>>>>>>>>>>            
22567>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
22568>>>>>>>>>>>>>            If (iSize <> 0) Begin
22570>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
22571>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
22571>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
22571>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
22572>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
22573>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
22574>>>>>>>>>>>>>                If (sFile <> "") Begin
22576>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
22577>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
22578>>>>>>>>>>>>>                    File_Exist sFile bExists
22579>>>>>>>>>>>>>                    If (bExists = True) Begin
22581>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
22582>>>>>>>>>>>>>                    End
22582>>>>>>>>>>>>>>
22582>>>>>>>>>>>>>                End
22582>>>>>>>>>>>>>>
22582>>>>>>>>>>>>>                Send Destroy of hoIniFile
22583>>>>>>>>>>>>>            End
22583>>>>>>>>>>>>>>
22583>>>>>>>>>>>>>        End
22583>>>>>>>>>>>>>>
22583>>>>>>>>>>>>>        
22583>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
22583>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
22585>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
22586>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
22587>>>>>>>>>>>>>            If (bExists = False) Begin
22589>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
22590>>>>>>>>>>>>>            End
22590>>>>>>>>>>>>>>
22590>>>>>>>>>>>>>        
22590>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
22591>>>>>>>>>>>>>            If (iCh < 0) Begin
22593>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
22594>>>>>>>>>>>>>            End                                 
22594>>>>>>>>>>>>>>
22594>>>>>>>>>>>>>            
22594>>>>>>>>>>>>>            Repeat
22594>>>>>>>>>>>>>>
22594>>>>>>>>>>>>>                Readln channel iCh sFile
22596>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
22598>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
22599>>>>>>>>>>>>>                End
22599>>>>>>>>>>>>>>
22599>>>>>>>>>>>>>            Until (SeqEof = True)
22601>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
22602>>>>>>>>>>>>>        End
22602>>>>>>>>>>>>>>
22602>>>>>>>>>>>>>        
22602>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
22603>>>>>>>>>>>>>    End_Function
22604>>>>>>>>>>>>>
22604>>>>>>>>>>>>>End_Class
22605>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
22605>>>>>>>>>>>Use vWin32fh.pkg
22605>>>>>>>>>>>
22605>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
22605>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
22605>>>>>>>>>>>    Use cConnectionDUF.pkg
Including file: cConnectionDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cConnectionDUF.pkg)
22605>>>>>>>>>>>>>// * Dummy class * that will only be used if DF 18.2 or less.
22605>>>>>>>>>>>>>//
22605>>>>>>>>>>>>>// The cConnection class is new to DF 19 and that DF 19 package/class
22605>>>>>>>>>>>>>// will be used automatically instead of this package
22605>>>>>>>>>>>>>// if the current DF version is 19 and up _and_ the class
22605>>>>>>>>>>>>>// has been instantianted in the cApplication object.
22605>>>>>>>>>>>>>//
22605>>>>>>>>>>>>>// If an object of the original cConnection class is placed in
22605>>>>>>>>>>>>>// the cApplication, that connection logic will be used instead
22605>>>>>>>>>>>>>// of the Database Update Framework's SQLConnections logic. Or more
22605>>>>>>>>>>>>>// correctly; "Managed Connection" settings will be read and applied
22605>>>>>>>>>>>>>// instead of those defined in the framework's SQLConnections.ini file.
22605>>>>>>>>>>>>>//
22605>>>>>>>>>>>>>Struct tConnection
22605>>>>>>>>>>>>>    String sId                // connection id
22605>>>>>>>>>>>>>    String sString            // server-string as added via the ini file
22605>>>>>>>>>>>>>    String sUID               // User Id
22605>>>>>>>>>>>>>    String sPWD               // non-encrypted password
22605>>>>>>>>>>>>>    Boolean bTrustedConnection // Trusted connection
22605>>>>>>>>>>>>>    Integer iOptions          // connection ID options (don't use)
22605>>>>>>>>>>>>>    String sDriver            // name of driver
22605>>>>>>>>>>>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
22605>>>>>>>>>>>>>    String sConnectionString  // Full connection string assembled from various strings
22605>>>>>>>>>>>>>    String sSection           // this is usually the section name as it appears
22605>>>>>>>>>>>>>                              // in the connections ini file (e.g., [Connection1])
22605>>>>>>>>>>>>>    Boolean bDisabled         // if set, this is not an active Id
22605>>>>>>>>>>>>>End_Struct
22605>>>>>>>>>>>>>
22605>>>>>>>>>>>>>
22605>>>>>>>>>>>>>Class cConnection is a cObject
22606>>>>>>>>>>>>>
22606>>>>>>>>>>>>>    Procedure Construct_Object
22608>>>>>>>>>>>>>        Forward Send Construct_Object
22610>>>>>>>>>>>>>
22610>>>>>>>>>>>>>    End_Procedure
22611>>>>>>>>>>>>>
22611>>>>>>>>>>>>>    Function ConnectionIdInfo Returns tConnection
22613>>>>>>>>>>>>>        tConnection Connection
22613>>>>>>>>>>>>>        tConnection Connection
22613>>>>>>>>>>>>>        Function_Return Connection
22614>>>>>>>>>>>>>    End_Function
22615>>>>>>>>>>>>>
22615>>>>>>>>>>>>>    Function IsConnectionIdLoggedIn Returns Boolean
22617>>>>>>>>>>>>>        Function_Return False
22618>>>>>>>>>>>>>    End_Function
22619>>>>>>>>>>>>>
22619>>>>>>>>>>>>>    Function LoginConnectionId Returns String
22621>>>>>>>>>>>>>        Function_Return ""
22622>>>>>>>>>>>>>    End_Function
22623>>>>>>>>>>>>>
22623>>>>>>>>>>>>>    // get array of managed connections across all drivers
22623>>>>>>>>>>>>>    // returns array of connections in tConnection.
22623>>>>>>>>>>>>>    Function ConnectionIDs Returns tConnection[]
22625>>>>>>>>>>>>>        tConnection[] Connections
22625>>>>>>>>>>>>>        tConnection[] Connections
22626>>>>>>>>>>>>>        Function_Return Connections
22627>>>>>>>>>>>>>    End_Function
22628>>>>>>>>>>>>>
22628>>>>>>>>>>>>>    Function ConnectionIdIndex String sConnectionID Returns Integer
22630>>>>>>>>>>>>>        Function_Return 0
22631>>>>>>>>>>>>>    End_Function
22632>>>>>>>>>>>>>
22632>>>>>>>>>>>>>    Function RedirectConnectionId String sConnectionID String sServer String sUserId String sPw Boolean bTrusted Boolean bKeepOpen Returns Boolean
22634>>>>>>>>>>>>>        Function_Return False
22635>>>>>>>>>>>>>    End_Function
22636>>>>>>>>>>>>>
22636>>>>>>>>>>>>>End_Class
22637>>>>>>>>>>>
22637>>>>>>>>>>>// We're making references to this object handle so we need it defined
22637>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
22637>>>>>>>>>>>
22637>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
22637>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
22638>>>>>>>>>>>
22638>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
22639>>>>>>>>>>>
22639>>>>>>>>>>>    Procedure Construct_Object
22641>>>>>>>>>>>        Forward Send Construct_Object
22643>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
22644>>>>>>>>>>>
22644>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
22645>>>>>>>>>>>
22645>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
22645>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
22645>>>>>>>>>>>        // methods to this class.
22645>>>>>>>>>>>        Property Boolean pbUseConnectionID True
22646>>>>>>>>>>>        Property Boolean pbToANSI          True
22647>>>>>>>>>>>        Property Boolean pbRecnum          True
22648>>>>>>>>>>>        Property Boolean pbCopyData        True
22649>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
22650>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
22651>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
22652>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
22653>>>>>>>>>>>
22653>>>>>>>>>>>        // Driver default value settings:
22653>>>>>>>>>>>        // Note: When the object is created the corresponding values
22653>>>>>>>>>>>        // from the driver .int files are read.
22653>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
22653>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
22654>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
22655>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
22656>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
22657>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
22658>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
22659>>>>>>>>>>>
22659>>>>>>>>>>>        // Driver "nullability" settings:
22659>>>>>>>>>>>        // Note: When the object is created the corresponding values
22659>>>>>>>>>>>        // from the driver .int files are read.
22659>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
22659>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
22660>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
22661>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
22662>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
22663>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
22664>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
22665>>>>>>>>>>>
22665>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
22665>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
22665>>>>>>>>>>>        //     driver interfaces.
22665>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
22665>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
22665>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
22666>>>>>>>>>>>
22666>>>>>>>>>>>    End_Procedure
22667>>>>>>>>>>>
22667>>>>>>>>>>>    Procedure End_Construct_Object
22669>>>>>>>>>>>        tSQLConnection SQLConnection
22669>>>>>>>>>>>        tSQLConnection SQLConnection
22669>>>>>>>>>>>
22669>>>>>>>>>>>        Forward Send End_Construct_Object
22671>>>>>>>>>>>
22671>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
22671>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
22672>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22673>>>>>>>>>>>    End_Procedure
22674>>>>>>>>>>>
22674>>>>>>>>>>>    // *** Properties ***
22674>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
22674>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
22674>>>>>>>>>>>    // merely here for conveniance.
22674>>>>>>>>>>>    //
22674>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
22674>>>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
22674>>>>>>>>>>>    // This struct property contains all the connection data.
22674>>>>>>>>>>>    //
22674>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
22676>>>>>>>>>>>        Boolean bOK
22676>>>>>>>>>>>
22676>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22677>>>>>>>>>>>
22677>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
22677>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
22679>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
22679>>>>>>>>>>>            Procedure_Return
22680>>>>>>>>>>>        End
22680>>>>>>>>>>>>
22680>>>>>>>>>>>
22680>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
22680>>>>>>>>>>>        // be logged in already and don't want to do it again.
22680>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
22682>>>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
22682>>>>>>>>>>>            // driver interfaces about the change & make a new login.
22682>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
22683>>>>>>>>>>>            If (bOK = False) Begin
22685>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
22686>>>>>>>>>>>>
22686>>>>>>>>>>>            End
22686>>>>>>>>>>>>
22686>>>>>>>>>>>        End
22686>>>>>>>>>>>>
22686>>>>>>>>>>>
22686>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
22686>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
22687>>>>>>>>>>>
22687>>>>>>>>>>>    End_Procedure
22688>>>>>>>>>>>
22688>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
22688>>>>>>>>>>>    // attempt to load the driver.
22688>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
22688>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
22690>>>>>>>>>>>        Boolean bOK
22690>>>>>>>>>>>
22690>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
22691>>>>>>>>>>>        If (bOK = False) Begin
22693>>>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
22694>>>>>>>>>>>        End
22694>>>>>>>>>>>>
22694>>>>>>>>>>>
22694>>>>>>>>>>>        Function_Return bOK
22695>>>>>>>>>>>    End_Function
22696>>>>>>>>>>>
22696>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
22696>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
22698>>>>>>>>>>>        String sAttributeValue
22698>>>>>>>>>>>        Integer iDriverID
22698>>>>>>>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
22698>>>>>>>>>>>
22698>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
22699>>>>>>>>>>>        If (bSQLDriver = False) Begin
22701>>>>>>>>>>>            Procedure_Return
22702>>>>>>>>>>>        End                                      
22702>>>>>>>>>>>>
22702>>>>>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
22703>>>>>>>>>>>        If (bIsMertechDriver = True) Begin
22705>>>>>>>>>>>            Procedure_Return
22706>>>>>>>>>>>        End
22706>>>>>>>>>>>>
22706>>>>>>>>>>>        
22706>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
22707>>>>>>>>>>>
22707>>>>>>>>>>>        // Driver default values for various data types:
22707>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
22710>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
22711>>>>>>>>>>>
22711>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
22714>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
22715>>>>>>>>>>>
22715>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
22718>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
22719>>>>>>>>>>>
22719>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
22722>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
22723>>>>>>>>>>>
22723>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
22726>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
22727>>>>>>>>>>>
22727>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
22730>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
22731>>>>>>>>>>>
22731>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
22731>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
22734>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
22735>>>>>>>>>>>
22735>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
22738>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
22739>>>>>>>>>>>
22739>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
22742>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
22743>>>>>>>>>>>
22743>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
22746>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
22747>>>>>>>>>>>
22747>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
22750>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
22751>>>>>>>>>>>
22751>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
22754>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
22755>>>>>>>>>>>
22755>>>>>>>>>>>    End_Procedure
22756>>>>>>>>>>>
22756>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
22758>>>>>>>>>>>        Boolean bOK bIsDaw bIsMertech
22758>>>>>>>>>>>        String sConnectionString
22758>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
22758>>>>>>>>>>>        Integer iDriverID
22758>>>>>>>>>>>
22758>>>>>>>>>>>        Move False to bOK
22759>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
22760>>>>>>>>>>>        If (bIsDaw = False) Begin
22762>>>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
22763>>>>>>>>>>>            If (bIsMertech = False) Begin
22765>>>>>>>>>>>                Function_Return False
22766>>>>>>>>>>>            End
22766>>>>>>>>>>>>
22766>>>>>>>>>>>        End
22766>>>>>>>>>>>>
22766>>>>>>>>>>>
22766>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
22767>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
22768>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
22769>>>>>>>>>>>        If (iDriverID = 0) Begin
22771>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
22772>>>>>>>>>>>            Function_Return False
22773>>>>>>>>>>>        End
22773>>>>>>>>>>>>
22773>>>>>>>>>>>
22773>>>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
22773>>>>>>>>>>>        If (bIsMertech = False) Begin
22775>>>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
22778>>>>>>>>>>>        End
22778>>>>>>>>>>>>
22778>>>>>>>>>>>
22778>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
22779>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
22780>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
22781>>>>>>>>>>>        Send Destroy   of hoDriver
22782>>>>>>>>>>>
22782>>>>>>>>>>>        Function_Return bOK
22783>>>>>>>>>>>    End_Function
22784>>>>>>>>>>>
22784>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
22786>>>>>>>>>>>        tSQLConnection SQLConnection
22786>>>>>>>>>>>        tSQLConnection SQLConnection
22786>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22787>>>>>>>>>>>        Function_Return SQLConnection
22788>>>>>>>>>>>    End_Function
22789>>>>>>>>>>>
22789>>>>>>>>>>>    Procedure Set psConnectionID String sValue
22791>>>>>>>>>>>        tSQLConnection SQLConnection
22791>>>>>>>>>>>        tSQLConnection SQLConnection
22791>>>>>>>>>>>
22791>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22792>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
22794>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
22795>>>>>>>>>>>        End
22795>>>>>>>>>>>>
22795>>>>>>>>>>>
22795>>>>>>>>>>>        // Else we might want to change the current connection ID
22795>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
22798>>>>>>>>>>>            Move False to Err
22799>>>>>>>>>>>            Logout SQLConnection.sDriverID
22800>>>>>>>>>>>            // This will also make a login to the new server.
22800>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
22801>>>>>>>>>>>        End
22801>>>>>>>>>>>>
22801>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22802>>>>>>>>>>>    End_Procedure
22803>>>>>>>>>>>
22803>>>>>>>>>>>    Function psConnectionID Returns String
22805>>>>>>>>>>>        tSQLConnection SQLConnection
22805>>>>>>>>>>>        tSQLConnection SQLConnection
22805>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22806>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
22807>>>>>>>>>>>    End_Function
22808>>>>>>>>>>>
22808>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
22808>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
22808>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
22808>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
22808>>>>>>>>>>>    Procedure Set psDriverID String sValue
22810>>>>>>>>>>>        tSQLConnection SQLConnection
22810>>>>>>>>>>>        tSQLConnection SQLConnection
22810>>>>>>>>>>>        Get pSQLConnection to SQLConnection
22811>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
22812>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22813>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
22815>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22816>>>>>>>>>>>        End
22816>>>>>>>>>>>>
22816>>>>>>>>>>>    End_Procedure
22817>>>>>>>>>>>
22817>>>>>>>>>>>    Function psDriverID Returns String
22819>>>>>>>>>>>        tSQLConnection SQLConnection
22819>>>>>>>>>>>        tSQLConnection SQLConnection
22819>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22820>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
22822>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
22823>>>>>>>>>>>        End
22823>>>>>>>>>>>>
22823>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
22824>>>>>>>>>>>    End_Function
22825>>>>>>>>>>>
22825>>>>>>>>>>>    Procedure Set psConnectionString String sValue
22827>>>>>>>>>>>        tSQLConnection SQLConnection
22827>>>>>>>>>>>        tSQLConnection SQLConnection
22827>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22828>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
22829>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22830>>>>>>>>>>>    End_Procedure
22831>>>>>>>>>>>
22831>>>>>>>>>>>    Function psConnectionString Returns String
22833>>>>>>>>>>>        tSQLConnection SQLConnection
22833>>>>>>>>>>>        tSQLConnection SQLConnection
22833>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22834>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
22835>>>>>>>>>>>    End_Function
22836>>>>>>>>>>>
22836>>>>>>>>>>>    Procedure Set psServer String sValue
22838>>>>>>>>>>>        tSQLConnection SQLConnection
22838>>>>>>>>>>>        tSQLConnection SQLConnection
22838>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22839>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
22840>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22841>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22842>>>>>>>>>>>    End_Procedure
22843>>>>>>>>>>>
22843>>>>>>>>>>>    Function psServer Returns String
22845>>>>>>>>>>>        tSQLConnection SQLConnection
22845>>>>>>>>>>>        tSQLConnection SQLConnection
22845>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22846>>>>>>>>>>>        Function_Return SQLConnection.sServer
22847>>>>>>>>>>>    End_Function
22848>>>>>>>>>>>
22848>>>>>>>>>>>    Procedure Set psDatabase String sValue
22850>>>>>>>>>>>        tSQLConnection SQLConnection
22850>>>>>>>>>>>        tSQLConnection SQLConnection
22850>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22851>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
22852>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22853>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22854>>>>>>>>>>>    End_Procedure
22855>>>>>>>>>>>
22855>>>>>>>>>>>    Function psDatabase Returns String
22857>>>>>>>>>>>        tSQLConnection SQLConnection
22857>>>>>>>>>>>        tSQLConnection SQLConnection
22857>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22858>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
22859>>>>>>>>>>>    End_Function
22860>>>>>>>>>>>
22860>>>>>>>>>>>    Procedure Set psUserID String sValue
22862>>>>>>>>>>>        tSQLConnection SQLConnection
22862>>>>>>>>>>>        tSQLConnection SQLConnection
22862>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22863>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
22864>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22865>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22866>>>>>>>>>>>    End_Procedure
22867>>>>>>>>>>>
22867>>>>>>>>>>>    Function psUserID Returns String
22869>>>>>>>>>>>        tSQLConnection SQLConnection
22869>>>>>>>>>>>        tSQLConnection SQLConnection
22869>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22870>>>>>>>>>>>        Function_Return SQLConnection.sUserID
22871>>>>>>>>>>>    End_Function
22872>>>>>>>>>>>
22872>>>>>>>>>>>    // This is the uncrypted password
22872>>>>>>>>>>>    Procedure Set psPassword String sValue
22874>>>>>>>>>>>        tSQLConnection SQLConnection
22874>>>>>>>>>>>        tSQLConnection SQLConnection
22874>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22875>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
22876>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22877>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22878>>>>>>>>>>>    End_Procedure
22879>>>>>>>>>>>
22879>>>>>>>>>>>    Function psPassword Returns String
22881>>>>>>>>>>>        tSQLConnection SQLConnection
22881>>>>>>>>>>>        tSQLConnection SQLConnection
22881>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22882>>>>>>>>>>>        Function_Return SQLConnection.sPassword
22883>>>>>>>>>>>    End_Function
22884>>>>>>>>>>>
22884>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
22886>>>>>>>>>>>        tSQLConnection SQLConnection
22886>>>>>>>>>>>        tSQLConnection SQLConnection
22886>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22887>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
22888>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22889>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22890>>>>>>>>>>>    End_Procedure
22891>>>>>>>>>>>
22891>>>>>>>>>>>    Function pbTrusted Returns Boolean
22893>>>>>>>>>>>        tSQLConnection SQLConnection
22893>>>>>>>>>>>        tSQLConnection SQLConnection
22893>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22894>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
22895>>>>>>>>>>>    End_Function
22896>>>>>>>>>>>
22896>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
22896>>>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
22896>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
22896>>>>>>>>>>>    //     the central pSQLConnection "hub".
22896>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
22898>>>>>>>>>>>        tSQLConnection SQLConnection
22898>>>>>>>>>>>        tSQLConnection SQLConnection
22898>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22899>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
22900>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22901>>>>>>>>>>>    End_Procedure
22902>>>>>>>>>>>
22902>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
22904>>>>>>>>>>>        tSQLConnection SQLConnection
22904>>>>>>>>>>>        tSQLConnection SQLConnection
22904>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22905>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
22906>>>>>>>>>>>    End_Function
22907>>>>>>>>>>>
22907>>>>>>>>>>>    Procedure Set piDbType Integer iValue
22909>>>>>>>>>>>        tSQLConnection SQLConnection
22909>>>>>>>>>>>        tSQLConnection SQLConnection
22909>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22910>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
22911>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22912>>>>>>>>>>>    End_Procedure
22913>>>>>>>>>>>
22913>>>>>>>>>>>    Function piDbType Returns Integer
22915>>>>>>>>>>>        tSQLConnection SQLConnection
22915>>>>>>>>>>>        tSQLConnection SQLConnection
22915>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22916>>>>>>>>>>>        Function_Return SQLConnection.iDbType
22917>>>>>>>>>>>    End_Function
22918>>>>>>>>>>>
22918>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
22920>>>>>>>>>>>        tSQLConnection SQLConnection
22920>>>>>>>>>>>        tSQLConnection SQLConnection
22920>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22921>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
22922>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22923>>>>>>>>>>>    End_Procedure
22924>>>>>>>>>>>
22924>>>>>>>>>>>    Function psBaseTableSpace Returns String
22926>>>>>>>>>>>        tSQLConnection SQLConnection
22926>>>>>>>>>>>        tSQLConnection SQLConnection
22926>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22927>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
22928>>>>>>>>>>>    End_Function
22929>>>>>>>>>>>
22929>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
22931>>>>>>>>>>>        tSQLConnection SQLConnection
22931>>>>>>>>>>>        tSQLConnection SQLConnection
22931>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22932>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
22933>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22934>>>>>>>>>>>    End_Procedure
22935>>>>>>>>>>>
22935>>>>>>>>>>>    Function psIndexTableSpace Returns String
22937>>>>>>>>>>>        tSQLConnection SQLConnection
22937>>>>>>>>>>>        tSQLConnection SQLConnection
22937>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22938>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
22939>>>>>>>>>>>    End_Function
22940>>>>>>>>>>>
22940>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
22942>>>>>>>>>>>        tSQLConnection SQLConnection
22942>>>>>>>>>>>        tSQLConnection SQLConnection
22942>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22943>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
22944>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22945>>>>>>>>>>>    End_Procedure
22946>>>>>>>>>>>
22946>>>>>>>>>>>    Function psLongTableSpace Returns String
22948>>>>>>>>>>>        tSQLConnection SQLConnection
22948>>>>>>>>>>>        tSQLConnection SQLConnection
22948>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22949>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
22950>>>>>>>>>>>    End_Function
22951>>>>>>>>>>>
22951>>>>>>>>>>>    Procedure Set psSchema String sValue
22953>>>>>>>>>>>        tSQLConnection SQLConnection
22953>>>>>>>>>>>        tSQLConnection SQLConnection
22953>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22954>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
22955>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22956>>>>>>>>>>>    End_Procedure
22957>>>>>>>>>>>
22957>>>>>>>>>>>    Function psSchema Returns String
22959>>>>>>>>>>>        tSQLConnection SQLConnection
22959>>>>>>>>>>>        tSQLConnection SQLConnection
22959>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22960>>>>>>>>>>>        Function_Return SQLConnection.sSchema
22961>>>>>>>>>>>    End_Function
22962>>>>>>>>>>>
22962>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
22964>>>>>>>>>>>        tSQLConnection SQLConnection
22964>>>>>>>>>>>        tSQLConnection SQLConnection
22964>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22965>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
22966>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22967>>>>>>>>>>>    End_Procedure
22968>>>>>>>>>>>
22968>>>>>>>>>>>    Function pbEnabled Returns Boolean
22970>>>>>>>>>>>        tSQLConnection SQLConnection
22970>>>>>>>>>>>        tSQLConnection SQLConnection
22970>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22971>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
22972>>>>>>>>>>>    End_Function
22973>>>>>>>>>>>
22973>>>>>>>>>>>
22973>>>>>>>>>>>    // ************************************
22973>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
22975>>>>>>>>>>>        tSQLConnection SQLConnection
22975>>>>>>>>>>>        tSQLConnection SQLConnection
22975>>>>>>>>>>>
22975>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
22975>>>>>>>>>>>        // deferr reading SQL connection values until later.
22975>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
22977>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
22977>>>>>>>>>>>            If (ghoConnection > 0) Begin
22979>>>>>>>>>>>                Get ReadcConnections to SQLConnection
22980>>>>>>>>>>>            End
22980>>>>>>>>>>>>
22980>>>>>>>>>>>
22980>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
22980>>>>>>>>>>>            // object is used.
22980>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
22982>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
22983>>>>>>>>>>>            End
22983>>>>>>>>>>>>
22983>>>>>>>>>>>        End
22983>>>>>>>>>>>>
22983>>>>>>>>>>>
22983>>>>>>>>>>>        Function_Return SQLConnection
22984>>>>>>>>>>>    End_Function
22985>>>>>>>>>>>
22985>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
22985>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
22987>>>>>>>>>>>        tConnection Connection
22987>>>>>>>>>>>        tConnection Connection
22987>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22987>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22987>>>>>>>>>>>        Integer iRetval iDbType
22987>>>>>>>>>>>        Boolean bOK bConnected
22987>>>>>>>>>>>        String sConnectionID
22987>>>>>>>>>>>
22987>>>>>>>>>>>
22987>>>>>>>>>>>        Function_Return SQLConnection
22988>>>>>>>>>>>    End_Function
22989>>>>>>>>>>>
22989>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
22989>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
22989>>>>>>>>>>>    // connection id for a particular driver.
22989>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
22989>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
22989>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
22989>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
22989>>>>>>>>>>>    // connections of the DAW cConnect class.
22989>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
22991>>>>>>>>>>>        tConnection[] ConnIdArray
22991>>>>>>>>>>>        tConnection[] ConnIdArray
22992>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
22992>>>>>>>>>>>        Boolean bEnabled bFound
22992>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
22992>>>>>>>>>>>
22992>>>>>>>>>>>        Move False to bFound
22993>>>>>>>>>>>        If (ghoConnection > 0) Begin
22995>>>>>>>>>>>
22995>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
22995>>>>>>>>>>>            Get psDriverID to sDriverID
22996>>>>>>>>>>>
22996>>>>>>>>>>>            Move 0 to iConnectionIDCounter
22997>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
22997>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
22998>>>>>>>>>>>            Decrement iSize
22999>>>>>>>>>>>            For iCount from 0 to iSize
23005>>>>>>>>>>>>
23005>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
23006>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
23007>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
23008>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
23008>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
23008>>>>>>>>>>>                If (sConnectionID = "") Begin
23010>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
23011>>>>>>>>>>>                End
23011>>>>>>>>>>>>
23011>>>>>>>>>>>                Else Begin
23012>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
23014>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
23015>>>>>>>>>>>                    End
23015>>>>>>>>>>>>
23015>>>>>>>>>>>                End
23015>>>>>>>>>>>>
23015>>>>>>>>>>>
23015>>>>>>>>>>>                If (bFound = True) Begin
23017>>>>>>>>>>>                    Increment iConnectionIDCounter
23018>>>>>>>>>>>                End
23018>>>>>>>>>>>>
23018>>>>>>>>>>>            Loop
23019>>>>>>>>>>>>
23019>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
23020>>>>>>>>>>>            If (bFound = True) Begin
23022>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
23023>>>>>>>>>>>            End
23023>>>>>>>>>>>>
23023>>>>>>>>>>>        End
23023>>>>>>>>>>>>
23023>>>>>>>>>>>
23023>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
23023>>>>>>>>>>>        // but no DFConn.ini record has been created.
23023>>>>>>>>>>>        If (iSize = -1) Begin
23025>>>>>>>>>>>            Move True to bFound
23026>>>>>>>>>>>        End
23026>>>>>>>>>>>>
23026>>>>>>>>>>>
23026>>>>>>>>>>>        Function_Return bFound
23027>>>>>>>>>>>    End_Function
23028>>>>>>>>>>>
23028>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
23028>>>>>>>>>>>    // create a connection to the server.
23028>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
23030>>>>>>>>>>>        String sPath sFileName
23030>>>>>>>>>>>        Boolean bExists bActive
23030>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
23030>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
23031>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
23031>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
23031>>>>>>>>>>>        Handle hoIniFile
23031>>>>>>>>>>>        Integer iSize iCount iRetval
23031>>>>>>>>>>>
23031>>>>>>>>>>>        Get psIniFilePath to sPath
23032>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
23033>>>>>>>>>>>        If (sPath = "") Begin
23035>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
23036>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
23037>>>>>>>>>>>        End
23037>>>>>>>>>>>>
23037>>>>>>>>>>>        Get vFolderFormat sPath to sPath
23038>>>>>>>>>>>        Get psIniFileName to sFileName
23039>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
23040>>>>>>>>>>>
23040>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
23041>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
23042>>>>>>>>>>>        If (iSize = 0) Begin
23044>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
23044>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
23044>>>>>>>>>>>            // in the cApplication object.
23044>>>>>>>>>>>            Get pSQLConnection to SQLConnection
23045>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
23047>>>>>>>>>>>                Function_Return SQLConnectionEmpty
23048>>>>>>>>>>>            End
23048>>>>>>>>>>>>
23048>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
23049>>>>>>>>>>>            Move 1 to iSize
23050>>>>>>>>>>>        End
23050>>>>>>>>>>>>
23050>>>>>>>>>>>
23050>>>>>>>>>>>        Move False to bActive
23051>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
23051>>>>>>>>>>>        Decrement iSize
23052>>>>>>>>>>>        For iCount from 0 to iSize
23058>>>>>>>>>>>>
23058>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
23059>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
23061>>>>>>>>>>>                Move True to bActive
23062>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
23063>>>>>>>>>>>            End
23063>>>>>>>>>>>>
23063>>>>>>>>>>>        Loop
23064>>>>>>>>>>>>
23064>>>>>>>>>>>
23064>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
23064>>>>>>>>>>>        If (bActive = False) Begin
23066>>>>>>>>>>>            Function_Return SQLConnectionEmpty
23067>>>>>>>>>>>        End
23067>>>>>>>>>>>>
23067>>>>>>>>>>>
23067>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
23068>>>>>>>>>>>
23068>>>>>>>>>>>        Set pSQLConnection to SQLConnection
23069>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
23070>>>>>>>>>>>
23070>>>>>>>>>>>        Function_Return SQLConnection
23071>>>>>>>>>>>    End_Function
23072>>>>>>>>>>>
23072>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
23074>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
23075>>>>>>>>>>>    End_Procedure
23076>>>>>>>>>>>
23076>>>>>>>>>>>    Function psIniFilePath Returns String
23078>>>>>>>>>>>        String sRetval
23078>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
23079>>>>>>>>>>>        Function_Return sRetval
23080>>>>>>>>>>>    End_Function
23081>>>>>>>>>>>
23081>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
23083>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
23084>>>>>>>>>>>    End_Procedure
23085>>>>>>>>>>>
23085>>>>>>>>>>>    Function psIniFileName Returns String
23087>>>>>>>>>>>        String sRetval
23087>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
23088>>>>>>>>>>>        Function_Return sRetval
23089>>>>>>>>>>>    End_Function
23090>>>>>>>>>>>
23090>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
23092>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
23093>>>>>>>>>>>    End_Procedure
23094>>>>>>>>>>>
23094>>>>>>>>>>>    Function psIniSectionName Returns String
23096>>>>>>>>>>>        String sRetval
23096>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
23097>>>>>>>>>>>        Function_Return sRetval
23098>>>>>>>>>>>    End_Function
23099>>>>>>>>>>>
23099>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
23101>>>>>>>>>>>        Handle ho
23101>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23102>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
23103>>>>>>>>>>>    End_Procedure
23104>>>>>>>>>>>
23104>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
23106>>>>>>>>>>>        Handle ho
23106>>>>>>>>>>>        String sRetval
23106>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23107>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
23108>>>>>>>>>>>        Function_Return sRetval
23109>>>>>>>>>>>    End_Function
23110>>>>>>>>>>>
23110>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
23112>>>>>>>>>>>        Handle ho
23112>>>>>>>>>>>        Boolean bRetval
23112>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23113>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
23114>>>>>>>>>>>        Function_Return bRetval
23115>>>>>>>>>>>    End_Function
23116>>>>>>>>>>>
23116>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
23118>>>>>>>>>>>        Handle ho
23118>>>>>>>>>>>        Boolean bRetval
23118>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23119>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
23120>>>>>>>>>>>        Function_Return bRetval
23121>>>>>>>>>>>    End_Function
23122>>>>>>>>>>>
23122>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
23124>>>>>>>>>>>        Handle ho
23124>>>>>>>>>>>        String sRetval
23124>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23125>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
23126>>>>>>>>>>>        Function_Return sRetval
23127>>>>>>>>>>>    End_Function
23128>>>>>>>>>>>
23128>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
23130>>>>>>>>>>>        Handle ho
23130>>>>>>>>>>>        String sRetval
23130>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23131>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
23132>>>>>>>>>>>        Function_Return sRetval
23133>>>>>>>>>>>    End_Function
23134>>>>>>>>>>>
23134>>>>>>>>>>>    // *** Main Connection Message ***
23134>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
23136>>>>>>>>>>>        Handle hoDriver
23136>>>>>>>>>>>        String sConnectionString sError
23136>>>>>>>>>>>        Boolean bLoginSuccessful
23136>>>>>>>>>>>
23136>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
23137>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
23138>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
23139>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
23140>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
23142>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
23143>>>>>>>>>>>>
23143>>>>>>>>>>>            If (bExitProgram = True) Begin
23145>>>>>>>>>>>                Send Exit_Application
23146>>>>>>>>>>>            End
23146>>>>>>>>>>>>
23146>>>>>>>>>>>        End
23146>>>>>>>>>>>>
23146>>>>>>>>>>>        Send Destroy of hoDriver
23147>>>>>>>>>>>    End_Procedure
23148>>>>>>>>>>>
23148>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
23150>>>>>>>>>>>        Integer iRetval
23150>>>>>>>>>>>        Handle hoCLI
23150>>>>>>>>>>>        String sDriverID
23150>>>>>>>>>>>
23150>>>>>>>>>>>        Get psDriverID to sDriverID
23151>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
23152>>>>>>>>>>>        If (hoCLI <> 0) Begin
23154>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
23155>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
23156>>>>>>>>>>>            Send Destroy of hoCLI
23157>>>>>>>>>>>        End
23157>>>>>>>>>>>>
23157>>>>>>>>>>>
23157>>>>>>>>>>>        Function_Return iRetval
23158>>>>>>>>>>>    End_Function
23159>>>>>>>>>>>
23159>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
23161>>>>>>>>>>>        tSQLConnection SQLConnection
23161>>>>>>>>>>>        tSQLConnection SQLConnection
23161>>>>>>>>>>>
23161>>>>>>>>>>>        Set psDriverID to sDriverID
23162>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
23163>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
23164>>>>>>>>>>>    End_Procedure
23165>>>>>>>>>>>
23165>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
23165>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
23165>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
23165>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
23165>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
23165>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
23165>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
23165>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
23167>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
23167>>>>>>>>>>>        Handle hoCLI
23167>>>>>>>>>>>        String sID
23167>>>>>>>>>>>
23167>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
23169>>>>>>>>>>>            Procedure_Return
23170>>>>>>>>>>>        End
23170>>>>>>>>>>>>
23170>>>>>>>>>>>
23170>>>>>>>>>>>        Move 0 to iResult
23171>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23172>>>>>>>>>>>        If (hoCLI <> 0) Begin
23174>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
23175>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
23176>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
23179>>>>>>>>>>>            Decrement iNumConn
23180>>>>>>>>>>>            For iConn from 0 to iNumConn
23186>>>>>>>>>>>>
23186>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
23189>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
23191>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
23192>>>>>>>>>>>                End
23192>>>>>>>>>>>>
23192>>>>>>>>>>>            Loop
23193>>>>>>>>>>>>
23193>>>>>>>>>>>            Send Destroy of hoCLI
23194>>>>>>>>>>>        End
23194>>>>>>>>>>>>
23194>>>>>>>>>>>
23194>>>>>>>>>>>    End_Procedure
23195>>>>>>>>>>>
23195>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
23197>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
23197>>>>>>>>>>>        Handle hoCLI
23197>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
23197>>>>>>>>>>>        tSQLConnection SQLConnection
23197>>>>>>>>>>>        tSQLConnection SQLConnection
23197>>>>>>>>>>>        Boolean bTrusted
23197>>>>>>>>>>>
23197>>>>>>>>>>>        Move 0 to iResult
23198>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23199>>>>>>>>>>>        If (hoCLI <> 0) Begin
23201>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
23202>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
23203>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
23206>>>>>>>>>>>            Decrement iNumConn
23207>>>>>>>>>>>            For iConn from 0 to iNumConn
23213>>>>>>>>>>>>
23213>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
23216>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
23218>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
23219>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
23222>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
23225>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
23226>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
23229>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
23230>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
23231>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
23232>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
23233>>>>>>>>>>>
23233>>>>>>>>>>>                    Case Begin
23233>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
23235>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
23236>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
23237>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
23238>>>>>>>>>>>                            Case Break
23239>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
23242>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23243>>>>>>>>>>>                            Case Break
23244>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
23247>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23248>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
23250>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
23251>>>>>>>>>>>                            End
23251>>>>>>>>>>>>
23251>>>>>>>>>>>                            Case Break
23252>>>>>>>>>>>                        Case (sDriverID = SQLFLEX)
23255>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23256>>>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
23257>>>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23259>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23260>>>>>>>>>>>                            End
23260>>>>>>>>>>>>
23260>>>>>>>>>>>                            Else Begin
23261>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23262>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23263>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23264>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23265>>>>>>>>>>>                            End
23265>>>>>>>>>>>>
23265>>>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
23266>>>>>>>>>>>                            Case Break
23267>>>>>>>>>>>                        Case (sDriverID = MDSMySQL)
23270>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23271>>>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
23272>>>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23274>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23275>>>>>>>>>>>                            End
23275>>>>>>>>>>>>
23275>>>>>>>>>>>                            Else Begin
23276>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23277>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23278>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23279>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23280>>>>>>>>>>>                            End
23280>>>>>>>>>>>>
23280>>>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
23281>>>>>>>>>>>                            Case Break
23282>>>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
23285>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23286>>>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
23287>>>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23289>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23290>>>>>>>>>>>                            End
23290>>>>>>>>>>>>
23290>>>>>>>>>>>                            Else Begin
23291>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23292>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23293>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23294>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23295>>>>>>>>>>>                            End
23295>>>>>>>>>>>>
23295>>>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
23296>>>>>>>>>>>                            Case Break
23297>>>>>>>>>>>
23297>>>>>>>>>>>                        Case (sDriverID = ORAFLEX)
23300>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
23301>>>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
23302>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23303>>>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
23305>>>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
23306>>>>>>>>>>>                            End
23306>>>>>>>>>>>>
23306>>>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23308>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23309>>>>>>>>>>>                            End
23309>>>>>>>>>>>>
23309>>>>>>>>>>>                            Else Begin
23310>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23311>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23312>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23313>>>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23314>>>>>>>>>>>                            End
23314>>>>>>>>>>>>
23314>>>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
23315>>>>>>>>>>>                            Case Break
23316>>>>>>>>>>>                        Case Else
23316>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
23317>>>>>>>>>>>>
23317>>>>>>>>>>>                            Case Break
23318>>>>>>>>>>>                    Case End
23318>>>>>>>>>>>                End
23318>>>>>>>>>>>>
23318>>>>>>>>>>>            Loop
23319>>>>>>>>>>>>
23319>>>>>>>>>>>            Send Destroy of hoCLI
23320>>>>>>>>>>>        End
23320>>>>>>>>>>>>
23320>>>>>>>>>>>
23320>>>>>>>>>>>        Function_Return SQLConnection
23321>>>>>>>>>>>    End_Function
23322>>>>>>>>>>>
23322>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
23324>>>>>>>>>>>        String  sCurrentDriver
23324>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
23324>>>>>>>>>>>
23324>>>>>>>>>>>        Move 0 to iDriver
23325>>>>>>>>>>>        Move 0 to iCount
23326>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
23329>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
23335>>>>>>>>>>>>
23335>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
23338>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
23340>>>>>>>>>>>                Function_Return iCount
23341>>>>>>>>>>>            End
23341>>>>>>>>>>>>
23341>>>>>>>>>>>        Loop
23342>>>>>>>>>>>>
23342>>>>>>>>>>>
23342>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
23342>>>>>>>>>>>        If (iDriver = 0) Begin
23344>>>>>>>>>>>            Move 0 to LastErr
23345>>>>>>>>>>>            Load_Driver sDriverID
23346>>>>>>>>>>>            // If driver could not be loaded.
23346>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
23348>>>>>>>>>>>                Move -1 to iCount
23349>>>>>>>>>>>            End
23349>>>>>>>>>>>>
23349>>>>>>>>>>>        End
23349>>>>>>>>>>>>
23349>>>>>>>>>>>        Function_Return iCount
23350>>>>>>>>>>>    End_Function
23351>>>>>>>>>>>
23351>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
23351>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
23353>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
23353>>>>>>>>>>>        Boolean bTrusted bSilent
23353>>>>>>>>>>>        Integer iRetval
23353>>>>>>>>>>>
23353>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
23354>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
23355>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
23356>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
23357>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
23358>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
23359>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
23360>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
23361>>>>>>>>>>>
23361>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
23362>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
23362>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
23363>>>>>>>>>>>    End_Procedure
23364>>>>>>>>>>>
23364>>>>>>>>>>>    // Called when the object is constructed.
23364>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
23364>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
23364>>>>>>>>>>>    // the database is needed.
23364>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
23366>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
23366>>>>>>>>>>>        Integer iDriver iRetval
23366>>>>>>>>>>>        Handle hoCLI
23366>>>>>>>>>>>        Boolean bOK bSilent bMertechDriver
23366>>>>>>>>>>>
23366>>>>>>>>>>>        Get pbSilentLogin      to bSilent
23367>>>>>>>>>>>        Get psConnectionID     to sConnectionID
23368>>>>>>>>>>>        Get psConnectionString to sConnectionString
23369>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
23369>>>>>>>>>>>        Get psDriverID to sDriverID
23370>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23371>>>>>>>>>>>        If (bOK = False) Begin
23373>>>>>>>>>>>            Function_Return False
23374>>>>>>>>>>>        End
23374>>>>>>>>>>>>
23374>>>>>>>>>>>
23374>>>>>>>>>>>        // Mertech drivers can't use connection ID's.
23374>>>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
23375>>>>>>>>>>>        If (bMertechDriver = True) Begin
23377>>>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
23377>>>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
23377>>>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
23378>>>>>>>>>>>            Function_Return (hoCLI <> 0)
23379>>>>>>>>>>>        End
23379>>>>>>>>>>>>
23379>>>>>>>>>>>
23379>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
23380>>>>>>>>>>>        // If driver not loaded; load it.
23380>>>>>>>>>>>        If (iDriver = 0) Begin
23382>>>>>>>>>>>            Load_Driver sDriverID
23383>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
23384>>>>>>>>>>>        End
23384>>>>>>>>>>>>
23384>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
23384>>>>>>>>>>>        If (iDriver = 0) Begin
23386>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
23387>>>>>>>>>>>>
23387>>>>>>>>>>>            Function_Return False
23388>>>>>>>>>>>        End           
23388>>>>>>>>>>>>
23388>>>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
23391>>>>>>>>>>>        
23391>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23392>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
23393>>>>>>>>>>>        // Delete the connection first; in case it exists
23393>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
23394>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
23395>>>>>>>>>>>        Send Destroy of hoCLI
23396>>>>>>>>>>>
23396>>>>>>>>>>>        Function_Return (iRetval = 0)
23397>>>>>>>>>>>    End_Function
23398>>>>>>>>>>>
23398>>>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
23398>>>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
23398>>>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
23398>>>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
23398>>>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
23398>>>>>>>>>>>
23398>>>>>>>>>>>
23398>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
23400>>>>>>>>>>>        Boolean bOK bMertechDriver
23400>>>>>>>>>>>
23400>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
23401>>>>>>>>>>>
23401>>>>>>>>>>>        If (bOK = False) Begin
23403>>>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
23404>>>>>>>>>>>        End
23404>>>>>>>>>>>>
23404>>>>>>>>>>>
23404>>>>>>>>>>>        If (bOK = False) Begin
23406>>>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
23407>>>>>>>>>>>            If (bMertechDriver = True) Begin
23409>>>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
23410>>>>>>>>>>>>
23410>>>>>>>>>>>            End
23410>>>>>>>>>>>>
23410>>>>>>>>>>>            Else Begin
23411>>>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
23412>>>>>>>>>>>>
23412>>>>>>>>>>>            End
23412>>>>>>>>>>>>
23412>>>>>>>>>>>            Function_Return False
23413>>>>>>>>>>>        End
23413>>>>>>>>>>>>
23413>>>>>>>>>>>
23413>>>>>>>>>>>        Function_Return True
23414>>>>>>>>>>>    End_Function
23415>>>>>>>>>>>
23415>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
23417>>>>>>>>>>>        Boolean bOK
23417>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
23418>>>>>>>>>>>        Function_Return bOK
23419>>>>>>>>>>>    End_Function
23420>>>>>>>>>>>
23420>>>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
23422>>>>>>>>>>>        Boolean bOK
23422>>>>>>>>>>>        Move False to bOK
23423>>>>>>>>>>>//        #IFDEF Is$MertechDrivers
23423>>>>>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
23424>>>>>>>>>>>//        #ENDIF
23424>>>>>>>>>>>        Function_Return bOK
23425>>>>>>>>>>>    End_Function
23426>>>>>>>>>>>
23426>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
23428>>>>>>>>>>>        Handle hoIniFile
23428>>>>>>>>>>>        String sConnect
23428>>>>>>>>>>>
23428>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
23429>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
23430>>>>>>>>>>>
23430>>>>>>>>>>>        Function_Return sConnect
23431>>>>>>>>>>>    End_Function
23432>>>>>>>>>>>
23432>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
23432>>>>>>>>>>>    // Pass a complete driver connection string
23432>>>>>>>>>>>    // Returns the following as a struct:
23432>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
23432>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
23432>>>>>>>>>>>    //
23432>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
23434>>>>>>>>>>>        tSQLConnection SQLConnection
23434>>>>>>>>>>>        tSQLConnection SQLConnection
23434>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
23434>>>>>>>>>>>        Boolean bTrusted bSilent bOK
23434>>>>>>>>>>>        Integer iPos
23434>>>>>>>>>>>
23434>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23435>>>>>>>>>>>        If (bOK = False) Begin
23437>>>>>>>>>>>            Function_Return SQLConnection
23438>>>>>>>>>>>        End
23438>>>>>>>>>>>>
23438>>>>>>>>>>>
23438>>>>>>>>>>>        Move False to bTrusted
23439>>>>>>>>>>>        Move False to bSilent
23440>>>>>>>>>>>
23440>>>>>>>>>>>        Case Begin
23440>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
23442>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
23443>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23444>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23445>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23446>>>>>>>>>>>                If (bTrusted = False) Begin
23448>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23449>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23450>>>>>>>>>>>                End
23450>>>>>>>>>>>>
23450>>>>>>>>>>>                Case Break
23451>>>>>>>>>>>
23451>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
23454>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
23456>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
23457>>>>>>>>>>>                End
23457>>>>>>>>>>>>
23457>>>>>>>>>>>                Else Begin
23458>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23459>>>>>>>>>>>                End
23459>>>>>>>>>>>>
23459>>>>>>>>>>>
23459>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23460>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23461>>>>>>>>>>>                If (bTrusted = False) Begin
23463>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23464>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23465>>>>>>>>>>>                End
23465>>>>>>>>>>>>
23465>>>>>>>>>>>                Case Break
23466>>>>>>>>>>>
23466>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
23469>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23470>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23471>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23472>>>>>>>>>>>                Case Break
23473>>>>>>>>>>>
23473>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
23476>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
23477>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23478>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23479>>>>>>>>>>>                If (bTrusted = False) Begin
23481>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23482>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23483>>>>>>>>>>>                End
23483>>>>>>>>>>>>
23483>>>>>>>>>>>                Case Break
23484>>>>>>>>>>>
23484>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
23487>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23488>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23489>>>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
23491>>>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
23492>>>>>>>>>>>                End
23492>>>>>>>>>>>>
23492>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23493>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23494>>>>>>>>>>>                Case Break
23495>>>>>>>>>>>
23495>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
23498>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23499>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23500>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23501>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23502>>>>>>>>>>>                Case Break
23503>>>>>>>>>>>
23503>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
23506>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23507>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23508>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23509>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23510>>>>>>>>>>>                Case Break
23511>>>>>>>>>>>
23511>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
23514>>>>>>>>>>>                Break
23515>>>>>>>>>>>        Case End
23515>>>>>>>>>>>
23515>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
23516>>>>>>>>>>>
23516>>>>>>>>>>>        // bSilent?
23516>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
23517>>>>>>>>>>>        If (iPos = 0) Begin
23519>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
23520>>>>>>>>>>>        End
23520>>>>>>>>>>>>
23520>>>>>>>>>>>        If (iPos = 0) Begin
23522>>>>>>>>>>>            Move "0"                                                            to sValue
23523>>>>>>>>>>>        End
23523>>>>>>>>>>>>
23523>>>>>>>>>>>        Else Begin
23524>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
23525>>>>>>>>>>>        End
23525>>>>>>>>>>>>
23525>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
23526>>>>>>>>>>>
23526>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
23527>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
23528>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
23529>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
23530>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
23531>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
23532>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
23533>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
23534>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
23535>>>>>>>>>>>
23535>>>>>>>>>>>        Function_Return SQLConnection
23536>>>>>>>>>>>    End_Function
23537>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
23537>>>>>>>>>>>>
23537>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
23539>>>>>>>>>>>>    Integer iStart iEnd
23539>>>>>>>>>>>>    String sRetval
23539>>>>>>>>>>>>
23539>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
23540>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
23541>>>>>>>>>>>>    If (iStart = 0) Begin
23543>>>>>>>>>>>>        Function_Return ""
23544>>>>>>>>>>>>    End
23544>>>>>>>>>>>>>
23544>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
23545>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
23546>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
23548>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
23549>>>>>>>>>>>>    End
23549>>>>>>>>>>>>>
23549>>>>>>>>>>>>    Else Begin
23550>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
23551>>>>>>>>>>>>    End
23551>>>>>>>>>>>>>
23551>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
23553>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
23554>>>>>>>>>>>>        Decrement iEnd
23555>>>>>>>>>>>>    End
23555>>>>>>>>>>>>>
23555>>>>>>>>>>>>    If (iEnd <> 0) Begin
23557>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
23558>>>>>>>>>>>>    End
23558>>>>>>>>>>>>>
23558>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
23559>>>>>>>>>>>>
23559>>>>>>>>>>>>    Function_Return (Trim(sRetval))
23560>>>>>>>>>>>>End_Function
23561>>>>>>>>>>>>
23561>>>>>>>>>>>>
23561>>>>>>>>>>>
23561>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
23561>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
23563>>>>>>>>>>>        Handle ho
23563>>>>>>>>>>>        Integer iIndex
23563>>>>>>>>>>>        Boolean bRetval bOK
23563>>>>>>>>>>>        tSQLConnection SQLConnection
23563>>>>>>>>>>>        tSQLConnection SQLConnection
23563>>>>>>>>>>>
23563>>>>>>>>>>>        Get pSQLConnection to SQLConnection
23564>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23565>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
23566>>>>>>>>>>>        If (iIndex = -1) Begin
23568>>>>>>>>>>>            Function_Return False
23569>>>>>>>>>>>        End
23569>>>>>>>>>>>>
23569>>>>>>>>>>>
23569>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
23570>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
23571>>>>>>>>>>>        If (ghoConnection > 0) Begin
23573>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
23574>>>>>>>>>>>            If (iIndex <> -1) Begin
23576>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
23577>>>>>>>>>>>            End
23577>>>>>>>>>>>>
23577>>>>>>>>>>>        End
23577>>>>>>>>>>>>
23577>>>>>>>>>>>
23577>>>>>>>>>>>        Function_Return bRetval
23578>>>>>>>>>>>    End_Function
23579>>>>>>>>>>>
23579>>>>>>>>>>>End_Class
23580>>>>>>>>>Use vWin32fh.pkg
23580>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout20\DfAbout.pkg)
23580>>>>>>>>>>>Use LanguageText.pkg
23580>>>>>>>>>>>Use Windows.pkg
23580>>>>>>>>>>>Use Dfclient.pkg
Including file: Dfclient.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfclient.pkg)
23580>>>>>>>>>>>>>Use Windows.pkg
23580>>>>>>>>>>>>>Use DfPanel.pkg
Including file: Dfpanel.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfpanel.pkg)
23580>>>>>>>>>>>>>>>Use Windows.pkg
23580>>>>>>>>>>>>>>>Use dfcolor.pkg
23580>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>//  Used when help object makes a request to the object requesting help.
23580>>>>>>>>>>>>>>>Use HelpSystemConstants.pkg
23580>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>Enumeration_List
23580>>>>>>>>>>>>>>>    Define amTop
23580>>>>>>>>>>>>>>>    Define amBottom
23580>>>>>>>>>>>>>>>    Define amLeft
23580>>>>>>>>>>>>>>>    Define amRight
23580>>>>>>>>>>>>>>>End_Enumeration_List
23580>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>Use DFAStBar.pkg  // df application status bar
Including file: Dfastbar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfastbar.pkg)
23580>>>>>>>>>>>>>>>>>Register_Procedure Add_Border_Object
23580>>>>>>>>>>>>>>>>>Register_Procedure Remove_Border_Object
23580>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>Use DFStatBr.pkg
Including file: Dfstatbr.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfstatbr.pkg)
23580>>>>>>>>>>>>>>>>>>>Use windows.pkg
23580>>>>>>>>>>>>>>>>>>>Use CommCtrl.pkg
23580>>>>>>>>>>>>>>>>>>>Use WinGDI.pkg
23580>>>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>>>
23580>>>>>>>>>>>>>>>>>>>Class BasicStatusBar is a dfBaseList
23581>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23583>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23585>>>>>>>>>>>>>>>>>>>        Property Integer Private.Simple_State False
23586>>>>>>>>>>>>>>>>>>>        
23586>>>>>>>>>>>>>>>>>>>        Property String  Private.Simple_Value ''
23587>>>>>>>>>>>>>>>>>>>        
23587>>>>>>>>>>>>>>>>>>>        Property Integer Tooltips_State False // this does nothing
23588>>>>>>>>>>>>>>>>>>>        Set Scroll_Bar_Visible_State to False
23589>>>>>>>>>>>>>>>>>>>        Set Border_Style             to Border_None
23590>>>>>>>>>>>>>>>>>>>        Set External_class_Name "cObsoleteBasicStatusBar" to "msctls_statusbar32"
23591>>>>>>>>>>>>>>>>>>>        Set Color to clDefault
23592>>>>>>>>>>>>>>>>>>>    End_Procedure
23593>>>>>>>>>>>>>>>>>>>    
23593>>>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
23595>>>>>>>>>>>>>>>>>>>        //If (Tooltips_State(self)) Set Window_Style To SBT_TOOLTIPS True
23595>>>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
23597>>>>>>>>>>>>>>>>>>>    End_Procedure
23598>>>>>>>>>>>>>>>>>>>    
23598>>>>>>>>>>>>>>>>>>>    Procedure Set Simple_State Integer bState
23600>>>>>>>>>>>>>>>>>>>        Handle hWnd
23600>>>>>>>>>>>>>>>>>>>        Set Private.Simple_state to bState
23601>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23602>>>>>>>>>>>>>>>>>>>        If hWnd ;            Send Windows_Message SB_SIMPLE bState 0
23605>>>>>>>>>>>>>>>>>>>    End_Procedure
23606>>>>>>>>>>>>>>>>>>>    
23606>>>>>>>>>>>>>>>>>>>    Function Simple_State Returns Integer
23608>>>>>>>>>>>>>>>>>>>        Function_Return (Private.Simple_state(Self))
23609>>>>>>>>>>>>>>>>>>>    End_Function
23610>>>>>>>>>>>>>>>>>>>    
23610>>>>>>>>>>>>>>>>>>>    Procedure Set Simple_Value String sValue
23612>>>>>>>>>>>>>>>>>>>        Integer iVoid
23612>>>>>>>>>>>>>>>>>>>        Handle hWnd
23612>>>>>>>>>>>>>>>>>>>        WString wsValue
23612>>>>>>>>>>>>>>>>>>>        
23612>>>>>>>>>>>>>>>>>>>        Set Private.Simple_Value to sValue
23613>>>>>>>>>>>>>>>>>>>        
23613>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23614>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23616>>>>>>>>>>>>>>>>>>>            Append sValue ( Character(0) )
23617>>>>>>>>>>>>>>>>>>>            Move sValue to wsValue
23618>>>>>>>>>>>>>>>>>>>            
23618>>>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SETTEXT (255 + sbNORMAL) (AddressOf(wsValue))
23619>>>>>>>>>>>>>>>>>>>        End
23619>>>>>>>>>>>>>>>>>>>>
23619>>>>>>>>>>>>>>>>>>>        Set Simple_State to True
23620>>>>>>>>>>>>>>>>>>>    End_Procedure
23621>>>>>>>>>>>>>>>>>>>    
23621>>>>>>>>>>>>>>>>>>>    Function Simple_Value Returns String
23623>>>>>>>>>>>>>>>>>>>        Function_Return (private.Simple_value(Self))
23624>>>>>>>>>>>>>>>>>>>    End_Function
23625>>>>>>>>>>>>>>>>>>>    
23625>>>>>>>>>>>>>>>>>>>    Procedure Activate
23627>>>>>>>>>>>>>>>>>>>    End_Procedure
23628>>>>>>>>>>>>>>>>>>>    
23628>>>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer iState
23630>>>>>>>>>>>>>>>>>>>        Handle hWnd
23630>>>>>>>>>>>>>>>>>>>        Get Window_handle to hWnd
23631>>>>>>>>>>>>>>>>>>>        Forward Send Page_Object iState
23633>>>>>>>>>>>>>>>>>>>        If (iState and hWnd = 0) ;            Send DoRestructure
23636>>>>>>>>>>>>>>>>>>>    End_Procedure
23637>>>>>>>>>>>>>>>>>>>    
23637>>>>>>>>>>>>>>>>>>>    Procedure Page Integer iState
23639>>>>>>>>>>>>>>>>>>>        Forward Send Page iState
23641>>>>>>>>>>>>>>>>>>>        If (iState=1) Begin
23643>>>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SETBKCOLOR 0 (Color(Self))
23644>>>>>>>>>>>>>>>>>>>        End
23644>>>>>>>>>>>>>>>>>>>>
23644>>>>>>>>>>>>>>>>>>>    End_Procedure
23645>>>>>>>>>>>>>>>>>>>    
23645>>>>>>>>>>>>>>>>>>>    Procedure DoRestructure
23647>>>>>>>>>>>>>>>>>>>        Integer iLoop icItems iWidth icWidth iRetVal
23647>>>>>>>>>>>>>>>>>>>        Handle hWnd
23647>>>>>>>>>>>>>>>>>>>        Integer[] aItems
23648>>>>>>>>>>>>>>>>>>>        
23648>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23649>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23651>>>>>>>>>>>>>>>>>>>            
23651>>>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SIMPLE (Simple_State(Self)) 0
23652>>>>>>>>>>>>>>>>>>>            Set Simple_Value to (Simple_Value(Self))
23653>>>>>>>>>>>>>>>>>>>            
23653>>>>>>>>>>>>>>>>>>>            Get Item_Count to icItems
23654>>>>>>>>>>>>>>>>>>>            
23654>>>>>>>>>>>>>>>>>>>            For iLoop from 1 to (icItems -1)
23660>>>>>>>>>>>>>>>>>>>>
23660>>>>>>>>>>>>>>>>>>>                Get Message (iLoop -1) to iWidth
23661>>>>>>>>>>>>>>>>>>>                Move (icWidth + iWidth) to icWidth
23662>>>>>>>>>>>>>>>>>>>                Move (icWidth) to aItems[iLoop - 1]
23663>>>>>>>>>>>>>>>>>>>                
23663>>>>>>>>>>>>>>>>>>>                Set Value (iLoop -1) to (Value(Self, iLoop -1))
23664>>>>>>>>>>>>>>>>>>>            Loop
23665>>>>>>>>>>>>>>>>>>>>
23665>>>>>>>>>>>>>>>>>>>            // Now make the last item 'spring' to the end
23665>>>>>>>>>>>>>>>>>>>            Move -1 to aItems[icItems - 1]
23666>>>>>>>>>>>>>>>>>>>                        
23666>>>>>>>>>>>>>>>>>>>            Move (SendMessage(hWnd, SB_SETPARTS, icItems, AddressOf(aItems))) to iRetVal
23667>>>>>>>>>>>>>>>>>>>            For iLoop from 0 to (icItems -1)
23673>>>>>>>>>>>>>>>>>>>>
23673>>>>>>>>>>>>>>>>>>>                Set Value iLoop to (Value(Self, iLoop))
23674>>>>>>>>>>>>>>>>>>>            Loop
23675>>>>>>>>>>>>>>>>>>>>
23675>>>>>>>>>>>>>>>>>>>            
23675>>>>>>>>>>>>>>>>>>>        End
23675>>>>>>>>>>>>>>>>>>>>
23675>>>>>>>>>>>>>>>>>>>    End_Procedure
23676>>>>>>>>>>>>>>>>>>>    
23676>>>>>>>>>>>>>>>>>>>    Procedure Add_Item Integer iItemWidth String sValue // this is obsolete
23678>>>>>>>>>>>>>>>>>>>        Integer iRetVal icItems
23678>>>>>>>>>>>>>>>>>>>        Handle hWnd
23678>>>>>>>>>>>>>>>>>>>        
23678>>>>>>>>>>>>>>>>>>>        Forward Send Add_Item iItemWidth sValue
23680>>>>>>>>>>>>>>>>>>>        Get Item_Count to icItems
23681>>>>>>>>>>>>>>>>>>>        Set Value (icItems -1) to sValue
23682>>>>>>>>>>>>>>>>>>>        If (Window_Handle(Self)) ;            Send DoRestructure
23685>>>>>>>>>>>>>>>>>>>        Set Current_item to (icItems -1)
23686>>>>>>>>>>>>>>>>>>>    End_Procedure
23687>>>>>>>>>>>>>>>>>>>    
23687>>>>>>>>>>>>>>>>>>>    Procedure AddPane Integer iItemWidth String sValue Integer iStyle
23689>>>>>>>>>>>>>>>>>>>        Integer iRetVal icItem
23689>>>>>>>>>>>>>>>>>>>        Handle hWnd
23689>>>>>>>>>>>>>>>>>>>        
23689>>>>>>>>>>>>>>>>>>>        Send Add_Item iItemWidth sValue
23690>>>>>>>>>>>>>>>>>>>        Get Item_Count to icItem
23691>>>>>>>>>>>>>>>>>>>        Set Value (icItem -1) to sValue
23692>>>>>>>>>>>>>>>>>>>        Set Aux_Value (icItem -1) to iStyle
23693>>>>>>>>>>>>>>>>>>>        If (Window_Handle(Self)) ;            Send DoRestructure
23696>>>>>>>>>>>>>>>>>>>    End_Procedure
23697>>>>>>>>>>>>>>>>>>>    
23697>>>>>>>>>>>>>>>>>>>    Procedure AutoSizeLocate
23699>>>>>>>>>>>>>>>>>>>        Integer iSize iRetVal
23699>>>>>>>>>>>>>>>>>>>        Handle hWnd
23699>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23700>>>>>>>>>>>>>>>>>>>        Delegate Get GuiSize to iSize
23702>>>>>>>>>>>>>>>>>>>        If hWnd ;            Move (SendMessage(hWnd, WM_SIZE, 0, iSize)) to iRetVal
23705>>>>>>>>>>>>>>>>>>>    End_Procedure
23706>>>>>>>>>>>>>>>>>>>    
23706>>>>>>>>>>>>>>>>>>>    Procedure Set Item_Display_Style Integer iItem Integer iStyle  // this is obsolete, Use PaneStyle
23708>>>>>>>>>>>>>>>>>>>        If (num_arguments = 2) ;            Set Aux_Value iItem to iStyle
23711>>>>>>>>>>>>>>>>>>>        Else ;            Set Aux_Value (current_item(Self)) to iItem //iStyle passed as arg1
23713>>>>>>>>>>>>>>>>>>>    End_Procedure
23714>>>>>>>>>>>>>>>>>>>    
23714>>>>>>>>>>>>>>>>>>>    Function Item_Display_Style Integer iItem Returns Integer // this is obsolete, use PaneStyle
23716>>>>>>>>>>>>>>>>>>>        Function_Return (Aux_value(Self, iItem))
23717>>>>>>>>>>>>>>>>>>>    End_Function
23718>>>>>>>>>>>>>>>>>>>    
23718>>>>>>>>>>>>>>>>>>>    Procedure Set Value Integer iItem String sValue
23720>>>>>>>>>>>>>>>>>>>        Handle hWnd
23720>>>>>>>>>>>>>>>>>>>        Integer iRetVal iTextStyle iVoid
23720>>>>>>>>>>>>>>>>>>>        String sNull
23720>>>>>>>>>>>>>>>>>>>        WString wsValue
23720>>>>>>>>>>>>>>>>>>>        
23720>>>>>>>>>>>>>>>>>>>        Forward Set Value iItem to sValue
23722>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23723>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23725>>>>>>>>>>>>>>>>>>>            Get Item_Display_Style iItem to iTextStyle
23726>>>>>>>>>>>>>>>>>>>            Append sValue ( Character(0) )
23727>>>>>>>>>>>>>>>>>>>            Move sValue to wsValue
23728>>>>>>>>>>>>>>>>>>>            Move (SendMessage(hWnd, SB_SETTEXT, iItem + iTextStyle, AddressOf(wsValue))) to iRetVal
23729>>>>>>>>>>>>>>>>>>>        End
23729>>>>>>>>>>>>>>>>>>>>
23729>>>>>>>>>>>>>>>>>>>        Set Simple_State to False
23730>>>>>>>>>>>>>>>>>>>    End_Procedure
23731>>>>>>>>>>>>>>>>>>>    
23731>>>>>>>>>>>>>>>>>>>    Function IsSimpleMode Returns Integer
23733>>>>>>>>>>>>>>>>>>>        Function_Return (WindowsMessage(SB_ISSIMPLE, 0, 0))
23734>>>>>>>>>>>>>>>>>>>    End_Function
23735>>>>>>>>>>>>>>>>>>>    
23735>>>>>>>>>>>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
23737>>>>>>>>>>>>>>>>>>>        Integer iVoid iCode
23737>>>>>>>>>>>>>>>>>>>        Longptr iPane
23737>>>>>>>>>>>>>>>>>>>        tWinNmMouse NmMouse
23737>>>>>>>>>>>>>>>>>>>        tWinNmMouse NmMouse
23737>>>>>>>>>>>>>>>>>>>        
23737>>>>>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(NmMouse), lParam, SizeOfType(tWinNmMouse))) to iVoid
23738>>>>>>>>>>>>>>>>>>>        
23738>>>>>>>>>>>>>>>>>>>        Move NmMouse.hdr.code   to iCode
23739>>>>>>>>>>>>>>>>>>>        Move NmMouse.dwItemSpec to iPane
23740>>>>>>>>>>>>>>>>>>>        
23740>>>>>>>>>>>>>>>>>>>        If (iCode = SBN_SIMPLEMODECHANGE) ;            Send OnSimpleModeChange
23743>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_CLICK) ;            Send OnClick            iPane
23747>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_DBLCLK) ;            Send OnDoubleClick      iPane
23751>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_RCLICK) ;            Send OnRightClick       iPane
23755>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_RDBLCLK) ;            Send OnDoubleRightClick iPane
23759>>>>>>>>>>>>>>>>>>>    End_Procedure
23760>>>>>>>>>>>>>>>>>>>    
23760>>>>>>>>>>>>>>>>>>>    //  This needs to be chagned to return the real GUISize of the status bar
23760>>>>>>>>>>>>>>>>>>>    //  by making API calls.
23760>>>>>>>>>>>>>>>>>>>    //
23760>>>>>>>>>>>>>>>>>>>    Function GuiSize Returns Integer
23762>>>>>>>>>>>>>>>>>>>        Handle hWnd
23762>>>>>>>>>>>>>>>>>>>        Integer cy cx iVoid
23762>>>>>>>>>>>>>>>>>>>        tWinRect Rect
23762>>>>>>>>>>>>>>>>>>>        tWinRect Rect
23762>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23763>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23765>>>>>>>>>>>>>>>>>>>            Move (GetWindowRect(hWnd, AddressOf(Rect))) to iVoid
23766>>>>>>>>>>>>>>>>>>>            Move (Rect.right - Rect.left) to cx
23767>>>>>>>>>>>>>>>>>>>            Move (Rect.bottom - Rect.top) to cy
23768>>>>>>>>>>>>>>>>>>>        End
23768>>>>>>>>>>>>>>>>>>>>
23768>>>>>>>>>>>>>>>>>>>        Else Begin
23769>>>>>>>>>>>>>>>>>>>            Move 25 to cy
23770>>>>>>>>>>>>>>>>>>>            Move 19 to cx
23771>>>>>>>>>>>>>>>>>>>        End
23771>>>>>>>>>>>>>>>>>>>>
23771>>>>>>>>>>>>>>>>>>>        Function_Return ( cy*65536 + cx )
23772>>>>>>>>>>>>>>>>>>>    End_Function
23773>>>>>>>>>>>>>>>>>>>    
23773>>>>>>>>>>>>>>>>>>>    Function PaneTextWidth WString sText Returns Integer
23775>>>>>>>>>>>>>>>>>>>        Handle hWnd hDC
23775>>>>>>>>>>>>>>>>>>>        Integer bOK
23775>>>>>>>>>>>>>>>>>>>        tWinPoint Point
23775>>>>>>>>>>>>>>>>>>>        tWinPoint Point
23775>>>>>>>>>>>>>>>>>>>        
23775>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23776>>>>>>>>>>>>>>>>>>>        Move (GetDC(hWnd)) to hDC
23777>>>>>>>>>>>>>>>>>>>        
23777>>>>>>>>>>>>>>>>>>>        Move (GetTextExtentW(hDC, AddressOf(sText), length(sText), AddressOf(Point))) to bOk
23778>>>>>>>>>>>>>>>>>>>        
23778>>>>>>>>>>>>>>>>>>>        Move (ReleaseDC(hWnd, hDC)) to hDC
23779>>>>>>>>>>>>>>>>>>>        
23779>>>>>>>>>>>>>>>>>>>        Function_Return Point.x
23780>>>>>>>>>>>>>>>>>>>    End_Function
23781>>>>>>>>>>>>>>>>>>>    
23781>>>>>>>>>>>>>>>>>>>    Procedure Set PaneWidth Integer iPane Integer cxPane
23783>>>>>>>>>>>>>>>>>>>        Set Message iPane to cxPane
23784>>>>>>>>>>>>>>>>>>>    End_Procedure
23785>>>>>>>>>>>>>>>>>>>    
23785>>>>>>>>>>>>>>>>>>>    Function PaneWidth Integer iPane Returns Integer
23787>>>>>>>>>>>>>>>>>>>        Function_Return (Message(Self,iPane))
23788>>>>>>>>>>>>>>>>>>>    End_Function
23789>>>>>>>>>>>>>>>>>>>    
23789>>>>>>>>>>>>>>>>>>>    Procedure Set PaneStyle Integer iPane Integer iStyle
23791>>>>>>>>>>>>>>>>>>>        Set Aux_Value iPane to iStyle
23792>>>>>>>>>>>>>>>>>>>    End_Procedure
23793>>>>>>>>>>>>>>>>>>>    
23793>>>>>>>>>>>>>>>>>>>    Function PaneStyle Integer iPane Returns Integer
23795>>>>>>>>>>>>>>>>>>>        Function_Return (Aux_Value(Self,iPane))
23796>>>>>>>>>>>>>>>>>>>    End_Function
23797>>>>>>>>>>>>>>>>>>>    
23797>>>>>>>>>>>>>>>>>>>    Procedure Set PaneText Integer iPane String sText
23799>>>>>>>>>>>>>>>>>>>        Set Value iPane to sText
23800>>>>>>>>>>>>>>>>>>>    End_Procedure
23801>>>>>>>>>>>>>>>>>>>    
23801>>>>>>>>>>>>>>>>>>>    Function PaneText Integer iPane Returns String
23803>>>>>>>>>>>>>>>>>>>        Function_Return (Value(Self,iPane))
23804>>>>>>>>>>>>>>>>>>>    End_Function
23805>>>>>>>>>>>>>>>>>>>    
23805>>>>>>>>>>>>>>>>>>>    Function PaneCount Returns Integer
23807>>>>>>>>>>>>>>>>>>>        Function_Return (Item_Count(Self))
23808>>>>>>>>>>>>>>>>>>>    End_Function
23809>>>>>>>>>>>>>>>>>>>    
23809>>>>>>>>>>>>>>>>>>>    Procedure OnClick Longptr iPane
23811>>>>>>>>>>>>>>>>>>>    End_Procedure
23812>>>>>>>>>>>>>>>>>>>    
23812>>>>>>>>>>>>>>>>>>>    Procedure OnDoubleClick Longptr iPane
23814>>>>>>>>>>>>>>>>>>>    End_Procedure
23815>>>>>>>>>>>>>>>>>>>    
23815>>>>>>>>>>>>>>>>>>>    Procedure OnRightClick Longptr iPane
23817>>>>>>>>>>>>>>>>>>>    End_Procedure
23818>>>>>>>>>>>>>>>>>>>    
23818>>>>>>>>>>>>>>>>>>>    Procedure OnDoubleRightClick Longptr iPane
23820>>>>>>>>>>>>>>>>>>>    End_Procedure
23821>>>>>>>>>>>>>>>>>>>    
23821>>>>>>>>>>>>>>>>>>>    Procedure OnSimpleModeChange
23823>>>>>>>>>>>>>>>>>>>    End_Procedure
23824>>>>>>>>>>>>>>>>>>>End_Class
23825>>>>>>>>>>>>>>>>>>>
23825>>>>>>>>>>>>>>>>>
23825>>>>>>>>>>>>>>>>>Class AppStatusBar is a BasicStatusBar
23826>>>>>>>>>>>>>>>>>    
23826>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23828>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23830>>>>>>>>>>>>>>>>>        Property Integer Status_Help_Item 0
23831>>>>>>>>>>>>>>>>>        Property Integer Menu_Simple_State TRUE
23832>>>>>>>>>>>>>>>>>        
23832>>>>>>>>>>>>>>>>>        // SET s/b private, Get is public
23832>>>>>>>>>>>>>>>>>        Property Integer Menu_status_State False // MUST start false
23833>>>>>>>>>>>>>>>>>        
23833>>>>>>>>>>>>>>>>>        Property Integer Old_Simple_State  false
23834>>>>>>>>>>>>>>>>>        
23834>>>>>>>>>>>>>>>>>        Property String  Old_Status_Value  ''
23835>>>>>>>>>>>>>>>>>        
23835>>>>>>>>>>>>>>>>>        Set Popup_State         To TRUE
23836>>>>>>>>>>>>>>>>>        Set Attach_Parent_State To TRUE
23837>>>>>>>>>>>>>>>>>        // register status-bar with container
23837>>>>>>>>>>>>>>>>>        Delegate Set StatusBar_id To self
23839>>>>>>>>>>>>>>>>>    End_Procedure
23840>>>>>>>>>>>>>>>>>    
23840>>>>>>>>>>>>>>>>>    Procedure Set Status_Help_Value String sHelp
23842>>>>>>>>>>>>>>>>>        Integer iPart
23842>>>>>>>>>>>>>>>>>        Get Status_Help_Item To iPart
23843>>>>>>>>>>>>>>>>>        Set Value iPart to sHelp
23844>>>>>>>>>>>>>>>>>    End_Procedure
23845>>>>>>>>>>>>>>>>>    
23845>>>>>>>>>>>>>>>>>    Function Status_Help_Value Returns String
23847>>>>>>>>>>>>>>>>>        Integer iPart
23847>>>>>>>>>>>>>>>>>        String sHelp
23847>>>>>>>>>>>>>>>>>        Get Status_Help_Item To iPart
23848>>>>>>>>>>>>>>>>>        Get Value iPart To sHelp
23849>>>>>>>>>>>>>>>>>        Function_Return sHelp
23850>>>>>>>>>>>>>>>>>    End_Procedure
23851>>>>>>>>>>>>>>>>>    
23851>>>>>>>>>>>>>>>>>    Procedure Initialize_Menu
23853>>>>>>>>>>>>>>>>>        Integer iState OldState
23853>>>>>>>>>>>>>>>>>        If Not (Menu_Status_state(self)) Begin
23855>>>>>>>>>>>>>>>>>            Get Simple_State to OldState
23856>>>>>>>>>>>>>>>>>            Set Old_Simple_State to OldState
23857>>>>>>>>>>>>>>>>>            If OldState ;                Set Old_Status_Value to (Simple_Value(self))
23860>>>>>>>>>>>>>>>>>            Else ;                Set Old_Status_Value to (Status_Help_Value(self))
23862>>>>>>>>>>>>>>>>>            Set Simple_State to (Menu_Simple_State(self))
23863>>>>>>>>>>>>>>>>>            Set Menu_Status_State to TRUE
23864>>>>>>>>>>>>>>>>>        End
23864>>>>>>>>>>>>>>>>>>
23864>>>>>>>>>>>>>>>>>    End_Procedure
23865>>>>>>>>>>>>>>>>>    
23865>>>>>>>>>>>>>>>>>    Procedure Exit_Menu
23867>>>>>>>>>>>>>>>>>        Integer OldState
23867>>>>>>>>>>>>>>>>>        String OldVal
23867>>>>>>>>>>>>>>>>>        If (Menu_Status_state(self)) Begin
23869>>>>>>>>>>>>>>>>>            Get Old_Simple_State to OldState
23870>>>>>>>>>>>>>>>>>            Set Simple_State     to OldState
23871>>>>>>>>>>>>>>>>>            Get old_status_Value to oldVal
23872>>>>>>>>>>>>>>>>>            If OldState ;                Set Simple_Value to OldVal
23875>>>>>>>>>>>>>>>>>            Else ;                Set Status_Help_Value to OldVal
23877>>>>>>>>>>>>>>>>>            Set Menu_Status_State to FALSE
23878>>>>>>>>>>>>>>>>>        End
23878>>>>>>>>>>>>>>>>>>
23878>>>>>>>>>>>>>>>>>    End_Procedure
23879>>>>>>>>>>>>>>>>>    
23879>>>>>>>>>>>>>>>>>    Procedure Show_Status_Help String sHelp
23881>>>>>>>>>>>>>>>>>        Integer iState
23881>>>>>>>>>>>>>>>>>        Get Simple_State to iState
23882>>>>>>>>>>>>>>>>>        If not iState ;            Set Status_Help_Value to sHelp
23885>>>>>>>>>>>>>>>>>        Else ;            Set Simple_Value      to sHelp
23887>>>>>>>>>>>>>>>>>    End_Procedure
23888>>>>>>>>>>>>>>>>>    
23888>>>>>>>>>>>>>>>>>    Function Current_Status_Help Returns String
23890>>>>>>>>>>>>>>>>>        Integer iState
23890>>>>>>>>>>>>>>>>>        String sHelp
23890>>>>>>>>>>>>>>>>>        Get Simple_State to iState
23891>>>>>>>>>>>>>>>>>        If not iState ;            Get Status_Help_Value to sHelp
23894>>>>>>>>>>>>>>>>>        Else ;            Get Simple_Value      to sHelp
23896>>>>>>>>>>>>>>>>>        Function_Return sHelp
23897>>>>>>>>>>>>>>>>>    End_Function
23898>>>>>>>>>>>>>>>>>    
23898>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer bShow
23900>>>>>>>>>>>>>>>>>        Integer hoClient
23900>>>>>>>>>>>>>>>>>        Handle hHndl
23900>>>>>>>>>>>>>>>>>        Get Window_Handle to hHndl
23901>>>>>>>>>>>>>>>>>        Forward Send Page_Object bShow
23903>>>>>>>>>>>>>>>>>        If (bShow AND hHndl=0) Begin
23905>>>>>>>>>>>>>>>>>            Delegate Get Client_Id To hoClient
23907>>>>>>>>>>>>>>>>>            If hoClient ;                Send Add_Border_Object to hoClient self amBOTTOM
23910>>>>>>>>>>>>>>>>>        End
23910>>>>>>>>>>>>>>>>>>
23910>>>>>>>>>>>>>>>>>    End_Procedure
23911>>>>>>>>>>>>>>>>>    
23911>>>>>>>>>>>>>>>>>    Procedure Deactivating
23913>>>>>>>>>>>>>>>>>        Integer hoClient
23913>>>>>>>>>>>>>>>>>        Delegate Get Client_Id To hoClient
23915>>>>>>>>>>>>>>>>>        Forward Send DeActivating
23917>>>>>>>>>>>>>>>>>        If hoClient ;            Send Remove_Border_Object to hoClient self amBOTTOM
23920>>>>>>>>>>>>>>>>>    End_Procedure
23921>>>>>>>>>>>>>>>>>    
23921>>>>>>>>>>>>>>>>>End_Class
23922>>>>>>>>>>>>>>>Use DFABtBar.pkg  // df application button bar
Including file: Dfabtbar.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfabtbar.pkg)
23922>>>>>>>>>>>>>>>>>Register_Procedure Add_Border_Object
23922>>>>>>>>>>>>>>>>>Register_Procedure Remove_Border_Object
23922>>>>>>>>>>>>>>>>>
23922>>>>>>>>>>>>>>>>>Use Windows.pkg
23922>>>>>>>>>>>>>>>>>
23922>>>>>>>>>>>>>>>>>Class AppToolBar is a BasicToolBar
23923>>>>>>>>>>>>>>>>>    
23923>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23925>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23927>>>>>>>>>>>>>>>>>        Set Scope_State         to True
23928>>>>>>>>>>>>>>>>>        Set Attach_Parent_State to True
23929>>>>>>>>>>>>>>>>>        Set Popup_State         to True
23930>>>>>>>>>>>>>>>>>        Set Client_Area_State   to True
23931>>>>>>>>>>>>>>>>>        Delegate Set ToolBar_Id to Self
23933>>>>>>>>>>>>>>>>>    End_Procedure
23934>>>>>>>>>>>>>>>>>    
23934>>>>>>>>>>>>>>>>>    Procedure Page Integer bState
23936>>>>>>>>>>>>>>>>>        Integer hoClient
23936>>>>>>>>>>>>>>>>>        Handle  hWnd
23936>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23937>>>>>>>>>>>>>>>>>        Forward Send Page bState
23939>>>>>>>>>>>>>>>>>        If (bState=1 and hWnd=0) Begin
23941>>>>>>>>>>>>>>>>>            Delegate Get Client_Id to hoClient
23943>>>>>>>>>>>>>>>>>            If hoClient ;                Send Add_Border_Object to hoClient Self amTOP
23946>>>>>>>>>>>>>>>>>        End
23946>>>>>>>>>>>>>>>>>>
23946>>>>>>>>>>>>>>>>>    End_Procedure
23947>>>>>>>>>>>>>>>>>    
23947>>>>>>>>>>>>>>>>>    Procedure Deactivating
23949>>>>>>>>>>>>>>>>>        Integer hoClient
23949>>>>>>>>>>>>>>>>>        Forward Send DeActivating
23951>>>>>>>>>>>>>>>>>        Delegate Get Client_Id to hoClient
23953>>>>>>>>>>>>>>>>>        If hoClient Begin
23955>>>>>>>>>>>>>>>>>            Send Remove_Border_Object to hoClient Self amTOP
23956>>>>>>>>>>>>>>>>>        End
23956>>>>>>>>>>>>>>>>>>
23956>>>>>>>>>>>>>>>>>    End_Procedure
23957>>>>>>>>>>>>>>>>>    
23957>>>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
23959>>>>>>>>>>>>>>>>>        Forward Set GuiSize to cy cx
23961>>>>>>>>>>>>>>>>>    End_Procedure
23962>>>>>>>>>>>>>>>>>    
23962>>>>>>>>>>>>>>>>>    // Container_Handle:
23962>>>>>>>>>>>>>>>>>    // JvH: - This function was put in to allow support for combo-form & other
23962>>>>>>>>>>>>>>>>>    // controls in the toolbar.
23962>>>>>>>>>>>>>>>>>    Function Container_Handle Returns Handle
23964>>>>>>>>>>>>>>>>>        Function_Return (window_handle(Self))
23965>>>>>>>>>>>>>>>>>    End_Function
23966>>>>>>>>>>>>>>>>>End_Class
23967>>>>>>>>>>>>>>>>>
23967>>>>>>>>>>>>>>>Use DFAClnt.pkg   // df application Client
Including file: Dfaclnt.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfaclnt.pkg)
23967>>>>>>>>>>>>>>>>>Use Windows.pkg
23967>>>>>>>>>>>>>>>>>Use Set.pkg
Including file: set.pkg    (C:\Program Files\DataFlex 23.0\Pkg\set.pkg)
23967>>>>>>>>>>>>>>>>>>>Use VDFBase.pkg
23967>>>>>>>>>>>>>>>>>>>
23967>>>>>>>>>>>>>>>>>>>Class Set is an ARRAY
23968>>>>>>>>>>>>>>>>>>>    
23968>>>>>>>>>>>>>>>>>>>    Function Find_Element String ElemStr Returns Integer
23970>>>>>>>>>>>>>>>>>>>        Integer ndx retVal ArrMax
23970>>>>>>>>>>>>>>>>>>>        String ArrVal
23970>>>>>>>>>>>>>>>>>>>        Get item_count to ArrMax
23971>>>>>>>>>>>>>>>>>>>        Move -1 to retVal
23972>>>>>>>>>>>>>>>>>>>        Move 0 to ndx
23973>>>>>>>>>>>>>>>>>>>        While (ndx < ArrMax and retVal = -1)
23977>>>>>>>>>>>>>>>>>>>            Get array_value  ndx to ArrVal
23978>>>>>>>>>>>>>>>>>>>            If (ArrVal = ElemStr) ;                Move ndx to retVal
23981>>>>>>>>>>>>>>>>>>>            Move (ndx + 1) to ndx
23982>>>>>>>>>>>>>>>>>>>        loop
23983>>>>>>>>>>>>>>>>>>>>
23983>>>>>>>>>>>>>>>>>>>        Function_Return retVal
23984>>>>>>>>>>>>>>>>>>>    End_Function
23985>>>>>>>>>>>>>>>>>>>    
23985>>>>>>>>>>>>>>>>>>>    Procedure Add_Element String Elem_Str Returns Integer
23987>>>>>>>>>>>>>>>>>>>        Integer Ret_Val
23987>>>>>>>>>>>>>>>>>>>        
23987>>>>>>>>>>>>>>>>>>>        Get Find_Element Elem_Str to Ret_Val
23988>>>>>>>>>>>>>>>>>>>        
23988>>>>>>>>>>>>>>>>>>>        If (Ret_Val < 0) ;            Get Item_Count to Ret_Val
23991>>>>>>>>>>>>>>>>>>>        
23991>>>>>>>>>>>>>>>>>>>        Set Array_Value  Ret_Val to Elem_Str
23992>>>>>>>>>>>>>>>>>>>        
23992>>>>>>>>>>>>>>>>>>>        Procedure_Return Ret_Val
23993>>>>>>>>>>>>>>>>>>>    End_Procedure
23994>>>>>>>>>>>>>>>>>>>    
23994>>>>>>>>>>>>>>>>>>>    Procedure Remove_Element String sElement
23996>>>>>>>>>>>>>>>>>>>        Integer iIndex
23996>>>>>>>>>>>>>>>>>>>        Get Find_Element sElement to iIndex
23997>>>>>>>>>>>>>>>>>>>        If (iIndex > -1) ;            Send delete_item iIndex
24000>>>>>>>>>>>>>>>>>>>    End_Procedure
24001>>>>>>>>>>>>>>>>>>>    
24001>>>>>>>>>>>>>>>>>>>    
24001>>>>>>>>>>>>>>>>>>>End_Class
24002>>>>>>>>>>>>>>>>>>>
24002>>>>>>>>>>>>>>>>>>>//
24002>>>>>>>>>>>>>>>>>>>// global function to create set instances at random
24002>>>>>>>>>>>>>>>>>>>//
24002>>>>>>>>>>>>>>>>>>>Function make_set for cDesktop Returns Integer
24004>>>>>>>>>>>>>>>>>>>    Integer retval
24004>>>>>>>>>>>>>>>>>>>    Object SetTemplate is a Set
24006>>>>>>>>>>>>>>>>>>>        Move Self to retval
24007>>>>>>>>>>>>>>>>>>>    End_Object
24008>>>>>>>>>>>>>>>>>>>    Function_Return retval
24009>>>>>>>>>>>>>>>>>>>End_Function
24010>>>>>>>>>>>>>>>>>>>
24010>>>>>>>>>>>>>>>>>>>
24010>>>>>>>>>>>>>>>>>>>
24010>>>>>>>>>>>>>>>>>Use Dfpanel.pkg
24010>>>>>>>>>>>>>>>>>
24010>>>>>>>>>>>>>>>>>Class AppClientArea is a MdiClientArea
24011>>>>>>>>>>>>>>>>>    
24011>>>>>>>>>>>>>>>>>    Procedure Construct_Object
24013>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
24015>>>>>>>>>>>>>>>>>        
24015>>>>>>>>>>>>>>>>>        Property Integer Auto_Arrange_Icons_State True
24016>>>>>>>>>>>>>>>>>        
24016>>>>>>>>>>>>>>>>>        Property Integer Private.Client_Scrollbar_State   True
24017>>>>>>>>>>>>>>>>>        
24017>>>>>>>>>>>>>>>>>        Delegate Set Client_Id to Self
24019>>>>>>>>>>>>>>>>>        // keep track of all child dialog objects (views)
24019>>>>>>>>>>>>>>>>>        
24019>>>>>>>>>>>>>>>>>        Object Mdi_Dialogs is a Set
24021>>>>>>>>>>>>>>>>>        End_Object
24022>>>>>>>>>>>>>>>>>        
24022>>>>>>>>>>>>>>>>>        Property Integer Private.Last_Dialog_Item -1
24023>>>>>>>>>>>>>>>>>    End_Procedure
24024>>>>>>>>>>>>>>>>>    
24024>>>>>>>>>>>>>>>>>    Procedure Set Client_Scrollbar_State Integer bState
24026>>>>>>>>>>>>>>>>>        Set Scroll_bar_Visible_State to bState
24027>>>>>>>>>>>>>>>>>        Set Private.Client_Scrollbar_State to bState
24028>>>>>>>>>>>>>>>>>    End_Procedure
24029>>>>>>>>>>>>>>>>>    
24029>>>>>>>>>>>>>>>>>    Function Client_Scrollbar_State Returns Integer
24031>>>>>>>>>>>>>>>>>        Function_Return (Private.Client_Scrollbar_State(Self))
24032>>>>>>>>>>>>>>>>>    End_Function
24033>>>>>>>>>>>>>>>>>    
24033>>>>>>>>>>>>>>>>>    Procedure Add_Mdi_Dialog Integer Id#
24035>>>>>>>>>>>>>>>>>        Send Add_element to (mdi_dialogs(Self)) Id#
24036>>>>>>>>>>>>>>>>>    End_Procedure
24037>>>>>>>>>>>>>>>>>    
24037>>>>>>>>>>>>>>>>>    Procedure Remove_Mdi_Dialog Integer Id#
24039>>>>>>>>>>>>>>>>>        Integer obj#
24039>>>>>>>>>>>>>>>>>        Move (mdi_dialogs(Self)) to Obj#
24040>>>>>>>>>>>>>>>>>        If Obj# ;            Send Remove_element to (mdi_dialogs(Obj#)) Id#
24043>>>>>>>>>>>>>>>>>    End_Procedure
24044>>>>>>>>>>>>>>>>>    
24044>>>>>>>>>>>>>>>>>    Function Next_Mdi_Dialog Integer FindFirst Returns Integer
24046>>>>>>>>>>>>>>>>>        Integer Id# Item# Obj#
24046>>>>>>>>>>>>>>>>>        Get Private.Last_dialog_item to Item#
24047>>>>>>>>>>>>>>>>>        If FindFirst ;            Move -1 to Item#
24050>>>>>>>>>>>>>>>>>        Increment Item#
24051>>>>>>>>>>>>>>>>>        Set Private.Last_dialog_item to Item#
24052>>>>>>>>>>>>>>>>>        Move (Mdi_dialogs(Self)) to Obj#
24053>>>>>>>>>>>>>>>>>        If (Item_count(Obj#)>Item#) ;            Get Value of Obj# Item# to Id#
24056>>>>>>>>>>>>>>>>>        Function_Return Id#
24057>>>>>>>>>>>>>>>>>    End_Function
24058>>>>>>>>>>>>>>>>>    
24058>>>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
24060>>>>>>>>>>>>>>>>>        Forward Set GuiSize to cy cx
24062>>>>>>>>>>>>>>>>>        If (active_state(Self) and Auto_Arrange_Icons_State(Self)) ;            Send Arrange_icons
24065>>>>>>>>>>>>>>>>>    End_Procedure
24066>>>>>>>>>>>>>>>>>    
24066>>>>>>>>>>>>>>>>>    Procedure Private.Adjust_MDI_Margins Integer cy Integer cx Integer BorderFlag
24068>>>>>>>>>>>>>>>>>        Integer cMargin
24068>>>>>>>>>>>>>>>>>        If (BorderFlag = amTOP) Begin
24070>>>>>>>>>>>>>>>>>            Get mdi_top_margin to cMargin
24071>>>>>>>>>>>>>>>>>            Set mdi_top_margin to (cMargin + cy)
24072>>>>>>>>>>>>>>>>>        End
24072>>>>>>>>>>>>>>>>>>
24072>>>>>>>>>>>>>>>>>        Else If (BorderFlag = amBOTTOM) Begin
24075>>>>>>>>>>>>>>>>>            Get mdi_bottom_margin to cMargin
24076>>>>>>>>>>>>>>>>>            Set mdi_bottom_margin to (cMargin + cy)
24077>>>>>>>>>>>>>>>>>        End
24077>>>>>>>>>>>>>>>>>>
24077>>>>>>>>>>>>>>>>>        Else If (BorderFlag = amLEFT) Begin
24080>>>>>>>>>>>>>>>>>            Get mdi_left_margin to cMargin
24081>>>>>>>>>>>>>>>>>            Set mdi_left_margin to (cMargin + cx)
24082>>>>>>>>>>>>>>>>>        End
24082>>>>>>>>>>>>>>>>>>
24082>>>>>>>>>>>>>>>>>        Else If (BorderFlag = amRIGHT) Begin
24085>>>>>>>>>>>>>>>>>            Get mdi_right_margin to cMargin
24086>>>>>>>>>>>>>>>>>            Set mdi_right_margin to (cMargin + cx)
24087>>>>>>>>>>>>>>>>>        End
24087>>>>>>>>>>>>>>>>>>
24087>>>>>>>>>>>>>>>>>    End_Procedure
24088>>>>>>>>>>>>>>>>>    
24088>>>>>>>>>>>>>>>>>    Procedure Add_Border_Object Integer hoBorder Integer BorderFlag
24090>>>>>>>>>>>>>>>>>        Integer cy cx
24090>>>>>>>>>>>>>>>>>        Move (hi(GuiSize(hoBorder)))  to cy
24091>>>>>>>>>>>>>>>>>        Move (low(GuiSize(hoBorder))) to cx
24092>>>>>>>>>>>>>>>>>        
24092>>>>>>>>>>>>>>>>>        Send Private.Adjust_MDI_Margins cy cx BorderFlag
24093>>>>>>>>>>>>>>>>>    End_Procedure
24094>>>>>>>>>>>>>>>>>    
24094>>>>>>>>>>>>>>>>>    Procedure Remove_Border_Object Integer hoBorder Integer BorderFlag
24096>>>>>>>>>>>>>>>>>        Integer cy cx
24096>>>>>>>>>>>>>>>>>        Move (-(hi(GuiSize(hoBorder))))  to cy
24097>>>>>>>>>>>>>>>>>        Move (-(low(GuiSize(hoBorder)))) to cx
24098>>>>>>>>>>>>>>>>>        
24098>>>>>>>>>>>>>>>>>        Send Private.Adjust_MDI_Margins cy cx BorderFlag
24099>>>>>>>>>>>>>>>>>    End_Procedure
24100>>>>>>>>>>>>>>>>>    
24100>>>>>>>>>>>>>>>>>    //
24100>>>>>>>>>>>>>>>>>    // default behavior of mdi client is to passively pass these
24100>>>>>>>>>>>>>>>>>    // message on to their mdi dialogs (views)
24100>>>>>>>>>>>>>>>>>    //
24100>>>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24102>>>>>>>>>>>>>>>>>        Integer rVal Id#
24102>>>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
24103>>>>>>>>>>>>>>>>>        While (Id# and Rval=0)
24107>>>>>>>>>>>>>>>>>            Get Verify_Exit_application of Id# to rVal
24108>>>>>>>>>>>>>>>>>            If not rval ;                Get Next_Mdi_Dialog False to Id#
24111>>>>>>>>>>>>>>>>>        End
24112>>>>>>>>>>>>>>>>>>
24112>>>>>>>>>>>>>>>>>        Function_Return rval
24113>>>>>>>>>>>>>>>>>    End_Function
24114>>>>>>>>>>>>>>>>>    
24114>>>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24116>>>>>>>>>>>>>>>>>        Integer Id#
24116>>>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
24117>>>>>>>>>>>>>>>>>        While Id#
24121>>>>>>>>>>>>>>>>>            Send Notify_Exit_Application to Id#
24122>>>>>>>>>>>>>>>>>            Get Next_Mdi_Dialog False to Id#
24123>>>>>>>>>>>>>>>>>        End
24124>>>>>>>>>>>>>>>>>>
24124>>>>>>>>>>>>>>>>>    End_Procedure
24125>>>>>>>>>>>>>>>>>    
24125>>>>>>>>>>>>>>>>>    Procedure Make_all_ViewMode Integer Mode
24127>>>>>>>>>>>>>>>>>        Integer Id#
24127>>>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
24128>>>>>>>>>>>>>>>>>        While Id#
24132>>>>>>>>>>>>>>>>>            If (active_State(Id#)) ;                Set View_Mode of Id# to Mode
24135>>>>>>>>>>>>>>>>>            Get Next_Mdi_Dialog False to Id#
24136>>>>>>>>>>>>>>>>>        End
24137>>>>>>>>>>>>>>>>>>
24137>>>>>>>>>>>>>>>>>    End_Procedure
24138>>>>>>>>>>>>>>>>>    
24138>>>>>>>>>>>>>>>>>    Procedure Minimize_all_Windows
24140>>>>>>>>>>>>>>>>>        Send Make_All_ViewMode VIEWMODE_ICONIZE
24141>>>>>>>>>>>>>>>>>    End_Procedure
24142>>>>>>>>>>>>>>>>>    
24142>>>>>>>>>>>>>>>>>    Procedure Restore_all_Windows
24144>>>>>>>>>>>>>>>>>        Send Make_All_ViewMode VIEWMODE_NORMAL
24145>>>>>>>>>>>>>>>>>    End_Procedure
24146>>>>>>>>>>>>>>>>>    
24146>>>>>>>>>>>>>>>>>    // The framework has used activate_about for years to activate an about
24146>>>>>>>>>>>>>>>>>    // dialog. As of 12.1, we have a sub-class for this and providing the
24146>>>>>>>>>>>>>>>>>    // required message makes things work better. It is expected that a
24146>>>>>>>>>>>>>>>>>    // developer will augment this in their clientarea to call the about
24146>>>>>>>>>>>>>>>>>    // object that they created.
24146>>>>>>>>>>>>>>>>>    Procedure Activate_About
24148>>>>>>>>>>>>>>>>>    End_Procedure
24149>>>>>>>>>>>>>>>>>    
24149>>>>>>>>>>>>>>>>>    
24149>>>>>>>>>>>>>>>>>End_Class
24150>>>>>>>>>>>>>>>Use DFADlg.pkg    // df application Dialog
Including file: Dfadlg.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfadlg.pkg)
24150>>>>>>>>>>>>>>>>>Use LanguageText.pkg
24150>>>>>>>>>>>>>>>>>Use Windows.pkg
24150>>>>>>>>>>>>>>>>>Use dfConfrm.pkg
Including file: Dfconfrm.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfconfrm.pkg)
24150>>>>>>>>>>>>>>>>>>>Use LanguageText.pkg
24150>>>>>>>>>>>>>>>>>>>Use msgbox.pkg
24150>>>>>>>>>>>>>>>>>>>
24150>>>>>>>>>>>>>>>>>>>// General purpose confirm function. Added to all classes
24150>>>>>>>>>>>>>>>>>>>//
24150>>>>>>>>>>>>>>>>>>>Function Confirm for cUIObject String item_name Returns Integer
24152>>>>>>>>>>>>>>>>>>>    Integer rval
24152>>>>>>>>>>>>>>>>>>>    Move (YesNo_Box(item_name, C_$Confirm, MB_DEFBUTTON1 )) to rval
24153>>>>>>>>>>>>>>>>>>>    Function_Return (rval<>MBR_YES)
24154>>>>>>>>>>>>>>>>>>>End_function
24155>>>>>>>>>>>>>>>>>>>
24155>>>>>>>>>>>>>>>>>>>Function Save_Confirmation for cUIObject Returns integer
24157>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$SaveThisRecord))
24158>>>>>>>>>>>>>>>>>>>End_function
24159>>>>>>>>>>>>>>>>>>>
24159>>>>>>>>>>>>>>>>>>>Function Delete_Confirmation for cUIObject Returns integer
24161>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$DeleteThisRecord))
24162>>>>>>>>>>>>>>>>>>>End_function
24163>>>>>>>>>>>>>>>>>>>
24163>>>>>>>>>>>>>>>>>>>Function Line_Save_Confirmation for cUIObject Returns Integer
24165>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$SaveThisLine))
24166>>>>>>>>>>>>>>>>>>>End_function
24167>>>>>>>>>>>>>>>>>>>
24167>>>>>>>>>>>>>>>>>>>Function Line_Delete_Confirmation for cUIObject Returns Integer
24169>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$DeleteThisLine))
24170>>>>>>>>>>>>>>>>>>>End_function
24171>>>>>>>>>>>>>>>>>>>
24171>>>>>>>>>>>>>>>>>>>Function Data_Loss_Confirmation for cUIObject Returns integer
24173>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$AbandonChanges))
24174>>>>>>>>>>>>>>>>>>>End_function
24175>>>>>>>>>>>>>>>>>>>
24175>>>>>>>>>>>>>>>>>>>Function Exit_Loss_Confirmation for cUIObject Returns integer
24177>>>>>>>>>>>>>>>>>>>    Integer tmp
24177>>>>>>>>>>>>>>>>>>>    get Should_save_recursive to tmp
24178>>>>>>>>>>>>>>>>>>>    If (tmp <> 0) ;        Function_Return (confirm(Self, C_$ChangesExistAbandon))
24181>>>>>>>>>>>>>>>>>>>End_function
24182>>>>>>>>>>>>>>>>>>>
24182>>>>>>>>>>>>>>>>>>>Function No_Confirmation for cUIObject Returns integer
24184>>>>>>>>>>>>>>>>>>>End_function
24185>>>>>>>>>>>>>>>>>>>
24185>>>>>>>>>>>>>>>>>>>Function Should_Save for cUIObject returns integer
24187>>>>>>>>>>>>>>>>>>>end_function
24188>>>>>>>>>>>>>>>>>>>
24188>>>>>>>>>>>>>>>>>>>Function Should_Save_Recursive for cUIObject returns integer
24190>>>>>>>>>>>>>>>>>>>    Integer rVal
24190>>>>>>>>>>>>>>>>>>>    Get Should_Save to Rval // changes in this object???
24191>>>>>>>>>>>>>>>>>>>    If (rVal = 0) ;        Broadcast Get Should_Save_Recursive to Rval // check w/ kids
24195>>>>>>>>>>>>>>>>>>>    Function_return rVal
24196>>>>>>>>>>>>>>>>>>>End_Function
24197>>>>>>>>>>>>>>>>>>>
24197>>>>>>>>>>>>>>>>>>>
24197>>>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
24197>>>>>>>>>>>>>>>>>Use tWinStructs.pkg
24197>>>>>>>>>>>>>>>>>Use Dfpanel.pkg
24197>>>>>>>>>>>>>>>>>
24197>>>>>>>>>>>>>>>>>
24197>>>>>>>>>>>>>>>>>// as of 15.0, moved some of dbViews features up to this level. Load/Save Environment showing view name
24197>>>>>>>>>>>>>>>>>Class AppDialog is a MdiDialog
24198>>>>>>>>>>>>>>>>>    
24198>>>>>>>>>>>>>>>>>    Procedure Construct_Object
24200>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
24202>>>>>>>>>>>>>>>>>        
24202>>>>>>>>>>>>>>>>>        // This can be used to stop this view from loading and saving its environment.
24202>>>>>>>>>>>>>>>>>        Property Boolean pbDisableSaveEnvironment False
24203>>>>>>>>>>>>>>>>>        
24203>>>>>>>>>>>>>>>>>        // set true to auto-activate the view. This does not work if the object is deferred.
24203>>>>>>>>>>>>>>>>>        // this is a design time property which is applied during end_construct_object. This should
24203>>>>>>>>>>>>>>>>>        Property Boolean pbAutoActivate False
24204>>>>>>>>>>>>>>>>>        
24204>>>>>>>>>>>>>>>>>        // used to keep track of window placment when deactivated object is reactivated.
24204>>>>>>>>>>>>>>>>>        Property tWinWindowPlacement pWindowPlacement
24205>>>>>>>>>>>>>>>>>    End_Procedure
24206>>>>>>>>>>>>>>>>>    
24206>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24208>>>>>>>>>>>>>>>>>        Boolean bAutoActivate
24208>>>>>>>>>>>>>>>>>        Delegate Send Add_Mdi_Dialog Self
24210>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
24212>>>>>>>>>>>>>>>>>        // if auto-activate, add this to he the panel's array of objects to be acivated.
24212>>>>>>>>>>>>>>>>>        Get pbAutoActivate to bAutoActivate
24213>>>>>>>>>>>>>>>>>        If bAutoActivate Begin
24215>>>>>>>>>>>>>>>>>            Delegate Send AddAutoActivateView Self
24217>>>>>>>>>>>>>>>>>        End
24217>>>>>>>>>>>>>>>>>>
24217>>>>>>>>>>>>>>>>>    End_Procedure
24218>>>>>>>>>>>>>>>>>    
24218>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
24220>>>>>>>>>>>>>>>>>        Integer obj
24220>>>>>>>>>>>>>>>>>        Move Self to obj
24221>>>>>>>>>>>>>>>>>        Delegate Send Remove_Mdi_Dialog obj
24223>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
24225>>>>>>>>>>>>>>>>>    End_Procedure
24226>>>>>>>>>>>>>>>>>    
24226>>>>>>>>>>>>>>>>>    // Augmented to save view position
24226>>>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24228>>>>>>>>>>>>>>>>>        Send Save_Environment
24229>>>>>>>>>>>>>>>>>    End_Procedure
24230>>>>>>>>>>>>>>>>>    
24230>>>>>>>>>>>>>>>>>    Function View_Changed Returns Integer
24232>>>>>>>>>>>>>>>>>    End_Function
24233>>>>>>>>>>>>>>>>>    
24233>>>>>>>>>>>>>>>>>    //
24233>>>>>>>>>>>>>>>>>    // Augment exit_application_check to see if view is changed. If changed,
24233>>>>>>>>>>>>>>>>>    // display exit message as required
24233>>>>>>>>>>>>>>>>>    
24233>>>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24235>>>>>>>>>>>>>>>>>        Integer Fail
24235>>>>>>>>>>>>>>>>>        Get View_Changed to Fail // Ask for changes in Data-sets
24236>>>>>>>>>>>>>>>>>        If fail ; // ok a change exist...activate changed view.            Get confirm (SFormat(C_$ChangesExistExit, Label(Self)) ) to fail
24239>>>>>>>>>>>>>>>>>        Function_Return fail
24240>>>>>>>>>>>>>>>>>    End_Function
24241>>>>>>>>>>>>>>>>>    
24241>>>>>>>>>>>>>>>>>    // Activates the view. If view is minimized it restores it first
24241>>>>>>>>>>>>>>>>>    // works with both popup_state T and F
24241>>>>>>>>>>>>>>>>>    
24241>>>>>>>>>>>>>>>>>    Procedure Activate_View Returns Integer
24243>>>>>>>>>>>>>>>>>        Integer rVal
24243>>>>>>>>>>>>>>>>>        If ( View_mode(Self)=VIEWMODE_ICONIZE ) ;            Set view_mode to viewmode_normal
24246>>>>>>>>>>>>>>>>>        If (Popup_state(Self)) ;    // support both popup and            Get Msg_Popup to rVal
24249>>>>>>>>>>>>>>>>>        Else ;            Get Msg_Activate to rVal
24251>>>>>>>>>>>>>>>>>        Procedure_Return rVal
24252>>>>>>>>>>>>>>>>>    End_Procedure
24253>>>>>>>>>>>>>>>>>    
24253>>>>>>>>>>>>>>>>>    
24253>>>>>>>>>>>>>>>>>    // augmented to load last view position
24253>>>>>>>>>>>>>>>>>    
24253>>>>>>>>>>>>>>>>>    Procedure Add_Focus Integer hoBase Returns Integer
24255>>>>>>>>>>>>>>>>>        Integer iRetVal bState
24255>>>>>>>>>>>>>>>>>        Get Visible_State to bState
24256>>>>>>>>>>>>>>>>>        Set Visible_State to False
24257>>>>>>>>>>>>>>>>>        Forward Get Msg_Add_Focus hoBase to iRetVal
24259>>>>>>>>>>>>>>>>>        If (iRetVal=0) Begin
24261>>>>>>>>>>>>>>>>>            Send Load_Environment
24262>>>>>>>>>>>>>>>>>        End
24262>>>>>>>>>>>>>>>>>>
24262>>>>>>>>>>>>>>>>>        Set Visible_State to bState
24263>>>>>>>>>>>>>>>>>        Procedure_Return iRetVal
24264>>>>>>>>>>>>>>>>>    End_Procedure
24265>>>>>>>>>>>>>>>>>    
24265>>>>>>>>>>>>>>>>>    // This is augmented to send save_environment during a view close (was in close_panel)
24265>>>>>>>>>>>>>>>>>    // we set view_mode to normal if it is zoomed. This is needed to make the MDI stuff work
24265>>>>>>>>>>>>>>>>>    // properly with the save/load environment. The Saved environment data will make it zoom if needed.
24265>>>>>>>>>>>>>>>>>    //
24265>>>>>>>>>>>>>>>>>    Procedure Deactivate Integer eDeactivateScope Returns Integer
24267>>>>>>>>>>>>>>>>>        Integer eArea iFail
24267>>>>>>>>>>>>>>>>>        Boolean bPreserveEnvironment
24267>>>>>>>>>>>>>>>>>        Move (If(num_arguments=0, Area_Type, eDeactivateScope)) to eArea // in case no param is passed
24268>>>>>>>>>>>>>>>>>        If (eArea<>0) Begin
24270>>>>>>>>>>>>>>>>>            Forward Get msg_deactivate eArea to iFail
24272>>>>>>>>>>>>>>>>>        End
24272>>>>>>>>>>>>>>>>>>
24272>>>>>>>>>>>>>>>>>        Else Begin
24273>>>>>>>>>>>>>>>>>            Send Save_Environment
24274>>>>>>>>>>>>>>>>>            Forward Get msg_deactivate eArea to iFail
24276>>>>>>>>>>>>>>>>>            
24276>>>>>>>>>>>>>>>>>            // this works around a problem where maximized MDI views get saved but don't come back
24276>>>>>>>>>>>>>>>>>            // correctly when loaded again without exiting. It turns out the the MDI client restores
24276>>>>>>>>>>>>>>>>>            // the view sometimes without telling view_mode. If view_mode is normal, it always works.
24276>>>>>>>>>>>>>>>>>            // This must happen after the view is deactivated!
24276>>>>>>>>>>>>>>>>>            
24276>>>>>>>>>>>>>>>>>            If ghoApplication Begin
24278>>>>>>>>>>>>>>>>>                Get pbPreserveEnvironment of ghoApplication to bPreserveEnvironment
24279>>>>>>>>>>>>>>>>>            End
24279>>>>>>>>>>>>>>>>>>
24279>>>>>>>>>>>>>>>>>            // do these checks to have as small of an effect as possible.
24279>>>>>>>>>>>>>>>>>            If (bPreserveEnvironment and iFail=0 and view_mode(Self)=Viewmode_Zoom) Begin
24281>>>>>>>>>>>>>>>>>                Set View_Mode to Viewmode_Normal
24282>>>>>>>>>>>>>>>>>            End
24282>>>>>>>>>>>>>>>>>>
24282>>>>>>>>>>>>>>>>>        End
24282>>>>>>>>>>>>>>>>>>
24282>>>>>>>>>>>>>>>>>        Procedure_Return iFail
24283>>>>>>>>>>>>>>>>>    End_Procedure
24284>>>>>>>>>>>>>>>>>    
24284>>>>>>>>>>>>>>>>>    // Save the window placement information for this to the application object
24284>>>>>>>>>>>>>>>>>    
24284>>>>>>>>>>>>>>>>>    Procedure Save_Environment
24286>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24286>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24286>>>>>>>>>>>>>>>>>        Boolean bSuccess bCancel
24286>>>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to bCancel
24287>>>>>>>>>>>>>>>>>        If not bCancel Begin
24289>>>>>>>>>>>>>>>>>            
24289>>>>>>>>>>>>>>>>>            // save environment to the object, in case it is reactivated during the same run.
24289>>>>>>>>>>>>>>>>>            Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
24290>>>>>>>>>>>>>>>>>            Move (GetWindowPlacement(Window_Handle(Self), addressof(WindowPlacement))) to bSuccess
24291>>>>>>>>>>>>>>>>>            If bSuccess Begin
24293>>>>>>>>>>>>>>>>>                // if minimized, assume restored, as we don't want to restart minimized!
24293>>>>>>>>>>>>>>>>>                If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
24295>>>>>>>>>>>>>>>>>                    Move SW_SHOWNORMAL to WindowPlacement.showCmd
24296>>>>>>>>>>>>>>>>>                End
24296>>>>>>>>>>>>>>>>>>
24296>>>>>>>>>>>>>>>>>                Set pWindowPlacement to WindowPlacement
24297>>>>>>>>>>>>>>>>>            End
24297>>>>>>>>>>>>>>>>>>
24297>>>>>>>>>>>>>>>>>            // also save environment to the application object, so it can be used when reloaded
24297>>>>>>>>>>>>>>>>>            If ghoApplication ;                Send DoSaveEnvironment of ghoApplication Self False
24300>>>>>>>>>>>>>>>>>        End
24300>>>>>>>>>>>>>>>>>>
24300>>>>>>>>>>>>>>>>>    End_Procedure
24301>>>>>>>>>>>>>>>>>    
24301>>>>>>>>>>>>>>>>>    // Load the window placement information for this from the application object
24301>>>>>>>>>>>>>>>>>    
24301>>>>>>>>>>>>>>>>>    Procedure Load_Environment
24303>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24303>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24303>>>>>>>>>>>>>>>>>        Boolean bSuccess bCancel
24303>>>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to bCancel
24304>>>>>>>>>>>>>>>>>        If not bCancel Begin
24306>>>>>>>>>>>>>>>>>            // if view has alrady been activated and deactivated use the setting from windowplacement saved in the object
24306>>>>>>>>>>>>>>>>>            Get pWindowPlacement to WindowPlacement
24307>>>>>>>>>>>>>>>>>            //  if length is zero, assume it has never been used before (never deactivated).
24307>>>>>>>>>>>>>>>>>            If (WindowPlacement.length>0) Begin
24309>>>>>>>>>>>>>>>>>                Move (SetWindowPlacement(Window_Handle(Self), AddressOf(WindowPlacement))) to bSuccess
24310>>>>>>>>>>>>>>>>>            End
24310>>>>>>>>>>>>>>>>>>
24310>>>>>>>>>>>>>>>>>            Else Begin
24311>>>>>>>>>>>>>>>>>                If ghoApplication ;                    Send DoLoadEnvironment of ghoApplication Self False
24314>>>>>>>>>>>>>>>>>            End
24314>>>>>>>>>>>>>>>>>>
24314>>>>>>>>>>>>>>>>>        End
24314>>>>>>>>>>>>>>>>>>
24314>>>>>>>>>>>>>>>>>    End_Procedure
24315>>>>>>>>>>>>>>>>>    
24315>>>>>>>>>>>>>>>>>    Procedure Entering_Scope Returns Integer
24317>>>>>>>>>>>>>>>>>        Integer rVal
24317>>>>>>>>>>>>>>>>>        Forward Get MSG_Entering_Scope to rVal
24319>>>>>>>>>>>>>>>>>        If not rVal ;            Send Show_View_Name (Label(Self))
24322>>>>>>>>>>>>>>>>>    End_Procedure
24323>>>>>>>>>>>>>>>>>    
24323>>>>>>>>>>>>>>>>>    Procedure Exiting_Scope Integer whereto Returns Integer
24325>>>>>>>>>>>>>>>>>        Integer rVal
24325>>>>>>>>>>>>>>>>>        Forward Get MSG_Exiting_Scope whereto to rVal
24327>>>>>>>>>>>>>>>>>        If not rVal ;            Send Show_View_Name ''
24330>>>>>>>>>>>>>>>>>    End_Procedure
24331>>>>>>>>>>>>>>>>>    
24331>>>>>>>>>>>>>>>>>    Procedure Show_view_Name String sHelp
24333>>>>>>>>>>>>>>>>>        Integer rVal Id
24333>>>>>>>>>>>>>>>>>        Get Statusbar_id to id
24334>>>>>>>>>>>>>>>>>        If Id ;            Send Show_View_Name to Id sHelp
24337>>>>>>>>>>>>>>>>>    End_Procedure
24338>>>>>>>>>>>>>>>>>    
24338>>>>>>>>>>>>>>>>>    // force object to be modal and then pop it up. Upon complettion restore it to a normal view
24338>>>>>>>>>>>>>>>>>    Procedure Popup_Modal Returns Integer
24340>>>>>>>>>>>>>>>>>        
24340>>>>>>>>>>>>>>>>>        Integer OldBMS OldAPS OldPS OldRS OldSS OldMDIState
24340>>>>>>>>>>>>>>>>>        Integer OldLoc OldAutoLoc OldKeyPath OldDisableSaveEnv OldMin OldMax
24340>>>>>>>>>>>>>>>>>        Integer rVal
24340>>>>>>>>>>>>>>>>>        
24340>>>>>>>>>>>>>>>>>        // If object is active we can't do anything. -1 means already active
24340>>>>>>>>>>>>>>>>>        If (Active_State(Self)) ;            Procedure_Return -1
24343>>>>>>>>>>>>>>>>>        
24343>>>>>>>>>>>>>>>>>        // Remember all important modal property settings.
24343>>>>>>>>>>>>>>>>>        Get Block_mouse_State to OldBMS
24344>>>>>>>>>>>>>>>>>        Get Attach_parent_State to OldAPS
24345>>>>>>>>>>>>>>>>>        Get Popup_State to OldPS
24346>>>>>>>>>>>>>>>>>        Get Ring_State to OldRS
24347>>>>>>>>>>>>>>>>>        Get Scope_State to OldSS
24348>>>>>>>>>>>>>>>>>        Get MDI_State to OldMDIState
24349>>>>>>>>>>>>>>>>>        Get Key_Path to OldKeyPath
24350>>>>>>>>>>>>>>>>>        Get Location to OldLoc
24351>>>>>>>>>>>>>>>>>        Get Maximize_Icon to OldMax
24352>>>>>>>>>>>>>>>>>        Get Minimize_Icon to OldMin
24353>>>>>>>>>>>>>>>>>        Get Auto_Locate_State to OldAutoLoc
24354>>>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to OldDisableSaveEnv
24355>>>>>>>>>>>>>>>>>        
24355>>>>>>>>>>>>>>>>>        // set propertie required to make this a modal dialog
24355>>>>>>>>>>>>>>>>>        Set pbDisableSaveEnvironment to True
24356>>>>>>>>>>>>>>>>>        Set MDI_State to False
24357>>>>>>>>>>>>>>>>>        Set Auto_Locate_State to True
24358>>>>>>>>>>>>>>>>>        Set Key_path to Desktop
24359>>>>>>>>>>>>>>>>>        Set Block_mouse_state to True
24360>>>>>>>>>>>>>>>>>        Set Attach_parent_state to False
24361>>>>>>>>>>>>>>>>>        // we used to set Exit_Application_Local_State to True - as of 19.1 we don't
24361>>>>>>>>>>>>>>>>>        Set Popup_State to True
24362>>>>>>>>>>>>>>>>>        Set Ring_State to True
24363>>>>>>>>>>>>>>>>>        Set Scope_State to True
24364>>>>>>>>>>>>>>>>>        Set Minimize_Icon to False
24365>>>>>>>>>>>>>>>>>        Set Maximize_Icon to False
24366>>>>>>>>>>>>>>>>>        
24366>>>>>>>>>>>>>>>>>        Get Msg_Popup to rVal
24367>>>>>>>>>>>>>>>>>        If rval ;            Move -2 to rVal      // did not activate
24370>>>>>>>>>>>>>>>>>        Else ;            Move StrMark to rVal // StrMark keeps track of UI value
24372>>>>>>>>>>>>>>>>>        // if 0- a stop_ui, if >0, ret value
24372>>>>>>>>>>>>>>>>>        // restore all expected properties
24372>>>>>>>>>>>>>>>>>        Set Auto_Locate_State to OldAutoLoc
24373>>>>>>>>>>>>>>>>>        Set Location to (hi(OldLoc)) (Low(OldLoc))
24374>>>>>>>>>>>>>>>>>        Set pbDisableSaveEnvironment to OldDisableSaveEnv
24375>>>>>>>>>>>>>>>>>        Set MDI_State to OldMDIState
24376>>>>>>>>>>>>>>>>>        Set Maximize_Icon to OldMax
24377>>>>>>>>>>>>>>>>>        Set Minimize_Icon to OldMin
24378>>>>>>>>>>>>>>>>>        Set Block_mouse_State   to OldBMS
24379>>>>>>>>>>>>>>>>>        Set Attach_parent_State to OldAPS
24380>>>>>>>>>>>>>>>>>        Set Popup_State         to OldPS
24381>>>>>>>>>>>>>>>>>        Set Ring_State          to OldRS
24382>>>>>>>>>>>>>>>>>        Set Scope_State         to OldSS
24383>>>>>>>>>>>>>>>>>        Procedure_Return rVal
24384>>>>>>>>>>>>>>>>>        
24384>>>>>>>>>>>>>>>>>    End_Procedure
24385>>>>>>>>>>>>>>>>>    
24385>>>>>>>>>>>>>>>>>End_Class
24386>>>>>>>>>>>>>>>>>
24386>>>>>>>>>>>>>>>>>// logically this is required
24386>>>>>>>>>>>>>>>>>//{ DesignerClass=cDTView }
24386>>>>>>>>>>>>>>>>>Class View is an AppDialog
24387>>>>>>>>>>>>>>>>>End_Class
24388>>>>>>>>>>>>>>>>>
24388>>>>>>>>>>>>>>>
24388>>>>>>>>>>>>>>>
24388>>>>>>>>>>>>>>>Register_Function pbPreserveEnvironment Returns Boolean
24388>>>>>>>>>>>>>>>Register_Procedure Set phoMainPanel Handle hoMain
24388>>>>>>>>>>>>>>>Register_Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
24388>>>>>>>>>>>>>>>Register_Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
24388>>>>>>>>>>>>>>>Register_Procedure Set pbVisible Boolean bVisible
24388>>>>>>>>>>>>>>>Register_Function  pbVisible Returns Boolean
24388>>>>>>>>>>>>>>>
24388>>>>>>>>>>>>>>>
24388>>>>>>>>>>>>>>>
24388>>>>>>>>>>>>>>>Class AppPanel is a BasicPanel
24389>>>>>>>>>>>>>>>    //
24389>>>>>>>>>>>>>>>    //  Panel defaults. Use windows MDI color
24389>>>>>>>>>>>>>>>    //
24389>>>>>>>>>>>>>>>    //
24389>>>>>>>>>>>>>>>    Procedure Construct_Object
24391>>>>>>>>>>>>>>>        Forward Send Construct_Object
24393>>>>>>>>>>>>>>>        
24393>>>>>>>>>>>>>>>        Property Integer Auto_Activate_State True
24394>>>>>>>>>>>>>>>        
24394>>>>>>>>>>>>>>>        // Support status for toolbar and status bar. For now we support
24394>>>>>>>>>>>>>>>        // 0=Hide, 1=Show,
24394>>>>>>>>>>>>>>>        //
24394>>>>>>>>>>>>>>>        Property Integer Private.ToolBar_State  1
24395>>>>>>>>>>>>>>>        
24395>>>>>>>>>>>>>>>        Property Integer Private.StatusBar_State  1
24396>>>>>>>>>>>>>>>        
24396>>>>>>>>>>>>>>>        Property Handle[] phoAutoActivateViews
24397>>>>>>>>>>>>>>>        
24397>>>>>>>>>>>>>>>        Set Scope_State to True
24398>>>>>>>>>>>>>>>        Set Mdi_State to True
24399>>>>>>>>>>>>>>>        
24399>>>>>>>>>>>>>>>        Set Size to 274 479
24400>>>>>>>>>>>>>>>        Set pbSizeToClientArea  to False
24401>>>>>>>>>>>>>>>    End_Procedure
24402>>>>>>>>>>>>>>>    
24402>>>>>>>>>>>>>>>    Procedure Set Auto_Arrange_Icons_State Integer bState
24404>>>>>>>>>>>>>>>        Integer hoClient
24404>>>>>>>>>>>>>>>        Get Client_id to hoClient
24405>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Set Auto_Arrange_Icons_State of hoClient to bState
24408>>>>>>>>>>>>>>>    End_Procedure
24409>>>>>>>>>>>>>>>    
24409>>>>>>>>>>>>>>>    Function Auto_Arrange_Icons_State Returns Integer
24411>>>>>>>>>>>>>>>        Integer hoClient bState
24411>>>>>>>>>>>>>>>        Get Client_id to hoClient
24412>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Get Auto_Arrange_Icons_State of hoClient to bState
24415>>>>>>>>>>>>>>>        Function_Return bState
24416>>>>>>>>>>>>>>>    End_Function
24417>>>>>>>>>>>>>>>    
24417>>>>>>>>>>>>>>>    Procedure Toggle_Auto_Arrange_Icons
24419>>>>>>>>>>>>>>>        Set Auto_Arrange_Icons_State ;            to (not(Auto_Arrange_Icons_State(Self)))
24420>>>>>>>>>>>>>>>    End_Procedure
24421>>>>>>>>>>>>>>>    
24421>>>>>>>>>>>>>>>    Procedure Set Client_Scrollbar_State Integer bState
24423>>>>>>>>>>>>>>>        Integer hoClient
24423>>>>>>>>>>>>>>>        Get Client_id to hoClient
24424>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Set Client_Scrollbar_State of hoClient to bState
24427>>>>>>>>>>>>>>>    End_Procedure
24428>>>>>>>>>>>>>>>    
24428>>>>>>>>>>>>>>>    Function Client_Scrollbar_State Returns Integer
24430>>>>>>>>>>>>>>>        Integer hoClient bState
24430>>>>>>>>>>>>>>>        Get Client_id to hoClient
24431>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Get Client_Scrollbar_State of hoClient to bState
24434>>>>>>>>>>>>>>>        Function_Return bState
24435>>>>>>>>>>>>>>>    End_Function
24436>>>>>>>>>>>>>>>    
24436>>>>>>>>>>>>>>>    Procedure Toggle_Client_Scrollbar_State
24438>>>>>>>>>>>>>>>        Set Client_Scrollbar_State ;            to (not(Client_Scrollbar_State(Self)))
24439>>>>>>>>>>>>>>>    End_Procedure
24440>>>>>>>>>>>>>>>    
24440>>>>>>>>>>>>>>>    Function ToolBar_State Returns Integer
24442>>>>>>>>>>>>>>>        Function_Return (private.Toolbar_State(Self))
24443>>>>>>>>>>>>>>>    End_Function
24444>>>>>>>>>>>>>>>    
24444>>>>>>>>>>>>>>>    Procedure Set Toolbar_State Integer bState
24446>>>>>>>>>>>>>>>        Integer hoToolBar
24446>>>>>>>>>>>>>>>        Handle hoCommandBars
24446>>>>>>>>>>>>>>>        If (bState<>toolbar_State(Self)) Begin
24448>>>>>>>>>>>>>>>            Set private.toolbar_State to bState
24449>>>>>>>>>>>>>>>            
24449>>>>>>>>>>>>>>>            Get phoCommandBars to hoCommandbars
24450>>>>>>>>>>>>>>>            If hoCommandbars ;                Procedure_Return
24453>>>>>>>>>>>>>>>            
24453>>>>>>>>>>>>>>>            If (Window_Handle(Self)) Begin
24455>>>>>>>>>>>>>>>                Get toolBar_ID to hoToolBar
24456>>>>>>>>>>>>>>>                If hoToolBar ;                    Send Activate_Component hoToolBar bState (Focus_Mode(hoToolbar))
24459>>>>>>>>>>>>>>>            End
24459>>>>>>>>>>>>>>>>
24459>>>>>>>>>>>>>>>        End
24459>>>>>>>>>>>>>>>>
24459>>>>>>>>>>>>>>>    End_Procedure
24460>>>>>>>>>>>>>>>    
24460>>>>>>>>>>>>>>>    Procedure Toggle_Toolbar
24462>>>>>>>>>>>>>>>        Set Toolbar_State to (not(Toolbar_State(Self)))
24463>>>>>>>>>>>>>>>    End_Procedure
24464>>>>>>>>>>>>>>>    
24464>>>>>>>>>>>>>>>    Function StatusBar_State Returns Integer
24466>>>>>>>>>>>>>>>        Handle hoCommandBars hoStatusBar
24466>>>>>>>>>>>>>>>        Boolean bState
24466>>>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24467>>>>>>>>>>>>>>>        If hoCommandbars Begin
24469>>>>>>>>>>>>>>>            Get Statusbar_ID to hoStatusBar
24470>>>>>>>>>>>>>>>            If hoStatusBar Begin
24472>>>>>>>>>>>>>>>                Get pbVisible of hoStatusBar to bState
24473>>>>>>>>>>>>>>>            End
24473>>>>>>>>>>>>>>>>
24473>>>>>>>>>>>>>>>        End
24473>>>>>>>>>>>>>>>>
24473>>>>>>>>>>>>>>>        Else Begin
24474>>>>>>>>>>>>>>>            Get private.Statusbar_state to bState
24475>>>>>>>>>>>>>>>        End
24475>>>>>>>>>>>>>>>>
24475>>>>>>>>>>>>>>>        Function_Return bState
24476>>>>>>>>>>>>>>>    End_Function
24477>>>>>>>>>>>>>>>    
24477>>>>>>>>>>>>>>>    Procedure Set Statusbar_State Integer bState
24479>>>>>>>>>>>>>>>        Handle hoStatusBar hoCommandBars
24479>>>>>>>>>>>>>>>        If (bState<>Statusbar_State(Self)) Begin
24481>>>>>>>>>>>>>>>            Set private.Statusbar_State to bState
24482>>>>>>>>>>>>>>>            Get Statusbar_ID to hoStatusBar
24483>>>>>>>>>>>>>>>            
24483>>>>>>>>>>>>>>>            Get phoCommandBars to hoCommandbars
24484>>>>>>>>>>>>>>>            If hoCommandbars Begin
24486>>>>>>>>>>>>>>>                If hoStatusBar Begin
24488>>>>>>>>>>>>>>>                    Set pbVisible of hoStatusBar to bState
24489>>>>>>>>>>>>>>>                End
24489>>>>>>>>>>>>>>>>
24489>>>>>>>>>>>>>>>            End
24489>>>>>>>>>>>>>>>>
24489>>>>>>>>>>>>>>>            Else Begin
24490>>>>>>>>>>>>>>>                If (Window_Handle(Self)) Begin
24492>>>>>>>>>>>>>>>                    If hoStatusBar ;                        Send Activate_Component hoStatusBar bState  nonfocusable
24495>>>>>>>>>>>>>>>                End
24495>>>>>>>>>>>>>>>>
24495>>>>>>>>>>>>>>>            End
24495>>>>>>>>>>>>>>>>
24495>>>>>>>>>>>>>>>        End
24495>>>>>>>>>>>>>>>>
24495>>>>>>>>>>>>>>>    End_Procedure
24496>>>>>>>>>>>>>>>    
24496>>>>>>>>>>>>>>>    Procedure Toggle_Statusbar
24498>>>>>>>>>>>>>>>        Set Statusbar_State to (not(statusbar_State(Self)))
24499>>>>>>>>>>>>>>>    End_Procedure
24500>>>>>>>>>>>>>>>    
24500>>>>>>>>>>>>>>>    Procedure AutoSizeLocate
24502>>>>>>>>>>>>>>>    End_Procedure
24503>>>>>>>>>>>>>>>    
24503>>>>>>>>>>>>>>>    Procedure Size_Components
24505>>>>>>>>>>>>>>>        Integer iToolBar iStatBar //iClient
24505>>>>>>>>>>>>>>>        Integer iSizeToolBar
24505>>>>>>>>>>>>>>>        Handle hoCommandbars
24505>>>>>>>>>>>>>>>        
24505>>>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24506>>>>>>>>>>>>>>>        If hoCommandbars ;            Procedure_Return
24509>>>>>>>>>>>>>>>        
24509>>>>>>>>>>>>>>>        If not (Window_Handle(Self)) ;            Procedure_Return
24512>>>>>>>>>>>>>>>        
24512>>>>>>>>>>>>>>>        Get ToolBar_id   to iToolBar
24513>>>>>>>>>>>>>>>        Get StatusBar_id to iStatBar
24514>>>>>>>>>>>>>>>        //Get Client_id    To iClient
24514>>>>>>>>>>>>>>>        
24514>>>>>>>>>>>>>>>        If (iToolBar and Window_Handle(iToolbar)) Begin
24516>>>>>>>>>>>>>>>            //Send AutoSizeLocate To iToolBar
24516>>>>>>>>>>>>>>>            Get GuiSize of iToolbar to iSizeToolbar
24517>>>>>>>>>>>>>>>            Set GUIsize of iToolbar to (hi(iSizeToolbar)) (low(iSizeToolbar)) // forces auto resize - don't change size
24518>>>>>>>>>>>>>>>            //set GUIsize of iToolbar to 28 800 // forces auto resize
24518>>>>>>>>>>>>>>>        End
24518>>>>>>>>>>>>>>>>
24518>>>>>>>>>>>>>>>        
24518>>>>>>>>>>>>>>>        If (iStatBar and Window_Handle(iStatBar)) Begin
24520>>>>>>>>>>>>>>>            Send AutoSizeLocate to iStatBar
24521>>>>>>>>>>>>>>>        End
24521>>>>>>>>>>>>>>>>
24521>>>>>>>>>>>>>>>    End_Procedure
24522>>>>>>>>>>>>>>>    
24522>>>>>>>>>>>>>>>    Procedure Activate_Component Integer Obj Integer st Integer focusmode
24524>>>>>>>>>>>>>>>        Integer act
24524>>>>>>>>>>>>>>>        If not Obj ;            Procedure_Return
24527>>>>>>>>>>>>>>>        Get Active_State of Obj to act
24528>>>>>>>>>>>>>>>        If (st and act=0) Begin
24530>>>>>>>>>>>>>>>            Set Focus_Mode of obj to focusable
24531>>>>>>>>>>>>>>>            Send Add_focus to obj Self
24532>>>>>>>>>>>>>>>            Set Focus_Mode of obj to focusmode
24533>>>>>>>>>>>>>>>        End
24533>>>>>>>>>>>>>>>>
24533>>>>>>>>>>>>>>>        Else If (st=0 and act) ;            Send deactivate to obj
24537>>>>>>>>>>>>>>>    End_Procedure
24538>>>>>>>>>>>>>>>    
24538>>>>>>>>>>>>>>>    Procedure Add_Components
24540>>>>>>>>>>>>>>>        Integer hClient
24540>>>>>>>>>>>>>>>        Handle hoCommandbars
24540>>>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24541>>>>>>>>>>>>>>>        If not hoCommandbars Begin
24543>>>>>>>>>>>>>>>            Get Client_id to hClient
24544>>>>>>>>>>>>>>>            If (hClient and hClient<>Self ) ; // this forces the client to start at a                Set mdi_top_margin of hClient to (mdi_top_margin(hClient)) // proper size when maximized w/ no components.
24547>>>>>>>>>>>>>>>            Send Activate_Component (Toolbar_Id(Self)) ;                (Toolbar_State(Self)) nonfocusable
24548>>>>>>>>>>>>>>>            Send Activate_Component (Statusbar_Id(Self)) ;                (Statusbar_State(Self)) nonfocusable
24549>>>>>>>>>>>>>>>            Send Size_Components
24550>>>>>>>>>>>>>>>        End
24550>>>>>>>>>>>>>>>>
24550>>>>>>>>>>>>>>>    End_Procedure
24551>>>>>>>>>>>>>>>    
24551>>>>>>>>>>>>>>>    Procedure Activate Returns Integer
24553>>>>>>>>>>>>>>>        Integer bFail
24553>>>>>>>>>>>>>>>        Forward Get MSG_activate to bFail
24555>>>>>>>>>>>>>>>        //If NOT bFail Send Add_Components
24555>>>>>>>>>>>>>>>        Send Add_Components
24556>>>>>>>>>>>>>>>        Set Main_Window to Self
24557>>>>>>>>>>>>>>>        Procedure_Return bFail
24558>>>>>>>>>>>>>>>    End_Procedure
24559>>>>>>>>>>>>>>>    
24559>>>>>>>>>>>>>>>    Procedure Client_Message Integer Msg_Id
24561>>>>>>>>>>>>>>>        Integer hoClient
24561>>>>>>>>>>>>>>>        Get Client_id to hoClient
24562>>>>>>>>>>>>>>>        If (hoClient and hoClient <> Self) ;            Send Msg_id to hoClient
24565>>>>>>>>>>>>>>>    End_Procedure
24566>>>>>>>>>>>>>>>    
24566>>>>>>>>>>>>>>>    Procedure Arrange_Icons
24568>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24569>>>>>>>>>>>>>>>    End_Procedure
24570>>>>>>>>>>>>>>>    
24570>>>>>>>>>>>>>>>    Procedure Cascade_Windows
24572>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24573>>>>>>>>>>>>>>>    End_Procedure
24574>>>>>>>>>>>>>>>    
24574>>>>>>>>>>>>>>>    Procedure Tile_Windows_Horizontal
24576>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24577>>>>>>>>>>>>>>>    End_Procedure
24578>>>>>>>>>>>>>>>    
24578>>>>>>>>>>>>>>>    Procedure Tile_Windows_Vertical
24580>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24581>>>>>>>>>>>>>>>    End_Procedure
24582>>>>>>>>>>>>>>>    
24582>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer sizy Integer sizx
24584>>>>>>>>>>>>>>>        Forward Set GUISize to sizy sizx
24586>>>>>>>>>>>>>>>        If BuildingObjectId ;            Procedure_Return
24589>>>>>>>>>>>>>>>        Send Size_Components
24590>>>>>>>>>>>>>>>    End_Procedure
24591>>>>>>>>>>>>>>>    
24591>>>>>>>>>>>>>>>    //  Returns false to indicate that this is not a DEO. This is used by
24591>>>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
24591>>>>>>>>>>>>>>>    //  send a DEO message. DEO view clients set this true
24591>>>>>>>>>>>>>>>    //
24591>>>>>>>>>>>>>>>    Function Is_Function Integer MsgId Integer ObjId Integer DelegateFg Returns Integer
24593>>>>>>>>>>>>>>>        Integer DelMode rVal Id
24593>>>>>>>>>>>>>>>        Move ( If(DelegateFg,Self,ObjId) ) to Id
24594>>>>>>>>>>>>>>>        Get Delegation_mode of Id to DelMode
24595>>>>>>>>>>>>>>>        Set Delegation_mode of Id to No_Delegate_or_Error
24596>>>>>>>>>>>>>>>        Get MsgId of ObjId to rVal
24597>>>>>>>>>>>>>>>        Set Delegation_mode of Id to DelMode
24598>>>>>>>>>>>>>>>        Function_Return rVal
24599>>>>>>>>>>>>>>>    End_Function
24600>>>>>>>>>>>>>>>    
24600>>>>>>>>>>>>>>>    // In this class this should return an id or nothing (no delegation).
24600>>>>>>>>>>>>>>>    // Note, if no context exists return a 0 or ''.
24600>>>>>>>>>>>>>>>    //
24600>>>>>>>>>>>>>>>    Function Help_Context Integer Context_Type Returns String
24602>>>>>>>>>>>>>>>        Integer ID
24602>>>>>>>>>>>>>>>        String  rVal
24602>>>>>>>>>>>>>>>        
24602>>>>>>>>>>>>>>>        If (Context_Type = HELP_CONTEXT_ID) ;            Get Help_ID to rVal
24605>>>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_KEYWORD) ;            Get Help_Keyword to rVal
24609>>>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_ID_OR_KEY) Begin
24612>>>>>>>>>>>>>>>            Get Help_ID to ID
24613>>>>>>>>>>>>>>>            If (ID = 0) ;                Get Help_Keyword to rVal
24616>>>>>>>>>>>>>>>            Move ID to rVal
24617>>>>>>>>>>>>>>>            If (rval = '') ;                Move 0 to rVal
24620>>>>>>>>>>>>>>>        End
24620>>>>>>>>>>>>>>>>
24620>>>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_DATAFILE) ;            Move '' to rVal
24624>>>>>>>>>>>>>>>        
24624>>>>>>>>>>>>>>>        Function_Return rVal
24625>>>>>>>>>>>>>>>    End_Function
24626>>>>>>>>>>>>>>>    
24626>>>>>>>>>>>>>>>    // Get context based on eContext. If no content found, Don't delegate with panels --- end the search (added to 11.1. See help_mx.pkg)
24626>>>>>>>>>>>>>>>    //
24626>>>>>>>>>>>>>>>    Function HtmlHelpContext Integer eContext String ByRef sContext Returns Integer
24628>>>>>>>>>>>>>>>        Integer eContextFound
24628>>>>>>>>>>>>>>>        Get HtmlHelpObjectContext eContext (&sContext) to eContextFound // context for this one object
24629>>>>>>>>>>>>>>>        Function_Return eContextFound
24630>>>>>>>>>>>>>>>    End_Function
24631>>>>>>>>>>>>>>>    
24631>>>>>>>>>>>>>>>    
24631>>>>>>>>>>>>>>>    // When verify_exit_appliction is received by default just
24631>>>>>>>>>>>>>>>    // send this message to the Mdi-client Id.
24631>>>>>>>>>>>>>>>    //
24631>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24633>>>>>>>>>>>>>>>        Integer Id rVal
24633>>>>>>>>>>>>>>>        Get Client_Id to id
24634>>>>>>>>>>>>>>>        If (Id and Id<>Self) ;            Get Verify_Exit_application of Id to rVal
24637>>>>>>>>>>>>>>>        Function_Return Rval
24638>>>>>>>>>>>>>>>    End_Function
24639>>>>>>>>>>>>>>>    
24639>>>>>>>>>>>>>>>    // When exit notifiction is received by default just
24639>>>>>>>>>>>>>>>    // send this message to the Mdi-client Id.
24639>>>>>>>>>>>>>>>    //
24639>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24641>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24642>>>>>>>>>>>>>>>        
24642>>>>>>>>>>>>>>>        Forward Send Notify_Exit_Application
24644>>>>>>>>>>>>>>>    End_Procedure
24645>>>>>>>>>>>>>>>    
24645>>>>>>>>>>>>>>>    Procedure Minimize_all_Windows
24647>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24648>>>>>>>>>>>>>>>    End_Procedure
24649>>>>>>>>>>>>>>>    
24649>>>>>>>>>>>>>>>    Procedure Restore_all_Windows
24651>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24652>>>>>>>>>>>>>>>    End_Procedure
24653>>>>>>>>>>>>>>>    
24653>>>>>>>>>>>>>>>    // augmented to  activate if required
24653>>>>>>>>>>>>>>>    //
24653>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24655>>>>>>>>>>>>>>>        Forward Send End_Construct_object
24657>>>>>>>>>>>>>>>        If (Auto_activate_state(Self)) ;            Send Activate
24660>>>>>>>>>>>>>>>    End_Procedure
24661>>>>>>>>>>>>>>>    
24661>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
24663>>>>>>>>>>>>>>>        Integer iError i iViews
24663>>>>>>>>>>>>>>>        Handle[] hoAutoActivateViews
24664>>>>>>>>>>>>>>>        Forward Get msg_Add_Focus hoParent to iError
24666>>>>>>>>>>>>>>>        If (iError=0) Begin
24668>>>>>>>>>>>>>>>            Get phoAutoActivateViews to hoAutoActivateViews
24669>>>>>>>>>>>>>>>            Move (SizeOfArray(hoAutoActivateViews)) to iViews
24670>>>>>>>>>>>>>>>            For i from 0 to (iViews-1)
24676>>>>>>>>>>>>>>>>
24676>>>>>>>>>>>>>>>                Send Activate_View of hoAutoActivateViews[i]
24677>>>>>>>>>>>>>>>            Loop
24678>>>>>>>>>>>>>>>>
24678>>>>>>>>>>>>>>>        End
24678>>>>>>>>>>>>>>>>
24678>>>>>>>>>>>>>>>    End_Procedure
24679>>>>>>>>>>>>>>>    
24679>>>>>>>>>>>>>>>    // adds a view to the array of views to be autoactivated
24679>>>>>>>>>>>>>>>    
24679>>>>>>>>>>>>>>>    Procedure AddAutoActivateView Handle hoView
24681>>>>>>>>>>>>>>>        Handle[] hoAutoActivateViews
24682>>>>>>>>>>>>>>>        Get phoAutoActivateViews to hoAutoActivateViews
24683>>>>>>>>>>>>>>>        Move hoView to hoAutoActivateViews[SizeOfArray(hoAutoActivateViews)]
24684>>>>>>>>>>>>>>>        Set phoAutoActivateViews to hoAutoActivateViews
24685>>>>>>>>>>>>>>>    End_Procedure
24686>>>>>>>>>>>>>>>    
24686>>>>>>>>>>>>>>>End_Class
24687>>>>>>>>>>>>>>>
24687>>>>>>>>>>>>>>>
24687>>>>>>>>>>>>>>>Use DFCursor.pkg
24687>>>>>>>>>>>>>>>
24687>>>>>>>>>>>>>>>//  Main DEO High level main Panel Class
24687>>>>>>>>>>>>>>>//
24687>>>>>>>>>>>>>>>Class Panel is a AppPanel
24688>>>>>>>>>>>>>>>    
24688>>>>>>>>>>>>>>>    Procedure Construct_Object
24690>>>>>>>>>>>>>>>        String St
24690>>>>>>>>>>>>>>>        Integer iVal
24690>>>>>>>>>>>>>>>        DWord dwState
24690>>>>>>>>>>>>>>>        Forward Send Construct_Object
24692>>>>>>>>>>>>>>>        
24692>>>>>>>>>>>>>>>        // defaults to hourglass...end_construct will remove
24692>>>>>>>>>>>>>>>        Send Cursor_wait to (Cursor_Control(Self)) // hourglass
24693>>>>>>>>>>>>>>>        
24693>>>>>>>>>>>>>>>        Set private_pbEnvironmentProgram to True
24694>>>>>>>>>>>>>>>    End_Procedure
24695>>>>>>>>>>>>>>>    
24695>>>>>>>>>>>>>>>    
24695>>>>>>>>>>>>>>>    // This sends the message register_active_view to all child objects.
24695>>>>>>>>>>>>>>>    // It passes the object ID of the object that is requesting this
24695>>>>>>>>>>>>>>>    // information. The flag BCast_Focus determines if this should
24695>>>>>>>>>>>>>>>    // broadcast or broadcast_focus
24695>>>>>>>>>>>>>>>    //
24695>>>>>>>>>>>>>>>    Procedure Notify_All_Views Integer Msg Integer obj Integer Bcast_Focus
24697>>>>>>>>>>>>>>>        Integer clobj
24697>>>>>>>>>>>>>>>        Get Client_ID to clObj
24698>>>>>>>>>>>>>>>        If (ClObj = 0) ;            Move Self to ClObj
24701>>>>>>>>>>>>>>>        If BCast_Focus ;            Broadcast_Focus Send Msg to Clobj obj
24705>>>>>>>>>>>>>>>        Else ;            Broadcast       Send Msg to Clobj obj
24708>>>>>>>>>>>>>>>    End_Procedure
24709>>>>>>>>>>>>>>>    
24709>>>>>>>>>>>>>>>
24709>>>>>>>>>>>>>>>    
24709>>>>>>>>>>>>>>>    // augmented to remove hourglass
24709>>>>>>>>>>>>>>>    //
24709>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24711>>>>>>>>>>>>>>>        // if application object exists, we need to tell that object that we are the main panel
24711>>>>>>>>>>>>>>>        If ghoApplication ;            Set phoMainPanel of ghoApplication to Self
24714>>>>>>>>>>>>>>>        Forward Send End_Construct_object
24716>>>>>>>>>>>>>>>        Send Cursor_ready to (Cursor_Control(Self)) // restore
24717>>>>>>>>>>>>>>>    End_Procedure
24718>>>>>>>>>>>>>>>    
24718>>>>>>>>>>>>>>>    Procedure Page Integer iState
24720>>>>>>>>>>>>>>>        Forward Send Page iState
24722>>>>>>>>>>>>>>>        If (iState =1) Begin
24724>>>>>>>>>>>>>>>            Send Load_Environment
24725>>>>>>>>>>>>>>>        End
24725>>>>>>>>>>>>>>>>
24725>>>>>>>>>>>>>>>    End_Procedure
24726>>>>>>>>>>>>>>>    
24726>>>>>>>>>>>>>>>End_Class
24727>>>>>>>>>>>>>>>
24727>>>>>>>>>>>>>>>//  Main DEO High level main MDI Client Class
24727>>>>>>>>>>>>>>>//
24727>>>>>>>>>>>>>>>//  Currently there is nothing special about this class but it was
24727>>>>>>>>>>>>>>>//  created because it is logically correct. Extensions may go here in
24727>>>>>>>>>>>>>>>//  the futire
24727>>>>>>>>>>>>>>>Class ClientArea is a AppClientArea
24728>>>>>>>>>>>>>>>End_Class
24729>>>>>>>>>>>>>>>
24729>>>>>>>>>>>>>Use EnClient.pkg
Including file: Enclient.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Enclient.pkg)
24729>>>>>>>>>>>>>>>Use windows.pkg
24729>>>>>>>>>>>>>>>Use NESTING.pkg       //include DEO nesting standard support module
Including file: nesting.pkg    (C:\Program Files\DataFlex 23.0\Pkg\nesting.pkg)
24729>>>>>>>>>>>>>>>>>Use VDFBase.pkg
24729>>>>>>>>>>>>>>>>>
24729>>>>>>>>>>>>>>>>>Class nesting_mixin is a mixin
24730>>>>>>>>>>>>>>>>>    
24730>>>>>>>>>>>>>>>>>    //   Component_State indicates if this object has a parent object which is
24730>>>>>>>>>>>>>>>>>    //   also a data-entry object.
24730>>>>>>>>>>>>>>>>>    //
24730>>>>>>>>>>>>>>>>>    //   Has_Components_State indicates if this object has at least one child-
24730>>>>>>>>>>>>>>>>>    //   object which is also a data-entry object.
24730>>>>>>>>>>>>>>>>>    //
24730>>>>>>>>>>>>>>>>>    //   First_DEO and Last_DEO are used temporarily during the searches for
24730>>>>>>>>>>>>>>>>>    //   the first and last data-entry object children of this object (see
24730>>>>>>>>>>>>>>>>>    //   Find_First_DEO, Find_Last_DEO, Inquire_First_DEO and Inquire_Last_DEO).
24730>>>>>>>>>>>>>>>>>    //
24730>>>>>>>>>>>>>>>>>    Procedure define_nesting
24732>>>>>>>>>>>>>>>>>        Property Integer Component_State        0
24733>>>>>>>>>>>>>>>>>        Property Integer Has_Components_State   0
24734>>>>>>>>>>>>>>>>>        Property Integer First_DEO              0
24735>>>>>>>>>>>>>>>>>        Property Integer Last_DEO               0
24736>>>>>>>>>>>>>>>>>        
24736>>>>>>>>>>>>>>>>>        // Stop_ui support - Moved from its own mixin package.
24736>>>>>>>>>>>>>>>>>        Property Integer Stop_UI_State False
24737>>>>>>>>>>>>>>>>>        
24737>>>>>>>>>>>>>>>>>    End_Procedure
24738>>>>>>>>>>>>>>>>>    
24738>>>>>>>>>>>>>>>>>    
24738>>>>>>>>>>>>>>>>>    //   This procedure is used to locate the first data-entry object among
24738>>>>>>>>>>>>>>>>>    //   this object's siblings (its parent's children).
24738>>>>>>>>>>>>>>>>>    //
24738>>>>>>>>>>>>>>>>>    //   This procedure is typically invoked via the BROADCAST command from
24738>>>>>>>>>>>>>>>>>    //   the Find_First_DEO function of this object's parent.
24738>>>>>>>>>>>>>>>>>    //
24738>>>>>>>>>>>>>>>>>    Procedure inquire_first_DEO Integer obj# Integer recurseClients
24740>>>>>>>>>>>>>>>>>        If (focus_mode(Self) = FOCUSABLE) Begin
24742>>>>>>>>>>>>>>>>>            If (recurseClients and client_area_state(Self)) ;                Broadcast_Focus Send inquire_first_DEO obj# recurseClients
24746>>>>>>>>>>>>>>>>>            Else Begin
24747>>>>>>>>>>>>>>>>>                Set first_DEO of obj# to Self
24748>>>>>>>>>>>>>>>>>                Procedure_Return 1  //to stop broadcast, since this object answered
24749>>>>>>>>>>>>>>>>>            End
24749>>>>>>>>>>>>>>>>>>
24749>>>>>>>>>>>>>>>>>        End
24749>>>>>>>>>>>>>>>>>>
24749>>>>>>>>>>>>>>>>>    End_Procedure
24750>>>>>>>>>>>>>>>>>    
24750>>>>>>>>>>>>>>>>>    //   If this object is focusable, set Lastt_DEO to this object's id.
24750>>>>>>>>>>>>>>>>>    //
24750>>>>>>>>>>>>>>>>>    //   This procedure is used to locate the last data-entry object among
24750>>>>>>>>>>>>>>>>>    //   this object's siblings (its parent's children).
24750>>>>>>>>>>>>>>>>>    //
24750>>>>>>>>>>>>>>>>>    //   This procedure is typically invoked via the BROADCAST command from
24750>>>>>>>>>>>>>>>>>    //   the Find_Last_DEO function of this object's parent.
24750>>>>>>>>>>>>>>>>>    //
24750>>>>>>>>>>>>>>>>>    Procedure inquire_last_DEO Integer obj# Integer recurseClients
24752>>>>>>>>>>>>>>>>>        If (focus_mode(Self) = FOCUSABLE) Begin
24754>>>>>>>>>>>>>>>>>            If (recurseClients and client_area_state(Self)) ;                Broadcast_Focus Send inquire_last_DEO obj# recurseClients
24758>>>>>>>>>>>>>>>>>            Else ;                Set last_DEO of obj# to Self
24760>>>>>>>>>>>>>>>>>        End
24760>>>>>>>>>>>>>>>>>>
24760>>>>>>>>>>>>>>>>>    End_Procedure
24761>>>>>>>>>>>>>>>>>    
24761>>>>>>>>>>>>>>>>>    //   This function returns the object id of the first data-entry object
24761>>>>>>>>>>>>>>>>>    //   which is a child of this object, or 0.
24761>>>>>>>>>>>>>>>>>    //
24761>>>>>>>>>>>>>>>>>    //   This function 'searches' by broadcasting Inquire_First_DEO, which
24761>>>>>>>>>>>>>>>>>    //   returns a 1 to terminate the broadcast after the first data-entry
24761>>>>>>>>>>>>>>>>>    //   object has been located.
24761>>>>>>>>>>>>>>>>>    //
24761>>>>>>>>>>>>>>>>>    Function find_first_DEO Returns Integer
24763>>>>>>>>>>>>>>>>>        Set First_DEO to 0
24764>>>>>>>>>>>>>>>>>        Broadcast_Focus Send inquire_first_DEO Self False //sets First_DEO property
24766>>>>>>>>>>>>>>>>>        Function_Return (first_deo(Self))
24767>>>>>>>>>>>>>>>>>    End_Function
24768>>>>>>>>>>>>>>>>>    
24768>>>>>>>>>>>>>>>>>    
24768>>>>>>>>>>>>>>>>>    //   This function returns the object id of the last data-entry object
24768>>>>>>>>>>>>>>>>>    //   which is a child of this object, or 0.
24768>>>>>>>>>>>>>>>>>    //
24768>>>>>>>>>>>>>>>>>    //   This function 'searches' by broadcasting Inquire_Last_DEO, which sets
24768>>>>>>>>>>>>>>>>>    //   the property Last_DEO.  Thus, the last object reached by the broadcast
24768>>>>>>>>>>>>>>>>>    //   is the last value to be set into Last_DEO.
24768>>>>>>>>>>>>>>>>>    //
24768>>>>>>>>>>>>>>>>>    Function find_last_DEO Returns Integer
24770>>>>>>>>>>>>>>>>>        Set Last_DEO to 0
24771>>>>>>>>>>>>>>>>>        Broadcast_Focus Send inquire_last_DEO Self False //sets Last_DEO property
24773>>>>>>>>>>>>>>>>>        Function_Return (Last_DEO(Self))
24774>>>>>>>>>>>>>>>>>    End_Function
24775>>>>>>>>>>>>>>>>>    
24775>>>>>>>>>>>>>>>>>    //   Removes this object from the screen and focus-tree, and also removes
24775>>>>>>>>>>>>>>>>>    //   this object's children from the screen and focus-tree.
24775>>>>>>>>>>>>>>>>>    //
24775>>>>>>>>>>>>>>>>>    //   If no flag argument was passed, AREA_TYPE becomes the flag parameter.
24775>>>>>>>>>>>>>>>>>    //
24775>>>>>>>>>>>>>>>>>    //   Client-objects already automatically remove their children from the
24775>>>>>>>>>>>>>>>>>    //   focus-tree.
24775>>>>>>>>>>>>>>>>>    //
24775>>>>>>>>>>>>>>>>>    Procedure Deactivate Integer eDeactivateScope Returns Integer
24777>>>>>>>>>>>>>>>>>        Integer retval Fg
24777>>>>>>>>>>>>>>>>>        If (num_arguments > 0) ;            Move eDeactivateScope to Fg
24780>>>>>>>>>>>>>>>>>        Else ;            Move AREA_TYPE to Fg
24782>>>>>>>>>>>>>>>>>        Forward Get msg_deactivate fg to retval
24784>>>>>>>>>>>>>>>>>        
24784>>>>>>>>>>>>>>>>>        If ( not(retval) and (fg = 0) ) Begin
24786>>>>>>>>>>>>>>>>>            
24786>>>>>>>>>>>>>>>>>            // This broadcast no_stop is probably not ever used, but would be if a
24786>>>>>>>>>>>>>>>>>            // child was in the focus tree, but not as a focus-child. weird, but needs be here.
24786>>>>>>>>>>>>>>>>>            If ( client_Area_state(Self)=0) ;                Broadcast NO_STOP Send deactivate 0
24791>>>>>>>>>>>>>>>>>            
24791>>>>>>>>>>>>>>>>>            If ( Stop_UI_State(Self) ) ;                Send Stop_Ui
24794>>>>>>>>>>>>>>>>>        End
24794>>>>>>>>>>>>>>>>>>
24794>>>>>>>>>>>>>>>>>        Procedure_Return retval
24795>>>>>>>>>>>>>>>>>    End_Procedure
24796>>>>>>>>>>>>>>>>>    
24796>>>>>>>>>>>>>>>>>    //   This procedure marks an object as a child data-entry object, and
24796>>>>>>>>>>>>>>>>>    //   attempts to use its parent's Server if this object has no Server.
24796>>>>>>>>>>>>>>>>>    //   Typically sent via broadcast from parent DEO.
24796>>>>>>>>>>>>>>>>>    //
24796>>>>>>>>>>>>>>>>>    Procedure Mark_As_Component
24798>>>>>>>>>>>>>>>>>        Set Component_State to True
24799>>>>>>>>>>>>>>>>>        Delegate Set Has_Components_State to True
24801>>>>>>>>>>>>>>>>>    End_Procedure
24802>>>>>>>>>>>>>>>>>    
24802>>>>>>>>>>>>>>>>>    
24802>>>>>>>>>>>>>>>>>    //   This procedure marks child data-entry objects as components.
24802>>>>>>>>>>>>>>>>>    //
24802>>>>>>>>>>>>>>>>>    //   The child data-entry objects must understand Mark_As_Component as a
24802>>>>>>>>>>>>>>>>>    //   method of setting their Component_State to TRUE.
24802>>>>>>>>>>>>>>>>>    Procedure Mark_Components
24804>>>>>>>>>>>>>>>>>        Set Component_State to False
24805>>>>>>>>>>>>>>>>>        Broadcast Send Mark_As_Component
24807>>>>>>>>>>>>>>>>>    End_Procedure
24808>>>>>>>>>>>>>>>>>End_Class
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>Use NAVIGATE.pkg      //include DEO navigation standard support module
Including file: navigate.pkg    (C:\Program Files\DataFlex 23.0\Pkg\navigate.pkg)
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>>>Use VDFBase.pkg
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>>>Register_Function verify_data_loss Returns Integer
24809>>>>>>>>>>>>>>>>>
24809>>>>>>>>>>>>>>>>>Class navigate_mixin is a mixin
24810>>>>>>>>>>>>>>>>>    
24810>>>>>>>>>>>>>>>>>    Procedure define_navigation
24812>>>>>>>>>>>>>>>>>        On_Key kBegin_of_Panel    Send Beginning_of_Panel PRIVATE
24813>>>>>>>>>>>>>>>>>        On_Key kCancel            Send Request_Cancel     PRIVATE
24814>>>>>>>>>>>>>>>>>        On_Key kEnd_of_Panel      Send End_of_Panel       PRIVATE
24815>>>>>>>>>>>>>>>>>        On_Key kExit_Function     Send Exit_Function      PRIVATE
24816>>>>>>>>>>>>>>>>>        On_Key kSwitch            Send Switch             PRIVATE
24817>>>>>>>>>>>>>>>>>        On_Key kSwitch_Back       Send Switch_Back        PRIVATE
24818>>>>>>>>>>>>>>>>>        Property Integer Auto_Top_Panel_State             True
24819>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Exit_Msg          0
24820>>>>>>>>>>>>>>>>>    End_Procedure
24821>>>>>>>>>>>>>>>>>    
24821>>>>>>>>>>>>>>>>>    Function Verify_Exit_msg Returns Integer
24823>>>>>>>>>>>>>>>>>        Integer msg#
24823>>>>>>>>>>>>>>>>>        Get private.verify_exit_msg to msg#
24824>>>>>>>>>>>>>>>>>        If (msg# = 0 and Component_State(Self)) ;            Delegate Get verify_exit_msg to msg#
24828>>>>>>>>>>>>>>>>>        Function_Return msg#
24829>>>>>>>>>>>>>>>>>    End_Function
24830>>>>>>>>>>>>>>>>>    
24830>>>>>>>>>>>>>>>>>    
24830>>>>>>>>>>>>>>>>>    Procedure Set Verify_Exit_msg Integer msg#
24832>>>>>>>>>>>>>>>>>        Set private.verify_Exit_Msg to msg#
24833>>>>>>>>>>>>>>>>>    End_Procedure
24834>>>>>>>>>>>>>>>>>    
24834>>>>>>>>>>>>>>>>>    
24834>>>>>>>>>>>>>>>>>    Function Verify_Exit Returns Integer
24836>>>>>>>>>>>>>>>>>        Integer msg#
24836>>>>>>>>>>>>>>>>>        Get verify_Exit_msg to msg#
24837>>>>>>>>>>>>>>>>>        If (msg# <> 0) ;            Get msg# to msg#
24840>>>>>>>>>>>>>>>>>        Function_Return msg#
24841>>>>>>>>>>>>>>>>>    End_Function
24842>>>>>>>>>>>>>>>>>    
24842>>>>>>>>>>>>>>>>>    
24842>>>>>>>>>>>>>>>>>    
24842>>>>>>>>>>>>>>>>>    
24842>>>>>>>>>>>>>>>>>    //   The deactivate message-send passes AREA_FLAG, which means that we want
24842>>>>>>>>>>>>>>>>>    //   to deactivate the object in the focus tree which is either a scope
24842>>>>>>>>>>>>>>>>>    //   (i.e. Scope_State = TRUE) or a pop-up (i.e. PopUp_State = TRUE), and
24842>>>>>>>>>>>>>>>>>    //   which is closest to this object in an 'upward' direction (i.e.
24842>>>>>>>>>>>>>>>>>    //   client/parent, not child or sibling).
24842>>>>>>>>>>>>>>>>>    //
24842>>>>>>>>>>>>>>>>>    Procedure Request_Cancel
24844>>>>>>>>>>>>>>>>>        Integer foc#
24844>>>>>>>>>>>>>>>>>        If (verify_exit(Self) = 0) Begin
24846>>>>>>>>>>>>>>>>>            Send deactivate AREA_FLAG
24847>>>>>>>>>>>>>>>>>            Get focus of desktop to foc#
24848>>>>>>>>>>>>>>>>>            If (foc# and skip_State(foc#)) ;                Send switch to foc#
24851>>>>>>>>>>>>>>>>>        End
24851>>>>>>>>>>>>>>>>>>
24851>>>>>>>>>>>>>>>>>    End_Procedure
24852>>>>>>>>>>>>>>>>>    
24852>>>>>>>>>>>>>>>>>    
24852>>>>>>>>>>>>>>>>>    
24852>>>>>>>>>>>>>>>>>    Procedure Exit_Function
24854>>>>>>>>>>>>>>>>>        Send request_cancel
24855>>>>>>>>>>>>>>>>>    End_Procedure
24856>>>>>>>>>>>>>>>>>    
24856>>>>>>>>>>>>>>>>>End_Class
24857>>>>>>>>>>>>>>>>>
24857>>>>>>>>>>>>>>>>>
24857>>>>>>>>>>>>>>>>>
24857>>>>>>>>>>>>>>>Use SERVER.pkg        //include Server support module
Including file: Server.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Server.pkg)
24857>>>>>>>>>>>>>>>>>
24857>>>>>>>>>>>>>>>>>Use VDFBase.pkg
24857>>>>>>>>>>>>>>>>>Use brdcster.pkg
Including file: brdcster.pkg    (C:\Program Files\DataFlex 23.0\Pkg\brdcster.pkg)
24857>>>>>>>>>>>>>>>>>>>Use Set.pkg
24857>>>>>>>>>>>>>>>>>>>
24857>>>>>>>>>>>>>>>>>>>//   This class is defined as a subclass of Set with a C language handler
24857>>>>>>>>>>>>>>>>>>>//   providing additional behavior.
24857>>>>>>>>>>>>>>>>>>>//
24857>>>>>>>>>>>>>>>>>>>Class Broadcaster is a Set 0 0 Broadcast_Handler
24858>>>>>>>>>>>>>>>>>>>End_Class
24859>>>>>>>>>>>>>>>>>>>
24859>>>>>>>>>>>>>>>>>>>
24859>>>>>>>>>>>>>>>>>>>Function make_broadcaster for cDesktop Returns Integer
24861>>>>>>>>>>>>>>>>>>>    Integer obj#
24861>>>>>>>>>>>>>>>>>>>    Object broadcasterTemplate is a broadcaster
24863>>>>>>>>>>>>>>>>>>>        Move Self to obj#
24864>>>>>>>>>>>>>>>>>>>    End_Object
24865>>>>>>>>>>>>>>>>>>>    Function_Return obj#
24866>>>>>>>>>>>>>>>>>>>End_Function
24867>>>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>Register_Procedure Item_Find Integer mode Integer datafile Integer datafield ;    Integer entUpdtFlag Integer errFlag Integer dfrdFlag
24867>>>>>>>>>>>>>>>>>Register_Procedure Add_User_Interface Integer obj#
24867>>>>>>>>>>>>>>>>>Register_Procedure Remove_User_Interface Integer obj#
24867>>>>>>>>>>>>>>>>>Register_Procedure Clear
24867>>>>>>>>>>>>>>>>>Register_Function  Component_State Returns Integer
24867>>>>>>>>>>>>>>>>>Register_Function  Can_Delete Returns Integer
24867>>>>>>>>>>>>>>>>>Register_Object Element
24867>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>// Values for DSO_Detach_Mode
24867>>>>>>>>>>>>>>>>>//   DETACH_NEVER        = Never
24867>>>>>>>>>>>>>>>>>//   DETACH_IF_ALLOWED   = do if changed_state=F and DEO Static_Server
24867>>>>>>>>>>>>>>>>>//   DETACH_IF_NO_CHANGE = do if changed_state=F
24867>>>>>>>>>>>>>>>>>//   DETACH_ALWAYS       = do it no matter what
24867>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>Enumeration_List
24867>>>>>>>>>>>>>>>>>    Define Detach_Never
24867>>>>>>>>>>>>>>>>>    Define Detach_If_No_Change
24867>>>>>>>>>>>>>>>>>    Define Detach_Always
24867>>>>>>>>>>>>>>>>>    Define Detach_If_Allowed
24867>>>>>>>>>>>>>>>>>End_Enumeration_List
24867>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>
24867>>>>>>>>>>>>>>>>>Class server_mixin is a mixin
24868>>>>>>>>>>>>>>>>>    
24868>>>>>>>>>>>>>>>>>    //   Server is the object id of the database agent for this object.
24868>>>>>>>>>>>>>>>>>    //
24868>>>>>>>>>>>>>>>>>    //   Watched_Servers is a set of object ids for database agents whose state
24868>>>>>>>>>>>>>>>>>    //   must also be monitored by this object (but which never receive requests
24868>>>>>>>>>>>>>>>>>    //   directly from this object, unlike the Server).
24868>>>>>>>>>>>>>>>>>    //
24868>>>>>>>>>>>>>>>>>    //   Servers_Scanned determines if the items of this object have been
24868>>>>>>>>>>>>>>>>>    //   scanned to see if this object should be connected to other database
24868>>>>>>>>>>>>>>>>>    //   agents as 'just watching' (see Watched_Servers, above).
24868>>>>>>>>>>>>>>>>>    //
24868>>>>>>>>>>>>>>>>>    //   Auto_Fill_State determines if this object should always automatically
24868>>>>>>>>>>>>>>>>>    //   fill itself with data when it is activated.
24868>>>>>>>>>>>>>>>>>    //
24868>>>>>>>>>>>>>>>>>    //   Deferred_State determines if this object's browsing in database files
24868>>>>>>>>>>>>>>>>>    //   should be reflected immediately in this object's database agent (and
24868>>>>>>>>>>>>>>>>>    //   the agents' agents, etc.), or not.
24868>>>>>>>>>>>>>>>>>    //
24868>>>>>>>>>>>>>>>>>    //
24868>>>>>>>>>>>>>>>>>    Procedure define_server
24870>>>>>>>>>>>>>>>>>        Integer obj#
24870>>>>>>>>>>>>>>>>>        Property Integer private.Server           0
24871>>>>>>>>>>>>>>>>>        Property Integer Watched_Servers          0
24872>>>>>>>>>>>>>>>>>        // used to send Set Changed_State to "foreign" servers, while Watched_Servers
24872>>>>>>>>>>>>>>>>>        // is used for sending messages from the DDO to DEOs (there are more of them)
24872>>>>>>>>>>>>>>>>>        Property Integer ChangedStateWatched_Servers     0
24873>>>>>>>>>>>>>>>>>        Property Integer private.Servers_Scanned  0
24874>>>>>>>>>>>>>>>>>        
24874>>>>>>>>>>>>>>>>>        Property Integer Auto_Fill_State False
24875>>>>>>>>>>>>>>>>>        Property Integer Deferred_State  False
24876>>>>>>>>>>>>>>>>>        
24876>>>>>>>>>>>>>>>>>        // added to support DEO request-delegation. This is set true
24876>>>>>>>>>>>>>>>>>        // if the server is explicitly set in this DEO (normally via a
24876>>>>>>>>>>>>>>>>>        // USING parameter).
24876>>>>>>>>>>>>>>>>>        Property Integer explicit_server_state False
24877>>>>>>>>>>>>>>>>>        
24877>>>>>>>>>>>>>>>>>        // Since this package's SET changed_state is using change_
24877>>>>>>>>>>>>>>>>>        // disabled_state we might as well define it here. This gets changed
24877>>>>>>>>>>>>>>>>>        // by Clear_mx to support setting of defaults without changing the
24877>>>>>>>>>>>>>>>>>        // objects changed_state.
24877>>>>>>>>>>>>>>>>>        
24877>>>>>>>>>>>>>>>>>        // This stops changed_state from getting changed. It allows item_changed_
24877>>>>>>>>>>>>>>>>>        // state to chagne without the object's changed_state getting changed.
24877>>>>>>>>>>>>>>>>>        // This should be considered protected (i.e., likely to change). The new
24877>>>>>>>>>>>>>>>>>        // messages Entry_Defaults and Set Default_Value are both public and use
24877>>>>>>>>>>>>>>>>>        // this. Try to use these messages instead of this property.
24877>>>>>>>>>>>>>>>>>        Property Integer Change_Disabled_State  False
24878>>>>>>>>>>>>>>>>>        
24878>>>>>>>>>>>>>>>>>        // If true DEO will not disconnect from server when deactivating.
24878>>>>>>>>>>>>>>>>>        // If true View should handles attaching and detaching.
24878>>>>>>>>>>>>>>>>>        Register_Function Default_static_server_state Returns Integer
24878>>>>>>>>>>>>>>>>>        Property Integer Static_Server_State  (Default_Static_Server_State(Self))
24879>>>>>>>>>>>>>>>>>        
24879>>>>>>>>>>>>>>>>>        // Properties to better support tables. If Refresh_dirty_state
24879>>>>>>>>>>>>>>>>>        // is true then the list object needs refreshing (because it was inactive
24879>>>>>>>>>>>>>>>>>        // and changes were made that were not updated). After add_focus is
24879>>>>>>>>>>>>>>>>>        // complete the add_focus_msg is sent (allows tables to initialize the
24879>>>>>>>>>>>>>>>>>        // list).
24879>>>>>>>>>>>>>>>>>        Property Integer Refresh_dirty_state  True // when not active/dirty
24880>>>>>>>>>>>>>>>>>        Property Integer Add_focus_msg        0    // by dflt no message
24881>>>>>>>>>>>>>>>>>        
24881>>>>>>>>>>>>>>>>>        // This will call a stub procedure which will be augmented (or replaced)
24881>>>>>>>>>>>>>>>>>        // by the xdeo mixins
24881>>>>>>>>>>>>>>>>>        Send Define_Extended_DEO_Mixin
24882>>>>>>>>>>>>>>>>>        
24882>>>>>>>>>>>>>>>>>    End_Procedure
24883>>>>>>>>>>>>>>>>>    
24883>>>>>>>>>>>>>>>>>    
24883>>>>>>>>>>>>>>>>>    Procedure remove_deo_from_server
24885>>>>>>>>>>>>>>>>>        Integer obj# isclient wsrvr
24885>>>>>>>>>>>>>>>>>        Get Server to obj#
24886>>>>>>>>>>>>>>>>>        // as of 17.0, containers will be added as a DEO so it receives the Refresh message
24886>>>>>>>>>>>>>>>>>        If (obj# <> 0) ;            Send remove_user_interface to obj# Self
24889>>>>>>>>>>>>>>>>>        Get Watched_Servers to wsrvr
24890>>>>>>>>>>>>>>>>>        If wsrvr ;            Send remove_user_interface to wsrvr Self True // TRUE for watchers
24893>>>>>>>>>>>>>>>>>        Set Refresh_dirty_state to True
24894>>>>>>>>>>>>>>>>>    End_Procedure
24895>>>>>>>>>>>>>>>>>    
24895>>>>>>>>>>>>>>>>>    
24895>>>>>>>>>>>>>>>>>    //   This function returns the object id of the database server which
24895>>>>>>>>>>>>>>>>>    //   encloses this object, if any.  Note that only the Data_Set class
24895>>>>>>>>>>>>>>>>>    //   defines this function to return anything other than 0.
24895>>>>>>>>>>>>>>>>>    //
24895>>>>>>>>>>>>>>>>>    //   This function is used with delegation to locate the Data_Set
24895>>>>>>>>>>>>>>>>>    //   which is the closest parent of this object.
24895>>>>>>>>>>>>>>>>>    //
24895>>>>>>>>>>>>>>>>>    Function Find_Server Returns Integer
24897>>>>>>>>>>>>>>>>>    End_Function
24898>>>>>>>>>>>>>>>>>    
24898>>>>>>>>>>>>>>>>>    Register_Function Server Returns Integer
24898>>>>>>>>>>>>>>>>>    
24898>>>>>>>>>>>>>>>>>    
24898>>>>>>>>>>>>>>>>>    //   This function returns the object id of the database agent of this object,
24898>>>>>>>>>>>>>>>>>    //   or 0.
24898>>>>>>>>>>>>>>>>>    Function Locate_Server Returns Integer
24900>>>>>>>>>>>>>>>>>        Function_Return (Server(Self))
24901>>>>>>>>>>>>>>>>>    End_Function
24902>>>>>>>>>>>>>>>>>    
24902>>>>>>>>>>>>>>>>>    
24902>>>>>>>>>>>>>>>>>    //   This function returns the object id of the database agent of this
24902>>>>>>>>>>>>>>>>>    //   object, or 0.
24902>>>>>>>>>>>>>>>>>    //   If this object's Server is 0, this object's parent's Server is
24902>>>>>>>>>>>>>>>>>    //   returned, if any.
24902>>>>>>>>>>>>>>>>>    //
24902>>>>>>>>>>>>>>>>>    // Notes
24902>>>>>>>>>>>>>>>>>    //
24902>>>>>>>>>>>>>>>>>    //   This function is used to allow nested data-entry objects to use the
24902>>>>>>>>>>>>>>>>>    //   database agent defined by their parent object.
24902>>>>>>>>>>>>>>>>>    //
24902>>>>>>>>>>>>>>>>>    Function Server Returns Integer
24904>>>>>>>>>>>>>>>>>        Integer obj#
24904>>>>>>>>>>>>>>>>>        Get private.Server to obj#
24905>>>>>>>>>>>>>>>>>        If (obj# = 0 and Component_State(Self)) ;            Function_Return (Locate_Server(parent(Self)))
24908>>>>>>>>>>>>>>>>>        Function_Return obj#
24909>>>>>>>>>>>>>>>>>    End_Function
24910>>>>>>>>>>>>>>>>>    
24910>>>>>>>>>>>>>>>>>    
24910>>>>>>>>>>>>>>>>>    //   This procedure sets the value of the Server property of this object,
24910>>>>>>>>>>>>>>>>>    //   notifying child-objects of the change, and destroying and creating
24910>>>>>>>>>>>>>>>>>    //   connections with database agents, as required.
24910>>>>>>>>>>>>>>>>>    //
24910>>>>>>>>>>>>>>>>>    //   If the Server of this object is changed while this object is inactive,
24910>>>>>>>>>>>>>>>>>    //   no notification of child-objects is required or performed.
24910>>>>>>>>>>>>>>>>>    Procedure Set Server Integer newVal
24912>>>>>>>>>>>>>>>>>        Integer oldVal
24912>>>>>>>>>>>>>>>>>        Set explicit_server_state to (newVal <> 0)
24913>>>>>>>>>>>>>>>>>        Get Server to oldVal
24914>>>>>>>>>>>>>>>>>        If (newVal <> 0) ;            Set private.Server to (object_id(newVal))
24917>>>>>>>>>>>>>>>>>        Else ;            Set private.Server to newVal
24919>>>>>>>>>>>>>>>>>        If (active_state(Self)) Begin
24921>>>>>>>>>>>>>>>>>            Broadcast Send server_changed oldVal newVal
24923>>>>>>>>>>>>>>>>>            If (oldVal <> 0) ;                Send remove_deo_from_server  //detach from current server
24926>>>>>>>>>>>>>>>>>            If (newval <> 0) ;                Send attach_deo_to_server    //attach to new server
24929>>>>>>>>>>>>>>>>>        End
24929>>>>>>>>>>>>>>>>>>
24929>>>>>>>>>>>>>>>>>    End_Procedure
24930>>>>>>>>>>>>>>>>>    
24930>>>>>>>>>>>>>>>>>    //   This procedure servers as notification of a change in the connection
24930>>>>>>>>>>>>>>>>>    //   of this object's parent to its database agent.  If this object uses
24930>>>>>>>>>>>>>>>>>    //   its parent's database agent by default (see the Server and Find_Server
24930>>>>>>>>>>>>>>>>>    //   functions, above), it must disconnect from the old agent and connect
24930>>>>>>>>>>>>>>>>>    //   with the new agent.
24930>>>>>>>>>>>>>>>>>    Procedure server_changed Integer oldVal Integer newVal
24932>>>>>>>>>>>>>>>>>        Integer oldSrvr
24932>>>>>>>>>>>>>>>>>        // as of 17.0, containers will be added as a DEO so it receives the Refresh message
24932>>>>>>>>>>>>>>>>>        Get private.Server to oldSrvr
24933>>>>>>>>>>>>>>>>>        If (oldSrvr = 0) Begin  //assumes Server(self) = oldVal by deleg
24935>>>>>>>>>>>>>>>>>            If (oldVal <> 0) ;                Send remove_user_interface to oldVal Self
24938>>>>>>>>>>>>>>>>>            If (newVal <> 0) ;                Send add_user_interface to newVal Self
24941>>>>>>>>>>>>>>>>>        End
24941>>>>>>>>>>>>>>>>>>
24941>>>>>>>>>>>>>>>>>    End_Procedure
24942>>>>>>>>>>>>>>>>>    
24942>>>>>>>>>>>>>>>>>    
24942>>>>>>>>>>>>>>>>>    //   This procedure empties the Watched_Servers broadcaster, after
24942>>>>>>>>>>>>>>>>>    //   detaching this object from all of the broadcaster's elements.
24942>>>>>>>>>>>>>>>>>    //   This procedure is invoked by Find_Servers_to_Watch, in preparation
24942>>>>>>>>>>>>>>>>>    //   for a scan. Deletes both sets of watched servers
24942>>>>>>>>>>>>>>>>>    //
24942>>>>>>>>>>>>>>>>>    Procedure delete_watched_servers
24944>>>>>>>>>>>>>>>>>        Integer vis#
24944>>>>>>>>>>>>>>>>>        
24944>>>>>>>>>>>>>>>>>        Get watched_servers to vis#
24945>>>>>>>>>>>>>>>>>        If vis# Begin
24947>>>>>>>>>>>>>>>>>            Send Remove_User_Interface to vis# Self True //detach from all, TRUE for watchers
24948>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24949>>>>>>>>>>>>>>>>>            Send delete_Data to vis#                    //empty it
24950>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24951>>>>>>>>>>>>>>>>>        End
24951>>>>>>>>>>>>>>>>>>
24951>>>>>>>>>>>>>>>>>        
24951>>>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to vis#
24952>>>>>>>>>>>>>>>>>        If vis# Begin
24954>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24955>>>>>>>>>>>>>>>>>            Send delete_Data to vis#                    //empty it
24956>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24957>>>>>>>>>>>>>>>>>        End
24957>>>>>>>>>>>>>>>>>>
24957>>>>>>>>>>>>>>>>>    End_Procedure
24958>>>>>>>>>>>>>>>>>    
24958>>>>>>>>>>>>>>>>>    //   This procedure adds the specified object id (obj#) to this object's
24958>>>>>>>>>>>>>>>>>    //   set of database agents who are merely 'watched', and establishes a
24958>>>>>>>>>>>>>>>>>    //   connection between the database agent and this object.
24958>>>>>>>>>>>>>>>>>    Procedure add_watched_server Integer obj#
24960>>>>>>>>>>>>>>>>>        Integer vis# ndx
24960>>>>>>>>>>>>>>>>>        Get watched_servers to vis#
24961>>>>>>>>>>>>>>>>>        // if w server does not exist, first create it
24961>>>>>>>>>>>>>>>>>        If (Vis# = 0) Begin
24963>>>>>>>>>>>>>>>>>            Get Create of Desktop U_Broadcaster to Vis#
24964>>>>>>>>>>>>>>>>>            Set Watched_Servers to Vis#
24965>>>>>>>>>>>>>>>>>        End
24965>>>>>>>>>>>>>>>>>>
24965>>>>>>>>>>>>>>>>>        //
24965>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to False
24966>>>>>>>>>>>>>>>>>        Get find_element of vis# obj# to ndx
24967>>>>>>>>>>>>>>>>>        If (ndx < 0) ;            Send add_element to vis# obj#
24970>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to True
24971>>>>>>>>>>>>>>>>>        If (ndx lt 0 and active_State(Self)) ;            Send add_user_interface to obj# Self True // TRUE for watchers
24974>>>>>>>>>>>>>>>>>    End_Procedure
24975>>>>>>>>>>>>>>>>>    
24975>>>>>>>>>>>>>>>>>    Procedure add_ChangedStateWatched_Servers Integer obj#
24977>>>>>>>>>>>>>>>>>        Integer vis# ndx
24977>>>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to vis#
24978>>>>>>>>>>>>>>>>>        If (Vis# = 0) Begin
24980>>>>>>>>>>>>>>>>>            Get Create of Desktop U_Broadcaster to Vis#
24981>>>>>>>>>>>>>>>>>            Set ChangedStateWatched_Servers to Vis#
24982>>>>>>>>>>>>>>>>>        End
24982>>>>>>>>>>>>>>>>>>
24982>>>>>>>>>>>>>>>>>        //
24982>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to False
24983>>>>>>>>>>>>>>>>>        Get find_element of vis# obj# to ndx
24984>>>>>>>>>>>>>>>>>        If (ndx < 0) ;            Send add_element to vis# obj#
24987>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to True
24988>>>>>>>>>>>>>>>>>    End_Procedure
24989>>>>>>>>>>>>>>>>>    
24989>>>>>>>>>>>>>>>>>    
24989>>>>>>>>>>>>>>>>>    //   This procedure removes the specified object id (obj#) from this object's
24989>>>>>>>>>>>>>>>>>    //   set of database agents who are merely 'watched', and destroys the
24989>>>>>>>>>>>>>>>>>    //   connection between the database agent and this object.
24989>>>>>>>>>>>>>>>>>    Procedure remove_watched_server Integer obj#
24991>>>>>>>>>>>>>>>>>        Integer vis# ndx
24991>>>>>>>>>>>>>>>>>        Get watched_servers to vis#
24992>>>>>>>>>>>>>>>>>        // Only if w server exists
24992>>>>>>>>>>>>>>>>>        If vis# Begin
24994>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24995>>>>>>>>>>>>>>>>>            Get find_element of vis# obj# to ndx
24996>>>>>>>>>>>>>>>>>            If (ndx >= 0) ;                Send remove_element to vis# obj#
24999>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
25000>>>>>>>>>>>>>>>>>            If (ndx >= 0 and active_State(Self)) ;                Send remove_user_interface to obj# Self True // TRUE for watchers
25003>>>>>>>>>>>>>>>>>        End
25003>>>>>>>>>>>>>>>>>>
25003>>>>>>>>>>>>>>>>>    End_Procedure
25004>>>>>>>>>>>>>>>>>    
25004>>>>>>>>>>>>>>>>>    //   This procedure causes the scanning of this object's items' fields,
25004>>>>>>>>>>>>>>>>>    //   and the production of a set of database agents who should be 'watched'.
25004>>>>>>>>>>>>>>>>>    //   This procedure depends completely upon Find_Servers_To_Watch, below.
25004>>>>>>>>>>>>>>>>>    //
25004>>>>>>>>>>>>>>>>>    Procedure Scan_Servers
25006>>>>>>>>>>>>>>>>>        Send find_servers_to_watch False
25007>>>>>>>>>>>>>>>>>    End_Procedure
25008>>>>>>>>>>>>>>>>>    
25008>>>>>>>>>>>>>>>>>    //   This procedure scans the fields of this object's items to determine
25008>>>>>>>>>>>>>>>>>    //   what other database agents (data_sets) other than this object's Server
25008>>>>>>>>>>>>>>>>>    //   should be 'watched' (for data changes).
25008>>>>>>>>>>>>>>>>>    //   This procedure is invoked once per object, the first time the object
25008>>>>>>>>>>>>>>>>>    //   is activated.  If the data_file, data_field, and/or main_file of this
25008>>>>>>>>>>>>>>>>>    //   object are changed (don't change them while this object is active!),
25008>>>>>>>>>>>>>>>>>    //   set Private.Servers_Scanned to FALSE to force this object to scan
25008>>>>>>>>>>>>>>>>>    //   again (when it is next activated).
25008>>>>>>>>>>>>>>>>>    //
25008>>>>>>>>>>>>>>>>>    
25008>>>>>>>>>>>>>>>>>    // 17.0: The logic has been retooled to add more watched servers to the DDOs. This is done so
25008>>>>>>>>>>>>>>>>>    // DD operations will send Refresh to these additional watched-servers. There are two changes:
25008>>>>>>>>>>>>>>>>>    // 1. Containers are now made watched servers for the Server and all parent servers
25008>>>>>>>>>>>>>>>>>    // 2. Non-file.field DEOs (e.g., expressions) are made watched servers for the server (which it
25008>>>>>>>>>>>>>>>>>    //    already did and for all parent servers. Without this, parent entry_item expressions were not
25008>>>>>>>>>>>>>>>>>    //    getting updated
25008>>>>>>>>>>>>>>>>>    // Here is how watched-servers works.
25008>>>>>>>>>>>>>>>>>    // Each DEO attaches and detaches from its Server by sending Add_User_interface and Remove_User_interface
25008>>>>>>>>>>>>>>>>>    // to the server DD. Once attached, the DD knows about this DEO and sends messages to it as needed (Refresh,
25008>>>>>>>>>>>>>>>>>    // Entry_Update, etc.). In addition, a DEO may need to attach a parent DDO so that changes in that parent DD
25008>>>>>>>>>>>>>>>>>    // results in those messages being sent. This is needed if the binding table in entry_item refers to a parent
25008>>>>>>>>>>>>>>>>>    // table. So we need to send Add_User_interface and Remove_User_interface to that parent server as well. If a DEO
25008>>>>>>>>>>>>>>>>>    // has multiple, there could be multiple parent servers. As of 17.0, we are also attaching to parent servers if
25008>>>>>>>>>>>>>>>>>    // we are unsure about how the DEO is being used. If an expression is used, it might need to be updated when
25008>>>>>>>>>>>>>>>>>    // a parent (or any ancestor) changes. Each DEO keeps track of servers that it attaches to and this is referred
25008>>>>>>>>>>>>>>>>>    // to as the watched_server list. This list is maintained so the DEO knows which DDOs to attach and detach to.
25008>>>>>>>>>>>>>>>>>    
25008>>>>>>>>>>>>>>>>>    
25008>>>>>>>>>>>>>>>>>    Procedure find_servers_to_watch Integer tableFlag
25010>>>>>>>>>>>>>>>>>        Integer i file# obj# maxitems count p srvr# self# srvrfile
25010>>>>>>>>>>>>>>>>>        String fileStr fStr
25010>>>>>>>>>>>>>>>>>        Boolean bContainer bDoAll
25010>>>>>>>>>>>>>>>>>        
25010>>>>>>>>>>>>>>>>>        Get Client_Area_State to bContainer
25011>>>>>>>>>>>>>>>>>        Set private.Servers_Scanned to True
25012>>>>>>>>>>>>>>>>>        
25012>>>>>>>>>>>>>>>>>        Get Server to srvr#
25013>>>>>>>>>>>>>>>>>        
25013>>>>>>>>>>>>>>>>>        If (srvr#=0) Begin
25015>>>>>>>>>>>>>>>>>            Procedure_Return
25016>>>>>>>>>>>>>>>>>        End
25016>>>>>>>>>>>>>>>>>>
25016>>>>>>>>>>>>>>>>>        
25016>>>>>>>>>>>>>>>>>        Send delete_watched_servers  //empty Watched_Servers broadcaster first
25017>>>>>>>>>>>>>>>>>        
25017>>>>>>>>>>>>>>>>>        Get main_file of srvr# to srvrfile  // data-set's main-file
25018>>>>>>>>>>>>>>>>>        
25018>>>>>>>>>>>>>>>>>        If bContainer Begin
25020>>>>>>>>>>>>>>>>>            // containers should get added to all parent DDOs
25020>>>>>>>>>>>>>>>>>            Send WatchAllParentServers srvr#
25021>>>>>>>>>>>>>>>>>            Procedure_Return
25022>>>>>>>>>>>>>>>>>        End
25022>>>>>>>>>>>>>>>>>>
25022>>>>>>>>>>>>>>>>>        
25022>>>>>>>>>>>>>>>>>        If (tableFlag <> 0) ;            Get Prototype_Object to self# // tables
25025>>>>>>>>>>>>>>>>>        Else ;            Move Self to self# // forms and text windows
25027>>>>>>>>>>>>>>>>>        
25027>>>>>>>>>>>>>>>>>        Get item_count of self# to maxitems
25028>>>>>>>>>>>>>>>>>        Decrement maxitems
25029>>>>>>>>>>>>>>>>>        
25029>>>>>>>>>>>>>>>>>        // if no items do nothing
25029>>>>>>>>>>>>>>>>>        // if one item do quick check
25029>>>>>>>>>>>>>>>>>        // if multiple items do it the hard way
25029>>>>>>>>>>>>>>>>>        
25029>>>>>>>>>>>>>>>>>        If (maxitems<0) Begin
25031>>>>>>>>>>>>>>>>>            // if no items, which is unusual, we don't know what this DEO is so we will treat it like a container
25031>>>>>>>>>>>>>>>>>            // and add it as a watched server for all DDOs
25031>>>>>>>>>>>>>>>>>            Send WatchAllParentServers srvr#
25032>>>>>>>>>>>>>>>>>            Procedure_Return  // no items
25033>>>>>>>>>>>>>>>>>        End
25033>>>>>>>>>>>>>>>>>>
25033>>>>>>>>>>>>>>>>>        
25033>>>>>>>>>>>>>>>>>        If (maxitems=0) Begin // only 1 item - skip most of the nonsense
25035>>>>>>>>>>>>>>>>>            Get data_file of self# 0 to file#
25036>>>>>>>>>>>>>>>>>            // we need watched server if file exists, it is not the main file
25036>>>>>>>>>>>>>>>>>            // and is not an updating file (as opposed to updating data-set).
25036>>>>>>>>>>>>>>>>>            If (file#>0 and file#<>srvrfile) Begin
25038>>>>>>>>>>>>>>>>>                Get which_data_set of srvr# file# to obj#
25039>>>>>>>>>>>>>>>>>                If (obj# <> 0 and obj# <> srvr#) Begin
25041>>>>>>>>>>>>>>>>>                    Send add_Watched_server obj#
25042>>>>>>>>>>>>>>>>>                    Send add_ChangedStateWatched_Servers obj#
25043>>>>>>>>>>>>>>>>>                End
25043>>>>>>>>>>>>>>>>>>
25043>>>>>>>>>>>>>>>>>            End
25043>>>>>>>>>>>>>>>>>>
25043>>>>>>>>>>>>>>>>>            Else If (file#=0) Begin
25046>>>>>>>>>>>>>>>>>                // if no file (e.g., expression) we don't know when it changes so we tell all servers
25046>>>>>>>>>>>>>>>>>                // that this is a watcher
25046>>>>>>>>>>>>>>>>>                Send WatchAllParentServers srvr#
25047>>>>>>>>>>>>>>>>>            End
25047>>>>>>>>>>>>>>>>>>
25047>>>>>>>>>>>>>>>>>            If File# ;                Send Copy_Item_Options Srvr# file# (Data_Field(Self#,0)) Self# 0
25050>>>>>>>>>>>>>>>>>        End
25050>>>>>>>>>>>>>>>>>>
25050>>>>>>>>>>>>>>>>>        Else Begin  // multiple items - do what you must
25051>>>>>>>>>>>>>>>>>            Move -1 to count
25052>>>>>>>>>>>>>>>>>            Move "," to fileStr
25053>>>>>>>>>>>>>>>>>            If tableFlag Begin
25055>>>>>>>>>>>>>>>>>                Get main_file to file#
25056>>>>>>>>>>>>>>>>>                If (file# <> srvrfile) Begin    // only do this if mainfile is not the srvr file
25058>>>>>>>>>>>>>>>>>                    Append fileStr file# ","   //insert mainfile to be sure it's watched
25060>>>>>>>>>>>>>>>>>                    Increment count
25061>>>>>>>>>>>>>>>>>                End
25061>>>>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>>>>>            End
25061>>>>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>>>>>            For i from 0 to maxitems
25067>>>>>>>>>>>>>>>>>>
25067>>>>>>>>>>>>>>>>>                Get data_file of self# i to file#
25068>>>>>>>>>>>>>>>>>                If (file#=0) Begin
25070>>>>>>>>>>>>>>>>>                    // as soon as we don't know what the item is used for we will have
25070>>>>>>>>>>>>>>>>>                    // to attach to all parent DDOs.
25070>>>>>>>>>>>>>>>>>                    Move True to bDoAll
25071>>>>>>>>>>>>>>>>>                End
25071>>>>>>>>>>>>>>>>>>
25071>>>>>>>>>>>>>>>>>                If (file# > 0 and file#<>srvrfile and ;                    not(fileStr contains (","+String(file#)+",")) ) Begin
25073>>>>>>>>>>>>>>>>>                    Move (fileStr+String(file#) + ",") to fileStr
25074>>>>>>>>>>>>>>>>>                    Increment count
25075>>>>>>>>>>>>>>>>>                End
25075>>>>>>>>>>>>>>>>>>
25075>>>>>>>>>>>>>>>>>                If File# ;                    Send Copy_Item_Options Srvr# file# (Data_Field(Self#,i)) Self# i
25078>>>>>>>>>>>>>>>>>            Loop
25079>>>>>>>>>>>>>>>>>>
25079>>>>>>>>>>>>>>>>>            
25079>>>>>>>>>>>>>>>>>            // if an item's binding table is unknown, we watch all parent DDOs.
25079>>>>>>>>>>>>>>>>>            If bDoAll Begin
25081>>>>>>>>>>>>>>>>>                Send WatchAllParentServers srvr#
25082>>>>>>>>>>>>>>>>>            End
25082>>>>>>>>>>>>>>>>>>
25082>>>>>>>>>>>>>>>>>            Else Begin
25083>>>>>>>>>>>>>>>>>                If (count >= 0) Begin // any watched items?
25085>>>>>>>>>>>>>>>>>                    Move (Right(fileStr, length(fileStr) - 1))  to fileStr  //remove leading comma
25086>>>>>>>>>>>>>>>>>                    For i from 0 to count
25092>>>>>>>>>>>>>>>>>>
25092>>>>>>>>>>>>>>>>>                        Move (Pos( "," ,fileStr)) to p
25093>>>>>>>>>>>>>>>>>                        If (p > 1) Begin
25095>>>>>>>>>>>>>>>>>                            Move (Left( fileStr , p-1)) to fStr
25096>>>>>>>>>>>>>>>>>                            Move (Right( fileStr, length(fileStr) - p)) to fileStr
25097>>>>>>>>>>>>>>>>>                            Move fStr to file#
25098>>>>>>>>>>>>>>>>>                            Get which_data_set of srvr# file# to obj#
25099>>>>>>>>>>>>>>>>>                            If (obj# <> 0 and obj# <> srvr#) Begin
25101>>>>>>>>>>>>>>>>>                                Send add_Watched_server obj#
25102>>>>>>>>>>>>>>>>>                                Send add_ChangedStateWatched_Servers obj#
25103>>>>>>>>>>>>>>>>>                            End
25103>>>>>>>>>>>>>>>>>>
25103>>>>>>>>>>>>>>>>>                        End
25103>>>>>>>>>>>>>>>>>>
25103>>>>>>>>>>>>>>>>>                    Loop
25104>>>>>>>>>>>>>>>>>>
25104>>>>>>>>>>>>>>>>>                End
25104>>>>>>>>>>>>>>>>>>
25104>>>>>>>>>>>>>>>>>            End
25104>>>>>>>>>>>>>>>>>>
25104>>>>>>>>>>>>>>>>>        End
25104>>>>>>>>>>>>>>>>>>
25104>>>>>>>>>>>>>>>>>    End_Procedure
25105>>>>>>>>>>>>>>>>>    
25105>>>>>>>>>>>>>>>>>    // This does nothing. Other sub-classes (or later mixins) should add
25105>>>>>>>>>>>>>>>>>    // logic to this.
25105>>>>>>>>>>>>>>>>>    Procedure Copy_Item_Options Integer iDSO Integer iFile Integer iField ;            Integer iDEO Integer iItem
25107>>>>>>>>>>>>>>>>>    End_Procedure
25108>>>>>>>>>>>>>>>>>    
25108>>>>>>>>>>>>>>>>>    // This does little. Other sub-classes (or later mixins) should add
25108>>>>>>>>>>>>>>>>>    // logic to this.
25108>>>>>>>>>>>>>>>>>    Procedure Define_Extended_DEO_Mixin
25110>>>>>>>>>>>>>>>>>    End_Procedure
25111>>>>>>>>>>>>>>>>>    
25111>>>>>>>>>>>>>>>>>    
25111>>>>>>>>>>>>>>>>>    // created for Nesting support
25111>>>>>>>>>>>>>>>>>    Procedure Mark_As_Component
25113>>>>>>>>>>>>>>>>>        Integer ser#
25113>>>>>>>>>>>>>>>>>        Set Component_State to True
25114>>>>>>>>>>>>>>>>>        Delegate Set Has_Components_State to True
25116>>>>>>>>>>>>>>>>>        Get private.Server to ser#
25117>>>>>>>>>>>>>>>>>        If (ser# = 0) Begin
25119>>>>>>>>>>>>>>>>>            Delegate Get Locate_Server to ser#
25121>>>>>>>>>>>>>>>>>            If (ser# <> 0) ;                Set private.Server to ser#
25124>>>>>>>>>>>>>>>>>        End
25124>>>>>>>>>>>>>>>>>>
25124>>>>>>>>>>>>>>>>>    End_Procedure
25125>>>>>>>>>>>>>>>>>    
25125>>>>>>>>>>>>>>>>>    // This only gets called when the developer is killing this object. During application
25125>>>>>>>>>>>>>>>>>    // shut-down, only destroy_object is called. This augmentation destroys the watched broadcaster
25125>>>>>>>>>>>>>>>>>    // (which is sitting on the desktop). During program shut down we don't care if this is called
25125>>>>>>>>>>>>>>>>>    // because it is getting destroyed anyway. We are making the assumption that a developer controlled
25125>>>>>>>>>>>>>>>>>    // destroy will always be called with the watcher still existing.
25125>>>>>>>>>>>>>>>>>    
25125>>>>>>>>>>>>>>>>>    Procedure Destroy
25127>>>>>>>>>>>>>>>>>        Handle hoWatched
25127>>>>>>>>>>>>>>>>>        Set Changed_State to False //   is this really needed anymore???
25128>>>>>>>>>>>>>>>>>        // if non 0, The watched server, must still exist.
25128>>>>>>>>>>>>>>>>>        Get Watched_Servers to hoWatched
25129>>>>>>>>>>>>>>>>>        If hoWatched Begin
25131>>>>>>>>>>>>>>>>>            Set Broadcast_State of hoWatched to False
25132>>>>>>>>>>>>>>>>>            Send Destroy of hoWatched     // destroy the bcaster
25133>>>>>>>>>>>>>>>>>        End
25133>>>>>>>>>>>>>>>>>>
25133>>>>>>>>>>>>>>>>>        // if non 0, The bound watched server, must still exist.
25133>>>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to hoWatched
25134>>>>>>>>>>>>>>>>>        If hoWatched Begin
25136>>>>>>>>>>>>>>>>>            Set Broadcast_State of hoWatched to False
25137>>>>>>>>>>>>>>>>>            Send Destroy of hoWatched     // destroy the bcaster
25138>>>>>>>>>>>>>>>>>        End
25138>>>>>>>>>>>>>>>>>>
25138>>>>>>>>>>>>>>>>>        Forward Send Destroy
25140>>>>>>>>>>>>>>>>>    End_Procedure
25141>>>>>>>>>>>>>>>>>    
25141>>>>>>>>>>>>>>>>>    
25141>>>>>>>>>>>>>>>>>    Function Should_Save Returns Integer
25143>>>>>>>>>>>>>>>>>        Integer Obj# Chngd
25143>>>>>>>>>>>>>>>>>        Get Server to Obj#
25144>>>>>>>>>>>>>>>>>        Get Changed_state to Chngd
25145>>>>>>>>>>>>>>>>>        Function_Return ( Chngd or (obj# <> 0 and Should_Save(obj#)) )
25146>>>>>>>>>>>>>>>>>    End_Function
25147>>>>>>>>>>>>>>>>>    
25147>>>>>>>>>>>>>>>>>    // Added server scan logic here instead of add_focus.
25147>>>>>>>>>>>>>>>>>    Procedure Attach_Deo_To_Server
25149>>>>>>>>>>>>>>>>>        Integer obj# isclient srvscn wsrvr
25149>>>>>>>>>>>>>>>>>        Get Server to obj#
25150>>>>>>>>>>>>>>>>>        Get client_area_state to isclient
25151>>>>>>>>>>>>>>>>>        If (obj# <> 0) ;            Send add_user_interface to obj# Self
25154>>>>>>>>>>>>>>>>>        Get private.Servers_Scanned to srvscn
25155>>>>>>>>>>>>>>>>>        If (srvscn = 0) ;            Send scan_servers
25158>>>>>>>>>>>>>>>>>        Get Watched_Servers to wsrvr
25159>>>>>>>>>>>>>>>>>        If wsrvr Send add_user_interface ;            to wsrvr Self True // TRUE for watchers
25162>>>>>>>>>>>>>>>>>        If (obj# <> 0 and isclient = 0) ;            Send update_dependent_items
25165>>>>>>>>>>>>>>>>>    End_Procedure
25166>>>>>>>>>>>>>>>>>    
25166>>>>>>>>>>>>>>>>>    // Removed server scan logic and moved it to attach-deo_to_server
25166>>>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
25168>>>>>>>>>>>>>>>>>        Integer srvscn retval msg
25168>>>>>>>>>>>>>>>>>        //
25168>>>>>>>>>>>>>>>>>        // standard DEO behavior
25168>>>>>>>>>>>>>>>>>        //
25168>>>>>>>>>>>>>>>>>        Forward Get msg_Add_Focus hoParent to retval
25170>>>>>>>>>>>>>>>>>        If retval ;            Procedure_Return retval
25173>>>>>>>>>>>>>>>>>        
25173>>>>>>>>>>>>>>>>>        If (client_area_State(Self) = 0) ; //clients already broadcast            Broadcast NO_STOP Send add_focus Self
25178>>>>>>>>>>>>>>>>>        //
25178>>>>>>>>>>>>>>>>>        // server augmentation
25178>>>>>>>>>>>>>>>>>        //
25178>>>>>>>>>>>>>>>>>        If (focus_mode(Self) <> NO_ACTIVATE and Active_State(Self)) ;            Send attach_DEO_to_server
25181>>>>>>>>>>>>>>>>>        
25181>>>>>>>>>>>>>>>>>        // last thing to do is send custom message. With list deos
25181>>>>>>>>>>>>>>>>>        // msg is probably initialize_list. With non-list deos it
25181>>>>>>>>>>>>>>>>>        // is probably nothing
25181>>>>>>>>>>>>>>>>>        Get add_focus_msg to msg
25182>>>>>>>>>>>>>>>>>        If msg ;            Send msg
25185>>>>>>>>>>>>>>>>>    End_Procedure
25186>>>>>>>>>>>>>>>>>    
25186>>>>>>>>>>>>>>>>>    // Connect DEO to Server if Demanded (DoAllfg=t) or ;
25186>>>>>>>>>>>>>>>>>    // allowed  (static_server_State=t). Broadcast if children exist
25186>>>>>>>>>>>>>>>>>    Procedure Connect_DEOs_to_Servers Integer DoAllFg
25188>>>>>>>>>>>>>>>>>        If (DoAllfg or Static_Server_State(Self)) ;            Send Attach_Deo_to_Server
25191>>>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Connect_DEOs_to_Servers DoAllfg
25195>>>>>>>>>>>>>>>>>    End_Procedure
25196>>>>>>>>>>>>>>>>>    
25196>>>>>>>>>>>>>>>>>    // Disconnect DEOs from Servers according to rules. Broadcast
25196>>>>>>>>>>>>>>>>>    // to child components.
25196>>>>>>>>>>>>>>>>>    //
25196>>>>>>>>>>>>>>>>>    // Pass: DoAllMode
25196>>>>>>>>>>>>>>>>>    //    DETACH_NEVER        Never
25196>>>>>>>>>>>>>>>>>    //    DETACH_IF_NO_CHANGE Do if changed_state=F
25196>>>>>>>>>>>>>>>>>    //    DETACH_ALWAYS       Do it no matter what
25196>>>>>>>>>>>>>>>>>    //    DETACH_IF_ALLOWED   Do if changed_state=F and auto_attach
25196>>>>>>>>>>>>>>>>>    //                        (I don't think this will be needed!)
25196>>>>>>>>>>>>>>>>>    //
25196>>>>>>>>>>>>>>>>>    Procedure Disconnect_DEOs_from_Servers Integer DoAllMode
25198>>>>>>>>>>>>>>>>>        If (DoAllMode <> DETACH_NEVER) Begin
25200>>>>>>>>>>>>>>>>>            If ( DoAllMode=DETACH_ALWAYS or ; // do all no matter what                ( (Changed_state(Self)=0) and ;                ( (DoAllMode=DETACH_IF_NO_CHANGE) or  ;                (Static_Server_State(Self)) ) ) ) ;                Send Remove_deo_from_server
25203>>>>>>>>>>>>>>>>>            If (Has_Components_State(Self)) ;                Broadcast Send Disconnect_DEOs_from_Servers DoAllMode
25207>>>>>>>>>>>>>>>>>        End
25207>>>>>>>>>>>>>>>>>>
25207>>>>>>>>>>>>>>>>>    End_Procedure
25208>>>>>>>>>>>>>>>>>    
25208>>>>>>>>>>>>>>>>>    // Changed to not remove from server if static.
25208>>>>>>>>>>>>>>>>>    Procedure Remove_Object
25210>>>>>>>>>>>>>>>>>        Forward Send remove_object
25212>>>>>>>>>>>>>>>>>        // remove if not static and no changes
25212>>>>>>>>>>>>>>>>>        If ( Static_Server_State(Self)=0 and ;            Changed_State(Self)=0 ) ;  // only detach if unchanged!            Send remove_DEO_from_server
25215>>>>>>>>>>>>>>>>>    End_Procedure
25216>>>>>>>>>>>>>>>>>    
25216>>>>>>>>>>>>>>>>>    
25216>>>>>>>>>>>>>>>>>    // (JJT) Changed so that this respects Change_disabled_state. I don't
25216>>>>>>>>>>>>>>>>>    //       like this here but its the best I can think of. Therefore, all
25216>>>>>>>>>>>>>>>>>    //       objects using server.pkg must understand Change_disabled_state.
25216>>>>>>>>>>>>>>>>>    //
25216>>>>>>>>>>>>>>>>>    // (JJT) Checks deferred_state and if set do not change the
25216>>>>>>>>>>>>>>>>>    // changed state of the server object. This had been in datalist and is
25216>>>>>>>>>>>>>>>>>    // required to make deferred_state work right. Deferred_state was created
25216>>>>>>>>>>>>>>>>>    // to make selection-lists work correctly and as far as I am concerned it
25216>>>>>>>>>>>>>>>>>    // should be the only supported use of this. Therefore, I would not *ever*
25216>>>>>>>>>>>>>>>>>    // expect deferred_state to be set true in tables, entry_forms, or text_
25216>>>>>>>>>>>>>>>>>    // windows. Since deferred-state is known to this mixin the change
25216>>>>>>>>>>>>>>>>>    // belongs here - but I expect it to only ever change behaviors in
25216>>>>>>>>>>>>>>>>>    // selection-lists.
25216>>>>>>>>>>>>>>>>>    
25216>>>>>>>>>>>>>>>>>    
25216>>>>>>>>>>>>>>>>>    // Changed to not remove from server if static.
25216>>>>>>>>>>>>>>>>>    Procedure Set Changed_State Integer newVal
25218>>>>>>>>>>>>>>>>>        Integer srvr# wsrvr
25218>>>>>>>>>>>>>>>>>        If not (Change_Disabled_State(Self)) Begin
25220>>>>>>>>>>>>>>>>>            Forward Set Changed_State to newVal
25222>>>>>>>>>>>>>>>>>            Get server to srvr#
25223>>>>>>>>>>>>>>>>>            
25223>>>>>>>>>>>>>>>>>            // if deferred keep the server out of it.
25223>>>>>>>>>>>>>>>>>            If not (deferred_State(Self)) Begin
25225>>>>>>>>>>>>>>>>>                If (newVal and srvr#) Begin
25227>>>>>>>>>>>>>>>>>                    Set Changed_State of srvr# to True
25228>>>>>>>>>>>>>>>>>                    // We also set changed_state of all "foreign" servers. These
25228>>>>>>>>>>>>>>>>>                    // are the ones whose Data_File is a parent File
25228>>>>>>>>>>>>>>>>>                    Get ChangedStateWatched_Servers to wsrvr
25229>>>>>>>>>>>>>>>>>                    If wsrvr ;                        Set Changed_State of wSrvr to True
25232>>>>>>>>>>>>>>>>>                End
25232>>>>>>>>>>>>>>>>>>
25232>>>>>>>>>>>>>>>>>                
25232>>>>>>>>>>>>>>>>>                // Remove is changed-state=false, not active and not static
25232>>>>>>>>>>>>>>>>>                If ( not(newVal) and not(Active_State(Self)) and ;                    not(Static_Server_State(Self)) ) ;                    Send remove_DEO_from_Server
25235>>>>>>>>>>>>>>>>>            End
25235>>>>>>>>>>>>>>>>>>
25235>>>>>>>>>>>>>>>>>        End
25235>>>>>>>>>>>>>>>>>>
25235>>>>>>>>>>>>>>>>>    End_Procedure
25236>>>>>>>>>>>>>>>>>    
25236>>>>>>>>>>>>>>>>>    // When an object is created this sets the default value for
25236>>>>>>>>>>>>>>>>>    // Static_Server_state. If a parent DEO exists it will use its
25236>>>>>>>>>>>>>>>>>    // static_server_state property. An Entry_view_Client0 object sets
25236>>>>>>>>>>>>>>>>>    // this - this way view based daf programs will use the new behavior
25236>>>>>>>>>>>>>>>>>    // (although it can be disabled)  but non-daf programs will work like
25236>>>>>>>>>>>>>>>>>    // they always did.
25236>>>>>>>>>>>>>>>>>    Function Default_Static_Server_State Returns Integer
25238>>>>>>>>>>>>>>>>>        Integer rVal
25238>>>>>>>>>>>>>>>>>        // We delegate to get the actual (not default) static state
25238>>>>>>>>>>>>>>>>>        // Note: Can't check with component_state - it not defined yet
25238>>>>>>>>>>>>>>>>>        Delegate Get Static_Server_State to rVal
25240>>>>>>>>>>>>>>>>>        Function_Return rVal
25241>>>>>>>>>>>>>>>>>    End_Function
25242>>>>>>>>>>>>>>>>>    
25242>>>>>>>>>>>>>>>>>    // This adds every parent DDO for the passed DDO to the DEO's list of DDOs to watch.
25242>>>>>>>>>>>>>>>>>    // It adds the parents and then does this recursively up the DDO tree.
25242>>>>>>>>>>>>>>>>>    // This means that this DEO will respond to any DD change for any server. This does not
25242>>>>>>>>>>>>>>>>>    Procedure WatchAllParentServers Handle hoDDO
25244>>>>>>>>>>>>>>>>>        Handle hoSrvr
25244>>>>>>>>>>>>>>>>>        Integer iServer iServers
25244>>>>>>>>>>>>>>>>>        Get Data_Set_Server_Count of hoDDO to iServers
25245>>>>>>>>>>>>>>>>>        For iServer from 0 to (iServers-1)
25251>>>>>>>>>>>>>>>>>>
25251>>>>>>>>>>>>>>>>>            Get Data_Set_Server of hoDDO iServer to hoSrvr
25252>>>>>>>>>>>>>>>>>            Send Add_Watched_Server hoSrvr
25253>>>>>>>>>>>>>>>>>            Send WatchAllParentServers hoSrvr
25254>>>>>>>>>>>>>>>>>        Loop
25255>>>>>>>>>>>>>>>>>>
25255>>>>>>>>>>>>>>>>>    End_Procedure
25256>>>>>>>>>>>>>>>>>    
25256>>>>>>>>>>>>>>>>>    
25256>>>>>>>>>>>>>>>>>End_Class
25257>>>>>>>>>>>>>>>>>
25257>>>>>>>>>>>>>>>>>//
25257>>>>>>>>>>>>>>>>>// The use of using on an object name is no longer supported. We will check for it's usage in case
25257>>>>>>>>>>>>>>>>>// developer's use this in old code.
25257>>>>>>>>>>>>>>>>>// Insetad of using, one should use "Set Server"
25257>>>>>>>>>>>>>>>>>//
25257>>>>>>>>>>>>>>>>>
25257>>>>>>>>>>>>>>>Use VERIFY.pkg        //include Verification support module
Including file: verify.pkg    (C:\Program Files\DataFlex 23.0\Pkg\verify.pkg)
25257>>>>>>>>>>>>>>>>>Use VDFBase.pkg
25257>>>>>>>>>>>>>>>>>
25257>>>>>>>>>>>>>>>>>Register_Function Component_State Returns Integer
25257>>>>>>>>>>>>>>>>>
25257>>>>>>>>>>>>>>>>>
25257>>>>>>>>>>>>>>>>>Class verify_mixin is a mixin
25258>>>>>>>>>>>>>>>>>    Procedure define_verify
25260>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Save_Msg      0
25261>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Delete_Msg    0
25262>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Data_Loss_Msg 0
25263>>>>>>>>>>>>>>>>>    End_Procedure
25264>>>>>>>>>>>>>>>>>    
25264>>>>>>>>>>>>>>>>>    
25264>>>>>>>>>>>>>>>>>    Procedure Set Verify_Save_msg Integer val
25266>>>>>>>>>>>>>>>>>        Set private.Verify_Save_Msg to val
25267>>>>>>>>>>>>>>>>>    End_Procedure
25268>>>>>>>>>>>>>>>>>    
25268>>>>>>>>>>>>>>>>>    Procedure Set Verify_Delete_msg Integer val
25270>>>>>>>>>>>>>>>>>        Set private.Verify_Delete_Msg to val
25271>>>>>>>>>>>>>>>>>    End_Procedure
25272>>>>>>>>>>>>>>>>>    
25272>>>>>>>>>>>>>>>>>    Procedure Set Verify_Data_Loss_msg Integer val
25274>>>>>>>>>>>>>>>>>        Set private.Verify_Data_Loss_Msg to val
25275>>>>>>>>>>>>>>>>>    End_Procedure
25276>>>>>>>>>>>>>>>>>    
25276>>>>>>>>>>>>>>>>>    Function Verify_Save_msg Returns Integer
25278>>>>>>>>>>>>>>>>>        Integer retval
25278>>>>>>>>>>>>>>>>>        Get private.Verify_Save_Msg to retval
25279>>>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Save_Msg to retval
25283>>>>>>>>>>>>>>>>>        Function_Return retval
25284>>>>>>>>>>>>>>>>>    End_Function
25285>>>>>>>>>>>>>>>>>    
25285>>>>>>>>>>>>>>>>>    Function Verify_Delete_msg Returns Integer
25287>>>>>>>>>>>>>>>>>        Integer retval
25287>>>>>>>>>>>>>>>>>        Get private.Verify_Delete_Msg to retval
25288>>>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Delete_Msg to retval
25292>>>>>>>>>>>>>>>>>        Function_Return retval
25293>>>>>>>>>>>>>>>>>    End_Function
25294>>>>>>>>>>>>>>>>>    
25294>>>>>>>>>>>>>>>>>    
25294>>>>>>>>>>>>>>>>>    Function Verify_Data_Loss_msg Returns Integer
25296>>>>>>>>>>>>>>>>>        Integer retval
25296>>>>>>>>>>>>>>>>>        Get private.Verify_Data_Loss_Msg to retval
25297>>>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Data_Loss_Msg to retval
25301>>>>>>>>>>>>>>>>>        Function_Return retval
25302>>>>>>>>>>>>>>>>>    End_Function
25303>>>>>>>>>>>>>>>>>    
25303>>>>>>>>>>>>>>>>>    Function Verify_Save Returns Integer
25305>>>>>>>>>>>>>>>>>        Integer msg# retval
25305>>>>>>>>>>>>>>>>>        Get Verify_Save_Msg to msg#
25306>>>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25308>>>>>>>>>>>>>>>>>            Get msg# to retval
25309>>>>>>>>>>>>>>>>>            Function_Return retval
25310>>>>>>>>>>>>>>>>>        End
25310>>>>>>>>>>>>>>>>>>
25310>>>>>>>>>>>>>>>>>    End_Function
25311>>>>>>>>>>>>>>>>>    
25311>>>>>>>>>>>>>>>>>    Function Verify_Delete Returns Integer
25313>>>>>>>>>>>>>>>>>        Integer msg# retval
25313>>>>>>>>>>>>>>>>>        Get Verify_Delete_Msg to msg#
25314>>>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25316>>>>>>>>>>>>>>>>>            Get msg# to retval
25317>>>>>>>>>>>>>>>>>            Function_Return retval
25318>>>>>>>>>>>>>>>>>        End
25318>>>>>>>>>>>>>>>>>>
25318>>>>>>>>>>>>>>>>>    End_Function
25319>>>>>>>>>>>>>>>>>    
25319>>>>>>>>>>>>>>>>>    Function Verify_Data_Loss Returns Integer
25321>>>>>>>>>>>>>>>>>        Integer msg# retval
25321>>>>>>>>>>>>>>>>>        Get Verify_Data_Loss_Msg to msg#
25322>>>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25324>>>>>>>>>>>>>>>>>            Get msg# to retval
25325>>>>>>>>>>>>>>>>>            Function_Return retval
25326>>>>>>>>>>>>>>>>>        End
25326>>>>>>>>>>>>>>>>>>
25326>>>>>>>>>>>>>>>>>    End_Function
25327>>>>>>>>>>>>>>>>>    
25327>>>>>>>>>>>>>>>>>End_Class
25328>>>>>>>>>>>>>>>Use ACTIONBR.pkg      //include action-bar support module
Including file: Actionbr.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Actionbr.pkg)
25328>>>>>>>>>>>>>>>>>Use VDFBase.pkg
25328>>>>>>>>>>>>>>>>>
25328>>>>>>>>>>>>>>>>>Class Action_Bar_Mixin is a mixin
25329>>>>>>>>>>>>>>>>>    Procedure Define_Action_bar
25331>>>>>>>>>>>>>>>>>    End_Procedure
25332>>>>>>>>>>>>>>>>>    
25332>>>>>>>>>>>>>>>>>    Procedure Define_Access_Keys
25334>>>>>>>>>>>>>>>>>    End_Procedure
25335>>>>>>>>>>>>>>>>>    
25335>>>>>>>>>>>>>>>>>    Procedure Add_Action_bar
25337>>>>>>>>>>>>>>>>>    End_Procedure
25338>>>>>>>>>>>>>>>>>End_Class
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>Use AutoLcMx.pkg   // Auto locate of popup mixin
25339>>>>>>>>>>>>>>>Use DEODlgMx.pkg   // DEO delegation support
Including file: deodlgmx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\deodlgmx.pkg)
25339>>>>>>>>>>>>>>>>>Use VDFBase.pkg
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>>>Enum_List
25339>>>>>>>>>>>>>>>>>    Define DELEGATE_NEVER
25339>>>>>>>>>>>>>>>>>    Define DELEGATE_SERVER
25339>>>>>>>>>>>>>>>>>    Define DELEGATE_ALWAYS
25339>>>>>>>>>>>>>>>>>End_Enum_List
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>>>Register_Function component_state Returns Integer
25339>>>>>>>>>>>>>>>>>
25339>>>>>>>>>>>>>>>>>Class deo_delegate_mixin is a mixin
25340>>>>>>>>>>>>>>>>>    Procedure define_deo_delegate
25342>>>>>>>>>>>>>>>>>        
25342>>>>>>>>>>>>>>>>>        Property Integer DEO_Delegate_Mode     Delegate_Server
25343>>>>>>>>>>>>>>>>>        
25343>>>>>>>>>>>>>>>>>        Property Integer delegate_clear_state  True
25344>>>>>>>>>>>>>>>>>        
25344>>>>>>>>>>>>>>>>>        Property Integer delegate_delete_state True
25345>>>>>>>>>>>>>>>>>        
25345>>>>>>>>>>>>>>>>>        Property Integer delegate_find_state   False
25346>>>>>>>>>>>>>>>>>        
25346>>>>>>>>>>>>>>>>>        Property Integer delegate_save_state   True
25347>>>>>>>>>>>>>>>>>    End_Procedure
25348>>>>>>>>>>>>>>>>>    
25348>>>>>>>>>>>>>>>>>    Function should_delegate Returns Integer
25350>>>>>>>>>>>>>>>>>        Integer Mode Dlg_Obj
25350>>>>>>>>>>>>>>>>>        
25350>>>>>>>>>>>>>>>>>        Delegate Get Object_Id to Dlg_Obj
25352>>>>>>>>>>>>>>>>>        Get Deo_Delegate_Mode to Mode
25353>>>>>>>>>>>>>>>>>        Function_Return ( (((Mode = DELEGATE_SERVER) and ;            not(Explicit_Server_State(Self)) and ;            (Locate_Server(Self) <> Dlg_Obj)) or ; // don't delegate if the object to delegate to is a server.            (Mode = DELEGATE_ALWAYS)) and Component_State(Self))
25354>>>>>>>>>>>>>>>>>    End_Function
25355>>>>>>>>>>>>>>>>>    
25355>>>>>>>>>>>>>>>>>    Function Should_delegate_Clear Returns Integer
25357>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_clear_state(Self))
25358>>>>>>>>>>>>>>>>>    End_Function
25359>>>>>>>>>>>>>>>>>    
25359>>>>>>>>>>>>>>>>>    Function Should_delegate_Save Returns Integer
25361>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_Save_state(Self))
25362>>>>>>>>>>>>>>>>>    End_Function
25363>>>>>>>>>>>>>>>>>    
25363>>>>>>>>>>>>>>>>>    Function Should_delegate_Delete Returns Integer
25365>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_delete_state(Self))
25366>>>>>>>>>>>>>>>>>    End_Function
25367>>>>>>>>>>>>>>>>>    
25367>>>>>>>>>>>>>>>>>    Function Should_delegate_Find Returns Integer
25369>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_Find_state(Self))
25370>>>>>>>>>>>>>>>>>    End_Function
25371>>>>>>>>>>>>>>>>>    
25371>>>>>>>>>>>>>>>>>End_Class
25372>>>>>>>>>>>>>>>>>
25372>>>>>>>>>>>>>>>>>//  During a clear (or a save/delete which sends clear) object-validation is
25372>>>>>>>>>>>>>>>>>//  properly shut off. However, the false assumption had been made that the
25372>>>>>>>>>>>>>>>>>//  DEO request_clear/clear_all messages originated with the object that had
25372>>>>>>>>>>>>>>>>>//  the focus. This was never true and is now even less likely to be true
25372>>>>>>>>>>>>>>>>>//  with the request_??? delegation method. The proper solution is to shut
25372>>>>>>>>>>>>>>>>>//  off object-validation in the focus object. The problem here is that
25372>>>>>>>>>>>>>>>>>//  the focus object may not understand this message (text_windows, buttons,
25372>>>>>>>>>>>>>>>>>//  etc). The work-around for now is to make sure that all objects understand
25372>>>>>>>>>>>>>>>>>//  these message. We can not directly add an Object_Validation message to the
25372>>>>>>>>>>>>>>>>>//  desktop (Object class). Because this message is internal this didn't work.
25372>>>>>>>>>>>>>>>>>//  By default this does nothing. Objects using val_mx actually pass this on
25372>>>>>>>>>>>>>>>>>//  object_validation.
25372>>>>>>>>>>>>>>>>>
25372>>>>>>>>>>>>>>>>>Procedure Set Object_Item_validation for cUIObject Integer fg
25374>>>>>>>>>>>>>>>>>End_Procedure
25375>>>>>>>>>>>>>>>>>
25375>>>>>>>>>>>>>>>>>Function Object_Item_Validation for cUIObject Returns Integer
25377>>>>>>>>>>>>>>>>>End_Function
25378>>>>>>>>>>>>>>>
25378>>>>>>>>>>>>>>>Register_Procedure Refind_DD_Records
25378>>>>>>>>>>>>>>>
25378>>>>>>>>>>>>>>>Class Entry_Client_mixin is a mixin
25379>>>>>>>>>>>>>>>
25379>>>>>>>>>>>>>>>    Procedure Construct_Object Integer myImg
25381>>>>>>>>>>>>>>>        Forward Send construct_object myImg
25383>>>>>>>>>>>>>>>        Set Ring_State to False
25384>>>>>>>>>>>>>>>        Property Integer private.Changed_State 0
25385>>>>>>>>>>>>>>>        
25385>>>>>>>>>>>>>>>        // We need this property to fully emulate a DEO
25385>>>>>>>>>>>>>>>        // (Actually, entry_clients should realy support ALL the DEO messages!)
25385>>>>>>>>>>>>>>>        Property Integer Auto_Clear_DEO_State True
25386>>>>>>>>>>>>>>>        
25386>>>>>>>>>>>>>>>        Send define_nesting      //invoke DEO nesting standard support constructor
25387>>>>>>>>>>>>>>>        Send define_navigation   //invoke DEO navigation standard support constructor
25388>>>>>>>>>>>>>>>        Send define_server       //invoke Server support constructor
25389>>>>>>>>>>>>>>>        Send define_action_bar   //invoke action-bar support constructor
25390>>>>>>>>>>>>>>>        Send define_verify       //invoke Verification support constructor
25391>>>>>>>>>>>>>>>        Send define_DEO_Delegate
25392>>>>>>>>>>>>>>>        Send Define_Auto_Locate
25393>>>>>>>>>>>>>>>        
25393>>>>>>>>>>>>>>>    End_Procedure
25394>>>>>>>>>>>>>>>    
25394>>>>>>>>>>>>>>>    Import_Class_Protocol NESTING_Mixin
25395>>>>>>>>>>>>>>>    Import_Class_Protocol NAVIGATE_Mixin
25396>>>>>>>>>>>>>>>    Import_Class_Protocol SERVER_Mixin
25397>>>>>>>>>>>>>>>    Import_Class_Protocol VERIFY_Mixin
25398>>>>>>>>>>>>>>>    Import_Class_Protocol ACTION_BAR_Mixin
25399>>>>>>>>>>>>>>>    Import_Class_Protocol Auto_Locate_Mixin
25400>>>>>>>>>>>>>>>    Import_Class_Protocol Deo_Delegate_Mixin
25401>>>>>>>>>>>>>>>    
25401>>>>>>>>>>>>>>>    
25401>>>>>>>>>>>>>>>    //
25401>>>>>>>>>>>>>>>    // created for Server support
25401>>>>>>>>>>>>>>>    //
25401>>>>>>>>>>>>>>>    Procedure Display
25403>>>>>>>>>>>>>>>        Broadcast Send display
25405>>>>>>>>>>>>>>>    End_Procedure
25406>>>>>>>>>>>>>>>    
25406>>>>>>>>>>>>>>>    //
25406>>>>>>>>>>>>>>>    // created for Server support
25406>>>>>>>>>>>>>>>    //
25406>>>>>>>>>>>>>>>    Procedure Clear
25408>>>>>>>>>>>>>>>        Broadcast Send Clear
25410>>>>>>>>>>>>>>>    End_Procedure
25411>>>>>>>>>>>>>>>    
25411>>>>>>>>>>>>>>>    //
25411>>>>>>>>>>>>>>>    // created for Server support
25411>>>>>>>>>>>>>>>    //
25411>>>>>>>>>>>>>>>    Procedure Clear_Set
25413>>>>>>>>>>>>>>>        Broadcast Send clear_set
25415>>>>>>>>>>>>>>>    End_Procedure
25416>>>>>>>>>>>>>>>    
25416>>>>>>>>>>>>>>>    //
25416>>>>>>>>>>>>>>>    // created for property support
25416>>>>>>>>>>>>>>>    //
25416>>>>>>>>>>>>>>>    Function Changed_State Returns Integer
25418>>>>>>>>>>>>>>>        Integer retval
25418>>>>>>>>>>>>>>>        Get Private.Changed_State to retval
25419>>>>>>>>>>>>>>>        Function_Return retval
25420>>>>>>>>>>>>>>>    End_Function
25421>>>>>>>>>>>>>>>    
25421>>>>>>>>>>>>>>>    //
25421>>>>>>>>>>>>>>>    // cancelled from Server mixin
25421>>>>>>>>>>>>>>>    //
25421>>>>>>>>>>>>>>>    Procedure Set Changed_State Integer newVal
25423>>>>>>>>>>>>>>>    End_Procedure
25424>>>>>>>>>>>>>>>    
25424>>>>>>>>>>>>>>>    //
25424>>>>>>>>>>>>>>>    // created for EntItem convenience
25424>>>>>>>>>>>>>>>    //
25424>>>>>>>>>>>>>>>    Procedure Entry_Clear Integer file#
25426>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Clear file#
25430>>>>>>>>>>>>>>>    End_Procedure
25431>>>>>>>>>>>>>>>    
25431>>>>>>>>>>>>>>>    //
25431>>>>>>>>>>>>>>>    // created for EntItem convenience
25431>>>>>>>>>>>>>>>    //
25431>>>>>>>>>>>>>>>    Procedure Entry_Clear_All Integer file#
25433>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Clear_All file#
25437>>>>>>>>>>>>>>>    End_Procedure
25438>>>>>>>>>>>>>>>    
25438>>>>>>>>>>>>>>>    //
25438>>>>>>>>>>>>>>>    // created for EntItem convenience
25438>>>>>>>>>>>>>>>    //
25438>>>>>>>>>>>>>>>    Procedure Entry_Display Integer file# Integer flag
25440>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Display file# flag
25444>>>>>>>>>>>>>>>    End_Procedure
25445>>>>>>>>>>>>>>>    
25445>>>>>>>>>>>>>>>    Procedure End_Construct_Object
25447>>>>>>>>>>>>>>>        Send Mark_Components      // nesting
25448>>>>>>>>>>>>>>>        Send Define_Access_Keys 0 // action_bar_keys
25449>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
25451>>>>>>>>>>>>>>>    End_Procedure
25452>>>>>>>>>>>>>>>    
25452>>>>>>>>>>>>>>>    // Added for deo delegate support
25452>>>>>>>>>>>>>>>    Procedure Request_Clear
25454>>>>>>>>>>>>>>>        Integer obj# retval foc
25454>>>>>>>>>>>>>>>        If (should_delegate_clear(Self)) ;            Delegate Send request_clear
25458>>>>>>>>>>>>>>>        Else Begin
25459>>>>>>>>>>>>>>>            Get Locate_Server to obj# // locate needed in case this is a DSO
25460>>>>>>>>>>>>>>>            If (should_save(Self) and ;                (Verify_Data_Loss(Self) <> 0)) ;                Procedure_Return
25463>>>>>>>>>>>>>>>            
25463>>>>>>>>>>>>>>>            Get Focus of desktop to Foc
25464>>>>>>>>>>>>>>>            Get Object_Item_Validation of Foc to retval
25465>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to False
25466>>>>>>>>>>>>>>>            
25466>>>>>>>>>>>>>>>            If (obj# <> 0) ;                Send Clear to obj#
25469>>>>>>>>>>>>>>>            Else ;                Send entry_clear 0
25471>>>>>>>>>>>>>>>            If (Auto_Top_Panel_State(Self)) ;                Send beginning_of_panel
25474>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to retval
25475>>>>>>>>>>>>>>>        End
25475>>>>>>>>>>>>>>>>
25475>>>>>>>>>>>>>>>    End_Procedure
25476>>>>>>>>>>>>>>>    
25476>>>>>>>>>>>>>>>    Procedure Request_Clear_All
25478>>>>>>>>>>>>>>>        Integer obj# retval foc
25478>>>>>>>>>>>>>>>        If (should_delegate_clear(Self)) ;            Delegate Send request_clear_all
25482>>>>>>>>>>>>>>>        Else Begin
25483>>>>>>>>>>>>>>>            Get Locate_Server to obj#
25484>>>>>>>>>>>>>>>            If (Should_Save(Self) and ;                (Verify_Data_Loss(Self) <> 0)) ;                Procedure_Return
25487>>>>>>>>>>>>>>>            
25487>>>>>>>>>>>>>>>            Get Focus of desktop to Foc
25488>>>>>>>>>>>>>>>            Get Object_Item_Validation of Foc to retval
25489>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to False
25490>>>>>>>>>>>>>>>            
25490>>>>>>>>>>>>>>>            If (obj# <> 0) ;                Send clear_all to obj#
25493>>>>>>>>>>>>>>>            Else ;                Send entry_clear_all 0
25495>>>>>>>>>>>>>>>            If (Auto_Top_Panel_State(Self)) ;                Send beginning_of_panel
25498>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to retval
25499>>>>>>>>>>>>>>>        End
25499>>>>>>>>>>>>>>>>
25499>>>>>>>>>>>>>>>    End_Procedure
25500>>>>>>>>>>>>>>>    
25500>>>>>>>>>>>>>>>    Procedure Request_Delete
25502>>>>>>>>>>>>>>>        Integer obj#
25502>>>>>>>>>>>>>>>        
25502>>>>>>>>>>>>>>>        If (should_delegate_delete(Self)) ;            Delegate Send request_delete
25506>>>>>>>>>>>>>>>        Else Begin
25507>>>>>>>>>>>>>>>            Move False to Err
25508>>>>>>>>>>>>>>>            Get Locate_Server to obj#
25509>>>>>>>>>>>>>>>            If (obj# <> 0 and can_delete(obj#) <> 0) Begin
25511>>>>>>>>>>>>>>>                If (Verify_Delete(Self) <> 0) ;                    Procedure_Return
25514>>>>>>>>>>>>>>>                Set changed_State to False
25515>>>>>>>>>>>>>>>                If (Deferred_State(Self)) ;                    Send Request_Assign to obj# 0  //0 means main_file of Server
25518>>>>>>>>>>>>>>>                Send Request_Delete to obj#
25519>>>>>>>>>>>>>>>                // ignore auto_clear_deo_state in deletes. Always clear deleted record
25519>>>>>>>>>>>>>>>                If (not(err)) ;                    Send Request_Clear
25522>>>>>>>>>>>>>>>            End
25522>>>>>>>>>>>>>>>>
25522>>>>>>>>>>>>>>>        End
25522>>>>>>>>>>>>>>>>
25522>>>>>>>>>>>>>>>    End_Procedure
25523>>>>>>>>>>>>>>>    
25523>>>>>>>>>>>>>>>    Procedure Request_Find Integer mode Integer entUpdtFlag
25525>>>>>>>>>>>>>>>        If (should_delegate_find(Self)) ;            Delegate Send request_find mode entUpdtFlag
25529>>>>>>>>>>>>>>>        Else Begin // for now don't support any default find behavior
25530>>>>>>>>>>>>>>>            // in clients
25530>>>>>>>>>>>>>>>            Procedure_Return
25531>>>>>>>>>>>>>>>        End
25531>>>>>>>>>>>>>>>>
25531>>>>>>>>>>>>>>>    End_Procedure
25532>>>>>>>>>>>>>>>    
25532>>>>>>>>>>>>>>>    Procedure Request_Save
25534>>>>>>>>>>>>>>>        Integer obj# retval
25534>>>>>>>>>>>>>>>        
25534>>>>>>>>>>>>>>>        If (should_delegate_save(Self)) ;            Delegate Send request_save
25538>>>>>>>>>>>>>>>        Else Begin
25539>>>>>>>>>>>>>>>            Get Locate_Server to obj#
25540>>>>>>>>>>>>>>>            
25540>>>>>>>>>>>>>>>            If (obj# <> 0 and not(Read_Only_State(obj#))) Begin
25542>>>>>>>>>>>>>>>                Move False to Err
25543>>>>>>>>>>>>>>>                
25543>>>>>>>>>>>>>>>                If (Should_Save(Self)) Begin
25545>>>>>>>>>>>>>>>                    Get Request_Validate of obj# to retval
25546>>>>>>>>>>>>>>>                    If (retval <> 0) ;                        Procedure_Return
25549>>>>>>>>>>>>>>>                    //
25549>>>>>>>>>>>>>>>                    // modification for Verify support
25549>>>>>>>>>>>>>>>                    //
25549>>>>>>>>>>>>>>>                    If (Verify_Save(Self) <> 0) ;                        Procedure_Return
25552>>>>>>>>>>>>>>>                    //
25552>>>>>>>>>>>>>>>                    // modification for Save support
25552>>>>>>>>>>>>>>>                    //
25552>>>>>>>>>>>>>>>                    If (Deferred_State(Self)) ;                        Send Request_Assign to obj# 0  //0 means main_file of server
25555>>>>>>>>>>>>>>>                    
25555>>>>>>>>>>>>>>>                    Send Request_Save to obj#
25556>>>>>>>>>>>>>>>                End
25556>>>>>>>>>>>>>>>>
25556>>>>>>>>>>>>>>>                //
25556>>>>>>>>>>>>>>>                If (not(err) and Auto_Clear_DEO_State(Self)) ;                    Send Request_Clear
25559>>>>>>>>>>>>>>>            End
25559>>>>>>>>>>>>>>>>
25559>>>>>>>>>>>>>>>        End
25559>>>>>>>>>>>>>>>>
25559>>>>>>>>>>>>>>>    End_Procedure
25560>>>>>>>>>>>>>>>    
25560>>>>>>>>>>>>>>>    // this allows us to save a record without it clearing regardless of
25560>>>>>>>>>>>>>>>    // the Auto_Clear_DEO_State value
25560>>>>>>>>>>>>>>>    //
25560>>>>>>>>>>>>>>>    Procedure Request_Save_No_Clear
25562>>>>>>>>>>>>>>>        Integer oldclr
25562>>>>>>>>>>>>>>>        If (should_delegate_save(Self)) ;            Delegate Send request_save_no_clear
25566>>>>>>>>>>>>>>>        Else Begin
25567>>>>>>>>>>>>>>>            Get Auto_Clear_DEO_State to OldClr  // whatever it was
25568>>>>>>>>>>>>>>>            Set Auto_Clear_DEO_State to False   // it is no NO!
25569>>>>>>>>>>>>>>>            Send request_save                   // do your magic
25570>>>>>>>>>>>>>>>            Set Auto_Clear_DEO_State to OldClr  // back to whatever it was
25571>>>>>>>>>>>>>>>        End
25571>>>>>>>>>>>>>>>>
25571>>>>>>>>>>>>>>>    End_Procedure
25572>>>>>>>>>>>>>>>    
25572>>>>>>>>>>>>>>>    Procedure Request_Superfind Integer mode
25574>>>>>>>>>>>>>>>        Integer ser# datafile
25574>>>>>>>>>>>>>>>        
25574>>>>>>>>>>>>>>>        If (should_delegate_find(Self)) ;            Delegate Send request_superfind mode
25578>>>>>>>>>>>>>>>        Else Begin
25579>>>>>>>>>>>>>>>            Procedure_Return
25580>>>>>>>>>>>>>>>        End
25580>>>>>>>>>>>>>>>>
25580>>>>>>>>>>>>>>>    End_Procedure
25581>>>>>>>>>>>>>>>    
25581>>>>>>>>>>>>>>>    //  Augment to Support AutoLocate.
25581>>>>>>>>>>>>>>>    //  This replaces (not augments) the procedure in actionbr. We need
25581>>>>>>>>>>>>>>>    //  to look into this (activating is very risky to augment activating
25581>>>>>>>>>>>>>>>    //  in mixins).
25581>>>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25581>>>>>>>>>>>>>>>    Procedure Activating // Returns Integer
25583>>>>>>>>>>>>>>>        Integer InvokingId RVal
25583>>>>>>>>>>>>>>>        Get Focus of desktop to InvokingId
25584>>>>>>>>>>>>>>>        //
25584>>>>>>>>>>>>>>>        Forward Get MSG_activating to rVal   //  This is the standard
25586>>>>>>>>>>>>>>>        If rVal ;            Procedure_Return rVal        //  actionbr activating
25589>>>>>>>>>>>>>>>        Send Add_action_bar                  //  logic
25590>>>>>>>>>>>>>>>        If (Auto_Locate_State(Self) ) ;            Send Auto_Locate InvokingId
25593>>>>>>>>>>>>>>>    End_Procedure
25594>>>>>>>>>>>>>>>    
25594>>>>>>>>>>>>>>>    // add this so that all db clients delegate this message.
25594>>>>>>>>>>>>>>>    // this is used to catch sub-views (tabview). Tab views (sub
25594>>>>>>>>>>>>>>>    // views) will augment this to do something useful
25594>>>>>>>>>>>>>>>    Function SubView_Changed Returns Integer
25596>>>>>>>>>>>>>>>        Integer hObj
25596>>>>>>>>>>>>>>>        Broadcast Get SubView_Changed to hObj
25598>>>>>>>>>>>>>>>        Function_Return hObj
25599>>>>>>>>>>>>>>>    End_Function
25600>>>>>>>>>>>>>>>    
25600>>>>>>>>>>>>>>>    // these are needed to pass these on to possible tabview.
25600>>>>>>>>>>>>>>>    Function Opening_view_Recursive Returns Integer
25602>>>>>>>>>>>>>>>        Integer bFail
25602>>>>>>>>>>>>>>>        Broadcast Get Opening_View_Recursive to bFail
25604>>>>>>>>>>>>>>>        Function_Return bFail
25605>>>>>>>>>>>>>>>    End_Function
25606>>>>>>>>>>>>>>>    
25606>>>>>>>>>>>>>>>    // these are needed to pass these on to possible tabview.
25606>>>>>>>>>>>>>>>    Procedure Seed_Data_Sets_Recursive
25608>>>>>>>>>>>>>>>        Broadcast Send Seed_Data_Sets_Recursive
25610>>>>>>>>>>>>>>>    End_Procedure
25611>>>>>>>>>>>>>>>    
25611>>>>>>>>>>>>>>>    // as of 17.0, clients are added to a DDOs DEO list, which means they receive the messages
25611>>>>>>>>>>>>>>>    // Refresh, Validate_Items and Entry_Update. These are stubs. The Refresh message is the one
25611>>>>>>>>>>>>>>>    // that will be useful. A developer can use this to process DD changes within a view or other
25611>>>>>>>>>>>>>>>    // container
25611>>>>>>>>>>>>>>>    
25611>>>>>>>>>>>>>>>    Procedure Refresh Integer eMode
25613>>>>>>>>>>>>>>>    End_Procedure
25614>>>>>>>>>>>>>>>    
25614>>>>>>>>>>>>>>>    Function Validate_Items Returns Integer
25616>>>>>>>>>>>>>>>    End_Function
25617>>>>>>>>>>>>>>>    
25617>>>>>>>>>>>>>>>    Procedure Entry_Update Integer file# Integer flag
25619>>>>>>>>>>>>>>>    End_Procedure
25620>>>>>>>>>>>>>>>    
25620>>>>>>>>>>>>>>>    Function Data_File Integer iItem Returns Integer
25622>>>>>>>>>>>>>>>        Function_Return 0
25623>>>>>>>>>>>>>>>    End_Function
25624>>>>>>>>>>>>>>>    
25624>>>>>>>>>>>>>>>    Function Data_Field Integer iItem Returns Integer
25626>>>>>>>>>>>>>>>        Function_Return 0
25627>>>>>>>>>>>>>>>    End_Function
25628>>>>>>>>>>>>>>>    
25628>>>>>>>>>>>>>>>    
25628>>>>>>>>>>>>>>>End_Class
25629>>>>>>>>>>>>>>>
25629>>>>>>>>>>>>>>>
25629>>>>>>>>>>>>>>>Define DEFAULT_VIEW_LATCH_STATE         for 1
25629>>>>>>>>>>>>>>>Define DEFAULT_VIEW_STATIC_SERVER_STATE for 1
25629>>>>>>>>>>>>>>>Define DEFAULT_DSO_DETACH_MODE          for DETACH_IF_NO_CHANGE
25629>>>>>>>>>>>>>>>
25629>>>>>>>>>>>>>>>Class Entry_View_Client_mixin is a mixin
25630>>>>>>>>>>>>>>>    Procedure Construct_Object Integer img#
25632>>>>>>>>>>>>>>>        Forward Send construct_object img#
25634>>>>>>>>>>>>>>>        Property String View_Name ''  // default name...could be useful
25635>>>>>>>>>>>>>>>        Set scope_State to True         // defaults to a Scope
25636>>>>>>>>>>>>>>>        Set Attach_Parent_State to True // default...controls parentage better
25637>>>>>>>>>>>>>>>        Set Ring_State to True          // default to Ring...makes sense
25638>>>>>>>>>>>>>>>        
25638>>>>>>>>>>>>>>>        Property Integer DSO_Detach_Mode          Default_DSO_Detach_Mode
25639>>>>>>>>>>>>>>>        Property Integer DEO_Attach_All_State     False
25640>>>>>>>>>>>>>>>        
25640>>>>>>>>>>>>>>>        Property Integer View_Latch_State         True  // Default_View_Latch_State
25641>>>>>>>>>>>>>>>        Property Integer Main_DD                  0
25642>>>>>>>>>>>>>>>        // keeps track of main-file record when new view is entered!
25642>>>>>>>>>>>>>>>        
25642>>>>>>>>>>>>>>>        Property RowID priInitialRowId
25643>>>>>>>>>>>>>>>        
25643>>>>>>>>>>>>>>>        // when false activate will attempt to activate the scope_focus
25643>>>>>>>>>>>>>>>        // when true, activate activates first object.
25643>>>>>>>>>>>>>>>        Property Integer Auto_Top_View_State      False
25644>>>>>>>>>>>>>>>
25644>>>>>>>>>>>>>>>        // When activate is performed (as opposed to set current_scope) the
25644>>>>>>>>>>>>>>>        // first focusable object is activated. Should the first item of the
25644>>>>>>>>>>>>>>>        // first object become the current_item?
25644>>>>>>>>>>>>>>>        // If Top_View is true and Top_Item is false you get the old dac
25644>>>>>>>>>>>>>>>        // behaviors.
25644>>>>>>>>>>>>>>>        Property Integer Auto_Top_Item_State      True
25645>>>>>>>>>>>>>>>        
25645>>>>>>>>>>>>>>>        // When changing views this will keep track of the object that had
25645>>>>>>>>>>>>>>>        // the focus when this view (scope) was exited. This manages nested
25645>>>>>>>>>>>>>>>        // scopes within a view.
25645>>>>>>>>>>>>>>>        Property Integer private.Last_View_Focus  0
25646>>>>>>>>>>>>>>>        Property Integer wasNotinUse_State        False // internal use
25647>>>>>>>>>>>>>>>    End_Procedure
25648>>>>>>>>>>>>>>>    
25648>>>>>>>>>>>>>>>    // Augment exit_application_check. If a change
25648>>>>>>>>>>>>>>>    // is detected activate the changed view. This way the user sees what
25648>>>>>>>>>>>>>>>    // has been changed.
25648>>>>>>>>>>>>>>>    //
25648>>>>>>>>>>>>>>>    Function Exit_Application_Check Returns Integer
25650>>>>>>>>>>>>>>>        Integer rVal Obj
25650>>>>>>>>>>>>>>>        
25650>>>>>>>>>>>>>>>        Get Should_Save to Rval // changes in this object???
25651>>>>>>>>>>>>>>>        If (rVal = 0) ;            Broadcast Get Exit_Application_Check to Rval // check w/ kids
25655>>>>>>>>>>>>>>>        
25655>>>>>>>>>>>>>>>        If (rVal <> 0) Begin  // ok a change exist...activate changed view.
25657>>>>>>>>>>>>>>>            //
25657>>>>>>>>>>>>>>>            // before activating the changed view make sure that we are not
25657>>>>>>>>>>>>>>>            // trying to activate this on top of a modal object. Check the current
25657>>>>>>>>>>>>>>>            // focus and all of its parent record up to (but not including) the
25657>>>>>>>>>>>>>>>            // desktop. If any of these object are modal (have block_mouse_state
25657>>>>>>>>>>>>>>>            // set to true) then do not display the changed view.
25657>>>>>>>>>>>>>>>            //
25657>>>>>>>>>>>>>>>            Get Focus of desktop to Obj
25658>>>>>>>>>>>>>>>            While Obj Gt DESKTOP
25662>>>>>>>>>>>>>>>                If (Block_Mouse_State(Obj)) ;                    Function_Return rVal // if modal..exit
25665>>>>>>>>>>>>>>>                Get Parent of Obj to Obj
25666>>>>>>>>>>>>>>>            Loop
25667>>>>>>>>>>>>>>>>
25667>>>>>>>>>>>>>>>            Send Activate
25668>>>>>>>>>>>>>>>        End
25668>>>>>>>>>>>>>>>>
25668>>>>>>>>>>>>>>>        Function_Return rVal
25669>>>>>>>>>>>>>>>    End_Function
25670>>>>>>>>>>>>>>>    
25670>>>>>>>>>>>>>>>    Function Opening_view_Recursive Returns Integer
25672>>>>>>>>>>>>>>>        Integer main bFail
25672>>>>>>>>>>>>>>>        Set delegation_mode to delegate_to_parent
25673>>>>>>>>>>>>>>>        Get Main_DD to Main
25674>>>>>>>>>>>>>>>        Set WasNotInUse_State to ( Main and In_use_State(Main)=0 )
25675>>>>>>>>>>>>>>>        Get Opening_View to bFail
25676>>>>>>>>>>>>>>>        If not bFail ;            Broadcast Get Opening_View_Recursive to bFail
25680>>>>>>>>>>>>>>>        Function_Return bFail
25681>>>>>>>>>>>>>>>    End_Function
25682>>>>>>>>>>>>>>>    
25682>>>>>>>>>>>>>>>    Procedure Seed_Data_Sets_Recursive
25684>>>>>>>>>>>>>>>        Integer NotInUse
25684>>>>>>>>>>>>>>>        Set delegation_mode to delegate_to_parent
25685>>>>>>>>>>>>>>>        Get WasNotInUse_State to NotInUse
25686>>>>>>>>>>>>>>>        If NotInUse ;            Send Seed_Data_Sets  // if ok, we've got blank in-use DSO.
25689>>>>>>>>>>>>>>>        Set WasNotInUse_State to False
25690>>>>>>>>>>>>>>>        Broadcast Send Seed_Data_Sets_Recursive
25692>>>>>>>>>>>>>>>    End_Procedure
25693>>>>>>>>>>>>>>>    
25693>>>>>>>>>>>>>>>    
25693>>>>>>>>>>>>>>>    //  Augmented to send Opening_view. If add_focus fails it sends
25693>>>>>>>>>>>>>>>    //  closing_view to reverse effects of Opening_view
25693>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
25695>>>>>>>>>>>>>>>        Integer rVal Main NotInUse
25695>>>>>>>>>>>>>>>        Get Opening_View_Recursive to rval
25696>>>>>>>>>>>>>>>        //
25696>>>>>>>>>>>>>>>        If (rVal = 0) Begin
25698>>>>>>>>>>>>>>>            // Connect DEOs and DSOs as required.
25698>>>>>>>>>>>>>>>            Send Connect_DEOs_to_Servers (DEO_Attach_All_State(Self))
25699>>>>>>>>>>>>>>>            Forward Get MSG_add_focus hoParent to rVal
25701>>>>>>>>>>>>>>>            Send Seed_Data_Sets_Recursive
25702>>>>>>>>>>>>>>>        End
25702>>>>>>>>>>>>>>>>
25702>>>>>>>>>>>>>>>        Procedure_Return rVal
25703>>>>>>>>>>>>>>>    End_Procedure
25704>>>>>>>>>>>>>>>    
25704>>>>>>>>>>>>>>>    // Augmented to Send Closing view
25704>>>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25704>>>>>>>>>>>>>>>    Procedure Deactivating //Returns Integer
25706>>>>>>>>>>>>>>>        Integer rVal
25706>>>>>>>>>>>>>>>        Forward Get MSG_Deactivating to rVal
25708>>>>>>>>>>>>>>>        If (rVal = 0) ;            Send closing_View
25711>>>>>>>>>>>>>>>    End_Procedure
25712>>>>>>>>>>>>>>>    
25712>>>>>>>>>>>>>>>    //  Disconnect servers from deos according to rules.
25712>>>>>>>>>>>>>>>    //
25712>>>>>>>>>>>>>>>    Procedure Closing_View
25714>>>>>>>>>>>>>>>        Integer Mode
25714>>>>>>>>>>>>>>>        Get DSO_Detach_Mode to Mode
25715>>>>>>>>>>>>>>>        // If we had a View with no DEOs the DSOs would remain in use. We
25715>>>>>>>>>>>>>>>        // will take the extra step to set all DSOs in-use-states to false.
25715>>>>>>>>>>>>>>>        Send Disconnect_DEOs_from_Servers Mode
25716>>>>>>>>>>>>>>>        // we assume that only DSOs understand Set In_Use_State and that
25716>>>>>>>>>>>>>>>        // no delegation occurs as part of setting this to false.
25716>>>>>>>>>>>>>>>        If (Mode = DETACH_ALWAYS) ;            Broadcast Recursive Set In_use_State to False
25720>>>>>>>>>>>>>>>    End_Procedure
25721>>>>>>>>>>>>>>>    
25721>>>>>>>>>>>>>>>    // use to preload anything into DSOs. By default, if a Main_DD is
25721>>>>>>>>>>>>>>>    // defined, we will attempt to latch on
25721>>>>>>>>>>>>>>>    // the record that was in the buffer when the view was entered!
25721>>>>>>>>>>>>>>>    Procedure Seed_Data_Sets
25723>>>>>>>>>>>>>>>        Integer srvr# File#
25723>>>>>>>>>>>>>>>        Integer bFill
25723>>>>>>>>>>>>>>>        RowID   riInitalRowId
25723>>>>>>>>>>>>>>>        Boolean bFound
25723>>>>>>>>>>>>>>>        Get Main_DD to srvr#
25724>>>>>>>>>>>>>>>        // If no Main-dd we don't do anything automatically, you are on your
25724>>>>>>>>>>>>>>>        // own to seed the data-sets any way you want.
25724>>>>>>>>>>>>>>>        If Srvr# Begin
25726>>>>>>>>>>>>>>>            Get auto_fill_State of srvr# to bFill
25727>>>>>>>>>>>>>>>            // if not auto-fill and we've got a record, someone went to a lot of
25727>>>>>>>>>>>>>>>            // trouble to set up a record. Don't change it. Normally this would
25727>>>>>>>>>>>>>>>            // occur w/ selection lists (which are not auto-fill) that seed the
25727>>>>>>>>>>>>>>>            // list in advance.
25727>>>>>>>>>>>>>>>            If ( bFill=0 and HasRecord(srvr#) ) ;                Procedure_Return
25730>>>>>>>>>>>>>>>            Get priInitialRowId to riInitalRowId
25731>>>>>>>>>>>>>>>            If ( not(IsNullRowId(riInitalRowId)) and View_Latch_State(Self) ) Begin
25733>>>>>>>>>>>>>>>                // if initial record and we latch, refind it via DSO
25733>>>>>>>>>>>>>>>                // Find & relate record manually and then perform
25733>>>>>>>>>>>>>>>                // a request_assign. This will not work if the finding file is
25733>>>>>>>>>>>>>>>                // a constrained child file
25733>>>>>>>>>>>>>>>                Get Main_file of Srvr# to File#
25734>>>>>>>>>>>>>>>                // we can now do this in a single step
25734>>>>>>>>>>>>>>>                Get FindByRowIdEx of srvr# File# riInitalRowId to bFound
25735>>>>>>>>>>>>>>>            End
25735>>>>>>>>>>>>>>>>
25735>>>>>>>>>>>>>>>            Else ;                 // if no initial record, do a formal                If not bFill ;                Send Clear to Srvr# // clear
25739>>>>>>>>>>>>>>>            // If the srvr is auto-fill and there was no initial record we
25739>>>>>>>>>>>>>>>            // will chose to do nothing under the assumption that the server
25739>>>>>>>>>>>>>>>            // has already done an auto-fill and its guess is as good as
25739>>>>>>>>>>>>>>>            // anything we could come up with.
25739>>>>>>>>>>>>>>>        End
25739>>>>>>>>>>>>>>>>
25739>>>>>>>>>>>>>>>    End_Procedure
25740>>>>>>>>>>>>>>>    
25740>>>>>>>>>>>>>>>    //  Needed by view. Find the record number of the requested file.
25740>>>>>>>>>>>>>>>    //  If file = 0 use the main_file of Main_DD (if it exists).
25740>>>>>>>>>>>>>>>    Function FileRowId Integer iFile Returns RowID
25742>>>>>>>>>>>>>>>        Handle hoMain
25742>>>>>>>>>>>>>>>        RowID  riID
25742>>>>>>>>>>>>>>>        // if file not passed use main-file of main data set
25742>>>>>>>>>>>>>>>        If (iFile=0) Begin
25744>>>>>>>>>>>>>>>            Get Main_DD to hoMain
25745>>>>>>>>>>>>>>>            If hoMain Begin
25747>>>>>>>>>>>>>>>                Get main_file of hoMain to iFile
25748>>>>>>>>>>>>>>>            End
25748>>>>>>>>>>>>>>>>
25748>>>>>>>>>>>>>>>        End
25748>>>>>>>>>>>>>>>>
25748>>>>>>>>>>>>>>>        If iFile Begin
25750>>>>>>>>>>>>>>>            Move (GetRowId(iFile)) to riId
25751>>>>>>>>>>>>>>>        End
25751>>>>>>>>>>>>>>>>
25751>>>>>>>>>>>>>>>        Function_Return riId
25752>>>>>>>>>>>>>>>    End_Function
25753>>>>>>>>>>>>>>>    
25753>>>>>>>>>>>>>>>    // We maintain Last_View_Focus to control for nested scopes. A normal
25753>>>>>>>>>>>>>>>    // will have its scope_state true and no scoped children. However, a
25753>>>>>>>>>>>>>>>    // zoom might be scoped. We control this by keeping track of the scope when
25753>>>>>>>>>>>>>>>    // a scope is exited.
25753>>>>>>>>>>>>>>>    
25753>>>>>>>>>>>>>>>    Procedure Set Last_View_Focus Integer Foc
25755>>>>>>>>>>>>>>>        Set private.Last_View_Focus to Foc
25756>>>>>>>>>>>>>>>    End_Procedure
25757>>>>>>>>>>>>>>>    
25757>>>>>>>>>>>>>>>    // Returns The last scope in the view to have the focus. Before returning
25757>>>>>>>>>>>>>>>    // the value make sure that the scope object is active, else return 0
25757>>>>>>>>>>>>>>>    Function Last_View_Focus Returns Integer
25759>>>>>>>>>>>>>>>        Integer foc
25759>>>>>>>>>>>>>>>        Get private.Last_View_Focus to Foc
25760>>>>>>>>>>>>>>>        // if not a valid object or this object is not active make it 0
25760>>>>>>>>>>>>>>>        If (Foc<=DESKTOP or Active_state(Self)=0 or Active_State(Foc)=0) ;            Move 0 to Foc
25763>>>>>>>>>>>>>>>        Function_Return Foc
25764>>>>>>>>>>>>>>>    End_Function
25765>>>>>>>>>>>>>>>    
25765>>>>>>>>>>>>>>>    // Take care of any buffer initialization
25765>>>>>>>>>>>>>>>    Function Opening_View Returns Integer
25767>>>>>>>>>>>>>>>        Integer main
25767>>>>>>>>>>>>>>>        RowID riId
25767>>>>>>>>>>>>>>>        
25767>>>>>>>>>>>>>>>        // if a main DSO exists and it is not in use we must perform
25767>>>>>>>>>>>>>>>        // any required pre-seeding logic.
25767>>>>>>>>>>>>>>>        //Get Main_DD to Main
25767>>>>>>>>>>>>>>>        //If ( Main AND In_use_State(Main)=0 ) Begin
25767>>>>>>>>>>>>>>>        If ( wasNotinUse_State(Self))  Begin
25769>>>>>>>>>>>>>>>            // Always clear all file buffers and keep track of the record number
25769>>>>>>>>>>>>>>>            // that was in the main-dso's file-buffer.
25769>>>>>>>>>>>>>>>            // This is used by seed_data_sets to seed as required.
25769>>>>>>>>>>>>>>>            Get FileRowId 0 to riId
25770>>>>>>>>>>>>>>>            Set priInitialRowId to riId
25771>>>>>>>>>>>>>>>            //Set Initial_Main_record to Rec#
25771>>>>>>>>>>>>>>>            Send Prepare_Data_Sets         // allow custom setting
25772>>>>>>>>>>>>>>>            Broadcast Send clear_main_file // Send refind_records to main
25774>>>>>>>>>>>>>>>        End
25774>>>>>>>>>>>>>>>>
25774>>>>>>>>>>>>>>>    End_Function
25775>>>>>>>>>>>>>>>    
25775>>>>>>>>>>>>>>>    // only called if Main_DD exists and it is not yet in-use
25775>>>>>>>>>>>>>>>    Procedure Prepare_Data_Sets
25777>>>>>>>>>>>>>>>    End_Procedure
25778>>>>>>>>>>>>>>>    
25778>>>>>>>>>>>>>>>    // added to make the file buffers more reliable
25778>>>>>>>>>>>>>>>    Procedure Entering_Scope Returns Integer
25780>>>>>>>>>>>>>>>        Integer rVal
25780>>>>>>>>>>>>>>>        Forward Get MSG_entering_scope to rVal
25782>>>>>>>>>>>>>>>        // The refind is probably a feature that should always happen.
25782>>>>>>>>>>>>>>>        // The main-data-set was a way to make this backwards compatable.
25782>>>>>>>>>>>>>>>        // Maybe that made no sense.
25782>>>>>>>>>>>>>>>        If (rVal = 0) ;            Broadcast Send refind_DD_records // only refinds in-use DDs.
25786>>>>>>>>>>>>>>>        Procedure_Return rVal
25787>>>>>>>>>>>>>>>    End_Procedure
25788>>>>>>>>>>>>>>>    
25788>>>>>>>>>>>>>>>    // Augment to keep track of the scope that had the focus when this
25788>>>>>>>>>>>>>>>    // view was exited. Exiting_Scope seems to get called at the right
25788>>>>>>>>>>>>>>>    // times - only when focus is moved to an object outside of view's focus.
25788>>>>>>>>>>>>>>>    Procedure Exiting_Scope Handle hoNewScope
25790>>>>>>>>>>>>>>>        Integer rVal
25790>>>>>>>>>>>>>>>        Forward Get MSG_Exiting_Scope hoNewScope to rVal
25792>>>>>>>>>>>>>>>        If (rVal = 0) ;            Set Last_View_Focus to (Current_Scope(Self))
25795>>>>>>>>>>>>>>>    End_Procedure
25796>>>>>>>>>>>>>>>    
25796>>>>>>>>>>>>>>>    //  Augmented to allow views to take the focus without changing the
25796>>>>>>>>>>>>>>>    //  focus within the object. The property Auto_top_View_State controls
25796>>>>>>>>>>>>>>>    //  this. If true, always return to first object, first item. If false
25796>>>>>>>>>>>>>>>    //  return to current-item of scope focus (when possible).
25796>>>>>>>>>>>>>>>    //
25796>>>>>>>>>>>>>>>    Procedure Activate Returns Integer
25798>>>>>>>>>>>>>>>        Integer rVal Foc
25798>>>>>>>>>>>>>>>        If ( Auto_Top_View_State(Self)=0 and ; // Do we want behavior?            scope_state(Self) and ;           // s/b true.            Active_state(Self) ) Begin        // Only if active.
25800>>>>>>>>>>>>>>>            // Last_View_Focus is the last scope to have the focus.
25800>>>>>>>>>>>>>>>            // It should be active (if not the prop is 0).
25800>>>>>>>>>>>>>>>            // If for some reason the focus is 0, do a vanilla activate.
25800>>>>>>>>>>>>>>>            Get Last_View_Focus to Foc
25801>>>>>>>>>>>>>>>            If Foc ;                Set Current_Scope to Foc
25804>>>>>>>>>>>>>>>            Else ;                Forward Get Msg_Activate to rVal
25807>>>>>>>>>>>>>>>        End
25807>>>>>>>>>>>>>>>>
25807>>>>>>>>>>>>>>>        Else Begin
25808>>>>>>>>>>>>>>>            Forward Get Msg_Activate to rVal
25810>>>>>>>>>>>>>>>            // first Item of first object.
25810>>>>>>>>>>>>>>>            If ( Rval=0 and Auto_Top_Item_State(Self) ) ;                Send Beginning_of_Panel
25813>>>>>>>>>>>>>>>        End
25813>>>>>>>>>>>>>>>>
25813>>>>>>>>>>>>>>>        Procedure_Return rVal
25814>>>>>>>>>>>>>>>    End_Procedure
25815>>>>>>>>>>>>>>>    
25815>>>>>>>>>>>>>>>    // Views don't delegate to get this property. It uses system default
25815>>>>>>>>>>>>>>>    Function Default_Static_Server_State Returns Integer
25817>>>>>>>>>>>>>>>        Function_Return DEFAULT_VIEW_STATIC_SERVER_STATE
25818>>>>>>>>>>>>>>>    End_Function
25819>>>>>>>>>>>>>>>    
25819>>>>>>>>>>>>>>>End_Class
25820>>>>>>>>>>>>>>>
25820>>>>>>>>>>>>>>>//
25820>>>>>>>>>>>>>>>//  Client for Selection Lists.
25820>>>>>>>>>>>>>>>//
25820>>>>>>>>>>>>>>>//  Selection_lists and Pick_lists need to know if they should
25820>>>>>>>>>>>>>>>//  move their values out. With simple sel/pick lists it figures this
25820>>>>>>>>>>>>>>>//  out if the list is a popup object. (POPUP sets the property
25820>>>>>>>>>>>>>>>//  move_value_out_state to TRUE. If the sel\pick list needs to be
25820>>>>>>>>>>>>>>>//  encapulsated by a client the actual list object is no longer a
25820>>>>>>>>>>>>>>>//  popup (the client is). We need this special client to set the
25820>>>>>>>>>>>>>>>//  move_value_out_state of the list. It does this by broadcasting
25820>>>>>>>>>>>>>>>//  this to all objects. This only works if the sel/pick list object is
25820>>>>>>>>>>>>>>>//  a direct child of the client (which it always will be).
25820>>>>>>>>>>>>>>>//
25820>>>>>>>>>>>>>>>//  Also note that this class supports movable objects
25820>>>>>>>>>>>>>>>
25820>>>>>>>>>>>>>>>Register_Procedure Set Move_Value_Out_State Integer State
25820>>>>>>>>>>>>>>>
25820>>>>>>>>>>>>>>>// used to catch old obsolete syntax
25820>>>>>>>>>>>>>Use DFNav_mx.pkg // Navigation changes for DF DEOs
Including file: Dfnav_mx.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfnav_mx.pkg)
25820>>>>>>>>>>>>>>>Use VDFBase.pkg
25820>>>>>>>>>>>>>>>
25820>>>>>>>>>>>>>>>Class DFnavigate_mixin is a Mixin
25821>>>>>>>>>>>>>>>    
25821>>>>>>>>>>>>>>>    Procedure define_DFNavigation
25823>>>>>>>>>>>>>>>        
25823>>>>>>>>>>>>>>>        On_Key kSwitch            Send Switch_Next_Area   PRIVATE
25824>>>>>>>>>>>>>>>        On_Key kSwitch_Back       Send Switch_Prior_Area  PRIVATE
25825>>>>>>>>>>>>>>>        
25825>>>>>>>>>>>>>>>        //  Change Panel switching to view switching.
25825>>>>>>>>>>>>>>>        //  The messages Switch_next_view and Switch_Prior_View
25825>>>>>>>>>>>>>>>        //  need to be resolved (via delegation) in the view object.
25825>>>>>>>>>>>>>>>        //  This means that all dfentry object must be placed inside
25825>>>>>>>>>>>>>>>        //  of a view object. This might cause problems ... we will see.
25825>>>>>>>>>>>>>>>        
25825>>>>>>>>>>>>>>>    End_Procedure
25826>>>>>>>>>>>>>>>    
25826>>>>>>>>>>>>>>>    Procedure Close_Panel
25828>>>>>>>>>>>>>>>        Send Exit_Function
25829>>>>>>>>>>>>>>>    End_Procedure
25830>>>>>>>>>>>>>>>    
25830>>>>>>>>>>>>>>>End_Class
25831>>>>>>>>>>>>>Use dfConfrm.pkg
25831>>>>>>>>>>>>>Use Dfdbmdpn.pkg // adds obsolete pointerButton for dbModalPanel
Including file: Dfdbmdpn.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfdbmdpn.pkg)
25831>>>>>>>>>>>>>>>Use Windows.pkg
25831>>>>>>>>>>>>>>>
25831>>>>>>>>>>>>>>>Class PointerButton is a Button
25832>>>>>>>>>>>>>>>    
25832>>>>>>>>>>>>>>>    Procedure Construct_Object
25834>>>>>>>>>>>>>>>        Forward Send Construct_Object
25836>>>>>>>>>>>>>>>        Set focus_mode to pointer_Only
25837>>>>>>>>>>>>>>>    End_Procedure
25838>>>>>>>>>>>>>>>    
25838>>>>>>>>>>>>>>>    Procedure Command Integer i1 Integer i2
25840>>>>>>>>>>>>>>>        Send Redirect_Message
25841>>>>>>>>>>>>>>>    End_Procedure
25842>>>>>>>>>>>>>>>    
25842>>>>>>>>>>>>>>>    Procedure Redirect_Message Returns Integer
25844>>>>>>>>>>>>>>>        Integer msg obj rval
25844>>>>>>>>>>>>>>>        Get message 0 to Msg
25845>>>>>>>>>>>>>>>        Get Aux_Value 0 to obj
25846>>>>>>>>>>>>>>>        If Msg ;            Get Msg of ( If(obj, obj, Focus(desktop)) ) to rval
25849>>>>>>>>>>>>>>>        Procedure_Return rval
25850>>>>>>>>>>>>>>>    End_Procedure
25851>>>>>>>>>>>>>>>    
25851>>>>>>>>>>>>>>>End_Class
25852>>>>>>>>>>>>>Use Dfdafmac.pkg
Including file: Dfdafmac.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfdafmac.pkg)
25852>>>>>>>>>>>>>>>Use Windows.pkg
25852>>>>>>>>>>>>>>>Use dfcursor.pkg
25852>>>>>>>>>>>>>>>
25852>>>>>>>>>>>>>>>
25852>>>>>>>>>>>>>>>//  This expects to create a view INSIDE of another object
25852>>>>>>>>>>>>>>>//  (Like a panel)
25852>>>>>>>>>>>>>>>//
25852>>>>>>>>>>>>>>>
25852>>>>>>>>>>>>>>>
25852>>>>>>>>>>>>>>>Define DEFERRED_OBJECT for Deferred_View
25852>>>>>>>>>>>>>>>
25852>>>>>>>>>>>>>>>Class CD_Client is a Container
25853>>>>>>>>>>>>>>>    
25853>>>>>>>>>>>>>>>    Procedure Construct_Object
25855>>>>>>>>>>>>>>>        Forward Send Construct_Object
25857>>>>>>>>>>>>>>>        
25857>>>>>>>>>>>>>>>        Property Integer Created_object_id 0
25858>>>>>>>>>>>>>>>        
25858>>>>>>>>>>>>>>>        Set focus_mode to nonfocusable
25859>>>>>>>>>>>>>>>    End_Procedure
25860>>>>>>>>>>>>>>>    
25860>>>>>>>>>>>>>>>    Procedure Popup
25862>>>>>>>>>>>>>>>        Send Popup_Modal
25863>>>>>>>>>>>>>>>    End_Procedure
25864>>>>>>>>>>>>>>>    
25864>>>>>>>>>>>>>>>    Register_Function Destroy_Object_State Returns Integer
25864>>>>>>>>>>>>>>>    
25864>>>>>>>>>>>>>>>    // is augmented by object instance. Should never
25864>>>>>>>>>>>>>>>    // be called.
25864>>>>>>>>>>>>>>>    Function Popup_Handle Returns Handle
25866>>>>>>>>>>>>>>>        Error DFERR_PROGRAM "Improper use of CD_Popup_Object command"
25867>>>>>>>>>>>>>>>>
25867>>>>>>>>>>>>>>>    End_Function
25868>>>>>>>>>>>>>>>    
25868>>>>>>>>>>>>>>>    Procedure Popup_Modal Returns Integer
25870>>>>>>>>>>>>>>>        Integer iRet
25870>>>>>>>>>>>>>>>        Handle hoId
25870>>>>>>>>>>>>>>>        Boolean bDestroy
25870>>>>>>>>>>>>>>>        Get Popup_Handle to hoId
25871>>>>>>>>>>>>>>>        If hoId Begin
25873>>>>>>>>>>>>>>>            Get msg_Popup_Modal of hoId to iRet
25874>>>>>>>>>>>>>>>            Get Destroy_Object_State of hoId to bDestroy
25875>>>>>>>>>>>>>>>            If bDestroy Begin
25877>>>>>>>>>>>>>>>                Send Destroy of hoId
25878>>>>>>>>>>>>>>>                Set Created_Object_Id to 0
25879>>>>>>>>>>>>>>>            End
25879>>>>>>>>>>>>>>>>
25879>>>>>>>>>>>>>>>            Procedure_Return iRet
25880>>>>>>>>>>>>>>>        End
25880>>>>>>>>>>>>>>>>
25880>>>>>>>>>>>>>>>    End_Procedure
25881>>>>>>>>>>>>>>>    
25881>>>>>>>>>>>>>>>End_Class
25882>>>>>>>>>>>>>>>
25882>>>>>>>>>>>>>>>
25882>>>>>>>>>>>>>>>
25882>>>>>>>>>>>>>
25882>>>>>>>>>>>>>Register_Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
25882>>>>>>>>>>>>>Register_Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
25882>>>>>>>>>>>>>
25882>>>>>>>>>>>>>Register_Function Data_Set_Should_Save Returns Integer
25882>>>>>>>>>>>>>
25882>>>>>>>>>>>>>//
25882>>>>>>>>>>>>>//  Grouping classes: Used within views to group objects
25882>>>>>>>>>>>>>//
25882>>>>>>>>>>>>>//  dbContainer3d_
25882>>>>>>>>>>>>>//     dbContainer3d
25882>>>>>>>>>>>>>//
25882>>>>>>>>>>>>>Class dbContainer3d_ is a Container3d STARTMAC ECstart
25883>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25883>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin // mixin in CM DEO behaviors
25884>>>>>>>>>>>>>    
25884>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25884>>>>>>>>>>>>>    //
25884>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25884>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25886>>>>>>>>>>>>>        Integer RVal
25886>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25888>>>>>>>>>>>>>        Procedure_Return rVal
25889>>>>>>>>>>>>>    End_Procedure
25890>>>>>>>>>>>>>End_Class
25891>>>>>>>>>>>>>
25891>>>>>>>>>>>>>Class dbContainer3d is a dbContainer3d_
25892>>>>>>>>>>>>>    Procedure Construct_Object
25894>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25896>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25897>>>>>>>>>>>>>    End_Procedure
25898>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25899>>>>>>>>>>>>>End_Class
25900>>>>>>>>>>>>>
25900>>>>>>>>>>>>>//
25900>>>>>>>>>>>>>// Group Based containers
25900>>>>>>>>>>>>>//
25900>>>>>>>>>>>>>//  dbGroup_
25900>>>>>>>>>>>>>//     dbGroup
25900>>>>>>>>>>>>>//
25900>>>>>>>>>>>>>Class dbGroup_ is a Group STARTMAC ECstart
25901>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25901>>>>>>>>>>>>>    
25901>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25902>>>>>>>>>>>>>    
25902>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25902>>>>>>>>>>>>>    //
25902>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25902>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25904>>>>>>>>>>>>>        Integer RVal
25904>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25906>>>>>>>>>>>>>        Procedure_Return rVal
25907>>>>>>>>>>>>>    End_Procedure
25908>>>>>>>>>>>>>End_Class
25909>>>>>>>>>>>>>
25909>>>>>>>>>>>>>Class dbGroup is a dbGroup_
25910>>>>>>>>>>>>>    Procedure Construct_Object
25912>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25914>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25915>>>>>>>>>>>>>    End_Procedure
25916>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25917>>>>>>>>>>>>>End_Class
25918>>>>>>>>>>>>>
25918>>>>>>>>>>>>>
25918>>>>>>>>>>>>>//
25918>>>>>>>>>>>>>// Invisible Grouping object
25918>>>>>>>>>>>>>//
25918>>>>>>>>>>>>>//   dbContainer - invisible container
25918>>>>>>>>>>>>>//
25918>>>>>>>>>>>>>Class dbContainer is an dbContainer3d
25919>>>>>>>>>>>>>    Import_Class_Protocol NonVisual_Container_Mixin
25920>>>>>>>>>>>>>End_Class
25921>>>>>>>>>>>>>
25921>>>>>>>>>>>>>//
25921>>>>>>>>>>>>>// View Support (views are mdi dialogs)
25921>>>>>>>>>>>>>//
25921>>>>>>>>>>>>>//   dbAppClient_
25921>>>>>>>>>>>>>//     dbAppView_
25921>>>>>>>>>>>>>//       dbView
25921>>>>>>>>>>>>>//
25921>>>>>>>>>>>>>Class dbAppClient_ is a View  STARTMAC ECstart
25922>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25922>>>>>>>>>>>>>    
25922>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25923>>>>>>>>>>>>>    
25923>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25923>>>>>>>>>>>>>    //
25923>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25923>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25925>>>>>>>>>>>>>        Integer RVal
25925>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25927>>>>>>>>>>>>>        Procedure_Return rVal
25928>>>>>>>>>>>>>    End_Procedure
25929>>>>>>>>>>>>>End_Class
25930>>>>>>>>>>>>>
25930>>>>>>>>>>>>>Class dbAppView_ is a dbAppClient_
25931>>>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
25932>>>>>>>>>>>>>End_Class
25933>>>>>>>>>>>>>
25933>>>>>>>>>>>>>Class dbView is a dbAppView_
25934>>>>>>>>>>>>>    
25934>>>>>>>>>>>>>    Procedure Construct_Object
25936>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25938>>>>>>>>>>>>>        
25938>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25939>>>>>>>>>>>>>        // dialog views get activated as popup objects.
25939>>>>>>>>>>>>>        Set Dso_Detach_Mode to Detach_Always
25940>>>>>>>>>>>>>        
25940>>>>>>>>>>>>>        // set default verify messages. These are good defaults. The
25940>>>>>>>>>>>>>        // developer may wish to change these in their object or sub-class.
25940>>>>>>>>>>>>>        // Note: these messsages are defined in dfconfrm.pkg
25940>>>>>>>>>>>>>        Set Verify_Data_Loss_Msg   to (RefFunc(Data_Loss_Confirmation))
25941>>>>>>>>>>>>>        Set Verify_Delete_Msg      to (RefFunc(Delete_Confirmation))
25942>>>>>>>>>>>>>        Set Verify_Save_Msg        to (RefFunc(Save_Confirmation))
25943>>>>>>>>>>>>>        Set Verify_Exit_Msg        to (RefFunc(Exit_Loss_Confirmation))
25944>>>>>>>>>>>>>        //
25944>>>>>>>>>>>>>    End_Procedure
25945>>>>>>>>>>>>>    
25945>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25946>>>>>>>>>>>>>    
25946>>>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
25946>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
25946>>>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
25946>>>>>>>>>>>>>    //
25946>>>>>>>>>>>>>    Function DEO_Object Returns Integer
25948>>>>>>>>>>>>>        Function_Return 1
25949>>>>>>>>>>>>>    End_Function
25950>>>>>>>>>>>>>    
25950>>>>>>>>>>>>>    //
25950>>>>>>>>>>>>>    //  Activate message for views that:
25950>>>>>>>>>>>>>    //  1. restores the view if it is minimized
25950>>>>>>>>>>>>>    //  2. Maintains the current scope's focus.
25950>>>>>>>>>>>>>    //
25950>>>>>>>>>>>>>    Procedure Activate_current_scope
25952>>>>>>>>>>>>>        If ( View_mode(Self)=VIEWMODE_ICONIZE ) ;            Set view_mode to viewmode_normal
25955>>>>>>>>>>>>>        Set Current_Scope to Self
25956>>>>>>>>>>>>>    End_Procedure
25957>>>>>>>>>>>>>    
25957>>>>>>>>>>>>>    // ------------deprecated....Use Object_label.
25957>>>>>>>>>>>>>    //  Pass full object name - return the relative name
25957>>>>>>>>>>>>>    //  e.g.,  Main.View.Obj1 --> Obj1
25957>>>>>>>>>>>>>    Function Local_Object_name String nm Returns String
25959>>>>>>>>>>>>>        Integer ps
25959>>>>>>>>>>>>>        Repeat
25959>>>>>>>>>>>>>>
25959>>>>>>>>>>>>>            Move (Pos( ".", nm)) to ps
25960>>>>>>>>>>>>>            If (ps = 0) ;                Function_Return nm
25963>>>>>>>>>>>>>            Increment ps
25964>>>>>>>>>>>>>            Move (Mid( Nm, 255, ps)) to Nm
25965>>>>>>>>>>>>>        Loop
25966>>>>>>>>>>>>>>
25966>>>>>>>>>>>>>    End_Function
25967>>>>>>>>>>>>>    
25967>>>>>>>>>>>>>    Function View_Changed Returns Integer
25969>>>>>>>>>>>>>        Integer Changed
25969>>>>>>>>>>>>>        // first see if any DDOs at this level are changed.
25969>>>>>>>>>>>>>        Broadcast Get Data_Set_Should_Save to Changed // Ask for changes in Data-sets
25971>>>>>>>>>>>>>        // if no changes, see if we have any sub-views that are changed
25971>>>>>>>>>>>>>        // This is used to catch tab-view pages.
25971>>>>>>>>>>>>>        If not Changed ;            Broadcast Get SubView_Changed to Changed
25975>>>>>>>>>>>>>        Function_Return Changed
25976>>>>>>>>>>>>>    End_Function
25977>>>>>>>>>>>>>    
25977>>>>>>>>>>>>>    Procedure Close_Client
25979>>>>>>>>>>>>>        Send Exit_Function
25980>>>>>>>>>>>>>    End_Procedure
25981>>>>>>>>>>>>>    
25981>>>>>>>>>>>>>End_Class
25982>>>>>>>>>>>>>
25982>>>>>>>>>>>>>
25982>>>>>>>>>>>>>
25982>>>>>>>>>>>>>//
25982>>>>>>>>>>>>>// ToolPanel Based Classes
25982>>>>>>>>>>>>>//
25982>>>>>>>>>>>>>//  dbFloatingPanel_
25982>>>>>>>>>>>>>//     dbFloatingPanel
25982>>>>>>>>>>>>>//        dbViewFloatingPanel
25982>>>>>>>>>>>>>//           dbViewToolPanel
25982>>>>>>>>>>>>>//           dbModalPanel <---this will get used
25982>>>>>>>>>>>>>//
25982>>>>>>>>>>>>>Class dbFloatingPanel_ is a FloatingPanel STARTMAC ECstart
25983>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25983>>>>>>>>>>>>>    
25983>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25984>>>>>>>>>>>>>    
25984>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25984>>>>>>>>>>>>>    //
25984>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25984>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25986>>>>>>>>>>>>>        Integer RVal
25986>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25988>>>>>>>>>>>>>        Procedure_Return rVal
25989>>>>>>>>>>>>>    End_Procedure
25990>>>>>>>>>>>>>End_Class
25991>>>>>>>>>>>>>
25991>>>>>>>>>>>>>Class dbFloatingPanel is a dbFloatingPanel_
25992>>>>>>>>>>>>>    Procedure Construct_Object
25994>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25996>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25997>>>>>>>>>>>>>        Set Minimize_Icon to False
25998>>>>>>>>>>>>>        Set Maximize_Icon to False
25999>>>>>>>>>>>>>    End_Procedure
26000>>>>>>>>>>>>>    
26000>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
26001>>>>>>>>>>>>>    
26001>>>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
26001>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
26001>>>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
26001>>>>>>>>>>>>>    //
26001>>>>>>>>>>>>>    Function DEO_Object Returns Integer
26003>>>>>>>>>>>>>        Function_Return 1
26004>>>>>>>>>>>>>    End_Function
26005>>>>>>>>>>>>>    
26005>>>>>>>>>>>>>    // we Modify this not delegate and look for a parent verify exit msg if this msg is 0.
26005>>>>>>>>>>>>>    // We assume that toolpanels and dbModalPanels are self contained in terms of opening and closing
26005>>>>>>>>>>>>>    // and therefore should only use themselves to figure out if there is a verify exit msg. This is needed
26005>>>>>>>>>>>>>    // in case a db modal panel physically placed inside of another DEO.
26005>>>>>>>>>>>>>    Function Verify_Exit_msg Returns Integer
26007>>>>>>>>>>>>>        Integer msg#
26007>>>>>>>>>>>>>        Get private.verify_exit_msg to msg#
26008>>>>>>>>>>>>>        // don't look at parent DEOs like we do elsewhere.
26008>>>>>>>>>>>>>        //if (msg# = 0 AND Component_State(self)) ;
26008>>>>>>>>>>>>>        //    delegate get verify_exit_msg to msg#
26008>>>>>>>>>>>>>        Function_Return msg#
26009>>>>>>>>>>>>>    End_Function
26010>>>>>>>>>>>>>    
26010>>>>>>>>>>>>>End_Class
26011>>>>>>>>>>>>>
26011>>>>>>>>>>>>>Class dbViewFloatingPanel is a dbFloatingPanel
26012>>>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
26013>>>>>>>>>>>>>End_Class
26014>>>>>>>>>>>>>
26014>>>>>>>>>>>>>Class dbViewToolPanel is a dbViewFloatingPanel
26015>>>>>>>>>>>>>    
26015>>>>>>>>>>>>>    Procedure Construct_Object
26017>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
26019>>>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_TOOLWINDOW True
26020>>>>>>>>>>>>>    End_Procedure
26021>>>>>>>>>>>>>    
26021>>>>>>>>>>>>>End_Class
26022>>>>>>>>>>>>>
26022>>>>>>>>>>>>>//  EntryModalPanel
26022>>>>>>>>>>>>>
26022>>>>>>>>>>>>>Class dbModalPanel is a dbViewFloatingPanel
26023>>>>>>>>>>>>>    Procedure Construct_Object
26025>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
26027>>>>>>>>>>>>>        
26027>>>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True
26028>>>>>>>>>>>>>        Set Modal_State to True
26029>>>>>>>>>>>>>        
26029>>>>>>>>>>>>>        Property Integer List_Object  0
26030>>>>>>>>>>>>>        
26030>>>>>>>>>>>>>        Property Integer Button_Height     14
26031>>>>>>>>>>>>>        Property Integer Button_Width      50
26032>>>>>>>>>>>>>        
26032>>>>>>>>>>>>>        Property Integer Max_Text_Extent   0
26033>>>>>>>>>>>>>        
26033>>>>>>>>>>>>>        Object Button_Ids is an array
26035>>>>>>>>>>>>>        End_Object
26036>>>>>>>>>>>>>    End_Procedure
26037>>>>>>>>>>>>>    
26037>>>>>>>>>>>>>    Function Button_Count Returns Integer
26039>>>>>>>>>>>>>        Function_Return (Item_count(Button_Ids))
26040>>>>>>>>>>>>>    End_Function
26041>>>>>>>>>>>>>    
26041>>>>>>>>>>>>>    Procedure Add_Button String sLabel Integer hMsg Integer hoTo
26043>>>>>>>>>>>>>        Integer hoBtn tx
26043>>>>>>>>>>>>>        // 8.2 - use newer syntax for creating dynamic objects
26043>>>>>>>>>>>>>        Get Create U_PointerButton to hoBtn
26044>>>>>>>>>>>>>        Set peAnchors of hoBtn to anBottomRight
26045>>>>>>>>>>>>>        Set Value of hoBtn 0 to sLabel
26046>>>>>>>>>>>>>        Set Message of hoBtn 0 to hMsg
26047>>>>>>>>>>>>>        If (Num_Arguments>2) ;            Set aux_value of hoBtn 0 to hoTo
26050>>>>>>>>>>>>>        Get Text_Extent of hoBtn sLabel to tx
26051>>>>>>>>>>>>>        Move (low(tx)) to tx
26052>>>>>>>>>>>>>        Set Array_Value of Button_Ids (Button_Count(Self)) to hoBtn
26053>>>>>>>>>>>>>        If (tx > Max_Text_Extent(Self));            Set Max_Text_Extent to tx
26056>>>>>>>>>>>>>    End_Procedure
26057>>>>>>>>>>>>>    
26057>>>>>>>>>>>>>    Procedure Size_Buttons
26059>>>>>>>>>>>>>        Integer bheight bwidth nb obj Bobj bt mt gsiz gwd
26059>>>>>>>>>>>>>        
26059>>>>>>>>>>>>>        Get button_height to bheight
26060>>>>>>>>>>>>>        Get button_width  to bwidth
26061>>>>>>>>>>>>>        Get Button_count to nb
26062>>>>>>>>>>>>>        Decrement nb
26063>>>>>>>>>>>>>        
26063>>>>>>>>>>>>>        Move Button_ids to obj
26064>>>>>>>>>>>>>        
26064>>>>>>>>>>>>>        For bt from 0 to nb
26070>>>>>>>>>>>>>>
26070>>>>>>>>>>>>>            Get integer_value of obj bt to bobj // button id
26071>>>>>>>>>>>>>            Set Size of bobj to bheight bwidth       // set dflt size
26072>>>>>>>>>>>>>            If (bt = 0) Begin
26074>>>>>>>>>>>>>                Get Max_Text_Extent to mt
26075>>>>>>>>>>>>>                Add 8 to mt
26076>>>>>>>>>>>>>                Get guisize of bobj to gsiz
26077>>>>>>>>>>>>>                Move (low(gsiz)) to gwd
26078>>>>>>>>>>>>>                If (gwd < mt) Begin
26080>>>>>>>>>>>>>                    Set guisize of bobj to (hi(gsiz)) mt
26081>>>>>>>>>>>>>                    Send adjust_logicals to bobj
26082>>>>>>>>>>>>>                    Move (low(size(bobj))) to bwidth
26083>>>>>>>>>>>>>                    Set Button_width to bwidth
26084>>>>>>>>>>>>>                End
26084>>>>>>>>>>>>>>
26084>>>>>>>>>>>>>            End
26084>>>>>>>>>>>>>>
26084>>>>>>>>>>>>>        Loop
26085>>>>>>>>>>>>>>
26085>>>>>>>>>>>>>    End_Procedure
26086>>>>>>>>>>>>>    
26086>>>>>>>>>>>>>    Procedure Position_Child_Objects
26088>>>>>>>>>>>>>        Integer lsz psz wd pwd ht llc nb mt bobj obj cht col bt list_obj
26088>>>>>>>>>>>>>        Integer rmrgn swd
26088>>>>>>>>>>>>>        
26088>>>>>>>>>>>>>        If (not(pbSizeToClientArea(Self))) Begin
26090>>>>>>>>>>>>>            // if using old sizing, we have not changed anything for 14.0
26090>>>>>>>>>>>>>            If (caption_bar(Self)) ;                Move (Hi(Physical_fontsize(Self))+4+6) to cht
26093>>>>>>>>>>>>>            Else ;                Move 0 to cht
26095>>>>>>>>>>>>>            
26095>>>>>>>>>>>>>            Get GUISize to psz               // size of panel
26096>>>>>>>>>>>>>            Get List_Object to List_obj      // id of the list object
26097>>>>>>>>>>>>>            If list_obj Begin
26099>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26100>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26101>>>>>>>>>>>>>                Move (low(llc)+low(lsz)+2) to rmrgn
26102>>>>>>>>>>>>>            End
26102>>>>>>>>>>>>>>
26102>>>>>>>>>>>>>            Else ;                Move (low(psz)-8) to rmrgn
26104>>>>>>>>>>>>>            
26104>>>>>>>>>>>>>            Get Button_count to nb        // number of buttons
26105>>>>>>>>>>>>>            
26105>>>>>>>>>>>>>            If (nb = 0) ;                Move ( hi(psz) - 4 - cht - 8) to ht
26108>>>>>>>>>>>>>            Else Begin
26109>>>>>>>>>>>>>                Move Button_ids to obj
26110>>>>>>>>>>>>>                Get integer_value of obj 0 to bobj
26111>>>>>>>>>>>>>                Get guisize of bobj to ht
26112>>>>>>>>>>>>>                Move (low(ht)) to wd
26113>>>>>>>>>>>>>                Move ( hi(ht)) to ht
26114>>>>>>>>>>>>>                Move 8 to swd // width of each space
26115>>>>>>>>>>>>>                If ( (rmrgn - ((wd+swd)*nb-swd)) < 0 ) ;                    Move 2 to swd
26118>>>>>>>>>>>>>                Move ( hi(psz) - ht - 4 - cht - 8) to ht
26119>>>>>>>>>>>>>                
26119>>>>>>>>>>>>>                Move (rmrgn-wd) to col
26120>>>>>>>>>>>>>                Decrement nb
26121>>>>>>>>>>>>>                While nb ge 0
26125>>>>>>>>>>>>>                    Get integer_value of obj nb to bobj
26126>>>>>>>>>>>>>                    Set GUIlocation of bobj to ht col
26127>>>>>>>>>>>>>                    Send Adjust_Logicals to bobj
26128>>>>>>>>>>>>>                    Move (col - swd - wd) to col
26129>>>>>>>>>>>>>                    Decrement nb
26130>>>>>>>>>>>>>                End
26131>>>>>>>>>>>>>>
26131>>>>>>>>>>>>>            End
26131>>>>>>>>>>>>>>
26131>>>>>>>>>>>>>            
26131>>>>>>>>>>>>>            If list_obj Begin
26133>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26134>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26135>>>>>>>>>>>>>                Move ( ht - Hi(llc) - 12 ) to ht
26136>>>>>>>>>>>>>                Set GUIsize of list_obj to ht (low(lsz))
26137>>>>>>>>>>>>>                Send Adjust_Logicals to list_obj
26138>>>>>>>>>>>>>            End
26138>>>>>>>>>>>>>>
26138>>>>>>>>>>>>>        End
26138>>>>>>>>>>>>>>
26138>>>>>>>>>>>>>        Else Begin
26139>>>>>>>>>>>>>            
26139>>>>>>>>>>>>>            // this is still obsolete, but we will make it work with client sizing, which makes it simpler actually
26139>>>>>>>>>>>>>            // bote that 8 is used through out as the GUI spacing amount. This is legacy and will not be changed
26139>>>>>>>>>>>>>            
26139>>>>>>>>>>>>>            Get GUISize to psz               // size of panel
26140>>>>>>>>>>>>>            Get List_Object to List_obj      // id of the list object
26141>>>>>>>>>>>>>            If list_obj Begin
26143>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26144>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26145>>>>>>>>>>>>>                Move (low(llc)+low(lsz)) to rmrgn
26146>>>>>>>>>>>>>            End
26146>>>>>>>>>>>>>>
26146>>>>>>>>>>>>>            Else Begin
26147>>>>>>>>>>>>>                Move (low(psz)-8) to rmrgn
26148>>>>>>>>>>>>>            End
26148>>>>>>>>>>>>>>
26148>>>>>>>>>>>>>            
26148>>>>>>>>>>>>>            Get Button_count to nb        // number of buttons
26149>>>>>>>>>>>>>            
26149>>>>>>>>>>>>>            If (nb = 0) ;                Move ( hi(psz) ) to ht
26152>>>>>>>>>>>>>            Else Begin
26153>>>>>>>>>>>>>                Move Button_ids to obj
26154>>>>>>>>>>>>>                Get integer_value of obj 0 to bobj
26155>>>>>>>>>>>>>                Get guisize of bobj to ht
26156>>>>>>>>>>>>>                Move (low(ht)) to wd
26157>>>>>>>>>>>>>                Move ( hi(ht)) to ht
26158>>>>>>>>>>>>>                Move 8 to swd // width of each space
26159>>>>>>>>>>>>>                Move ( hi(psz) - ht - 8) to ht
26160>>>>>>>>>>>>>                
26160>>>>>>>>>>>>>                Move (rmrgn-wd) to col
26161>>>>>>>>>>>>>                Decrement nb
26162>>>>>>>>>>>>>                While (nb>=0)
26166>>>>>>>>>>>>>                    Get integer_value of obj nb to bobj
26167>>>>>>>>>>>>>                    Set GUIlocation of bobj to ht col
26168>>>>>>>>>>>>>                    Send Adjust_Logicals to bobj
26169>>>>>>>>>>>>>                    Move (col - swd - wd) to col
26170>>>>>>>>>>>>>                    Decrement nb
26171>>>>>>>>>>>>>                End
26172>>>>>>>>>>>>>>
26172>>>>>>>>>>>>>            End
26172>>>>>>>>>>>>>>
26172>>>>>>>>>>>>>            
26172>>>>>>>>>>>>>            If list_obj Begin
26174>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26175>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26176>>>>>>>>>>>>>                Move ( ht - Hi(llc) - 8 ) to ht
26177>>>>>>>>>>>>>                Set GUIsize of list_obj to ht (low(lsz))
26178>>>>>>>>>>>>>                Send Adjust_Logicals of list_obj
26179>>>>>>>>>>>>>            End
26179>>>>>>>>>>>>>>
26179>>>>>>>>>>>>>        End
26179>>>>>>>>>>>>>>
26179>>>>>>>>>>>>>    End_Procedure
26180>>>>>>>>>>>>>    
26180>>>>>>>>>>>>>    Procedure End_Construct_Object
26182>>>>>>>>>>>>>        Send Size_Buttons
26183>>>>>>>>>>>>>        Send Position_Child_Objects
26184>>>>>>>>>>>>>        Forward Send end_construct_object
26186>>>>>>>>>>>>>    End_Procedure
26187>>>>>>>>>>>>>    
26187>>>>>>>>>>>>>    Procedure Search
26189>>>>>>>>>>>>>        Integer Obj#
26189>>>>>>>>>>>>>        Get List_Object to obj#
26190>>>>>>>>>>>>>        If Obj# ;            Send Search to Obj#
26193>>>>>>>>>>>>>    End_Procedure
26194>>>>>>>>>>>>>    
26194>>>>>>>>>>>>>    // created for advanced CD_popup_object support. Returns the true handle of the
26194>>>>>>>>>>>>>    // popup object whether it is a regular object or a CD popup object.
26194>>>>>>>>>>>>>    Function Popup_Handle Returns Handle
26196>>>>>>>>>>>>>        Function_Return Self
26197>>>>>>>>>>>>>    End_Function
26198>>>>>>>>>>>>>    
26198>>>>>>>>>>>>>End_Class
26199>>>>>>>>>>>>>
26199>>>>>>>>>>>>>//
26199>>>>>>>>>>>>>// Panel Based Classes
26199>>>>>>>>>>>>>//
26199>>>>>>>>>>>>>//  dbPanel_
26199>>>>>>>>>>>>>//     dbPanel
26199>>>>>>>>>>>>>//        dbViewPanel_
26199>>>>>>>>>>>>>//           dbViewPanel
26199>>>>>>>>>>>>>//
26199>>>>>>>>>>>>>// None of these are likely to be used
26199>>>>>>>>>>>>>//
26199>>>>>>>>>>>>>
26199>>>>>>>>>>>>>Class dbPanel_ is a BasicPanel STARTMAC ECstart
26200>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
26200>>>>>>>>>>>>>    
26200>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
26201>>>>>>>>>>>>>    
26201>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
26201>>>>>>>>>>>>>    //
26201>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
26201>>>>>>>>>>>>>    Procedure Activating //Returns Integer
26203>>>>>>>>>>>>>        Integer RVal
26203>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
26205>>>>>>>>>>>>>        Procedure_Return rVal
26206>>>>>>>>>>>>>    End_Procedure
26207>>>>>>>>>>>>>End_Class
26208>>>>>>>>>>>>>
26208>>>>>>>>>>>>>Class dbPanel is a dbPanel_
26209>>>>>>>>>>>>>    Procedure Construct_Object
26211>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
26213>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
26214>>>>>>>>>>>>>    End_Procedure
26215>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
26216>>>>>>>>>>>>>End_Class
26217>>>>>>>>>>>>>
26217>>>>>>>>>>>>>Class dbViewPanel_ is a dbPanel
26218>>>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
26219>>>>>>>>>>>>>End_Class
26220>>>>>>>>>>>>>
26220>>>>>>>>>>>>>Class dbViewPanel is a dbViewPanel_
26221>>>>>>>>>>>>>    Procedure Construct_Object
26223>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
26225>>>>>>>>>>>>>    End_Procedure
26226>>>>>>>>>>>>>    
26226>>>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
26226>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
26226>>>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
26226>>>>>>>>>>>>>    //
26226>>>>>>>>>>>>>    Function DEO_Object Returns Integer
26228>>>>>>>>>>>>>        Function_Return 1
26229>>>>>>>>>>>>>    End_Function
26230>>>>>>>>>>>>>End_Class
26231>>>>>>>>>>>Use DFbitmap.pkg
Including file: Dfbitmap.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfbitmap.pkg)
26231>>>>>>>>>>>>>Use LanguageText.pkg
26231>>>>>>>>>>>>>Use Windows.pkg
26231>>>>>>>>>>>>>Use File_Dlg.pkg
26231>>>>>>>>>>>>>
26231>>>>>>>>>>>>>Class BitmapContainer is a Container3D
26232>>>>>>>>>>>>>    
26232>>>>>>>>>>>>>    Procedure Construct_Object
26234>>>>>>>>>>>>>        Forward Send Construct_Object
26236>>>>>>>>>>>>>        
26236>>>>>>>>>>>>>        Property Integer Changed_State False
26237>>>>>>>>>>>>>        
26237>>>>>>>>>>>>>        // If true, double click sends Get Select_Bitmap which invokes
26237>>>>>>>>>>>>>        // an open file dialog
26237>>>>>>>>>>>>>        Property Integer Allow_Select_Bitmap_State  False
26238>>>>>>>>>>>>>        
26238>>>>>>>>>>>>>        // title for common file dialog
26238>>>>>>>>>>>>>        Property String Dialog_Caption C_$SelectBitmapFile
26239>>>>>>>>>>>>>        
26239>>>>>>>>>>>>>        // start-up directory for common file dialog
26239>>>>>>>>>>>>>        Property String Initial_Folder ""
26240>>>>>>>>>>>>>        
26240>>>>>>>>>>>>>        Send Define_ToolTip_Support_Mixin
26241>>>>>>>>>>>>>        
26241>>>>>>>>>>>>>        // this object should not take the focus
26241>>>>>>>>>>>>>        Set Focus_Mode to NonFocusable
26242>>>>>>>>>>>>>        Set Client_Area_State to False
26243>>>>>>>>>>>>>        Set pbUseFormWindowHandle to False   // must come after Define_ToolTip_Support_Mixin
26244>>>>>>>>>>>>>    End_Procedure
26245>>>>>>>>>>>>>    
26245>>>>>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
26246>>>>>>>>>>>>>    
26246>>>>>>>>>>>>>    // Although this is not a client it should add child objects to
26246>>>>>>>>>>>>>    // the focus tree. Should only be textboxes!
26246>>>>>>>>>>>>>    //
26246>>>>>>>>>>>>>    Procedure Add_Focus Integer Obj
26248>>>>>>>>>>>>>        Forward Send Add_Focus Obj
26250>>>>>>>>>>>>>        Broadcast Send Add_Focus Self
26252>>>>>>>>>>>>>    End_Procedure
26253>>>>>>>>>>>>>    
26253>>>>>>>>>>>>>    // Popup an open file dialog and select a bitmap file. Returns file
26253>>>>>>>>>>>>>    // name
26253>>>>>>>>>>>>>    //
26253>>>>>>>>>>>>>    Function Select_Bitmap Returns String
26255>>>>>>>>>>>>>        String sFileName
26255>>>>>>>>>>>>>        String sPropVal
26255>>>>>>>>>>>>>        Integer iRet
26255>>>>>>>>>>>>>        Handle hoOpenFile
26255>>>>>>>>>>>>>        
26255>>>>>>>>>>>>>        Get Create U_OpenDialog to  hoOpenFile
26256>>>>>>>>>>>>>        // Mask will look like this: "Bitmaps (.bmp;*.rle)|*.bmp;*.rle|All Files (*.*)|*.*"
26256>>>>>>>>>>>>>        Set Filter_String  of hoOpenFile to (C_$Bitmaps * "(.bmp;*.rle)|*.bmp;*.rle|" + C_$AllFiles * "(*.*)|*.*")
26257>>>>>>>>>>>>>        Get Dialog_Caption to sPropVal
26258>>>>>>>>>>>>>        Set Dialog_Caption of hoOpenFile to sPropVal
26259>>>>>>>>>>>>>        Get Initial_Folder to sPropVal
26260>>>>>>>>>>>>>        Set Initial_Folder of hoOpenFile to sPropVal
26261>>>>>>>>>>>>>        Get Show_Dialog    of hoOpenFile  to iRet
26262>>>>>>>>>>>>>        If iRet ;            Get File_Name of hoOpenFile  to sFileName
26265>>>>>>>>>>>>>        Send Destroy of hoOpenFile
26266>>>>>>>>>>>>>        Function_Return sFileName
26267>>>>>>>>>>>>>    End_Function
26268>>>>>>>>>>>>>    
26268>>>>>>>>>>>>>    Procedure Invoke_Select_Bitmap
26270>>>>>>>>>>>>>        String sFileName
26270>>>>>>>>>>>>>        Get Select_Bitmap to sFileName
26271>>>>>>>>>>>>>        If (sFileName<>"") Begin
26273>>>>>>>>>>>>>            Set Bitmap to sFileName
26274>>>>>>>>>>>>>            Set Changed_State to True
26275>>>>>>>>>>>>>        End
26275>>>>>>>>>>>>>>
26275>>>>>>>>>>>>>    End_Procedure
26276>>>>>>>>>>>>>    
26276>>>>>>>>>>>>>    
26276>>>>>>>>>>>>>    // Augmented to invoke the filedialog to retrieve a new bitmap
26276>>>>>>>>>>>>>    Procedure Mouse_Click Integer i1 Integer i2
26278>>>>>>>>>>>>>        Forward Send Mouse_Click i1 i2
26280>>>>>>>>>>>>>        If (Allow_Select_Bitmap_State(Self)) Begin
26282>>>>>>>>>>>>>            Send Invoke_Select_Bitmap
26283>>>>>>>>>>>>>        End
26283>>>>>>>>>>>>>>
26283>>>>>>>>>>>>>    End_Procedure
26284>>>>>>>>>>>>>    
26284>>>>>>>>>>>>>    Procedure Page_Object Integer iState
26286>>>>>>>>>>>>>        Forward Send Page_Object iState
26288>>>>>>>>>>>>>        
26288>>>>>>>>>>>>>        // Handle tooltip support....
26288>>>>>>>>>>>>>        If (iState = 0) Begin
26290>>>>>>>>>>>>>            Send RequestDeleteToolTip
26291>>>>>>>>>>>>>        End
26291>>>>>>>>>>>>>>
26291>>>>>>>>>>>>>        Else Begin
26292>>>>>>>>>>>>>            Send RequestAddToolTip
26293>>>>>>>>>>>>>        End
26293>>>>>>>>>>>>>>
26293>>>>>>>>>>>>>    End_Procedure
26294>>>>>>>>>>>>>    
26294>>>>>>>>>>>>>    
26294>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
26294>>>>>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
26294>>>>>>>>>>>>>    // is implemented in a mixin class.
26294>>>>>>>>>>>>>    Procedure RequestAddToolTip
26296>>>>>>>>>>>>>        Send AddToolTip
26297>>>>>>>>>>>>>    End_Procedure
26298>>>>>>>>>>>>>    
26298>>>>>>>>>>>>>    
26298>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
26298>>>>>>>>>>>>>    Procedure RequestDeleteToolTip
26300>>>>>>>>>>>>>        Send DeleteToolTip
26301>>>>>>>>>>>>>    End_Procedure
26302>>>>>>>>>>>>>End_Class
26303>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
26303>>>>>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cRichEdit.pkg)
26303>>>>>>>>>>>>>Use Windows.pkg
26303>>>>>>>>>>>>>Use cEdit_Mixin.pkg
Including file: cEdit_mixin.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cEdit_mixin.pkg)
26303>>>>>>>>>>>>>>>// mixin used by both cRichEdit and cTextEdit
26303>>>>>>>>>>>>>>>Use Windows.pkg
26303>>>>>>>>>>>>>>>
26303>>>>>>>>>>>>>>>// for undoType and RedoType
26303>>>>>>>>>>>>>>>Enum_List
26303>>>>>>>>>>>>>>>    Define utUnknown
26303>>>>>>>>>>>>>>>    Define utTyping
26303>>>>>>>>>>>>>>>    Define utDelete
26303>>>>>>>>>>>>>>>    Define utDragDrop
26303>>>>>>>>>>>>>>>    Define utCut
26303>>>>>>>>>>>>>>>    Define utPaste
26303>>>>>>>>>>>>>>>End_Enum_List
26303>>>>>>>>>>>>>>>
26303>>>>>>>>>>>>>>>Class cEdit_Mixin is a Mixin
26304>>>>>>>>>>>>>>>    
26304>>>>>>>>>>>>>>>    Procedure Define_cEdit_Mixin
26306>>>>>>>>>>>>>>>        Send Define_Standard_Object_Mixin
26307>>>>>>>>>>>>>>>        Send Define_Dflabel_Mixin
26308>>>>>>>>>>>>>>>        Send Define_ToolTip_Support_Mixin
26309>>>>>>>>>>>>>>>        
26309>>>>>>>>>>>>>>>        Set Label_Offset to 1 0
26310>>>>>>>>>>>>>>>        Set Label_Justification_Mode to Jmode_Top
26311>>>>>>>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
26312>>>>>>>>>>>>>>>        Set Color     to clWindow      // should be the default...also system colors don't work
26313>>>>>>>>>>>>>>>        Set TextColor to clWindowText  // should be the default
26314>>>>>>>>>>>>>>>        
26314>>>>>>>>>>>>>>>        Property Boolean Changed_State False
26315>>>>>>>>>>>>>>>        
26315>>>>>>>>>>>>>>>        Property Integer pbSuppressChange False
26316>>>>>>>>>>>>>>>        
26316>>>>>>>>>>>>>>>        Property Integer piPriorEnabledColor 0 // private, used by shadow_display
26317>>>>>>>>>>>>>>>        
26317>>>>>>>>>>>>>>>        Send Define_Shadow_Mixin
26318>>>>>>>>>>>>>>>        
26318>>>>>>>>>>>>>>>        Property Integer Floating_Menu_Object Default_Form_Floating_Menu_Id
26319>>>>>>>>>>>>>>>        
26319>>>>>>>>>>>>>>>        On_Key kEnter Send default_key
26320>>>>>>>>>>>>>>>        
26320>>>>>>>>>>>>>>>        Set Disable_default_action_button_state to True
26321>>>>>>>>>>>>>>>        
26321>>>>>>>>>>>>>>>    End_Procedure
26322>>>>>>>>>>>>>>>    
26322>>>>>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
26323>>>>>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
26324>>>>>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
26325>>>>>>>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
26326>>>>>>>>>>>>>>>    
26326>>>>>>>>>>>>>>>    // currently there is no built in context menu support (old edit has one).
26326>>>>>>>>>>>>>>>    Procedure Mouse_Down2 Integer iWindowNumber Integer iPosition
26328>>>>>>>>>>>>>>>        Integer obj rval
26328>>>>>>>>>>>>>>>        Forward Send mouse_down2 iWindowNumber iPosition
26330>>>>>>>>>>>>>>>        Get Floating_Menu_object to obj
26331>>>>>>>>>>>>>>>        If obj Begin
26333>>>>>>>>>>>>>>>            If (Focus(desktop)<>Self) Begin
26335>>>>>>>>>>>>>>>                Get msg_Activate to rval
26336>>>>>>>>>>>>>>>            End
26336>>>>>>>>>>>>>>>>
26336>>>>>>>>>>>>>>>            If (Focus(desktop)=Self) Begin
26338>>>>>>>>>>>>>>>                Send Popup to obj
26339>>>>>>>>>>>>>>>            End
26339>>>>>>>>>>>>>>>>
26339>>>>>>>>>>>>>>>        End
26339>>>>>>>>>>>>>>>>
26339>>>>>>>>>>>>>>>    End_Procedure
26340>>>>>>>>>>>>>>>    
26340>>>>>>>>>>>>>>>    Function Object_Shadow_State Returns Integer
26342>>>>>>>>>>>>>>>        Function_Return (Private.Shadow_State(Self))
26343>>>>>>>>>>>>>>>    End_Function
26344>>>>>>>>>>>>>>>    
26344>>>>>>>>>>>>>>>    // enables or disables an active window. Allows enabled_state to be used after object is paged
26344>>>>>>>>>>>>>>>    Procedure Enable_Window Integer iState
26346>>>>>>>>>>>>>>>        Handle hWnd
26346>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
26347>>>>>>>>>>>>>>>        If hWnd ;            Move (EnableWindow(hWnd,iState)) to hWnd
26350>>>>>>>>>>>>>>>    End_Procedure
26351>>>>>>>>>>>>>>>    
26351>>>>>>>>>>>>>>>    Procedure Set Current_Shadow_State Integer iState
26353>>>>>>>>>>>>>>>        Set Private.Shadow_State to iState     // used by get object_shadow_state/enabled_state
26354>>>>>>>>>>>>>>>        Set Window_Style to WS_DISABLED iState // used to set style before the object is paged
26355>>>>>>>>>>>>>>>        Send Enable_Window (not(iState))       // used to enable/disable after object is paged
26356>>>>>>>>>>>>>>>    End_Procedure
26357>>>>>>>>>>>>>>>    
26357>>>>>>>>>>>>>>>    
26357>>>>>>>>>>>>>>>    Procedure Shadow_Display
26359>>>>>>>>>>>>>>>        // control will take care of shadowing itself
26359>>>>>>>>>>>>>>>        Send Label_Shadow_Display // if object has a label text box, handle disabling this
26360>>>>>>>>>>>>>>>    End_Procedure
26361>>>>>>>>>>>>>>>    
26361>>>>>>>>>>>>>>>    Procedure Set Item_Shadow_State Integer iItem Integer iState
26363>>>>>>>>>>>>>>>    End_Procedure
26364>>>>>>>>>>>>>>>    
26364>>>>>>>>>>>>>>>    Function Item_Shadow_State Integer iItem Returns Integer
26366>>>>>>>>>>>>>>>    End_Function
26367>>>>>>>>>>>>>>>    
26367>>>>>>>>>>>>>>>    Procedure OnChange
26369>>>>>>>>>>>>>>>    End_Procedure
26370>>>>>>>>>>>>>>>    
26370>>>>>>>>>>>>>>>    Procedure OnMaxText
26372>>>>>>>>>>>>>>>    End_Procedure
26373>>>>>>>>>>>>>>>    
26373>>>>>>>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
26375>>>>>>>>>>>>>>>        Integer iParam
26375>>>>>>>>>>>>>>>        Forward Send Command wParam lParam
26377>>>>>>>>>>>>>>>        Move (hi(wParam)) to iParam
26378>>>>>>>>>>>>>>>        If (iParam=EN_CHANGE) Begin
26380>>>>>>>>>>>>>>>            // if we are supressing change notification, do nothing.
26380>>>>>>>>>>>>>>>            If (pbSuppressChange(Self)) ;                Procedure_Return
26383>>>>>>>>>>>>>>>            If not (changed_state(Self)) Begin
26385>>>>>>>>>>>>>>>                Set Changed_state to True
26386>>>>>>>>>>>>>>>            End
26386>>>>>>>>>>>>>>>>
26386>>>>>>>>>>>>>>>            Send OnChange
26387>>>>>>>>>>>>>>>        End
26387>>>>>>>>>>>>>>>>
26387>>>>>>>>>>>>>>>        Else If (iParam=EN_MAXTEXT) Begin
26390>>>>>>>>>>>>>>>            Send OnMaxText
26391>>>>>>>>>>>>>>>        End
26391>>>>>>>>>>>>>>>>
26391>>>>>>>>>>>>>>>    End_Procedure
26392>>>>>>>>>>>>>>>    
26392>>>>>>>>>>>>>>>    // Some messages trigger the command message with a change event. In some circumstances we must suppress this.
26392>>>>>>>>>>>>>>>    // The delete_data message and the page message both do this.
26392>>>>>>>>>>>>>>>    
26392>>>>>>>>>>>>>>>    Procedure Delete_Data
26394>>>>>>>>>>>>>>>        Boolean bWas
26394>>>>>>>>>>>>>>>        Get pbSuppressChange to bWas
26395>>>>>>>>>>>>>>>        Set pbSuppressChange to True // Delete_Data sends command which triggers change. We suppress that here
26396>>>>>>>>>>>>>>>        Forward Send delete_data
26398>>>>>>>>>>>>>>>        Set changed_state to False
26399>>>>>>>>>>>>>>>        Send OnChange
26400>>>>>>>>>>>>>>>        Set pbSuppressChange to bWas
26401>>>>>>>>>>>>>>>    End_Procedure
26402>>>>>>>>>>>>>>>    
26402>>>>>>>>>>>>>>>    Procedure Page Integer iState
26404>>>>>>>>>>>>>>>        Boolean bWas
26404>>>>>>>>>>>>>>>        Get pbSuppressChange to bWas
26405>>>>>>>>>>>>>>>        Set pbSuppressChange to True  // Page sends command which triggers change. We suppress that here
26406>>>>>>>>>>>>>>>        Forward Send Page iState
26408>>>>>>>>>>>>>>>        Set pbSuppressChange to bWas
26409>>>>>>>>>>>>>>>    End_Procedure
26410>>>>>>>>>>>>>>>    
26410>>>>>>>>>>>>>>>    
26410>>>>>>>>>>>>>>>    Procedure AppendTextLn String sText
26412>>>>>>>>>>>>>>>        Send AppendText sText
26413>>>>>>>>>>>>>>>        Send AppendText (character(10))
26414>>>>>>>>>>>>>>>    End_Procedure
26415>>>>>>>>>>>>>>>    
26415>>>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
26415>>>>>>>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
26415>>>>>>>>>>>>>>>    // is implemented in a mixin class.
26415>>>>>>>>>>>>>>>    Procedure RequestAddToolTip
26417>>>>>>>>>>>>>>>        Send AddToolTip
26418>>>>>>>>>>>>>>>    End_Procedure
26419>>>>>>>>>>>>>>>    
26419>>>>>>>>>>>>>>>    
26419>>>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
26419>>>>>>>>>>>>>>>    Procedure RequestDeleteToolTip
26421>>>>>>>>>>>>>>>        Send DeleteToolTip
26422>>>>>>>>>>>>>>>    End_Procedure
26423>>>>>>>>>>>>>>>End_Class
26424>>>>>>>>>>>>>
26424>>>>>>>>>>>>>// constants used for RichEdit Properties
26424>>>>>>>>>>>>>// peAlignment
26424>>>>>>>>>>>>>Enum_List
26424>>>>>>>>>>>>>    Define alLeft   for 1
26424>>>>>>>>>>>>>    Define alRight  for 2
26424>>>>>>>>>>>>>    Define alCenter for 3
26424>>>>>>>>>>>>>End_Enum_List
26424>>>>>>>>>>>>>
26424>>>>>>>>>>>>>// peBullets
26424>>>>>>>>>>>>>Enum_List
26424>>>>>>>>>>>>>    Define buNone
26424>>>>>>>>>>>>>    Define buBullets
26424>>>>>>>>>>>>>    Define buArabicNumbers
26424>>>>>>>>>>>>>    Define buLowerLetters
26424>>>>>>>>>>>>>    Define buUpperLetters
26424>>>>>>>>>>>>>    Define buLowerRomans
26424>>>>>>>>>>>>>    Define buUpperRomans
26424>>>>>>>>>>>>>End_Enum_List
26424>>>>>>>>>>>>>
26424>>>>>>>>>>>>>// peBulletStyle
26424>>>>>>>>>>>>>Enum_List
26424>>>>>>>>>>>>>    Define busRightParen   for 0
26424>>>>>>>>>>>>>    Define busEncloseParen for 256
26424>>>>>>>>>>>>>    Define busPeriod       for 512
26424>>>>>>>>>>>>>    Define busNumberOnly   for 768
26424>>>>>>>>>>>>>    Define busNoDisplay    for 1024
26424>>>>>>>>>>>>>End_Enum_List
26424>>>>>>>>>>>>>
26424>>>>>>>>>>>>>// peLineSpacingType
26424>>>>>>>>>>>>>Enum_List
26424>>>>>>>>>>>>>    Define lstSingle
26424>>>>>>>>>>>>>    Define lstSingleAndOneHalf
26424>>>>>>>>>>>>>    Define lstDouble
26424>>>>>>>>>>>>>End_Enum_List
26424>>>>>>>>>>>>>
26424>>>>>>>>>>>>>Class cRichEdit is a DFBaseRichEdit
26425>>>>>>>>>>>>>    
26425>>>>>>>>>>>>>    Procedure Construct_Object
26427>>>>>>>>>>>>>        Forward Send Construct_Object
26429>>>>>>>>>>>>>        Send Define_cEdit_Mixin
26430>>>>>>>>>>>>>        
26430>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
26431>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
26432>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
26433>>>>>>>>>>>>>        
26433>>>>>>>>>>>>>    End_Procedure
26434>>>>>>>>>>>>>    
26434>>>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
26435>>>>>>>>>>>>>    
26435>>>>>>>>>>>>>    Procedure ToggleBold
26437>>>>>>>>>>>>>        Set pbBold to (not(pbBold(Self)))
26438>>>>>>>>>>>>>    End_Procedure
26439>>>>>>>>>>>>>    
26439>>>>>>>>>>>>>    Procedure ToggleItalics
26441>>>>>>>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
26442>>>>>>>>>>>>>    End_Procedure
26443>>>>>>>>>>>>>    
26443>>>>>>>>>>>>>    Procedure ToggleUnderline
26445>>>>>>>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
26446>>>>>>>>>>>>>    End_Procedure
26447>>>>>>>>>>>>>    
26447>>>>>>>>>>>>>End_Class
26448>>>>>>>>>>>>>
26448>>>>>>>>>>>>>
26448>>>>>>>>>>>Use cTextEdit.pkg
Including file: cTextEdit.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cTextEdit.pkg)
26448>>>>>>>>>>>>>use Windows.pkg
26448>>>>>>>>>>>>>Use cEdit_Mixin.pkg
26448>>>>>>>>>>>>>
26448>>>>>>>>>>>>>Class cTextEdit is a DFBaseTextEdit
26449>>>>>>>>>>>>>    
26449>>>>>>>>>>>>>    Procedure Construct_Object
26451>>>>>>>>>>>>>        Forward Send Construct_Object
26453>>>>>>>>>>>>>        Send Define_cEdit_Mixin
26454>>>>>>>>>>>>>    End_Procedure
26455>>>>>>>>>>>>>    
26455>>>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
26456>>>>>>>>>>>>>    
26456>>>>>>>>>>>>>End_Class
26457>>>>>>>>>>>>>
26457>>>>>>>>>>>>>
26457>>>>>>>>>>>>>
26457>>>>>>>>>>>Use cRichEdit.pkg
26457>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 23.0\Pkg\gFormatNumbers.pkg)
26457>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cFormatter.pkg)
26457>>>>>>>>>>>>>>>Use VDFBase.pkg
26457>>>>>>>>>>>>>>>
26457>>>>>>>>>>>>>>>Class cFormatter is an cObject
26458>>>>>>>>>>>>>>>    
26458>>>>>>>>>>>>>>>    Procedure Construct_object
26460>>>>>>>>>>>>>>>        Integer iCh
26460>>>>>>>>>>>>>>>        Forward Send construct_object
26462>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
26463>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
26464>>>>>>>>>>>>>>>        
26464>>>>>>>>>>>>>>>        Property String  psLeft
26465>>>>>>>>>>>>>>>        Property String  psright
26466>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
26467>>>>>>>>>>>>>>>        Property Integer piPoints
26468>>>>>>>>>>>>>>>        
26468>>>>>>>>>>>>>>>        Property String  psCurPosLeft
26469>>>>>>>>>>>>>>>        Property String  psCurPosright
26470>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
26471>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
26472>>>>>>>>>>>>>>>        
26472>>>>>>>>>>>>>>>        Property String  psCurNegLeft
26473>>>>>>>>>>>>>>>        Property String  psCurNegright
26474>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
26475>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
26476>>>>>>>>>>>>>>>        
26476>>>>>>>>>>>>>>>        Property String  psNumPosLeft
26477>>>>>>>>>>>>>>>        Property String  psNumPosright
26478>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
26479>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
26480>>>>>>>>>>>>>>>        
26480>>>>>>>>>>>>>>>        Property String  psNumNegLeft
26481>>>>>>>>>>>>>>>        Property String  psNumNegright
26482>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
26483>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
26484>>>>>>>>>>>>>>>        
26484>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
26485>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
26486>>>>>>>>>>>>>>>        
26486>>>>>>>>>>>>>>>    End_Procedure
26487>>>>>>>>>>>>>>>    
26487>>>>>>>>>>>>>>>    // internal
26487>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
26487>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
26489>>>>>>>>>>>>>>>        
26489>>>>>>>>>>>>>>>        String sLeft sRight sDigit
26489>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
26489>>>>>>>>>>>>>>>        
26489>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
26489>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
26489>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
26490>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
26491>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
26492>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
26493>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
26494>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
26495>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
26496>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
26497>>>>>>>>>>>>>>>        
26497>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
26498>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
26501>>>>>>>>>>>>>>>        
26501>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
26502>>>>>>>>>>>>>>>        
26502>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
26503>>>>>>>>>>>>>>>        
26503>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
26503>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
26504>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
26505>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
26506>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
26507>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
26508>>>>>>>>>>>>>>>        
26508>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
26510>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
26511>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
26513>>>>>>>>>>>>>>>                Move -2 to iDigits
26514>>>>>>>>>>>>>>>                Increment i
26515>>>>>>>>>>>>>>>            End
26515>>>>>>>>>>>>>>>>
26515>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
26519>>>>>>>>>>>>>>>                Increment i
26520>>>>>>>>>>>>>>>            Loop
26521>>>>>>>>>>>>>>>>
26521>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
26522>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
26525>>>>>>>>>>>>>>>            //
26525>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
26526>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
26530>>>>>>>>>>>>>>>                Increment i
26531>>>>>>>>>>>>>>>            Loop
26532>>>>>>>>>>>>>>>>
26532>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
26533>>>>>>>>>>>>>>>        End
26533>>>>>>>>>>>>>>>>
26533>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
26534>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
26535>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
26536>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
26538>>>>>>>>>>>>>>>                Move sFmt to sLeft
26539>>>>>>>>>>>>>>>                Move ""   to sRight
26540>>>>>>>>>>>>>>>            End
26540>>>>>>>>>>>>>>>>
26540>>>>>>>>>>>>>>>            Else Begin
26541>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
26542>>>>>>>>>>>>>>>                Move 1 to i
26543>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
26547>>>>>>>>>>>>>>>                    Increment i
26548>>>>>>>>>>>>>>>                Loop
26549>>>>>>>>>>>>>>>>
26549>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
26550>>>>>>>>>>>>>>>            End
26550>>>>>>>>>>>>>>>>
26550>>>>>>>>>>>>>>>        End
26550>>>>>>>>>>>>>>>>
26550>>>>>>>>>>>>>>>        // set temporary format properties and exit
26550>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
26551>>>>>>>>>>>>>>>        Set psLeft         to sLeft
26552>>>>>>>>>>>>>>>        Set psRight        to sRight
26553>>>>>>>>>>>>>>>        Set piPoints       to iDigits
26554>>>>>>>>>>>>>>>    End_Procedure
26555>>>>>>>>>>>>>>>    
26555>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
26555>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
26555>>>>>>>>>>>>>>>    //
26555>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
26555>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
26557>>>>>>>>>>>>>>>        String sPos sNeg
26557>>>>>>>>>>>>>>>        Integer iPos
26557>>>>>>>>>>>>>>>        
26557>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
26558>>>>>>>>>>>>>>>        If iPos Begin
26560>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
26561>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
26562>>>>>>>>>>>>>>>        End
26562>>>>>>>>>>>>>>>>
26562>>>>>>>>>>>>>>>        Else Begin
26563>>>>>>>>>>>>>>>            Move sFmt         to sPos
26564>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
26565>>>>>>>>>>>>>>>        End
26565>>>>>>>>>>>>>>>>
26565>>>>>>>>>>>>>>>        Send ParseFormat sPos
26566>>>>>>>>>>>>>>>        If bCurrency Begin
26568>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
26569>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
26570>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
26571>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
26572>>>>>>>>>>>>>>>        End
26572>>>>>>>>>>>>>>>>
26572>>>>>>>>>>>>>>>        Else Begin
26573>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
26574>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
26575>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
26576>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
26577>>>>>>>>>>>>>>>        End
26577>>>>>>>>>>>>>>>>
26577>>>>>>>>>>>>>>>        
26577>>>>>>>>>>>>>>>        Send ParseFormat sNeg
26578>>>>>>>>>>>>>>>        If bCurrency Begin
26580>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
26581>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
26582>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
26583>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
26584>>>>>>>>>>>>>>>        End
26584>>>>>>>>>>>>>>>>
26584>>>>>>>>>>>>>>>        Else Begin
26585>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
26586>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
26587>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
26588>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
26589>>>>>>>>>>>>>>>        End
26589>>>>>>>>>>>>>>>>
26589>>>>>>>>>>>>>>>    End_Procedure
26590>>>>>>>>>>>>>>>    
26590>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
26590>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
26592>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
26592>>>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
26592>>>>>>>>>>>>>>>        
26592>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
26595>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
26596>>>>>>>>>>>>>>>        
26596>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
26597>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
26598>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
26599>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
26600>>>>>>>>>>>>>>>        // format for decimal separator
26600>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
26603>>>>>>>>>>>>>>>        
26603>>>>>>>>>>>>>>>        // format for thousand sep.
26603>>>>>>>>>>>>>>>        If bSep Begin
26605>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
26608>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
26609>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
26610>>>>>>>>>>>>>>>            While (iLen>3)
26614>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
26615>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
26616>>>>>>>>>>>>>>>            Loop
26617>>>>>>>>>>>>>>>>
26617>>>>>>>>>>>>>>>        End
26617>>>>>>>>>>>>>>>>
26617>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
26617>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
26620>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
26621>>>>>>>>>>>>>>>    End_Function
26622>>>>>>>>>>>>>>>    
26622>>>>>>>>>>>>>>>    // Public: Format for currency
26622>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
26624>>>>>>>>>>>>>>>        String  sLeft sRight
26624>>>>>>>>>>>>>>>        Integer bSep
26624>>>>>>>>>>>>>>>        If (nNumber<0) Begin
26626>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
26627>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
26628>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
26629>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
26632>>>>>>>>>>>>>>>        End
26632>>>>>>>>>>>>>>>>
26632>>>>>>>>>>>>>>>        Else Begin
26633>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
26634>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
26635>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
26636>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
26639>>>>>>>>>>>>>>>        End
26639>>>>>>>>>>>>>>>>
26639>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26640>>>>>>>>>>>>>>>    End_Function
26641>>>>>>>>>>>>>>>    
26641>>>>>>>>>>>>>>>    // Public: Format for numeric
26641>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
26643>>>>>>>>>>>>>>>        String  sLeft sRight
26643>>>>>>>>>>>>>>>        Integer bSep
26643>>>>>>>>>>>>>>>        If (nNumber<0) Begin
26645>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
26646>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
26647>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
26648>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
26651>>>>>>>>>>>>>>>        End
26651>>>>>>>>>>>>>>>>
26651>>>>>>>>>>>>>>>        Else Begin
26652>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
26653>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
26654>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
26655>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
26658>>>>>>>>>>>>>>>        End
26658>>>>>>>>>>>>>>>>
26658>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26659>>>>>>>>>>>>>>>    End_Function
26660>>>>>>>>>>>>>>>    
26660>>>>>>>>>>>>>>>    
26660>>>>>>>>>>>>>>>    // Public: Format passing format string
26660>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
26662>>>>>>>>>>>>>>>        Integer iPos bIsNeg
26662>>>>>>>>>>>>>>>        String  sLeft sRight
26662>>>>>>>>>>>>>>>        Integer iPoints bSep
26662>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
26663>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
26664>>>>>>>>>>>>>>>        Case Begin
26664>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
26667>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
26671>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
26675>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
26677>>>>>>>>>>>>>>>        Case End
26677>>>>>>>>>>>>>>>        Send ParseFormat sFmt
26678>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
26679>>>>>>>>>>>>>>>        Get psLeft         to sLeft
26680>>>>>>>>>>>>>>>        Get psRight        to sRight
26681>>>>>>>>>>>>>>>        Get piPoints       to iPoints
26682>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26683>>>>>>>>>>>>>>>    End_Function
26684>>>>>>>>>>>>>>>    
26684>>>>>>>>>>>>>>>End_Class
26685>>>>>>>>>>>>>
26685>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
26685>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
26686>>>>>>>>>>>>>
26686>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
26688>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
26689>>>>>>>>>>>>>End_Function
26690>>>>>>>>>>>>>
26690>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
26692>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
26693>>>>>>>>>>>>>End_Function
26694>>>>>>>>>>>>>
26694>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
26696>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
26697>>>>>>>>>>>>>End_Function
26698>>>>>>>>>>>>>
26698>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
26700>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
26701>>>>>>>>>>>>>End_Procedure
26702>>>>>>>>>>>>>
26702>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
26704>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
26705>>>>>>>>>>>>>End_Procedure
26706>>>>>>>>>>>>>
26706>>>>>>>>>>>>>
26706>>>>>>>>>>>Use tWinStructs.pkg
26706>>>>>>>>>>>
26706>>>>>>>>>>>Use cli.pkg
26706>>>>>>>>>>>Use DFBTRDRV.PKG
26706>>>>>>>>>>>Use MSSqldrv.pkg
26706>>>>>>>>>>>Use db2_drv.pkg
26706>>>>>>>>>>>Use odbc_drv.pkg
26706>>>>>>>>>>>Use seq_chnl.pkg
26706>>>>>>>>>>>
26706>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
26706>>>>>>>>>>>Register_Function Help_filename Returns String
26706>>>>>>>>>>>Register_Function GetHelpFile Returns String
26706>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
26706>>>>>>>>>>>
26706>>>>>>>>>>>// Use of Mertech drivers:
26706>>>>>>>>>>>// Ad the line "Define Is$MertechDrivers" prior "Use" of this package to your source code if using Mertech drivers!
26706>>>>>>>>>>>//#IFDEF Is$MertechDrivers
26706>>>>>>>>>>>//    #REM Using Mertech.inc
26706>>>>>>>>>>>//    Use mertech.inc
26706>>>>>>>>>>>//#ENDIF
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>// *** Constant Declarations: ***
26706>>>>>>>>>>>//
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>// System icon menu constants. If the upper left hand
26706>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
26706>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
26706>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
26706>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
26706>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
26706>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
26706>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
26706>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
26706>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
26706>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
26706>>>>>>>>>>>
26706>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
26706>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
26706>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
26706>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
26706>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
26706>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
26706>>>>>>>>>>>
26706>>>>>>>>>>>// *** Struct Declarations: ***
26706>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
26706>>>>>>>>>>>    DWord   cbSize
26706>>>>>>>>>>>    Integer fMask
26706>>>>>>>>>>>    Handle  hwnd
26706>>>>>>>>>>>    Pointer lpVerb
26706>>>>>>>>>>>    Pointer lpFile
26706>>>>>>>>>>>    Pointer lpParameters
26706>>>>>>>>>>>    Pointer lpDirectory
26706>>>>>>>>>>>    Integer nShow
26706>>>>>>>>>>>    Integer iMissingAlignment1
26706>>>>>>>>>>>    Pointer hInstApp
26706>>>>>>>>>>>    Pointer lpIDList
26706>>>>>>>>>>>    Pointer lpClass
26706>>>>>>>>>>>    Handle  hkeyClass
26706>>>>>>>>>>>    DWord   dwHotKey
26706>>>>>>>>>>>    Integer iMissingAlignment2
26706>>>>>>>>>>>    Handle  hIconMonitor // Union
26706>>>>>>>>>>>    //Handle  hMonitor     // Union
26706>>>>>>>>>>>    Handle  hProcess
26706>>>>>>>>>>>End_Struct
26706>>>>>>>>>>>
26706>>>>>>>>>>>
26706>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
26706>>>>>>>>>>>//Type MEMORYSTATUS
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
26706>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
26706>>>>>>>>>>>//End_Type
26706>>>>>>>>>>>
26706>>>>>>>>>>>// *** External Function calls: ***
26706>>>>>>>>>>>//
26706>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
26707>>>>>>>>>>>
26707>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
26708>>>>>>>>>>>
26708>>>>>>>>>>>// Do not call directly, use the wrapper function instead
26708>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
26709>>>>>>>>>>>
26709>>>>>>>>>>>    // Wrapper Function WNetGetUser
26709>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
26711>>>>>>>>>>>
26711>>>>>>>>>>>        DWord   dwResult
26711>>>>>>>>>>>        UWide   uwName uwUserName
26711>>>>>>>>>>>        UWide   uwName uwUserName
26711>>>>>>>>>>>
26711>>>>>>>>>>>        Send StringToWide lpName (&uwName)
26712>>>>>>>>>>>
26712>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
26713>>>>>>>>>>>
26713>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
26714>>>>>>>>>>>
26714>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
26715>>>>>>>>>>>
26715>>>>>>>>>>>        Function_Return dwResult
26716>>>>>>>>>>>    End_Function
26717>>>>>>>>>>>
26717>>>>>>>>>>>
26717>>>>>>>>>>>
26717>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
26718>>>>>>>>>>>
26718>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
26719>>>>>>>>>>>
26719>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
26720>>>>>>>>>>>
26720>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
26721>>>>>>>>>>>
26721>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
26722>>>>>>>>>>>
26722>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
26722>>>>>>>>>>>
26722>>>>>>>>>>>Function ComputerName Desktop Returns String
26724>>>>>>>>>>>    String sName
26724>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
26725>>>>>>>>>>>>
26725>>>>>>>>>>>    Function_Return sName
26726>>>>>>>>>>>End_Function
26727>>>>>>>>>>>
26727>>>>>>>>>>>Function Network_User_Name Desktop Returns String
26729>>>>>>>>>>>    WString wName
26729>>>>>>>>>>>    Integer iRetval iLength
26729>>>>>>>>>>>
26729>>>>>>>>>>>    Move 0 to iLength
26730>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
26731>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
26732>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
26733>>>>>>>>>>>
26733>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
26735>>>>>>>>>>>        Function_Return (CString (wName))
26736>>>>>>>>>>>    End
26736>>>>>>>>>>>>
26736>>>>>>>>>>>
26736>>>>>>>>>>>    Function_Return "User Unknown"
26737>>>>>>>>>>>End_Function
26738>>>>>>>>>>>
26738>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
26740>>>>>>>>>>>    String sClient sDriver sClientDriver
26740>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
26740>>>>>>>>>>>    Handle hoMsqlDrv
26740>>>>>>>>>>>
26740>>>>>>>>>>>    Move 0 to iDriver
26741>>>>>>>>>>>    Move "" to sClient
26742>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
26745>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
26751>>>>>>>>>>>>
26751>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
26754>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
26756>>>>>>>>>>>            Move iCount to iDriver
26757>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
26758>>>>>>>>>>>        End
26758>>>>>>>>>>>>
26758>>>>>>>>>>>    Loop
26759>>>>>>>>>>>>
26759>>>>>>>>>>>
26759>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
26759>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
26761>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
26764>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
26765>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
26766>>>>>>>>>>>        Send Destroy of hoMsqlDrv
26767>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
26768>>>>>>>>>>>    End
26768>>>>>>>>>>>>
26768>>>>>>>>>>>
26768>>>>>>>>>>>    Function_Return sClient
26769>>>>>>>>>>>End_Function
26770>>>>>>>>>>>
26770>>>>>>>>>>>// *** Class Declarations: ***
26770>>>>>>>>>>>//
26770>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
26771>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
26773>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
26774>>>>>>>>>>>    End_Procedure
26775>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
26777>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
26779>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
26780>>>>>>>>>>>    End_Procedure
26781>>>>>>>>>>>End_Class
26782>>>>>>>>>>>
26782>>>>>>>>>>>Class cCopyEditorContentButton is a Button
26783>>>>>>>>>>>    Procedure Construct_Object
26785>>>>>>>>>>>        Forward Send Construct_Object
26787>>>>>>>>>>>        Property Handle phoEditorHandle
26788>>>>>>>>>>>        Set psToolTip to C_$DescCopy
26789>>>>>>>>>>>    End_Procedure
26790>>>>>>>>>>>
26790>>>>>>>>>>>    Procedure CopyToWindowsClipboard
26792>>>>>>>>>>>        Handle hoEditor
26792>>>>>>>>>>>        Boolean bCanCopy
26792>>>>>>>>>>>        Address aEditorAddress
26792>>>>>>>>>>>
26792>>>>>>>>>>>        Get phoEditorHandle to hoEditor
26793>>>>>>>>>>>        Send Select_All of hoEditor
26794>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
26795>>>>>>>>>>>        If (bCanCopy = True) Begin
26797>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
26798>>>>>>>>>>>            Send Copy   of hoEditor
26799>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
26799>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
26800>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
26801>>>>>>>>>>>        End
26801>>>>>>>>>>>>
26801>>>>>>>>>>>    End_Procedure
26802>>>>>>>>>>>End_Class
26803>>>>>>>>>>>
26803>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
26804>>>>>>>>>>>    Procedure Construct_Object
26806>>>>>>>>>>>        Forward Send Construct_Object
26808>>>>>>>>>>>
26808>>>>>>>>>>>        Set Size to 100 245
26809>>>>>>>>>>>        Set Location to 6 6
26810>>>>>>>>>>>        Set Border_Style to Border_None
26811>>>>>>>>>>>        Set Read_Only_State to True
26812>>>>>>>>>>>        Set pbWrap to True
26813>>>>>>>>>>>        Set peAnchors to anAll
26814>>>>>>>>>>>    End_Procedure
26815>>>>>>>>>>>
26815>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
26815>>>>>>>>>>>
26815>>>>>>>>>>>    Procedure AppendTextLn String sText
26817>>>>>>>>>>>        String sWorkspaceWSFile
26817>>>>>>>>>>>
26817>>>>>>>>>>>        // Only works for English:
26817>>>>>>>>>>>        If (ghoApplication > 0) Begin
26819>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
26821>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
26822>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
26823>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
26824>>>>>>>>>>>            End
26824>>>>>>>>>>>>
26824>>>>>>>>>>>        End
26824>>>>>>>>>>>>
26824>>>>>>>>>>>        Send AppendText sText
26825>>>>>>>>>>>        Send AppendText (character(10))
26826>>>>>>>>>>>    End_Procedure
26827>>>>>>>>>>>
26827>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
26827>>>>>>>>>>>    //    information box
26827>>>>>>>>>>>    Procedure Show_Current_Directory
26829>>>>>>>>>>>        String sDir
26829>>>>>>>>>>>
26829>>>>>>>>>>>        Get_Current_Directory To sDir
26830>>>>>>>>>>>
26830>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
26831>>>>>>>>>>>    End_Procedure
26832>>>>>>>>>>>
26832>>>>>>>>>>>    Procedure Show_Windows_Directory
26834>>>>>>>>>>>        String sWindir
26834>>>>>>>>>>>
26834>>>>>>>>>>>        Get_Windows_Directory To sWindir
26835>>>>>>>>>>>
26835>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
26836>>>>>>>>>>>    End_Procedure
26837>>>>>>>>>>>
26837>>>>>>>>>>>    Procedure Show_Current_User
26839>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
26840>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
26841>>>>>>>>>>>    End_Procedure
26842>>>>>>>>>>>
26842>>>>>>>>>>>    Procedure Show_Number_Format
26844>>>>>>>>>>>        Integer iFormat
26844>>>>>>>>>>>        String sFormatText
26844>>>>>>>>>>>
26844>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
26847>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
26848>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
26849>>>>>>>>>>>
26849>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
26852>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
26853>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
26854>>>>>>>>>>>    End_Procedure
26855>>>>>>>>>>>
26855>>>>>>>>>>>    Procedure Show_Filelist_Name
26857>>>>>>>>>>>        String sFilename
26857>>>>>>>>>>>
26857>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
26860>>>>>>>>>>>
26860>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
26861>>>>>>>>>>>    End_Procedure
26862>>>>>>>>>>>
26862>>>>>>>>>>>    Procedure Show_Lock_Delay
26864>>>>>>>>>>>        Integer iLockdelay
26864>>>>>>>>>>>
26864>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
26867>>>>>>>>>>>
26867>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
26868>>>>>>>>>>>    End_Procedure
26869>>>>>>>>>>>
26869>>>>>>>>>>>    Procedure Show_Lock_Timeout
26871>>>>>>>>>>>        Integer iLockTimeout
26871>>>>>>>>>>>
26871>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
26874>>>>>>>>>>>
26874>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
26875>>>>>>>>>>>    End_Procedure
26876>>>>>>>>>>>
26876>>>>>>>>>>>    Procedure Show_Screen_Size
26878>>>>>>>>>>>        Integer iYscreensize iXscreensize
26878>>>>>>>>>>>
26878>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
26879>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
26880>>>>>>>>>>>
26880>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
26881>>>>>>>>>>>    End_Procedure
26882>>>>>>>>>>>
26882>>>>>>>>>>>    Procedure Show_Page_Size
26884>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
26885>>>>>>>>>>>    End_procedure
26886>>>>>>>>>>>
26886>>>>>>>>>>>    Procedure Show_Date
26888>>>>>>>>>>>        Date dToday
26888>>>>>>>>>>>
26888>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
26889>>>>>>>>>>>
26889>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
26890>>>>>>>>>>>    End_procedure
26891>>>>>>>>>>>
26891>>>>>>>>>>>    Procedure Show_Date_Format
26893>>>>>>>>>>>        Integer iDateFormat
26893>>>>>>>>>>>        String sDateFormat
26893>>>>>>>>>>>
26893>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
26896>>>>>>>>>>>        Case Begin
26896>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
26898>>>>>>>>>>>                Move C_$USA To sDateFormat
26899>>>>>>>>>>>                Case Break
26900>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
26903>>>>>>>>>>>                Move C_$European To sDateFormat
26904>>>>>>>>>>>                Case Break
26905>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
26908>>>>>>>>>>>                Move C_$Military To sDateFormat
26909>>>>>>>>>>>                Case Break
26910>>>>>>>>>>>            Case Else
26910>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
26911>>>>>>>>>>>                Case Break
26912>>>>>>>>>>>        Case End
26912>>>>>>>>>>>
26912>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
26913>>>>>>>>>>>    End_Procedure
26914>>>>>>>>>>>
26914>>>>>>>>>>>    // 2013-08-14 NGS
26914>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
26914>>>>>>>>>>>    Procedure Show_Systemresources
26916>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
26916>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
26916>>>>>>>>>>>        Integer iRetval
26916>>>>>>>>>>>        Number nValue
26916>>>>>>>>>>>        String sValue
26916>>>>>>>>>>>
26916>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
26917>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
26918>>>>>>>>>>>        If (iRetval = 0) Begin
26920>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
26921>>>>>>>>>>>            Procedure_Return
26922>>>>>>>>>>>        End
26922>>>>>>>>>>>>
26922>>>>>>>>>>>
26922>>>>>>>>>>>        Send AppendTextLn ""
26923>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
26924>>>>>>>>>>>
26924>>>>>>>>>>>        // Show memory in Gigabytes:
26924>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
26925>>>>>>>>>>>        Move (Round(nValue)) to nValue
26926>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
26927>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
26928>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
26929>>>>>>>>>>>
26929>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
26929>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
26930>>>>>>>>>>>        Move (Round(nValue)) to nValue
26931>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26932>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
26933>>>>>>>>>>>
26933>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
26933>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
26934>>>>>>>>>>>        Move (Round(nValue)) to nValue
26935>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26936>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
26937>>>>>>>>>>>
26937>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
26937>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
26938>>>>>>>>>>>        Move (Round(nValue)) to nValue
26939>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26940>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
26941>>>>>>>>>>>
26941>>>>>>>>>>>        // Add an empty row after the memory information:
26941>>>>>>>>>>>        Send AppendTextLn ""
26942>>>>>>>>>>>    End_Procedure
26943>>>>>>>>>>>
26943>>>>>>>>>>>    Procedure Show_Registration
26945>>>>>>>>>>>        String sRegName
26945>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
26945>>>>>>>>>>>
26945>>>>>>>>>>>        Registration sRegName iSN
26946>>>>>>>>>>>>
26946>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
26947>>>>>>>>>>>        Get_Current_User_Count to iUserCount
26948>>>>>>>>>>>
26948>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
26949>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
26950>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
26951>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
26952>>>>>>>>>>>    End_Procedure
26953>>>>>>>>>>>
26953>>>>>>>>>>>    //****************************************************************************
26953>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
26953>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
26953>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
26953>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
26953>>>>>>>>>>>    // information To be displayed
26953>>>>>>>>>>>    //****************************************************************************
26953>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
26953>>>>>>>>>>>
26953>>>>>>>>>>>    Procedure Show_ServicePack
26955>>>>>>>>>>>        String sKey sVersion sDataFlex
26955>>>>>>>>>>>        Handle hoRegistry
26955>>>>>>>>>>>        Boolean bExists bOpened
26955>>>>>>>>>>>
26955>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
26956>>>>>>>>>>>
26956>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
26957>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
26958>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
26959>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
26960>>>>>>>>>>>
26960>>>>>>>>>>>        If (bExists) Begin
26962>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
26963>>>>>>>>>>>        End
26963>>>>>>>>>>>>
26963>>>>>>>>>>>        Else Begin
26964>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
26965>>>>>>>>>>>        End
26965>>>>>>>>>>>>
26965>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
26966>>>>>>>>>>>        If (bExists) Begin
26968>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
26969>>>>>>>>>>>            If (bOpened) Begin
26971>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
26972>>>>>>>>>>>                If (bExists) Begin
26974>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
26975>>>>>>>>>>>                End
26975>>>>>>>>>>>>
26975>>>>>>>>>>>                Send CloseKey of hoRegistry
26976>>>>>>>>>>>            End
26976>>>>>>>>>>>>
26976>>>>>>>>>>>        End
26976>>>>>>>>>>>>
26976>>>>>>>>>>>        Send Destroy of hoRegistry
26977>>>>>>>>>>>
26977>>>>>>>>>>>        If (sVersion <> "") Begin
26979>>>>>>>>>>>           Send AppendTextLn sVersion
26980>>>>>>>>>>>           Send AppendTextLn ""
26981>>>>>>>>>>>        End
26981>>>>>>>>>>>>
26981>>>>>>>>>>>    End_Procedure
26982>>>>>>>>>>>
26982>>>>>>>>>>>    Procedure Show_WorkspaceInformation
26984>>>>>>>>>>>        Integer hoWorkspace
26984>>>>>>>>>>>
26984>>>>>>>>>>>        If (ghoApplication <> 0) Begin
26986>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
26987>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
26989>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
26990>>>>>>>>>>>            End
26990>>>>>>>>>>>>
26990>>>>>>>>>>>        End
26990>>>>>>>>>>>>
26990>>>>>>>>>>>    End_Procedure
26991>>>>>>>>>>>
26991>>>>>>>>>>>    //****************************************************************************
26991>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
26991>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
26991>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
26991>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
26991>>>>>>>>>>>    // the information To be displayed
26991>>>>>>>>>>>    //****************************************************************************
26991>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
26991>>>>>>>>>>>
26991>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
26993>>>>>>>>>>>        If (ghoConnection > 0) Begin
26995>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
26996>>>>>>>>>>>            Send AppendTextLn ""
26997>>>>>>>>>>>        End
26997>>>>>>>>>>>>
26997>>>>>>>>>>>    End_Procedure
26998>>>>>>>>>>>
26998>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
27000>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
27001>>>>>>>>>>>    End_Function
27002>>>>>>>>>>>
27002>>>>>>>>>>>    Procedure Show_Versions
27004>>>>>>>>>>>        Integer iVersion iRevision iBuild
27004>>>>>>>>>>>
27004>>>>>>>>>>>        Version_information iVersion iRevision iBuild
27006>>>>>>>>>>>
27006>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
27007>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
27008>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
27009>>>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
27010>>>>>>>>>>>    End_Procedure
27011>>>>>>>>>>>
27011>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
27013>>>>>>>>>>>        Boolean bOK
27013>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
27014>>>>>>>>>>>        Function_Return bOK
27015>>>>>>>>>>>    End_Function
27016>>>>>>>>>>>
27016>>>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
27018>>>>>>>>>>>        Boolean bOK
27018>>>>>>>>>>>        Function_Return bOK
27019>>>>>>>>>>>    End_Function
27020>>>>>>>>>>>
27020>>>>>>>>>>>    //***
27020>>>>>>>>>>>    //*** BW
27020>>>>>>>>>>>    //*** Procedure: Show_Drivers
27020>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
27020>>>>>>>>>>>    //***
27020>>>>>>>>>>>
27020>>>>>>>>>>>    Procedure Show_Drivers
27022>>>>>>>>>>>        String sDriverID sVersion sClient sValue
27022>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
27022>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
27022>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
27022>>>>>>>>>>>
27022>>>>>>>>>>>        Move False to bStudioLicense
27023>>>>>>>>>>>
27023>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
27024>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
27025>>>>>>>>>>>
27025>>>>>>>>>>>        // For testing purposes:
27025>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
27025>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
27025>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
27025>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
27025>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
27025>>>>>>>>>>>//
27025>>>>>>>>>>>//        #IFDEF Is$MertechDrivers
27025>>>>>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
27025>>>>>>>>>>>//            Load_Driver SQLFLEX
27025>>>>>>>>>>>//            Load_Driver MDSPgSQL
27025>>>>>>>>>>>//            Load_Driver MDSMySQL
27025>>>>>>>>>>>//            Load_Driver ORAFLEX
27025>>>>>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
27025>>>>>>>>>>>//        #ENDIF
27025>>>>>>>>>>>        Move False to Err
27026>>>>>>>>>>>
27026>>>>>>>>>>>        // Loop through all loaded drivers.
27026>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
27029>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
27031>>>>>>>>>>>            Send AppendTextLn ""
27032>>>>>>>>>>>        End
27032>>>>>>>>>>>>
27032>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
27038>>>>>>>>>>>>
27038>>>>>>>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
27038>>>>>>>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
27038>>>>>>>>>>>            // would be thrown, so we safeguard from that here.
27038>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
27039>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
27042>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
27043>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
27044>>>>>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
27045>>>>>>>>>>>
27045>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
27047>>>>>>>>>>>
27047>>>>>>>>>>>                // Pervasive/Btrieve database
27047>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
27049>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
27050>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
27051>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
27053>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
27054>>>>>>>>>>>                    End
27054>>>>>>>>>>>>
27054>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
27055>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
27057>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
27058>>>>>>>>>>>                    End
27058>>>>>>>>>>>>
27058>>>>>>>>>>>                End
27058>>>>>>>>>>>>
27058>>>>>>>>>>>
27058>>>>>>>>>>>                Else Begin
27059>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
27060>>>>>>>>>>>                    Move 0 to iNumServers
27061>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
27063>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
27066>>>>>>>>>>>                    End
27066>>>>>>>>>>>>
27066>>>>>>>>>>>
27066>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
27068>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
27070>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
27071>>>>>>>>>>>                        End
27071>>>>>>>>>>>>
27071>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
27072>>>>>>>>>>>                    End
27072>>>>>>>>>>>>
27072>>>>>>>>>>>
27072>>>>>>>>>>>                    If (bIsMertechDriver = True) Begin
27074>>>>>>>>>>>                    End
27074>>>>>>>>>>>>
27074>>>>>>>>>>>
27074>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
27074>>>>>>>>>>>                    // Studio licens is in use and there is no
27074>>>>>>>>>>>                    // number of max users defined because the driver is
27074>>>>>>>>>>>                    // relying on the info from the VDF license.
27074>>>>>>>>>>>                    If (bStudioLicense = False) Begin
27076>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
27077>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
27078>>>>>>>>>>>                    End
27078>>>>>>>>>>>>
27078>>>>>>>>>>>                End
27078>>>>>>>>>>>>
27078>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
27079>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
27081>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
27082>>>>>>>>>>>                End
27082>>>>>>>>>>>>
27082>>>>>>>>>>>                If (iNumServers <> 0) Begin
27084>>>>>>>>>>>                    For iCount from 1 to iNumServers
27090>>>>>>>>>>>>
27090>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
27093>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
27095>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
27096>>>>>>>>>>>                        End
27096>>>>>>>>>>>>
27096>>>>>>>>>>>                    Loop
27097>>>>>>>>>>>>
27097>>>>>>>>>>>                End
27097>>>>>>>>>>>>
27097>>>>>>>>>>>            End
27097>>>>>>>>>>>>
27097>>>>>>>>>>>        Loop
27098>>>>>>>>>>>>
27098>>>>>>>>>>>
27098>>>>>>>>>>>        Send AppendTextLn ""
27099>>>>>>>>>>>        If (bStudioLicense = False) Begin
27101>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
27102>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
27103>>>>>>>>>>>        End
27103>>>>>>>>>>>>
27103>>>>>>>>>>>        Else Begin
27104>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
27105>>>>>>>>>>>        End
27105>>>>>>>>>>>>
27105>>>>>>>>>>>        Send Destroy of hoCLIHandler
27106>>>>>>>>>>>        Send Destroy of hoBtrvHandler
27107>>>>>>>>>>>    End_Procedure
27108>>>>>>>>>>>
27108>>>>>>>>>>>    Procedure Show_HelpFile
27110>>>>>>>>>>>        String sHelpFile
27110>>>>>>>>>>>        Integer eHelpType
27110>>>>>>>>>>>
27110>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27112>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
27113>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
27115>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
27116>>>>>>>>>>>            End
27116>>>>>>>>>>>>
27116>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
27119>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
27120>>>>>>>>>>>            End
27120>>>>>>>>>>>>
27120>>>>>>>>>>>            Else Begin
27121>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
27122>>>>>>>>>>>            End
27122>>>>>>>>>>>>
27122>>>>>>>>>>>
27122>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
27123>>>>>>>>>>>        End
27123>>>>>>>>>>>>
27123>>>>>>>>>>>    End_Procedure
27124>>>>>>>>>>>
27124>>>>>>>>>>>    Procedure Show_EnterAsTab
27126>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
27126>>>>>>>>>>>        String sText
27126>>>>>>>>>>>
27126>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27128>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
27129>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
27131>>>>>>>>>>>                Move "True" To sText
27132>>>>>>>>>>>            End
27132>>>>>>>>>>>>
27132>>>>>>>>>>>            Else Begin
27133>>>>>>>>>>>                Move "False" To sText
27134>>>>>>>>>>>            End
27134>>>>>>>>>>>>
27134>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
27135>>>>>>>>>>>        End
27135>>>>>>>>>>>>
27135>>>>>>>>>>>    End_Procedure
27136>>>>>>>>>>>
27136>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
27136>>>>>>>>>>>    //    found systeminformation
27136>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
27138>>>>>>>>>>>        Forward Send Add_Focus hoRoot
27140>>>>>>>>>>>
27140>>>>>>>>>>>        Send Delete_Data
27141>>>>>>>>>>>
27141>>>>>>>>>>>        Set Changed_State To False
27142>>>>>>>>>>>        Set Read_Only_State To True
27143>>>>>>>>>>>
27143>>>>>>>>>>>        Send Show_Registration
27144>>>>>>>>>>>        Send Show_Drivers
27145>>>>>>>>>>>        Send Show_ServicePack
27146>>>>>>>>>>>        Send Show_Versions
27147>>>>>>>>>>>        Send AppendTextLn ""
27148>>>>>>>>>>>
27148>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27150>>>>>>>>>>>            Send Show_WorkSpaceInformation
27151>>>>>>>>>>>            Send Show_HelpFile
27152>>>>>>>>>>>            Send AppendTextLn ""
27153>>>>>>>>>>>        End
27153>>>>>>>>>>>>
27153>>>>>>>>>>>        Else Begin
27154>>>>>>>>>>>            Send AppendTextLn ""
27155>>>>>>>>>>>        End
27155>>>>>>>>>>>>
27155>>>>>>>>>>>
27155>>>>>>>>>>>        If (ghoConnection <> 0) Begin
27157>>>>>>>>>>>            Send Show_ConnectionIdInformation
27158>>>>>>>>>>>        End
27158>>>>>>>>>>>>
27158>>>>>>>>>>>
27158>>>>>>>>>>>        Send Show_Current_User
27159>>>>>>>>>>>        Send Show_Windows_Directory
27160>>>>>>>>>>>        Send Show_Current_Directory
27161>>>>>>>>>>>
27161>>>>>>>>>>>        // This is already shown in the workspace details,
27161>>>>>>>>>>>        // unless no workspace object is present:
27161>>>>>>>>>>>        If (ghoApplication = 0) Begin
27163>>>>>>>>>>>            Send Show_Filelist_Name
27164>>>>>>>>>>>        End
27164>>>>>>>>>>>>
27164>>>>>>>>>>>
27164>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27166>>>>>>>>>>>            Send AppendTextLn ""
27167>>>>>>>>>>>            Send Show_EnterAsTab
27168>>>>>>>>>>>        End
27168>>>>>>>>>>>>
27168>>>>>>>>>>>
27168>>>>>>>>>>>        Send Show_Screen_Size
27169>>>>>>>>>>>        Send Show_Page_Size
27170>>>>>>>>>>>        Send Show_Number_Format
27171>>>>>>>>>>>        Send Show_Date_Format
27172>>>>>>>>>>>        Send Show_Lock_Delay
27173>>>>>>>>>>>        Send Show_Lock_Timeout
27174>>>>>>>>>>>        Send Show_Date
27175>>>>>>>>>>>        Send Show_Systemresources
27176>>>>>>>>>>>        Send Beginning_of_Data
27177>>>>>>>>>>>
27177>>>>>>>>>>>        Set Icon to 'default.ico'
27178>>>>>>>>>>>    End_Procedure
27179>>>>>>>>>>>End_Class
27180>>>>>>>>>>>
27180>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
27181>>>>>>>>>>>    Procedure Construct_Object
27183>>>>>>>>>>>        Forward Send Construct_Object
27185>>>>>>>>>>>
27185>>>>>>>>>>>        Set Label to C_$SystemInformation
27186>>>>>>>>>>>        Set Size to 140 267
27187>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
27188>>>>>>>>>>>        Set Border_Style to Border_Thick
27189>>>>>>>>>>>        Set Sysmenu_Icon to False
27190>>>>>>>>>>>
27190>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
27190>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
27191>>>>>>>>>>>
27191>>>>>>>>>>>        // 2014-09-14 NGS
27191>>>>>>>>>>>        // Added a container object around the cTexteditor
27191>>>>>>>>>>>        // object to get a border around the text.
27191>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
27193>>>>>>>>>>>            Set Location to 2 4
27194>>>>>>>>>>>            Set Size to 110 255
27195>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
27196>>>>>>>>>>>            Set Color to clWhite
27197>>>>>>>>>>>            Set peAnchors to anAll
27198>>>>>>>>>>>
27198>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
27200>>>>>>>>>>>            End_Object
27201>>>>>>>>>>>
27201>>>>>>>>>>>        End_Object
27202>>>>>>>>>>>
27202>>>>>>>>>>>        Object oCloseButton is a Button
27204>>>>>>>>>>>            Set Label to C_$Close
27205>>>>>>>>>>>            Set Location to 120 210
27206>>>>>>>>>>>            Set Message item 0 to msg_Close_Panel
27207>>>>>>>>>>>            Set Default_State To True
27208>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
27208>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
27208>>>>>>>>>>>            // for that situation.
27208>>>>>>>>>>>            Set peAnchors to anBottomRight
27209>>>>>>>>>>>        End_Object
27210>>>>>>>>>>>
27210>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
27212>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
27213>>>>>>>>>>>            Set Size to 14 50
27214>>>>>>>>>>>            Set Location to 120 158
27215>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27215>>>>>>>>>>>            // we might as well prepare the object for it.
27215>>>>>>>>>>>            Set peAnchors to anBottomRight
27216>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
27217>>>>>>>>>>>        End_Object
27218>>>>>>>>>>>
27218>>>>>>>>>>>        On_Key kCancel Send Close_Panel
27219>>>>>>>>>>>    End_Procedure
27220>>>>>>>>>>>
27220>>>>>>>>>>>    Procedure Page Integer iPageObject
27222>>>>>>>>>>>        Handle hMenu
27222>>>>>>>>>>>        Integer iPrevState
27222>>>>>>>>>>>
27222>>>>>>>>>>>        Forward Send Page iPageObject
27224>>>>>>>>>>>
27224>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
27224>>>>>>>>>>>        //
27224>>>>>>>>>>>    End_Procedure
27225>>>>>>>>>>>
27225>>>>>>>>>>>End_Class
27226>>>>>>>>>>>
27226>>>>>>>>>>>Class cAboutEdit is an cRichEdit
27227>>>>>>>>>>>    Procedure Construct_Object
27229>>>>>>>>>>>        Forward Send Construct_Object
27231>>>>>>>>>>>
27231>>>>>>>>>>>        Property String psContentText
27232>>>>>>>>>>>
27232>>>>>>>>>>>        Set Size to 77 153
27233>>>>>>>>>>>        Set Location to 8 60
27234>>>>>>>>>>>        Set Read_Only_State to True
27235>>>>>>>>>>>        Set Skip_State to True
27236>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
27236>>>>>>>>>>>        // or 1/20 of a printer's point.
27236>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
27237>>>>>>>>>>>        Set Border_Style  to Border_None
27238>>>>>>>>>>>    End_Procedure
27239>>>>>>>>>>>
27239>>>>>>>>>>>    // Adds a line of text to the edit object
27239>>>>>>>>>>>    Procedure Add_Line String sText
27241>>>>>>>>>>>        String sContentText
27241>>>>>>>>>>>        Get psContentText to sContentText
27242>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
27243>>>>>>>>>>>        Set psContentText to sContentText
27244>>>>>>>>>>>    End_Procedure
27245>>>>>>>>>>>
27245>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
27245>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
27245>>>>>>>>>>>    // because the object isn't paged yet when we add these
27245>>>>>>>>>>>    // values and the COM edit object needs to be paged
27245>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
27245>>>>>>>>>>>    Procedure Add_LineLn String sText
27247>>>>>>>>>>>        String sContentText sCR
27247>>>>>>>>>>>
27247>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
27248>>>>>>>>>>>        Get psContentText to sContentText
27249>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
27250>>>>>>>>>>>        Set psContentText to sContentText
27251>>>>>>>>>>>    End_Procedure
27252>>>>>>>>>>>
27252>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
27254>>>>>>>>>>>        String sLinkText
27254>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
27255>>>>>>>>>>>        Send Show_HomePage sLinkText
27256>>>>>>>>>>>    End_Procedure
27257>>>>>>>>>>>
27257>>>>>>>>>>>    Procedure Page Integer iPageObject
27259>>>>>>>>>>>        String sContentText
27259>>>>>>>>>>>
27259>>>>>>>>>>>        Forward Send Page iPageObject
27261>>>>>>>>>>>        Get psContentText to sContentText
27262>>>>>>>>>>>        Send AppendText sContentText
27263>>>>>>>>>>>        send Beginning_of_Data
27264>>>>>>>>>>>    End_Procedure
27265>>>>>>>>>>>
27265>>>>>>>>>>>End_Class
27266>>>>>>>>>>>
27266>>>>>>>>>>>Class AboutDialog is a ModalPanel
27267>>>>>>>>>>>    Procedure Construct_Object
27269>>>>>>>>>>>
27269>>>>>>>>>>>        Forward Send Construct_Object
27271>>>>>>>>>>>
27271>>>>>>>>>>>        Set Label to C_$About
27272>>>>>>>>>>>        Set Size to 118 230
27273>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
27274>>>>>>>>>>>        Set Border_Style to Border_Thick
27275>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
27276>>>>>>>>>>>
27276>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
27278>>>>>>>>>>>        End_Object
27279>>>>>>>>>>>
27279>>>>>>>>>>>        Object oBox is a Container3d
27281>>>>>>>>>>>            Set Border_Style to Border_Normal
27282>>>>>>>>>>>            Set Size to 90 220
27283>>>>>>>>>>>            Set Location to 4 5
27284>>>>>>>>>>>            Set Color to clWhite
27285>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27285>>>>>>>>>>>            // we might as well prepare the object for it.
27285>>>>>>>>>>>            Set peAnchors to anAll
27286>>>>>>>>>>>
27286>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
27288>>>>>>>>>>>                Set Border_Style To Border_None
27289>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
27290>>>>>>>>>>>                Set Color to clWhite
27291>>>>>>>>>>>                Set Size to 45 50
27292>>>>>>>>>>>                Set Location to 0 3
27293>>>>>>>>>>>            End_Object
27294>>>>>>>>>>>
27294>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
27296>>>>>>>>>>>                Set Border_Style to Border_None
27297>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
27298>>>>>>>>>>>                Set Color to clWhite
27299>>>>>>>>>>>                Set Size to 30 55
27300>>>>>>>>>>>                Set Location to 50 3
27301>>>>>>>>>>>            End_Object
27302>>>>>>>>>>>
27302>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
27304>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
27304>>>>>>>>>>>                // we might as well prepare the object for it.
27304>>>>>>>>>>>                Set peAnchors to anAll
27305>>>>>>>>>>>            End_Object
27306>>>>>>>>>>>
27306>>>>>>>>>>>            // These objects are here for backwards compatability only.
27306>>>>>>>>>>>            // They are not used.
27306>>>>>>>>>>>            Object oProductName is a TextBox
27308>>>>>>>>>>>                Set Label To C_$ProductName
27309>>>>>>>>>>>                Set Size To 10 45
27310>>>>>>>>>>>                Set Location To 8 53
27311>>>>>>>>>>>                Set Visible_State to False
27312>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27313>>>>>>>>>>>            End_Object
27314>>>>>>>>>>>
27314>>>>>>>>>>>            Object oVersion is a TextBox
27316>>>>>>>>>>>                Set Label To C_$Version
27317>>>>>>>>>>>                Set Size To 10 25
27318>>>>>>>>>>>                Set Location To 21 53
27319>>>>>>>>>>>                Set Visible_State to False
27320>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27321>>>>>>>>>>>            End_Object
27322>>>>>>>>>>>
27322>>>>>>>>>>>            Object oCopyright is a TextBox
27324>>>>>>>>>>>                Set Label To C_$Copyright
27325>>>>>>>>>>>                Set Size To 10 31
27326>>>>>>>>>>>                Set Location To 34 53
27327>>>>>>>>>>>                Set Visible_State to False
27328>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27329>>>>>>>>>>>            End_Object
27330>>>>>>>>>>>
27330>>>>>>>>>>>            Object oAuthor is a TextBox
27332>>>>>>>>>>>                Set Label To C_$Author
27333>>>>>>>>>>>                Set Size To 10 22
27334>>>>>>>>>>>                Set Location To 46 53
27335>>>>>>>>>>>                Set Visible_State to False
27336>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27337>>>>>>>>>>>            End_Object
27338>>>>>>>>>>>
27338>>>>>>>>>>>        End_Object
27339>>>>>>>>>>>
27339>>>>>>>>>>>        Object oOKButton is a Button
27341>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
27342>>>>>>>>>>>            Set Location to 98 176
27343>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27343>>>>>>>>>>>            // we might as well prepare the object for it.
27343>>>>>>>>>>>            Set peAnchors to anBottomRight
27344>>>>>>>>>>>        End_Object
27345>>>>>>>>>>>
27345>>>>>>>>>>>        Object oSysInfoButton is a Button
27347>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
27348>>>>>>>>>>>            Set Location to 98 123
27349>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27349>>>>>>>>>>>            // we might as well prepare the object for it.
27349>>>>>>>>>>>            Set peAnchors to anBottomRight
27350>>>>>>>>>>>        End_Object
27351>>>>>>>>>>>
27351>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
27353>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
27354>>>>>>>>>>>            Set Size to 14 50
27355>>>>>>>>>>>            Set Location to 98 70
27356>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27356>>>>>>>>>>>            // we might as well prepare the object for it.
27356>>>>>>>>>>>            Set peAnchors to anBottomRight
27357>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
27358>>>>>>>>>>>        End_Object
27359>>>>>>>>>>>
27359>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
27360>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
27361>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
27362>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
27362>>>>>>>>>>>    End_Procedure
27363>>>>>>>>>>>
27363>>>>>>>>>>>    Procedure Page Integer iPageObject
27365>>>>>>>>>>>        Handle hMenu
27365>>>>>>>>>>>        Integer iPrevState
27365>>>>>>>>>>>
27365>>>>>>>>>>>        Forward Send Page iPageObject
27367>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
27367>>>>>>>>>>>        Set Icon to "Default.ico"
27368>>>>>>>>>>>
27368>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
27368>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
27369>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27370>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
27370>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27370>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27371>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27372>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27373>>>>>>>>>>>        // The "Close" menu command may be good to have.
27373>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27373>>>>>>>>>>>    End_Procedure
27374>>>>>>>>>>>
27374>>>>>>>>>>>    Procedure Set ProductName String sText
27376>>>>>>>>>>>        Set Value of oProductName to sText
27377>>>>>>>>>>>    End_Procedure
27378>>>>>>>>>>>
27378>>>>>>>>>>>    Procedure Set Copyright String sText
27380>>>>>>>>>>>        Set Value of oCopyright to sText
27381>>>>>>>>>>>    End_Procedure
27382>>>>>>>>>>>
27382>>>>>>>>>>>    Procedure Set Author String sText
27384>>>>>>>>>>>        Set Value of oAuthor to sText
27385>>>>>>>>>>>    End_Procedure
27386>>>>>>>>>>>
27386>>>>>>>>>>>    Procedure Set Version String sVersion
27388>>>>>>>>>>>        Handle hoVersionInfo
27388>>>>>>>>>>>        Boolean bIncluded
27388>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
27388>>>>>>>>>>>//        Date dCompileDate
27388>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
27388>>>>>>>>>>>
27388>>>>>>>>>>>        If (sVersion = "") Begin
27390>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
27390>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
27390>>>>>>>>>>>            If (ghoApplication <> 0) Begin
27392>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
27393>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
27395>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
27396>>>>>>>>>>>                    If (bIncluded) Begin
27398>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
27399>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
27400>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
27401>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
27402>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
27403>>>>>>>>>>>                    End
27403>>>>>>>>>>>>
27403>>>>>>>>>>>                End
27403>>>>>>>>>>>>
27403>>>>>>>>>>>            End
27403>>>>>>>>>>>>
27403>>>>>>>>>>>        End
27403>>>>>>>>>>>>
27403>>>>>>>>>>>
27403>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
27403>>>>>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
27404>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
27406>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
27407>>>>>>>>>>>        End
27407>>>>>>>>>>>>
27407>>>>>>>>>>>//        Get GetCompileDate to dCompileDate
27407>>>>>>>>>>>//        If (sVersion <> "") Begin
27407>>>>>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
27407>>>>>>>>>>>//        End
27407>>>>>>>>>>>
27407>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
27408>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
27410>>>>>>>>>>>            If (sCertInfo <> "") Begin
27412>>>>>>>>>>>                Send Add_LineLn sCertInfo
27413>>>>>>>>>>>            End
27413>>>>>>>>>>>>
27413>>>>>>>>>>>            Else Begin
27414>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
27415>>>>>>>>>>>            End
27415>>>>>>>>>>>>
27415>>>>>>>>>>>        End
27415>>>>>>>>>>>>
27415>>>>>>>>>>>    End_Procedure
27416>>>>>>>>>>>
27416>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
27418>>>>>>>>>>>        Boolean bIsDate
27418>>>>>>>>>>>        String sGoodCharacters sChar
27418>>>>>>>>>>>        Integer iCount iLength
27418>>>>>>>>>>>
27418>>>>>>>>>>>        Move True to bIsDate
27419>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
27420>>>>>>>>>>>        Move (Length(sDate)) to iLength
27421>>>>>>>>>>>        For iCount from 1 to iLength
27427>>>>>>>>>>>>
27427>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
27428>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
27429>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
27430>>>>>>>>>>>            If (bIsDate = False) Begin
27432>>>>>>>>>>>                Move iLength to iCount
27433>>>>>>>>>>>            End
27433>>>>>>>>>>>>
27433>>>>>>>>>>>        Loop
27434>>>>>>>>>>>>
27434>>>>>>>>>>>        Function_Return bIsDate
27435>>>>>>>>>>>    End_Function
27436>>>>>>>>>>>
27436>>>>>>>>>>>    Function GetCompileDate Returns Date
27438>>>>>>>>>>>        Date dCompileDate
27438>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
27438>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
27438>>>>>>>>>>>        Boolean bIsValid   
27438>>>>>>>>>>>        
27438>>>>>>>>>>>        Move 0 to dCompileDate
27439>>>>>>>>>>>        // Get full path to the current running executable
27439>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
27440>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
27441>>>>>>>>>>>
27441>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
27441>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
27442>>>>>>>>>>>
27442>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
27444>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
27445>>>>>>>>>>>        If (iPos > 0) Begin
27447>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
27447>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
27448>>>>>>>>>>>
27448>>>>>>>>>>>            // If the current date format is non US, we need to temporary
27448>>>>>>>>>>>            // change the format and then move the string to the date variable.
27448>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
27451>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
27454>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
27455>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
27457>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
27458>>>>>>>>>>>            End
27458>>>>>>>>>>>>
27458>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
27459>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
27460>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
27463>>>>>>>>>>>        End
27463>>>>>>>>>>>>
27463>>>>>>>>>>>        Else Begin
27464>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
27465>>>>>>>>>>>>
27465>>>>>>>>>>>        End
27465>>>>>>>>>>>>
27465>>>>>>>>>>>
27465>>>>>>>>>>>        Send Seq_Close_Channel iChannel
27466>>>>>>>>>>>
27466>>>>>>>>>>>        Function_Return dCompileDate
27467>>>>>>>>>>>    End_Function
27468>>>>>>>>>>>
27468>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
27468>>>>>>>>>>>    // (the passed program), has been finished
27468>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
27468>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
27470>>>>>>>>>>>        Handle hProcess
27470>>>>>>>>>>>        Integer iVoid
27470>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
27470>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
27470>>>>>>>>>>>
27470>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
27471>>>>>>>>>>>
27471>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
27472>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
27473>>>>>>>>>>>
27473>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
27474>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
27475>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
27475>>>>>>>>>>>        Move 0                       to sInfo.nShow
27476>>>>>>>>>>>
27476>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
27477>>>>>>>>>>>        Move sInfo.hProcess to hProcess
27478>>>>>>>>>>>        If (hProcess) Begin
27480>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
27481>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
27482>>>>>>>>>>>        End
27482>>>>>>>>>>>>
27482>>>>>>>>>>>    End_Procedure
27483>>>>>>>>>>>
27483>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
27485>>>>>>>>>>>        String sDirSep
27485>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
27486>>>>>>>>>>>        Move (Trim(sPath)) to sPath
27487>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
27489>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
27490>>>>>>>>>>>        End
27490>>>>>>>>>>>>
27490>>>>>>>>>>>        Function_Return sPath
27491>>>>>>>>>>>    End_Function
27492>>>>>>>>>>>
27492>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
27492>>>>>>>>>>>    // or there is a problem with the certificate.
27492>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
27492>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
27492>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
27494>>>>>>>>>>>        Boolean bExists
27494>>>>>>>>>>>        String sPath sProgram sParams sRetval
27494>>>>>>>>>>>        Integer iCh
27494>>>>>>>>>>>
27494>>>>>>>>>>>        Move "" to sRetval
27495>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
27496>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
27497>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
27498>>>>>>>>>>>        If (bExists = False) Begin
27500>>>>>>>>>>>            Function_Return "-1"
27501>>>>>>>>>>>        End
27501>>>>>>>>>>>>
27501>>>>>>>>>>>
27501>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
27502>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
27503>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
27504>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
27505>>>>>>>>>>>        Get Seq_New_Channel to iCh
27506>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
27508>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
27511>>>>>>>>>>>        Close_Output channel iCh
27513>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
27513>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
27514>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
27516>>>>>>>>>>>            Readln channel iCh sRetval
27518>>>>>>>>>>>            Readln channel iCh sRetval
27520>>>>>>>>>>>            Readln channel iCh sRetval
27522>>>>>>>>>>>            Readln channel iCh sRetval
27524>>>>>>>>>>>        Close_Input channel iCh
27526>>>>>>>>>>>        Send Seq_Release_Channel iCh
27527>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
27529>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
27530>>>>>>>>>>>        End
27530>>>>>>>>>>>>
27530>>>>>>>>>>>        Else Begin
27531>>>>>>>>>>>            Move "" to sRetval
27532>>>>>>>>>>>        End
27532>>>>>>>>>>>>
27532>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
27532>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
27533>>>>>>>>>>>>
27533>>>>>>>>>>>        Function_Return sRetval
27534>>>>>>>>>>>    End_Function
27535>>>>>>>>>>>
27535>>>>>>>>>>>    Procedure Add_LineLn String sValue
27537>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
27538>>>>>>>>>>>    End_Procedure
27539>>>>>>>>>>>
27539>>>>>>>>>>>    Procedure Add_Line String sValue
27541>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
27542>>>>>>>>>>>    End_Procedure
27543>>>>>>>>>>>
27543>>>>>>>>>>>    Procedure Set Logo string sLogo
27545>>>>>>>>>>>        // Square bitmaps of 80x80 work best
27545>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
27546>>>>>>>>>>>    End_Procedure
27547>>>>>>>>>>>
27547>>>>>>>>>>>    Procedure Set LogoDF String sLogo
27549>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
27550>>>>>>>>>>>    End_Procedure
27551>>>>>>>>>>>
27551>>>>>>>>>>>    Procedure Show_Sysinfo
27553>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
27554>>>>>>>>>>>    End_Procedure
27555>>>>>>>>>>>
27555>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
27557>>>>>>>>>>>        Handle hWnd
27557>>>>>>>>>>>        Get Window_Handle to hWnd
27558>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
27559>>>>>>>>>>>    End_Procedure
27560>>>>>>>>>>>
27560>>>>>>>>>>>End_Class
27561>>>>>>>>>
27561>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
27563>>>>>>>>>    End_Function
27564>>>>>>>>>
27564>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
27565>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
27566>>>>>>>>>>
27566>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
27568>>>>>>>>>>    Integer iStart iEnd
27568>>>>>>>>>>    String sRetval
27568>>>>>>>>>>
27568>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
27569>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
27570>>>>>>>>>>    If (iStart = 0) Begin
27572>>>>>>>>>>        Function_Return ""
27573>>>>>>>>>>    End
27573>>>>>>>>>>>
27573>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
27574>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
27575>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
27577>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
27578>>>>>>>>>>    End
27578>>>>>>>>>>>
27578>>>>>>>>>>    Else Begin
27579>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
27580>>>>>>>>>>    End
27580>>>>>>>>>>>
27580>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
27582>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
27583>>>>>>>>>>        Decrement iEnd
27584>>>>>>>>>>    End
27584>>>>>>>>>>>
27584>>>>>>>>>>    If (iEnd <> 0) Begin
27586>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
27587>>>>>>>>>>    End
27587>>>>>>>>>>>
27587>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
27588>>>>>>>>>>
27588>>>>>>>>>>    Function_Return (Trim(sRetval))
27589>>>>>>>>>>End_Function
27590>>>>>>>>>>
27590>>>>>>>>>>
27590>>>>>>>>>    
27590>>>>>>>>>    Procedure Construct_Object
27592>>>>>>>>>        Handle ho
27592>>>>>>>>>        Forward Send Construct_Object
27594>>>>>>>>>
27594>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
27595>>>>>>>>>
27595>>>>>>>>>        Send CreateDbUpdateLibraryProperties
27596>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
27596>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
27596>>>>>>>>>        // etc settings.
27596>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27598>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
27599>>>>>>>>>            Set phoSQLConnectionHandler to ho
27600>>>>>>>>>        End
27600>>>>>>>>>>
27600>>>>>>>>>
27600>>>>>>>>>    End_Procedure
27601>>>>>>>>>
27601>>>>>>>>>    Procedure End_Construct_Object
27603>>>>>>>>>        Forward Send End_Construct_Object
27605>>>>>>>>>
27605>>>>>>>>>    End_Procedure
27606>>>>>>>>>
27606>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
27608>>>>>>>>>        Integer i iCols iItem
27608>>>>>>>>>        tSqlColumnNew[] aQueryColumns
27608>>>>>>>>>        tSqlColumnNew[] aQueryColumns
27609>>>>>>>>>
27609>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
27610>>>>>>>>>        For i from 1 to iCols
27616>>>>>>>>>>
27616>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
27617>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
27618>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
27619>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
27620>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
27621>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
27622>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
27623>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
27624>>>>>>>>>        Loop
27625>>>>>>>>>>
27625>>>>>>>>>        Set piColumns to iCols
27626>>>>>>>>>        Set paQueryColumns to aQueryColumns
27627>>>>>>>>>    End_Procedure
27628>>>>>>>>>
27628>>>>>>>>>End_Class
27629>>>>>>>
27629>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
27630>>>>>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
27630>>>>>>>//    #Include ParseKeyWord.pkg
27630>>>>>>>
27630>>>>>>>    Procedure Construct_Object
27632>>>>>>>        Handle ho
27632>>>>>>>        Forward Send Construct_Object
27634>>>>>>>
27634>>>>>>>//        Move Self to ghoDbUpdateFunctionLibrary
27634>>>>>>>//
27634>>>>>>>//        Send CreateDbUpdateLibraryProperties
27634>>>>>>>//        // If no ghoSQLConnectionHandler object has been created prior to this object,
27634>>>>>>>//        // we will create one as it is used for all ConnectionID, ConnectionString
27634>>>>>>>//        // etc settings.
27634>>>>>>>//        If (ghoSQLConnectionHandler = 0) Begin
27634>>>>>>>//            Get Create (RefClass(cSQLConnectionHandler)) to ho
27634>>>>>>>//            Set phoSQLConnectionHandler to ho
27634>>>>>>>//        End   
27634>>>>>>>        
27634>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
27635>>>>>>>
27635>>>>>>>    End_Procedure
27636>>>>>>>
27636>>>>>>>    Procedure End_Construct_Object
27638>>>>>>>        Forward Send End_Construct_Object
27640>>>>>>>    End_Procedure
27641>>>>>>>
27641>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
27641>>>>>>>    //
27641>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27641>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
27643>>>>>>>        Function_Return False
27644>>>>>>>    End_Function
27645>>>>>>>
27645>>>>>>>    // Function for creating a new *Database*.
27645>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
27645>>>>>>>    // Returns True if successful.
27645>>>>>>>    // ToDo: Currently only works for MS-SQL...
27645>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
27647>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
27647>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
27647>>>>>>>        Handle hConnection hStmt hoSQLManager
27647>>>>>>>        Integer iFetchResult iDbType
27647>>>>>>>        Boolean bOK bMertechDriver bExists
27647>>>>>>>
27647>>>>>>>        Get piDbType to iDbType
27648>>>>>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
27648>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
27650>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
27651>>>>>>>>
27651>>>>>>>            Function_Return False
27652>>>>>>>        End
27652>>>>>>>>
27652>>>>>>>
27652>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
27653>>>>>>>        If (bExists = True) Begin
27655>>>>>>>            Function_Return True
27656>>>>>>>        End
27656>>>>>>>>
27656>>>>>>>
27656>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27657>>>>>>>        If (bMertechDriver = False) Begin
27659>>>>>>>            Get phoSQLManager to hoSQLManager
27660>>>>>>>        End
27660>>>>>>>>
27660>>>>>>>        Else Begin
27661>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
27662>>>>>>>        End
27662>>>>>>>>
27662>>>>>>>
27662>>>>>>>        Get psConnectionID     to sConnectionID
27663>>>>>>>        Get psConnectionString to sConnectionString
27664>>>>>>>        Move 0 to LastErr
27665>>>>>>>
27665>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
27667>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
27667>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
27667>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
27667>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
27667>>>>>>>//                If (iPos > 0) Begin
27667>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
27667>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
27667>>>>>>>//                End
27667>>>>>>>//            End
27667>>>>>>>        End
27667>>>>>>>>
27667>>>>>>>
27667>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27668>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
27669>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27670>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
27672>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
27673>>>>>>>>
27673>>>>>>>            Function_Return False
27674>>>>>>>        End
27674>>>>>>>>
27674>>>>>>>
27674>>>>>>>        Get SqlOpen of hConnection to hStmt
27675>>>>>>>
27675>>>>>>>        If (hStmt = 0) Begin
27677>>>>>>>            Send SqlDisconnect of hoSQLManager
27678>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
27679>>>>>>>>
27679>>>>>>>            Function_Return False
27680>>>>>>>        End
27680>>>>>>>>
27680>>>>>>>
27680>>>>>>>        Get psCollation to sCollation
27681>>>>>>>
27681>>>>>>>        Case Begin
27681>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
27683>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
27684>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
27685>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
27686>>>>>>>
27686>>>>>>>                // Check if database exists
27686>>>>>>>                Send SqlExecDirect of hStmt sSQL
27687>>>>>>>                Get SqlFetch of hStmt to iFetchResult
27688>>>>>>>                Send SqlClose of hStmt
27689>>>>>>>                Send SqlDisconnect of hConnection
27690>>>>>>>                // If database already exists we're out of here!
27690>>>>>>>                // Note that we return True as this is not an error.
27690>>>>>>>                If (iFetchResult > 0) Begin
27692>>>>>>>                    Function_Return True
27693>>>>>>>                End
27693>>>>>>>>
27693>>>>>>>                // Database doesn't exist, create it.
27693>>>>>>>                If (iFetchResult = 0) Begin
27695>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
27696>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27697>>>>>>>                    If (sCollation <> "") Begin
27699>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
27700>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
27701>>>>>>>                    End
27701>>>>>>>>
27701>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
27702>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27703>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
27705>>>>>>>                        Function_Return False
27706>>>>>>>                    End
27706>>>>>>>>
27706>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
27706>>>>>>>                    Sleep 1
27707>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
27708>>>>>>>                End
27708>>>>>>>>
27708>>>>>>>                Case Break
27709>>>>>>>
27709>>>>>>>            Case (sDriverID = MDSPgSQL)
27712>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
27712>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
27713>>>>>>>                Case Break
27714>>>>>>>
27714>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
27717>>>>>>>                // ToDo: How should this be set/checked?
27717>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
27717>>>>>>>//                    Set psCollation to "utf8"
27717>>>>>>>//                End
27717>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
27717>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
27718>>>>>>>                Case Break
27719>>>>>>>
27719>>>>>>>            Case (sDriverID = MDSDB2)
27722>>>>>>>                Case Break
27723>>>>>>>
27723>>>>>>>            Case Else
27723>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
27724>>>>>>>>
27724>>>>>>>        Case End
27724>>>>>>>
27724>>>>>>>        If (Err = False) Begin
27726>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
27727>>>>>>>        End
27727>>>>>>>>
27727>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
27727>>>>>>>        // the one we just created.
27727>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
27729>>>>>>>            Set psDatabase to sDatabase
27730>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
27730>>>>>>>            If (bPermanantly = True) Begin
27732>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
27734>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
27735>>>>>>>                End
27735>>>>>>>>
27735>>>>>>>            End
27735>>>>>>>>
27735>>>>>>>        End
27735>>>>>>>>
27735>>>>>>>
27735>>>>>>>        Function_Return (Err = False)
27736>>>>>>>    End_Function
27737>>>>>>>
27737>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
27737>>>>>>>    // will be used.
27737>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
27739>>>>>>>        Boolean bOK bExists bShowProgress bErr
27739>>>>>>>        String sStatement sDriverID
27739>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27739>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27739>>>>>>>        Integer iDbType
27739>>>>>>>
27739>>>>>>>        If (sDatabase = "") Begin
27741>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
27742>>>>>>>>
27742>>>>>>>            Function_Return False
27743>>>>>>>        End
27743>>>>>>>>
27743>>>>>>>        If (sBackupName = "") Begin
27745>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
27746>>>>>>>>
27746>>>>>>>            Function_Return False
27747>>>>>>>        End
27747>>>>>>>>
27747>>>>>>>
27747>>>>>>>        // Create backup-folder if it doesn't exist
27747>>>>>>>        Get vFolderExists sPath to bExists
27748>>>>>>>        If (bExists = False) Begin
27750>>>>>>>            Get vCreateDirectory sPath to bErr
27751>>>>>>>            If (bErr = True) Begin
27753>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
27754>>>>>>>>
27754>>>>>>>                Function_Return False
27755>>>>>>>            End
27755>>>>>>>>
27755>>>>>>>        End
27755>>>>>>>>
27755>>>>>>>        // Make sure the path ends with a back-slash
27755>>>>>>>        If (sPath <> "") Begin
27757>>>>>>>            Get vFolderFormat sPath to sPath
27758>>>>>>>        End
27758>>>>>>>>
27758>>>>>>>
27758>>>>>>>        Get psDriverID to sDriverID
27759>>>>>>>        Get piDbType   to iDbType
27760>>>>>>>        If (num_arguments > 3) Begin
27762>>>>>>>            Move bShowProg to bShowProgress
27763>>>>>>>        End
27763>>>>>>>>
27763>>>>>>>
27763>>>>>>>        Case Begin
27763>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
27765>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
27765>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
27765>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
27766>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
27767>>>>>>>
27767>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
27768>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
27769>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
27770>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
27771>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
27772>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
27773>>>>>>>                Case Break
27774>>>>>>>            Case Else
27774>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
27775>>>>>>>        Case End
27775>>>>>>>
27775>>>>>>>        Function_Return bOK
27776>>>>>>>    End_Function
27777>>>>>>>
27777>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
27779>>>>>>>//        Boolean bOK bExists
27779>>>>>>>        String sStatement sDriverID sRetval //sPrevious
27779>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27779>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27779>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
27779>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
27779>>>>>>>        tSQLConnection SQLConnection
27779>>>>>>>        tSQLConnection SQLConnection
27779>>>>>>>
27779>>>>>>>        If (sDatabase = "") Begin
27781>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
27782>>>>>>>>
27782>>>>>>>            Function_Return ""
27783>>>>>>>        End
27783>>>>>>>>
27783>>>>>>>
27783>>>>>>>        Move "" to sRetval
27784>>>>>>>        Get psDriverID to sDriverID
27785>>>>>>>        Get piDbType   to iDbType
27786>>>>>>>
27786>>>>>>>        Case Begin
27786>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
27788>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
27788>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
27789>>>>>>>
27789>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
27790>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
27791>>>>>>>                Get phoSQLManager to hoSQLHandler
27792>>>>>>>
27792>>>>>>>                If (hoSQLHandler <> 0) Begin
27794>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
27795>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
27796>>>>>>>
27796>>>>>>>                    If (hoSQLConnect <> 0) Begin
27798>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
27799>>>>>>>                        If (hstmt <> 0) Begin
27801>>>>>>>                            Send SqlExecDirect of hstmt sStatement
27802>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
27803>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
27804>>>>>>>                            If (iFetchResult <> 0) Begin
27806>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
27807>>>>>>>                            End
27807>>>>>>>>
27807>>>>>>>                            Send SQLClose of hstmt
27808>>>>>>>                        End
27808>>>>>>>>
27808>>>>>>>                        Send SQLDisconnect of hoSQLConnect
27809>>>>>>>                    End
27809>>>>>>>>
27809>>>>>>>                End
27809>>>>>>>>
27809>>>>>>>                Case Break
27810>>>>>>>            Case Else
27810>>>>>>>                If (bSilent = False) Begin
27812>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
27813>>>>>>>                End
27813>>>>>>>>
27813>>>>>>>        Case End
27813>>>>>>>
27813>>>>>>>        Function_Return sRetval
27814>>>>>>>    End_Function
27815>>>>>>>
27815>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
27817>>>>>>>        Boolean bMertechDriver // bOK bExists 
27817>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
27817>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
27817>>>>>>>        Handle hConnection hStmt hoSQLManager
27817>>>>>>>        Integer iDbType // iFetchResult
27817>>>>>>>
27817>>>>>>>        If (sDatabase = "") Begin
27819>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
27820>>>>>>>>
27820>>>>>>>            Function_Return False
27821>>>>>>>        End
27821>>>>>>>>
27821>>>>>>>
27821>>>>>>>        If (sSQLCollation = "") Begin
27823>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
27824>>>>>>>>
27824>>>>>>>            Function_Return False
27825>>>>>>>        End
27825>>>>>>>>
27825>>>>>>>
27825>>>>>>>        Get psDriverID to sDriverID
27826>>>>>>>        Get piDbType   to iDbType
27827>>>>>>>
27827>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27828>>>>>>>        If (bMertechDriver = False) Begin
27830>>>>>>>            Get phoSQLManager to hoSQLManager
27831>>>>>>>        End
27831>>>>>>>>
27831>>>>>>>        Else Begin
27832>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
27833>>>>>>>        End
27833>>>>>>>>
27833>>>>>>>
27833>>>>>>>        Get psConnectionID     to sConnectionID
27834>>>>>>>        Get psConnectionString to sConnectionString
27835>>>>>>>        Move 0 to LastErr
27836>>>>>>>
27836>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27837>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
27838>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27839>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
27841>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
27842>>>>>>>>
27842>>>>>>>            Function_Return False
27843>>>>>>>        End
27843>>>>>>>>
27843>>>>>>>
27843>>>>>>>        Get SqlOpen of hConnection to hStmt
27844>>>>>>>
27844>>>>>>>        If (hStmt = 0) Begin
27846>>>>>>>            Send SqlDisconnect of hoSQLManager
27847>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
27848>>>>>>>>
27848>>>>>>>            Function_Return False
27849>>>>>>>        End
27849>>>>>>>>
27849>>>>>>>
27849>>>>>>>        // Check if collation already exists
27849>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
27850>>>>>>>        // If the current collate is the same as the new; do nothing.
27850>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
27852>>>>>>>            Function_Return True
27853>>>>>>>        End
27853>>>>>>>>
27853>>>>>>>
27853>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
27854>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
27855>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
27856>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
27857>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
27858>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
27859>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
27860>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
27861>>>>>>>
27861>>>>>>>        // MS-SQL Syntax:
27861>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
27861>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
27861>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
27861>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
27862>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
27863>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
27864>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
27864>>>>>>>
27864>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27865>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
27866>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27867>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
27869>>>>>>>           Function_Return False
27870>>>>>>>        End
27870>>>>>>>>
27870>>>>>>>
27870>>>>>>>        Function_Return (Err = False)
27871>>>>>>>    End_Function
27872>>>>>>>
27872>>>>>>>
27872>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27872>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
27874>>>>>>>        Function_Return False
27875>>>>>>>    End_Function
27876>>>>>>>
27876>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
27876>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
27876>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
27876>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
27876>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
27876>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
27878>>>>>>>        Handle hToTable
27878>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
27878>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
27878>>>>>>>        tSQLConnection SQLConnection
27878>>>>>>>        tSQLConnection SQLConnection
27878>>>>>>>        Integer iPos iMaxRecords
27878>>>>>>>
27878>>>>>>>        Get psDriverID to sDriverID
27879>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
27880>>>>>>>        If (bExists = False) Begin
27882>>>>>>>            Function_Return False
27883>>>>>>>        End
27883>>>>>>>>
27883>>>>>>>
27883>>>>>>>        If (num_arguments > 1) Begin
27885>>>>>>>            Move bCpyDat to bCopyData
27886>>>>>>>        End
27886>>>>>>>>
27886>>>>>>>        Else Begin
27887>>>>>>>            Move False to bCopyData
27888>>>>>>>        End
27888>>>>>>>>
27888>>>>>>>
27888>>>>>>>        Open hTable
27890>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
27893>>>>>>>        If (bOpened = False) Begin
27895>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
27896>>>>>>>>
27896>>>>>>>            Function_Return False
27897>>>>>>>        End
27897>>>>>>>>
27897>>>>>>>        Move 0 to hToTable
27898>>>>>>>
27898>>>>>>>        Move 16711679 to iMaxRecords
27899>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
27902>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
27903>>>>>>>        If (iPos > 0) Begin
27905>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
27906>>>>>>>        End
27906>>>>>>>>
27906>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
27909>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
27910>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
27911>>>>>>>
27911>>>>>>>        If (ghoProgressBar <> 0) Begin
27913>>>>>>>            Send DoAdvance of ghoProgressBar
27914>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
27915>>>>>>>        End
27915>>>>>>>>
27915>>>>>>>
27915>>>>>>>        Move False to Err
27916>>>>>>>
27916>>>>>>>        Structure_Start hToTable DATAFLEX_ID
27917>>>>>>>            Structure_Copy hTable to hToTable
27918>>>>>>>
27918>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
27921>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
27924>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
27927>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
27930>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
27933>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27934>>>>>>>
27934>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27936>>>>>>>
27936>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27937>>>>>>>        Move (not(Err)) to bOK
27938>>>>>>>        If (bOK = True and bCopyData = True) Begin
27940>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
27941>>>>>>>        End
27941>>>>>>>>
27941>>>>>>>
27941>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27942>>>>>>>        If (bMertechDriver = True) Begin
27944>>>>>>>            Open hTable
27946>>>>>>>        End
27946>>>>>>>>
27946>>>>>>>
27946>>>>>>>        // This must be after copying data...
27946>>>>>>>        If (Err = False) Begin
27948>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
27951>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
27954>>>>>>>        End
27954>>>>>>>>
27954>>>>>>>        Move (not(Err)) to bOK
27955>>>>>>>
27955>>>>>>>        Function_Return (bOK = True)
27956>>>>>>>    End_Function
27957>>>>>>>
27957>>>>>>>    Function AddFolderDelimiter String sPath Returns String
27959>>>>>>>        String sDirSep
27959>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
27960>>>>>>>        Move (Trim(sPath)) to sPath
27961>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
27963>>>>>>>            Move (sPath + sDirSep) to sPath
27964>>>>>>>        End
27964>>>>>>>>
27964>>>>>>>        Function_Return sPath
27965>>>>>>>    End_Function
27966>>>>>>>
27966>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
27966>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
27966>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
27968>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
27968>>>>>>>        Integer iDbType
27968>>>>>>>        Boolean bExists
27968>>>>>>>
27968>>>>>>>        Get psDriverID to sDriverID
27969>>>>>>>        Get UtilTableHandleToString hTable to sTableName
27970>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
27971>>>>>>>        If (bExists = True) Begin
27973>>>>>>>            Function_Return False
27974>>>>>>>        End
27974>>>>>>>>
27974>>>>>>>
27974>>>>>>>        Get psDataPathFirstPart to sPath
27975>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
27976>>>>>>>
27976>>>>>>>        Get piDbType to iDbType
27977>>>>>>>        Get _SqlProperTableName sTableName to sTableName
27978>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
27979>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
27980>>>>>>>
27980>>>>>>>        Move False to Err
27981>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27982>>>>>>>
27982>>>>>>>        Function_Return (Err = False)
27983>>>>>>>    End_Function
27984>>>>>>>
27984>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
27984>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
27984>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
27986>>>>>>>        String sSQLString sPath sCreateTable sDriverID
27986>>>>>>>        Integer iDbType
27986>>>>>>>        Boolean bExists
27986>>>>>>>
27986>>>>>>>        Get psDriverID to sDriverID
27987>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
27988>>>>>>>        If (bExists = True) Begin
27990>>>>>>>            Function_Return False
27991>>>>>>>        End
27991>>>>>>>>
27991>>>>>>>
27991>>>>>>>        Get psDataPathFirstPart to sPath
27992>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
27993>>>>>>>        If (bExists = True) Begin
27995>>>>>>>            // ToDo: What should we do if an .int file already exists?
27995>>>>>>>        End
27995>>>>>>>>
27995>>>>>>>
27995>>>>>>>        Get piDbType to iDbType
27996>>>>>>>        Get _SqlProperTableName sTableName to sTableName
27997>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
27998>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
27999>>>>>>>
27999>>>>>>>        Move False to Err
28000>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
28001>>>>>>>
28001>>>>>>>        Function_Return (Err = False)
28002>>>>>>>    End_Function
28003>>>>>>>    
28003>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
28003>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
28003>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
28005>>>>>>>        Boolean bOK                                                            
28005>>>>>>>        String sStatement
28005>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
28006>>>>>>>        Function_Return bOK
28007>>>>>>>    End_Function
28008>>>>>>>    
28008>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
28008>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
28008>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
28008>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
28010>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
28010>>>>>>>        Integer iRetval iDbType
28010>>>>>>>        Boolean bExists bMertechDriver bOK
28010>>>>>>>
28010>>>>>>>        Get psDriverID to sDriverID
28011>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28012>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28013>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
28014>>>>>>>        If (bExists = False) Begin
28016>>>>>>>            Function_Return False
28017>>>>>>>        End
28017>>>>>>>>
28017>>>>>>>
28017>>>>>>>        Get psDataPathFirstPart to sPath
28018>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
28019>>>>>>>
28019>>>>>>>        Get piDbType to iDbType
28020>>>>>>>        Get _SqlProperTableName sTableName to sTableName
28021>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
28022>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
28023>>>>>>>
28023>>>>>>>        Move False to Err
28024>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
28025>>>>>>>
28025>>>>>>>        // We also need to remove the cache-file since the table has been changed
28025>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28026>>>>>>>
28026>>>>>>>        Function_Return (Err = False)
28027>>>>>>>    End_Function
28028>>>>>>>
28028>>>>>>>    // First deletes the data cache file and then drops the passed data table.
28028>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
28030>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
28030>>>>>>>        Integer iRetval iDbType
28030>>>>>>>        Boolean bMertechDriver bOK
28030>>>>>>>
28030>>>>>>>        Get psDriverID to sDriverID
28031>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28032>>>>>>>        Get psDataPathFirstPart to sPath
28033>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
28034>>>>>>>
28034>>>>>>>        Get piDbType to iDbType
28035>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
28036>>>>>>>        Get psSchema to sSchema
28037>>>>>>>        If (sSchema = "") Begin
28039>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
28040>>>>>>>        End
28040>>>>>>>>
28040>>>>>>>        Move (Uppercase(sTableName)) to sVal
28041>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
28043>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
28044>>>>>>>        End
28044>>>>>>>>
28044>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
28045>>>>>>>
28045>>>>>>>        Move False to Err
28046>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
28047>>>>>>>
28047>>>>>>>        // We also need to remove the cache-file since the table has been changed
28047>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28048>>>>>>>
28048>>>>>>>        Function_Return (Err = False)
28049>>>>>>>    End_Function
28050>>>>>>>
28050>>>>>>>    // *** Sql View Messages ***
28050>>>>>>>
28050>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
28050>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
28052>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
28052>>>>>>>        Integer iRetval
28052>>>>>>>        Boolean bMertechDriver bOK
28052>>>>>>>
28052>>>>>>>        Get psDriverID to sDriverID
28053>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28054>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
28055>>>>>>>
28055>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
28056>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
28057>>>>>>>        Set psSQLStatementString to sSQLString
28058>>>>>>>
28058>>>>>>>        // As we don't check if the view exist or not, it might happen
28058>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
28058>>>>>>>        Move False to Err
28059>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28060>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
28061>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
28062>>>>>>>        Move 0 to LastErr
28063>>>>>>>
28063>>>>>>>        // We also need to remove the cache-file since the table has been changed
28063>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
28064>>>>>>>
28064>>>>>>>        Function_Return (Err = False)
28065>>>>>>>    End_Function
28066>>>>>>>
28066>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
28068>>>>>>>        Boolean bOK
28068>>>>>>>        Integer iDbType
28068>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
28068>>>>>>>
28068>>>>>>>        Get psDriverID to sDriverID
28069>>>>>>>        Get piDbType   to iDbType
28070>>>>>>>
28070>>>>>>>        Case Begin
28070>>>>>>>            Case (iDbType = EN_DbTypeDB2)
28072>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
28073>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
28074>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
28075>>>>>>>            Break
28076>>>>>>>
28076>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
28079>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
28080>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
28081>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
28082>>>>>>>            Break
28083>>>>>>>
28083>>>>>>>            Case (iDbType = EN_DbTypeOracle)
28086>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
28087>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
28088>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
28089>>>>>>>            Break
28090>>>>>>>
28090>>>>>>>            Case (iDbType = EN_DbTypePostgre)
28093>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
28094>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
28095>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
28096>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
28097>>>>>>>            Break
28098>>>>>>>
28098>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
28101>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
28102>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
28103>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
28104>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
28105>>>>>>>            Break
28106>>>>>>>        Case End
28106>>>>>>>
28106>>>>>>>        Move False to Err
28107>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
28108>>>>>>>        Move (Err = False) to bOK
28109>>>>>>>
28109>>>>>>>        Function_Return bOK
28110>>>>>>>    End_Function
28111>>>>>>>
28111>>>>>>>    // * Dummy function for the Studio's Code Explorer *
28111>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
28113>>>>>>>        Function_Return False
28114>>>>>>>    End_Function
28115>>>>>>>
28115>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
28115>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
28117>>>>>>>        Integer iLength iDecimals
28117>>>>>>>        String sColumnValue
28117>>>>>>>        String sTableName sDriverID
28117>>>>>>>        Boolean bOK bInitializeValue
28117>>>>>>>
28117>>>>>>>        Get psDriverID to sDriverID
28118>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28119>>>>>>>        If (bOK = False) Begin
28121>>>>>>>            Function_Return False
28122>>>>>>>        End
28122>>>>>>>>
28122>>>>>>>
28122>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28123>>>>>>>        If (sTableName = "") Begin
28125>>>>>>>            Function_Return False
28126>>>>>>>        End
28126>>>>>>>>
28126>>>>>>>
28126>>>>>>>        If (num_arguments > 3) Begin
28128>>>>>>>            Move iLen     to iLength
28129>>>>>>>            Move iDec     to iDecimals
28130>>>>>>>            Move bInitVal to bInitializeValue
28131>>>>>>>            Move sColVal  to sColumnValue
28132>>>>>>>        End
28132>>>>>>>>
28132>>>>>>>
28132>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
28133>>>>>>>
28133>>>>>>>        Function_Return (bOK = True)
28134>>>>>>>    End_Function
28135>>>>>>>
28135>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
28135>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
28137>>>>>>>        Integer iDbType iLength iDecimals iDriver
28137>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
28137>>>>>>>        String sDriverID sNotNull
28137>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
28137>>>>>>>        Handle hTable
28137>>>>>>>
28137>>>>>>>        Get psDriverID to sDriverID
28138>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28139>>>>>>>        If (bOK = False) Begin
28141>>>>>>>            Function_Return True
28142>>>>>>>        End
28142>>>>>>>>
28142>>>>>>>
28142>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
28143>>>>>>>        If (hTable = 0) Begin
28145>>>>>>>            Get NextFreeFilelistSlot to hTable
28146>>>>>>>        End
28146>>>>>>>>
28146>>>>>>>
28146>>>>>>>        Get piDbType to iDbType
28147>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
28147>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
28148>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
28150>>>>>>>            Function_Return True
28151>>>>>>>        End
28151>>>>>>>>
28151>>>>>>>
28151>>>>>>>        Get DriverIndex sDriverID to iDriver
28152>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
28153>>>>>>>        If (bIsMertechDriver = False) Begin
28155>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28158>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
28161>>>>>>>        End
28161>>>>>>>>
28161>>>>>>>
28161>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
28162>>>>>>>        If (num_arguments > 3) Begin
28164>>>>>>>            Move iLen     to iLength
28165>>>>>>>            Move iDec     to iDecimals
28166>>>>>>>            Move bInitVal to bInitializeValue
28167>>>>>>>            Move sColVal  to sColumnValue
28168>>>>>>>        End
28168>>>>>>>>
28168>>>>>>>
28168>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
28169>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
28170>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
28171>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
28172>>>>>>>
28172>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
28173>>>>>>>        If (bFixed = False) Begin
28175>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
28176>>>>>>>        End
28176>>>>>>>>
28176>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
28177>>>>>>>
28177>>>>>>>        Move False to Err
28178>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28179>>>>>>>
28179>>>>>>>        If (bInitializeValue = True and Err = False) Begin
28181>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
28182>>>>>>>        End
28182>>>>>>>>
28182>>>>>>>
28182>>>>>>>        If (Err = False) Begin
28184>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
28185>>>>>>>        End
28185>>>>>>>>
28185>>>>>>>
28185>>>>>>>        Move (not(Err)) to bRetval
28186>>>>>>>
28186>>>>>>>        // We also need to remove the cache-file since the table has been changed
28186>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28187>>>>>>>        If (bIsMertechDriver = False) Begin
28189>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28192>>>>>>>        End
28192>>>>>>>>
28192>>>>>>>        Function_Return bRetval
28193>>>>>>>    End_Function
28194>>>>>>>
28194>>>>>>>    // To update all current rows for a table column with a common value.
28194>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
28196>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
28196>>>>>>>        Boolean bRetval bSQLDriver
28196>>>>>>>        Integer iCurrErr iDbType
28196>>>>>>>
28196>>>>>>>        Move False to bRetval
28197>>>>>>>        Get piDbType to iDbType
28198>>>>>>>        Get psDriverID to sDriverID
28199>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
28200>>>>>>>        If (bSQLDriver = False) Begin
28202>>>>>>>            Function_Return bRetval
28203>>>>>>>        End
28203>>>>>>>>
28203>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28204>>>>>>>
28204>>>>>>>        Move Err to iCurrErr
28205>>>>>>>        Move False to Err
28206>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
28207>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
28208>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
28209>>>>>>>        If (sDriverID = MDSMySQL) Begin
28211>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
28212>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
28213>>>>>>>        End
28213>>>>>>>>
28213>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
28213>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
28215>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
28216>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
28217>>>>>>>        End
28217>>>>>>>>
28217>>>>>>>        Else Begin
28218>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
28219>>>>>>>        End
28219>>>>>>>>
28219>>>>>>>
28219>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28220>>>>>>>        Move (Err = False) to bRetval
28221>>>>>>>        Move iCurrErr to Err
28222>>>>>>>
28222>>>>>>>        Function_Return bRetval
28223>>>>>>>    End_Function
28224>>>>>>>
28224>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
28224>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
28224>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
28226>>>>>>>        String sDriverID sTableName
28226>>>>>>>        Boolean bOK
28226>>>>>>>
28226>>>>>>>        Get psDriverID to sDriverID
28227>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28228>>>>>>>        If (bOK = False) Begin
28230>>>>>>>            Function_Return False
28231>>>>>>>        End
28231>>>>>>>>
28231>>>>>>>
28231>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28232>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
28233>>>>>>>
28233>>>>>>>        Function_Return (Err = False)
28234>>>>>>>    End_Function
28235>>>>>>>
28235>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
28235>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
28235>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
28235>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
28237>>>>>>>        Integer iDbType iLength iDecimals
28237>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
28237>>>>>>>        Boolean bExists bOK bFixed
28237>>>>>>>        Handle hTable
28237>>>>>>>
28237>>>>>>>        Get psDriverID to sDriverID
28238>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28239>>>>>>>        If (bOK = False) Begin
28241>>>>>>>            Function_Return False
28242>>>>>>>        End
28242>>>>>>>>
28242>>>>>>>
28242>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
28243>>>>>>>        If (hTable = 0) Begin
28245>>>>>>>            Get NextFreeFilelistSlot to hTable
28246>>>>>>>        End
28246>>>>>>>>
28246>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
28247>>>>>>>        If (bExists = False) Begin
28249>>>>>>>            Function_Return False
28250>>>>>>>        End
28250>>>>>>>>
28250>>>>>>>
28250>>>>>>>        If (num_arguments > 3) Begin
28252>>>>>>>            Move iLen to iLength
28253>>>>>>>        End
28253>>>>>>>>
28253>>>>>>>        If (num_arguments > 4) Begin
28255>>>>>>>            Move iDec to iDecimals
28256>>>>>>>        End
28256>>>>>>>>
28256>>>>>>>
28256>>>>>>>        Get piDbType to iDbType
28257>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
28258>>>>>>>
28258>>>>>>>        Move False to Err
28259>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
28260>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
28261>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
28262>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
28263>>>>>>>
28263>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
28264>>>>>>>        If (bFixed = False) Begin
28266>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
28267>>>>>>>        End
28267>>>>>>>>
28267>>>>>>>
28267>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
28268>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28269>>>>>>>
28269>>>>>>>        // We also need to remove the cache-file since the table has been changed
28269>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28270>>>>>>>
28270>>>>>>>        Function_Return (Err = False)
28271>>>>>>>    End_Function
28272>>>>>>>
28272>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
28274>>>>>>>        Boolean bOK bErr bIsSQLDriver
28274>>>>>>>        String sDriverID
28274>>>>>>>        Integer iDataType
28274>>>>>>>
28274>>>>>>>        Get psDriverID to sDriverID
28275>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
28276>>>>>>>        If (bIsSQLDriver = False) Begin
28278>>>>>>>            Function_Return False
28279>>>>>>>        End
28279>>>>>>>>
28279>>>>>>>
28279>>>>>>>        Move Err to bErr
28280>>>>>>>        Move False to bErr
28281>>>>>>>
28281>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
28281>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
28281>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
28282>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
28285>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
28287>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
28288>>>>>>>        End
28288>>>>>>>>
28288>>>>>>>
28288>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
28291>>>>>>>        Move (not(Err)) to bOK
28292>>>>>>>        Move bErr to Err
28293>>>>>>>
28293>>>>>>>        Function_Return bOK
28294>>>>>>>    End_Function
28295>>>>>>>
28295>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
28297>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
28297>>>>>>>        String sDriverID
28297>>>>>>>
28297>>>>>>>        Get psDriverID to sDriverID
28298>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
28299>>>>>>>        If (bIsSQLDriver = False) Begin
28301>>>>>>>            Function_Return False
28302>>>>>>>        End
28302>>>>>>>>
28302>>>>>>>
28302>>>>>>>        Move Err to bErr
28303>>>>>>>        Move False to bErr
28304>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
28307>>>>>>>        If (bNullable = bCurrentState) Begin
28309>>>>>>>            Function_Return True
28310>>>>>>>        End
28310>>>>>>>>
28310>>>>>>>
28310>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
28313>>>>>>>        If (bOpen = False) Begin
28315>>>>>>>            Get AutoConnectionIDLogin to bOK
28316>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28317>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
28318>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
28319>>>>>>>            Open hTable
28321>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28322>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
28323>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
28324>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
28327>>>>>>>        End
28327>>>>>>>>
28327>>>>>>>        If (bOpen = True) Begin
28329>>>>>>>            Structure_Start hTable sDriverID
28330>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
28333>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
28334>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28336>>>>>>>            Set Action_Text of ghoStatusPanel to ""
28337>>>>>>>        End
28337>>>>>>>>
28337>>>>>>>
28337>>>>>>>        Move (not(Err)) to bOK
28338>>>>>>>        Move bErr to Err
28339>>>>>>>
28339>>>>>>>        Function_Return bOK
28340>>>>>>>    End_Function
28341>>>>>>>
28341>>>>>>>    // Drop column by its table handle
28341>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
28343>>>>>>>        String sDriverID sTableName
28343>>>>>>>        Boolean bOK
28343>>>>>>>
28343>>>>>>>        Get psDriverID to sDriverID
28344>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28345>>>>>>>        If (bOK = False) Begin
28347>>>>>>>            Function_Return False
28348>>>>>>>        End
28348>>>>>>>>
28348>>>>>>>
28348>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28349>>>>>>>        If (sTableName = "") Begin
28351>>>>>>>            Function_Return False
28352>>>>>>>        End
28352>>>>>>>>
28352>>>>>>>
28352>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
28353>>>>>>>
28353>>>>>>>        Function_Return (bOK = True)
28354>>>>>>>    End_Function
28355>>>>>>>
28355>>>>>>>    // Drop column by its table name as a string.
28355>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
28357>>>>>>>        Integer iDbType iDriver
28357>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
28357>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
28357>>>>>>>        Handle hTable
28357>>>>>>>
28357>>>>>>>        Get psDriverID to sDriverID
28358>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28359>>>>>>>        If (bOK = False) Begin
28361>>>>>>>            Function_Return False
28362>>>>>>>        End
28362>>>>>>>>
28362>>>>>>>
28362>>>>>>>        Get DriverIndex sDriverID to iDriver
28363>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28366>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
28369>>>>>>>
28369>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
28370>>>>>>>        If (hTable <> 0) Begin
28372>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
28373>>>>>>>            If (bExists = False) Begin
28375>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28378>>>>>>>                Function_Return False
28379>>>>>>>            End
28379>>>>>>>>
28379>>>>>>>        End
28379>>>>>>>>
28379>>>>>>>
28379>>>>>>>        Get piDbType to iDbType
28380>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
28382>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
28383>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
28384>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28387>>>>>>>            Function_Return bOK
28388>>>>>>>        End
28388>>>>>>>>
28388>>>>>>>
28388>>>>>>>        Move False to Err
28389>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
28390>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
28391>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
28392>>>>>>>
28392>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
28393>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28394>>>>>>>        Move (not(Err)) to bRetval
28395>>>>>>>
28395>>>>>>>        // We also need to remove the cache-file since the table has been changed
28395>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28396>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28399>>>>>>>
28399>>>>>>>        Function_Return bRetval
28400>>>>>>>    End_Function
28401>>>>>>>
28401>>>>>>>    // Rename a field/column by table handle (filelist number)
28401>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
28403>>>>>>>        String sDriverID sTableName
28403>>>>>>>        Boolean bOK
28403>>>>>>>
28403>>>>>>>        Get psDriverID to sDriverID
28404>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28405>>>>>>>        If (bOK = False) Begin
28407>>>>>>>            Function_Return False
28408>>>>>>>        End
28408>>>>>>>>
28408>>>>>>>
28408>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28409>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
28410>>>>>>>
28410>>>>>>>        Function_Return (Err = False)
28411>>>>>>>    End_Function
28412>>>>>>>
28412>>>>>>>    // Rename a field/column by table name.
28412>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
28414>>>>>>>        Integer iDbType iDataType
28414>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
28414>>>>>>>        Boolean bOK bRetval
28414>>>>>>>        Handle hTable
28414>>>>>>>
28414>>>>>>>        Move sTableName to sOrgTableName
28415>>>>>>>        Get psDriverID to sDriverID
28416>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28417>>>>>>>        If (bOK = False) Begin
28419>>>>>>>            Function_Return False
28420>>>>>>>        End
28420>>>>>>>>
28420>>>>>>>
28420>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
28421>>>>>>>        If (sVal = "") Begin
28423>>>>>>>            Function_Return False
28424>>>>>>>        End
28424>>>>>>>>
28424>>>>>>>
28424>>>>>>>        Get piDbType to iDbType
28425>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
28426>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
28427>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
28428>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
28429>>>>>>>
28429>>>>>>>        Case Begin
28429>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
28431>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
28432>>>>>>>                Case Break
28433>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
28433>>>>>>>            Case (iDbType = EN_dbTypeOracle)
28436>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
28437>>>>>>>                Case Break
28438>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
28438>>>>>>>            Case (iDbType = EN_dbTypeDB2)
28441>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
28442>>>>>>>                Case Break
28443>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
28443>>>>>>>            Case (iDbType = EN_dbTypePostgre)
28446>>>>>>>                Move sOrgTableName to sTableName
28447>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
28448>>>>>>>                Case Break
28449>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
28452>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
28452>>>>>>>                Move sOrgTableName to sTableName
28453>>>>>>>                Get psDatabase to sDatabase
28454>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
28455>>>>>>>                If (hTable = 0) Begin
28457>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
28458>>>>>>>                    If (bOK = False) Begin
28460>>>>>>>                        Function_Return False
28461>>>>>>>                    End
28461>>>>>>>>
28461>>>>>>>                    Get NextFreeFilelistSlot to hTable
28462>>>>>>>                End
28462>>>>>>>>
28462>>>>>>>                Else Begin
28463>>>>>>>                    Open hTable
28465>>>>>>>                End
28465>>>>>>>>
28465>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
28466>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
28467>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
28468>>>>>>>                Case Break
28469>>>>>>>            Case Else
28469>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
28470>>>>>>>        Case End
28470>>>>>>>
28470>>>>>>>        Move False to Err
28471>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28472>>>>>>>        Move (Err = False) to bRetval
28473>>>>>>>        // We also need to remove the cache-file since the table has been changed
28473>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28474>>>>>>>
28474>>>>>>>        Function_Return bRetval
28475>>>>>>>    End_Function
28476>>>>>>>
28476>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
28478>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
28478>>>>>>>        Boolean bMertechDriver
28478>>>>>>>        Integer iNumCols iCount iDataType
28478>>>>>>>        String sValue
28478>>>>>>>
28478>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28479>>>>>>>        If (bMertechDriver = False) Begin
28481>>>>>>>            Get phoSQLManager to hoSQLHandler
28482>>>>>>>        End
28482>>>>>>>>
28482>>>>>>>        Else Begin
28483>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
28484>>>>>>>        End
28484>>>>>>>>
28484>>>>>>>
28484>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
28485>>>>>>>        If (hSQLConnect <> 0) Begin
28487>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
28488>>>>>>>            If (hStmt <> 0) Begin
28490>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
28491>>>>>>>
28491>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
28492>>>>>>>                For iCount from 1 to iNumCols
28498>>>>>>>>
28498>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
28499>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
28501>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
28502>>>>>>>                        Move iNumCols to iCount // We're out of here
28503>>>>>>>                    End
28503>>>>>>>>
28503>>>>>>>                Loop
28504>>>>>>>>
28504>>>>>>>
28504>>>>>>>                Send SQLClose of hStmt
28505>>>>>>>            End
28505>>>>>>>>
28505>>>>>>>            Send SQLDisconnect of hSQLConnect
28506>>>>>>>        End
28506>>>>>>>>
28506>>>>>>>
28506>>>>>>>        Function_Return iDataType
28507>>>>>>>    End_Function
28508>>>>>>>
28508>>>>>>>    // * Dummy function for the Studio's Code Explorer *
28508>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
28510>>>>>>>        Function_Return False
28511>>>>>>>    End_Function
28512>>>>>>>
28512>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
28514>>>>>>>        String sMessage // sConnectionString
28514>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
28514>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
28514>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
28517>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
28517>>>>>>>        TimeSpan tsQuery tsFetch
28517>>>>>>>        tSqlErrorArray aSqlErrorArray
28517>>>>>>>        tSqlErrorArray aSqlErrorArray
28517>>>>>>>        Boolean bOK bMertechDriver bShowProgress
28517>>>>>>>        tSQLConnection SQLConnection
28517>>>>>>>        tSQLConnection SQLConnection
28517>>>>>>>
28517>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28518>>>>>>>        If (bOK = False) Begin
28520>>>>>>>            Procedure_Return
28521>>>>>>>        End
28521>>>>>>>>
28521>>>>>>>
28521>>>>>>>        If (num_arguments > 2) Begin
28523>>>>>>>            Move bShowProgr to bShowProgress
28524>>>>>>>        End
28524>>>>>>>>
28524>>>>>>>
28524>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28525>>>>>>>
28525>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28526>>>>>>>        If (bMertechDriver = True) Begin
28528>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
28529>>>>>>>        End
28529>>>>>>>>
28529>>>>>>>        If (bMertechDriver = False) Begin
28531>>>>>>>            Get phoSQLManager to hoSqlHandler
28532>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
28533>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
28534>>>>>>>        End
28534>>>>>>>>
28534>>>>>>>
28534>>>>>>>        If (hoSQLConnect <> 0) Begin
28536>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
28537>>>>>>>            If (hoStmt <> 0) Begin
28539>>>>>>>                // record starting date/time stamp
28539>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
28540>>>>>>>                // turn on error handling if enabled
28540>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
28542>>>>>>>                    Set pbSqlError to False
28543>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
28544>>>>>>>                    Move Error_Object_Id to hoError
28545>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
28547>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
28548>>>>>>>                    End
28548>>>>>>>>
28548>>>>>>>                    Else Begin
28549>>>>>>>                        Move Self to Error_Object_Id
28550>>>>>>>                    End
28550>>>>>>>>
28550>>>>>>>                End
28550>>>>>>>>
28550>>>>>>>
28550>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
28550>>>>>>>                Set psSQLStatementString to sStmt
28551>>>>>>>                Send Cursor_Wait of Cursor_Control
28552>>>>>>>                Send SqlExecDirect of hoStmt sStmt
28553>>>>>>>                Send Cursor_Ready of Cursor_Control
28554>>>>>>>
28554>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
28556>>>>>>>                    Move hoError to Error_Object_Id
28557>>>>>>>                End
28557>>>>>>>>
28557>>>>>>>
28557>>>>>>>                Move 0 to iMsgs
28558>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
28558>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
28558>>>>>>>                If (bMertechDriver = False) Begin
28560>>>>>>>                    Move Err to iErr
28561>>>>>>>                    Move LastErr to iLastErr
28562>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
28563>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
28564>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
28565>>>>>>>                    Send _SqlColumnInfo hoStmt
28566>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
28567>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28568>>>>>>>                    Repeat
28568>>>>>>>>
28568>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
28569>>>>>>>                        If (iFetchResult <> 0) Begin
28571>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
28572>>>>>>>                        End
28572>>>>>>>>
28572>>>>>>>                    Until (iFetchResult = 0)
28574>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
28575>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
28576>>>>>>>                    Move iErr to Err
28577>>>>>>>                    Move iLastErr to LastErr
28578>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
28579>>>>>>>                End
28579>>>>>>>>
28579>>>>>>>
28579>>>>>>>                Set piRows    to iRows
28580>>>>>>>                Set piRowType to iRowType
28581>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
28582>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
28583>>>>>>>
28583>>>>>>>                If (iMsgs <> 0) Begin
28585>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
28587>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28588>>>>>>>                    End
28588>>>>>>>>
28588>>>>>>>                    For i from 1 to iMsgs
28594>>>>>>>>
28594>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
28595>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
28596>>>>>>>                        If (bShowProgress = True) Begin
28598>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
28600>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
28601>>>>>>>                            End
28601>>>>>>>>
28601>>>>>>>                            Else Begin
28602>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
28604>>>>>>>                            End
28604>>>>>>>>
28604>>>>>>>                        End
28604>>>>>>>>
28604>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
28605>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
28606>>>>>>>                    Loop
28607>>>>>>>>
28607>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
28609>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28610>>>>>>>                    End
28610>>>>>>>>
28610>>>>>>>                    Set paQueryMessages to sMsg
28611>>>>>>>                End
28611>>>>>>>>
28611>>>>>>>                Else Begin
28612>>>>>>>                    If (bShowProgress = True) Begin
28614>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
28615>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
28617>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
28618>>>>>>>                            Decrement iMsgs
28619>>>>>>>                            For i from 0 to iMsgs
28625>>>>>>>>
28625>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
28628>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
28631>>>>>>>                            Loop
28632>>>>>>>>
28632>>>>>>>                        End
28632>>>>>>>>
28632>>>>>>>                    End
28632>>>>>>>>
28632>>>>>>>                End
28632>>>>>>>>
28632>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
28633>>>>>>>            End
28633>>>>>>>>
28633>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
28634>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
28635>>>>>>>            Set ptsQueryExec to tsQuery
28636>>>>>>>            Set ptsFetchResults to tsFetch
28637>>>>>>>            Send SqlClose of hoStmt
28638>>>>>>>        End
28638>>>>>>>>
28638>>>>>>>
28638>>>>>>>        Send SqlDisconnect of hoSQLConnect
28639>>>>>>>    End_Procedure
28640>>>>>>>
28640>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
28640>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
28640>>>>>>>    // Returns False if no error occured.
28640>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
28642>>>>>>>        Boolean bOK bShowProgress
28642>>>>>>>        tSQLScriptArray SQLScriptArray
28642>>>>>>>        tSQLScriptArray SQLScriptArray
28642>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
28642>>>>>>>        TimeSpan tsTotalTime
28642>>>>>>>
28642>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
28643>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
28644>>>>>>>        If (SQLScriptArray.bError = True) Begin
28646>>>>>>>            Function_Return False
28647>>>>>>>        End
28647>>>>>>>>
28647>>>>>>>
28647>>>>>>>        If (num_arguments > 3) Begin
28649>>>>>>>            Move bShowProgr to bShowProgress
28650>>>>>>>        End
28650>>>>>>>>
28650>>>>>>>
28650>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28651>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
28652>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
28653>>>>>>>
28653>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
28654>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
28655>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
28656>>>>>>>
28656>>>>>>>        Function_Return bOK
28657>>>>>>>    End_Function
28658>>>>>>>
28658>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
28658>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
28658>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
28658>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
28660>>>>>>>        Integer iChannel iArgumentSize iCount
28660>>>>>>>        Number nByteCount
28660>>>>>>>        String sSQLScript
28660>>>>>>>        tSQLScriptArray SqlScriptArray
28660>>>>>>>        tSQLScriptArray SqlScriptArray
28660>>>>>>>        UChar[] uCharData
28661>>>>>>>
28661>>>>>>>        Move False to Err
28662>>>>>>>        Get Seq_New_Channel to iChannel
28663>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28665>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
28666>>>>>>>>
28666>>>>>>>            Move True to SqlScriptArray.bError
28667>>>>>>>            Function_Return SqlScriptArray
28668>>>>>>>        End
28668>>>>>>>>
28668>>>>>>>
28668>>>>>>>        // First decide the size of the script
28668>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
28670>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
28672>>>>>>>        Close_Input channel iChannel
28674>>>>>>>
28674>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
28675>>>>>>>        If (nByteCount  < 1) Begin
28677>>>>>>>            Send Seq_Release_Channel iChannel
28678>>>>>>>            Move True to SqlScriptArray.bError
28679>>>>>>>            Function_Return SqlScriptArray
28680>>>>>>>        End
28680>>>>>>>>
28680>>>>>>>
28680>>>>>>>        // If necessary change the string argument_size
28680>>>>>>>        // Read the script file from memory line-by-line
28680>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
28682>>>>>>>            Move 0 to iCount
28683>>>>>>>            Repeat
28683>>>>>>>>
28683>>>>>>>                Readln channel iChannel sSQLScript
28685>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
28686>>>>>>>                Increment iCount
28687>>>>>>>            Until (SeqEof = True)
28689>>>>>>>        Close_Input channel iChannel
28691>>>>>>>        Send Seq_Release_Channel iChannel
28692>>>>>>>
28692>>>>>>>        // Finally "sanitize" the script by removing all comments.
28692>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
28693>>>>>>>
28693>>>>>>>        Function_Return SqlScriptArray
28694>>>>>>>    End_Function
28695>>>>>>>
28695>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
28697>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
28697>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
28697>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
28697>>>>>>>        String[] sMsg aSQLQueryMessages
28699>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
28699>>>>>>>        TimeSpan tsQuery
28699>>>>>>>        tSqlErrorArray aSqlErrorArray
28699>>>>>>>        tSqlErrorArray aSqlErrorArray
28699>>>>>>>        tSQLConnection SQLConnection
28699>>>>>>>        tSQLConnection SQLConnection
28699>>>>>>>        Boolean bMertechDriver bShowProgress
28699>>>>>>>
28699>>>>>>>        If (num_arguments > 4) Begin
28701>>>>>>>            Move bShowProgr to bShowProgress
28702>>>>>>>        End
28702>>>>>>>>
28702>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28703>>>>>>>        If (bMertechDriver = False) Begin
28705>>>>>>>            Get phoSQLManager to hoSql
28706>>>>>>>        End
28706>>>>>>>>
28706>>>>>>>        Else Begin
28707>>>>>>>            Get _MertechSQLManagerHandle to hoSql
28708>>>>>>>        End
28708>>>>>>>>
28708>>>>>>>
28708>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
28709>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
28709>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
28709>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
28709>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
28709>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
28709>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
28709>>>>>>>        Get piChunkMax to iChunkMax
28710>>>>>>>        Move 0 to iChunkCounter
28711>>>>>>>        Move "" to sStmt
28712>>>>>>>
28712>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
28713>>>>>>>        Move (Character(13) + Character(10)) to sCR
28714>>>>>>>
28714>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28715>>>>>>>
28715>>>>>>>        If (bMertechDriver = True) Begin
28717>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
28718>>>>>>>        End
28718>>>>>>>>
28718>>>>>>>        If (bMertechDriver = False) Begin
28720>>>>>>>            Get phoSQLManager  to hoSQL
28721>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
28723>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
28725>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
28726>>>>>>>                    If (iPos > 0) Begin
28728>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
28729>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
28730>>>>>>>                    End
28730>>>>>>>>
28730>>>>>>>                End
28730>>>>>>>>
28730>>>>>>>            End
28730>>>>>>>>
28730>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
28731>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
28732>>>>>>>        End
28732>>>>>>>>
28732>>>>>>>
28732>>>>>>>        If (hoSQLConnect <> 0) Begin
28734>>>>>>>            Move False to Err
28735>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
28736>>>>>>>            If (hoStmt <> 0) Begin
28738>>>>>>>
28738>>>>>>>                // If the embedded resource should be written as a script file to disk:
28738>>>>>>>                If (bCreateScriptFile = True) Begin
28740>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
28741>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
28742>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
28743>>>>>>>                    Get Seq_New_Channel to iOut
28744>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28746>>>>>>>                        Direct_Output channel iOut sExportFile
28748>>>>>>>                    End
28748>>>>>>>>
28748>>>>>>>                End
28748>>>>>>>>
28748>>>>>>>
28748>>>>>>>                // Record starting date/time stamp
28748>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
28749>>>>>>>                // Turn on error handling if enabled
28749>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
28751>>>>>>>                    Set pbSqlError to False
28752>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
28753>>>>>>>                    Move Error_Object_Id to hoError
28754>>>>>>>                    Move Self to Error_Object_Id
28755>>>>>>>                End
28755>>>>>>>>
28755>>>>>>>
28755>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
28756>>>>>>>                Decrement iRows
28757>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
28759>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
28760>>>>>>>                End
28760>>>>>>>>
28760>>>>>>>
28760>>>>>>>                For iCount from 0 to iRows
28766>>>>>>>>
28766>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
28767>>>>>>>
28767>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
28769>>>>>>>                        If (sSQLVal <> "") Begin
28771>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
28772>>>>>>>                        End
28772>>>>>>>>
28772>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
28773>>>>>>>                    End
28773>>>>>>>>
28773>>>>>>>
28773>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
28773>>>>>>>                    // or if at the very end of the script.
28773>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
28775>>>>>>>
28775>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
28775>>>>>>>                        // instead of all in one go.
28775>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
28776>>>>>>>
28776>>>>>>>                        If (bCreateScriptFile = True) Begin
28778>>>>>>>                            Write channel iOut sStmt
28780>>>>>>>                        End
28780>>>>>>>>
28780>>>>>>>                        Move "" to sStmt
28781>>>>>>>                        Move 0 to iChunkCounter
28782>>>>>>>                    End
28782>>>>>>>>
28782>>>>>>>                    Increment iChunkCounter
28783>>>>>>>                Loop
28784>>>>>>>>
28784>>>>>>>
28784>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
28784>>>>>>>                //       so not used for now.
28784>>>>>>>                If (bMertechDriver = False) Begin
28786>>>>>>>                    Repeat
28786>>>>>>>>
28786>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
28788>>>>>>>                            Move hoError to Error_Object_Id
28789>>>>>>>                        End
28789>>>>>>>>
28789>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
28790>>>>>>>
28790>>>>>>>                        Send _SqlColumnInfo hoStmt
28791>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
28792>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
28793>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
28794>>>>>>>                        Set piRows    to iRows
28795>>>>>>>                        Set piRowType to iRowType
28796>>>>>>>
28796>>>>>>>                        If (iMsgs <> 0) Begin
28798>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
28800>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28801>>>>>>>                            End
28801>>>>>>>>
28801>>>>>>>                            For i from 1 to iMsgs
28807>>>>>>>>
28807>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
28808>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
28809>>>>>>>                                If (bShowProgress = True) Begin
28811>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
28813>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
28814>>>>>>>                                    End
28814>>>>>>>>
28814>>>>>>>                                    Else Begin
28815>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
28817>>>>>>>                                    End
28817>>>>>>>>
28817>>>>>>>                                End
28817>>>>>>>>
28817>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
28818>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
28819>>>>>>>                            Loop
28820>>>>>>>>
28820>>>>>>>
28820>>>>>>>
28820>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
28822>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28823>>>>>>>                            End
28823>>>>>>>>
28823>>>>>>>                            Set paQueryMessages to sMsg
28824>>>>>>>                        End
28824>>>>>>>>
28824>>>>>>>
28824>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
28825>>>>>>>                    Until (iNextSet = 0)
28827>>>>>>>                End
28827>>>>>>>>
28827>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
28828>>>>>>>            End
28828>>>>>>>>
28828>>>>>>>
28828>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
28829>>>>>>>            Set ptsQueryExec to tsQuery
28830>>>>>>>            Send SqlClose of hoStmt
28831>>>>>>>
28831>>>>>>>            If (bCreateScriptFile = True) Begin
28833>>>>>>>                Close_Output channel iOut
28835>>>>>>>                Send Seq_Release_Channel iOut
28836>>>>>>>            End
28836>>>>>>>>
28836>>>>>>>        End
28836>>>>>>>>
28836>>>>>>>        Send SqlDisconnect of hoSQLConnect
28837>>>>>>>
28837>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
28838>>>>>>>    End_Function
28839>>>>>>>
28839>>>>>>>    // * Dummy function for the Studio's Code Explorer *
28839>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
28841>>>>>>>        Function_Return False
28842>>>>>>>    End_Function
28843>>>>>>>
28843>>>>>>>    // Does three things with auxilirary files;
28843>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
28843>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
28843>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
28843>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
28845>>>>>>>        String sDataPath sDDSrcPath sDriverID
28845>>>>>>>        Boolean bOK bExists bMertechDriver
28845>>>>>>>        Integer iCount iCh iPos
28845>>>>>>>
28845>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
28845>>>>>>>        If (sTableName contains ".") Begin
28847>>>>>>>            Move (Pos(".", sTableName)) to iPos
28848>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
28849>>>>>>>        End
28849>>>>>>>>
28849>>>>>>>
28849>>>>>>>        Get psDriverID to sDriverID
28850>>>>>>>        Get psDataPathFirstPart to sDataPath
28851>>>>>>>        Get vFolderExists sDataPath to bOK
28852>>>>>>>        If (bOK = False) Begin
28854>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
28855>>>>>>>>
28855>>>>>>>            Function_Return False
28856>>>>>>>        End
28856>>>>>>>>
28856>>>>>>>
28856>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28857>>>>>>>        // First delete the cache file:
28857>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28858>>>>>>>
28858>>>>>>>        Get Seq_New_Channel to iCh
28859>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28861>>>>>>>            Function_Return False
28862>>>>>>>        End
28862>>>>>>>>
28862>>>>>>>
28862>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
28863>>>>>>>        If (bExists = False) Begin
28865>>>>>>>            Function_Return False
28866>>>>>>>        End
28866>>>>>>>>
28866>>>>>>>
28866>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
28867>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
28867>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
28868>>>>>>>
28868>>>>>>>        // If in development environment; output new .fd file:
28868>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
28869>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
28870>>>>>>>        If (iCount > 1) Begin
28872>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
28873>>>>>>>        End
28873>>>>>>>>
28873>>>>>>>        Get vFolderExists sDDSrcPath to bExists
28874>>>>>>>        If (bExists = True) Begin
28876>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
28877>>>>>>>            Move False to Err
28878>>>>>>>            Get AutoConnectionIDLogin to bOK
28879>>>>>>>            If (hTable <> 0) Begin
28881>>>>>>>                Open hTable
28883>>>>>>>            End
28883>>>>>>>>
28883>>>>>>>            Else Begin
28884>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
28885>>>>>>>            End
28885>>>>>>>>
28885>>>>>>>
28885>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
28888>>>>>>>            If (bOK = True) Begin
28890>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
28892>>>>>>>            End
28892>>>>>>>>
28892>>>>>>>            If (Err = True) Begin
28894>>>>>>>                Move False to bOK
28895>>>>>>>            End
28895>>>>>>>>
28895>>>>>>>        End
28895>>>>>>>>
28895>>>>>>>
28895>>>>>>>        Function_Return (bOK = True)
28896>>>>>>>    End_Function
28897>>>>>>>
28897>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
28899>>>>>>>        Integer iChIn iChOut // iCount
28899>>>>>>>        Boolean bExists
28899>>>>>>>        String sExistingColumn
28899>>>>>>>
28899>>>>>>>        Move False to bExists
28900>>>>>>>        Get Seq_New_Channel to iChIn
28901>>>>>>>        Get Seq_New_Channel to iChOut
28902>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28904>>>>>>>            Function_Return True
28905>>>>>>>        End
28905>>>>>>>>
28905>>>>>>>
28905>>>>>>>        Move False to Err
28906>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
28906>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
28908>>>>>>>        While (not(SeqEof))
28912>>>>>>>            Readln channel iChIn sExistingColumn
28914>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
28916>>>>>>>                Move True to bExists
28917>>>>>>>            End
28917>>>>>>>>
28917>>>>>>>            If (Trim(sExistingColumn) = "") Begin
28919>>>>>>>                Move True to SeqEof
28920>>>>>>>            End
28920>>>>>>>>
28920>>>>>>>        Loop
28921>>>>>>>>
28921>>>>>>>        Close_Input channel iChIn
28923>>>>>>>        Send Seq_Release_Channel iChIn
28924>>>>>>>
28924>>>>>>>        If (bExists = False) Begin
28926>>>>>>>            Append_Output channel iChOut sFullTAGFileName
28928>>>>>>>            Writeln channel iChOut sColumnName
28931>>>>>>>            Close_Output channel iChOut
28933>>>>>>>            Send Seq_Release_Channel iChOut
28934>>>>>>>        End
28934>>>>>>>>
28934>>>>>>>
28934>>>>>>>        Function_Return (Err = False)
28935>>>>>>>    End_Function
28936>>>>>>>
28936>>>>>>>    // Message for changing .int files to use connection ID's
28936>>>>>>>    //
28936>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
28936>>>>>>>    // OR changes an existing connection id to a new id.
28936>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
28936>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
28936>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
28938>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
28938>>>>>>>        String[] sFilesData
28939>>>>>>>        Boolean bOK bCancel
28939>>>>>>>        Integer iSize iCount
28939>>>>>>>
28939>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
28940>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
28941>>>>>>>        If (iSize = 0) Begin
28943>>>>>>>            If (ghoStatusPanel <> 0) Begin
28945>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
28947>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
28948>>>>>>>                End
28948>>>>>>>>
28948>>>>>>>            End
28948>>>>>>>>
28948>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
28949>>>>>>>            Procedure_Return
28950>>>>>>>        End
28950>>>>>>>>
28950>>>>>>>
28950>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
28951>>>>>>>        Get vFolderFormat sDataPath to sDataPath
28952>>>>>>>        Decrement iSize
28953>>>>>>>        For iCount from 0 to iSize
28959>>>>>>>>
28959>>>>>>>            Move sFilesData[iCount] to sFileName
28960>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
28960>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
28961>>>>>>>            If (ghoStatusPanel <> 0) Begin
28963>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
28965>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
28966>>>>>>>                    If (bCancel = True) Begin
28968>>>>>>>                        Send Deactivate of ghoStatusPanel
28969>>>>>>>                        Procedure_Return
28970>>>>>>>                    End
28970>>>>>>>>
28970>>>>>>>                End
28970>>>>>>>>
28970>>>>>>>            End
28970>>>>>>>>
28970>>>>>>>        Loop
28971>>>>>>>>
28971>>>>>>>
28971>>>>>>>        Get psDriverID to sDriverID
28972>>>>>>>
28972>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
28972>>>>>>>        Move "" to sFileName
28973>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
28975>>>>>>>            Move "MSSQLDrv.int" to sFileName
28976>>>>>>>        End
28976>>>>>>>>
28976>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
28978>>>>>>>            Move "DB2_Drv.int" to sFileName
28979>>>>>>>        End
28979>>>>>>>>
28979>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
28981>>>>>>>            Move "ODBC_Drv.int" to sFileName
28982>>>>>>>        End
28982>>>>>>>>
28982>>>>>>>        If (sFileName <> "") Begin
28984>>>>>>>            Move "" to sDriverFile
28985>>>>>>>            Get_File_Path sFileName to sDriverFile
28986>>>>>>>            If (sDriverFile <> "") Begin
28988>>>>>>>                Get psConnectionString to sConnectionString
28989>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
28990>>>>>>>            End
28990>>>>>>>>
28990>>>>>>>        End
28990>>>>>>>>
28990>>>>>>>    End_Procedure
28991>>>>>>>
28991>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
28991>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
28993>>>>>>>        String[] sDatabaseArray
28994>>>>>>>        String sVal sServer sDriverID
28994>>>>>>>        Integer iCount iSize iPos
28994>>>>>>>        Boolean bExists
28994>>>>>>>        tSQLConnection SQLConnection
28994>>>>>>>        tSQLConnection SQLConnection
28994>>>>>>>
28994>>>>>>>        Move False to bExists
28995>>>>>>>        Get psDriverID to sDriverID
28996>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
28996>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
28998>>>>>>>            Function_Return bExists
28999>>>>>>>        End
28999>>>>>>>>
28999>>>>>>>
28999>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
29000>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
29002>>>>>>>            Function_Return False
29003>>>>>>>        End
29003>>>>>>>>
29003>>>>>>>
29003>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
29004>>>>>>>        Move SQLConnection.sServer to sServer
29005>>>>>>>
29005>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
29005>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
29007>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
29008>>>>>>>        End
29008>>>>>>>>
29008>>>>>>>        Else If (sServer contains "/") Begin
29011>>>>>>>            Move (Pos("/", sServer)) to iPos
29012>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
29013>>>>>>>        End
29013>>>>>>>>
29013>>>>>>>
29013>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
29014>>>>>>>        Decrement iSize
29015>>>>>>>        For iCount from 0 to iSize
29021>>>>>>>>
29021>>>>>>>            Move sDatabaseArray[iCount] to sVal
29022>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
29024>>>>>>>                Move True to bExists
29025>>>>>>>                If (bExists = True) Begin
29027>>>>>>>                    Move iSize to iCount // We're done.
29028>>>>>>>                End
29028>>>>>>>>
29028>>>>>>>            End
29028>>>>>>>>
29028>>>>>>>        Loop
29029>>>>>>>>
29029>>>>>>>
29029>>>>>>>        Function_Return bExists
29030>>>>>>>    End_Function
29031>>>>>>>
29031>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
29031>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
29033>>>>>>>        String sDatabase sSchema sTableName sVal
29033>>>>>>>        Boolean bExists
29033>>>>>>>        String[] sTablesArray
29034>>>>>>>        Integer iSize iCount
29034>>>>>>>
29034>>>>>>>        Move False to bExists
29035>>>>>>>        Get UtilTableHandleToString hTable to sTableName
29036>>>>>>>        Get psDatabase to sDatabase
29037>>>>>>>        Get psSchema   to sSchema
29038>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
29039>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
29040>>>>>>>        Decrement iSize
29041>>>>>>>        For iCount from 0 to iSize
29047>>>>>>>>
29047>>>>>>>            Move sTablesArray[iCount] to sVal
29048>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
29050>>>>>>>                Move True to bExists
29051>>>>>>>                Move iSize to iCount // We're done!
29052>>>>>>>            End
29052>>>>>>>>
29052>>>>>>>        Loop
29053>>>>>>>>
29053>>>>>>>
29053>>>>>>>        Function_Return bExists
29054>>>>>>>    End_Function
29055>>>>>>>
29055>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
29055>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
29057>>>>>>>        String sDatabase sSchema sVal
29057>>>>>>>        Boolean bExists
29057>>>>>>>        String[] sTablesArray
29058>>>>>>>        Integer iSize iCount
29058>>>>>>>
29058>>>>>>>        Move False to bExists
29059>>>>>>>        Get psDatabase to sDatabase
29060>>>>>>>        Get psSchema   to sSchema
29061>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
29062>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
29063>>>>>>>        Decrement iSize
29064>>>>>>>        For iCount from 0 to iSize
29070>>>>>>>>
29070>>>>>>>            Move sTablesArray[iCount] to sVal
29071>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
29073>>>>>>>                Move True to bExists
29074>>>>>>>                Move iSize to iCount // We're done!
29075>>>>>>>            End
29075>>>>>>>>
29075>>>>>>>        Loop
29076>>>>>>>>
29076>>>>>>>
29076>>>>>>>        Function_Return bExists
29077>>>>>>>    End_Function
29078>>>>>>>
29078>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
29080>>>>>>>        String sVal sTableSpelledCorrectly
29080>>>>>>>        Boolean bExists
29080>>>>>>>        String[] sTablesArray
29081>>>>>>>        Integer iSize iCount
29081>>>>>>>
29081>>>>>>>        Move False to bExists
29082>>>>>>>        Move sTableName to sTableSpelledCorrectly
29083>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
29084>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
29085>>>>>>>        Decrement iSize
29086>>>>>>>        For iCount from 0 to iSize
29092>>>>>>>>
29092>>>>>>>            Move sTablesArray[iCount] to sVal
29093>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
29095>>>>>>>                Move sVal to sTableSpelledCorrectly
29096>>>>>>>                Move iSize to iCount // We're done!
29097>>>>>>>            End
29097>>>>>>>>
29097>>>>>>>        Loop
29098>>>>>>>>
29098>>>>>>>
29098>>>>>>>        Function_Return sTableSpelledCorrectly
29099>>>>>>>    End_Function
29100>>>>>>>
29100>>>>>>>    // ToDo: This index name function needs to be finished...
29100>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
29102>>>>>>>        String sSchema sTableName sDriverID
29102>>>>>>>        Boolean bExists
29102>>>>>>>
29102>>>>>>>        Get psDriverID to sDriverID
29103>>>>>>>        Get psSchema to sSchema
29104>>>>>>>        Get UtilTableHandleToString hTable to sTableName
29105>>>>>>>
29105>>>>>>>        Function_Return bExists
29106>>>>>>>    End_Function
29107>>>>>>>
29107>>>>>>>    // Checks if a column/field name exists in a SQL table definition
29107>>>>>>>    // Returns True if it does
29107>>>>>>>    // Sample:
29107>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
29107>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
29109>>>>>>>        Integer iNumColumns iColumn
29109>>>>>>>        String sColumn sDriverID
29109>>>>>>>        String[] sColumnsArray
29110>>>>>>>        Boolean bExists bOK
29110>>>>>>>
29110>>>>>>>        Move False to bExists
29111>>>>>>>        Get AutoConnectionIDLogin to bOK
29112>>>>>>>        Get psDriverID to sDriverID
29113>>>>>>>
29113>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
29114>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
29115>>>>>>>        Decrement iNumColumns
29116>>>>>>>        For iColumn from 0 to iNumColumns
29122>>>>>>>>
29122>>>>>>>            Move sColumnsArray[iColumn] to sColumn
29123>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
29125>>>>>>>                Move True to bExists
29126>>>>>>>                Move iNumColumns to iColumn // We're out of here
29127>>>>>>>            End
29127>>>>>>>>
29127>>>>>>>        Loop
29128>>>>>>>>
29128>>>>>>>
29128>>>>>>>        Function_Return bExists
29129>>>>>>>    End_Function
29130>>>>>>>
29130>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
29132>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
29132>>>>>>>        Boolean bOpened bOK
29132>>>>>>>        String sColumnName sNativeTypeName
29132>>>>>>>
29132>>>>>>>        Get AutoConnectionIDLogin to bOK
29133>>>>>>>        Get OpenTableExclusive hTable to bOK
29134>>>>>>>        If (bOK = False) Begin
29136>>>>>>>            Function_Return False
29137>>>>>>>        End
29137>>>>>>>>
29137>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
29140>>>>>>>        If (bOpened = False) Begin
29142>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
29143>>>>>>>>
29143>>>>>>>            Function_Return False
29144>>>>>>>        End
29144>>>>>>>>
29144>>>>>>>
29144>>>>>>>        Move False to Err
29145>>>>>>>
29145>>>>>>>        Structure_Start hTable
29146>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
29149>>>>>>>
29149>>>>>>>            For iColumn from 1 to iNumColumns
29155>>>>>>>>
29155>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
29158>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
29161>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
29164>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
29167>>>>>>>
29167>>>>>>>                Case Begin
29167>>>>>>>                    Case (iDFType = DF_DATE)
29169>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
29171>>>>>>>                            // Convert datetime to date
29171>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
29174>>>>>>>                        End
29174>>>>>>>>
29174>>>>>>>                        Case Break
29175>>>>>>>                    Case (iDFType = DF_DATETIME)
29178>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
29180>>>>>>>                            // Convert datetime to datetime2
29180>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
29183>>>>>>>                        End
29183>>>>>>>>
29183>>>>>>>                        Case Break
29184>>>>>>>                    Case (iDFType = DF_ASCII)
29187>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
29189>>>>>>>                            // Convert char to varchar
29189>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
29192>>>>>>>                        End
29192>>>>>>>>
29192>>>>>>>                        Case Break
29193>>>>>>>                    Case (iDFType = DF_TEXT)
29196>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
29198>>>>>>>                            // Convert text to varchar(max)
29198>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
29201>>>>>>>                        End
29201>>>>>>>>
29201>>>>>>>                        Case Break
29202>>>>>>>                    Case (iDFType = DF_BINARY)
29205>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
29207>>>>>>>                            // Convert image to varbinary(max)
29207>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
29210>>>>>>>                        End
29210>>>>>>>>
29210>>>>>>>                        Case Break
29211>>>>>>>                Case End
29211>>>>>>>            Loop
29212>>>>>>>>
29212>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
29213>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
29215>>>>>>>
29215>>>>>>>        Set Action_Text of ghoStatusPanel to ""
29216>>>>>>>        Function_Return (Err = False)
29217>>>>>>>    End_Function
29218>>>>>>>
29218>>>>>>>
29218>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
29218>>>>>>>    // the DbUpdateVersion database revision in.
29218>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
29218>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
29218>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
29220>>>>>>>        Boolean bOK bOpened
29220>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
29220>>>>>>>
29220>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
29223>>>>>>>        Get _TableNameOnly sTableName to sTableName
29224>>>>>>>        If (sTableName = "") Begin
29226>>>>>>>            Function_Return False
29227>>>>>>>        End
29227>>>>>>>>
29227>>>>>>>
29227>>>>>>>        // This just creates the table and a "dummy" column.
29227>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
29228>>>>>>>        If (bOK = False) Begin
29230>>>>>>>            Function_Return False
29231>>>>>>>        End
29231>>>>>>>>
29231>>>>>>>
29231>>>>>>>        Close hTable
29232>>>>>>>        Move False to Err
29233>>>>>>>
29233>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
29234>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
29235>>>>>>>        Move "Decimal" to sDataType
29236>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
29237>>>>>>>
29237>>>>>>>        // Adds the "sColumnName" passed to the function
29237>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
29238>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
29239>>>>>>>
29239>>>>>>>        // Now we can delete the dummy column:
29239>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
29240>>>>>>>
29240>>>>>>>        // Finally, we attach to the newly created table.
29240>>>>>>>        If (Err = False) Begin
29242>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
29243>>>>>>>        End
29243>>>>>>>>
29243>>>>>>>        Open hTable
29245>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
29248>>>>>>>
29248>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
29249>>>>>>>    End_Function
29250>>>>>>>
29250>>>>>>>    // The table must already exist in the filelist for this function to work.
29250>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
29250>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
29252>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
29252>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
29252>>>>>>>        String[] sIndexArray
29253>>>>>>>        Integer iCount iCh iSize
29253>>>>>>>
29253>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
29254>>>>>>>        Get psConnectionString to sConnectionString
29255>>>>>>>
29255>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
29256>>>>>>>        If (bANSI = False) Begin
29258>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
29259>>>>>>>        End
29259>>>>>>>>
29259>>>>>>>
29259>>>>>>>        Get psDataPathFirstPart to sDataPath
29260>>>>>>>        Get vFolderExists sDataPath to bOK
29261>>>>>>>        If (bOK = False) Begin
29263>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
29264>>>>>>>>
29264>>>>>>>            Function_Return False
29265>>>>>>>        End
29265>>>>>>>>
29265>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29266>>>>>>>
29266>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29269>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
29272>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
29273>>>>>>>        Move sLogicalName  to sPhysicalFileName
29274>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
29275>>>>>>>
29275>>>>>>>        Get IsMertechDriver sDriverID to bMertech
29276>>>>>>>        If (bMertech = True) Begin
29278>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
29278>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
29278>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
29278>>>>>>>            Function_Return (bOK = True)
29279>>>>>>>        End
29279>>>>>>>>
29279>>>>>>>
29279>>>>>>>        Get psSchema hTable to sSchemaName
29280>>>>>>>        If (sSchemaName = "") Begin
29282>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
29283>>>>>>>        End
29283>>>>>>>>
29283>>>>>>>
29283>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
29283>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
29284>>>>>>>        If (bExists = True) Begin
29286>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
29287>>>>>>>        End
29287>>>>>>>>
29287>>>>>>>
29287>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
29288>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
29289>>>>>>>
29289>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
29290>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
29295>>>>>>>            If (bUseConnectionID = True) Begin
29297>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
29304>>>>>>>            End
29304>>>>>>>>
29304>>>>>>>            Else Begin
29305>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
29312>>>>>>>            End
29312>>>>>>>>
29312>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
29317>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
29322>>>>>>>            // There seems to be a new order how these are set from DF19.
29322>>>>>>>            If (bSysFile = True) Begin
29324>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
29329>>>>>>>            End
29329>>>>>>>>
29329>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
29334>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
29339>>>>>>>            If (bSysFile = True) Begin
29341>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
29346>>>>>>>            End
29346>>>>>>>>
29346>>>>>>>
29346>>>>>>>            If (bSysFile = False) Begin
29348>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
29349>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
29350>>>>>>>                If (iSize > 0) Begin
29352>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
29355>>>>>>>                    Writeln channel iCh // Just an empty line
29357>>>>>>>                End
29357>>>>>>>>
29357>>>>>>>                Decrement iSize
29358>>>>>>>                For iCount from 0 to iSize
29364>>>>>>>>
29364>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
29367>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
29370>>>>>>>                    Writeln channel iCh
29372>>>>>>>                Loop
29373>>>>>>>>
29373>>>>>>>            End
29373>>>>>>>>
29373>>>>>>>        Send Seq_Close_Channel iCh
29374>>>>>>>
29374>>>>>>>        // Wait a sec for Windows to finish writing the file:
29374>>>>>>>        Sleep 1
29375>>>>>>>
29375>>>>>>>        Function_Return (bOK = True)
29376>>>>>>>    End_Function
29377>>>>>>>
29377>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
29377>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
29377>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
29377>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
29377>>>>>>>    // column types.
29377>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
29379>>>>>>>        Handle hDatabase
29379>>>>>>>        Integer iDriver iServers iCount
29379>>>>>>>        String sValue
29379>>>>>>>
29379>>>>>>>        If (sServer = "") Begin
29381>>>>>>>            Function_Return 0
29382>>>>>>>        End
29382>>>>>>>>
29382>>>>>>>
29382>>>>>>>        Get DriverIndex sDriverID to iDriver
29383>>>>>>>        If (iDriver = 0) Begin
29385>>>>>>>            Function_Return 0
29386>>>>>>>        End
29386>>>>>>>>
29386>>>>>>>
29386>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
29389>>>>>>>        For iCount from 1 to iServers
29395>>>>>>>>
29395>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
29398>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
29400>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
29403>>>>>>>            End
29403>>>>>>>>
29403>>>>>>>        Loop
29404>>>>>>>>
29404>>>>>>>
29404>>>>>>>        Function_Return hDatabase
29405>>>>>>>    End_Function
29406>>>>>>>
29406>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
29406>>>>>>>//        String sRootName
29406>>>>>>>//        Boolean bOK
29406>>>>>>>//
29406>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29406>>>>>>>//        Move (sRootName contains sDriverID) to bOK
29406>>>>>>>//
29406>>>>>>>//        Function_Return bOK
29406>>>>>>>//    End_Function
29406>>>>>>>
29406>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
29406>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
29406>>>>>>>//        Integer iDbType
29406>>>>>>>//        Boolean bOK
29406>>>>>>>//
29406>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
29406>>>>>>>//        If (bOK = True) Begin
29406>>>>>>>//            Function_Return False
29406>>>>>>>//        End
29406>>>>>>>//
29406>>>>>>>//        Get psDriverID to sDriverID
29406>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29406>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
29406>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
29406>>>>>>>//
29406>>>>>>>//        Get psDriverID to sDriverID
29406>>>>>>>//        Get piDbType   to iDbType
29406>>>>>>>//        Get psSchema   to sSchema
29406>>>>>>>//        If (sSchema = "") Begin
29406>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
29406>>>>>>>//        End
29406>>>>>>>//
29406>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
29406>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
29406>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
29406>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
29406>>>>>>>//            End
29406>>>>>>>//            Else Begin
29406>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
29406>>>>>>>//            End
29406>>>>>>>//        End
29406>>>>>>>//
29406>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29406>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
29406>>>>>>>//
29406>>>>>>>//        Function_Return True
29406>>>>>>>//    End_Function
29406>>>>>>>
29406>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
29406>>>>>>>    // from the passed filelist.
29406>>>>>>>    // Returns the number of tables affected.
29406>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
29408>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
29408>>>>>>>        Integer iRetval
29408>>>>>>>        Handle hTable
29408>>>>>>>
29408>>>>>>>        // We first save the current filelist as the passed filelist name
29408>>>>>>>        // may come from another workspace, to restore it when we're ready.
29408>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
29411>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
29414>>>>>>>        Move 0 to hTable
29415>>>>>>>        Move 0 to iRetval
29416>>>>>>>
29416>>>>>>>        Repeat
29416>>>>>>>>
29416>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
29419>>>>>>>            If (hTable <> 0) Begin
29421>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29424>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
29427>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
29430>>>>>>>                Move (Uppercase(sRootName)) to sVal
29431>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
29433>>>>>>>                    // Prefixes:
29433>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
29434>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
29435>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
29436>>>>>>>                    // Suffixes:
29436>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
29437>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
29438>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
29439>>>>>>>
29439>>>>>>>                    // Change Filelist entry:
29439>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
29442>>>>>>>
29442>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
29443>>>>>>>                    If (sVal contains "dbo.") Begin
29445>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
29446>>>>>>>
29446>>>>>>>                        // Change Filelist entry:
29446>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
29449>>>>>>>                    End
29449>>>>>>>>
29449>>>>>>>                    Increment iRetval
29450>>>>>>>                End
29450>>>>>>>>
29450>>>>>>>            End
29450>>>>>>>>
29450>>>>>>>        Until (hTable = 0)
29452>>>>>>>
29452>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
29455>>>>>>>
29455>>>>>>>        Function_Return iRetval
29456>>>>>>>    End_Function
29457>>>>>>>
29457>>>>>>>    // To open all Sql based tables in Filelist.cfg
29457>>>>>>>    Procedure SqlUtilOpenAllTables
29459>>>>>>>        Handle hTable
29459>>>>>>>        String sRoot sDriverID
29459>>>>>>>        Boolean bOK
29459>>>>>>>
29459>>>>>>>        Move 0 to hTable
29460>>>>>>>        Move "" to sDriverID
29461>>>>>>>        Get AutoConnectionIDLogin to bOK
29462>>>>>>>
29462>>>>>>>        Repeat
29462>>>>>>>>
29462>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
29465>>>>>>>            If (hTable > 0) Begin
29467>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
29470>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
29472>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
29475>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
29477>>>>>>>                        Open hTable
29479>>>>>>>                    End
29479>>>>>>>>
29479>>>>>>>                End
29479>>>>>>>>
29479>>>>>>>            End
29479>>>>>>>>
29479>>>>>>>
29479>>>>>>>        Until (hTable = 0)
29481>>>>>>>    End_Procedure
29482>>>>>>>
29482>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
29482>>>>>>>//        String sRetval sDriverID
29482>>>>>>>//        String sTableName
29482>>>>>>>//        Integer iDbType iIndex
29482>>>>>>>//        Boolean bOK
29482>>>>>>>//
29482>>>>>>>//        Get psDriverID to sDriverID
29482>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
29482>>>>>>>//        If (hTable = 0 or bOK = False) Begin
29482>>>>>>>//            Function_Return ""
29482>>>>>>>//        End
29482>>>>>>>//
29482>>>>>>>//        Move False to Err
29482>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
29482>>>>>>>//        Get piDbType to iDbType
29482>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
29482>>>>>>>//        If (iIndex = -1) Begin
29482>>>>>>>//            Function_Return ""
29482>>>>>>>//        End
29482>>>>>>>//
29482>>>>>>>//        Function_Return sRetval
29482>>>>>>>//    End_Function
29482>>>>>>>
29482>>>>>>>    // Checks if the passed Table;
29482>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
29482>>>>>>>    // 2) It has an .int file.
29482>>>>>>>    // If both is True it should already be connected to SQL
29482>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
29484>>>>>>>        Boolean bExists bRootName
29484>>>>>>>        String sRootName sDataPath
29484>>>>>>>
29484>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29487>>>>>>>        Move (sRootName contains sDriverID) to bRootName
29488>>>>>>>
29488>>>>>>>        Get psDataPathFirstPart to sDataPath
29489>>>>>>>        Get vFolderExists sDataPath to bExists
29490>>>>>>>        If (bExists = False) Begin
29492>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
29492>>>>>>>            Function_Return False
29493>>>>>>>        End
29493>>>>>>>>
29493>>>>>>>
29493>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29494>>>>>>>        Get _TableNameOnly sRootName to sRootName
29495>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
29496>>>>>>>
29496>>>>>>>        Function_Return (bRootName = True and bExists = True)
29497>>>>>>>    End_Function
29498>>>>>>>
29498>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
29500>>>>>>>        Boolean bViewTableType bOpen bOK
29500>>>>>>>        Integer iTableCount iNumTables
29500>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
29500>>>>>>>        Handle hoCliHandler
29500>>>>>>>        tSQLConnection SQLConnection
29500>>>>>>>        tSQLConnection SQLConnection
29500>>>>>>>
29500>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
29503>>>>>>>        If (bOpen = False) Begin
29505>>>>>>>            Get AutoConnectionIDLogin to bOK
29506>>>>>>>            Open hTable
29508>>>>>>>        End
29508>>>>>>>>
29508>>>>>>>
29508>>>>>>>        Get pSQLConnection to SQLConnection
29509>>>>>>>        Get phoCLIHandler to hoCliHandler
29510>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
29511>>>>>>>
29511>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
29514>>>>>>>        Get _TableNameOnly sTableName to sTableName
29515>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
29518>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
29519>>>>>>>
29519>>>>>>>        For iTableCount from 1 to iNumTables
29525>>>>>>>>
29525>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
29526>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
29527>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
29529>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
29530>>>>>>>                Move iNumTables to iTableCount // We're done.
29531>>>>>>>            End
29531>>>>>>>>
29531>>>>>>>        Loop
29532>>>>>>>>
29532>>>>>>>
29532>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
29533>>>>>>>        If (bOpen = False) Begin
29535>>>>>>>            Close hTable
29536>>>>>>>        End
29536>>>>>>>>
29536>>>>>>>
29536>>>>>>>        Function_Return bViewTableType
29537>>>>>>>    End_Function
29538>>>>>>>
29538>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
29538>>>>>>>    //
29538>>>>>>>    // SQL utility function that returns a database type (string) constant
29538>>>>>>>    // corresponding to the passed iDbType.
29538>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
29540>>>>>>>        String sRetval
29540>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
29541>>>>>>>        Function_Return sRetval
29542>>>>>>>    End_Function
29543>>>>>>>
29543>>>>>>>    // SQL utility function that returns a database type constant (integer)
29543>>>>>>>    // corresponding to the passed sDbType string constant.
29543>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
29545>>>>>>>        Integer iRetval
29545>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
29546>>>>>>>        Function_Return iRetval
29547>>>>>>>    End_Function
29548>>>>>>>
29548>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
29548>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
29548>>>>>>>    // the SQL Connection program's grid.
29548>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
29550>>>>>>>        String sRetval
29550>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
29551>>>>>>>        Function_Return sRetval
29552>>>>>>>    End_Function
29553>>>>>>>
29553>>>>>>>    // Pass a driver name as a string and the function will return
29553>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
29553>>>>>>>    // quite work and always returns "MS SQL Server"
29553>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
29555>>>>>>>        Integer iRetval
29555>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
29556>>>>>>>        Function_Return iRetval
29557>>>>>>>    End_Function
29558>>>>>>>
29558>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
29558>>>>>>>    // that "fits" in the max allowed length for table names.
29558>>>>>>>    // Max number of characters allowed for table names;
29558>>>>>>>    // IBM DB2      = 128
29558>>>>>>>    // MS-SQL       = 128
29558>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
29558>>>>>>>    // MySQL        = 64
29558>>>>>>>    // PostgreSQL   = 64
29558>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
29560>>>>>>>        String sGUIDName
29560>>>>>>>        Integer iDbType iLength
29560>>>>>>>
29560>>>>>>>        Get piDbType to iDbType
29561>>>>>>>        Move (RandomHexUUID()) to sGUIDName
29562>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
29563>>>>>>>        Move (Length(sGUIDName)) to iLength
29564>>>>>>>
29564>>>>>>>        Case Begin
29564>>>>>>>            Case (iDbType = EN_DbTypeDB2)
29566>>>>>>>            If (iLength > 128) Begin
29568>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
29569>>>>>>>            End
29569>>>>>>>>
29569>>>>>>>            Case Break
29570>>>>>>>
29570>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
29573>>>>>>>            If (iLength > 128) Begin
29575>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
29576>>>>>>>            End
29576>>>>>>>>
29576>>>>>>>            Case Break
29577>>>>>>>
29577>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
29580>>>>>>>            If (iLength > 128) Begin
29582>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
29583>>>>>>>            End
29583>>>>>>>>
29583>>>>>>>            Case Break
29584>>>>>>>
29584>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
29587>>>>>>>            If (iLength > 64) Begin
29589>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
29590>>>>>>>            End
29590>>>>>>>>
29590>>>>>>>            Case Break
29591>>>>>>>
29591>>>>>>>            Case (iDbType = EN_DbTypePostgre)
29594>>>>>>>            If (iLength > 64) Begin
29596>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
29597>>>>>>>            End
29597>>>>>>>>
29597>>>>>>>        Case End
29597>>>>>>>
29597>>>>>>>        Function_Return sGUIDName
29598>>>>>>>    End_Function
29599>>>>>>>
29599>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
29599>>>>>>>    // Pass the memory resource file reference and the filename to be created,
29599>>>>>>>    // including full path.
29599>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
29601>>>>>>>        String sText
29601>>>>>>>        Integer iCh iSize iArgSize
29601>>>>>>>
29601>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
29602>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
29603>>>>>>>        Get_Channel_Size iCh to iSize
29604>>>>>>>        Read_Block channel iCh sText iSize
29606>>>>>>>        Send Seq_Close_Channel iCh
29607>>>>>>>
29607>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
29608>>>>>>>            Write channel iCh sText
29610>>>>>>>        Send Seq_Close_Channel iCh
29611>>>>>>>
29611>>>>>>>        // Wait for file to be written to disk.
29611>>>>>>>        Sleep 2
29612>>>>>>>    End_Procedure
29613>>>>>>>
29613>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
29615>>>>>>>        String sNotNull sRetval sDefaultValue
29615>>>>>>>        Boolean bOK
29615>>>>>>>
29615>>>>>>>        Get IsSQLDriver sDriverID to bOK
29616>>>>>>>        If (bOK = False) Begin
29618>>>>>>>            Function_Return ""
29619>>>>>>>        End
29619>>>>>>>>
29619>>>>>>>
29619>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
29620>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
29621>>>>>>>
29621>>>>>>>        Case Begin
29621>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
29623>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
29624>>>>>>>                Case Break
29625>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
29628>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
29629>>>>>>>                Case Break
29630>>>>>>>            Case (iDbType = EN_dbTypePostgre)
29633>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
29634>>>>>>>                Case Break
29635>>>>>>>            Case (iDbType = EN_dbTypeDB2)
29638>>>>>>>                Move (String(sNotNull))                                     to sRetval
29639>>>>>>>                Case Break
29640>>>>>>>
29640>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
29640>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
29640>>>>>>>            Case (iDbType = EN_dbTypeOracle)
29643>>>>>>>                Move  ""                                                    to sRetval
29644>>>>>>>                Case Break
29645>>>>>>>
29645>>>>>>>            Case Else
29645>>>>>>>                Move  ""                                                    to sRetval
29646>>>>>>>        Case End
29646>>>>>>>
29646>>>>>>>        Function_Return sRetval
29647>>>>>>>    End_Function
29648>>>>>>>
29648>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
29650>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
29650>>>>>>>        Boolean bOpened bOK bMertech
29650>>>>>>>
29650>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
29650>>>>>>>        // which makes the program unable to run because they can't be opened.
29650>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
29650>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
29650>>>>>>>        // proper .int files for the two tables.
29650>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
29652>>>>>>>            Function_Return True
29653>>>>>>>        End
29653>>>>>>>>
29653>>>>>>>
29653>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29656>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
29657>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
29658>>>>>>>        Move CS_ANSI_Txt to sNewFormat
29659>>>>>>>        Get AutoConnectionIDLogin to bOK
29660>>>>>>>
29660>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
29660>>>>>>>        Sleep 1
29661>>>>>>>
29661>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
29664>>>>>>>        If (bOpened = False) Begin
29666>>>>>>>            Open hTable
29668>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
29671>>>>>>>        End
29671>>>>>>>>
29671>>>>>>>        If (bOpened = False) Begin
29673>>>>>>>            Function_Return False
29674>>>>>>>        End
29674>>>>>>>>
29674>>>>>>>
29674>>>>>>>        Get psDriverID to sDriverID
29675>>>>>>>        Get IsMertechDriver sDriverID to bMertech
29676>>>>>>>        If (bMertech = True) Begin
29678>>>>>>>            Get psDataPathFirstPart to sDataPath
29679>>>>>>>            Get vFolderExists sDataPath to bOK
29680>>>>>>>            If (bOK = False) Begin
29682>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
29683>>>>>>>>
29683>>>>>>>                Function_Return False
29684>>>>>>>            End
29684>>>>>>>>
29684>>>>>>>            Get vFolderFormat sDataPath to sDataPath
29685>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29688>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
29689>>>>>>>            Move sDatabaseName to sPhysicalFileName
29690>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
29691>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
29692>>>>>>>            Function_Return (bOK = True)
29693>>>>>>>        End
29693>>>>>>>>
29693>>>>>>>
29693>>>>>>>        Move False to Err
29694>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29697>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
29698>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
29698>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
29698>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
29699>>>>>>>
29699>>>>>>>        Move False to Err
29700>>>>>>>
29700>>>>>>>        If (hTable > 0) Begin
29702>>>>>>>            Structure_Start hTable
29703>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
29706>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29709>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
29711>>>>>>>        End
29711>>>>>>>>
29711>>>>>>>        Else Begin
29712>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
29715>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29718>>>>>>>        End
29718>>>>>>>>
29718>>>>>>>        Function_Return (Err = False)
29719>>>>>>>    End_Function
29720>>>>>>>
29720>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
29722>>>>>>>        String[] sReturnArray
29723>>>>>>>        String sValue // sUserID sPassword
29723>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
29723>>>>>>>        Integer iFetchResult iRetval
29723>>>>>>>        tSQLConnection SQLConnection
29723>>>>>>>        tSQLConnection SQLConnection
29723>>>>>>>
29723>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
29724>>>>>>>        If (hoSQLHandler <> 0) Begin
29726>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
29727>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
29728>>>>>>>            If (hoSQLConnect <> 0) Begin
29730>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
29731>>>>>>>                If (hStmt <> 0) Begin
29733>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
29734>>>>>>>                    If (sArgument <> "") Begin
29736>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
29737>>>>>>>                    End
29737>>>>>>>>
29737>>>>>>>                    Send SQLCall of hStmt
29738>>>>>>>
29738>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
29739>>>>>>>                    If (iRetval = 0) Begin
29741>>>>>>>                        Repeat
29741>>>>>>>>
29741>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
29742>>>>>>>                            If (iFetchResult <> 0) Begin
29744>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
29745>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
29746>>>>>>>                            End
29746>>>>>>>>
29746>>>>>>>                        Until (iFetchResult = 0)
29748>>>>>>>                        Send SQLClose of hStmt
29749>>>>>>>                    End
29749>>>>>>>>
29749>>>>>>>                End
29749>>>>>>>>
29749>>>>>>>                Send SQLDisconnect of hoSQLConnect
29750>>>>>>>            End
29750>>>>>>>>
29750>>>>>>>        End
29750>>>>>>>>
29750>>>>>>>
29750>>>>>>>        Function_Return sReturnArray
29751>>>>>>>    End_Function
29752>>>>>>>
29752>>>>>>>    // * Dummy function for the Studio's Code Explorer *
29752>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
29754>>>>>>>        Function_Return False
29755>>>>>>>    End_Function
29756>>>>>>>
29756>>>>>>>    // Enumerate SQL Servers.
29756>>>>>>>    // Pass a driver id. Returns a string array.
29756>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
29756>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
29756>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
29758>>>>>>>        String[] sReturnArray
29759>>>>>>>        Handle hoSQLHandler
29759>>>>>>>        String sServer
29759>>>>>>>        Integer iCount iNumItems iDataSourceType
29759>>>>>>>
29759>>>>>>>        If (num_arguments > 1) Begin
29761>>>>>>>            Move iDatSrcType to iDataSourceType
29762>>>>>>>        End
29762>>>>>>>>
29762>>>>>>>
29762>>>>>>>        Case Begin
29762>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29764>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
29765>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
29766>>>>>>>                For iCount from 0 to (iNumItems - 1)
29772>>>>>>>>
29772>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
29773>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
29774>>>>>>>                Loop
29775>>>>>>>>
29775>>>>>>>                Case Break
29776>>>>>>>
29776>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29779>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
29780>>>>>>>                Send SeedDataSources of hoSQLHandler
29781>>>>>>>                Move 0 to iCount
29782>>>>>>>                Repeat
29782>>>>>>>>
29782>>>>>>>                    Get DataSources of hoSQLHandler to sServer
29783>>>>>>>                    If (sServer <> "") Begin
29785>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
29786>>>>>>>                        Move sServer to sReturnArray[iCount]
29787>>>>>>>                    End
29787>>>>>>>>
29787>>>>>>>                    Increment iCount
29788>>>>>>>                Until (sServer = "")
29790>>>>>>>                Case Break
29791>>>>>>>
29791>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29794>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
29795>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
29796>>>>>>>                Move 0 to iCount
29797>>>>>>>                Repeat
29797>>>>>>>>
29797>>>>>>>                    Get DataSources of hoSQLHandler to sServer
29798>>>>>>>                    If (sServer <> "") Begin
29800>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
29801>>>>>>>                        Move sServer to sReturnArray[iCount]
29802>>>>>>>                    End
29802>>>>>>>>
29802>>>>>>>                    Increment iCount
29803>>>>>>>                Until (sServer = "")
29805>>>>>>>                Case Break
29806>>>>>>>
29806>>>>>>>            Case (sDriverID = SQLFLEX)
29809>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
29810>>>>>>>                Case Break
29811>>>>>>>
29811>>>>>>>            Case (sDriverID = ORAFLEX)
29814>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
29815>>>>>>>                Case Break
29816>>>>>>>
29816>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
29816>>>>>>>            Case (sDriverID = MDSPgSQL)
29819>>>>>>>                Move "localhost" to sReturnArray[0]
29820>>>>>>>                Case Break
29821>>>>>>>
29821>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
29821>>>>>>>            Case (sDriverID = MDSMySQL)
29824>>>>>>>                Move "localhost" to sReturnArray[0]
29825>>>>>>>                Case Break
29826>>>>>>>
29826>>>>>>>            Case Else
29826>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
29827>>>>>>>>
29827>>>>>>>        Case End
29827>>>>>>>
29827>>>>>>>        Function_Return sReturnArray
29828>>>>>>>    End_Function
29829>>>>>>>
29829>>>>>>>    // Returns all databases as a string array for the passed driver id.
29829>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
29831>>>>>>>        String[] sReturnArray
29832>>>>>>>        String sServer sVal
29832>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
29832>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
29833>>>>>>>        tSQLConnection SQLConnection
29833>>>>>>>        tSQLConnection SQLConnection
29833>>>>>>>        Boolean bOK
29833>>>>>>>        Integer iCount iSize
29833>>>>>>>
29833>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29834>>>>>>>        If (bOK = False) Begin
29836>>>>>>>            Function_Return sReturnArray
29837>>>>>>>        End
29837>>>>>>>>
29837>>>>>>>
29837>>>>>>>        Case Begin
29837>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29839>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
29840>>>>>>>                Case Break
29841>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29844>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
29845>>>>>>>                Case Break
29846>>>>>>>
29846>>>>>>>            // This is needed to be able to check if a database exists or not.
29846>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29849>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
29850>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
29852>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
29854>>>>>>>                        // If a FILEDSN: (can only be one database name)
29854>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
29855>>>>>>>                    End
29855>>>>>>>>
29855>>>>>>>                    Else Begin
29856>>>>>>>                        // Else the DSN's were read from the registry.
29856>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
29857>>>>>>>                        Move SQLConnection.sServer to sServer
29858>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
29859>>>>>>>                        Decrement iSize
29860>>>>>>>                        for iCount from 0 to iSize
29866>>>>>>>>
29866>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
29867>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
29869>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
29870>>>>>>>                                Move iSize to iCount // We're done.
29871>>>>>>>                            End
29871>>>>>>>>
29871>>>>>>>                        Loop
29872>>>>>>>>
29872>>>>>>>                    End
29872>>>>>>>>
29872>>>>>>>                End
29872>>>>>>>>
29872>>>>>>>                Case Break
29873>>>>>>>
29873>>>>>>>            Case (sDriverID = SQLFLEX)
29876>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
29877>>>>>>>                Case Break
29878>>>>>>>
29878>>>>>>>            Case (sDriverID = MDSPgSQL)
29881>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
29882>>>>>>>                Case Break
29883>>>>>>>
29883>>>>>>>            Case (sDriverID = MDSMySQL)
29886>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
29887>>>>>>>                Case Break
29888>>>>>>>
29888>>>>>>>            Case (sDriverID = ORAFLEX)
29891>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
29892>>>>>>>                Case Break
29893>>>>>>>
29893>>>>>>>            Case Else
29893>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
29893>>>>>>>        Case End
29893>>>>>>>
29893>>>>>>>        Function_Return sReturnArray
29894>>>>>>>    End_Function
29895>>>>>>>
29895>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
29895>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
29897>>>>>>>        String[] sReturnArray
29898>>>>>>>        Boolean bOK
29898>>>>>>>
29898>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29899>>>>>>>        If (bOK = False) Begin
29901>>>>>>>            Function_Return sReturnArray
29902>>>>>>>        End
29902>>>>>>>>
29902>>>>>>>
29902>>>>>>>        Case Begin
29902>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29904>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
29905>>>>>>>                Case Break
29906>>>>>>>
29906>>>>>>>            Case (sDriverID = MDSPgSQL)
29909>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
29910>>>>>>>                Case Break
29911>>>>>>>
29911>>>>>>>            Case (sDriverID = ORAFLEX)
29914>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
29915>>>>>>>                Case Break
29916>>>>>>>
29916>>>>>>>            Case Else
29916>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
29917>>>>>>>>
29917>>>>>>>                Case Break
29918>>>>>>>        Case End
29918>>>>>>>
29918>>>>>>>        Function_Return sReturnArray
29919>>>>>>>    End_Function
29920>>>>>>>
29920>>>>>>>    // Returns all schemas as a string array for the passed driver id.
29920>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
29922>>>>>>>        String[] sReturnArray
29923>>>>>>>        Boolean bOK
29923>>>>>>>
29923>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29924>>>>>>>        If (bOK = False) Begin
29926>>>>>>>            Function_Return sReturnArray
29927>>>>>>>        End
29927>>>>>>>>
29927>>>>>>>
29927>>>>>>>        Case Begin
29927>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29929>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
29930>>>>>>>                Case Break
29931>>>>>>>
29931>>>>>>>            Case (sDriverID = MDSPgSQL)
29934>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
29935>>>>>>>                Case Break
29936>>>>>>>
29936>>>>>>>            Case (sDriverID = ORAFLEX)
29939>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
29940>>>>>>>                Case Break
29941>>>>>>>
29941>>>>>>>            Case Else
29941>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
29942>>>>>>>>
29942>>>>>>>                Case Break
29943>>>>>>>        Case End
29943>>>>>>>
29943>>>>>>>        Function_Return sReturnArray
29944>>>>>>>    End_Function
29945>>>>>>>
29945>>>>>>>    // Returns a string array with all tables for the current database.
29945>>>>>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
29947>>>>>>>        String[] sReturnArray sArray
29949>>>>>>>        String sConnectionString sSelect
29949>>>>>>>        Integer iSize iCount iDbType
29949>>>>>>>        Boolean bOK
29949>>>>>>>
29949>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
29951>>>>>>>            Function_Return sArray
29952>>>>>>>        End
29952>>>>>>>>
29952>>>>>>>
29952>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29953>>>>>>>        If (bOK = False) Begin
29955>>>>>>>            Function_Return sReturnArray
29956>>>>>>>        End
29956>>>>>>>>
29956>>>>>>>        If (sSchema = "") Begin
29958>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
29959>>>>>>>        End
29959>>>>>>>>
29959>>>>>>>
29959>>>>>>>        Get psConnectionString to sConnectionString
29960>>>>>>>
29960>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
29960>>>>>>>        // the dbType.
29960>>>>>>>        Get piDbType to iDbType
29961>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
29963>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
29965>>>>>>>                Move MDSMySQL to sDriverID
29966>>>>>>>            End
29966>>>>>>>>
29966>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
29968>>>>>>>                Move MSSQLDRV_ID to sDriverID
29969>>>>>>>            End
29969>>>>>>>>
29969>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
29971>>>>>>>                Move DB2_DRV_ID to sDriverID
29972>>>>>>>            End
29972>>>>>>>>
29972>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
29974>>>>>>>                Move MDSPgSQL to sDriverID
29975>>>>>>>            End
29975>>>>>>>>
29975>>>>>>>        End
29975>>>>>>>>
29975>>>>>>>
29975>>>>>>>        Case Begin
29975>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29977>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
29978>>>>>>>                Case Break
29979>>>>>>>
29979>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29982>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
29983>>>>>>>                Case Break
29984>>>>>>>
29984>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29987>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
29988>>>>>>>                Case Break
29989>>>>>>>
29989>>>>>>>            Case (sDriverID = SQLFLEX)
29992>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
29993>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
29994>>>>>>>                Case Break
29995>>>>>>>
29995>>>>>>>            Case (sDriverID = MDSMySQL)
29998>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
29999>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
30000>>>>>>>                Case Break
30001>>>>>>>
30001>>>>>>>            Case (sDriverID = MDSPgSQL)
30004>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
30005>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
30006>>>>>>>                Case Break
30007>>>>>>>
30007>>>>>>>            Case (sDriverID = ORAFLEX)
30010>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
30011>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
30012>>>>>>>                Move (SizeOfArray(sArray)) to iSize
30013>>>>>>>                Decrement iSize
30014>>>>>>>                For iCount from 0 to iSize
30020>>>>>>>>
30020>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
30022>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
30023>>>>>>>                    End
30023>>>>>>>>
30023>>>>>>>                Loop
30024>>>>>>>>
30024>>>>>>>                Case Break
30025>>>>>>>
30025>>>>>>>            Case Else
30025>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
30026>>>>>>>>
30026>>>>>>>                Case Break
30027>>>>>>>        Case End
30027>>>>>>>
30027>>>>>>>        Function_Return sReturnArray
30028>>>>>>>    End_Function
30029>>>>>>>
30029>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
30029>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
30031>>>>>>>        String[] sReturnArray
30032>>>>>>>        String sConnectionString sSelect sSchema
30032>>>>>>>        Boolean bOK
30032>>>>>>>        Integer iDbType
30032>>>>>>>
30032>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
30033>>>>>>>        If (bOK = False) Begin
30035>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
30036>>>>>>>>
30036>>>>>>>            Function_Return sReturnArray
30037>>>>>>>        End
30037>>>>>>>>
30037>>>>>>>
30037>>>>>>>        Get psConnectionString to sConnectionString
30038>>>>>>>        Get psSchema to sSchema
30039>>>>>>>
30039>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
30039>>>>>>>        // the dbType.
30039>>>>>>>        Get piDbType to iDbType
30040>>>>>>>
30040>>>>>>>        Case Begin
30040>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
30042>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
30044>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
30045>>>>>>>                End
30045>>>>>>>>
30045>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
30047>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
30048>>>>>>>                End
30048>>>>>>>>
30048>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
30050>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
30051>>>>>>>                End
30051>>>>>>>>
30051>>>>>>>
30051>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
30052>>>>>>>                Case Break
30053>>>>>>>
30053>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
30056>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
30057>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
30058>>>>>>>                Case Break
30059>>>>>>>
30059>>>>>>>            Case (sDriverID = DB2_DRV_ID)
30062>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
30063>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
30064>>>>>>>                Case Break
30065>>>>>>>
30065>>>>>>>            Case (sDriverID = SQLFLEX)
30068>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
30069>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
30070>>>>>>>                Case Break
30071>>>>>>>
30071>>>>>>>            Case (sDriverID = MDSMySQL)
30074>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
30075>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
30076>>>>>>>                Case Break
30077>>>>>>>
30077>>>>>>>            Case (sDriverID = MDSPgSQL)
30080>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
30081>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
30082>>>>>>>                Case Break
30083>>>>>>>
30083>>>>>>>            Case (sDriverID = ORAFLEX)
30086>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
30087>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
30088>>>>>>>                Case Break
30089>>>>>>>
30089>>>>>>>            Case Else
30089>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
30090>>>>>>>>
30090>>>>>>>                Case Break
30091>>>>>>>        Case End
30091>>>>>>>
30091>>>>>>>        Function_Return sReturnArray
30092>>>>>>>    End_Function
30093>>>>>>>
30093>>>>>>>
30093>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
30093>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
30095>>>>>>>        String[] sReturnArray sReturnArray2
30097>>>>>>>        String sConnectionString sSelect sSchema
30097>>>>>>>        Boolean bOK
30097>>>>>>>        Integer iCount iSize
30097>>>>>>>
30097>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
30098>>>>>>>        If (bOK = False) Begin
30100>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
30101>>>>>>>>
30101>>>>>>>            Function_Return sReturnArray
30102>>>>>>>        End
30102>>>>>>>>
30102>>>>>>>
30102>>>>>>>        Get psConnectionString to sConnectionString
30103>>>>>>>        Get psSchema to sSchema
30104>>>>>>>
30104>>>>>>>        Case Begin
30104>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
30106>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
30107>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
30108>>>>>>>                Case Break
30109>>>>>>>
30109>>>>>>>            Case (sDriverID = DB2_DRV_ID)
30112>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30113>>>>>>>>
30113>>>>>>>//                Move () to sSelect
30113>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
30113>>>>>>>                Case Break
30114>>>>>>>
30114>>>>>>>            Case (sDriverID = SQLFLEX)
30117>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30118>>>>>>>>
30118>>>>>>>//                Move () to sSelect
30118>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
30118>>>>>>>                Case Break
30119>>>>>>>
30119>>>>>>>            Case (sDriverID = MDSMySQL)
30122>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30123>>>>>>>>
30123>>>>>>>//                Move () to sSelect
30123>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
30123>>>>>>>                Case Break
30124>>>>>>>
30124>>>>>>>            Case (sDriverID = MDSPgSQL)
30127>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30128>>>>>>>>
30128>>>>>>>//                Move () to sSelect
30128>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
30128>>>>>>>                Case Break
30129>>>>>>>
30129>>>>>>>            Case (sDriverID = ORAFLEX)
30132>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30133>>>>>>>>
30133>>>>>>>//                Move () to sSelect
30133>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
30133>>>>>>>                Case Break
30134>>>>>>>
30134>>>>>>>            Case Else
30134>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
30135>>>>>>>>
30135>>>>>>>                Case Break
30136>>>>>>>        Case End
30136>>>>>>>
30136>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
30137>>>>>>>        Decrement iSize
30138>>>>>>>        For iCount from 0 to iSize
30144>>>>>>>>
30144>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
30146>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
30147>>>>>>>            End
30147>>>>>>>>
30147>>>>>>>        Loop
30148>>>>>>>>
30148>>>>>>>
30148>>>>>>>        Function_Return sReturnArray2
30149>>>>>>>    End_Function
30150>>>>>>>
30150>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
30150>>>>>>>    // The format of the array is "TableName.FieldName"
30150>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
30152>>>>>>>        String[] sFileNameArray sFieldNameArray
30154>>>>>>>        tSQLRelation[] sRelationsArray
30154>>>>>>>        tSQLRelation[] sRelationsArray
30155>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
30155>>>>>>>        Boolean bOK
30155>>>>>>>        Integer iCount iSize iLength
30155>>>>>>>
30155>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
30156>>>>>>>        If (bOK = False) Begin
30158>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
30159>>>>>>>>
30159>>>>>>>            Function_Return sRelationsArray
30160>>>>>>>        End
30160>>>>>>>>
30160>>>>>>>
30160>>>>>>>        Get psConnectionString to sConnectionString
30161>>>>>>>        Get psSchema to sSchema
30162>>>>>>>
30162>>>>>>>        Case Begin
30162>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
30164>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
30165>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
30166>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
30167>>>>>>>                Case Break
30168>>>>>>>
30168>>>>>>>            Case (sDriverID = DB2_DRV_ID)
30171>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30172>>>>>>>>
30172>>>>>>>//                Move () to sSelect
30172>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
30172>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
30172>>>>>>>                Case Break
30173>>>>>>>
30173>>>>>>>            Case (sDriverID = SQLFLEX)
30176>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30177>>>>>>>>
30177>>>>>>>//                Move () to sSelect
30177>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
30177>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
30177>>>>>>>                Case Break
30178>>>>>>>
30178>>>>>>>            Case (sDriverID = MDSMySQL)
30181>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30182>>>>>>>>
30182>>>>>>>//                Move () to sSelect
30182>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
30182>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
30182>>>>>>>                Case Break
30183>>>>>>>
30183>>>>>>>            Case (sDriverID = MDSPgSQL)
30186>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30187>>>>>>>>
30187>>>>>>>//                Move () to sSelect
30187>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
30187>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
30187>>>>>>>                Case Break
30188>>>>>>>
30188>>>>>>>            Case (sDriverID = ORAFLEX)
30191>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
30192>>>>>>>>
30192>>>>>>>//                Move () to sSelect
30192>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
30192>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
30192>>>>>>>                Case Break
30193>>>>>>>
30193>>>>>>>            Case Else
30193>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
30194>>>>>>>>
30194>>>>>>>                Case Break
30195>>>>>>>        Case End
30195>>>>>>>
30195>>>>>>>        Move (Length(sTableName)) to iLength
30196>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
30197>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
30198>>>>>>>        Decrement iSize
30199>>>>>>>        For iCount from 0 to iSize
30205>>>>>>>>
30205>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
30207>>>>>>>                Move sFileNameArray[iCount]         to sFileName
30208>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
30209>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
30210>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
30211>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
30212>>>>>>>            End
30212>>>>>>>>
30212>>>>>>>        Loop
30213>>>>>>>>
30213>>>>>>>
30213>>>>>>>        Function_Return sRelationsArray
30214>>>>>>>    End_Function
30215>>>>>>>
30215>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
30217>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
30217>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
30218>>>>>>>        String[] sUsers sPrograms
30220>>>>>>>        String sSelect
30220>>>>>>>        Integer iSize iCount
30220>>>>>>>
30220>>>>>>>        Case Begin
30220>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
30222>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
30223>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
30224>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
30225>>>>>>>                Case Break
30226>>>>>>>            Case (sDriverID = SQLFLEX)
30229>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
30230>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
30231>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
30232>>>>>>>                Case Break
30233>>>>>>>            Case Else
30233>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
30234>>>>>>>>
30234>>>>>>>        Case End
30234>>>>>>>
30234>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
30235>>>>>>>        Decrement iSize
30236>>>>>>>        For iCount from 0 to iSize
30242>>>>>>>>
30242>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
30243>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
30244>>>>>>>        Loop
30245>>>>>>>>
30245>>>>>>>
30245>>>>>>>        Function_Return SQLLoggedInUser
30246>>>>>>>    End_Function
30247>>>>>>>
30247>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
30247>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
30247>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
30249>>>>>>>        String[] sFilesData
30250>>>>>>>        Boolean bExists
30250>>>>>>>        Integer iCh
30250>>>>>>>        String sFileName sExt
30250>>>>>>>
30250>>>>>>>        Get vFolderExists sDataPath to bExists
30251>>>>>>>        If (bExists = True) Begin
30253>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
30254>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
30255>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
30256>>>>>>>            Direct_Input channel iCh sDataPath
30258>>>>>>>                Repeat
30258>>>>>>>>
30258>>>>>>>                    Readln channel iCh sFileName
30260>>>>>>>                    Get ParseFileExtension sFileName to sExt
30261>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
30263>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
30265>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
30266>>>>>>>                        End
30266>>>>>>>>
30266>>>>>>>                    End
30266>>>>>>>>
30266>>>>>>>                Until (SeqEof = True)
30268>>>>>>>            Close_Input channel iCh
30270>>>>>>>            Send Seq_Release_Channel iCh
30271>>>>>>>        End
30271>>>>>>>>
30271>>>>>>>        Function_Return sFilesData
30272>>>>>>>    End_Function
30273>>>>>>>
30273>>>>>>>    // Only done for MSSQLDRV_ID so far...
30273>>>>>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
30275>>>>>>>        Boolean bMertechDriver
30275>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
30275>>>>>>>        String sDescription sFrom sSys sValue sPrevious
30275>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
30275>>>>>>>        Integer iFetchResult iRows iColumn iPos
30275>>>>>>>        tSQLConnection SQLConnection
30275>>>>>>>        tSQLConnection SQLConnection
30275>>>>>>>        String[] asCollations
30276>>>>>>>        
30276>>>>>>>        If (sDriverID = "") Begin
30278>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
30279>>>>>>>>
30279>>>>>>>            Function_Return asCollations
30280>>>>>>>        End
30280>>>>>>>>
30280>>>>>>>
30280>>>>>>>        // Only done for MSSQLDRV_ID so far...
30280>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
30282>>>>>>>            Function_Return asCollations
30283>>>>>>>        End                 
30283>>>>>>>>
30283>>>>>>>
30283>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
30284>>>>>>>        If (bMertechDriver = False) Begin
30286>>>>>>>            Get phoSQLManager to hoSQLManager
30287>>>>>>>        End
30287>>>>>>>>
30287>>>>>>>        Else Begin
30288>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
30289>>>>>>>        End
30289>>>>>>>>
30289>>>>>>>
30289>>>>>>>        Get psConnectionID     to sConnectionID
30290>>>>>>>        Get psConnectionString to sConnectionString
30291>>>>>>>        Move 0 to LastErr
30292>>>>>>>
30292>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30293>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
30294>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30295>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
30297>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
30298>>>>>>>>
30298>>>>>>>            Function_Return asCollations
30299>>>>>>>        End
30299>>>>>>>>
30299>>>>>>>
30299>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
30300>>>>>>>
30300>>>>>>>        If (hStmt = 0) Begin
30302>>>>>>>            Send SqlDisconnect of hoSQLManager
30303>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
30304>>>>>>>>
30304>>>>>>>            Function_Return asCollations
30305>>>>>>>        End
30305>>>>>>>>
30305>>>>>>>
30305>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
30306>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
30307>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
30308>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
30309>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
30310>>>>>>>
30310>>>>>>>        // MS-SQL Syntax:  
30310>>>>>>>        // SELECT name, description
30310>>>>>>>        //   from sys.fn_helpcollations();
30310>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
30311>>>>>>>
30311>>>>>>>        Move 1 to iColumn
30312>>>>>>>        Send SqlExecDirect of hStmt sSQL
30313>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
30314>>>>>>>        Repeat
30314>>>>>>>>
30314>>>>>>>            Get SQLFetch of hStmt to iFetchResult
30315>>>>>>>            If (iFetchResult <> 0) Begin
30317>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
30318>>>>>>>                If (sValue <> sPrevious) Begin         
30320>>>>>>>                    // We need to skip all collations starting with "SQL" because they
30320>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
30320>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
30321>>>>>>>                    If (iPos <> 1) Begin
30323>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
30324>>>>>>>                    End
30324>>>>>>>>
30324>>>>>>>                End
30324>>>>>>>>
30324>>>>>>>                Move sValue to sPrevious
30325>>>>>>>            End
30325>>>>>>>>
30325>>>>>>>        Until (iFetchResult = 0)
30327>>>>>>>        Send SQLClose of hStmt
30328>>>>>>>        Send SQLDisconnect of hoSQLConnect
30329>>>>>>>
30329>>>>>>>        Function_Return asCollations
30330>>>>>>>    End_Function
30331>>>>>>>
30331>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
30331>>>>>>>    // for DAW drivers.
30331>>>>>>>    // Returns: A string array.
30331>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
30333>>>>>>>        String[] sReturnArray
30334>>>>>>>        String sValue sPrevious
30334>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
30334>>>>>>>        Integer iFetchResult iRows
30334>>>>>>>        tSQLConnection SQLConnection
30334>>>>>>>        tSQLConnection SQLConnection
30334>>>>>>>
30334>>>>>>>        Get phoSQLManager to hoSQLHandler
30335>>>>>>>
30335>>>>>>>        If (hoSQLHandler <> 0) Begin
30337>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30338>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
30339>>>>>>>
30339>>>>>>>            If (hoSQLConnect <> 0) Begin
30341>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
30342>>>>>>>                If (hstmt <> 0) Begin
30344>>>>>>>                    Send SqlExecDirect of hstmt sStmt
30345>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
30346>>>>>>>                    Repeat
30346>>>>>>>>
30346>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
30347>>>>>>>                        If (iFetchResult <> 0) Begin
30349>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
30350>>>>>>>                            If (sValue <> sPrevious) Begin
30352>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
30353>>>>>>>                            End
30353>>>>>>>>
30353>>>>>>>                            Move sValue to sPrevious
30354>>>>>>>                        End
30354>>>>>>>>
30354>>>>>>>                    Until (iFetchResult = 0)
30356>>>>>>>                    Send SQLClose of hstmt
30357>>>>>>>                End
30357>>>>>>>>
30357>>>>>>>                Send SQLDisconnect of hoSQLConnect
30358>>>>>>>            End
30358>>>>>>>>
30358>>>>>>>        End
30358>>>>>>>>
30358>>>>>>>
30358>>>>>>>        Function_Return sReturnArray
30359>>>>>>>    End_Function
30360>>>>>>>
30360>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
30360>>>>>>>    // for Mertech drivers.
30360>>>>>>>    // Returns: A string array.
30360>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
30362>>>>>>>        String[] sReturnArray
30363>>>>>>>        String sValue
30363>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
30363>>>>>>>        Integer iFetchResult iRows
30363>>>>>>>        tSQLConnection SQLConnection
30363>>>>>>>        tSQLConnection SQLConnection
30363>>>>>>>
30363>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
30364>>>>>>>
30364>>>>>>>        If (hoSQLHandler <> 0) Begin
30366>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30367>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
30368>>>>>>>
30368>>>>>>>            If (hoSQLConnect <> 0) Begin
30370>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
30371>>>>>>>                If (hStmt <> 0) Begin
30373>>>>>>>                    Send SqlExecDirect of hStmt sStmt
30374>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
30375>>>>>>>                    Repeat
30375>>>>>>>>
30375>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
30376>>>>>>>                        If (iFetchResult <> 0) Begin
30378>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
30379>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
30380>>>>>>>                        End
30380>>>>>>>>
30380>>>>>>>                    Until (iFetchResult = 0)
30382>>>>>>>                    Send SQLClose of hStmt
30383>>>>>>>                End
30383>>>>>>>>
30383>>>>>>>                Send SQLDisconnect of hoSQLConnect
30384>>>>>>>            End
30384>>>>>>>>
30384>>>>>>>        End
30384>>>>>>>>
30384>>>>>>>
30384>>>>>>>        Function_Return sReturnArray
30385>>>>>>>    End_Function
30386>>>>>>>
30386>>>>>>>    // * Dummy function for the Studio's Code Explorer *
30386>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
30388>>>>>>>        Function_Return False
30389>>>>>>>    End_Function
30390>>>>>>>
30390>>>>>>>    // Returns the index for the passed sTableName
30390>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
30390>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
30392>>>>>>>        Integer iIndex iSize iCount
30392>>>>>>>        String[] sTablesArray
30393>>>>>>>        String sDatabase sSchema sVal sConnectionString
30393>>>>>>>
30393>>>>>>>        Move -1 to iIndex
30394>>>>>>>        Get psConnectionString to sConnectionString
30395>>>>>>>        Get psDatabase to sDatabase
30396>>>>>>>        Get psSchema   to sSchema
30397>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
30398>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
30399>>>>>>>        Decrement iSize
30400>>>>>>>        For iCount from 0 to iSize
30406>>>>>>>>
30406>>>>>>>            Move sTablesArray[iCount] to sVal
30407>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
30409>>>>>>>                Move iCount to iIndex // We found it!
30410>>>>>>>                Move iSize to iCount  // End the loop
30411>>>>>>>            End
30411>>>>>>>>
30411>>>>>>>        Loop
30412>>>>>>>>
30412>>>>>>>
30412>>>>>>>        Function_Return iIndex
30413>>>>>>>    End_Function
30414>>>>>>>
30414>>>>>>>    // Helper function that builds a string like;
30414>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
30414>>>>>>>    Function _SqlSelectFromWhereName Returns String
30416>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
30416>>>>>>>
30416>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
30417>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
30418>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
30419>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
30420>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
30421>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
30422>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
30423>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
30424>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
30425>>>>>>>        Function_Return sRetval
30426>>>>>>>    End_Function
30427>>>>>>>
30427>>>>>>>    // Helper function to create a SQL statement like;
30427>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
30427>>>>>>>    // Used for checking if an index exists.
30427>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
30429>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
30429>>>>>>>
30429>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
30430>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
30431>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
30432>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
30433>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
30434>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
30435>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
30436>>>>>>>
30436>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
30437>>>>>>>
30437>>>>>>>        Function_Return sRetval
30438>>>>>>>    End_Function
30439>>>>>>>
30439>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
30439>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
30439>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
30441>>>>>>>        String sRetval
30441>>>>>>>        If (iLength <> 0) Begin
30443>>>>>>>            Move ("(" + String(iLength)) to sRetval
30444>>>>>>>            If (iDecimals <> 0) Begin
30446>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
30447>>>>>>>            End
30447>>>>>>>>
30447>>>>>>>            Move (sRetval + ")") to sRetval
30448>>>>>>>        End
30448>>>>>>>>
30448>>>>>>>        Function_Return sRetval
30449>>>>>>>    End_Function
30450>>>>>>>
30450>>>>>>>    // Checks that the passed sDriverID is defined.
30450>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
30450>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
30452>>>>>>>        Boolean bOK
30452>>>>>>>        Integer iDriver
30452>>>>>>>
30452>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
30454>>>>>>>            Function_Return False
30455>>>>>>>        End
30455>>>>>>>>
30455>>>>>>>
30455>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
30456>>>>>>>
30456>>>>>>>        If (bOK = False) Begin
30458>>>>>>>            Get IsMertechDriver sDriverID to bOK
30459>>>>>>>        End
30459>>>>>>>>
30459>>>>>>>
30459>>>>>>>        If (bOK = False) Begin
30461>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
30462>>>>>>>>
30462>>>>>>>            Function_Return False
30463>>>>>>>        End
30463>>>>>>>>
30463>>>>>>>
30463>>>>>>>        Get DriverIndex sDriverID to iDriver
30464>>>>>>>        If (iDriver = 0) Begin
30466>>>>>>>            Load_Driver sDriverID
30467>>>>>>>        End
30467>>>>>>>>
30467>>>>>>>
30467>>>>>>>        Function_Return True
30468>>>>>>>    End_Function
30469>>>>>>>
30469>>>>>>>    // Checks that the length parameter has been passed correctly.
30469>>>>>>>    // This is only of concern for certain SQL data types.
30469>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
30471>>>>>>>        Integer iLength
30471>>>>>>>        Boolean bOK bCheckTypeLength
30471>>>>>>>
30471>>>>>>>        If (num_arguments > 1) Begin
30473>>>>>>>            Move iLen to iLength
30474>>>>>>>        End
30474>>>>>>>>
30474>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
30475>>>>>>>
30475>>>>>>>        If (bCheckTypeLength = True) Begin
30477>>>>>>>            Move (iLength > 0) to bOK
30478>>>>>>>        End
30478>>>>>>>>
30478>>>>>>>
30478>>>>>>>        Function_Return (bOK = True)
30479>>>>>>>    End_Function
30480>>>>>>>
30480>>>>>>>    Function _SqlProperTableName String sTableName Returns String
30482>>>>>>>        String sVal sSchema sDriverID
30482>>>>>>>        Integer iDbType
30482>>>>>>>
30482>>>>>>>        If (Trim(sTableName) = "") Begin
30484>>>>>>>            Function_Return ""
30485>>>>>>>        End
30485>>>>>>>>
30485>>>>>>>
30485>>>>>>>        Get psDriverID to sDriverID
30486>>>>>>>        Get piDbType   to iDbType
30487>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
30489>>>>>>>            Get psUserID to sSchema
30490>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
30490>>>>>>>            Move (Uppercase(sSchema)) to sSchema
30491>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
30492>>>>>>>            Function_Return sTableName
30493>>>>>>>        End
30493>>>>>>>>
30493>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
30495>>>>>>>            Get psDatabase to sVal
30496>>>>>>>            Move (sVal + "." + sTableName) to sTableName
30497>>>>>>>            Function_Return sTableName
30498>>>>>>>        End
30498>>>>>>>>
30498>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
30500>>>>>>>            Move ('"' + sTableName + '"') to sTableName
30501>>>>>>>            Function_Return sTableName
30502>>>>>>>        End
30502>>>>>>>>
30502>>>>>>>
30502>>>>>>>        Get psSchema to sSchema
30503>>>>>>>        If (sSchema = "") Begin
30505>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
30506>>>>>>>        End
30506>>>>>>>>
30506>>>>>>>
30506>>>>>>>        Move (Uppercase(sTableName)) to sVal
30507>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
30509>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
30511>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
30512>>>>>>>            End
30512>>>>>>>>
30512>>>>>>>            Else Begin
30513>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
30514>>>>>>>            End
30514>>>>>>>>
30514>>>>>>>        End
30514>>>>>>>>
30514>>>>>>>
30514>>>>>>>        Function_Return sTableName
30515>>>>>>>    End_Function
30516>>>>>>>
30516>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
30516>>>>>>>    // the passed sFieldName has the correct spelling.
30516>>>>>>>    // Used with Embedded SQL statement calls.
30516>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
30516>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
30518>>>>>>>        String sRetval sValue sDriverID
30518>>>>>>>        String[] sColumnNamesArray
30519>>>>>>>        Integer iCount iColumns
30519>>>>>>>
30519>>>>>>>        Move "" to sRetval
30520>>>>>>>        Get psDriverID to sDriverID
30521>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
30522>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
30523>>>>>>>        Decrement iColumns
30524>>>>>>>
30524>>>>>>>        For iCount from 0 to iColumns
30530>>>>>>>>
30530>>>>>>>            Move sColumnNamesArray[iCount] to sValue
30531>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
30533>>>>>>>                Move sValue to sRetval
30534>>>>>>>                Move iColumns to iCount // We're done.
30535>>>>>>>            End
30535>>>>>>>>
30535>>>>>>>        Loop
30536>>>>>>>>
30536>>>>>>>
30536>>>>>>>        Function_Return sRetval
30537>>>>>>>    End_Function
30538>>>>>>>
30538>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
30540>>>>>>>        String[] sReturnArray
30541>>>>>>>        Handle hoSQLHandler
30541>>>>>>>        Integer iCount iSize iItem
30541>>>>>>>        String sServer
30541>>>>>>>        tSQLConnection SQLConnection
30541>>>>>>>        tSQLConnection SQLConnection
30541>>>>>>>
30541>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
30542>>>>>>>        Send Delete_Data    of hoSQLHandler
30543>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
30544>>>>>>>
30544>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30545>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
30546>>>>>>>        Decrement iSize
30547>>>>>>>
30547>>>>>>>        For iCount from 0 to iSize
30553>>>>>>>>
30553>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
30554>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
30555>>>>>>>            Increment iItem
30556>>>>>>>        Loop
30557>>>>>>>>
30557>>>>>>>
30557>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30558>>>>>>>
30558>>>>>>>        Function_Return sReturnArray
30559>>>>>>>    End_Function
30560>>>>>>>
30560>>>>>>>    Function _SqlTableArrayDAW Returns String[]
30562>>>>>>>        String[] sReturnArray
30563>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
30563>>>>>>>        Handle hoSQLHandler
30563>>>>>>>        Integer iCount iSize iItem iPos
30563>>>>>>>        Boolean bOK
30563>>>>>>>        tSQLConnection SQLConnection
30563>>>>>>>        tSQLConnection SQLConnection
30563>>>>>>>
30563>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30564>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
30566>>>>>>>            Function_Return sReturnArray
30567>>>>>>>        End
30567>>>>>>>>
30567>>>>>>>
30567>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
30568>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
30569>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
30570>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
30571>>>>>>>
30571>>>>>>>        Get phoCLIHandler to hoSQLHandler
30572>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
30573>>>>>>>        Send Delete_Data  of hoSQLHandler
30574>>>>>>>
30574>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30575>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
30576>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
30576>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
30576>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
30576>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
30576>>>>>>>//                If (iPos > 0) Begin
30576>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
30576>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
30576>>>>>>>//                End
30576>>>>>>>//            End
30576>>>>>>>//        End
30576>>>>>>>
30576>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
30577>>>>>>>        Move False to Err
30578>>>>>>>        Move 0 to iItem
30579>>>>>>>
30579>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
30579>>>>>>>        for iCount from 1 to iSize
30585>>>>>>>>
30585>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
30586>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
30587>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
30588>>>>>>>            If (sSchema = "") Begin
30590>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
30591>>>>>>>            End
30591>>>>>>>>
30591>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
30592>>>>>>>            Move (Trim(sTable)) to sTable
30593>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
30595>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
30596>>>>>>>            End
30596>>>>>>>>
30596>>>>>>>            Else Begin
30597>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
30598>>>>>>>            End
30598>>>>>>>>
30598>>>>>>>            If (bOK = True) Begin
30600>>>>>>>                Move sTable to sReturnArray[iItem]
30601>>>>>>>                Increment iItem
30602>>>>>>>            End
30602>>>>>>>>
30602>>>>>>>        Loop
30603>>>>>>>>
30603>>>>>>>
30603>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30604>>>>>>>
30604>>>>>>>        Function_Return sReturnArray
30605>>>>>>>    End_Function
30606>>>>>>>
30606>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
30608>>>>>>>        String[] sReturnArray
30609>>>>>>>        String sValue
30609>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
30609>>>>>>>        Integer iRetval iCols iFetchResult
30609>>>>>>>        tSQLConnection SQLConnection
30609>>>>>>>        tSQLConnection SQLConnection
30609>>>>>>>
30609>>>>>>>        Get phoSQLManager to hoSQLHandler
30610>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30611>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
30612>>>>>>>
30612>>>>>>>        If (hoSQLConnect <> 0) Begin
30614>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
30615>>>>>>>            If (hStmt <> 0) Begin
30617>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
30618>>>>>>>                If (sArgument <> "") Begin
30620>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
30621>>>>>>>                End
30621>>>>>>>>
30621>>>>>>>
30621>>>>>>>                Send SqlCall             of hStmt
30622>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
30623>>>>>>>                If (iRetval = 0) Begin
30625>>>>>>>                    Repeat
30625>>>>>>>>
30625>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
30626>>>>>>>                        If (iCols > 0) Begin
30628>>>>>>>                            Repeat
30628>>>>>>>>
30628>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
30629>>>>>>>                                If (iFetchResult <> 0) Begin
30631>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
30632>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
30633>>>>>>>                                End
30633>>>>>>>>
30633>>>>>>>                            Until (iFetchResult = 0)
30635>>>>>>>                        End
30635>>>>>>>>
30635>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
30636>>>>>>>                    Until (iRetval = 0)
30638>>>>>>>                    Send SqlClose of hStmt
30639>>>>>>>                End
30639>>>>>>>>
30639>>>>>>>            End
30639>>>>>>>>
30639>>>>>>>            Send SqlDisconnect of hoSQLConnect
30640>>>>>>>        End
30640>>>>>>>>
30640>>>>>>>        Function_Return sReturnArray
30641>>>>>>>    End_Function
30642>>>>>>>
30642>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
30644>>>>>>>        String[] sReturnArray
30645>>>>>>>        String sDataSource
30645>>>>>>>        Handle hoSQLHandler
30645>>>>>>>        Integer iItem
30645>>>>>>>
30645>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
30646>>>>>>>        Send SeedDataSources of hoSQLHandler
30647>>>>>>>
30647>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30648>>>>>>>
30648>>>>>>>        Repeat
30648>>>>>>>>
30648>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
30649>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
30650>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
30651>>>>>>>            Increment iItem
30652>>>>>>>        Until (sDataSource = "")
30654>>>>>>>
30654>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30655>>>>>>>
30655>>>>>>>        Function_Return sReturnArray
30656>>>>>>>    End_Function
30657>>>>>>>
30657>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
30659>>>>>>>        String[] sReturnArray
30660>>>>>>>        String sDataSource
30660>>>>>>>        Handle hoSQLHandler
30660>>>>>>>        Integer iItem
30660>>>>>>>
30660>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
30661>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30662>>>>>>>
30662>>>>>>>        Send SeedDataSources of hoSQLHandler
30663>>>>>>>
30663>>>>>>>        Repeat
30663>>>>>>>>
30663>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
30664>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
30666>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
30667>>>>>>>                Increment iItem
30668>>>>>>>            End
30668>>>>>>>>
30668>>>>>>>        Until (sDataSource = "")
30670>>>>>>>
30670>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30671>>>>>>>
30671>>>>>>>        Function_Return sReturnArray
30672>>>>>>>    End_Function
30673>>>>>>>
30673>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
30675>>>>>>>        String[] sDataSources
30676>>>>>>>        tSQLConnection SQLConnection
30676>>>>>>>        tSQLConnection SQLConnection
30676>>>>>>>        tSQLIntTableInfo[] sReturnArray
30676>>>>>>>        tSQLIntTableInfo[] sReturnArray
30677>>>>>>>        Integer iDataSources iCount iItem
30677>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
30677>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
30677>>>>>>>        Boolean bExists bKeyOpened
30677>>>>>>>
30677>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30678>>>>>>>        Move SQLConnection.sConnectionString to sConnection
30679>>>>>>>        Move SQLConnection.sServer           to sServer
30680>>>>>>>
30680>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
30680>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
30682>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
30683>>>>>>>            Set psFileName of hoIniFile to sServer
30684>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
30685>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
30686>>>>>>>            Send Destroy of hoIniFile
30687>>>>>>>        End
30687>>>>>>>>
30687>>>>>>>
30687>>>>>>>        // DSN - read DATABASE name from the registry
30687>>>>>>>        Else Begin
30688>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
30689>>>>>>>
30689>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
30689>>>>>>>            // most probably place the info is kept that we're after.
30689>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
30690>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
30691>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
30692>>>>>>>            If (bExists = True) Begin
30694>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
30695>>>>>>>            End
30695>>>>>>>>
30695>>>>>>>            Else Begin
30696>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
30697>>>>>>>            End
30697>>>>>>>>
30697>>>>>>>
30697>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
30698>>>>>>>            If (bExists) Begin
30700>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
30701>>>>>>>                If (bKeyOpened) Begin
30703>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
30704>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
30705>>>>>>>                    If (iDataSources > 0) Begin
30707>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
30708>>>>>>>                        Decrement iDataSources
30709>>>>>>>                        for iCount from 0 to iDataSources
30715>>>>>>>>
30715>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
30716>>>>>>>                        Loop
30717>>>>>>>>
30717>>>>>>>                        Move 0 to iItem
30718>>>>>>>                        for iCount from 0 to iDataSources
30724>>>>>>>>
30724>>>>>>>                            Move sDataSources[iCount] to sSubKey
30725>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
30726>>>>>>>                            If (bKeyOpened = True) Begin
30728>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
30729>>>>>>>                                If (bExists = True) Begin
30731>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
30732>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
30733>>>>>>>                                    Increment iItem
30734>>>>>>>                                End
30734>>>>>>>>
30734>>>>>>>                            End
30734>>>>>>>>
30734>>>>>>>                        Loop
30735>>>>>>>>
30735>>>>>>>                    End
30735>>>>>>>>
30735>>>>>>>                    Send CloseKey of hoRegistry
30736>>>>>>>                    Send Destroy of hoODBCDataSources
30737>>>>>>>                End
30737>>>>>>>>
30737>>>>>>>            End
30737>>>>>>>>
30737>>>>>>>
30737>>>>>>>            // We then check the "User DNS" area in the registry.
30737>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
30738>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
30739>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
30740>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
30741>>>>>>>
30741>>>>>>>            If (bExists) Begin
30743>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
30744>>>>>>>                If (bKeyOpened) Begin
30746>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
30747>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
30748>>>>>>>                    If (iDataSources > 0) Begin
30750>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
30751>>>>>>>                        Decrement iDataSources
30752>>>>>>>                        for iCount from 0 to iDataSources
30758>>>>>>>>
30758>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
30759>>>>>>>                        Loop
30760>>>>>>>>
30760>>>>>>>                        for iCount from 0 to iDataSources
30766>>>>>>>>
30766>>>>>>>                            Move sDataSources[iCount] to sSubKey
30767>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
30768>>>>>>>                            If (bKeyOpened = True) Begin
30770>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
30771>>>>>>>                                If (bExists = True) Begin
30773>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
30774>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
30775>>>>>>>                                    Increment iItem
30776>>>>>>>                                End
30776>>>>>>>>
30776>>>>>>>                            End
30776>>>>>>>>
30776>>>>>>>                        Loop
30777>>>>>>>>
30777>>>>>>>                    End
30777>>>>>>>>
30777>>>>>>>                    Send CloseKey of hoRegistry
30778>>>>>>>                    Send Destroy of hoODBCDataSources
30779>>>>>>>                End
30779>>>>>>>>
30779>>>>>>>            End
30779>>>>>>>>
30779>>>>>>>
30779>>>>>>>            Send Destroy of hoRegistry
30780>>>>>>>        End
30780>>>>>>>>
30780>>>>>>>
30780>>>>>>>        Function_Return sReturnArray
30781>>>>>>>    End_Function
30782>>>>>>>
30782>>>>>>>    // We might have a split Sql script where the info about which database to use is
30782>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
30782>>>>>>>    // insert it for scriplets to come after the first one.
30782>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
30784>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
30784>>>>>>>        Integer iStart iEnd iDbType
30784>>>>>>>        Boolean bOK
30784>>>>>>>
30784>>>>>>>        Get piDbType to iDbType
30785>>>>>>>        Get psDriverID to sDriverID
30786>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
30787>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
30788>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
30789>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
30790>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
30791>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
30793>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
30794>>>>>>>            Move (Pos("]", sTmp)) to iEnd
30795>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
30796>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
30797>>>>>>>            Set Private.psUseDatabase to sUseDatabase
30798>>>>>>>        End
30798>>>>>>>>
30798>>>>>>>        Else Begin
30799>>>>>>>            Move (Uppercase(sStmt)) to sTmp
30800>>>>>>>
30800>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
30800>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
30802>>>>>>>                Get Private.psUseDatabase to sUseDatabase
30803>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
30804>>>>>>>            End
30804>>>>>>>>
30804>>>>>>>
30804>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
30804>>>>>>>            // We will get an error when trying to create a view if it already exists.
30804>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
30804>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
30807>>>>>>>                // Make sure we only have one space between statements/words.
30807>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
30808>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
30809>>>>>>>                Move (Trim(sTmp)) to sTmp
30810>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
30811>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
30812>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
30814>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
30815>>>>>>>                End
30815>>>>>>>>
30815>>>>>>>                Move (Trim(sTmp)) to sTmp
30816>>>>>>>                // Remove data view as it already exists!
30816>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
30817>>>>>>>            End
30817>>>>>>>>
30817>>>>>>>        End
30817>>>>>>>>
30817>>>>>>>
30817>>>>>>>        Function_Return sStmt
30818>>>>>>>    End_Function
30819>>>>>>>
30819>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
30819>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
30821>>>>>>>        String sRetval
30821>>>>>>>        Integer iDbType iIndex
30821>>>>>>>        tSQLKeyWords[] SQLKeywordArray
30821>>>>>>>        tSQLKeyWords[] SQLKeywordArray
30822>>>>>>>        tSQLKeyWords   SQLKeyWords
30822>>>>>>>        tSQLKeyWords   SQLKeyWords
30822>>>>>>>
30822>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
30822>>>>>>>        Move "" to sRetval
30823>>>>>>>        Get piDbType to iDbType
30824>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
30825>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
30826>>>>>>>
30826>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
30827>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
30828>>>>>>>        If (iIndex >= 0) Begin
30830>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
30831>>>>>>>        End
30831>>>>>>>>
30831>>>>>>>
30831>>>>>>>        Function_Return sRetval
30832>>>>>>>    End_Function
30833>>>>>>>
30833>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
30833>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
30835>>>>>>>        String[] sSQLScriptArray
30836>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
30836>>>>>>>        Integer iSize iCount
30836>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
30836>>>>>>>
30836>>>>>>>        Move False to bCommentStart
30837>>>>>>>        Move False to bCommentEnd
30838>>>>>>>        Move False to bDashComment
30839>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
30840>>>>>>>        Move "*/"  to sCommentEnd
30841>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
30842>>>>>>>
30842>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
30843>>>>>>>        Decrement iSize
30844>>>>>>>        Move "" to sText
30845>>>>>>>
30845>>>>>>>        For iCount from 0 to iSize
30851>>>>>>>>
30851>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
30852>>>>>>>            Move (Trim(sLine)) to sTmp
30853>>>>>>>            If (sTmp <> "") Begin
30855>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
30856>>>>>>>                If (bCommentStart = False) Begin
30858>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
30859>>>>>>>                    If (bCommentStart = False) Begin
30861>>>>>>>                    End
30861>>>>>>>>
30861>>>>>>>                End
30861>>>>>>>>
30861>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
30862>>>>>>>                If (bCommentEnd = True) Begin
30864>>>>>>>                    Move False to bCommentStart
30865>>>>>>>                End
30865>>>>>>>>
30865>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
30867>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
30868>>>>>>>                End
30868>>>>>>>>
30868>>>>>>>            End
30868>>>>>>>>
30868>>>>>>>        Loop
30869>>>>>>>>
30869>>>>>>>
30869>>>>>>>        // Update the retval struct array:
30869>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
30870>>>>>>>        Function_Return SqlScriptArray
30871>>>>>>>    End_Function
30872>>>>>>>
30872>>>>>>>
30872>>>>>>>    // *** Database API Functions: ***
30872>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
30872>>>>>>>    // make changes/updates to the database.
30872>>>>>>>
30872>>>>>>>    // * Dummy function for the Studio's Code Explorer *
30872>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
30874>>>>>>>        Function_Return False
30875>>>>>>>    End_Function
30876>>>>>>>
30876>>>>>>>    // This might not do what you think - Here's what it does:
30876>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
30876>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
30876>>>>>>>    // to the SQL table.
30876>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
30876>>>>>>>    // already exists in SQL.
30876>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
30876>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
30876>>>>>>>    // restructuring an existing table.
30876>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
30878>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
30878>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
30878>>>>>>>        Handle hToTable
30878>>>>>>>
30878>>>>>>>        Move True to bUseConnectionID
30879>>>>>>>        If (num_arguments > 1) Begin
30881>>>>>>>            Move bUseConnID to bUseConnectionID
30882>>>>>>>        End
30882>>>>>>>>
30882>>>>>>>
30882>>>>>>>        Get psDriverID to sDriverID
30883>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
30883>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
30884>>>>>>>        If (bExists = False) Begin
30886>>>>>>>            Function_Return False
30887>>>>>>>        End
30887>>>>>>>>
30887>>>>>>>
30887>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
30888>>>>>>>
30888>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
30889>>>>>>>        If (bOK = False) Begin
30891>>>>>>>            Function_Return False
30892>>>>>>>        End
30892>>>>>>>>
30892>>>>>>>
30892>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
30892>>>>>>>        // we do nothing
30892>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
30893>>>>>>>        If (bExists = True) Begin
30895>>>>>>>            Function_Return False
30896>>>>>>>        End
30896>>>>>>>>
30896>>>>>>>
30896>>>>>>>        Get psConnectionID     to sConnectionID
30897>>>>>>>        Get psConnectionString to sConnectionString
30898>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
30900>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
30901>>>>>>>>
30901>>>>>>>            Function_Return False
30902>>>>>>>        End
30902>>>>>>>>
30902>>>>>>>
30902>>>>>>>        Set Private.phCurrentTable to hTable
30903>>>>>>>        Get psSchema to sSchema
30904>>>>>>>        If (sSchema = "") Begin
30906>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
30907>>>>>>>        End
30907>>>>>>>>
30907>>>>>>>
30907>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
30908>>>>>>>
30908>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
30908>>>>>>>        // was a programmer's error and we adjust for it here.
30908>>>>>>>        If (bMertechDriver = True) Begin
30910>>>>>>>            Move False to bUseConnectionID
30911>>>>>>>        End
30911>>>>>>>>
30911>>>>>>>
30911>>>>>>>        // If we should use a connection id we need to check it exists;
30911>>>>>>>        // else we create it before attempting creating the table
30911>>>>>>>        If (bUseConnectionID = True) Begin
30913>>>>>>>            Get AutoConnectionIDLogin to bOK
30914>>>>>>>            If (bOk = False) Begin
30916>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
30917>>>>>>>>
30917>>>>>>>                Function_Return False
30918>>>>>>>            End
30918>>>>>>>>
30918>>>>>>>        End
30918>>>>>>>>
30918>>>>>>>
30918>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30921>>>>>>>        Get _TableNameOnly sRootName to sRootName
30922>>>>>>>        If (sRootName = "") Begin
30924>>>>>>>            Function_Return False
30925>>>>>>>        End
30925>>>>>>>>
30925>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
30926>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
30929>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
30932>>>>>>>
30932>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
30932>>>>>>>        //
30932>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
30932>>>>>>>        // because then the table should not be visible to users.
30932>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
30932>>>>>>>//        If (iPos <> 1) Begin
30932>>>>>>>//            If (sDisplayName contains ".") Begin
30932>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
30932>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
30932>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
30932>>>>>>>//            End
30932>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
30932>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
30932>>>>>>>//            End
30932>>>>>>>//        End
30932>>>>>>>
30932>>>>>>>        If (bIsAlias = False) Begin
30934>>>>>>>            Get OpenTableExclusive hTable to bOpened
30935>>>>>>>            If (bOpened = False) Begin
30937>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
30938>>>>>>>>
30938>>>>>>>                Function_Return False
30939>>>>>>>            End
30939>>>>>>>>
30939>>>>>>>        End
30939>>>>>>>>
30939>>>>>>>
30939>>>>>>>        If (ghoProgressBar <> 0) Begin
30941>>>>>>>            Send DoAdvance of ghoProgressBar
30942>>>>>>>            Set Message_Text of ghoStatusPanel to ""
30943>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
30944>>>>>>>        End
30944>>>>>>>>
30944>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
30944>>>>>>>        Move hTable to hToTable
30945>>>>>>>        Move False to Err
30946>>>>>>>
30946>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
30946>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
30946>>>>>>>        // a proper and updated .int file.
30946>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
30949>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
30950>>>>>>>
30950>>>>>>>        If (bIsAlias = False) Begin
30952>>>>>>>            Structure_Start hToTable sDriverID
30953>>>>>>>                Set Private.phCurrentTable to hTable
30954>>>>>>>                If (bUseConnectionID = True) Begin
30956>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
30959>>>>>>>                End
30959>>>>>>>>
30959>>>>>>>                Else Begin
30960>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
30963>>>>>>>                End
30963>>>>>>>>
30963>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
30966>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
30966>>>>>>>                Move False to Err
30967>>>>>>>                Move 0 to LastErr
30968>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
30969>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
30971>>>>>>>            Set Action_Text of ghoStatusPanel to ""
30972>>>>>>>        End
30972>>>>>>>>
30972>>>>>>>
30972>>>>>>>        Move (not(Err)) to bOK
30973>>>>>>>        If (bOK = True) Begin
30975>>>>>>>            // The attributes set above will always trigger an error
30975>>>>>>>            // We also adjust the Filelist entries
30975>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
30978>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
30981>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
30984>>>>>>>
30984>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
30984>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
30985>>>>>>>        End
30985>>>>>>>>
30985>>>>>>>
30985>>>>>>>        Function_Return (bOK = True)
30986>>>>>>>    End_Function
30987>>>>>>>
30987>>>>>>>    // Sample usage:
30987>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
30987>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
30987>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
30989>>>>>>>        Boolean bOK bIsSQLTable
30989>>>>>>>
30989>>>>>>>        Get AutoConnectionIDLogin to bOK
30990>>>>>>>        Move False to Err
30991>>>>>>>        Get OpenTableExclusive hTable to bOK
30992>>>>>>>        If (bOK = False) Begin
30994>>>>>>>            Function_Return False
30995>>>>>>>        End
30995>>>>>>>>
30995>>>>>>>
30995>>>>>>>        // ToDo: Add to all table change functions!
30995>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
30996>>>>>>>            If (bIsSQLTable = True) Begin
30998>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
31001>>>>>>>            End
31001>>>>>>>>
31001>>>>>>>
31001>>>>>>>        Set Private.phCurrentTable to hTable
31002>>>>>>>        Structure_Start hTable
31003>>>>>>>            Set_Attribute iAttribute of hTable to iValue
31006>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31007>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31009>>>>>>>
31009>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31010>>>>>>>        Function_Return (Err = False)
31011>>>>>>>    End_Function
31012>>>>>>>
31012>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
31014>>>>>>>        Boolean bOK
31014>>>>>>>        
31014>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
31015>>>>>>>        If (bOK = True) Begin
31017>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
31018>>>>>>>        End
31018>>>>>>>>
31018>>>>>>>        
31018>>>>>>>        Function_Return (bOK = True)
31019>>>>>>>    End_Function
31020>>>>>>>    
31020>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
31020>>>>>>>    // or to change the filelist slot names.
31020>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
31022>>>>>>>        String sFileListName
31022>>>>>>>        
31022>>>>>>>        Move False to Err
31023>>>>>>>
31023>>>>>>>        If (ghoProgressBar <> 0) Begin
31025>>>>>>>            Send DoAdvance of ghoProgressBar
31026>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
31027>>>>>>>        End
31027>>>>>>>>
31027>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
31027>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
31029>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
31032>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
31035>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
31038>>>>>>>            Function_Return (Err = False) // And we're done.
31039>>>>>>>        End
31039>>>>>>>>
31039>>>>>>>
31039>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31041>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
31041>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
31042>>>>>>>        End
31042>>>>>>>>
31042>>>>>>>//        Else Begin
31042>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
31042>>>>>>>//        End
31042>>>>>>>//
31042>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31042>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31042>>>>>>>
31042>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31045>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31048>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31051>>>>>>>        
31051>>>>>>>        Function_Return (Err = False)
31052>>>>>>>    End_Function
31053>>>>>>>
31053>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
31055>>>>>>>        Boolean bOK
31055>>>>>>>
31055>>>>>>>        Get AutoConnectionIDLogin to bOK
31056>>>>>>>        Move False to Err
31057>>>>>>>        Get OpenTableExclusive hTable to bOK
31058>>>>>>>        If (bOK = False) Begin
31060>>>>>>>            Function_Return False
31061>>>>>>>        End
31061>>>>>>>>
31061>>>>>>>
31061>>>>>>>        Set Private.phCurrentTable to hTable
31062>>>>>>>        Structure_Start hTable
31063>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
31066>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31067>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31069>>>>>>>
31069>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31070>>>>>>>        Function_Return (Err = False)
31071>>>>>>>    End_Function
31072>>>>>>>
31072>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
31074>>>>>>>        Boolean bOK bIsSQLTable
31074>>>>>>>
31074>>>>>>>        Move False to Err
31075>>>>>>>        Get AutoConnectionIDLogin to bOK
31076>>>>>>>        Open hToTable
31078>>>>>>>        Get OpenTableExclusive hTable to bOK
31079>>>>>>>        If (bOK = False) Begin
31081>>>>>>>            Function_Return False
31082>>>>>>>        End
31082>>>>>>>>
31082>>>>>>>
31082>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
31083>>>>>>>            If (bIsSQLTable = True) Begin
31085>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
31088>>>>>>>            End
31088>>>>>>>>
31088>>>>>>>
31088>>>>>>>        Set Private.phCurrentTable to hTable
31089>>>>>>>        Structure_Start hTable
31090>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
31093>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
31096>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31097>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31099>>>>>>>
31099>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31100>>>>>>>        Function_Return (Err = False)
31101>>>>>>>    End_Function
31102>>>>>>>
31102>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
31104>>>>>>>        Integer[] aTableConvertExceptions
31105>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
31106>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
31107>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
31108>>>>>>>    End_Procedure
31109>>>>>>>
31109>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
31111>>>>>>>        Integer[] aTableDateCorrectionExceptions
31112>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
31113>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
31114>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
31115>>>>>>>    End_Procedure
31116>>>>>>>
31116>>>>>>>    Procedure ApiTableConvertALLToSql
31118>>>>>>>        Integer[] iTablesArray
31119>>>>>>>        Integer iSize iCount
31119>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
31119>>>>>>>        String sDriverID
31119>>>>>>>
31119>>>>>>>        Get psDriverID to sDriverID
31120>>>>>>>        Get pbUseConnectionID to bUseConnectionID
31121>>>>>>>        Get pbToANSI          to bToANSI
31122>>>>>>>        Get pbRecnum          to bRecnum
31123>>>>>>>        Get pbCopyData        to bCopyData
31124>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
31126>>>>>>>            Get pbContinueOnError to bContinueOnError
31127>>>>>>>        End
31127>>>>>>>>
31127>>>>>>>
31127>>>>>>>        Get _AllTablesToConvert to iTablesArray
31128>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
31129>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
31130>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
31131>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
31132>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
31133>>>>>>>
31133>>>>>>>        Decrement iSize
31134>>>>>>>        For iCount from 0 to iSize
31140>>>>>>>>
31140>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
31141>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
31142>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
31142>>>>>>>            // if there was an error converting one table...
31142>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
31142>>>>>>>        Loop
31143>>>>>>>>
31143>>>>>>>
31143>>>>>>>    End_Procedure
31144>>>>>>>
31144>>>>>>>    Procedure ApiTableAttachALLToSql
31146>>>>>>>        Integer[] iTablesArray
31147>>>>>>>        Integer iSize iCount
31147>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
31147>>>>>>>        String sDriverID
31147>>>>>>>
31147>>>>>>>        Get psDriverID to sDriverID
31148>>>>>>>        Get pbUseConnectionID to bUseConnectionID
31149>>>>>>>        Get pbToANSI          to bToANSI
31150>>>>>>>        Get pbRecnum          to bRecnum
31151>>>>>>>        Get pbCopyData        to bCopyData
31152>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
31154>>>>>>>            Get pbContinueOnError to bContinueOnError
31155>>>>>>>        End
31155>>>>>>>>
31155>>>>>>>
31155>>>>>>>        Get _AllTablesToConvert to iTablesArray
31156>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
31157>>>>>>>        Decrement iSize
31158>>>>>>>        For iCount from 0 to iSize
31164>>>>>>>>
31164>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
31165>>>>>>>        Loop
31166>>>>>>>>
31166>>>>>>>
31166>>>>>>>    End_Procedure
31167>>>>>>>
31167>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
31167>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
31169>>>>>>>        Handle hTable
31169>>>>>>>        String sConnectionID
31169>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
31169>>>>>>>
31169>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
31170>>>>>>>        If (bSameTableNames = True) Begin
31172>>>>>>>            Function_Return True
31173>>>>>>>        End
31173>>>>>>>>
31173>>>>>>>
31173>>>>>>>        Move True to bOK
31174>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
31175>>>>>>>        Set Private.phCurrentTable              to hTable
31176>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
31179>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
31182>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
31185>>>>>>>
31185>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
31187>>>>>>>            Get psConnectionID to sConnectionID
31188>>>>>>>            Get UtilTableExists hTable to bTableExists
31189>>>>>>>            If (bTableExists = True) Begin
31191>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
31192>>>>>>>            End
31192>>>>>>>>
31192>>>>>>>            Else Begin
31193>>>>>>>                Get pbToANSI to bANSI
31194>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
31195>>>>>>>            End
31195>>>>>>>>
31195>>>>>>>        End
31195>>>>>>>>
31195>>>>>>>
31195>>>>>>>        Function_Return bOK
31196>>>>>>>    End_Function
31197>>>>>>>
31197>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
31199>>>>>>>        Handle hToTable hoLogFile
31199>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
31199>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
31199>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
31199>>>>>>>        tSQLConnection SQLConnection
31199>>>>>>>        tSQLConnection SQLConnection
31199>>>>>>>
31199>>>>>>>        Get UtilTableExists hTable to bExists
31200>>>>>>>        If (bExists = False) Begin
31202>>>>>>>            Set Private.phCurrentTable to hTable
31203>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
31204>>>>>>>>
31204>>>>>>>            Function_Return False
31205>>>>>>>        End
31205>>>>>>>>
31205>>>>>>>
31205>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
31206>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
31206>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
31206>>>>>>>        If (bIsAlias = True) Begin
31208>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
31211>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
31213>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
31216>>>>>>>                Get psConnectionID to sConnectionID
31217>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
31218>>>>>>>            End
31218>>>>>>>>
31218>>>>>>>            Function_Return True
31219>>>>>>>        End
31219>>>>>>>>
31219>>>>>>>
31219>>>>>>>        Set Private.phCurrentTable to hTable
31220>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
31223>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
31226>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
31229>>>>>>>
31229>>>>>>>        If (ghoProgressBar <> 0) Begin
31231>>>>>>>            Send DoAdvance of ghoProgressBar
31232>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
31233>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
31234>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
31235>>>>>>>        End
31235>>>>>>>>
31235>>>>>>>
31235>>>>>>>        // Marco Kuipers suggestion;
31235>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
31235>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
31235>>>>>>>        // SQL table.
31235>>>>>>>        Get UtilTableIsSQL hTable to bOK
31236>>>>>>>        If (bOK = False) Begin
31238>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
31239>>>>>>>            If (bExists = True) Begin
31241>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
31241>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
31241>>>>>>>                Get phoLogFile to hoLogFile
31242>>>>>>>                If (hoLogFile <> 0) Begin          
31244>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
31245>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
31245>>>>>>>                    Send LogError sWarning False
31246>>>>>>>                End
31246>>>>>>>>
31246>>>>>>>                Else Begin
31247>>>>>>>                    Error DFERR_PROGRAM sWarning
31248>>>>>>>>
31248>>>>>>>                End                                                       
31248>>>>>>>>
31248>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
31249>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
31250>>>>>>>            End
31250>>>>>>>>
31250>>>>>>>        End
31250>>>>>>>>
31250>>>>>>>
31250>>>>>>>        // Does the rootname contain a driver?
31250>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
31252>>>>>>>            // Does the table already exist as an SQL table?
31252>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
31253>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
31253>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
31253>>>>>>>            If (bExists = False) Begin
31255>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
31256>>>>>>>            End
31256>>>>>>>>
31256>>>>>>>            If (bExists = True) Begin
31258>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
31259>>>>>>>                Function_Return False
31260>>>>>>>            End
31260>>>>>>>>
31260>>>>>>>        End
31260>>>>>>>>
31260>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
31261>>>>>>>
31261>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
31262>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
31262>>>>>>>        // passed as True, we adjust for that here.
31262>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
31263>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
31265>>>>>>>            Move False to bUseConnectionID
31266>>>>>>>        End
31266>>>>>>>>
31266>>>>>>>
31266>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
31267>>>>>>>        Move SQLConnection.sSchema           to sSchema
31268>>>>>>>        If (sSchema = "") Begin
31270>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
31271>>>>>>>            Move (Lowercase(sSchema))        to sSchema
31272>>>>>>>        End
31272>>>>>>>>
31272>>>>>>>
31272>>>>>>>        If (sDriverID = ORAFLEX) Begin
31274>>>>>>>            Move SQLConnection.sUserID       to sSchema
31275>>>>>>>        End
31275>>>>>>>>
31275>>>>>>>
31275>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
31276>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
31277>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
31278>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
31280>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
31281>>>>>>>>
31281>>>>>>>            Function_Return False
31282>>>>>>>        End
31282>>>>>>>>
31282>>>>>>>
31282>>>>>>>        Get AutoConnectionIDLogin to bOK
31283>>>>>>>        Open hTable
31285>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
31288>>>>>>>        If (bOpened = False) Begin
31290>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
31291>>>>>>>>
31291>>>>>>>            Function_Return False
31292>>>>>>>        End
31292>>>>>>>>
31292>>>>>>>
31292>>>>>>>        If (ghoProgressBar <> 0) Begin
31294>>>>>>>            Send DoAdvance of ghoProgressBar
31295>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
31296>>>>>>>        End
31296>>>>>>>>
31296>>>>>>>
31296>>>>>>>        Move 0 to hToTable
31297>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
31298>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
31299>>>>>>>
31299>>>>>>>        Case Begin
31299>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
31301>>>>>>>                Case Break
31302>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
31305>>>>>>>                Case Break
31306>>>>>>>            Case (sDriverID = DB2_DRV_ID)
31309>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
31310>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
31311>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
31312>>>>>>>                Case Break
31313>>>>>>>            Case (sDriverID = ORAFLEX)
31316>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
31317>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
31318>>>>>>>                Case Break
31319>>>>>>>            Case (sDriverID = MDSMySQL)
31322>>>>>>>                Case Break
31323>>>>>>>            Case (sDriverID = MDSPgSQL)
31326>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
31327>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
31328>>>>>>>                Case Break
31329>>>>>>>            Case (sDriverID = DATAFLEX_ID)
31332>>>>>>>                Case Break
31333>>>>>>>            Case Else
31333>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
31334>>>>>>>>
31334>>>>>>>                Case Break
31335>>>>>>>        Case End
31335>>>>>>>
31335>>>>>>>        Move False to Err
31336>>>>>>>
31336>>>>>>>        If (bMertechDriver = True) Begin
31338>>>>>>>            // Note: This function also sets the Err flag.
31338>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
31339>>>>>>>        End
31339>>>>>>>>
31339>>>>>>>
31339>>>>>>>        If (bMertechDriver = False) Begin
31341>>>>>>>            Structure_Start hToTable sDriverID
31342>>>>>>>                Structure_Copy hTable to hToTable
31343>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
31346>>>>>>>
31346>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
31348>>>>>>>                    If (bUseConnectionID = True) Begin
31350>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
31353>>>>>>>                    End
31353>>>>>>>>
31353>>>>>>>                    Else Begin
31354>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
31357>>>>>>>                    End
31357>>>>>>>>
31357>>>>>>>
31357>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
31360>>>>>>>
31360>>>>>>>                    If (sSchema <> "") Begin
31362>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
31365>>>>>>>                    End
31365>>>>>>>>
31365>>>>>>>
31365>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
31367>>>>>>>                        If (sLongTableSpace <> "") Begin
31369>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
31372>>>>>>>                        End
31372>>>>>>>>
31372>>>>>>>                        If (sBaseTableSpace <> "") Begin
31374>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
31377>>>>>>>                        End
31377>>>>>>>>
31377>>>>>>>                        If (sIndexTableSpace <> "") Begin
31379>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
31382>>>>>>>                        End
31382>>>>>>>>
31382>>>>>>>                    End
31382>>>>>>>>
31382>>>>>>>                End
31382>>>>>>>>
31382>>>>>>>
31382>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
31383>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31385>>>>>>>            Set Action_Text of ghoStatusPanel to ""
31386>>>>>>>        End
31386>>>>>>>>
31386>>>>>>>
31386>>>>>>>        Move (not(Err)) to bOK
31387>>>>>>>
31387>>>>>>>        If (bOK = True and bCopyData = True) Begin
31389>>>>>>>            If (bMertechDriver = False) Begin
31391>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
31392>>>>>>>            End
31392>>>>>>>>
31392>>>>>>>            Else Begin
31393>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
31394>>>>>>>            End
31394>>>>>>>>
31394>>>>>>>
31394>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
31396>>>>>>>                Get pbContinueOnError to bContinueOnError
31397>>>>>>>            End
31397>>>>>>>>
31397>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
31397>>>>>>>            // rename it by adding a GUID to the end of the table name
31397>>>>>>>            // - or as much as "fit" because different SQL back-ends have
31397>>>>>>>            // different rules how long a table name can be.
31397>>>>>>>            // The new table will probably contain data but something went
31397>>>>>>>            // wrong while converting the data from embedded to SQL.
31397>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
31399>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
31400>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
31401>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
31402>>>>>>>>
31402>>>>>>>            End
31402>>>>>>>>
31402>>>>>>>        End
31402>>>>>>>>
31402>>>>>>>
31402>>>>>>>        // This must be after copying data...
31402>>>>>>>        If (Err = False) Begin
31404>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
31407>>>>>>>            // It seems the Studio does not do this any more, so commented out.
31407>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
31407>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
31407>>>>>>>            //                // The max length for the display_name is 31 characters...
31407>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
31407>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
31407>>>>>>>            //                End
31407>>>>>>>            //            End
31407>>>>>>>        End
31407>>>>>>>>
31407>>>>>>>
31407>>>>>>>        Close hTable
31408>>>>>>>        Move (not(Err)) to bOK
31409>>>>>>>        Function_Return bOK
31410>>>>>>>    End_Function
31411>>>>>>>
31411>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
31411>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
31411>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
31411>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
31413>>>>>>>        Boolean bOpened bOK
31413>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
31413>>>>>>>        String sErrorFile sEmpty sPath
31413>>>>>>>
31413>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
31416>>>>>>>        Get AutoConnectionIDLogin to bOK
31417>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
31419>>>>>>>            Send IncreaseSortBufferSize
31420>>>>>>>//            Send SetAllIndexesToBatch hToTable
31420>>>>>>>        End
31420>>>>>>>>
31420>>>>>>>
31420>>>>>>>        Move False to Err
31421>>>>>>>        Open sPhysicalName as hToTable
31423>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
31426>>>>>>>        If (bOpened = False) Begin
31428>>>>>>>            Function_Return False
31429>>>>>>>        End
31429>>>>>>>>
31429>>>>>>>
31429>>>>>>>        If (ghoStatusPanel <> 0) Begin
31431>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
31432>>>>>>>            Set piMinimum of ghoProgressBar to 0
31433>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
31434>>>>>>>        End
31434>>>>>>>>
31434>>>>>>>
31434>>>>>>>        Move "" to sEmpty
31435>>>>>>>        Move False to Err
31436>>>>>>>        Move True to bOK
31437>>>>>>>        Set Private.phCurrentTable to hToTable
31438>>>>>>>
31438>>>>>>>        // No need to get the record identifier
31438>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
31441>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31444>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31446>>>>>>>            // Remove all indices to speed up copying of data:
31446>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
31451>>>>>>>            If (iRetval <> 0) Begin       
31453>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
31454>>>>>>>>
31454>>>>>>>                Close hToTable
31455>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31458>>>>>>>                Function_Return False
31459>>>>>>>            End
31459>>>>>>>>
31459>>>>>>>        End
31459>>>>>>>>
31459>>>>>>>
31459>>>>>>>        Move (sRootName + ".err") to sErrorFile
31460>>>>>>>        Move 0 to iIndex
31461>>>>>>>        Move False to Err
31462>>>>>>>
31462>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
31464>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
31467>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
31472>>>>>>>            If (iRetval <> 0) Begin
31474>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
31475>>>>>>>>
31475>>>>>>>                Close hToTable
31476>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31479>>>>>>>                Function_Return False
31480>>>>>>>            End
31480>>>>>>>>
31480>>>>>>>        End
31480>>>>>>>>
31480>>>>>>>        Else Begin
31481>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
31484>>>>>>>        End
31484>>>>>>>>
31484>>>>>>>
31484>>>>>>>        If (Err = False) Begin
31486>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
31487>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
31488>>>>>>>        End
31488>>>>>>>>
31488>>>>>>>
31488>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31490>>>>>>>            // Recreate indices:
31490>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
31495>>>>>>>            If (iRetval <> 0) Begin
31497>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
31498>>>>>>>>
31498>>>>>>>                Close hToTable
31499>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31502>>>>>>>                Function_Return False
31503>>>>>>>            End
31503>>>>>>>>
31503>>>>>>>        End
31503>>>>>>>>
31503>>>>>>>
31503>>>>>>>        Close hToTable
31504>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31507>>>>>>>
31507>>>>>>>        If (bOK = True) Begin
31509>>>>>>>            Move (not(Err)) to bOK
31510>>>>>>>        End
31510>>>>>>>>
31510>>>>>>>
31510>>>>>>>        If (ghoStatusPanel <> 0) Begin
31512>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
31513>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
31514>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
31515>>>>>>>        End
31515>>>>>>>>
31515>>>>>>>
31515>>>>>>>        Function_Return (bOK = True)
31516>>>>>>>    End_Function
31517>>>>>>>
31517>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
31517>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
31517>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
31519>>>>>>>        Handle hFile
31519>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
31519>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
31519>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
31519>>>>>>>        tSQLConnection SQLConnection
31519>>>>>>>        tSQLConnection SQLConnection
31519>>>>>>>        tAPIColumn[] aColumns
31519>>>>>>>        tAPIColumn[] aColumns
31520>>>>>>>        tColumnType ColumnType
31520>>>>>>>        tColumnType ColumnType
31520>>>>>>>
31520>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
31520>>>>>>>        Get UtilTableExists hTable to bOk
31521>>>>>>>        If (bOk = True) Begin
31523>>>>>>>            Function_Return False
31524>>>>>>>        End
31524>>>>>>>>
31524>>>>>>>
31524>>>>>>>        Set Private.phCurrentTable to hTable
31525>>>>>>>        Move sLogicalName to sTableName
31526>>>>>>>        If (ghoProgressBar <> 0) Begin
31528>>>>>>>            Send DoAdvance of ghoProgressBar
31529>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
31530>>>>>>>        End
31530>>>>>>>>
31530>>>>>>>
31530>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
31531>>>>>>>        Get psDriverID to sDriverID
31532>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
31533>>>>>>>        Get piDbType to iDbType
31534>>>>>>>
31534>>>>>>>        // If no columns passed in, we need to create a "dummy" column
31534>>>>>>>        Move False to bDeleteDummy
31535>>>>>>>        If (Num_Arguments = 8) Begin
31537>>>>>>>            Move aColumnIn to aColumns
31538>>>>>>>        End
31538>>>>>>>>
31538>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
31540>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
31541>>>>>>>            Move ColumnType.iSQLType to iDataType
31542>>>>>>>            If (bRecnum = False) Begin
31544>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
31545>>>>>>>            End
31545>>>>>>>>
31545>>>>>>>            Else Begin
31546>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
31547>>>>>>>            End
31547>>>>>>>>
31547>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
31548>>>>>>>            Move True to bDeleteDummy
31549>>>>>>>        End
31549>>>>>>>>
31549>>>>>>>
31549>>>>>>>        // If columns have been passed as an array we need to check if an identity column
31549>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
31549>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
31549>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
31549>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
31551>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
31552>>>>>>>            Decrement iSize
31553>>>>>>>            for iCount from 0 to iSize
31559>>>>>>>>
31559>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
31561>>>>>>>                    Move False to bRecnum
31562>>>>>>>                    Move iSize to iCount
31563>>>>>>>                End
31563>>>>>>>>
31563>>>>>>>            Loop
31564>>>>>>>>
31564>>>>>>>        End
31564>>>>>>>>
31564>>>>>>>
31564>>>>>>>        // If this is a SQL based driver we also check if the table exists
31564>>>>>>>        // in the SQL back end; in case we do nothing.
31564>>>>>>>        If (bSqlDriver = True) Begin
31566>>>>>>>            // Get all connection properties
31566>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
31567>>>>>>>            Move SQLConnection.sSchema to sSchema
31568>>>>>>>            If (sSchema = "") Begin
31570>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
31571>>>>>>>            End
31571>>>>>>>>
31571>>>>>>>
31571>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
31572>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
31572>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
31572>>>>>>>            If (bExists = False) Begin
31574>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
31575>>>>>>>            End
31575>>>>>>>>
31575>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
31575>>>>>>>            // we will just add it to Filelist.cfg
31575>>>>>>>            If (bExists = True) Begin
31577>>>>>>>                If (bExistsInFilelist = False) Begin
31579>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
31581>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
31582>>>>>>>                    End
31582>>>>>>>>
31582>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31585>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31588>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31591>>>>>>>                    Move False to bSysFile
31592>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
31593>>>>>>>                End
31593>>>>>>>>
31593>>>>>>>                Function_Return False
31594>>>>>>>            End
31594>>>>>>>>
31594>>>>>>>        End
31594>>>>>>>>
31594>>>>>>>
31594>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
31595>>>>>>>        If (num_arguments > 6) Begin
31597>>>>>>>            If (bANSI = False) Begin
31599>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
31600>>>>>>>            End
31600>>>>>>>>
31600>>>>>>>        End
31600>>>>>>>>
31600>>>>>>>
31600>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
31600>>>>>>>        // is a programmer's error and we auto-correct for it here.
31600>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
31600>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
31600>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
31600>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
31600>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
31601>>>>>>>        If (bMertechDriver = True) Begin
31603>>>>>>>            If (bUseConnectionID = True) Begin
31605>>>>>>>                Move False to bUseConnectionID
31606>>>>>>>            End
31606>>>>>>>>
31606>>>>>>>            Move sDriverID to sOriginalDriverID
31607>>>>>>>            Move DATAFLEX_ID to sDriverID
31608>>>>>>>        End
31608>>>>>>>>
31608>>>>>>>
31608>>>>>>>        Move False to Err
31609>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
31611>>>>>>>            Move sRootName to sPhysicalFile
31612>>>>>>>        End
31612>>>>>>>>
31612>>>>>>>
31612>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31614>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
31615>>>>>>>
31615>>>>>>>            // If DAW driver and we should use a connection id we need to
31615>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
31615>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
31617>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
31618>>>>>>>                If (bExists = False) Begin
31620>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
31621>>>>>>>                    If (bOk = False) Begin
31623>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
31624>>>>>>>>
31624>>>>>>>                        Function_Return False
31625>>>>>>>                    End
31625>>>>>>>>
31625>>>>>>>                End
31625>>>>>>>>
31625>>>>>>>            End
31625>>>>>>>>
31625>>>>>>>
31625>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
31627>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
31628>>>>>>>            End
31628>>>>>>>>
31628>>>>>>>            Else Begin
31629>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
31630>>>>>>>            End
31630>>>>>>>>
31630>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
31631>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
31631>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
31631>>>>>>>//            End
31631>>>>>>>        End
31631>>>>>>>>
31631>>>>>>>        Move False to Err
31632>>>>>>>        Move 0 to hFile
31633>>>>>>>
31633>>>>>>>        Structure_Start hFile sDriverID
31634>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
31636>>>>>>>                If (bUseConnectionID = True) Begin
31638>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
31641>>>>>>>                End
31641>>>>>>>>
31641>>>>>>>                Else Begin
31642>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
31645>>>>>>>                End
31645>>>>>>>>
31645>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
31648>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
31651>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
31654>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
31657>>>>>>>
31657>>>>>>>                If (sSchema <> "") Begin
31659>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
31662>>>>>>>                End
31662>>>>>>>>
31662>>>>>>>
31662>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
31664>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
31666>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
31669>>>>>>>                    End
31669>>>>>>>>
31669>>>>>>>                End
31669>>>>>>>>
31669>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
31671>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
31673>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
31676>>>>>>>                    End
31676>>>>>>>>
31676>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
31678>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
31681>>>>>>>                    End
31681>>>>>>>>
31681>>>>>>>                End
31681>>>>>>>>
31681>>>>>>>            End
31681>>>>>>>>
31681>>>>>>>
31681>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
31684>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
31685>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31686>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31688>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31689>>>>>>>
31689>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
31689>>>>>>>        If (bMertechDriver = True) Begin
31691>>>>>>>            Move sOriginalDriverID to sDriverID
31692>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
31694>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
31695>>>>>>>            End
31695>>>>>>>>
31695>>>>>>>            // Note: This function also sets the Err flag.
31695>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
31695>>>>>>>        End
31695>>>>>>>>
31695>>>>>>>
31695>>>>>>>        Move (not(Err)) to bOK
31696>>>>>>>        If (bOk = True) Begin
31698>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
31700>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
31701>>>>>>>            End
31701>>>>>>>>
31701>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31704>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31707>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31710>>>>>>>
31710>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
31710>>>>>>>            If (bDeleteDummy) Begin
31712>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
31713>>>>>>>            End
31713>>>>>>>>
31713>>>>>>>        End
31713>>>>>>>>
31713>>>>>>>
31713>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
31714>>>>>>>        Close hTable
31715>>>>>>>        Function_Return (bOK = True)
31716>>>>>>>    End_Function
31717>>>>>>>
31717>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
31719>>>>>>>        Move False to Err
31720>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
31723>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
31726>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
31729>>>>>>>
31729>>>>>>>        Function_Return (Err = False)
31730>>>>>>>    End_Function
31731>>>>>>>
31731>>>>>>>    // ToDo: Needs to be revised
31731>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
31733>>>>>>>        Handle hTable
31733>>>>>>>        String sDEFName sDataPath
31733>>>>>>>        Boolean bExists
31733>>>>>>>
31733>>>>>>>        // Do nothing if MSSQL Driver.
31733>>>>>>>//        Get IsMSSQLDriver to bExists
31733>>>>>>>//        If (bExists = True) Begin
31733>>>>>>>//            Procedure_Return
31733>>>>>>>//        End
31733>>>>>>>
31733>>>>>>>        Get psDataPathFirstPart to sDataPath
31734>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
31735>>>>>>>        If (bExists = True) Begin
31737>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
31737>>>>>>>            // still be missing from the filelist and needs to be added.
31737>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
31738>>>>>>>            If (bExists = True) Begin
31740>>>>>>>                Procedure_Return
31741>>>>>>>            End
31741>>>>>>>>
31741>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
31741>>>>>>>            Else Begin
31742>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
31745>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
31748>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
31751>>>>>>>                Procedure_Return
31752>>>>>>>            End
31752>>>>>>>>
31752>>>>>>>        End
31752>>>>>>>>
31752>>>>>>>
31752>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
31753>>>>>>>        Move 0 to hTable
31754>>>>>>>        Move False to Err
31755>>>>>>>
31755>>>>>>>        Structure_Start hTable DATAFLEX_ID
31756>>>>>>>            Load_Def sDEFName Onto hTable
31757>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
31760>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31761>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31763>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31764>>>>>>>
31764>>>>>>>        Move iFilelistSlot to hTable
31765>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
31768>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
31771>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
31774>>>>>>>
31774>>>>>>>    End_Procedure
31775>>>>>>>
31775>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
31777>>>>>>>        Boolean bTmp bErr bOK
31777>>>>>>>        String sTableName sDisplayName sFileName
31777>>>>>>>
31777>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
31777>>>>>>>        Move Err to bTmp
31778>>>>>>>        Move False to Err
31779>>>>>>>
31779>>>>>>>        Get AutoConnectionIDLogin to bOK
31780>>>>>>>        // First get the info for the current filelist slot:
31780>>>>>>>        Open iFromFileSlot
31782>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
31785>>>>>>>        If (bOK = True) Begin
31787>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
31790>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
31793>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
31796>>>>>>>
31796>>>>>>>            //...then move it.
31796>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
31799>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
31802>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
31805>>>>>>>
31805>>>>>>>            //...and finally remove the old filelist values.
31805>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
31808>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
31811>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
31814>>>>>>>        End
31814>>>>>>>>
31814>>>>>>>        Close iFromFileSlot
31815>>>>>>>
31815>>>>>>>        Move Err to bErr
31816>>>>>>>        Move bTmp to Err
31817>>>>>>>        Function_Return (bErr = False)
31818>>>>>>>    End_Function
31819>>>>>>>
31819>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
31821>>>>>>>        Handle hTable
31821>>>>>>>        Boolean bOK
31821>>>>>>>        String sDriverID
31821>>>>>>>
31821>>>>>>>        Get UtilTableExists hTableFrom to bOK
31822>>>>>>>        If (bOK = False) Begin
31824>>>>>>>            Set Private.phCurrentTable to hTableFrom
31825>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
31826>>>>>>>>
31826>>>>>>>            Function_Return False
31827>>>>>>>        End
31827>>>>>>>>
31827>>>>>>>
31827>>>>>>>        Get UtilTableExists hTableTo to bOK
31828>>>>>>>        If (bOK = False) Begin
31830>>>>>>>            Set Private.phCurrentTable to hTableTo
31831>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
31832>>>>>>>>
31832>>>>>>>            Function_Return False
31833>>>>>>>        End
31833>>>>>>>>
31833>>>>>>>
31833>>>>>>>        Get AutoConnectionIDLogin to bOK
31834>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
31835>>>>>>>        If (bOK = False) Begin
31837>>>>>>>            Function_Return False
31838>>>>>>>        End
31838>>>>>>>>
31838>>>>>>>
31838>>>>>>>        Move False to Err
31839>>>>>>>        Open hTableTo
31841>>>>>>>
31841>>>>>>>        Move hTableFrom to hTable
31842>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
31845>>>>>>>        Set Private.phCurrentTable to hTable
31846>>>>>>>
31846>>>>>>>        Structure_Start hTable sDriverID
31847>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
31850>>>>>>>            If (iColumnTo <> 0) Begin
31852>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
31855>>>>>>>            End
31855>>>>>>>>
31855>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31856>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31858>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31859>>>>>>>
31859>>>>>>>        If (hTableTo > 0) Begin
31861>>>>>>>            Close hTableTo
31862>>>>>>>        End
31862>>>>>>>>
31862>>>>>>>
31862>>>>>>>        Function_Return (Err = False)
31863>>>>>>>    End_Function
31864>>>>>>>
31864>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
31864>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
31866>>>>>>>        String sTableName sDriverID
31866>>>>>>>        Boolean bOk
31866>>>>>>>        String sDataPath
31866>>>>>>>
31866>>>>>>>        Get AutoConnectionIDLogin to bOK
31867>>>>>>>        Move False to Err
31868>>>>>>>        Get psDriverID to sDriverID
31869>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
31870>>>>>>>        If (sTableName = "") Begin
31872>>>>>>>            Function_Return False
31873>>>>>>>        End
31873>>>>>>>>
31873>>>>>>>
31873>>>>>>>        Set Private.phCurrentTable to hTable
31874>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
31875>>>>>>>        Delete_db sTableName
31876>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
31877>>>>>>>
31877>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31879>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
31879>>>>>>>            Get psDataPathFirstPart to sDataPath
31880>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
31881>>>>>>>        End
31881>>>>>>>>
31881>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
31881>>>>>>>        If (hTable <> 0) Begin
31883>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
31886>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
31889>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
31892>>>>>>>        End
31892>>>>>>>>
31892>>>>>>>
31892>>>>>>>        Close hTable
31893>>>>>>>        Function_Return (hTable <> 0)
31894>>>>>>>    End_Function
31895>>>>>>>
31895>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
31897>>>>>>>        Handle hTable
31897>>>>>>>        Boolean bOK
31897>>>>>>>
31897>>>>>>>        Get AutoConnectionIDLogin to bOK
31898>>>>>>>        Move False to Err
31899>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
31901>>>>>>>        Move hTableFrom to hTable
31902>>>>>>>
31902>>>>>>>        Structure_Start hTable
31903>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
31906>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31907>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31909>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31910>>>>>>>
31910>>>>>>>        Close hTableFrom
31911>>>>>>>        Function_Return (Err = False)
31912>>>>>>>    End_Function
31913>>>>>>>
31913>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
31915>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
31915>>>>>>>        Boolean bOK bExists bOpened
31915>>>>>>>        tAPITableNameInfo APITableNameInfo
31915>>>>>>>        tAPITableNameInfo APITableNameInfo
31915>>>>>>>
31915>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
31918>>>>>>>        If (bOpened = False) Begin
31920>>>>>>>            Get OpenTableExclusive hTable to bOpened
31921>>>>>>>            If (bOpened = False) Begin
31923>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
31924>>>>>>>                Function_Return False
31925>>>>>>>            End
31925>>>>>>>>
31925>>>>>>>        End
31925>>>>>>>>
31925>>>>>>>
31925>>>>>>>        Set Private.phCurrentTable to hTable
31926>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
31927>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
31928>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
31929>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
31930>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
31931>>>>>>>        If (bExists = True) Begin
31933>>>>>>>            Function_Return True
31934>>>>>>>        End
31934>>>>>>>>
31934>>>>>>>
31934>>>>>>>        Set Private.phCurrentTable to hTable
31935>>>>>>>        Move False to Err
31936>>>>>>>        Get psDataPathFirstPart to sDataPath
31937>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
31940>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
31943>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
31946>>>>>>>
31946>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
31949>>>>>>>        Close hTable
31950>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
31952>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
31953>>>>>>>            If (bExists = True) Begin
31955>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
31957>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
31960>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
31960>>>>>>>                    // might report "File in use..." and the deletion will fail.
31960>>>>>>>                    Sleep 2
31961>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
31962>>>>>>>                End
31962>>>>>>>>
31962>>>>>>>            End
31962>>>>>>>>
31962>>>>>>>        End
31962>>>>>>>>
31962>>>>>>>
31962>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31964>>>>>>>            If (not(sPhysicalName contains ".")) Begin
31966>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
31967>>>>>>>            End
31967>>>>>>>>
31967>>>>>>>
31967>>>>>>>            // Change the table name in the .int file to the new table new:
31967>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
31968>>>>>>>            If (bOK = False) Begin
31970>>>>>>>                Function_Return False
31971>>>>>>>            End
31971>>>>>>>>
31971>>>>>>>
31971>>>>>>>            // Change table name at the SQL side:
31971>>>>>>>            Get psSchema to sSchema
31972>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
31973>>>>>>>
31973>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
31974>>>>>>>            // Remove cache file and Rename the physical file names:
31974>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
31975>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
31976>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
31977>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
31978>>>>>>>
31978>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
31978>>>>>>>//            If (not(sDisplayName contains ".")) Begin
31978>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
31978>>>>>>>//            End
31978>>>>>>>        End
31978>>>>>>>>
31978>>>>>>>
31978>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31981>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31984>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31987>>>>>>>
31987>>>>>>>        Function_Return (Err = False)
31988>>>>>>>    End_Function
31989>>>>>>>
31989>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
31991>>>>>>>        Move False to Err
31992>>>>>>>        Set Private.phCurrentTable to hTable
31993>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31996>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31999>>>>>>>
31999>>>>>>>        Function_Return (Err = False)
32000>>>>>>>    End_Function
32001>>>>>>>
32001>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
32001>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
32001>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
32003>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
32003>>>>>>>        Handle hTable
32003>>>>>>>        Boolean bIsSame
32003>>>>>>>
32003>>>>>>>        Move APITableInfo.iTableNumber      to hTable
32004>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
32005>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
32008>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
32009>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
32012>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
32015>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
32016>>>>>>>
32016>>>>>>>        If (bCompareFilelistUppercase = True) Begin
32018>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
32019>>>>>>>        End
32019>>>>>>>>
32019>>>>>>>        Else Begin
32020>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
32021>>>>>>>        End
32021>>>>>>>>
32021>>>>>>>
32021>>>>>>>        Function_Return bIsSame
32022>>>>>>>    End_Function
32023>>>>>>>
32023>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
32023>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
32025>>>>>>>        Handle hTable
32025>>>>>>>        String sTableName
32025>>>>>>>        String sDriverIDFrom sDriverIDTo
32025>>>>>>>        Integer iDbType
32025>>>>>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
32025>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
32025>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
32025>>>>>>>        tSQLConnection SQLConnection
32025>>>>>>>        tSQLConnection SQLConnection
32025>>>>>>>        tAPITable      APITableFrom APITableTo
32025>>>>>>>        tAPITable      APITableFrom APITableTo
32025>>>>>>>        tColumnType    ColumnType
32025>>>>>>>        tColumnType    ColumnType
32025>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
32025>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
32026>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
32026>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
32027>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
32027>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
32028>>>>>>>
32028>>>>>>>        // We don't allow changes to the framework's DbVersion table.
32028>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
32030>>>>>>>            Function_Return False
32031>>>>>>>        End
32031>>>>>>>>
32031>>>>>>>
32031>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
32032>>>>>>>        Get piDbType                            to iDbType
32033>>>>>>>        Get pbRecnum                            to bRecnum
32034>>>>>>>        Get pbToANSI                            to bToANSI
32035>>>>>>>        Get pbCopyData                          to bCopyData
32036>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
32037>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
32038>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
32039>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
32040>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
32041>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
32042>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
32044>>>>>>>            Move False                          to bUseConnectionID
32045>>>>>>>        End
32045>>>>>>>>
32045>>>>>>>
32045>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
32046>>>>>>>        Set Private.phCurrentTable              to hTable
32047>>>>>>>        Get UtilTableExists  hTable             to bTableExists
32048>>>>>>>
32048>>>>>>>        If (ghoProgressBar <> 0) Begin
32050>>>>>>>            Send DoAdvance of ghoProgressBar
32051>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
32052>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
32053>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
32054>>>>>>>        End
32054>>>>>>>>
32054>>>>>>>
32054>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
32055>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
32056>>>>>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
32057>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
32058>>>>>>>        Move True                               to APITableFrom.bFromTable
32059>>>>>>>        Move hTable                             to APITableFrom.hTable
32060>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
32061>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
32062>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
32063>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
32064>>>>>>>
32064>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
32066>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
32067>>>>>>>            If (bOk = True) Begin
32069>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
32070>>>>>>>                Function_Return bOk
32071>>>>>>>            End 
32071>>>>>>>>
32071>>>>>>>        End
32071>>>>>>>>
32071>>>>>>>
32071>>>>>>>        If (bTableExists = True) Begin
32073>>>>>>>            If (bIsSQLTableTo = True) Begin
32075>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
32076>>>>>>>            End
32076>>>>>>>>
32076>>>>>>>
32076>>>>>>>            Get OpenTableExclusive hTable to bOpened
32077>>>>>>>            If (bOpened = False) Begin
32079>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
32080>>>>>>>                Function_Return False
32081>>>>>>>            End
32081>>>>>>>>
32081>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
32082>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
32083>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
32084>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
32085>>>>>>>        End
32085>>>>>>>>
32085>>>>>>>
32085>>>>>>>        Move False to Err
32086>>>>>>>        Case Begin
32086>>>>>>>            // Alias table:
32086>>>>>>>            Case (bIsAliasFrom = True)
32088>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
32089>>>>>>>                Case Break
32090>>>>>>>
32090>>>>>>>            // New Table:
32090>>>>>>>            Case (bTableExists = False)
32093>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
32094>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
32094>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
32096>>>>>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
32097>>>>>>>                End                                                                 
32097>>>>>>>>
32097>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
32098>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
32099>>>>>>>                Case Break
32100>>>>>>>
32100>>>>>>>            // Update table:
32100>>>>>>>            Case (bTableExists = True)
32103>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
32104>>>>>>>                If (bIsSame = True) Begin
32106>>>>>>>                    Case Break
32107>>>>>>>                End
32107>>>>>>>>
32107>>>>>>>                If (bFilelistError = True) Begin
32109>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
32110>>>>>>>                    If (bOk = False) Begin
32112>>>>>>>                        Case Break
32113>>>>>>>                    End
32113>>>>>>>>
32113>>>>>>>                End
32113>>>>>>>>
32113>>>>>>>
32113>>>>>>>                If (ghoProgressBar <> 0) Begin
32115>>>>>>>                    Send DoAdvance of ghoProgressBar
32116>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
32117>>>>>>>                End
32117>>>>>>>>
32117>>>>>>>
32117>>>>>>>                // Columns:
32117>>>>>>>                Move True to bOk
32118>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
32119>>>>>>>                If (bIsSame = False) Begin
32121>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
32122>>>>>>>                End
32122>>>>>>>>
32122>>>>>>>                If (bOk = False) Begin
32124>>>>>>>                    Case Break
32125>>>>>>>                End
32125>>>>>>>>
32125>>>>>>>
32125>>>>>>>                // Indexes:
32125>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
32126>>>>>>>                If (bIsSame = False) Begin
32128>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
32129>>>>>>>                End
32129>>>>>>>>
32129>>>>>>>
32129>>>>>>>                // Relations:
32129>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
32130>>>>>>>                If (bIsSame = False) Begin
32132>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
32133>>>>>>>                    If (bOk = False) Begin
32135>>>>>>>                        Case Break
32136>>>>>>>                    End
32136>>>>>>>>
32136>>>>>>>                End
32136>>>>>>>>
32136>>>>>>>
32136>>>>>>>                Case Break
32137>>>>>>>
32137>>>>>>>            Case Else
32137>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
32138>>>>>>>>
32138>>>>>>>                Move False to bOk
32139>>>>>>>        Case End
32139>>>>>>>        
32139>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
32139>>>>>>>        // or convert an embedded table to SQL
32139>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
32141>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
32142>>>>>>>            If (bOk = False) Begin
32144>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
32145>>>>>>>            End
32145>>>>>>>>
32145>>>>>>>        End
32145>>>>>>>>
32145>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
32148>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
32149>>>>>>>        End
32149>>>>>>>>
32149>>>>>>>        
32149>>>>>>>        // Filelist Names:
32149>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
32150>>>>>>>        Close hTable
32151>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
32152>>>>>>>
32152>>>>>>>        Function_Return (bOK = True)
32153>>>>>>>    End_Function
32154>>>>>>>
32154>>>>>>>    // * Dummy function for the Studio's Code Explorer *
32154>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
32156>>>>>>>        Function_Return False
32157>>>>>>>    End_Function
32158>>>>>>>
32158>>>>>>>    // Adds a column name to the passed table number.
32158>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
32160>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
32160>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
32160>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
32160>>>>>>>
32160>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
32161>>>>>>>        If (bExists = True) Begin
32163>>>>>>>            Function_Return False
32164>>>>>>>        End
32164>>>>>>>>
32164>>>>>>>
32164>>>>>>>        Move False to Err
32165>>>>>>>        If (num_arguments > 4) Begin
32167>>>>>>>            Move iPrec to iPrecision
32168>>>>>>>        End
32168>>>>>>>>
32168>>>>>>>        If (num_arguments > 6) Begin
32170>>>>>>>            Move bInitVal to bInitializeValue
32171>>>>>>>            Move sColVal  to sColumnValue
32172>>>>>>>        End
32172>>>>>>>>
32172>>>>>>>        If (iType < -1490) Begin
32174>>>>>>>            Move (iType + 1500) to iType
32175>>>>>>>        End
32175>>>>>>>>
32175>>>>>>>
32175>>>>>>>        Move hTable to iFile
32176>>>>>>>        Get psDriverID to sDriverID
32177>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
32178>>>>>>>        Get AutoConnectionIDLogin to bOK
32179>>>>>>>        Move False to Err
32180>>>>>>>        Move LastErr to iLastErr
32181>>>>>>>        Get OpenTableExclusive iFile to bOK
32182>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
32182>>>>>>>        Set Private.phCurrentTable to hTable
32183>>>>>>>        Structure_Start iFile sDriverID
32184>>>>>>>            Move 0 to iColumn
32185>>>>>>>            Set Private.piCurrentField to iColumn
32186>>>>>>>            Create_Field hTable At iColumn
32187>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
32190>>>>>>>            If (bMertechDriver = True) Begin
32192>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32193>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
32194>>>>>>>            End
32194>>>>>>>>
32194>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
32197>>>>>>>            If (bMertechDriver = True) Begin
32199>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
32200>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
32201>>>>>>>                Move False to Err
32202>>>>>>>                Move iLastErr to LastErr
32203>>>>>>>            End
32203>>>>>>>>
32203>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
32206>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
32209>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32210>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32212>>>>>>>
32212>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32213>>>>>>>
32213>>>>>>>        // If in development environment; create .fd file:
32213>>>>>>>        Open hTable
32215>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
32216>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32217>>>>>>>        If (iCount > 1) Begin
32219>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32220>>>>>>>        End
32220>>>>>>>>
32220>>>>>>>        Get vFolderExists sDDSrcPath to bExists
32221>>>>>>>        If (bExists = True) Begin
32223>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
32224>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
32227>>>>>>>            Get _TableNameOnly sTableName to sTableName
32228>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32230>>>>>>>        End
32230>>>>>>>>
32230>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
32232>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
32233>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
32234>>>>>>>            If (iCount > 1) Begin
32236>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
32237>>>>>>>            End
32237>>>>>>>>
32237>>>>>>>            Get vFolderFormat sDataPath to sDataPath
32238>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
32238>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
32238>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
32238>>>>>>>        End
32238>>>>>>>>
32238>>>>>>>        // Check for a default value
32238>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
32240>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
32241>>>>>>>        End
32241>>>>>>>>
32241>>>>>>>        Close hTable
32242>>>>>>>
32242>>>>>>>        Function_Return (Err = False)
32243>>>>>>>    End_Function
32244>>>>>>>
32244>>>>>>>    // Adds a column name to the passed table number.
32244>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
32246>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
32246>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
32246>>>>>>>        String sDdSrcPath sTableName
32246>>>>>>>
32246>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
32247>>>>>>>        Move False to Err
32248>>>>>>>        If (bExists = True) Begin
32250>>>>>>>            Function_Return False
32251>>>>>>>        End
32251>>>>>>>>
32251>>>>>>>        If (num_arguments > 4) Begin
32253>>>>>>>            Move iPrec to iPrecision
32254>>>>>>>        End
32254>>>>>>>>
32254>>>>>>>        If (iType < -1490) Begin
32256>>>>>>>            Move (iType + 1500) to iType
32257>>>>>>>        End
32257>>>>>>>>
32257>>>>>>>
32257>>>>>>>        Get AutoConnectionIDLogin to bOK
32258>>>>>>>        Move False to Err
32259>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
32260>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
32260>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
32260>>>>>>>        Get piDbType to iDbType
32261>>>>>>>        If (bIsSQLTypeTo = False) Begin
32263>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
32264>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32266>>>>>>>                Move DF_DATE to iType
32267>>>>>>>            End
32267>>>>>>>>
32267>>>>>>>        End
32267>>>>>>>>
32267>>>>>>>
32267>>>>>>>        // Structure_start will change the value of hTable...
32267>>>>>>>        Move hTable to iFile
32268>>>>>>>        Get OpenTableExclusive iFile to bOK
32269>>>>>>>        If (bOK = False) Begin
32271>>>>>>>            Function_Return False
32272>>>>>>>        End
32272>>>>>>>>
32272>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
32275>>>>>>>
32275>>>>>>>        // If the passed column number is higher than the current number of fields
32275>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
32275>>>>>>>        // a new field to the end:
32275>>>>>>>        If (iColumn > iNumberOfFields) Begin
32277>>>>>>>            Move 0 to iColumn
32278>>>>>>>        End
32278>>>>>>>>
32278>>>>>>>
32278>>>>>>>        Set Private.phCurrentTable to hTable
32279>>>>>>>        Set Private.piCurrentField to iColumn
32280>>>>>>>
32280>>>>>>>        Structure_Start iFile
32281>>>>>>>            Create_Field iFile At iColumn
32282>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
32285>>>>>>>            If (bIsSQLTypeTo = False) Begin
32287>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
32290>>>>>>>            End
32290>>>>>>>>
32290>>>>>>>            Else Begin
32291>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
32294>>>>>>>            End
32294>>>>>>>>
32294>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
32295>>>>>>>            If (bIsDateType = False) Begin
32297>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
32300>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
32303>>>>>>>            End
32303>>>>>>>>
32303>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32304>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32306>>>>>>>
32306>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32307>>>>>>>        // If in development environment; create .fd file:
32307>>>>>>>        Open hTable
32309>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
32310>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32311>>>>>>>        If (iCount > 1) Begin
32313>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32314>>>>>>>        End
32314>>>>>>>>
32314>>>>>>>        Get vFolderExists sDDSrcPath to bExists
32315>>>>>>>        If (bExists = True) Begin
32317>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
32318>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
32321>>>>>>>            Get _TableNameOnly sTableName to sTableName
32322>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32324>>>>>>>        End
32324>>>>>>>>
32324>>>>>>>
32324>>>>>>>        // Check for a default value
32324>>>>>>>        Close hTable
32325>>>>>>>
32325>>>>>>>        Function_Return (Err = False)
32326>>>>>>>    End_Function
32327>>>>>>>
32327>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
32327>>>>>>>//        Integer iColumn iCount iFile
32327>>>>>>>//        Boolean bExists bOK
32327>>>>>>>//        String sDdSrcPath sTableName
32327>>>>>>>//
32327>>>>>>>//        Get AutoConnectionIDLogin to bOK
32327>>>>>>>//        Move False to Err
32327>>>>>>>//
32327>>>>>>>//        // Structure_start will change the value of hTable...
32327>>>>>>>//        Move hTable to iFile
32327>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
32327>>>>>>>//
32327>>>>>>>//        Structure_Start iFile
32327>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
32327>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32327>>>>>>>//
32327>>>>>>>//        // If in development environment; create .fd file:
32327>>>>>>>//        Open hTable
32327>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
32327>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32327>>>>>>>//        If (iCount > 1) Begin
32327>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32327>>>>>>>//        End
32327>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
32327>>>>>>>//        If (bExists = True) Begin
32327>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
32327>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
32327>>>>>>>//            Get _TableNameOnly sTableName to sTableName
32327>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32327>>>>>>>//        End
32327>>>>>>>//        Close hTable
32327>>>>>>>//
32327>>>>>>>//        Function_Return (Err = False)
32327>>>>>>>//    End_Function
32327>>>>>>>
32327>>>>>>>    // To update all records for a table column with a fixed value.
32327>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
32329>>>>>>>        Integer iRecs iCurrErr iField iRecord
32329>>>>>>>        Boolean bRetval bOpen
32329>>>>>>>
32329>>>>>>>        Move 0 to iRecs
32330>>>>>>>        Move False to bRetval
32331>>>>>>>        Move Err to iCurrErr
32332>>>>>>>        Move False to Err
32333>>>>>>>
32333>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
32336>>>>>>>        If (bOpen = False) Begin
32338>>>>>>>            Open hTable
32340>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
32343>>>>>>>            If (bOpen = False) Begin
32345>>>>>>>                Function_Return bRetval
32346>>>>>>>            End
32346>>>>>>>>
32346>>>>>>>        End
32346>>>>>>>>
32346>>>>>>>
32346>>>>>>>        Field_Map hTable sFieldName to iField
32348>>>>>>>        If (iField <> 0) Begin
32350>>>>>>>            Set Private.phCurrentTable to hTable
32351>>>>>>>            Set Private.piCurrentField to iField
32352>>>>>>>            Clear hTable
32353>>>>>>>            Repeat
32353>>>>>>>>
32353>>>>>>>                Vfind hTable 0 GT
32355>>>>>>>                If (Found) Begin
32357>>>>>>>                    If (ghoStatusPanel <> 0) Begin
32359>>>>>>>                        Get_Field_Value hTable 0 to iRecord
32362>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
32363>>>>>>>                    End
32363>>>>>>>>
32363>>>>>>>                    Reread hTable
32367>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
32370>>>>>>>                        SaveRecord hTable
32371>>>>>>>                    Unlock
32372>>>>>>>>
32372>>>>>>>                End
32372>>>>>>>>
32372>>>>>>>           Until (not(Found))
32374>>>>>>>        End
32374>>>>>>>>
32374>>>>>>>
32374>>>>>>>        Move (Err = False) to bRetval
32375>>>>>>>        Move iCurrErr to Err
32376>>>>>>>
32376>>>>>>>        Function_Return bRetval
32377>>>>>>>    End_Function
32378>>>>>>>
32378>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
32378>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
32380>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
32380>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
32380>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
32380>>>>>>>
32380>>>>>>>//        Set Private.phCurrentTable to hTable
32380>>>>>>>        Get psDriverID to sDriverID
32381>>>>>>>        Get piDbType to iDbType
32382>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32383>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
32384>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
32385>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
32386>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
32388>>>>>>>            Move True to bIsSqlTable
32389>>>>>>>        End
32389>>>>>>>>
32389>>>>>>>        Move False to bIsOpen
32390>>>>>>>        If (hTable > 0) Begin
32392>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
32395>>>>>>>        End
32395>>>>>>>>
32395>>>>>>>        If (bIsOpen = True) Begin
32397>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
32400>>>>>>>        End
32400>>>>>>>>
32400>>>>>>>        Else Begin
32401>>>>>>>            Get pbRecnum to bRecnumTable
32402>>>>>>>        End
32402>>>>>>>>
32402>>>>>>>
32402>>>>>>>        Move False to Err
32403>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
32404>>>>>>>        Decrement iSize
32405>>>>>>>        for iCount from 0 to iSize
32411>>>>>>>>
32411>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
32412>>>>>>>            If (hTable > 0) Begin
32414>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32415>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32416>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
32419>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
32420>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
32421>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32422>>>>>>>            End
32422>>>>>>>>
32422>>>>>>>            Else Begin
32423>>>>>>>                Move False to bFieldExists
32424>>>>>>>            End
32424>>>>>>>>
32424>>>>>>>
32424>>>>>>>            If (bFieldExists = False) Begin
32426>>>>>>>                Move 0 to iColumn
32427>>>>>>>                Create_Field hTable At iColumn
32428>>>>>>>            End
32428>>>>>>>>
32428>>>>>>>            Else Begin
32429>>>>>>>                Move iCount to iColumn
32430>>>>>>>            End
32430>>>>>>>>
32430>>>>>>>
32430>>>>>>>            Set Private.piCurrentField to iColumn
32431>>>>>>>
32431>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
32432>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
32435>>>>>>>
32435>>>>>>>            Move aColumns[iCount].iType to iType
32436>>>>>>>            Move (not(iType < -1490)) to bNativeType
32437>>>>>>>            If (iType < -1490) Begin
32439>>>>>>>                Move (iType + 1500) to iType
32440>>>>>>>            End
32440>>>>>>>>
32440>>>>>>>
32440>>>>>>>            If (bIsSqlTable = True) Begin
32442>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
32444>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
32445>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
32448>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
32451>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
32454>>>>>>>
32454>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
32455>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
32457>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
32458>>>>>>>                    End
32458>>>>>>>>
32458>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
32461>>>>>>>
32461>>>>>>>                End
32461>>>>>>>>
32461>>>>>>>                Else Begin
32462>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
32465>>>>>>>                End
32465>>>>>>>>
32465>>>>>>>            End
32465>>>>>>>>
32465>>>>>>>            Else Begin
32466>>>>>>>                If (bCreating = False) Begin
32468>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
32469>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32471>>>>>>>                        Move DF_DATE to iType
32472>>>>>>>                    End
32472>>>>>>>>
32472>>>>>>>                End
32472>>>>>>>>
32472>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
32475>>>>>>>            End
32475>>>>>>>>
32475>>>>>>>
32475>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
32476>>>>>>>            If (bIsDateType = False) Begin
32478>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
32481>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
32484>>>>>>>            End
32484>>>>>>>>
32484>>>>>>>
32484>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
32486>>>>>>>                Move 0 to iIndex
32487>>>>>>>                Create_Index hTable at iIndex
32488>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
32491>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
32494>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
32497>>>>>>>
32497>>>>>>>                // If we have an identity table - we must create a primary_key table.
32497>>>>>>>                If (bIsSqlTable = True) Begin
32499>>>>>>>                End
32499>>>>>>>>
32499>>>>>>>            End
32499>>>>>>>>
32499>>>>>>>        Loop
32500>>>>>>>>
32500>>>>>>>
32500>>>>>>>        Function_Return (Err = False)
32501>>>>>>>    End_Function
32502>>>>>>>
32502>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
32502>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
32504>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
32504>>>>>>>        Boolean bOK bIsSqlTable
32504>>>>>>>        String sFieldNameTo
32504>>>>>>>
32504>>>>>>>        If (num_arguments > 4) Begin
32506>>>>>>>            Move iPrec to iPrecFrom
32507>>>>>>>        End
32507>>>>>>>>
32507>>>>>>>        If (iTypeFrom < -1490) Begin
32509>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
32510>>>>>>>        End
32510>>>>>>>>
32510>>>>>>>
32510>>>>>>>        Get AutoConnectionIDLogin to bOK
32511>>>>>>>        Move False to Err
32512>>>>>>>        Get OpenTableExclusive hTable to bOK
32513>>>>>>>        If (bOK = False) Begin
32515>>>>>>>            Function_Return False
32516>>>>>>>        End
32516>>>>>>>>
32516>>>>>>>
32516>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32517>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32518>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
32520>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32521>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32522>>>>>>>        If (Err = True) Begin
32524>>>>>>>            Function_Return False
32525>>>>>>>        End
32525>>>>>>>>
32525>>>>>>>
32525>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
32528>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
32529>>>>>>>        If (bIsSqlTable = False) Begin
32531>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
32534>>>>>>>        End
32534>>>>>>>>
32534>>>>>>>        Else Begin
32535>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
32538>>>>>>>        End
32538>>>>>>>>
32538>>>>>>>        // Let the driver decide the other values;
32538>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
32541>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
32544>>>>>>>
32544>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
32546>>>>>>>            Function_Return False
32547>>>>>>>        End
32547>>>>>>>>
32547>>>>>>>
32547>>>>>>>        Set Private.phCurrentTable to hTable
32548>>>>>>>        Set Private.piCurrentField to iColumn
32549>>>>>>>
32549>>>>>>>        Structure_Start hTable
32550>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
32553>>>>>>>//            If (bIsSqlTable = False) Begin
32553>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
32556>>>>>>>//            End
32556>>>>>>>//            Else Begin
32556>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
32556>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
32556>>>>>>>//            End
32556>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
32559>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
32562>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32563>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32565>>>>>>>
32565>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32566>>>>>>>        Function_Return (Err = False)
32567>>>>>>>    End_Function
32568>>>>>>>
32568>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
32568>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
32570>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
32570>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
32570>>>>>>>        String sFieldNameTo sDriverIDTo
32570>>>>>>>        tColumnType ColumnType
32570>>>>>>>        tColumnType ColumnType
32570>>>>>>>
32570>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
32571>>>>>>>        Get piDbType to iDbType
32572>>>>>>>        If (num_arguments > 4) Begin
32574>>>>>>>            Move iPrec to iPrecFrom
32575>>>>>>>            Move iOpt  to iOptionFrom
32576>>>>>>>        End
32576>>>>>>>>
32576>>>>>>>        If (iTypeFrom < -1490) Begin
32578>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
32579>>>>>>>        End
32579>>>>>>>>
32579>>>>>>>
32579>>>>>>>        Get AutoConnectionIDLogin to bOK
32580>>>>>>>        Move False to Err
32581>>>>>>>        Close hTable
32582>>>>>>>        Get OpenTableExclusive hTable to bOK
32583>>>>>>>        If (bOK = False) Begin
32585>>>>>>>            Function_Return False
32586>>>>>>>        End
32586>>>>>>>>
32586>>>>>>>
32586>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
32589>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
32592>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
32593>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32595>>>>>>>            Move DF_DATE to iDataFlexType
32596>>>>>>>        End
32596>>>>>>>>
32596>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
32599>>>>>>>
32599>>>>>>>        If (bIsSQLTableTo = True) Begin
32601>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
32604>>>>>>>        End
32604>>>>>>>>
32604>>>>>>>        Else Begin
32605>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
32608>>>>>>>        End
32608>>>>>>>>
32608>>>>>>>
32608>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
32611>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
32614>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
32617>>>>>>>
32617>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
32617>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
32617>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
32619>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
32620>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32622>>>>>>>                Move DF_DATE to iTypeTo  
32623>>>>>>>            End
32623>>>>>>>>
32623>>>>>>>        End
32623>>>>>>>>
32623>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
32626>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
32627>>>>>>>        End
32627>>>>>>>>
32627>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
32628>>>>>>>
32628>>>>>>>        If (bCompareDate_DateTime = False) Begin
32630>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
32631>>>>>>>            If (bSkip = True) Begin
32633>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
32635>>>>>>>                    Function_Return True
32636>>>>>>>                End
32636>>>>>>>>
32636>>>>>>>            End
32636>>>>>>>>
32636>>>>>>>        End
32636>>>>>>>>
32636>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
32639>>>>>>>            Function_Return True
32640>>>>>>>        End
32640>>>>>>>>
32640>>>>>>>
32640>>>>>>>        Set Private.phCurrentTable to hTable
32641>>>>>>>        Set Private.piCurrentField to iColumn
32642>>>>>>>
32642>>>>>>>        Structure_Start hTable
32643>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
32645>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
32648>>>>>>>            End
32648>>>>>>>>
32648>>>>>>>
32648>>>>>>>            If (bIsSameDataType = False) Begin
32650>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
32653>>>>>>>                If (bIsSQLTableTo = True) Begin
32655>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
32658>>>>>>>                End
32658>>>>>>>>
32658>>>>>>>            End
32658>>>>>>>>
32658>>>>>>>
32658>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
32660>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
32663>>>>>>>            End
32663>>>>>>>>
32663>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
32665>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
32668>>>>>>>            End
32668>>>>>>>>
32668>>>>>>>
32668>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
32670>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
32670>>>>>>>                If (bRecnumTable = True) Begin
32672>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
32675>>>>>>>                End
32675>>>>>>>>
32675>>>>>>>
32675>>>>>>>                // We might need to create an index here.
32675>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
32675>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
32675>>>>>>>                // index update checking logic.
32675>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
32678>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
32680>>>>>>>                    Create_Index hTable At iIndex
32681>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
32684>>>>>>>                End
32684>>>>>>>>
32684>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
32687>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
32690>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
32693>>>>>>>                If (bIsSQLTableTo = True) Begin
32695>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
32698>>>>>>>                End
32698>>>>>>>>
32698>>>>>>>            End
32698>>>>>>>>
32698>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32699>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32701>>>>>>>
32701>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32702>>>>>>>        Function_Return (Err = False)
32703>>>>>>>    End_Function
32704>>>>>>>
32704>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
32706>>>>>>>        Boolean bOK
32706>>>>>>>
32706>>>>>>>        Get AutoConnectionIDLogin to bOK
32707>>>>>>>        Move False to Err
32708>>>>>>>        Get OpenTableExclusive hTable to bOK
32709>>>>>>>        If (bOK = False) Begin
32711>>>>>>>            Function_Return False
32712>>>>>>>        End
32712>>>>>>>>
32712>>>>>>>
32712>>>>>>>        Structure_Start hTable
32713>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
32716>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32717>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32719>>>>>>>
32719>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32720>>>>>>>        Function_Return (Err = False)
32721>>>>>>>    End_Function
32722>>>>>>>
32722>>>>>>>    // To move an existing field to another position in a table.
32722>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
32724>>>>>>>        String sColumn sDriverID
32724>>>>>>>        Integer iType
32724>>>>>>>        Boolean bOK bIsDate
32724>>>>>>>
32724>>>>>>>        Close hTable
32725>>>>>>>        Get AutoConnectionIDLogin to bOK
32726>>>>>>>        Get OpenTableExclusive hTable to bOK
32727>>>>>>>        If (bOK = False) Begin
32729>>>>>>>            Function_Return False
32730>>>>>>>        End
32730>>>>>>>>
32730>>>>>>>
32730>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
32733>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
32735>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
32736>>>>>>>>
32736>>>>>>>            Function_Return False
32737>>>>>>>        End
32737>>>>>>>>
32737>>>>>>>
32737>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
32740>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
32743>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
32744>>>>>>>
32744>>>>>>>        Set Private.phCurrentTable to hTable
32745>>>>>>>        Set Private.piCurrentField to iOld
32746>>>>>>>
32746>>>>>>>//        If (bIsDate = False) Begin
32746>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
32746>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
32746>>>>>>>//        End
32746>>>>>>>//        Else Begin
32746>>>>>>>//            Move 6 to iLength
32746>>>>>>>//            Move 0 to iPrecision
32746>>>>>>>//        End
32746>>>>>>>
32746>>>>>>>        Move False to Err
32747>>>>>>>
32747>>>>>>>        Structure_Start hTable
32748>>>>>>>            Delete_Field hTable iOld
32749>>>>>>>            Create_Field hTable At iNew
32750>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
32753>>>>>>>
32753>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
32756>>>>>>>            If (bIsSQLType = False) Begin
32758>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
32761>>>>>>>            End
32761>>>>>>>>
32761>>>>>>>            Else Begin
32762>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
32765>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
32765>>>>>>>            End
32765>>>>>>>>
32765>>>>>>>
32765>>>>>>>            If (bIsDate = False) Begin
32767>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
32770>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
32773>>>>>>>            End
32773>>>>>>>>
32773>>>>>>>
32773>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32774>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32776>>>>>>>
32776>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32777>>>>>>>        Function_Return (Err = False)
32778>>>>>>>    End_Function
32779>>>>>>>
32779>>>>>>>    // Deletes a column name for the passed table number (and column number).
32779>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
32781>>>>>>>        Integer iColumn
32781>>>>>>>        Boolean bOK
32781>>>>>>>
32781>>>>>>>        Get AutoConnectionIDLogin to bOK
32782>>>>>>>        Move False to Err
32783>>>>>>>        Close hTable
32784>>>>>>>        Get OpenTableExclusive hTable to bOK
32785>>>>>>>        If (bOK = False) Begin
32787>>>>>>>            Function_Return False
32788>>>>>>>        End
32788>>>>>>>>
32788>>>>>>>
32788>>>>>>>        If (not(Err)) Begin
32790>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32791>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32792>>>>>>>            Field_Map hTable sFieldName to iColumn
32794>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
32795>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32796>>>>>>>            If (iColumn = 0) Begin
32798>>>>>>>                Move 0 to LastErr
32799>>>>>>>                Function_Return False
32800>>>>>>>            End
32800>>>>>>>>
32800>>>>>>>            Move False to Err
32801>>>>>>>
32801>>>>>>>            Set Private.phCurrentTable to hTable
32802>>>>>>>            Set Private.piCurrentField to iColumn
32803>>>>>>>
32803>>>>>>>            Structure_Start hTable
32804>>>>>>>                Delete_Field hTable iColumn
32805>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
32806>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32808>>>>>>>            Set Action_Text of ghoStatusPanel to ""
32809>>>>>>>        End
32809>>>>>>>>
32809>>>>>>>        Else Begin
32810>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
32811>>>>>>>>
32811>>>>>>>        End
32811>>>>>>>>
32811>>>>>>>
32811>>>>>>>        Function_Return (Err = False)
32812>>>>>>>    End_Function
32813>>>>>>>
32813>>>>>>>    // Renames a field for the passed table number & old field name & new field name
32813>>>>>>>    // Returns True if no errors occured.
32813>>>>>>>    // Sample usage:
32813>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
32813>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
32815>>>>>>>        Integer iField
32815>>>>>>>        Boolean bOK bExists bIsOpen
32815>>>>>>>
32815>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
32816>>>>>>>        If (bExists = True) Begin
32818>>>>>>>            Function_Return False
32819>>>>>>>        End
32819>>>>>>>>
32819>>>>>>>
32819>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
32819>>>>>>>        //       opened exclusively, so we first open it in normal mode.
32819>>>>>>>        Close hTable
32820>>>>>>>        Open hTable
32822>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
32825>>>>>>>        If (bIsOpen = False) Begin
32827>>>>>>>            Function_Return False
32828>>>>>>>        End
32828>>>>>>>>
32828>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32829>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32830>>>>>>>        Field_Map hTable sOldFieldName to iField
32832>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32833>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32834>>>>>>>
32834>>>>>>>        Get AutoConnectionIDLogin to bOK
32835>>>>>>>        Get OpenTableExclusive hTable to bOK
32836>>>>>>>        If (bOK = False) Begin
32838>>>>>>>            Function_Return False
32839>>>>>>>        End
32839>>>>>>>>
32839>>>>>>>
32839>>>>>>>        Move False to Err
32840>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
32841>>>>>>>        Set Private.phCurrentTable to hTable
32842>>>>>>>        Set Private.piCurrentField to iField
32843>>>>>>>
32843>>>>>>>        If (iField > 0) Begin
32845>>>>>>>            Structure_Start hTable
32846>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
32849>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
32850>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32852>>>>>>>        End
32852>>>>>>>>
32852>>>>>>>        Else Begin
32853>>>>>>>            Move 0 to LastErr
32854>>>>>>>            Move False to Err
32855>>>>>>>        End
32855>>>>>>>>
32855>>>>>>>
32855>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32856>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
32857>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32858>>>>>>>
32858>>>>>>>        Function_Return (Err = False)
32859>>>>>>>    End_Function
32860>>>>>>>
32860>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
32862>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
32862>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
32863>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
32863>>>>>>>        Boolean bRenameField
32863>>>>>>>
32863>>>>>>>        Open hTable
32865>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32866>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32867>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
32868>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
32871>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
32872>>>>>>>        Decrement iSize
32873>>>>>>>        for iCount from 0 to iSize
32879>>>>>>>>
32879>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
32881>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32882>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32883>>>>>>>
32883>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
32885>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
32887>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
32888>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
32889>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
32891>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
32892>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
32893>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
32894>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
32895>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
32896>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
32897>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
32898>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
32899>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
32900>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
32901>>>>>>>                        Increment iItem
32902>>>>>>>                    End
32902>>>>>>>>
32902>>>>>>>                End
32902>>>>>>>>
32902>>>>>>>            End
32902>>>>>>>>
32902>>>>>>>        Loop
32903>>>>>>>>
32903>>>>>>>
32903>>>>>>>        Move False to Err
32904>>>>>>>        Move 0 to LastErr
32905>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32906>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32907>>>>>>>        Function_Return aAPIColumnsToInsert
32908>>>>>>>    End_Function
32909>>>>>>>
32909>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
32911>>>>>>>        Integer iSize iCount
32911>>>>>>>        Boolean bOK
32911>>>>>>>        tAPIColumn[] aColumnsTo
32911>>>>>>>        tAPIColumn[] aColumnsTo
32912>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32912>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32913>>>>>>>
32913>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
32914>>>>>>>        If (iSize = 0) Begin
32916>>>>>>>            Function_Return True
32917>>>>>>>        End
32917>>>>>>>>
32917>>>>>>>
32917>>>>>>>        Move False to Err
32918>>>>>>>        Decrement iSize
32919>>>>>>>        for iCount from 0 to iSize
32925>>>>>>>>
32925>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
32926>>>>>>>        Loop
32927>>>>>>>>
32927>>>>>>>
32927>>>>>>>        Function_Return bOK
32928>>>>>>>    End_Function
32929>>>>>>>
32929>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
32929>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
32931>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
32931>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
32932>>>>>>>        Integer iSize iCount iItem iShouldMove
32932>>>>>>>
32932>>>>>>>        Move 0 to iItem
32933>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
32934>>>>>>>        Decrement iSize
32935>>>>>>>        for iCount from 0 to iSize
32941>>>>>>>>
32941>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
32943>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
32944>>>>>>>                If (iShouldMove <> -1) Begin
32946>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
32947>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
32948>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
32949>>>>>>>                    Increment iItem
32950>>>>>>>                End
32950>>>>>>>>
32950>>>>>>>            End
32950>>>>>>>>
32950>>>>>>>        Loop
32951>>>>>>>>
32951>>>>>>>
32951>>>>>>>        Move False to Err
32952>>>>>>>        Move 0 to LastErr
32953>>>>>>>        Function_Return aAPIColumnsToMove
32954>>>>>>>    End_Function
32955>>>>>>>
32955>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
32957>>>>>>>        Integer iSize iCount
32957>>>>>>>        Boolean bOK
32957>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32957>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32958>>>>>>>
32958>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
32959>>>>>>>        If (iSize = 0) Begin
32961>>>>>>>            Function_Return True
32962>>>>>>>        End
32962>>>>>>>>
32962>>>>>>>
32962>>>>>>>        Move False to Err
32963>>>>>>>        Decrement iSize
32964>>>>>>>        for iCount from 0 to iSize
32970>>>>>>>>
32970>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32971>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
32972>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
32974>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
32975>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
32976>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32977>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
32978>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
32980>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
32981>>>>>>>                    Decrement iSize
32982>>>>>>>                    Move 0 to iCount
32983>>>>>>>                End
32983>>>>>>>>
32983>>>>>>>            End
32983>>>>>>>>
32983>>>>>>>        Loop
32984>>>>>>>>
32984>>>>>>>
32984>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32985>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
32986>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
32988>>>>>>>            Move 0 to LastErr
32989>>>>>>>        End
32989>>>>>>>>
32989>>>>>>>        Function_Return bOK
32990>>>>>>>    End_Function
32991>>>>>>>
32991>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
32991>>>>>>>    // We then assume this field should be renamed.
32991>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
32991>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
32991>>>>>>>//
32991>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32991>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
32991>>>>>>>//
32991>>>>>>>//        If (bDifferentFieldNames = True) Begin
32991>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
32991>>>>>>>//            If (bShouldBeRenamed = False) Begin
32991>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32991>>>>>>>//                Function_Return False
32991>>>>>>>//            End
32991>>>>>>>//
32991>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
32991>>>>>>>//            If (bShouldBeRenamed = False) Begin
32991>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32991>>>>>>>//                Function_Return False
32991>>>>>>>//            End
32991>>>>>>>//
32991>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
32991>>>>>>>//            If (bShouldBeRenamed = False) Begin
32991>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32991>>>>>>>//                Function_Return False
32991>>>>>>>//            End
32991>>>>>>>//
32991>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
32991>>>>>>>//            If (bShouldBeRenamed = False) Begin
32991>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32991>>>>>>>//                Function_Return False
32991>>>>>>>//            End
32991>>>>>>>//        End
32991>>>>>>>//
32991>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
32991>>>>>>>//        Function_Return True
32991>>>>>>>//    End_Function
32991>>>>>>>
32991>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
32991>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
32991>>>>>>>    // - The "FROM" field name is <> "TO" field name
32991>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
32991>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
32991>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
32993>>>>>>>        Boolean bShouldRename
32993>>>>>>>        String sFieldNameFrom sFieldNameTo
32993>>>>>>>
32993>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
32994>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
32995>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
32997>>>>>>>            Function_Return False
32998>>>>>>>        End
32998>>>>>>>>
32998>>>>>>>
32998>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
32999>>>>>>>//        If (bShouldRename = False) Begin
32999>>>>>>>//            Function_Return False
32999>>>>>>>//        End
32999>>>>>>>//
32999>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
32999>>>>>>>//            Function_Return True
32999>>>>>>>//        End
32999>>>>>>>
32999>>>>>>>        Function_Return bShouldRename
33000>>>>>>>    End_Function
33001>>>>>>>
33001>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
33001>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
33001>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
33003>>>>>>>        Integer iCount iSize iRetval
33003>>>>>>>        String sFieldNameFrom
33003>>>>>>>
33003>>>>>>>        Move -1 to iRetval
33004>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
33006>>>>>>>            Function_Return iRetval
33007>>>>>>>        End
33007>>>>>>>>
33007>>>>>>>
33007>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
33008>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
33009>>>>>>>        Decrement iSize
33010>>>>>>>        for iCount from 0 to iSize
33016>>>>>>>>
33016>>>>>>>            // We're only interested in fields other than the passed field/column number:
33016>>>>>>>            If (iCount <> iColumn) Begin
33018>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
33020>>>>>>>                    Move (iCount + 1) to iRetval
33021>>>>>>>                End
33021>>>>>>>>
33021>>>>>>>            End
33021>>>>>>>>
33021>>>>>>>        Loop
33022>>>>>>>>
33022>>>>>>>
33022>>>>>>>        Move 0 to LastErr
33023>>>>>>>        Function_Return iRetval
33024>>>>>>>    End_Function
33025>>>>>>>
33025>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
33027>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
33027>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
33028>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
33028>>>>>>>        Boolean bRenameField
33028>>>>>>>
33028>>>>>>>        Open hTable
33030>>>>>>>        Move 0 to iItem
33031>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
33032>>>>>>>        Decrement iSize
33033>>>>>>>        for iCount from 0 to iSize
33039>>>>>>>>
33039>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
33041>>>>>>>                // Check if the field exists in another position (other field number)
33041>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
33042>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
33043>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
33045>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
33046>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
33047>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
33048>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
33049>>>>>>>                    Increment iItem
33050>>>>>>>                End
33050>>>>>>>>
33050>>>>>>>            End
33050>>>>>>>>
33050>>>>>>>        Loop
33051>>>>>>>>
33051>>>>>>>
33051>>>>>>>        Move False to Err
33052>>>>>>>        Move 0 to LastErr
33053>>>>>>>        Function_Return aAPIColumnsToRename
33054>>>>>>>    End_Function
33055>>>>>>>
33055>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
33057>>>>>>>        Integer iSize iCount
33057>>>>>>>        Boolean bOK
33057>>>>>>>        tAPIColumn[] aColumnsTo
33057>>>>>>>        tAPIColumn[] aColumnsTo
33058>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
33058>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
33059>>>>>>>
33059>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
33060>>>>>>>        If (iSize = 0) Begin
33062>>>>>>>            Function_Return True
33063>>>>>>>        End
33063>>>>>>>>
33063>>>>>>>
33063>>>>>>>        Move False to Err
33064>>>>>>>        Decrement iSize
33065>>>>>>>        For iCount from 0 to iSize
33071>>>>>>>>
33071>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33072>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
33073>>>>>>>        Loop
33074>>>>>>>>
33074>>>>>>>
33074>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
33075>>>>>>>        Function_Return bOK
33076>>>>>>>    End_Function
33077>>>>>>>
33077>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
33079>>>>>>>        Boolean bDateType
33079>>>>>>>
33079>>>>>>>        If (bIsSQLTableTo = True) Begin
33081>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
33082>>>>>>>        End
33082>>>>>>>>
33082>>>>>>>        Else Begin
33083>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
33084>>>>>>>        End
33084>>>>>>>>
33084>>>>>>>
33084>>>>>>>        Function_Return bDateType
33085>>>>>>>    End_Function
33086>>>>>>>
33086>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
33088>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
33088>>>>>>>        Integer iCount2 iColumn2
33088>>>>>>>        Handle hFile
33088>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
33088>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
33088>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
33088>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
33088>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
33093>>>>>>>        tColumnType ColumnType
33093>>>>>>>        tColumnType ColumnType
33093>>>>>>>
33093>>>>>>>        Move False to Err
33094>>>>>>>        Close hTable
33095>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
33096>>>>>>>        If (bIsOpen = False) Begin
33098>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
33099>>>>>>>>
33099>>>>>>>            Function_Return False
33100>>>>>>>        End 
33100>>>>>>>>
33100>>>>>>>        
33100>>>>>>>        Get piDbType to iDbType
33101>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
33104>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
33105>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
33106>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
33109>>>>>>>
33109>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33110>>>>>>>
33110>>>>>>>        // Before we start to change the table we need to do three things;
33110>>>>>>>        // 1) Insert any new fields
33110>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
33111>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
33113>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
33114>>>>>>>            If (bOK = False) Begin
33116>>>>>>>                Function_Return False
33117>>>>>>>            End
33117>>>>>>>>
33117>>>>>>>            // Update info with changes made.
33117>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
33118>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33119>>>>>>>        End
33119>>>>>>>>
33119>>>>>>>
33119>>>>>>>        // 2) Move fields with same names
33119>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
33120>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
33122>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
33123>>>>>>>            If (bOK = False) Begin
33125>>>>>>>                Function_Return False
33126>>>>>>>            End
33126>>>>>>>>
33126>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
33127>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33128>>>>>>>        End
33128>>>>>>>>
33128>>>>>>>        
33128>>>>>>>        // 3) Rename fields
33128>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
33129>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
33131>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
33132>>>>>>>            If (bOK = False) Begin
33134>>>>>>>                Function_Return False
33135>>>>>>>            End
33135>>>>>>>>
33135>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
33136>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33137>>>>>>>        End
33137>>>>>>>>
33137>>>>>>>
33137>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
33137>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
33137>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
33137>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
33137>>>>>>>//            If (bOK = False) Begin
33137>>>>>>>//                Function_Return False
33137>>>>>>>//            End
33137>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
33137>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33137>>>>>>>//        End
33137>>>>>>>
33137>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
33137>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
33139>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
33140>>>>>>>            If (bIsSame = True) Begin
33142>>>>>>>                Function_Return True
33143>>>>>>>            End
33143>>>>>>>>
33143>>>>>>>        End
33143>>>>>>>>
33143>>>>>>>
33143>>>>>>>        // We can now continue to make standard field changes:
33143>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
33144>>>>>>>        Set Private.phCurrentTable to hTable
33145>>>>>>>        Move hTable to hFile
33146>>>>>>>        Structure_Start hFile sDriverIDTo
33147>>>>>>>
33147>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
33148>>>>>>>            Decrement iColumns
33149>>>>>>>            for iCount from 0 to iColumns
33155>>>>>>>>
33155>>>>>>>                Send DoAdvance of ghoProgressBar
33156>>>>>>>
33156>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
33157>>>>>>>                Set Private.piCurrentField                  to iColumn
33158>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
33159>>>>>>>                If (bIsSame = False) Begin
33161>>>>>>>
33161>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
33162>>>>>>>                    If (bFieldExistsFrom = True) Begin
33164>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
33165>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
33166>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
33167>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
33168>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
33169>>>>>>>
33169>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
33170>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
33171>>>>>>>                        If (iTypeFrom < -1490) Begin
33173>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
33174>>>>>>>                        End
33174>>>>>>>>
33174>>>>>>>
33174>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
33174>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
33174>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
33176>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
33177>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
33179>>>>>>>                                Move DF_DATE to iTypeFrom
33180>>>>>>>                            End
33180>>>>>>>>
33180>>>>>>>                        End
33180>>>>>>>>
33180>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
33183>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
33184>>>>>>>                        End
33184>>>>>>>>
33184>>>>>>>
33184>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
33185>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
33186>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
33187>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
33188>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
33189>>>>>>>
33189>>>>>>>                        Move False to bSkipTypeChange
33190>>>>>>>                        If (bCompareDate_DateTime = False) Begin
33192>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
33193>>>>>>>                        End
33193>>>>>>>>
33193>>>>>>>
33193>>>>>>>                        If (bFieldExistsTo = False) Begin
33195>>>>>>>                            Move 0 to iColumn
33196>>>>>>>                            Create_Field hFile At iColumn
33197>>>>>>>                            Set Private.piCurrentField to iColumn
33198>>>>>>>                        End
33198>>>>>>>>
33198>>>>>>>
33198>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
33200>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
33203>>>>>>>                        End
33203>>>>>>>>
33203>>>>>>>
33203>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
33205>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
33208>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
33209>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
33211>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
33212>>>>>>>                            End
33212>>>>>>>>
33212>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
33215>>>>>>>                        End
33215>>>>>>>>
33215>>>>>>>
33215>>>>>>>                        If (bSkipTypeChange = False) Begin
33217>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
33219>>>>>>>                                If (bIsSQLTableTo = True) Begin
33221>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
33224>>>>>>>                                End
33224>>>>>>>>
33224>>>>>>>                                Else Begin                                                   
33225>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
33227>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
33228>>>>>>>                                    End
33228>>>>>>>>
33228>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
33231>>>>>>>                                End
33231>>>>>>>>
33231>>>>>>>                            End
33231>>>>>>>>
33231>>>>>>>                        End
33231>>>>>>>>
33231>>>>>>>
33231>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
33232>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
33232>>>>>>>                        If (bIsDateType = False) Begin
33234>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
33236>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
33239>>>>>>>                            End
33239>>>>>>>>
33239>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
33241>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
33244>>>>>>>                            End
33244>>>>>>>>
33244>>>>>>>                        End
33244>>>>>>>>
33244>>>>>>>
33244>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
33246>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
33246>>>>>>>                            If (bRecnumTable = True) Begin
33248>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
33251>>>>>>>                            End
33251>>>>>>>>
33251>>>>>>>
33251>>>>>>>                            // We might need to create an index here.
33251>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
33251>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
33251>>>>>>>                            // index update checking logic.
33251>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
33254>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
33256>>>>>>>                                Create_Index hFile at iIndex
33257>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
33260>>>>>>>                            End
33260>>>>>>>>
33260>>>>>>>
33260>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
33263>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
33266>>>>>>>                                // Note: The order of these two are crucial!
33266>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
33269>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
33272>>>>>>>                        End
33272>>>>>>>>
33272>>>>>>>                    End
33272>>>>>>>>
33272>>>>>>>                    Else Begin
33273>>>>>>>                        Delete_Field hFile iColumn
33274>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
33275>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
33276>>>>>>>                        Decrement iCount2
33277>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
33277>>>>>>>                        // starting with the array number we just deleted the field for.
33277>>>>>>>                        for iColumn2 from iCount to iCount2
33283>>>>>>>>
33283>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
33284>>>>>>>                        Loop
33285>>>>>>>>
33285>>>>>>>                        Decrement iCount
33286>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33287>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
33288>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
33290>>>>>>>                            Move iColumns to iCount 
33291>>>>>>>                        End
33291>>>>>>>>
33291>>>>>>>                    End
33291>>>>>>>>
33291>>>>>>>                End
33291>>>>>>>>
33291>>>>>>>            Loop
33292>>>>>>>>
33292>>>>>>>
33292>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33293>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33295>>>>>>>
33295>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33296>>>>>>>        Function_Return (Err = False)
33297>>>>>>>    End_Function
33298>>>>>>>
33298>>>>>>>    // * Dummy function for the Studio's Code Explorer *
33298>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
33300>>>>>>>        Function_Return False
33301>>>>>>>    End_Function
33302>>>>>>>
33302>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
33302>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
33302>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
33302>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
33304>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
33304>>>>>>>        String sDriverID
33304>>>>>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
33304>>>>>>>
33304>>>>>>>        Get AutoConnectionIDLogin to bOK
33305>>>>>>>        Get OpenTableExclusive hTable to bOK
33306>>>>>>>        If (bOK = False) Begin
33308>>>>>>>            Function_Return False
33309>>>>>>>        End
33309>>>>>>>>
33309>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33312>>>>>>>
33312>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33313>>>>>>>            If (bIsSQLTable = True) Begin
33315>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33318>>>>>>>            End
33318>>>>>>>>
33318>>>>>>>
33318>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
33321>>>>>>>            Move (iIndexSegments > 0) to bExists
33322>>>>>>>        If (bExists = True) Begin
33324>>>>>>>            Function_Return True
33325>>>>>>>        End
33325>>>>>>>>
33325>>>>>>>
33325>>>>>>>        Move -1 to iSegment1
33326>>>>>>>        Move -1 to iSegment2
33327>>>>>>>        Move -1 to iSegment3
33328>>>>>>>        Move -1 to iSegment4
33329>>>>>>>        Move -1 to iSegment5
33330>>>>>>>        Move -1 to iSegment6
33331>>>>>>>        Move -1 to iSegment7
33332>>>>>>>        Move -1 to iSegment8
33333>>>>>>>        Move -1 to iSegment9
33334>>>>>>>        Move -1 to iSegment10
33335>>>>>>>
33335>>>>>>>        If (num_arguments > 3) Begin
33337>>>>>>>            Move iSgmnt1 to iSegment1
33338>>>>>>>        End
33338>>>>>>>>
33338>>>>>>>        If (num_arguments > 4) Begin
33340>>>>>>>            Move iSgmnt2 to iSegment2
33341>>>>>>>        End
33341>>>>>>>>
33341>>>>>>>        If (num_arguments > 5) Begin
33343>>>>>>>            Move iSgmnt3 to iSegment3
33344>>>>>>>        End
33344>>>>>>>>
33344>>>>>>>        If (num_arguments > 6) Begin
33346>>>>>>>            Move iSgmnt4 to iSegment4
33347>>>>>>>        End
33347>>>>>>>>
33347>>>>>>>        If (num_arguments > 7) Begin
33349>>>>>>>            Move iSgmnt5 to iSegment5
33350>>>>>>>        End
33350>>>>>>>>
33350>>>>>>>        If (num_arguments > 8) Begin
33352>>>>>>>            Move iSgmnt6 to iSegment6
33353>>>>>>>        End
33353>>>>>>>>
33353>>>>>>>        If (num_arguments > 9) Begin
33355>>>>>>>            Move iSgmnt7 to iSegment7
33356>>>>>>>        End
33356>>>>>>>>
33356>>>>>>>        If (num_arguments > 10) Begin
33358>>>>>>>            Move iSgmnt8 to iSegment8
33359>>>>>>>        End
33359>>>>>>>>
33359>>>>>>>        If (num_arguments > 11) Begin
33361>>>>>>>            Move iSgmnt9 to iSegment9
33362>>>>>>>        End
33362>>>>>>>>
33362>>>>>>>        If (num_arguments > 12) Begin
33364>>>>>>>            Move iSgmnt10 to iSegment10
33365>>>>>>>        End
33365>>>>>>>>
33365>>>>>>>
33365>>>>>>>        Move False to Err
33366>>>>>>>        Move hTable to iTableNo
33367>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33368>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
33369>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
33370>>>>>>>
33370>>>>>>>        // We start by deleting the index, if it exists.
33370>>>>>>>        If (bExists = True) Begin
33372>>>>>>>            Structure_Start hTable sDriverID
33373>>>>>>>                Delete_Index iTableNo iIndex
33374>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
33375>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33377>>>>>>>        End
33377>>>>>>>>
33377>>>>>>>
33377>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
33378>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
33379>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
33380>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33381>>>>>>>        Move False to Err
33382>>>>>>>        Move 0 to LastErr
33383>>>>>>>
33383>>>>>>>        // Need to re-open if index deleted.
33383>>>>>>>        Move iTableNo to hTable
33384>>>>>>>        Get OpenTableExclusive hTable to bOK
33385>>>>>>>        If (bOK = False) Begin
33387>>>>>>>            Function_Return False
33388>>>>>>>        End
33388>>>>>>>>
33388>>>>>>>
33388>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33389>>>>>>>        Structure_Start hTable sDriverID
33390>>>>>>>            Create_Index hTable At iIndex
33391>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
33394>>>>>>>
33394>>>>>>>            If (iSgmnt1 <> -1) Begin
33396>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
33399>>>>>>>            End
33399>>>>>>>>
33399>>>>>>>            If (iSegment2 <> -1) Begin
33401>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
33404>>>>>>>            End
33404>>>>>>>>
33404>>>>>>>            If (iSegment3 <> -1) Begin
33406>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
33409>>>>>>>            End
33409>>>>>>>>
33409>>>>>>>            If (iSegment4 <> -1) Begin
33411>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
33414>>>>>>>            End
33414>>>>>>>>
33414>>>>>>>            If (iSegment5 <> -1) Begin
33416>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
33419>>>>>>>            End
33419>>>>>>>>
33419>>>>>>>            If (iSegment6 <> -1) Begin
33421>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
33424>>>>>>>            End
33424>>>>>>>>
33424>>>>>>>            If (iSegment7 <> -1) Begin
33426>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
33429>>>>>>>            End
33429>>>>>>>>
33429>>>>>>>            If (iSegment8 <> -1) Begin
33431>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
33434>>>>>>>            End
33434>>>>>>>>
33434>>>>>>>            If (iSegment9 <> -1) Begin
33436>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
33439>>>>>>>            End
33439>>>>>>>>
33439>>>>>>>            If (iSegment10 <> -1) Begin
33441>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
33444>>>>>>>            End
33444>>>>>>>>
33444>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33445>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33447>>>>>>>
33447>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33448>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33449>>>>>>>
33449>>>>>>>        Function_Return (Err = False)
33450>>>>>>>    End_Function
33451>>>>>>>
33451>>>>>>>    // Example:
33451>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
33451>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
33451>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
33453>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
33453>>>>>>>        String sDriverID
33453>>>>>>>        Boolean bOK bIsSQLTable
33453>>>>>>>
33453>>>>>>>        Get AutoConnectionIDLogin to bOK
33454>>>>>>>
33454>>>>>>>        Move False to Err
33455>>>>>>>        Move hTable to iTableNo
33456>>>>>>>        Get OpenTableExclusive hTable to bOK
33457>>>>>>>        If (bOK = False) Begin
33459>>>>>>>            Function_Return False
33460>>>>>>>        End
33460>>>>>>>>
33460>>>>>>>
33460>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33463>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33464>>>>>>>            If (bIsSQLTable = True) Begin
33466>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33469>>>>>>>            End
33469>>>>>>>>
33469>>>>>>>
33469>>>>>>>        // We start by deleting the index
33469>>>>>>>        Structure_Start hTable sDriverID
33470>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33471>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
33472>>>>>>>            Delete_Index iTableNo iIndex
33473>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
33474>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
33475>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
33477>>>>>>>
33477>>>>>>>        Move False to Err
33478>>>>>>>        Move iTableNo to hTable
33479>>>>>>>        Get OpenTableExclusive hTable to bOK
33480>>>>>>>        If (bOK = False) Begin
33482>>>>>>>            Function_Return False
33483>>>>>>>        End
33483>>>>>>>>
33483>>>>>>>
33483>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33484>>>>>>>        Structure_Start hTable sDriverID
33485>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
33486>>>>>>>
33486>>>>>>>            Create_Index hTable at iIndex
33487>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
33490>>>>>>>
33490>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
33496>>>>>>>>
33496>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
33499>>>>>>>            Loop
33500>>>>>>>>
33500>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
33502>>>>>>>
33502>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33503>>>>>>>
33503>>>>>>>        Function_Return (Err = False)
33504>>>>>>>    End_Function
33505>>>>>>>
33505>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
33507>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
33507>>>>>>>        String sDriverID sSQLIndexName
33507>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
33507>>>>>>>
33507>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
33508>>>>>>>        If (iSegmentsFrom = 0) Begin
33510>>>>>>>            Function_Return False
33511>>>>>>>        End
33511>>>>>>>>
33511>>>>>>>
33511>>>>>>>        Get AutoConnectionIDLogin to bOK
33512>>>>>>>        Move False to Err
33513>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
33514>>>>>>>        If (bIsOpen = False) Begin
33516>>>>>>>            Function_Return False
33517>>>>>>>        End
33517>>>>>>>>
33517>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33520>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
33521>>>>>>>            If (bIsSQLTable = True) Begin
33523>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33526>>>>>>>            End
33526>>>>>>>>
33526>>>>>>>
33526>>>>>>>        Move 0     to iSegmentsTo
33527>>>>>>>        Move 0     to iSQLIndexType
33528>>>>>>>        Move ""    to sSQLIndexName
33529>>>>>>>        Move False to bIsSQLTemporaryIndex
33530>>>>>>>        Move False to bIsSQLPrimaryKey
33531>>>>>>>        Move False to bIsSQLClustered
33532>>>>>>>
33532>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
33533>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
33536>>>>>>>        Move (iSegmentsTo > 0) to bExists
33537>>>>>>>        If (bExists = True) Begin
33539>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
33541>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
33544>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
33547>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
33548>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
33551>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
33554>>>>>>>            End
33554>>>>>>>>
33554>>>>>>>        End
33554>>>>>>>>
33554>>>>>>>
33554>>>>>>>        Move hTable to iTableNo
33555>>>>>>>        Move False to Err
33556>>>>>>>        Move 0 to LastErr
33557>>>>>>>
33557>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
33557>>>>>>>        //       _outside_ the Structure_Start/End construct.
33557>>>>>>>//        Move False to bIsSQLTemporaryIndex
33557>>>>>>>//        #IF (!@ > 170)
33557>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
33557>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
33557>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
33557>>>>>>>//                End
33557>>>>>>>//            End
33557>>>>>>>//        #ENDIF
33557>>>>>>>
33557>>>>>>>        Structure_Start hTable sDriverID
33558>>>>>>>            If (bExists = True) Begin
33560>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
33561>>>>>>>            End
33561>>>>>>>>
33561>>>>>>>
33561>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
33562>>>>>>>
33562>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
33564>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
33567>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
33570>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
33573>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
33576>>>>>>>            End
33576>>>>>>>>
33576>>>>>>>
33576>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
33579>>>>>>>
33579>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
33585>>>>>>>>
33585>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
33586>>>>>>>                If (iFieldFrom <> -1 ) Begin
33588>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
33591>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
33594>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
33597>>>>>>>                End
33597>>>>>>>>
33597>>>>>>>            Loop
33598>>>>>>>>
33598>>>>>>>
33598>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33599>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33601>>>>>>>
33601>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33602>>>>>>>
33602>>>>>>>        Function_Return (Err = False)
33603>>>>>>>    End_Function
33604>>>>>>>
33604>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
33604>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
33604>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
33606>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
33606>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
33606>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
33606>>>>>>>
33606>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
33606>>>>>>>        // so we can then not rename the index.
33606>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
33607>>>>>>>        If (bIsMertechDriver = True) Begin
33609>>>>>>>            Function_Return False
33610>>>>>>>        End    
33610>>>>>>>>
33610>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
33611>>>>>>>        
33611>>>>>>>        If (bIsSQLDriver = False) Begin
33613>>>>>>>            Function_Return False
33614>>>>>>>        End
33614>>>>>>>>
33614>>>>>>>
33614>>>>>>>        Move False to Err
33615>>>>>>>        Move hTable to iTableNo
33616>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
33619>>>>>>>        for iCount from 0 to iLastIndex
33625>>>>>>>>
33625>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
33628>>>>>>>            Move (iSegments > 0) to bExists
33629>>>>>>>            If (bExists = True) Begin
33631>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
33634>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
33636>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
33637>>>>>>>                    Structure_Start iTableNo sDriverID
33638>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
33641>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33643>>>>>>>                    Open hTable
33645>>>>>>>                End
33645>>>>>>>>
33645>>>>>>>            End
33645>>>>>>>>
33645>>>>>>>        Loop
33646>>>>>>>>
33646>>>>>>>
33646>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
33649>>>>>>>        If (bIsOpen = False) Begin
33651>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
33652>>>>>>>        End
33652>>>>>>>>
33652>>>>>>>        If (bIsOpen = False) Begin
33654>>>>>>>            Function_Return False
33655>>>>>>>        End
33655>>>>>>>>
33655>>>>>>>
33655>>>>>>>        Function_Return (Err = False)
33656>>>>>>>    End_Function
33657>>>>>>>
33657>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
33657>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
33657>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
33659>>>>>>>        Integer iSize iCount
33659>>>>>>>        Integer iRetVal
33659>>>>>>>
33659>>>>>>>        Move 0 to iRetVal
33660>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
33663>>>>>>>        If (iRetVal = 0) Begin
33665>>>>>>>            Function_Return 0
33666>>>>>>>        End
33666>>>>>>>>
33666>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
33667>>>>>>>        Decrement iSize
33668>>>>>>>        for iCount from 0 to iSize
33674>>>>>>>>
33674>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
33676>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
33678>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
33679>>>>>>>                End
33679>>>>>>>>
33679>>>>>>>            End
33679>>>>>>>>
33679>>>>>>>        Loop
33680>>>>>>>>
33680>>>>>>>
33680>>>>>>>        Function_Return iRetVal
33681>>>>>>>    End_Function
33682>>>>>>>
33682>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
33684>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
33684>>>>>>>        Boolean bIsSQLTable
33684>>>>>>>        
33684>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33685>>>>>>>            If (bIsSQLTable = True) Begin
33687>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33690>>>>>>>            End
33690>>>>>>>>
33690>>>>>>>
33690>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33693>>>>>>>        If (iSegment = iNumSegments) Begin
33695>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33695>>>>>>>        End
33695>>>>>>>>
33695>>>>>>>
33695>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
33698>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
33704>>>>>>>>
33704>>>>>>>                //*** Move index segment attributes
33704>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
33707>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
33710>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
33713>>>>>>>
33713>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
33716>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
33719>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
33722>>>>>>>            Loop
33723>>>>>>>>
33723>>>>>>>
33723>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33726>>>>>>>        End
33726>>>>>>>>
33726>>>>>>>
33726>>>>>>>        Function_Return (Err = False)
33727>>>>>>>    End_Function
33728>>>>>>>
33728>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
33730>>>>>>>        Integer iCount iSize iIndex
33730>>>>>>>        String sDriverID
33730>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
33730>>>>>>>
33730>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
33731>>>>>>>        If (iSize = 0) Begin
33733>>>>>>>            Function_Return True
33734>>>>>>>        End
33734>>>>>>>>
33734>>>>>>>
33734>>>>>>>        Get AutoConnectionIDLogin to bOK
33735>>>>>>>        Move False to Err
33736>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
33739>>>>>>>        If (bIsOpen = False) Begin
33741>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
33742>>>>>>>            If (bIsOpen = False) Begin
33744>>>>>>>                Function_Return False
33745>>>>>>>            End
33745>>>>>>>>
33745>>>>>>>        End
33745>>>>>>>>
33745>>>>>>>
33745>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33748>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
33749>>>>>>>            If (bIsSQLTable = True) Begin
33751>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33754>>>>>>>            End
33754>>>>>>>>
33754>>>>>>>
33754>>>>>>>        Move False to Err
33755>>>>>>>        Move 0 to LastErr
33756>>>>>>>        Decrement iSize
33757>>>>>>>
33757>>>>>>>        Structure_Start hTable sDriverID
33758>>>>>>>            for iCount from 0 to iSize
33764>>>>>>>>
33764>>>>>>>//                Move False to bIsSQLPrimaryKey
33764>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
33764>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33764>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
33764>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
33764>>>>>>>//                #ENDIF
33764>>>>>>>                // We can't delete if this is a primary key index:
33764>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
33764>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
33765>>>>>>>                    Delete_Index hTable iIndex
33766>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
33766>>>>>>>//                End
33766>>>>>>>            Loop
33767>>>>>>>>
33767>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33768>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33770>>>>>>>//        Move False to Err
33770>>>>>>>        Move 0 to LastErr
33771>>>>>>>
33771>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33772>>>>>>>        Function_Return (Err = False)
33773>>>>>>>    End_Function
33774>>>>>>>
33774>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
33776>>>>>>>        Boolean bOK
33776>>>>>>>
33776>>>>>>>        Get AutoConnectionIDLogin to bOK
33777>>>>>>>        Move False to Err
33778>>>>>>>        Get OpenTableExclusive hTable to bOK
33779>>>>>>>        If (bOK = False) Begin
33781>>>>>>>            Function_Return False
33782>>>>>>>        End
33782>>>>>>>>
33782>>>>>>>        Structure_Start hTable
33783>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
33786>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33787>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33789>>>>>>>
33789>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33790>>>>>>>        Function_Return (Err = False)
33791>>>>>>>    End_Function
33792>>>>>>>
33792>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
33794>>>>>>>        Integer iCase
33794>>>>>>>        Boolean bOK
33794>>>>>>>
33794>>>>>>>        If (bUppercase = True) Begin
33796>>>>>>>            Move DF_CASE_IGNORED to iCase
33797>>>>>>>        End
33797>>>>>>>>
33797>>>>>>>        Else Begin
33798>>>>>>>            Move DF_CASE_USED to iCase
33799>>>>>>>        End
33799>>>>>>>>
33799>>>>>>>
33799>>>>>>>        Get AutoConnectionIDLogin to bOK
33800>>>>>>>        Move False to Err
33801>>>>>>>        Get OpenTableExclusive hTable to bOK
33802>>>>>>>        If (bOK = False) Begin
33804>>>>>>>            Function_Return False
33805>>>>>>>        End
33805>>>>>>>>
33805>>>>>>>        Structure_Start hTable
33806>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
33809>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33810>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33812>>>>>>>
33812>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33813>>>>>>>        Function_Return (Err = False)
33814>>>>>>>    End_Function
33815>>>>>>>
33815>>>>>>>    // To delete an index
33815>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
33817>>>>>>>        Integer iTableNo iNumSegments
33817>>>>>>>        String sDriverID
33817>>>>>>>        Boolean bOK bIsSQLTable
33817>>>>>>>
33817>>>>>>>        Get AutoConnectionIDLogin to bOK
33818>>>>>>>        Move False to Err
33819>>>>>>>        Move hTable to iTableNo
33820>>>>>>>        Get OpenTableExclusive hTable to bOK
33821>>>>>>>        If (bOK = False) Begin
33823>>>>>>>            Function_Return False
33824>>>>>>>        End
33824>>>>>>>>
33824>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33827>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33828>>>>>>>            If (bIsSQLTable = True) Begin
33830>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33833>>>>>>>            End
33833>>>>>>>>
33833>>>>>>>
33833>>>>>>>        // Check to see if the index exists or not...
33833>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33836>>>>>>>        If (iNumSegments = 0) Begin
33838>>>>>>>            Function_Return True // Then nothing to do.
33839>>>>>>>        End
33839>>>>>>>>
33839>>>>>>>
33839>>>>>>>        Structure_Start hTable sDriverID
33840>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
33841>>>>>>>            Delete_Index iTableNo iIndex
33842>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
33843>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33844>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33846>>>>>>>
33846>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33847>>>>>>>        Function_Return (Err = False)
33848>>>>>>>    End_Function
33849>>>>>>>
33849>>>>>>>    // Delete an Index Segment
33849>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
33851>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
33851>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
33851>>>>>>>        Integer iIndexType
33851>>>>>>>        String sDriverID
33851>>>>>>>
33851>>>>>>>        Get AutoConnectionIDLogin to bOK
33852>>>>>>>        Move False to Err
33853>>>>>>>
33853>>>>>>>        Get OpenTableExclusive hTable to bOK
33854>>>>>>>        If (bOK = False) Begin
33856>>>>>>>            Function_Return False
33857>>>>>>>        End
33857>>>>>>>>
33857>>>>>>>
33857>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33858>>>>>>>            If (bIsSQLTable = True) Begin
33860>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33863>>>>>>>            End
33863>>>>>>>>
33863>>>>>>>
33863>>>>>>>        // Check to see if the index exists or not...
33863>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33866>>>>>>>        If (iNumSegments = 0) Begin
33868>>>>>>>            Function_Return False
33869>>>>>>>        End
33869>>>>>>>>
33869>>>>>>>
33869>>>>>>>        Move False to bIndexTemporary
33870>>>>>>>        Get psDriverID to sDriverID
33871>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
33872>>>>>>>        If (bSQLDriver) Begin
33874>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
33877>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
33880>>>>>>>                Move True to bIndexTemporary
33881>>>>>>>        End
33881>>>>>>>>
33881>>>>>>>
33881>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
33881>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
33883>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33886>>>>>>>            If (iSegment = iNumSegments) Begin
33888>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33891>>>>>>>            End
33891>>>>>>>>
33891>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
33894>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
33900>>>>>>>>
33900>>>>>>>                    //*** Move index segment attributes
33900>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
33903>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
33906>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
33909>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
33912>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
33915>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
33918>>>>>>>                Loop
33919>>>>>>>>
33919>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33922>>>>>>>            End
33922>>>>>>>>
33922>>>>>>>        End
33922>>>>>>>>
33922>>>>>>>
33922>>>>>>>        Else Begin
33923>>>>>>>           Structure_Start hTable
33924>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33927>>>>>>>               If (iSegment = iNumSegments) Begin
33929>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33932>>>>>>>               End
33932>>>>>>>>
33932>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
33935>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
33941>>>>>>>>
33941>>>>>>>                       //*** Move index segment attributes
33941>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
33944>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
33947>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
33950>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
33953>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
33956>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
33959>>>>>>>                   Loop
33960>>>>>>>>
33960>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33963>>>>>>>               End
33963>>>>>>>>
33963>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
33964>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33966>>>>>>>            Set Action_Text of ghoStatusPanel to ""
33967>>>>>>>        End
33967>>>>>>>>
33967>>>>>>>
33967>>>>>>>        Function_Return (Err = False)
33968>>>>>>>    End_Function
33969>>>>>>>
33969>>>>>>>    // Add/Insert an Index Segment
33969>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
33971>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
33971>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
33971>>>>>>>        Integer iIndexType
33971>>>>>>>        String sDriverId
33971>>>>>>>
33971>>>>>>>        Get AutoConnectionIDLogin to bOK
33972>>>>>>>        Move False to Err
33973>>>>>>>
33973>>>>>>>        Get OpenTableExclusive hTable to bOK
33974>>>>>>>        If (bOK = False) Begin
33976>>>>>>>            Function_Return False
33977>>>>>>>        End
33977>>>>>>>>
33977>>>>>>>
33977>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33978>>>>>>>            If (bIsSQLTable = True) Begin
33980>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33983>>>>>>>            End
33983>>>>>>>>
33983>>>>>>>
33983>>>>>>>        Move False to bIndexTemporary
33984>>>>>>>        // Check to see if the index exists or not...
33984>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33987>>>>>>>        If (iNumSegments = 0) Begin
33989>>>>>>>            Function_Return False
33990>>>>>>>        End
33990>>>>>>>>
33990>>>>>>>
33990>>>>>>>        Get psDriverID to sDriverID
33991>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
33992>>>>>>>        If (bSQLDriver) Begin
33994>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
33997>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
34000>>>>>>>                Move True to bIndexTemporary
34001>>>>>>>        End
34001>>>>>>>>
34001>>>>>>>
34001>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
34001>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
34003>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
34006>>>>>>>
34006>>>>>>>           If (iSegment > iNumSegments) Begin
34008>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
34011>>>>>>>               Move (iNumSegments + 1) to iCurSegment
34012>>>>>>>           End
34012>>>>>>>>
34012>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
34015>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
34018>>>>>>>               Move iNumSegments to iCurSegment
34019>>>>>>>
34019>>>>>>>               While (iCurSegment > iSegment)
34023>>>>>>>                   //*** Move index segment attributes
34023>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
34026>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
34029>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
34032>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
34035>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
34038>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
34041>>>>>>>                   Decrement iCurSegment
34042>>>>>>>               Loop
34043>>>>>>>>
34043>>>>>>>
34043>>>>>>>               //*** Now set new segment attributes
34043>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
34046>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
34049>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
34052>>>>>>>           End
34052>>>>>>>>
34052>>>>>>>        End
34052>>>>>>>>
34052>>>>>>>
34052>>>>>>>        Else Begin
34053>>>>>>>        Structure_Start hTable
34054>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
34057>>>>>>>
34057>>>>>>>            If (iSegment > iNumSegments) Begin
34059>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
34062>>>>>>>                Move (iNumSegments + 1) to iCurSegment
34063>>>>>>>            End
34063>>>>>>>>
34063>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
34066>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
34069>>>>>>>                Move iNumSegments to iCurSegment
34070>>>>>>>
34070>>>>>>>                While (iCurSegment > iSegment)
34074>>>>>>>                    //*** Move index segment attributes
34074>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
34077>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
34080>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
34083>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
34086>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
34089>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
34092>>>>>>>                    Decrement iCurSegment
34093>>>>>>>                Loop
34094>>>>>>>>
34094>>>>>>>
34094>>>>>>>                //*** Now set new segment attributes
34094>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
34097>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
34100>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
34103>>>>>>>            End
34103>>>>>>>>
34103>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34104>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34106>>>>>>>            Set Action_Text of ghoStatusPanel to ""
34107>>>>>>>        End
34107>>>>>>>>
34107>>>>>>>
34107>>>>>>>        Function_Return (Err = False)
34108>>>>>>>    End_Function
34109>>>>>>>
34109>>>>>>>    // * Dummy function for the Studio's Code Explorer *
34109>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
34111>>>>>>>        Function_Return False
34112>>>>>>>    End_Function  
34113>>>>>>>    
34113>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
34113>>>>>>>    // for an SQL conversion.
34113>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
34115>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
34115>>>>>>>        
34115>>>>>>>        Move True to bConvertTo30FormatbOK
34116>>>>>>>        Move True to bRepairAndReindexOK
34117>>>>>>>        Move True to bFixBogusDatesOK
34118>>>>>>>        Move True to bMoveMiscFilesToBackupOK
34119>>>>>>>        
34119>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
34121>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
34122>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
34123>>>>>>>        End                                                                                
34123>>>>>>>>
34123>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
34125>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
34126>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
34127>>>>>>>        End
34127>>>>>>>>
34127>>>>>>>        If (bConvertTo30Format = True) Begin
34129>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
34130>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
34131>>>>>>>        End                                                 
34131>>>>>>>>
34131>>>>>>>        If (bRepairAndReindex = True) Begin
34133>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
34134>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
34135>>>>>>>        End  
34135>>>>>>>>
34135>>>>>>>        If (bFixBogusDates = True) Begin
34137>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
34138>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
34139>>>>>>>        End                                    
34139>>>>>>>>
34139>>>>>>>        
34139>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
34140>>>>>>>    End_Function
34141>>>>>>>
34141>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
34143>>>>>>>        Boolean bOK bFlexErrs bTemp
34143>>>>>>>        Handle hTable
34143>>>>>>>        String sTableName
34143>>>>>>>        Integer iCount iSize
34143>>>>>>>        
34143>>>>>>>        Move True to bOK
34144>>>>>>>        Move 0 to hTable    
34145>>>>>>>
34145>>>>>>>        Get UtilFilelistNoOfTables to iSize
34146>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
34147>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
34148>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
34149>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
34150>>>>>>>
34150>>>>>>>        Repeat
34150>>>>>>>>
34150>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
34151>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
34152>>>>>>>            Increment iCount
34153>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34156>>>>>>>            If (hTable > 0) Begin
34158>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
34161>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
34162>>>>>>>                If (bFlexErrs = False) Begin
34164>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
34165>>>>>>>                    If (bTemp = False) Begin
34167>>>>>>>                        Move False to bOK
34168>>>>>>>                    End
34168>>>>>>>>
34168>>>>>>>                End
34168>>>>>>>>
34168>>>>>>>            End
34168>>>>>>>>
34168>>>>>>>        Until (hTable = 0)
34170>>>>>>>        
34170>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34171>>>>>>>        Function_Return bOK
34172>>>>>>>    End_Function
34173>>>>>>>    
34173>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
34173>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
34173>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
34173>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
34175>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
34175>>>>>>>        String sRevision
34175>>>>>>>        
34175>>>>>>>        Get AutoConnectionIDLogin to bOK
34176>>>>>>>        If (bOK = False) Begin
34178>>>>>>>            Function_Return True
34179>>>>>>>        End
34179>>>>>>>>
34179>>>>>>>        Get OpenTableExclusive hTable to bOK
34180>>>>>>>        If (bOK = False) Begin
34182>>>>>>>            Function_Return True
34183>>>>>>>        End
34183>>>>>>>>
34183>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
34184>>>>>>>        If (bIsEmbedded = False) Begin
34186>>>>>>>            Function_Return True
34187>>>>>>>        End                             
34187>>>>>>>>
34187>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
34188>>>>>>>        If (bIsAlias = True) Begin
34190>>>>>>>            Function_Return True
34191>>>>>>>        End                     
34191>>>>>>>>
34191>>>>>>>        
34191>>>>>>>        Move False to Err
34192>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
34195>>>>>>>        If (sRevision contains "2.3") Begin
34197>>>>>>>            Move False to Err
34198>>>>>>>            Set Private.phCurrentTable to hTable
34199>>>>>>>            Structure_Start hTable    
34200>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
34203>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
34204>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
34206>>>>>>>            Set Action_Text of ghoStatusPanel to ""
34207>>>>>>>        End
34207>>>>>>>>
34207>>>>>>>        
34207>>>>>>>        Function_Return (Err = False)
34208>>>>>>>    End_Function
34209>>>>>>>
34209>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
34211>>>>>>>        Boolean bIgnore bExists bOK bResponse
34211>>>>>>>        Handle hTable   
34211>>>>>>>        String sTableName
34211>>>>>>>        
34211>>>>>>>        Move False to Err 
34212>>>>>>>        Move True to bOK
34213>>>>>>>        Move 0 to hTable
34214>>>>>>>        Repeat
34214>>>>>>>>
34214>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34217>>>>>>>            If (hTable > 0) Begin
34219>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
34222>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
34223>>>>>>>                If (bIgnore = False) Begin
34225>>>>>>>                    Get UtilTableExists hTable to bExists
34226>>>>>>>                    If (bExists = False) Begin
34228>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
34229>>>>>>>                        If (bResponse = False) Begin
34231>>>>>>>                            Move False to bOK
34232>>>>>>>                        End
34232>>>>>>>>
34232>>>>>>>                        
34232>>>>>>>                    End
34232>>>>>>>>
34232>>>>>>>                End
34232>>>>>>>>
34232>>>>>>>            End
34232>>>>>>>>
34232>>>>>>>        Until (hTable = 0)                     
34234>>>>>>>        
34234>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
34235>>>>>>>        Function_Return bOK
34236>>>>>>>    End_Function
34237>>>>>>>    
34237>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
34237>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
34237>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
34237>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
34237>>>>>>>    //
34237>>>>>>>    // The root of the problem is the following:
34237>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
34237>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
34237>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
34237>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
34237>>>>>>>    // an SQL error will be thrown;
34237>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
34237>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
34239>>>>>>>        Boolean bOK bIsAlias bIsSQL
34239>>>>>>>        Integer iCount iSize iDateSize
34239>>>>>>>        Handle hTable
34239>>>>>>>        String sLogicalName
34239>>>>>>>        Integer[] aTablesToCheck aDateFields
34241>>>>>>>
34241>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
34242>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
34243>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
34244>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
34245>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
34246>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
34247>>>>>>>
34247>>>>>>>        Move True to bOK
34248>>>>>>>        Decrement iSize
34249>>>>>>>        for iCount from 0 to iSize
34255>>>>>>>>
34255>>>>>>>            Move aTablesToCheck[iCount] to hTable
34256>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
34257>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
34258>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
34259>>>>>>>
34259>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
34262>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
34263>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
34264>>>>>>>
34264>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
34266>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
34267>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
34268>>>>>>>                If (iDateSize > 0) Begin
34270>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
34271>>>>>>>                    Close hTable
34272>>>>>>>                End
34272>>>>>>>>
34272>>>>>>>            End
34272>>>>>>>>
34272>>>>>>>        Loop
34273>>>>>>>>
34273>>>>>>>
34273>>>>>>>        Close DF_ALL
34274>>>>>>>        Function_Return bOK
34275>>>>>>>    End_Function
34276>>>>>>>
34276>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
34276>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
34278>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
34280>>>>>>>        Integer iSize iCount iType
34280>>>>>>>        Boolean bOpen bOK
34280>>>>>>>        
34280>>>>>>>        Get UtilTableExists hTable to bOK
34281>>>>>>>        If (bOK = False) Begin
34283>>>>>>>            Set Private.phCurrentTable to hTable
34284>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
34285>>>>>>>>
34285>>>>>>>            Function_Return aDateFieldsEmpty
34286>>>>>>>        End
34286>>>>>>>>
34286>>>>>>>        Set Private.phCurrentTable to hTable
34287>>>>>>>        Set Private.piCurrentField to 0
34288>>>>>>>
34288>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34288>>>>>>>        Open hTable
34290>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
34293>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
34293>>>>>>>        If (bOpen = False) Begin
34295>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
34295>>>>>>>            Function_Return aDateFieldsEmpty
34296>>>>>>>        End
34296>>>>>>>>
34296>>>>>>>
34296>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
34299>>>>>>>        For iCount from 1 to iSize
34305>>>>>>>>
34305>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
34308>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
34310>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
34311>>>>>>>            End
34311>>>>>>>>
34311>>>>>>>        Loop
34312>>>>>>>>
34312>>>>>>>
34312>>>>>>>        Function_Return aDateFields
34313>>>>>>>    End_Function
34314>>>>>>>
34314>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
34314>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
34314>>>>>>>    // and the record is saved
34314>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
34314>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
34314>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
34316>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
34316>>>>>>>        String sDriverID sDateMin
34316>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
34316>>>>>>>        Date dDate dDateMin
34316>>>>>>>        Integer[] iaChangeField
34317>>>>>>>
34317>>>>>>>        Get UtilTableExists hTable to bOK
34318>>>>>>>        // I believe we should just skip files not found and not report an error.
34318>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
34318>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
34318>>>>>>>        // Especially considering that this call is probably done at the very
34318>>>>>>>        // beginning of a DUF update.
34318>>>>>>>        If (bOK = False) Begin
34320>>>>>>>//            Set Private.phCurrentTable to hTable
34320>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
34320>>>>>>>//            Function_Return False
34320>>>>>>>            Function_Return True
34321>>>>>>>        End
34321>>>>>>>>
34321>>>>>>>
34321>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
34321>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
34321>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
34324>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
34327>>>>>>>
34327>>>>>>>//        Send SetAllIndexesToBatch hTable True
34327>>>>>>>        Open hTable
34329>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
34332>>>>>>>        If (bOpened = False) Begin
34334>>>>>>>            Function_Return False
34335>>>>>>>        End
34335>>>>>>>>
34335>>>>>>>        
34335>>>>>>>        Set Private.phCurrentTable to hTable
34336>>>>>>>        Move 0 to iRecord
34337>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
34338>>>>>>>        Decrement iSize
34339>>>>>>>
34339>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
34342>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
34343>>>>>>>        If (iDriverIndex <> 0) Begin
34345>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
34348>>>>>>>            If (sDateMin = "") Begin
34350>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
34351>>>>>>>            End
34351>>>>>>>>
34351>>>>>>>            Else Begin
34352>>>>>>>                If (IsDate(sDateMin)) Begin
34354>>>>>>>                    Move sDateMin to dDateMin
34355>>>>>>>                End
34355>>>>>>>>
34355>>>>>>>                Else Begin
34356>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
34357>>>>>>>                End
34357>>>>>>>>
34357>>>>>>>            End
34357>>>>>>>>
34357>>>>>>>        End
34357>>>>>>>>
34357>>>>>>>        Else Begin
34358>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
34359>>>>>>>        End
34359>>>>>>>>
34359>>>>>>>
34359>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
34362>>>>>>>        Set piPosition   of ghoProgressBar to 0
34363>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
34364>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
34365>>>>>>>        Move False to Err
34366>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34367>>>>>>>
34367>>>>>>>        Clear hTable
34368>>>>>>>        Repeat
34368>>>>>>>>
34368>>>>>>>            Vfind hTable 0 GT
34370>>>>>>>            Move Found to bFound
34371>>>>>>>            If (bFound = True) Begin
34373>>>>>>>                Move False to bSaveChanges
34374>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
34375>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
34376>>>>>>>                Decrement iSize
34377>>>>>>>                For iCount from 0 to iSize
34383>>>>>>>>
34383>>>>>>>                    Move aDateFields[iCount] to iField
34384>>>>>>>                    Get_Field_Value hTable iField to dDate
34387>>>>>>>                    If (bFixZeroDates = True) Begin
34389>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
34390>>>>>>>                    End
34390>>>>>>>>
34390>>>>>>>                    Else Begin
34391>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
34392>>>>>>>                    End
34392>>>>>>>>
34392>>>>>>>                    If (bChange = True) Begin
34394>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
34395>>>>>>>                    End
34395>>>>>>>>
34395>>>>>>>                Loop
34396>>>>>>>>
34396>>>>>>>
34396>>>>>>>                // Only change Date fields that needs to be changed.
34396>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
34398>>>>>>>                    Reread hTable
34402>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
34403>>>>>>>                        Decrement iSize
34404>>>>>>>                        For iCount from 0 to iSize
34410>>>>>>>>
34410>>>>>>>                            Move iaChangeField[iCount] to iField
34411>>>>>>>                            Set Private.piCurrentField to iField
34412>>>>>>>                            Set_Field_Value hTable iField to dDateMin
34415>>>>>>>                        Loop
34416>>>>>>>>
34416>>>>>>>                        Move False to Err
34417>>>>>>>                        SaveRecord hTable
34418>>>>>>>                    Unlock
34419>>>>>>>>
34419>>>>>>>                End
34419>>>>>>>>
34419>>>>>>>
34419>>>>>>>                Increment iRecord
34420>>>>>>>                // Increment the StatusPanel counter and check the
34420>>>>>>>                // cancel status every 100 records rather than every
34420>>>>>>>                // record, it's way faster.
34420>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
34422>>>>>>>                    Send DoAdvance of ghoProgressBar
34423>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
34424>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
34425>>>>>>>                End
34425>>>>>>>>
34425>>>>>>>            End
34425>>>>>>>>
34425>>>>>>>        Until (bFound = False)
34427>>>>>>>
34427>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
34430>>>>>>>        If (bResetIndexesToOnLine = True) Begin
34432>>>>>>>            Send SetAllIndexesToBatch hTable False
34433>>>>>>>        End
34433>>>>>>>>
34433>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34434>>>>>>>
34434>>>>>>>        Function_Return (Err = False)
34435>>>>>>>    End_Function
34436>>>>>>>
34436>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
34436>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
34436>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
34438>>>>>>>        Boolean bIsSame
34438>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
34438>>>>>>>
34438>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
34439>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
34440>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
34441>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
34442>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
34443>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
34444>>>>>>>
34444>>>>>>>        If (bCompareFilelistUppercase = True) Begin
34446>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
34447>>>>>>>        End
34447>>>>>>>>
34447>>>>>>>        Else Begin
34448>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
34449>>>>>>>        End
34449>>>>>>>>
34449>>>>>>>        If (bIsSame = False) Begin
34451>>>>>>>            Function_Return False
34452>>>>>>>        End
34452>>>>>>>>
34452>>>>>>>
34452>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
34453>>>>>>>        If (bIsSame = False) Begin
34455>>>>>>>            Function_Return False
34456>>>>>>>        End
34456>>>>>>>>
34456>>>>>>>
34456>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
34457>>>>>>>        If (bIsSame = False) Begin
34459>>>>>>>            Function_Return False
34460>>>>>>>        End
34460>>>>>>>>
34460>>>>>>>
34460>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
34461>>>>>>>        If (bIsSame = False) Begin
34463>>>>>>>            Function_Return False
34464>>>>>>>        End
34464>>>>>>>>
34464>>>>>>>
34464>>>>>>>        Function_Return bIsSame
34465>>>>>>>    End_Function
34466>>>>>>>
34466>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
34468>>>>>>>        Handle hTableFrom hTableTo
34468>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
34468>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
34468>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
34468>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34468>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34469>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34469>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34470>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34470>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34471>>>>>>>
34471>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
34472>>>>>>>        If (bIsSame = True) Begin
34474>>>>>>>            Function_Return True
34475>>>>>>>        End
34475>>>>>>>>
34475>>>>>>>
34475>>>>>>>        Move False to bFilelistError
34476>>>>>>>        Move True to bIsSame
34477>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
34478>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
34479>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
34480>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
34481>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
34482>>>>>>>
34482>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
34483>>>>>>>        Get _TableNameOnly sRootName             to sRootName
34484>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
34485>>>>>>>
34485>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
34485>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
34485>>>>>>>        If (bCodeGenerateMode = True) Begin
34487>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
34487>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
34489>>>>>>>                Function_Return False
34490>>>>>>>            End
34490>>>>>>>>
34490>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
34491>>>>>>>            If (bIsSame = False) Begin
34493>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
34494>>>>>>>                Move True to bFilelistError
34495>>>>>>>                Function_Return False
34496>>>>>>>            End
34496>>>>>>>>
34496>>>>>>>        End
34496>>>>>>>>
34496>>>>>>>
34496>>>>>>>        If (bCodeGenerateMode = False) Begin
34498>>>>>>>            // Then we want to create this table
34498>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
34500>>>>>>>                Function_Return False
34501>>>>>>>            End
34501>>>>>>>>
34501>>>>>>>
34501>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
34502>>>>>>>            If (bIsSame = False) Begin
34504>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
34505>>>>>>>>
34505>>>>>>>                Move True to bFilelistError
34506>>>>>>>                Function_Return False
34507>>>>>>>            End
34507>>>>>>>>
34507>>>>>>>        End
34507>>>>>>>>
34507>>>>>>>
34507>>>>>>>        // Check columns:
34507>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
34508>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
34509>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
34510>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
34511>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
34512>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
34513>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
34514>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
34515>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
34516>>>>>>>        If (bIsSame = False) Begin
34518>>>>>>>            Function_Return False
34519>>>>>>>        End
34519>>>>>>>>
34519>>>>>>>
34519>>>>>>>        // ...then check indexes:
34519>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
34520>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
34521>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
34522>>>>>>>        If (bIsSame = False) Begin
34524>>>>>>>            Function_Return False
34525>>>>>>>        End
34525>>>>>>>>
34525>>>>>>>
34525>>>>>>>        // ...and finally relationships:
34525>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
34526>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
34527>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
34528>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
34529>>>>>>>
34529>>>>>>>        Function_Return (bIsSame = True)
34530>>>>>>>    End_Function
34531>>>>>>>
34531>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
34531>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
34533>>>>>>>        Handle hTable
34533>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
34533>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
34533>>>>>>>
34533>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
34535>>>>>>>            Move True to bFilelistError
34536>>>>>>>            Function_Return False
34537>>>>>>>        End
34537>>>>>>>>
34537>>>>>>>
34537>>>>>>>        Move APITableCompare.hTable to hTable
34538>>>>>>>        Move True  to bIsSame
34539>>>>>>>        Move False to bFilelistError
34540>>>>>>>
34540>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
34542>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
34543>>>>>>>        End
34543>>>>>>>>
34543>>>>>>>        Else Begin
34544>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
34545>>>>>>>        End
34545>>>>>>>>
34545>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
34546>>>>>>>
34546>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
34547>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
34548>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
34549>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
34550>>>>>>>
34550>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
34550>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
34550>>>>>>>        If (bCodeGenerateMode = True) Begin
34552>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
34552>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
34554>>>>>>>                Function_Return False
34555>>>>>>>            End
34555>>>>>>>>
34555>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
34556>>>>>>>            If (bIsSame = False) Begin
34558>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
34559>>>>>>>                Move True to bFilelistError
34560>>>>>>>                Function_Return False
34561>>>>>>>            End
34561>>>>>>>>
34561>>>>>>>        End
34561>>>>>>>>
34561>>>>>>>
34561>>>>>>>        If (bCodeGenerateMode = False) Begin
34563>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
34565>>>>>>>                // Then we might want to create this table
34565>>>>>>>                Function_Return False
34566>>>>>>>            End
34566>>>>>>>>
34566>>>>>>>
34566>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
34567>>>>>>>            If (bIsSame = False) Begin
34569>>>>>>>                Function_Return False
34570>>>>>>>            End
34570>>>>>>>>
34570>>>>>>>
34570>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
34571>>>>>>>            If (bIsSame = False) Begin
34573>>>>>>>                Function_Return False
34574>>>>>>>            End
34574>>>>>>>>
34574>>>>>>>
34574>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
34575>>>>>>>            If (bIsSame = False) Begin
34577>>>>>>>                Function_Return False
34578>>>>>>>            End
34578>>>>>>>>
34578>>>>>>>
34578>>>>>>>            // Check table names et al.
34578>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
34579>>>>>>>            If (bIsSame = False) Begin
34581>>>>>>>                Function_Return False
34582>>>>>>>            End
34582>>>>>>>>
34582>>>>>>>        End
34582>>>>>>>>
34582>>>>>>>
34582>>>>>>>        // Check Columns:
34582>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
34583>>>>>>>        If (bIsSame = False) Begin
34585>>>>>>>            Function_Return False
34586>>>>>>>        End
34586>>>>>>>>
34586>>>>>>>
34586>>>>>>>        // ...then check Indexes:
34586>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
34587>>>>>>>        If (bIsSame = False) Begin
34589>>>>>>>            Function_Return False
34590>>>>>>>        End
34590>>>>>>>>
34590>>>>>>>
34590>>>>>>>        // ...and finally Relationships:
34590>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
34591>>>>>>>
34591>>>>>>>        Function_Return (bIsSame = True)
34592>>>>>>>    End_Function
34593>>>>>>>
34593>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
34593>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
34593>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
34593>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
34593>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
34595>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34595>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34595>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
34595>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
34597>>>>>>>        tAPIColumn[]    aApiColumns
34597>>>>>>>        tAPIColumn[]    aApiColumns
34598>>>>>>>        tAPIIndex[]     aApiIndexes
34598>>>>>>>        tAPIIndex[]     aApiIndexes
34599>>>>>>>        tAPIRelation[]  aApiRelations
34599>>>>>>>        tAPIRelation[]  aApiRelations
34600>>>>>>>        Handle hTable
34600>>>>>>>        Integer iCount
34600>>>>>>>        Boolean bUserCancel bOK
34600>>>>>>>        String sLogicalName sMessageText
34600>>>>>>>
34600>>>>>>>        Get AutoConnectionIDLogin to bOK
34601>>>>>>>        Move 0 to hTable
34602>>>>>>>        If (bFromTables = True) Begin
34604>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
34605>>>>>>>            If (bCompareUtil = True) Begin
34607>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
34608>>>>>>>            End
34608>>>>>>>>
34608>>>>>>>        End
34608>>>>>>>>
34608>>>>>>>        Else Begin
34609>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
34610>>>>>>>            If (bCompareUtil = True) Begin
34612>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
34613>>>>>>>            End
34613>>>>>>>>
34613>>>>>>>        End
34613>>>>>>>>
34613>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
34614>>>>>>>
34614>>>>>>>        Get UtilFilelistNoOfTables to iCount
34615>>>>>>>        Set piMaximum of ghoProgressBar to iCount
34616>>>>>>>        Move 0 to iCount
34617>>>>>>>
34617>>>>>>>        Repeat
34617>>>>>>>>
34617>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34620>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
34622>>>>>>>
34622>>>>>>>                Open hTable
34624>>>>>>>                // ToDo: Needs to be revised
34624>>>>>>>                // For some reason tables may be reported as "unopened", while in
34624>>>>>>>                // fact the open was successful (!)
34624>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34624>>>>>>>//                If (bIsOpen = False) Begin
34624>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
34624>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
34624>>>>>>>//                    Function_Return aApiTablesEmpty
34624>>>>>>>//                End
34624>>>>>>>
34624>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
34627>>>>>>>                Set piPosition of ghoProgressBar to iCount
34628>>>>>>>                Send DoAdvance of ghoProgressBarOverall
34629>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
34630>>>>>>>
34630>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
34631>>>>>>>//                Close hTable DF_PERMANENT
34631>>>>>>>                Increment iCount
34632>>>>>>>            End
34632>>>>>>>>
34632>>>>>>>
34632>>>>>>>            If (bStatusPanel = True) Begin
34634>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
34635>>>>>>>                If (bUserCancel = True) Begin
34637>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
34638>>>>>>>                    Function_Return aApiTablesEmpty
34639>>>>>>>                End
34639>>>>>>>>
34639>>>>>>>            End
34639>>>>>>>>
34639>>>>>>>
34639>>>>>>>        Until (hTable = 0)
34641>>>>>>>
34641>>>>>>>        Function_Return aApiTables
34642>>>>>>>    End_Function
34643>>>>>>>
34643>>>>>>>    // Returns a 'single' table APITable struct.
34643>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
34645>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34645>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34645>>>>>>>        tAPITable         ApiTable ApiTableEmpty
34645>>>>>>>        tAPITable         ApiTable ApiTableEmpty
34645>>>>>>>        tAPIColumn[]     aApiColumns
34645>>>>>>>        tAPIColumn[]     aApiColumns
34646>>>>>>>        tAPIIndex[]      aApiIndexes
34646>>>>>>>        tAPIIndex[]      aApiIndexes
34647>>>>>>>        tAPIRelation[]   aApiRelations
34647>>>>>>>        tAPIRelation[]   aApiRelations
34648>>>>>>>        Boolean bIsOpen
34648>>>>>>>
34648>>>>>>>        Open hTable
34650>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34653>>>>>>>        If (bIsOpen = False) Begin
34655>>>>>>>            Move True to ApiTableEmpty.bError
34656>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34657>>>>>>>            Function_Return ApiTableEmpty
34658>>>>>>>        End
34658>>>>>>>>
34658>>>>>>>
34658>>>>>>>        // Fill Table Name Info
34658>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
34659>>>>>>>
34659>>>>>>>        // Fill columns
34659>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
34660>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
34662>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
34664>>>>>>>                Move True to ApiTableEmpty.bError
34665>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34666>>>>>>>                Function_Return ApiTableEmpty
34667>>>>>>>            End
34667>>>>>>>>
34667>>>>>>>        End
34667>>>>>>>>
34667>>>>>>>
34667>>>>>>>        // Fill indexes
34667>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
34668>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
34670>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
34672>>>>>>>                Move True to ApiTableEmpty.bError
34673>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34674>>>>>>>                Function_Return ApiTableEmpty
34675>>>>>>>            End
34675>>>>>>>>
34675>>>>>>>        End
34675>>>>>>>>
34675>>>>>>>
34675>>>>>>>        // Fill relationships
34675>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
34676>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
34678>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
34680>>>>>>>                Move True to ApiTableEmpty.bError
34681>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34682>>>>>>>                Function_Return ApiTableEmpty
34683>>>>>>>            End
34683>>>>>>>>
34683>>>>>>>        End
34683>>>>>>>>
34683>>>>>>>
34683>>>>>>>        Move hTable             to ApiTable.hTable
34684>>>>>>>        Move bFromTables        to ApiTable.bFromTable
34685>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
34686>>>>>>>
34686>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
34687>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
34688>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
34689>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
34690>>>>>>>
34690>>>>>>>        Function_Return ApiTable
34691>>>>>>>    End_Function
34692>>>>>>>
34692>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
34694>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
34694>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
34694>>>>>>>        Boolean bIsOpen
34694>>>>>>>
34694>>>>>>>        Open hTable
34696>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34699>>>>>>>        If (bIsOpen = False) Begin
34701>>>>>>>            Move True   to APITableNameInfoEmpty.bError
34702>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
34703>>>>>>>            Function_Return APITableNameInfoEmpty
34704>>>>>>>        End
34704>>>>>>>>
34704>>>>>>>
34704>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
34705>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
34708>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
34711>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
34714>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
34717>>>>>>>
34717>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
34718>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
34719>>>>>>>
34719>>>>>>>        Function_Return APITableNameInfo
34720>>>>>>>    End_Function
34721>>>>>>>
34721>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
34723>>>>>>>        Integer iSize iCount iItem
34723>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34723>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34723>>>>>>>
34723>>>>>>>        Move -1 to iItem
34724>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
34725>>>>>>>        Decrement iSize
34726>>>>>>>        for iCount from 0 to iSize
34732>>>>>>>>
34732>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
34733>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
34735>>>>>>>                Move iCount to iItem
34736>>>>>>>                Move iSize  to iCount // We're done.
34737>>>>>>>            End
34737>>>>>>>>
34737>>>>>>>        Loop
34738>>>>>>>>
34738>>>>>>>
34738>>>>>>>        Function_Return iItem
34739>>>>>>>    End_Function
34740>>>>>>>
34740>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
34742>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
34745>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
34748>>>>>>>
34748>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
34751>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
34754>>>>>>>
34754>>>>>>>        Function_Return (EQ)
34755>>>>>>>    End_Function
34756>>>>>>>
34756>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
34758>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
34758>>>>>>>        Handle hTable
34758>>>>>>>        tAPITable[] aAPITableFromAndTo
34758>>>>>>>        tAPITable[] aAPITableFromAndTo
34759>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
34759>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
34759>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34759>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34759>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
34759>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
34760>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34760>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34761>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34761>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34762>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34762>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34763>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
34763>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
34763>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
34763>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
34766>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
34766>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
34769>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
34769>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
34772>>>>>>>
34772>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
34773>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
34774>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
34776>>>>>>>            Function_Return aAPITableCompare
34777>>>>>>>        End
34777>>>>>>>>
34777>>>>>>>
34777>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
34778>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
34779>>>>>>>
34779>>>>>>>        Move 0 to iItem
34780>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
34781>>>>>>>        Decrement iSize
34782>>>>>>>        for iCount from 0 to iSize
34788>>>>>>>>
34788>>>>>>>
34788>>>>>>>            Move iCount to iItemFrom
34789>>>>>>>            Move iCount to iItemTo
34790>>>>>>>            Move APITableEmpty to APITableFrom
34791>>>>>>>            Move APITableEmpty to APITableTo
34792>>>>>>>
34792>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
34794>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
34795>>>>>>>            End
34795>>>>>>>>
34795>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
34797>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
34798>>>>>>>            End
34798>>>>>>>>
34798>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
34800>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
34801>>>>>>>                Move (iCount + 1) to iItemTo
34802>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
34803>>>>>>>            End
34803>>>>>>>>
34803>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
34805>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
34806>>>>>>>                If (iItemTo <> -1) Begin
34808>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
34809>>>>>>>                End
34809>>>>>>>>
34809>>>>>>>                Else Begin
34810>>>>>>>                    Move APITableEmpty to APITableTo
34811>>>>>>>                End
34811>>>>>>>>
34811>>>>>>>            End
34811>>>>>>>>
34811>>>>>>>
34811>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
34812>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
34813>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
34814>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
34815>>>>>>>
34815>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
34816>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
34817>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
34818>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
34819>>>>>>>
34819>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
34820>>>>>>>
34820>>>>>>>            If (hTable > 0) Begin
34822>>>>>>>
34822>>>>>>>                // Table info:
34822>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
34823>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
34824>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
34825>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
34826>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
34827>>>>>>>
34827>>>>>>>                // Column info:
34827>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
34828>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
34829>>>>>>>
34829>>>>>>>                // Index info:
34829>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
34830>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
34831>>>>>>>
34831>>>>>>>                // Relation info:
34831>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
34832>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
34833>>>>>>>
34833>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
34834>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
34835>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
34836>>>>>>>                If (iItemTo > iItemFrom) Begin
34838>>>>>>>                    Increment iCount
34839>>>>>>>                End
34839>>>>>>>>
34839>>>>>>>                Increment iItem
34840>>>>>>>            End
34840>>>>>>>>
34840>>>>>>>
34840>>>>>>>        Loop
34841>>>>>>>>
34841>>>>>>>
34841>>>>>>>        Function_Return aAPITableCompare
34842>>>>>>>    End_Function
34843>>>>>>>
34843>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
34845>>>>>>>        Integer iSize iCount iItem
34845>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34845>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34845>>>>>>>
34845>>>>>>>        Move -1 to iItem
34846>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
34847>>>>>>>        Decrement iSize
34848>>>>>>>        For iCount from 0 to iSize
34854>>>>>>>>
34854>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
34855>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
34857>>>>>>>                Move iCount to iItem
34858>>>>>>>                Move iSize  to iCount // We're done.
34859>>>>>>>            End
34859>>>>>>>>
34859>>>>>>>        Loop
34860>>>>>>>>
34860>>>>>>>
34860>>>>>>>        Function_Return iItem
34861>>>>>>>    End_Function
34862>>>>>>>
34862>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
34864>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34864>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34864>>>>>>>
34864>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
34866>>>>>>>            Function_Return APITableNameInfoCompare
34867>>>>>>>        End
34867>>>>>>>>
34867>>>>>>>
34867>>>>>>>        // FROM database info:
34867>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
34869>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
34870>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
34871>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
34872>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
34873>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
34874>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
34875>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
34876>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
34877>>>>>>>        End
34877>>>>>>>>
34877>>>>>>>
34877>>>>>>>        // TO database info:
34877>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
34879>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
34880>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
34881>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
34882>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
34883>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
34884>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
34885>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
34886>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
34887>>>>>>>        End
34887>>>>>>>>
34887>>>>>>>
34887>>>>>>>        Function_Return APITableNameInfoCompare
34888>>>>>>>    End_Function
34889>>>>>>>
34889>>>>>>>    // Note:
34889>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
34889>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
34889>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
34889>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
34889>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
34889>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
34891>>>>>>>        String sTableName
34891>>>>>>>        Boolean bOpen bExists bOK
34891>>>>>>>
34891>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
34892>>>>>>>        If (bExists = False) Begin
34894>>>>>>>            Function_Return ""
34895>>>>>>>        End
34895>>>>>>>>
34895>>>>>>>
34895>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34896>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
34899>>>>>>>        If (bOpen = False) Begin
34901>>>>>>>            Get AutoConnectionIDLogin to bOK
34902>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
34903>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
34904>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
34905>>>>>>>            Open hTable
34907>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
34908>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
34909>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
34910>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
34913>>>>>>>        End
34913>>>>>>>>
34913>>>>>>>        If (bOpen = True) Begin
34915>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
34916>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
34919>>>>>>>            // If blank it is an embedded table:
34919>>>>>>>            If (sTableName = "") Begin
34921>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
34924>>>>>>>                Move 0 to LastErr
34925>>>>>>>                Move False to Err
34926>>>>>>>            End
34926>>>>>>>>
34926>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
34927>>>>>>>        End
34927>>>>>>>>
34927>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34928>>>>>>>        Move 0 to LastErr
34929>>>>>>>
34929>>>>>>>        Function_Return sTableName
34930>>>>>>>    End_Function
34931>>>>>>>
34931>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
34931>>>>>>>    // Returns 0 if unsuccessful.
34931>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
34931>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
34933>>>>>>>        String sValue sPrefixTableName sDriverID
34933>>>>>>>        Handle hTable hRetval
34933>>>>>>>
34933>>>>>>>        Get psDriverID to sDriverID
34934>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
34936>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
34937>>>>>>>        End
34937>>>>>>>>
34937>>>>>>>        Move 0 to hTable
34938>>>>>>>        Move 0 to hRetval
34939>>>>>>>        Repeat
34939>>>>>>>>
34939>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34942>>>>>>>            If (hTable <> 0) Begin
34944>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
34947>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
34949>>>>>>>                    Move hTable to hRetval
34950>>>>>>>                    Move 0 to hTable
34951>>>>>>>                End
34951>>>>>>>>
34951>>>>>>>            End
34951>>>>>>>>
34951>>>>>>>        Until (hTable = 0)
34953>>>>>>>
34953>>>>>>>        Function_Return hRetval
34954>>>>>>>    End_Function
34955>>>>>>>
34955>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
34955>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
34955>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
34957>>>>>>>        Boolean bOK bExists
34957>>>>>>>        String sDataPath sBackupFolder
34957>>>>>>>
34957>>>>>>>        Close DF_ALL DF_PERMANENT
34958>>>>>>>        Send DoAdvance of ghoProgressBar
34959>>>>>>>
34959>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
34960>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
34961>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
34962>>>>>>>        Get vFolderFormat sDataPath to sDataPath
34963>>>>>>>
34963>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
34964>>>>>>>        If (bExists = False) Begin
34966>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
34967>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
34968>>>>>>>            If (bExists = False) Begin
34970>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
34971>>>>>>>>
34971>>>>>>>                Function_Return False
34972>>>>>>>            End
34972>>>>>>>>
34972>>>>>>>        End
34972>>>>>>>>
34972>>>>>>>
34972>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
34973>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
34974>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
34975>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
34976>>>>>>>        // We need to wait for Windows before we can copy files back
34976>>>>>>>        Sleep 2  
34977>>>>>>>        
34977>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
34977>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
34978>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
34979>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
34980>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
34981>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
34982>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
34983>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
34983>>>>>>>        
34983>>>>>>>
34983>>>>>>>        Set Message_Text of ghoStatusPanel to ""
34984>>>>>>>        Function_Return True
34985>>>>>>>    End_Function
34986>>>>>>>    
34986>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
34988>>>>>>>        Boolean bOK bRetval
34988>>>>>>>        Handle hTable
34988>>>>>>>        Integer iSize iCount
34988>>>>>>>        
34988>>>>>>>        Move True to bOK
34989>>>>>>>        Get UtilFilelistNoOfTables to iSize
34990>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
34991>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
34992>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
34993>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
34994>>>>>>>
34994>>>>>>>        Repeat
34994>>>>>>>>
34994>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
34995>>>>>>>            Increment iCount
34996>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34999>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
35001>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
35002>>>>>>>                If (bRetval = False) Begin
35004>>>>>>>                    Move False to bOK
35005>>>>>>>                End
35005>>>>>>>>
35005>>>>>>>            End
35005>>>>>>>>
35005>>>>>>>        Until (hTable = 0)
35007>>>>>>>                
35007>>>>>>>        Function_Return bOK
35008>>>>>>>    End_Function           
35009>>>>>>>    
35009>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
35009>>>>>>>    // After the header has been repaired - also makes a re-index.  
35009>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
35009>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
35011>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
35011>>>>>>>        Integer iRetval
35011>>>>>>>        String sRootName sFileName sDataPath
35011>>>>>>>        
35011>>>>>>>        Move False to Err
35012>>>>>>>        Move 0 to LastErr 
35013>>>>>>>        Move True to bOK
35014>>>>>>>        
35014>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
35015>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
35017>>>>>>>            Function_Return True
35018>>>>>>>        End
35018>>>>>>>>
35018>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
35019>>>>>>>        If (bIsAlias = True) Begin
35021>>>>>>>            Function_Return True
35022>>>>>>>        End
35022>>>>>>>>
35022>>>>>>>        
35022>>>>>>>        // Check for bad file and remove if exists
35022>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
35025>>>>>>>        Set private.phCurrentTable to hTable  
35026>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
35027>>>>>>>        
35027>>>>>>>        // This is important! Else it can happen that the table can't be opened,
35027>>>>>>>        // with a "4077 - File in use" error.
35027>>>>>>>        Close DF_ALL DF_PERMANENT    
35028>>>>>>>        Open hTable
35030>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35033>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35034>>>>>>>        If (bIsOpen = False) Begin
35036>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
35037>>>>>>>>
35037>>>>>>>            Function_Return False        
35038>>>>>>>        End
35038>>>>>>>>
35038>>>>>>>
35038>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
35039>>>>>>>        If (bBadExists = True) Begin
35041>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
35042>>>>>>>            Get vDeleteFile sFileName to iRetval
35043>>>>>>>        End
35043>>>>>>>>
35043>>>>>>>        
35043>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
35044>>>>>>>        
35044>>>>>>>        Move False to Err
35045>>>>>>>        // **** Repair and reindex the table. ****
35045>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
35046>>>>>>>
35046>>>>>>>        // Check for bad file: if it exists, something went wrong
35046>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
35047>>>>>>>        Get vFolderFormat sDataPath to sDataPath
35048>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
35049>>>>>>>        If (bBadExists = True) Begin
35051>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
35052>>>>>>>>
35052>>>>>>>            Move False to bOK
35053>>>>>>>        End
35053>>>>>>>>
35053>>>>>>>        Close hTable
35054>>>>>>>
35054>>>>>>>        Function_Return bOK
35055>>>>>>>    End_Function
35056>>>>>>>
35056>>>>>>>    // Repair and reindex the named DataFlex data-table.
35056>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
35056>>>>>>>    // so use with care (make sure you only pass embedded table names).
35056>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
35058>>>>>>>        String sMode
35058>>>>>>>        Integer iVoid
35058>>>>>>>
35058>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
35059>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
35060>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
35061>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
35066>>>>>>>        Set Message_Text of ghoStatusPanel to ""
35067>>>>>>>        Function_Return (iVoid = 0)
35068>>>>>>>    End_Function
35069>>>>>>>
35069>>>>>>>    // Returns _two_ arrays.
35069>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
35069>>>>>>>    // Also returns all files that are Alias files in a second array.
35069>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
35069>>>>>>>    //            the DoSetAllMasterAndAlias message.
35069>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
35071>>>>>>>        Integer[] iaFileIsAlias
35072>>>>>>>        Integer hTable iFileAlias iSize
35072>>>>>>>        Boolean bOpen
35072>>>>>>>
35072>>>>>>>        Move 0 to hTable
35073>>>>>>>        Repeat
35073>>>>>>>>
35073>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
35076>>>>>>>            If (hTable <> 0) Begin
35078>>>>>>>                Open hTable
35080>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
35083>>>>>>>                If (bOpen = True) Begin
35085>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
35088>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
35090>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
35091>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
35092>>>>>>>                    End
35092>>>>>>>>
35092>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
35095>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
35096>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
35097>>>>>>>                    End
35097>>>>>>>>
35097>>>>>>>                End
35097>>>>>>>>
35097>>>>>>>            End
35097>>>>>>>>
35097>>>>>>>        Until (hTable = 0)
35099>>>>>>>
35099>>>>>>>        Function_Return iaFileIsAlias
35100>>>>>>>    End_Function  
35101>>>>>>>    
35101>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
35101>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
35103>>>>>>>        String sMode
35103>>>>>>>        Integer iRepairNeeded bIsOpen
35103>>>>>>>
35103>>>>>>>        Move "0" to sMode
35104>>>>>>>        Set private.phCurrentTable to hTable 
35105>>>>>>>        Close hTable
35106>>>>>>>        Open hTable
35108>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35111>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
35116>>>>>>>
35116>>>>>>>        Function_Return iRepairNeeded
35117>>>>>>>    End_Function
35118>>>>>>>
35118>>>>>>>
35118>>>>>>>    // Helper function
35118>>>>>>>    // Takes two params:
35118>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
35118>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
35118>>>>>>>    // Returns:
35118>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
35118>>>>>>>    //  DF_FILE_IS_MASTER if master
35118>>>>>>>    //  DF_FILE_IS_ALIAS if alias
35118>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
35120>>>>>>>        Integer i iSize
35120>>>>>>>
35120>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
35121>>>>>>>        Decrement iSize
35122>>>>>>>        for i from 0 to iSize
35128>>>>>>>>
35128>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
35130>>>>>>>                Function_Return DF_FILE_IS_MASTER
35131>>>>>>>            End
35131>>>>>>>>
35131>>>>>>>        Loop
35132>>>>>>>>
35132>>>>>>>
35132>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
35133>>>>>>>        Decrement iSize
35134>>>>>>>        for i from 0 to iSize
35140>>>>>>>>
35140>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
35142>>>>>>>                Function_Return DF_FILE_IS_ALIAS
35143>>>>>>>            End
35143>>>>>>>>
35143>>>>>>>        Loop
35144>>>>>>>>
35144>>>>>>>
35144>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
35145>>>>>>>    End_Function
35146>>>>>>>
35146>>>>>>>    // Determine the available indexes of a table.
35146>>>>>>>    //
35146>>>>>>>    // Arguments:
35146>>>>>>>    //   Handle hTable - The number of the table
35146>>>>>>>    //
35146>>>>>>>    // Returns:
35146>>>>>>>    //   String - A string to be used with the sort command
35146>>>>>>>    //   to re-index all indexes of a table.
35146>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
35148>>>>>>>        String  sSortString
35148>>>>>>>        Integer iLastIndex iNumSegments iCount
35148>>>>>>>
35148>>>>>>>        Move "" to sSortString
35149>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
35152>>>>>>>
35152>>>>>>>        for iCount from 1 to iLastIndex
35158>>>>>>>>
35158>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
35161>>>>>>>            If iNumSegments Begin
35163>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
35166>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
35167>>>>>>>            End
35167>>>>>>>>
35167>>>>>>>        Loop
35168>>>>>>>>
35168>>>>>>>
35168>>>>>>>        Function_Return sSortString
35169>>>>>>>    End_Function
35170>>>>>>>
35170>>>>>>>    
35170>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35170>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
35172>>>>>>>        Function_Return False
35173>>>>>>>    End_Function
35174>>>>>>>
35174>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
35174>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
35176>>>>>>>        Boolean bIsSame
35176>>>>>>>        Integer iCount iColumns iColumn
35176>>>>>>>
35176>>>>>>>        Move True to bIsSame
35177>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
35178>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
35179>>>>>>>        Decrement iColumns
35180>>>>>>>
35180>>>>>>>        for iCount from 0 to iColumns
35186>>>>>>>>
35186>>>>>>>            Set piPosition of ghoProgressBar to iCount
35187>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
35188>>>>>>>            If (bIsSame = False) Begin
35190>>>>>>>                Function_Return False
35191>>>>>>>            End
35191>>>>>>>>
35191>>>>>>>        Loop
35192>>>>>>>>
35192>>>>>>>
35192>>>>>>>        Function_Return (bIsSame = True)
35193>>>>>>>    End_Function
35194>>>>>>>
35194>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
35194>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
35196>>>>>>>        Integer iFromType iToType iDbType
35196>>>>>>>        tColumnType ColumnType
35196>>>>>>>        tColumnType ColumnType
35196>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
35196>>>>>>>
35196>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
35198>>>>>>>            Function_Return False
35199>>>>>>>        End
35199>>>>>>>>
35199>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
35201>>>>>>>            Function_Return False
35202>>>>>>>        End
35202>>>>>>>>
35202>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
35204>>>>>>>            Function_Return False
35205>>>>>>>        End                                                                
35205>>>>>>>>
35205>>>>>>>
35205>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
35207>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
35209>>>>>>>                Function_Return False
35210>>>>>>>            End
35210>>>>>>>>
35210>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
35212>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
35214>>>>>>>                    End
35214>>>>>>>>
35214>>>>>>>                Else Begin
35215>>>>>>>                    Function_Return False
35216>>>>>>>                End
35216>>>>>>>>
35216>>>>>>>            End
35216>>>>>>>>
35216>>>>>>>        End
35216>>>>>>>>
35216>>>>>>>
35216>>>>>>>        Get piDbType                       to iDbType
35217>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
35218>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
35219>>>>>>>
35219>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
35219>>>>>>>        // data types between Embedded and SQL.
35219>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
35221>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
35222>>>>>>>        End
35222>>>>>>>>
35222>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
35224>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
35225>>>>>>>        End
35225>>>>>>>>
35225>>>>>>>
35225>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
35226>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
35227>>>>>>>
35227>>>>>>>        // Make Date and DateTime comparison?
35227>>>>>>>        If (bCompareDate_DataTime = True) Begin
35229>>>>>>>            If (iFromType <> iToType) Begin
35231>>>>>>>                Function_Return False
35232>>>>>>>            End
35232>>>>>>>>
35232>>>>>>>        End
35232>>>>>>>>
35232>>>>>>>
35232>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
35232>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
35234>>>>>>>            If (iFromType <> iToType) Begin
35236>>>>>>>                Function_Return False
35237>>>>>>>            End
35237>>>>>>>>
35237>>>>>>>        End
35237>>>>>>>>
35237>>>>>>>
35237>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
35237>>>>>>>        If (bIsDateTypeFrom = False) Begin
35239>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
35241>>>>>>>                Function_Return False
35242>>>>>>>            End
35242>>>>>>>>
35242>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
35244>>>>>>>                Function_Return False
35245>>>>>>>            End
35245>>>>>>>>
35245>>>>>>>        End
35245>>>>>>>>
35245>>>>>>>
35245>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
35247>>>>>>>            Function_Return False
35248>>>>>>>        End
35248>>>>>>>>
35248>>>>>>>
35248>>>>>>>        Function_Return True
35249>>>>>>>    End_Function
35250>>>>>>>
35250>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
35252>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
35252>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
35252>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
35252>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
35254>>>>>>>        String sDriverID sRootName sLogicalName
35254>>>>>>>
35254>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35255>>>>>>>        Get piDbType to iDbType
35256>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
35259>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
35262>>>>>>>
35262>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35265>>>>>>>        If (bIsOpen = False) Begin
35267>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35268>>>>>>>            Open hTable
35270>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35271>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35274>>>>>>>            If (bIsOpen = False) Begin
35276>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35277>>>>>>>                Move True to APIColumnsEmpty[0].bError
35278>>>>>>>                Function_Return APIColumnsEmpty
35279>>>>>>>            End
35279>>>>>>>>
35279>>>>>>>        End
35279>>>>>>>>
35279>>>>>>>
35279>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35282>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
35283>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
35284>>>>>>>
35284>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
35285>>>>>>>        If (bIsSqlTable = True) Begin
35287>>>>>>>            Get UtilTableExists hTable to bExists
35288>>>>>>>            If (bExists = False) Begin
35290>>>>>>>                Move True to APIColumnsEmpty[0].bError
35291>>>>>>>                Function_Return APIColumnsEmpty
35292>>>>>>>            End
35292>>>>>>>>
35292>>>>>>>        End
35292>>>>>>>>
35292>>>>>>>
35292>>>>>>>        Move 0 to iCount
35293>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35296>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
35297>>>>>>>
35297>>>>>>>        for iColumn from 1 to iNumColumns
35303>>>>>>>>
35303>>>>>>>            Move 0 to iOptions
35304>>>>>>>            Move False to bIdentityKey
35305>>>>>>>            Move False to Err
35306>>>>>>>            Move 0     to LastErr
35307>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
35308>>>>>>>            Set piPosition of ghoProgressBar to iColumn
35309>>>>>>>            If (bDawSqlDriver = True) Begin
35311>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35312>>>>>>>                If (bIsSqlTable = True) Begin
35314>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
35317>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
35318>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
35321>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
35324>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
35327>>>>>>>                End
35327>>>>>>>>
35327>>>>>>>                Else Begin
35328>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
35331>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
35332>>>>>>>                End
35332>>>>>>>>
35332>>>>>>>
35332>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
35332>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
35335>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
35336>>>>>>>                If (bExists = False) Begin
35338>>>>>>>                    Move 0 to APIColumns[iCount].iType
35339>>>>>>>                End
35339>>>>>>>>
35339>>>>>>>                If (bExists = True) Begin
35341>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
35344>>>>>>>                End
35344>>>>>>>>
35344>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35345>>>>>>>                If (bIdentityKey = True) Begin
35347>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
35348>>>>>>>                End
35348>>>>>>>>
35348>>>>>>>            End
35348>>>>>>>>
35348>>>>>>>            Else Begin
35349>>>>>>>                Move False to Err
35350>>>>>>>                Move 0     to LastErr
35351>>>>>>>                If (bIsSqlTable = True) Begin
35353>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
35356>>>>>>>                End
35356>>>>>>>>
35356>>>>>>>                Else Begin
35357>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
35360>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
35361>>>>>>>                End
35361>>>>>>>>
35361>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
35361>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
35362>>>>>>>                If (bExists = False) Begin
35364>>>>>>>                    Move 0 to APIColumns[iCount].iType
35365>>>>>>>                End
35365>>>>>>>>
35365>>>>>>>            End
35365>>>>>>>>
35365>>>>>>>
35365>>>>>>>            If (bExists = True) Begin
35367>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
35368>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
35371>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
35371>>>>>>>//                If (bIsSqlTable = True) Begin
35371>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
35371>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
35371>>>>>>>//                End
35371>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
35374>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
35377>>>>>>>
35377>>>>>>>                // If the length was zero we might have an Overlap(!) field.
35377>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
35377>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
35379>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
35382>>>>>>>                    If (iType = DF_OVERLAP) Begin
35384>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
35385>>>>>>>                        Move 0 to APIColumns[iCount].iLength
35386>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
35387>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
35388>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
35389>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
35390>>>>>>>                        Decrement iCount
35391>>>>>>>                    End
35391>>>>>>>>
35391>>>>>>>                End
35391>>>>>>>>
35391>>>>>>>            End
35391>>>>>>>>
35391>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
35392>>>>>>>            If (bUserCancel = True) Begin
35394>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
35395>>>>>>>                Function_Return APIColumnsEmpty
35396>>>>>>>            End
35396>>>>>>>>
35396>>>>>>>            Increment iCount
35397>>>>>>>        Loop
35398>>>>>>>>
35398>>>>>>>
35398>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35399>>>>>>>        Function_Return APIColumns
35400>>>>>>>    End_Function
35401>>>>>>>
35401>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
35401>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
35401>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
35401>>>>>>>    // have "holes" in the series of index numbers.
35401>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
35403>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35403>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35404>>>>>>>        tAPIColumnCompare   APIColumnCompare
35404>>>>>>>        tAPIColumnCompare   APIColumnCompare
35404>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
35404>>>>>>>
35404>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
35405>>>>>>>        Decrement iSizeFrom
35406>>>>>>>        for iCount from 0 to iSizeFrom
35412>>>>>>>>
35412>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
35413>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
35414>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
35415>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
35416>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
35417>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
35418>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
35419>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
35420>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
35421>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
35422>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
35423>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
35424>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
35425>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
35426>>>>>>>        Loop
35427>>>>>>>>
35427>>>>>>>
35427>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
35428>>>>>>>        Decrement iSizeTo
35429>>>>>>>        for iCount from 0 to iSizeTo
35435>>>>>>>>
35435>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
35436>>>>>>>            // Search if the field number already exists in the array; else add it.
35436>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
35437>>>>>>>            If (iItem = -1) Begin
35439>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
35440>>>>>>>            End
35440>>>>>>>>
35440>>>>>>>
35440>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
35441>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
35442>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
35443>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
35444>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
35445>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
35446>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
35447>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
35448>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
35449>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
35450>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
35451>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
35452>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
35453>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
35454>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
35455>>>>>>>        Loop
35456>>>>>>>>
35456>>>>>>>
35456>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
35457>>>>>>>
35457>>>>>>>        Function_Return aAPIColumnCompare
35458>>>>>>>    End_Function
35459>>>>>>>
35459>>>>>>>    // Checks if a field name exists in a table definition
35459>>>>>>>    // Returns True if it does
35459>>>>>>>    // Sample:
35459>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
35459>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
35461>>>>>>>        Integer iNumColumns iColumn
35461>>>>>>>        String sColumn
35461>>>>>>>        Boolean bExists bOK bOpen
35461>>>>>>>
35461>>>>>>>        Get AutoConnectionIDLogin to bOK
35462>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35463>>>>>>>        Open hTable
35465>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35466>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
35469>>>>>>>        If (bOpen = False) Begin
35471>>>>>>>            Function_Return False
35472>>>>>>>        End
35472>>>>>>>>
35472>>>>>>>
35472>>>>>>>        Move False to bExists
35473>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35476>>>>>>>        for iColumn from 1 to iNumColumns
35482>>>>>>>>
35482>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
35485>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
35487>>>>>>>                Move iNumColumns to iColumn
35488>>>>>>>                Move True to bExists
35489>>>>>>>            End
35489>>>>>>>>
35489>>>>>>>        Loop
35490>>>>>>>>
35490>>>>>>>        Close hTable
35491>>>>>>>
35491>>>>>>>        Function_Return bExists
35492>>>>>>>    End_Function
35493>>>>>>>
35493>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
35493>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
35495>>>>>>>        Integer iNumColumns iColumn iRetval
35495>>>>>>>        String sColumn
35495>>>>>>>        Boolean bOK bOpen
35495>>>>>>>
35495>>>>>>>        Get AutoConnectionIDLogin to bOK
35496>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35497>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35498>>>>>>>        Open hTable
35500>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35501>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
35504>>>>>>>        If (bOpen = False) Begin
35506>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35507>>>>>>>            Function_Return False
35508>>>>>>>        End
35508>>>>>>>>
35508>>>>>>>
35508>>>>>>>        Move 0 to iColumn
35509>>>>>>>        Move 0 to iRetval
35510>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35513>>>>>>>        for iColumn from 1 to iNumColumns
35519>>>>>>>>
35519>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
35522>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
35524>>>>>>>                Move iColumn to iRetval
35525>>>>>>>                Move iNumColumns to iColumn
35526>>>>>>>            End
35526>>>>>>>>
35526>>>>>>>        Loop
35527>>>>>>>>
35527>>>>>>>        Close hTable
35528>>>>>>>
35528>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35529>>>>>>>        Function_Return iRetval
35530>>>>>>>    End_Function
35531>>>>>>>
35531>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
35531>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
35531>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
35533>>>>>>>        tColumnType RetvalType
35533>>>>>>>        tColumnType RetvalType
35533>>>>>>>
35533>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
35534>>>>>>>        Function_Return RetvalType.iSQLType
35535>>>>>>>    End_Function
35536>>>>>>>
35536>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
35536>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
35536>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
35538>>>>>>>        tColumnType RetvalType
35538>>>>>>>        tColumnType RetvalType
35538>>>>>>>
35538>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35539>>>>>>>        Function_Return RetvalType.sSQLType
35540>>>>>>>    End_Function
35541>>>>>>>
35541>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
35543>>>>>>>        tColumnType RetvalType
35543>>>>>>>        tColumnType RetvalType
35543>>>>>>>
35543>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35544>>>>>>>        Function_Return RetvalType.sPrecision
35545>>>>>>>    End_Function
35546>>>>>>>
35546>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
35548>>>>>>>        tColumnType RetvalType
35548>>>>>>>        tColumnType RetvalType
35548>>>>>>>
35548>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35549>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
35549>>>>>>>        // if the column type length is _not_ fixed.
35549>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
35550>>>>>>>    End_Function
35551>>>>>>>
35551>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
35553>>>>>>>        tColumnType RetvalType
35553>>>>>>>        tColumnType RetvalType
35553>>>>>>>        String sValue
35553>>>>>>>        Integer iRetval iPos
35553>>>>>>>
35553>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35554>>>>>>>        Move RetvalType.sPrecision to sValue
35555>>>>>>>        Move (Pos(".", sValue)) to iPos
35556>>>>>>>        If (iPos <> 0) Begin
35558>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
35559>>>>>>>        End
35559>>>>>>>>
35559>>>>>>>        Else Begin
35560>>>>>>>            Move sValue to iRetval
35561>>>>>>>        End
35561>>>>>>>>
35561>>>>>>>        Function_Return iRetval
35562>>>>>>>    End_Function
35563>>>>>>>
35563>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
35565>>>>>>>        tColumnType RetvalType
35565>>>>>>>        tColumnType RetvalType
35565>>>>>>>        String sValue
35565>>>>>>>        Integer iRetval iPos
35565>>>>>>>
35565>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35566>>>>>>>        Move RetvalType.sPrecision to sValue
35567>>>>>>>        Move (Pos(".", sValue)) to iPos
35568>>>>>>>        If (iPos = 0) Begin
35570>>>>>>>            Function_Return 0
35571>>>>>>>        End
35571>>>>>>>>
35571>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
35572>>>>>>>
35572>>>>>>>        Function_Return iRetval
35573>>>>>>>    End_Function
35574>>>>>>>
35574>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35574>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
35576>>>>>>>        Function_Return False
35577>>>>>>>    End_Function
35578>>>>>>>
35578>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
35578>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
35580>>>>>>>        Boolean bIsSame
35580>>>>>>>        Integer iCount iSize
35580>>>>>>>
35580>>>>>>>        Move True to bIsSame
35581>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
35582>>>>>>>        Decrement iSize
35583>>>>>>>        For iCount from 0 to iSize
35589>>>>>>>>
35589>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35590>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35591>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
35592>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35593>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35594>>>>>>>            If (bIsSame = False) Begin
35596>>>>>>>                Function_Return False
35597>>>>>>>            End
35597>>>>>>>>
35597>>>>>>>        Loop
35598>>>>>>>>
35598>>>>>>>
35598>>>>>>>        Function_Return bIsSame
35599>>>>>>>    End_Function
35600>>>>>>>
35600>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
35600>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
35602>>>>>>>        Boolean bIsSame
35602>>>>>>>        Integer iSegment
35602>>>>>>>
35602>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
35603>>>>>>>        If (bIsSame = False) Begin
35605>>>>>>>            Function_Return False
35606>>>>>>>        End
35606>>>>>>>>
35606>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
35607>>>>>>>        If (bIsSame = False) Begin
35609>>>>>>>            Function_Return False
35610>>>>>>>        End
35610>>>>>>>>
35610>>>>>>>
35610>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
35612>>>>>>>            // * We should probably not compare SQL index names?
35612>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
35612>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
35612>>>>>>>            //     Function_Return False
35612>>>>>>>            // End
35612>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
35613>>>>>>>            If (bIsSame = False) Begin
35615>>>>>>>                Function_Return False
35616>>>>>>>            End
35616>>>>>>>>
35616>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
35617>>>>>>>            If (bIsSame = False) Begin
35619>>>>>>>                Function_Return False
35620>>>>>>>            End
35620>>>>>>>>
35620>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
35621>>>>>>>            If (bIsSame = False) Begin
35623>>>>>>>                Function_Return False
35624>>>>>>>            End
35624>>>>>>>>
35624>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
35625>>>>>>>            If (bIsSame = False) Begin
35627>>>>>>>                Function_Return False
35628>>>>>>>            End
35628>>>>>>>>
35628>>>>>>>        End
35628>>>>>>>>
35628>>>>>>>
35628>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
35629>>>>>>>        Move (iSegment = -1) to bIsSame
35630>>>>>>>
35630>>>>>>>        Function_Return (bIsSame = True)
35631>>>>>>>    End_Function
35632>>>>>>>
35632>>>>>>>    // Compares each segment for the passed index.
35632>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
35632>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
35634>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
35634>>>>>>>        Boolean bIsSame
35634>>>>>>>
35634>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35635>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35636>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
35637>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
35638>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
35639>>>>>>>
35639>>>>>>>        Decrement iNumSegments
35640>>>>>>>        for iSegment from 0 to iNumSegments
35646>>>>>>>>
35646>>>>>>>            Move False to bIsSame
35647>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
35649>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
35650>>>>>>>            End
35650>>>>>>>>
35650>>>>>>>            If (bIsSame = False) Begin
35652>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35653>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35654>>>>>>>                Function_Return iSegment
35655>>>>>>>            End
35655>>>>>>>>
35655>>>>>>>        Loop
35656>>>>>>>>
35656>>>>>>>
35656>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35657>>>>>>>        Function_Return -1 // This means bIsSame = True
35658>>>>>>>    End_Function
35659>>>>>>>
35659>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
35661>>>>>>>        Boolean bIsSame
35661>>>>>>>
35661>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
35662>>>>>>>        If (bIsSame = False) Begin
35664>>>>>>>            Function_Return False
35665>>>>>>>        End
35665>>>>>>>>
35665>>>>>>>        If (bCompareIndexUppercase = True) Begin
35667>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
35668>>>>>>>            If (bIsSame = False) Begin
35670>>>>>>>                Function_Return False
35671>>>>>>>            End
35671>>>>>>>>
35671>>>>>>>        End
35671>>>>>>>>
35671>>>>>>>        If (bCompareIndexAscending = True) Begin
35673>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
35674>>>>>>>            If (bIsSame = False) Begin
35676>>>>>>>                Function_Return False
35677>>>>>>>            End
35677>>>>>>>>
35677>>>>>>>        End
35677>>>>>>>>
35677>>>>>>>
35677>>>>>>>        Function_Return True
35678>>>>>>>    End_Function
35679>>>>>>>
35679>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
35681>>>>>>>        Boolean bIsSame bOK
35681>>>>>>>        Integer iSize iSizeTo iCount
35681>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35681>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35682>>>>>>>
35682>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
35683>>>>>>>        If (iSize = 0) Begin
35685>>>>>>>            Function_Return True
35686>>>>>>>        End
35686>>>>>>>>
35686>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
35687>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
35688>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
35689>>>>>>>
35689>>>>>>>        for iCount from 0 to (iSize - 1)
35695>>>>>>>>
35695>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
35696>>>>>>>            If (bIsSame = False) Begin
35698>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
35699>>>>>>>            End
35699>>>>>>>>
35699>>>>>>>        Loop
35700>>>>>>>>
35700>>>>>>>
35700>>>>>>>        // We probably should delete other indexes if they exists.
35700>>>>>>>        for iCount from (iSize +1) to iSizeTo
35706>>>>>>>>
35706>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
35707>>>>>>>        Loop
35708>>>>>>>>
35708>>>>>>>
35708>>>>>>>        Function_Return bOK
35709>>>>>>>    End_Function
35710>>>>>>>
35710>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
35710>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
35710>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
35710>>>>>>>//        String sFieldName sDriverID
35710>>>>>>>//
35710>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35710>>>>>>>//        If (bIsOpen = False) Begin
35710>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35710>>>>>>>//            Open hTable
35710>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35710>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35710>>>>>>>//            If (bIsOpen = False) Begin
35710>>>>>>>//                Function_Return False
35710>>>>>>>//            End
35710>>>>>>>//        End
35710>>>>>>>//
35710>>>>>>>//        Move True to bEqual
35710>>>>>>>//        Get psDriverID to sDriverID
35710>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
35710>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
35710>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
35710>>>>>>>//        Decrement iSize
35710>>>>>>>//
35710>>>>>>>//        For iCount from 0 to iSize
35710>>>>>>>//            Move 0 to iOptions
35710>>>>>>>//            Move False to bIdentityKey
35710>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
35710>>>>>>>//
35710>>>>>>>//            // We need to use the column name - not the column integer as
35710>>>>>>>//            // the order does not need to be the same, and the logic should still work.
35710>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
35710>>>>>>>//            If (iColumn > 0) Begin
35710>>>>>>>//                If (bDawSqlDriver = True) Begin
35710>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35710>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
35710>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
35710>>>>>>>//                        Move False to bEqual
35710>>>>>>>//                    End
35710>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
35710>>>>>>>//                    If (bIdentityKey = True) Begin
35710>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
35710>>>>>>>//                    End
35710>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
35710>>>>>>>//                        Move False to bEqual
35710>>>>>>>//                    End
35710>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35710>>>>>>>//                End
35710>>>>>>>//                Else Begin
35710>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
35710>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
35710>>>>>>>//                        Move False to bEqual
35710>>>>>>>//                    End
35710>>>>>>>//                End
35710>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
35710>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
35710>>>>>>>//                    Move False to bEqual
35710>>>>>>>//                End
35710>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
35710>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
35710>>>>>>>//                    Move False to bEqual
35710>>>>>>>//                End
35710>>>>>>>//                If (bEqual = False) Begin
35710>>>>>>>//                    Function_Return False
35710>>>>>>>//                End
35710>>>>>>>//            End
35710>>>>>>>//
35710>>>>>>>//            Else Begin
35710>>>>>>>//                Function_Return False
35710>>>>>>>//            End
35710>>>>>>>//        Loop
35710>>>>>>>//
35710>>>>>>>//        Function_Return bEqual
35710>>>>>>>//    End_Function
35710>>>>>>>
35710>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
35712>>>>>>>        tAPIIndex[] APIIndexes
35712>>>>>>>        tAPIIndex[] APIIndexes
35713>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
35713>>>>>>>        String sDriverID
35713>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
35713>>>>>>>
35713>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35714>>>>>>>        Get psDriverID to sDriverID
35715>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
35716>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
35717>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35720>>>>>>>        If (bIsOpen = False) Begin
35722>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35723>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35724>>>>>>>            Open hTable
35726>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35727>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35728>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35731>>>>>>>            If (bIsOpen = False) Begin
35733>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35734>>>>>>>                Move True to APIIndexes[0].bError
35735>>>>>>>                Function_Return APIIndexes
35736>>>>>>>            End
35736>>>>>>>>
35736>>>>>>>        End
35736>>>>>>>>
35736>>>>>>>
35736>>>>>>>        Move 0 to iCount
35737>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
35740>>>>>>>        for iIndex from 1 to iIndexes
35746>>>>>>>>
35746>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
35746>>>>>>>            // numbers doesn't not need to be consequitive:
35746>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
35749>>>>>>>            If (iNumSegments > 0) Begin
35751>>>>>>>
35751>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
35752>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
35755>>>>>>>                If (bIsSQLTable = True) Begin
35757>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
35760>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
35763>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
35766>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
35769>>>>>>>                End
35769>>>>>>>>
35769>>>>>>>
35769>>>>>>>                Move 0 to iSegmentCount
35770>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
35773>>>>>>>                For iSegment from 1 to iNumSegments
35779>>>>>>>>
35779>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
35782>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
35783>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
35786>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
35789>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
35792>>>>>>>                    Increment iSegmentCount
35793>>>>>>>                Loop
35794>>>>>>>>
35794>>>>>>>                Increment iCount
35795>>>>>>>            End
35795>>>>>>>>
35795>>>>>>>        Loop
35796>>>>>>>>
35796>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35797>>>>>>>
35797>>>>>>>        Function_Return APIIndexes
35798>>>>>>>    End_Function
35799>>>>>>>
35799>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
35799>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
35799>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
35799>>>>>>>    // have "holes" in the series of index numbers.
35799>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
35801>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35801>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35802>>>>>>>        tAPIIndexCompare   APIIndexCompare
35802>>>>>>>        tAPIIndexCompare   APIIndexCompare
35802>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
35802>>>>>>>
35802>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
35803>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
35804>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
35806>>>>>>>            Function_Return aAPIIndexCompare
35807>>>>>>>        End
35807>>>>>>>>
35807>>>>>>>
35807>>>>>>>        Decrement iSizeFrom
35808>>>>>>>        for iCount from 0 to iSizeFrom
35814>>>>>>>>
35814>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
35815>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
35816>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
35817>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
35818>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
35819>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
35820>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
35821>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
35822>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
35823>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
35824>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
35825>>>>>>>        Loop
35826>>>>>>>>
35826>>>>>>>
35826>>>>>>>        Decrement iSizeTo
35827>>>>>>>        for iCount from 0 to iSizeTo
35833>>>>>>>>
35833>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
35834>>>>>>>            // Search if the Index number already exists in the array; else add it.
35834>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
35835>>>>>>>            If (iItem = -1) Begin
35837>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
35838>>>>>>>            End
35838>>>>>>>>
35838>>>>>>>
35838>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
35839>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
35840>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
35841>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
35842>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
35843>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
35844>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
35845>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
35846>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
35847>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
35848>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
35849>>>>>>>        Loop
35850>>>>>>>>
35850>>>>>>>
35850>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
35851>>>>>>>
35851>>>>>>>        Function_Return aAPIIndexCompare
35852>>>>>>>    End_Function
35853>>>>>>>
35853>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
35853>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
35855>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
35855>>>>>>>        String sDriverID
35855>>>>>>>
35855>>>>>>>        Get psDriverID to sDriverID
35856>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
35857>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
35858>>>>>>>        If (bIsSqlTable = True) Begin
35860>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
35861>>>>>>>        End
35861>>>>>>>>
35861>>>>>>>
35861>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
35862>>>>>>>        If (bIsSame = False) Begin
35864>>>>>>>            Function_Return False
35865>>>>>>>        End
35865>>>>>>>>
35865>>>>>>>
35865>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
35867>>>>>>>            // Don't think we should do this. Or should we?
35867>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
35867>>>>>>>
35867>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
35868>>>>>>>            If (bIsSame = False) Begin
35870>>>>>>>                Function_Return False
35871>>>>>>>            End
35871>>>>>>>>
35871>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
35872>>>>>>>            If (bIsSame = False) Begin
35874>>>>>>>                Function_Return False
35875>>>>>>>            End
35875>>>>>>>>
35875>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
35876>>>>>>>            If (bIsSame = False) Begin
35878>>>>>>>                Function_Return False
35879>>>>>>>            End
35879>>>>>>>>
35879>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
35880>>>>>>>            If (bIsSame = False) Begin
35882>>>>>>>                Function_Return False
35883>>>>>>>            End
35883>>>>>>>>
35883>>>>>>>        End
35883>>>>>>>>
35883>>>>>>>
35883>>>>>>>        Function_Return bIsSame
35884>>>>>>>    End_Function
35885>>>>>>>
35885>>>>>>>    // DF_INDEX_SQL_TYPE values
35885>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
35885>>>>>>>    // returns a string with the name.
35885>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
35887>>>>>>>        String sRetval
35887>>>>>>>        Case Begin
35887>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
35889>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
35890>>>>>>>                Case Break
35891>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
35894>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
35895>>>>>>>                Case Break
35896>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
35899>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
35900>>>>>>>                Case Break
35901>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
35904>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
35905>>>>>>>                Case Break
35906>>>>>>>            Case Else
35906>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
35907>>>>>>>        Case End
35907>>>>>>>        Function_Return sRetval
35908>>>>>>>    End_Function
35909>>>>>>>
35909>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35909>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
35911>>>>>>>        Function_Return False
35912>>>>>>>    End_Function
35913>>>>>>>
35913>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
35913>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
35915>>>>>>>        Boolean bIsSame
35915>>>>>>>        Integer iSize iCount
35915>>>>>>>
35915>>>>>>>        Move True to bIsSame
35916>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
35917>>>>>>>        Decrement iSize
35918>>>>>>>        For iCount from 0 to iSize
35924>>>>>>>>
35924>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
35925>>>>>>>            If (bIsSame = False) Begin
35927>>>>>>>                Function_Return False
35928>>>>>>>            End
35928>>>>>>>>
35928>>>>>>>        Loop
35929>>>>>>>>
35929>>>>>>>
35929>>>>>>>        Function_Return bIsSame
35930>>>>>>>    End_Function
35931>>>>>>>
35931>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
35931>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
35933>>>>>>>        Boolean bIsSame
35933>>>>>>>
35933>>>>>>>        Move True to bIsSame
35934>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
35936>>>>>>>            Function_Return False
35937>>>>>>>        End
35937>>>>>>>>
35937>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
35939>>>>>>>            Function_Return False
35940>>>>>>>        End
35940>>>>>>>>
35940>>>>>>>
35940>>>>>>>        // We could also compare field names, but I don't think that is necessary...
35940>>>>>>>
35940>>>>>>>        Function_Return bIsSame
35941>>>>>>>    End_Function
35942>>>>>>>
35942>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
35942>>>>>>>    // already exists.
35942>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
35944>>>>>>>        Boolean bOK
35944>>>>>>>        Integer iSizeTo iSize iCount iColumn
35944>>>>>>>        String sDriverID
35944>>>>>>>
35944>>>>>>>        Move True to bOK
35945>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
35946>>>>>>>        If (iSizeTo > 0) Begin
35948>>>>>>>            Get AutoConnectionIDLogin to bOK
35949>>>>>>>            Move False to Err
35950>>>>>>>            Open hTable Mode DF_EXCLUSIVE
35952>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35955>>>>>>>            Decrement iSizeTo
35956>>>>>>>
35956>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
35956>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
35956>>>>>>>            Structure_Start hTable sDriverID
35957>>>>>>>                for iCount from 0 to iSizeTo
35963>>>>>>>>
35963>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
35964>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
35967>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
35970>>>>>>>                Loop
35971>>>>>>>>
35971>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
35972>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35974>>>>>>>            Set Action_Text of ghoStatusPanel to ""
35975>>>>>>>        End
35975>>>>>>>>
35975>>>>>>>
35975>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
35976>>>>>>>        Decrement iSize
35977>>>>>>>        for iCount from 0 to iSize
35983>>>>>>>>
35983>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
35984>>>>>>>        Loop
35985>>>>>>>>
35985>>>>>>>
35985>>>>>>>        Function_Return bOK
35986>>>>>>>    End_Function
35987>>>>>>>
35987>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
35989>>>>>>>        tAPIRelation[] APIRelations
35989>>>>>>>        tAPIRelation[] APIRelations
35990>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
35990>>>>>>>        Handle hParent
35990>>>>>>>        Boolean bIsOpen
35990>>>>>>>
35990>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35991>>>>>>>        Move 0 to iCount
35992>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35995>>>>>>>        If (bIsOpen = False) Begin
35997>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35998>>>>>>>            Open hTable
36000>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
36001>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
36004>>>>>>>            If (bIsOpen = False) Begin
36006>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
36007>>>>>>>                Move True to APIRelations[0].bError
36008>>>>>>>                Function_Return APIRelations
36009>>>>>>>            End
36009>>>>>>>>
36009>>>>>>>        End
36009>>>>>>>>
36009>>>>>>>
36009>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
36012>>>>>>>        For iColumn from 1 to iNumColumns
36018>>>>>>>>
36018>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
36021>>>>>>>            If (hParent <> 0) Begin
36023>>>>>>>                Open hParent
36025>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
36026>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
36029>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
36030>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
36033>>>>>>>
36033>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
36034>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
36037>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
36040>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
36041>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
36044>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
36045>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
36046>>>>>>>                Move False                                              to APIRelations[iCount].bError
36047>>>>>>>                Close hParent
36048>>>>>>>                Increment iCount
36049>>>>>>>            End
36049>>>>>>>>
36049>>>>>>>        Loop
36050>>>>>>>>
36050>>>>>>>
36050>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
36051>>>>>>>        Function_Return APIRelations
36052>>>>>>>    End_Function
36053>>>>>>>
36053>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
36055>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
36057>>>>>>>            Function_Return (EQ)
36058>>>>>>>        End
36058>>>>>>>>
36058>>>>>>>
36058>>>>>>>        Function_Return (GT)
36059>>>>>>>    End_Function
36060>>>>>>>
36060>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
36062>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
36065>>>>>>>
36065>>>>>>>        Function_Return (GT)
36066>>>>>>>    End_Function
36067>>>>>>>
36067>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
36067>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
36067>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
36069>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
36069>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
36070>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
36070>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
36071>>>>>>>        tAPIRelationCompare   APIRelationCompare
36071>>>>>>>        tAPIRelationCompare   APIRelationCompare
36071>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
36071>>>>>>>
36071>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
36072>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
36073>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
36075>>>>>>>            Function_Return aAPIRelationCompare
36076>>>>>>>        End
36076>>>>>>>>
36076>>>>>>>
36076>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
36077>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
36078>>>>>>>
36078>>>>>>>        Decrement iSizeFrom
36079>>>>>>>        for iCount from 0 to iSizeFrom
36085>>>>>>>>
36085>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
36086>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
36087>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
36088>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
36089>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
36090>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
36091>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
36092>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
36093>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
36094>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
36095>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
36096>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
36097>>>>>>>        Loop
36098>>>>>>>>
36098>>>>>>>
36098>>>>>>>        Decrement iSizeTo
36099>>>>>>>        for iCount from 0 to iSizeTo
36105>>>>>>>>
36105>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
36106>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
36107>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
36108>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
36109>>>>>>>
36109>>>>>>>            // Search if the relation already exists in the array; else add it.
36109>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
36110>>>>>>>            If (iItem = -1) Begin
36112>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
36113>>>>>>>            End
36113>>>>>>>>
36113>>>>>>>
36113>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
36114>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
36115>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
36116>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
36117>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
36118>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
36119>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
36120>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
36121>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
36122>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
36123>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
36124>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
36125>>>>>>>        Loop
36126>>>>>>>>
36126>>>>>>>
36126>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
36127>>>>>>>
36127>>>>>>>        Function_Return aAPIRelationCompare
36128>>>>>>>    End_Function
36129>>>>>>>
36129>>>>>>>    // * Dummy function for the Studio's Code Explorer *
36129>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
36131>>>>>>>        Function_Return False
36132>>>>>>>    End_Function
36133>>>>>>>
36133>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
36133>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
36133>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
36133>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
36135>>>>>>>        Boolean bFound
36135>>>>>>>
36135>>>>>>>        Move False to Err
36136>>>>>>>        Open CodeMast
36138>>>>>>>        Open CodeType
36140>>>>>>>
36140>>>>>>>        If (bCodeType = True) Begin
36142>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
36143>>>>>>>            Clear CodeType
36144>>>>>>>            Move sTypeValue to CODETYPE.Type
36145>>>>>>>            Find eq CODETYPE by 1
36146>>>>>>>>
36146>>>>>>>            Move Found to bFound
36147>>>>>>>            If (bFound = True) Begin
36149>>>>>>>                Reread CodeType
36153>>>>>>>            End
36153>>>>>>>>
36153>>>>>>>            Else Begin
36154>>>>>>>                Clear CodeType
36155>>>>>>>            End
36155>>>>>>>>
36155>>>>>>>
36155>>>>>>>            Move sTypeValue to CODETYPE.Type
36156>>>>>>>            Move sValue2    to CODETYPE.Description
36157>>>>>>>            Move sValue3    to CODETYPE.Comment
36158>>>>>>>            SaveRecord CODETYPE
36159>>>>>>>
36159>>>>>>>            If (bFound = True) Begin
36161>>>>>>>                Unlock
36162>>>>>>>>
36162>>>>>>>            End
36162>>>>>>>>
36162>>>>>>>        End
36162>>>>>>>>
36162>>>>>>>
36162>>>>>>>        If (bCodeType = False) Begin
36164>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
36165>>>>>>>            Clear CODEMAST
36166>>>>>>>            Move sTypeValue to CODEMAST.Type
36167>>>>>>>            Move sValue2    to CODEMAST.Code
36168>>>>>>>            Find eq CODEMAST by 1
36169>>>>>>>>
36169>>>>>>>            Move Found to bFound
36170>>>>>>>            If (bFound = True) Begin
36172>>>>>>>                Reread CODEMAST
36176>>>>>>>            End
36176>>>>>>>>
36176>>>>>>>            Else Begin
36177>>>>>>>                Clear CODEMAST
36178>>>>>>>            End
36178>>>>>>>>
36178>>>>>>>
36178>>>>>>>            Move sTypeValue to CODEMAST.Type
36179>>>>>>>            Move sValue2    to CODEMAST.Code
36180>>>>>>>            Move sValue3    to CODEMAST.Description
36181>>>>>>>            SaveRecord CODEMAST
36182>>>>>>>
36182>>>>>>>            If (bFound = True) Begin
36184>>>>>>>                Unlock
36185>>>>>>>>
36185>>>>>>>            End
36185>>>>>>>>
36185>>>>>>>        End
36185>>>>>>>>
36185>>>>>>>
36185>>>>>>>        Close CodeMast
36186>>>>>>>        Close CodeType
36187>>>>>>>
36187>>>>>>>        Function_Return (Err = False)
36188>>>>>>>    End_Function
36189>>>>>>>
36189>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
36189>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
36189>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
36191>>>>>>>        Boolean bFound
36191>>>>>>>
36191>>>>>>>        Move False to Err
36192>>>>>>>        Open CodeMast
36194>>>>>>>        Open CodeType
36196>>>>>>>
36196>>>>>>>        Clear CodeType
36197>>>>>>>        Move sFromValue to CODETYPE.Type
36198>>>>>>>        Find eq CODETYPE.Type
36199>>>>>>>>
36199>>>>>>>        If (Found = True) Begin
36201>>>>>>>            Reread CODETYPE
36205>>>>>>>                Move sToValue to CODETYPE.Type
36206>>>>>>>                SaveRecord CODETYPE
36207>>>>>>>            Unlock
36208>>>>>>>>
36208>>>>>>>        End
36208>>>>>>>>
36208>>>>>>>
36208>>>>>>>        Clear CODEMAST
36209>>>>>>>        Find gt CODEMAST by Recnum
36210>>>>>>>>
36210>>>>>>>        While (Found = True)
36214>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
36215>>>>>>>            If (bFound = True) Begin
36217>>>>>>>                Reread CODEMAST
36221>>>>>>>                    Move sToValue to CODEMAST.Type
36222>>>>>>>                    SaveRecord CODEMAST
36223>>>>>>>                Unlock
36224>>>>>>>>
36224>>>>>>>            End
36224>>>>>>>>
36224>>>>>>>            Find gt CODEMAST by Recnum
36225>>>>>>>>
36225>>>>>>>        Loop
36226>>>>>>>>
36226>>>>>>>
36226>>>>>>>        Close CodeMast
36227>>>>>>>        Close CodeType
36228>>>>>>>
36228>>>>>>>        Function_Return (Err = False)
36229>>>>>>>    End_Function
36230>>>>>>>
36230>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
36230>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
36232>>>>>>>        Boolean bFound
36232>>>>>>>
36232>>>>>>>        Move False to Err
36233>>>>>>>        Open CodeMast
36235>>>>>>>
36235>>>>>>>        Clear CODEMAST
36236>>>>>>>        Move sTypeValue to CODEMAST.Type
36237>>>>>>>        Move sValue2    to CODEMAST.Code
36238>>>>>>>        Find eq CODEMAST.Code
36239>>>>>>>>
36239>>>>>>>        Move Found to bFound
36240>>>>>>>        If (bFound = True) Begin
36242>>>>>>>            Delete CODEMAST
36243>>>>>>>        End
36243>>>>>>>>
36243>>>>>>>
36243>>>>>>>        Close CodeMast
36244>>>>>>>
36244>>>>>>>        Function_Return (Err = False)
36245>>>>>>>    End_Function
36246>>>>>>>
36246>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
36248>>>>>>>        Boolean bRecnum bToAnsi
36248>>>>>>>        Integer iCh
36248>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
36248>>>>>>>
36248>>>>>>>        If (Trim(sDataPath) = "") Begin
36250>>>>>>>            Function_Return False
36251>>>>>>>        End
36251>>>>>>>>
36251>>>>>>>
36251>>>>>>>        Move False to Err
36252>>>>>>>        Get psDriverID     to sDriverID
36253>>>>>>>        Get psConnectionID to sConnectionID
36254>>>>>>>        Get psSchema       to sSchemaName
36255>>>>>>>        Get True           to bRecnum
36256>>>>>>>        Get pbToANSI       to bToAnsi
36257>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
36258>>>>>>>        If (bToAnsi = False) Begin
36260>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
36261>>>>>>>        End
36261>>>>>>>>
36261>>>>>>>
36261>>>>>>>        Get vFolderFormat sDataPath to sDataPath
36262>>>>>>>        Move "CodeMast.int"         to sFileName
36263>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
36264>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
36267>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
36270>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
36273>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
36276>>>>>>>            Writeln channel iCh ("")
36279>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
36282>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
36285>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
36288>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
36291>>>>>>>            Writeln channel iCh ("")
36294>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
36297>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
36300>>>>>>>            Writeln channel iCh ("")
36303>>>>>>>        Send Seq_Close_Channel iCh
36304>>>>>>>
36304>>>>>>>        Get vFolderFormat sDataPath to sDataPath
36305>>>>>>>        Move "CodeType.int"         to sFileName
36306>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
36307>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
36310>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
36313>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
36316>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
36319>>>>>>>            Writeln channel iCh ("")
36322>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
36325>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
36328>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
36331>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
36334>>>>>>>            Writeln channel iCh ("")
36337>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
36340>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
36343>>>>>>>            Writeln channel iCh ("")
36346>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
36349>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
36352>>>>>>>            Writeln channel iCh ("")
36355>>>>>>>        Send Seq_Close_Channel iCh
36356>>>>>>>
36356>>>>>>>        Function_Return (Err = False)
36357>>>>>>>    End_Function
36358>>>>>>>
36358>>>>>>>    // * Dummy function for the Studio's Code Explorer *
36358>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
36360>>>>>>>        Function_Return False
36361>>>>>>>    End_Function
36362>>>>>>>
36362>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
36362>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
36362>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
36364>>>>>>>        Boolean bOK bExists
36364>>>>>>>        String sDataPath sBackupFolder
36364>>>>>>>
36364>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
36365>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
36366>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
36367>>>>>>>        Get vFolderFormat sDataPath to sDataPath
36368>>>>>>>
36368>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
36369>>>>>>>        If (bExists = False) Begin
36371>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
36372>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
36373>>>>>>>            If (bExists = False) Begin
36375>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
36376>>>>>>>>
36376>>>>>>>                Function_Return False
36377>>>>>>>            End
36377>>>>>>>>
36377>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
36378>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
36379>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
36380>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
36381>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
36382>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
36383>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
36384>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
36385>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
36386>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
36387>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
36388>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
36389>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
36390>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
36391>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
36392>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
36393>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
36394>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
36395>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
36396>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
36397>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
36398>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
36399>>>>>>>        End
36399>>>>>>>>
36399>>>>>>>
36399>>>>>>>        Set Message_Text of ghoStatusPanel to ""
36400>>>>>>>        Function_Return True
36401>>>>>>>    End_Function
36402>>>>>>>    
36402>>>>>>>    // Check if the file exists in the Data folder,
36402>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
36402>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
36404>>>>>>>        String sPath
36404>>>>>>>        Boolean bExists
36404>>>>>>>
36404>>>>>>>        Get psDataPathFirstPart to sPath
36405>>>>>>>        Move (sPath + sFileName) to sFileName
36406>>>>>>>        Get vFilePathExists sFileName to bExists
36407>>>>>>>
36407>>>>>>>        If (bExists = False) Begin
36409>>>>>>>            // Read from memory & create file on disk.
36409>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
36410>>>>>>>            Get vFilePathExists sFileName to bExists
36411>>>>>>>        End
36411>>>>>>>>
36411>>>>>>>        Function_Return bExists
36412>>>>>>>    End_Function
36413>>>>>>>
36413>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
36415>>>>>>>        tColumnType RetvalType
36415>>>>>>>        tColumnType RetvalType
36415>>>>>>>        Integer iRetval
36415>>>>>>>
36415>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
36416>>>>>>>        Move RetvalType.iDataFlexType to iRetval
36417>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
36419>>>>>>>            If (iLength <= 255) Begin
36421>>>>>>>                Move DF_ASCII to iRetval
36422>>>>>>>            End
36422>>>>>>>>
36422>>>>>>>        End
36422>>>>>>>>
36422>>>>>>>        Function_Return iRetval
36423>>>>>>>    End_Function
36424>>>>>>>
36424>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
36426>>>>>>>        String sRetval
36426>>>>>>>
36426>>>>>>>        Case Begin
36426>>>>>>>            Case (iDataType = DF_ASCII)
36428>>>>>>>                Move "DF_ASCII" to sRetval
36429>>>>>>>                Case Break
36430>>>>>>>            Case (iDataType = DF_BCD)
36433>>>>>>>                Move "DF_BCD" to sRetval
36434>>>>>>>                Case Break
36435>>>>>>>            Case (iDataType = DF_BINARY)
36438>>>>>>>                Move "DF_BINARY" to sRetval
36439>>>>>>>                Case Break
36440>>>>>>>            Case (iDataType = DF_DATE)
36443>>>>>>>                Move "DF_DATE" to sRetval
36444>>>>>>>                Case Break
36445>>>>>>>            Case (iDataType = DF_DATETIME)
36448>>>>>>>                Move "DF_DATETIME" to sRetval
36449>>>>>>>                Case Break
36450>>>>>>>            Case (iDataType = DF_TEXT)
36453>>>>>>>                Move "DF_TEXT" to sRetval
36454>>>>>>>                Case Break
36455>>>>>>>            Case Else
36455>>>>>>>                Move "" to sRetval
36456>>>>>>>        Case End
36456>>>>>>>
36456>>>>>>>        Function_Return sRetval
36457>>>>>>>    End_Function
36458>>>>>>>
36458>>>>>>>    // The default value used for a datatype as specified in the driver int file.
36458>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
36460>>>>>>>        String sRetval sServer
36460>>>>>>>        tColumnType RetvalType
36460>>>>>>>        tColumnType RetvalType
36460>>>>>>>        Integer iDriver iDataFlexType
36460>>>>>>>        Handle hDatabase
36460>>>>>>>
36460>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
36461>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
36462>>>>>>>        Get DriverIndex sDriverID to iDriver
36463>>>>>>>        Get psServer to sServer
36464>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
36465>>>>>>>        If (hDatabase = 0) Begin
36467>>>>>>>            Function_Return ""
36468>>>>>>>        End
36468>>>>>>>>
36468>>>>>>>
36468>>>>>>>        Case Begin
36468>>>>>>>            Case (iDataFlexType = DF_ASCII)
36470>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
36473>>>>>>>                Case Break
36474>>>>>>>            Case (iDataFlexType = DF_BCD)
36477>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
36480>>>>>>>                Case Break
36481>>>>>>>            Case (iDataFlexType = DF_BINARY)
36484>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
36487>>>>>>>                Case Break
36488>>>>>>>            Case (iDataFlexType = DF_DATE)
36491>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
36494>>>>>>>                Case Break
36495>>>>>>>            Case (iDataFlexType = DF_DATETIME)
36498>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
36501>>>>>>>                Case Break
36502>>>>>>>            Case (iDataFlexType = DF_TEXT)
36505>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
36508>>>>>>>                Case Break
36509>>>>>>>            Case Else
36509>>>>>>>                Move "" to sRetval
36510>>>>>>>        Case End
36510>>>>>>>
36510>>>>>>>        Function_Return sRetval
36511>>>>>>>    End_Function
36512>>>>>>>
36512>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
36514>>>>>>>        String sDriverID sServer
36514>>>>>>>        tColumnType RetvalType
36514>>>>>>>        tColumnType RetvalType
36514>>>>>>>        Integer iDbType iDriver
36514>>>>>>>        Handle hDatabase
36514>>>>>>>
36514>>>>>>>        Get psDriverID to sDriverID
36515>>>>>>>        Get piDbType   to iDbType
36516>>>>>>>        Get DriverIndex sDriverID to iDriver
36517>>>>>>>        Get psServer to sServer
36518>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
36519>>>>>>>        If (hDatabase = 0) Begin
36521>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
36522>>>>>>>>
36522>>>>>>>            Procedure_Return
36523>>>>>>>        End
36523>>>>>>>>
36523>>>>>>>
36523>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
36526>>>>>>>
36526>>>>>>>    End_Procedure
36527>>>>>>>
36527>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
36529>>>>>>>        String sDriverID sServer
36529>>>>>>>        tColumnType RetvalType
36529>>>>>>>        tColumnType RetvalType
36529>>>>>>>        Integer iDbType iDriver
36529>>>>>>>        Handle hDatabase
36529>>>>>>>
36529>>>>>>>        Get psDriverID to sDriverID
36530>>>>>>>        Get piDbType   to iDbType
36531>>>>>>>        Get DriverIndex sDriverID to iDriver
36532>>>>>>>        Get psServer to sServer
36533>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
36534>>>>>>>        If (hDatabase = 0) Begin
36536>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
36537>>>>>>>>
36537>>>>>>>            Procedure_Return
36538>>>>>>>        End
36538>>>>>>>>
36538>>>>>>>
36538>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
36541>>>>>>>
36541>>>>>>>    End_Procedure
36542>>>>>>>
36542>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
36542>>>>>>>    // are mapped to the standard DataFlex data types.
36542>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
36542>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
36544>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
36544>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
36546>>>>>>>        String sDataType
36546>>>>>>>        Integer iDataType iDriverID iCount
36546>>>>>>>        Boolean bSQLDriver
36546>>>>>>>
36546>>>>>>>        Move 0 to iCount
36547>>>>>>>        Get DriverIndex sDriverID to iDriverID
36548>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
36549>>>>>>>        If (bSQLDriver = False) Begin
36551>>>>>>>            Function_Return EmptyArray
36552>>>>>>>        End
36552>>>>>>>>
36552>>>>>>>
36552>>>>>>>        // DF_ASCII
36552>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36554>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
36557>>>>>>>        End
36557>>>>>>>>
36557>>>>>>>        Else Begin
36558>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
36561>>>>>>>        End
36561>>>>>>>>
36561>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36562>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
36563>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
36564>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36565>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36566>>>>>>>        Increment iCount
36567>>>>>>>
36567>>>>>>>        // DF_BINARY
36567>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36569>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
36572>>>>>>>        End
36572>>>>>>>>
36572>>>>>>>        Else Begin
36573>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
36576>>>>>>>        End
36576>>>>>>>>
36576>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36577>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
36578>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
36579>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36580>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36581>>>>>>>        Increment iCount
36582>>>>>>>
36582>>>>>>>        // DF_DATE
36582>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36584>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
36587>>>>>>>        End
36587>>>>>>>>
36587>>>>>>>        Else Begin
36588>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
36591>>>>>>>        End
36591>>>>>>>>
36591>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36592>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
36593>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
36594>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36595>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36596>>>>>>>        Increment iCount
36597>>>>>>>
36597>>>>>>>        // DF_DATETIME
36597>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36599>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
36602>>>>>>>        End
36602>>>>>>>>
36602>>>>>>>        Else Begin
36603>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
36606>>>>>>>        End
36606>>>>>>>>
36606>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36607>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
36608>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
36609>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36610>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36611>>>>>>>        Increment iCount
36612>>>>>>>
36612>>>>>>>        // DF_NUMERIC
36612>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
36612>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
36612>>>>>>>        // we make them here all "Numeric"...
36612>>>>>>>        Case Begin
36612>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
36614>>>>>>>                Move SQL_NUMERIC to iDataType
36615>>>>>>>                Move "numeric"   to sDataType
36616>>>>>>>                Case Break
36617>>>>>>>            Case (sDriverID = DB2_DRV_ID)
36620>>>>>>>                Move SQL_NUMERIC to iDataType
36621>>>>>>>                Move "NUMERIC"   to sDataType
36622>>>>>>>                Case Break
36623>>>>>>>            Case (sDriverID = SQLFLEX)
36626>>>>>>>                Move eSQLServer_NUMERIC to iDataType
36627>>>>>>>                Move "numeric"   to sDataType
36628>>>>>>>                Case Break
36629>>>>>>>            Case (sDriverID = MDSMySQL)
36632>>>>>>>                Move eMySQL_DECIMAL to iDataType
36633>>>>>>>                Move "decimal"   to sDataType
36634>>>>>>>                Case Break
36635>>>>>>>            Case (sDriverID = ORAFLEX)
36638>>>>>>>                Move eOracle_NUMBER to iDataType
36639>>>>>>>                Move "NUMBER"   to sDataType
36640>>>>>>>                Case Break
36641>>>>>>>            Case (sDriverID = MDSPgSQL)
36644>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
36645>>>>>>>                Move "decimal"   to sDataType
36646>>>>>>>                Case Break
36647>>>>>>>            Case Else
36647>>>>>>>                Move DF_BCD      to iDataType
36648>>>>>>>                Move "Numeric"   to sDataType
36649>>>>>>>        Case End
36649>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
36650>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
36651>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36652>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36653>>>>>>>        Increment iCount
36654>>>>>>>
36654>>>>>>>        // DF_TEXT
36654>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36656>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
36659>>>>>>>        End
36659>>>>>>>>
36659>>>>>>>        Else Begin
36660>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
36663>>>>>>>        End
36663>>>>>>>>
36663>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36664>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
36665>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
36666>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36667>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36668>>>>>>>
36668>>>>>>>        Function_Return ColumnTypeArray
36669>>>>>>>    End_Function
36670>>>>>>>
36670>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
36672>>>>>>>        tColumnType[] ColumnTypeArray
36672>>>>>>>        tColumnType[] ColumnTypeArray
36673>>>>>>>        tColumnType   ColumnType
36673>>>>>>>        tColumnType   ColumnType
36673>>>>>>>        Integer iCount iSize
36673>>>>>>>
36673>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
36674>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
36675>>>>>>>        Decrement iSize
36676>>>>>>>
36676>>>>>>>        for iCount from 0 to iSize
36682>>>>>>>>
36682>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
36684>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
36685>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
36686>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
36687>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
36688>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
36689>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
36690>>>>>>>                Move iSize to iCount
36691>>>>>>>            End
36691>>>>>>>>
36691>>>>>>>        Loop
36692>>>>>>>>
36692>>>>>>>
36692>>>>>>>        Function_Return ColumnType
36693>>>>>>>    End_Function
36694>>>>>>>
36694>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
36694>>>>>>>    // are mapped to a DUF data type.
36694>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
36696>>>>>>>        tColumnType ColumnType
36696>>>>>>>        tColumnType ColumnType
36696>>>>>>>        String sDataType
36696>>>>>>>        Integer iDriverID iCount
36696>>>>>>>
36696>>>>>>>        Move 0 to iCount
36697>>>>>>>        Get DriverIndex sDriverID to iDriverID
36698>>>>>>>
36698>>>>>>>        Case Begin
36698>>>>>>>            // DF_ASCII
36698>>>>>>>            Case (iType = DF_ASCII_DUF)
36700>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36702>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
36705>>>>>>>                End
36705>>>>>>>>
36705>>>>>>>                Else Begin
36706>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
36709>>>>>>>                End
36709>>>>>>>>
36709>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
36710>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
36711>>>>>>>                Move sDataType   to ColumnType.sSQLType
36712>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
36713>>>>>>>                Move False       to ColumnType.bCanEditSize
36714>>>>>>>                Case Break
36715>>>>>>>
36715>>>>>>>            // DF_BINARY
36715>>>>>>>            Case (iType = DF_BINARY_DUF)
36718>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36720>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
36723>>>>>>>                End
36723>>>>>>>>
36723>>>>>>>                Else Begin
36724>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
36727>>>>>>>                End
36727>>>>>>>>
36727>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
36728>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
36729>>>>>>>                Move sDataType   to ColumnType.sSQLType
36730>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
36731>>>>>>>                Move False       to ColumnType.bCanEditSize
36732>>>>>>>                Case Break
36733>>>>>>>
36733>>>>>>>            // DF_DATE
36733>>>>>>>            Case (iType = DF_DATE_DUF)
36736>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36738>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
36741>>>>>>>                End
36741>>>>>>>>
36741>>>>>>>                Else Begin
36742>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
36745>>>>>>>                End
36745>>>>>>>>
36745>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
36746>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
36747>>>>>>>                Move sDataType   to ColumnType.sSQLType
36748>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
36749>>>>>>>                Move True        to ColumnType.bCanEditSize
36750>>>>>>>                Case Break
36751>>>>>>>
36751>>>>>>>            // DF_DATETIME
36751>>>>>>>            Case (iType = DF_DATETIME_DUF)
36754>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36756>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
36759>>>>>>>                End
36759>>>>>>>>
36759>>>>>>>                Else Begin
36760>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
36763>>>>>>>                End
36763>>>>>>>>
36763>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
36764>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
36765>>>>>>>                Move sDataType   to ColumnType.sSQLType
36766>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
36767>>>>>>>                Move True        to ColumnType.bCanEditSize
36768>>>>>>>                Case Break
36769>>>>>>>
36769>>>>>>>            // DF_NUMERIC
36769>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
36769>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
36769>>>>>>>            // we make them here all "Numeric"...
36769>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
36769>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
36769>>>>>>>            // End
36769>>>>>>>            // Else Begin
36769>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
36769>>>>>>>            // End
36769>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
36769>>>>>>>            Case (iType = DF_BCD_DUF)
36772>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
36773>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
36774>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
36775>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
36776>>>>>>>                Move False       to ColumnType.bCanEditSize
36777>>>>>>>                Case Break
36778>>>>>>>
36778>>>>>>>            // DF_TEXT
36778>>>>>>>            Case (iType = DF_TEXT_DUF)
36781>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36783>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
36786>>>>>>>                End
36786>>>>>>>>
36786>>>>>>>                Else Begin
36787>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
36790>>>>>>>                End
36790>>>>>>>>
36790>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
36791>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
36792>>>>>>>                Move sDataType   to ColumnType.sSQLType
36793>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
36794>>>>>>>                Move False       to ColumnType.bCanEditSize
36795>>>>>>>                Case Break
36796>>>>>>>
36796>>>>>>>            Case Else
36796>>>>>>>                Move -1999       to ColumnType.iDataFlexType
36797>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
36798>>>>>>>                Move "Undefined" to ColumnType.sSQLType
36799>>>>>>>                Move -1999       to ColumnType.iSQLType
36800>>>>>>>                Move True        to ColumnType.bCanEditSize
36801>>>>>>>
36801>>>>>>>        Case End
36801>>>>>>>
36801>>>>>>>        Function_Return ColumnType
36802>>>>>>>    End_Function
36803>>>>>>>
36803>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
36805>>>>>>>        String sDataPath sDriverID
36805>>>>>>>        Boolean bMertechDriver bOK
36805>>>>>>>        Integer iPos
36805>>>>>>>
36805>>>>>>>        If (sTableName contains ".") Begin
36807>>>>>>>            Move (Pos(".", sTableName)) to iPos
36808>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
36809>>>>>>>        End
36809>>>>>>>>
36809>>>>>>>
36809>>>>>>>        Get psDriverID to sDriverID
36810>>>>>>>        Get psDataPathFirstPart to sDataPath
36811>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
36812>>>>>>>        // First delete the cache file:
36812>>>>>>>        If (bMertechDriver = False) Begin
36814>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
36815>>>>>>>        End
36815>>>>>>>>
36815>>>>>>>        Else Begin
36816>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
36817>>>>>>>        End
36817>>>>>>>>
36817>>>>>>>
36817>>>>>>>        Function_Return bOK
36818>>>>>>>    End_Function
36819>>>>>>>
36819>>>>>>>    // Changes source code files.
36819>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
36819>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
36819>>>>>>>    // to use a Connection ID.
36819>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
36819>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
36819>>>>>>>    // Returns True if no errors occured.
36819>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
36821>>>>>>>        Integer iCh iRow iItems iCount
36821>>>>>>>        String sValue sRow
36821>>>>>>>        String[] sFileArray
36822>>>>>>>        Boolean bExists bIsActive
36822>>>>>>>
36822>>>>>>>        Move False to Err
36823>>>>>>>        Move 0 to iRow
36824>>>>>>>
36824>>>>>>>        If (ghoStatusPanel <> 0) Begin
36826>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
36827>>>>>>>        End
36827>>>>>>>>
36827>>>>>>>
36827>>>>>>>        Get vFilePathExists sFileName to bExists
36828>>>>>>>        If (bExists = False) Begin
36830>>>>>>>            If (bShowResult = True) Begin
36832>>>>>>>                If (bIsActive = True) Begin
36834>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
36835>>>>>>>                End
36835>>>>>>>>
36835>>>>>>>                Else Begin
36836>>>>>>>                    Showln "File does not exist: " sFileName
36839>>>>>>>                End
36839>>>>>>>>
36839>>>>>>>            End
36839>>>>>>>>
36839>>>>>>>            Function_Return False
36840>>>>>>>        End
36840>>>>>>>>
36840>>>>>>>
36840>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
36841>>>>>>>        If (iCh < 1) Begin
36843>>>>>>>            Function_Return False
36844>>>>>>>        End
36844>>>>>>>>
36844>>>>>>>
36844>>>>>>>        If (bShowResult = True) Begin
36846>>>>>>>            If (ghoStatusPanel <> 0) Begin
36848>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
36849>>>>>>>                If (bIsActive = True) Begin
36851>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
36852>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
36853>>>>>>>                    Send DoAdvance of ghoProgressBar
36854>>>>>>>                End
36854>>>>>>>>
36854>>>>>>>            End
36854>>>>>>>>
36854>>>>>>>            Else Begin
36855>>>>>>>                Showln ""
36857>>>>>>>                Showln "sFileName = " sFileName
36860>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
36865>>>>>>>            End
36865>>>>>>>>
36865>>>>>>>        End
36865>>>>>>>>
36865>>>>>>>
36865>>>>>>>        While (not(SeqEof))
36869>>>>>>>            Readln channel iCh sRow
36871>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
36873>>>>>>>//                If (bShowResult = True) Begin
36873>>>>>>>//                    If (bIsActive = True) Begin
36873>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
36873>>>>>>>//                    End
36873>>>>>>>//                    Else Begin
36873>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
36873>>>>>>>//                    End
36873>>>>>>>//                End
36873>>>>>>>                // Change the whole line to the new connection id:
36873>>>>>>>                Move sChangeTo to sRow
36874>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
36874>>>>>>>            End
36874>>>>>>>>
36874>>>>>>>            Move sRow to sFileArray[iRow]
36875>>>>>>>            Increment iRow
36876>>>>>>>        Loop
36877>>>>>>>>
36877>>>>>>>        Send Seq_Close_Channel iCh
36878>>>>>>>
36878>>>>>>>        Sleep 1 // Wait for Windows to close the file
36879>>>>>>>
36879>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
36880>>>>>>>        If (iCh < 1) Begin
36882>>>>>>>            Function_Return False
36883>>>>>>>        End
36883>>>>>>>>
36883>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
36884>>>>>>>        Decrement iItems
36885>>>>>>>
36885>>>>>>>        For iCount from 0 to iItems
36891>>>>>>>>
36891>>>>>>>            Move sFileArray[iCount] to sValue
36892>>>>>>>            Writeln channel iCh sValue
36895>>>>>>>        Loop
36896>>>>>>>>
36896>>>>>>>        Send Seq_Close_Channel iCh
36897>>>>>>>
36897>>>>>>>        Function_Return (Err = False)
36898>>>>>>>    End_Function
36899>>>>>>>
36899>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
36901>>>>>>>        Integer iRetval
36901>>>>>>>        Move 1 to iRetval
36902>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
36904>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
36905>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
36906>>>>>>>        End
36906>>>>>>>>
36906>>>>>>>        Function_Return (iRetval = 0)
36907>>>>>>>    End_Function
36908>>>>>>>
36908>>>>>>>    // *** DEPRECIATED ***
36908>>>>>>>    // Use the AutoSetConnectionID function instead.
36908>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
36908>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
36908>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
36908>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
36908>>>>>>>//        String sConnectionString sDriverID
36908>>>>>>>//        Boolean bOK bSilent bDawDriver
36908>>>>>>>//        Handle hoCLI
36908>>>>>>>//
36908>>>>>>>//        Move False to bOK
36908>>>>>>>//        Get psDriverID to sDriverID
36908>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
36908>>>>>>>//        If (bDawDriver = False) Begin
36908>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
36908>>>>>>>//            Function_Return False
36908>>>>>>>//        End
36908>>>>>>>//
36908>>>>>>>//        Get psConnectionString to sConnectionString
36908>>>>>>>//        Get pbSilentLogin      to bSilent
36908>>>>>>>//
36908>>>>>>>//        Get phoCLIHandler to hoCLI
36908>>>>>>>//        If (hoCLI <> 0) Begin
36908>>>>>>>//            Set psDriverID of hoCLI to sDriverID
36908>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
36908>>>>>>>//        End
36908>>>>>>>//
36908>>>>>>>//        Function_Return (bOK = False)
36908>>>>>>>//    End_Function
36908>>>>>>>
36908>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
36908>>>>>>>    // and opens it in "notepad.exe".
36908>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
36908>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
36908>>>>>>>    Procedure UtilShowErrorList
36910>>>>>>>        tSqlErrorArray aSqlErrorArray
36910>>>>>>>        tSqlErrorArray aSqlErrorArray
36910>>>>>>>        Integer iRows iCount iCh iErrorNum
36910>>>>>>>        String sPath sFileName sErrorTxt sStatement
36910>>>>>>>
36910>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
36911>>>>>>>        Get vFolderFormat sPath to sPath
36912>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
36913>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
36914>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
36915>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
36916>>>>>>>            If (iRows > 0) Begin
36918>>>>>>>                Decrement iRows
36919>>>>>>>                for iCount from 0 to iRows
36925>>>>>>>>
36925>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
36926>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
36927>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
36928>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
36934>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
36938>>>>>>>                Loop
36939>>>>>>>>
36939>>>>>>>            End
36939>>>>>>>>
36939>>>>>>>        Send Seq_Close_Channel iCh
36940>>>>>>>
36940>>>>>>>        If (iRows > 0) Begin
36942>>>>>>>            Runprogram Shell Background (sPath + sFileName)
36943>>>>>>>        End
36943>>>>>>>>
36943>>>>>>>    End_Procedure
36944>>>>>>>
36944>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
36944>>>>>>>    // and the table needs to exist as an SQL table.
36944>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
36946>>>>>>>        String sRootName sDriverID
36946>>>>>>>        Boolean bIsSQL
36946>>>>>>>
36946>>>>>>>        Move False to bIsSQL
36947>>>>>>>        If (hTable > 0) Begin
36949>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
36952>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
36953>>>>>>>            If (bIsSQL = True) Begin
36955>>>>>>>                Get psDriverID to sDriverID
36956>>>>>>>                Get _TableNameOnly sRootName to sRootName
36957>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
36958>>>>>>>            End
36958>>>>>>>>
36958>>>>>>>        End
36958>>>>>>>>
36958>>>>>>>
36958>>>>>>>        Function_Return bIsSQL
36959>>>>>>>    End_Function
36960>>>>>>>
36960>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
36962>>>>>>>        Boolean bIsSQL
36962>>>>>>>        Move (sRootName contains ":") to bIsSQL
36963>>>>>>>        Function_Return bIsSQL
36964>>>>>>>    End_Function
36965>>>>>>>
36965>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
36965>>>>>>>    // that the embedded .dat file exists on disk.
36965>>>>>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
36967>>>>>>>        Boolean bExists bIsEmbedded
36967>>>>>>>        String sDataPath sRootName
36967>>>>>>>
36967>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
36968>>>>>>>        If (bExists = False) Begin
36970>>>>>>>            Function_Return False
36971>>>>>>>        End
36971>>>>>>>>
36971>>>>>>>
36971>>>>>>>        Move False to bIsEmbedded
36972>>>>>>>        If (hTable > 0) Begin
36974>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
36977>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
36978>>>>>>>        End
36978>>>>>>>>
36978>>>>>>>        If (bIsEmbedded = True) Begin
36980>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
36981>>>>>>>            Get vFolderFormat sDataPath to sDataPath
36982>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
36983>>>>>>>        End
36983>>>>>>>>
36983>>>>>>>
36983>>>>>>>        Function_Return bIsEmbedded
36984>>>>>>>    End_Function
36985>>>>>>>
36985>>>>>>>
36985>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
36985>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
36985>>>>>>>    // but the Logical name is different.
36985>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
36985>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
36987>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
36987>>>>>>>        Handle hInTable hMasterTable 
36987>>>>>>>        Boolean bIsAlias
36987>>>>>>>        
36987>>>>>>>        Move hTable to hInTable
36988>>>>>>>        Move False to bIsAlias
36989>>>>>>>        Move 0 to hMasterTable
36990>>>>>>>        
36990>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
36993>>>>>>>        // Remove any prefix with a driver name.
36993>>>>>>>        Get _TableNameOnly sRootName to sRootName     
36994>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
36997>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
36998>>>>>>>        
36998>>>>>>>        // If the table has the same root and logical name it can't be an alias,
36998>>>>>>>        // so we can safely return a "False".
36998>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
37000>>>>>>>            Function_Return False
37001>>>>>>>        End
37001>>>>>>>>
37001>>>>>>>        
37001>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
37001>>>>>>>        // as the passed hTable root name.
37001>>>>>>>        // A master table always has the same root and logical name.
37001>>>>>>>        Move 0 to hTable
37002>>>>>>>        Repeat
37002>>>>>>>>
37002>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37005>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
37007>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
37010>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
37011>>>>>>>                // If we found another table with the same root and logical name
37011>>>>>>>                // we have found a master table.
37011>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
37013>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
37016>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
37017>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
37019>>>>>>>                        Move hTable to hMasterTable   
37020>>>>>>>                        Move 0 to hTable // To end the loop.
37021>>>>>>>                    End
37021>>>>>>>>
37021>>>>>>>                End
37021>>>>>>>>
37021>>>>>>>            End
37021>>>>>>>>
37021>>>>>>>        Until (hTable = 0)
37023>>>>>>>        
37023>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
37025>>>>>>>            Move True to bIsAlias
37026>>>>>>>        End
37026>>>>>>>>
37026>>>>>>>        
37026>>>>>>>        Function_Return bIsAlias
37027>>>>>>>    End_Function
37028>>>>>>>
37028>>>>>>>    // To Open a table with any driver.
37028>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
37028>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
37028>>>>>>>    //
37028>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
37028>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
37028>>>>>>>    // returns a True if successful (table could be opened).
37028>>>>>>>    //
37028>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
37028>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
37028>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
37028>>>>>>>    // set properly we can open the table.
37028>>>>>>>    //
37028>>>>>>>    // DAW Driver Syntax:
37028>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
37028>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
37028>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
37028>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
37028>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
37028>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
37028>>>>>>>    //
37028>>>>>>>    // DAW Driver Sample:
37028>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
37028>>>>>>>    //
37028>>>>>>>    // Mertech Driver Samples:
37028>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
37028>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
37028>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
37028>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
37028>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
37030>>>>>>>        String sTableNameOrg
37030>>>>>>>        Boolean bOpen bOK
37030>>>>>>>        tSQLConnection SQLConnection
37030>>>>>>>        tSQLConnection SQLConnection
37030>>>>>>>        
37030>>>>>>>        Move False to bOpen
37031>>>>>>>        Move sTableName to sTableNameOrg
37032>>>>>>>        If (hTable > 0) Begin
37034>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
37035>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37036>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
37037>>>>>>>            Send Ignore_Error of Error_Object_Id 10
37038>>>>>>>            Open hTable Mode iMode
37040>>>>>>>            Send Trap_Error of Error_Object_Id 20529
37041>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37042>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
37043>>>>>>>            Send Trap_Error of Error_Object_Id 10
37044>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
37047>>>>>>>            If (bOpen = True) Begin
37049>>>>>>>                Function_Return True
37050>>>>>>>            End
37050>>>>>>>>
37050>>>>>>>        End
37050>>>>>>>>
37050>>>>>>>
37050>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
37051>>>>>>>        If (hTable > 0) Begin
37053>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
37056>>>>>>>        End
37056>>>>>>>>
37056>>>>>>>
37056>>>>>>>        Function_Return bOpen
37057>>>>>>>    End_Function
37058>>>>>>>
37058>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
37060>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
37060>>>>>>>        Boolean bOpen bMertechDriver bOK
37060>>>>>>>        tSQLConnection SQLConnection
37060>>>>>>>        tSQLConnection SQLConnection
37060>>>>>>>
37060>>>>>>>        If (hTable < 1) Begin
37062>>>>>>>            Function_Return False
37063>>>>>>>        End
37063>>>>>>>>
37063>>>>>>>
37063>>>>>>>        Move sTableName to sTableNameOrg
37064>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
37065>>>>>>>        Move SQLConnection.sDriverID to sDriverID
37066>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
37067>>>>>>>        Move SQLConnection.sConnectionString to sConnection
37068>>>>>>>        Move SQLConnection.sSchema to sSchema
37069>>>>>>>        If (sSchema = "") Begin
37071>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
37072>>>>>>>        End
37072>>>>>>>>
37072>>>>>>>
37072>>>>>>>        // We need to remove the ".int" part of the table name because
37072>>>>>>>        // the table name after the "#" in the connection syntax below wants the
37072>>>>>>>        // "bare" table name without any extension.
37072>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
37074>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
37076>>>>>>>                Get ParseFileExtension sTableName to sExt
37077>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
37078>>>>>>>            End
37078>>>>>>>>
37078>>>>>>>            Else Begin
37079>>>>>>>                Move sTableName to sTableNameShort
37080>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
37081>>>>>>>            End
37081>>>>>>>>
37081>>>>>>>            If (bMertechDriver = False) Begin
37083>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
37084>>>>>>>                Move sConnection to sTableName
37085>>>>>>>            End
37085>>>>>>>>
37085>>>>>>>        End
37085>>>>>>>>
37085>>>>>>>
37085>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
37086>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
37087>>>>>>>        If (hTable = 0) Begin
37089>>>>>>>            Get NextFreeFilelistSlot to hTable
37090>>>>>>>        End
37090>>>>>>>>
37090>>>>>>>
37090>>>>>>>        Case Begin
37090>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
37092>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37092>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
37094>>>>>>>                    Close hTable
37095>>>>>>>                    Open sTableName as hTable
37097>>>>>>>                End
37097>>>>>>>>
37097>>>>>>>                Else Begin
37098>>>>>>>                    Get OpenTableExclusive hTable to bOK
37099>>>>>>>                    If (bOK = False) Begin
37101>>>>>>>                        Function_Return False
37102>>>>>>>                    End
37102>>>>>>>>
37102>>>>>>>                End
37102>>>>>>>>
37102>>>>>>>                Case Break
37103>>>>>>>
37103>>>>>>>            Case (sDriverID = DB2_DRV_ID)
37106>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37106>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
37108>>>>>>>                    Close hTable
37109>>>>>>>                    Open sTableName as hTable
37111>>>>>>>                End
37111>>>>>>>>
37111>>>>>>>                Else Begin
37112>>>>>>>                    Get OpenTableExclusive hTable to bOK
37113>>>>>>>                    If (bOK = False) Begin
37115>>>>>>>                        Function_Return False
37116>>>>>>>                    End
37116>>>>>>>>
37116>>>>>>>                End
37116>>>>>>>>
37116>>>>>>>                Case Break
37117>>>>>>>
37117>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
37120>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37120>>>>>>>                If (iMode = DF_SHARE) Begin
37122>>>>>>>                    Close hTable
37123>>>>>>>                    Open sTableName as hTable
37125>>>>>>>                End
37125>>>>>>>>
37125>>>>>>>                Else Begin
37126>>>>>>>                    Get OpenTableExclusive hTable to bOK
37127>>>>>>>                    If (bOK = False) Begin
37129>>>>>>>                        Function_Return False
37130>>>>>>>                    End
37130>>>>>>>>
37130>>>>>>>                End
37130>>>>>>>>
37130>>>>>>>                Case Break
37131>>>>>>>
37131>>>>>>>            Case (sDriverID = SQLFLEX)
37134>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
37134>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
37134>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
37135>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37135>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
37137>>>>>>>                    Close hTable
37138>>>>>>>                    Open sTableName as hTable
37140>>>>>>>                End
37140>>>>>>>>
37140>>>>>>>                Else Begin
37141>>>>>>>                    Get OpenTableExclusive hTable to bOK
37142>>>>>>>                    If (bOK = False) Begin
37144>>>>>>>                        Function_Return False
37145>>>>>>>                    End
37145>>>>>>>>
37145>>>>>>>                End
37145>>>>>>>>
37145>>>>>>>                Case Break
37146>>>>>>>
37146>>>>>>>            Case (sDriverID = MDSMySQL)
37149>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
37149>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
37150>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37150>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
37152>>>>>>>                    Close hTable
37153>>>>>>>                    Open sTableName as hTable
37155>>>>>>>                End
37155>>>>>>>>
37155>>>>>>>                Else Begin
37156>>>>>>>                    Get OpenTableExclusive hTable to bOK
37157>>>>>>>                    If (bOK = False) Begin
37159>>>>>>>                        Function_Return False
37160>>>>>>>                    End
37160>>>>>>>>
37160>>>>>>>                End
37160>>>>>>>>
37160>>>>>>>                Case Break
37161>>>>>>>
37161>>>>>>>            Case (sDriverID = MDSPgSQL)
37164>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
37164>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
37165>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37165>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
37167>>>>>>>                    Close hTable
37168>>>>>>>                    Open sTableName as hTable
37170>>>>>>>                End
37170>>>>>>>>
37170>>>>>>>                Else Begin
37171>>>>>>>                    Get OpenTableExclusive hTable to bOK
37172>>>>>>>                    If (bOK = False) Begin
37174>>>>>>>                        Function_Return False
37175>>>>>>>                    End
37175>>>>>>>>
37175>>>>>>>                End
37175>>>>>>>>
37175>>>>>>>                Case Break
37176>>>>>>>
37176>>>>>>>            Case (sDriverID = ORAFLEX)
37179>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
37179>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
37179>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
37180>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
37180>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
37182>>>>>>>                    Close hTable
37183>>>>>>>                    Open sTableName as hTable
37185>>>>>>>                End
37185>>>>>>>>
37185>>>>>>>                Else Begin
37186>>>>>>>                    Get OpenTableExclusive hTable to bOK
37187>>>>>>>                    If (bOK = False) Begin
37189>>>>>>>                        Function_Return False
37190>>>>>>>                    End
37190>>>>>>>>
37190>>>>>>>                End
37190>>>>>>>>
37190>>>>>>>                Case Break
37191>>>>>>>
37191>>>>>>>            Case (sDriverID = DATAFLEX_ID)
37194>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
37196>>>>>>>                    Close hTable
37197>>>>>>>                    Open sTableName as hTable
37199>>>>>>>                End
37199>>>>>>>>
37199>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
37202>>>>>>>                    Get OpenTableExclusive hTable to bOK
37203>>>>>>>                    If (bOK = False) Begin
37205>>>>>>>                        Function_Return False
37206>>>>>>>                    End
37206>>>>>>>>
37206>>>>>>>                End
37206>>>>>>>>
37206>>>>>>>                Else Begin
37207>>>>>>>                    Open hTable
37209>>>>>>>                End
37209>>>>>>>>
37209>>>>>>>                Case Break
37210>>>>>>>
37210>>>>>>>            Case Else
37210>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
37211>>>>>>>>
37211>>>>>>>        Case End
37211>>>>>>>
37211>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
37212>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
37213>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
37215>>>>>>>            Move False to Found
37216>>>>>>>        End
37216>>>>>>>>
37216>>>>>>>        // If open failed, the Err is set to true,
37216>>>>>>>        // but we don't want that because it could end our loop.
37216>>>>>>>        Move False to Err
37217>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
37220>>>>>>>
37220>>>>>>>        Function_Return bOpen
37221>>>>>>>    End_Function
37222>>>>>>>
37222>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
37222>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
37222>>>>>>>    // if it is an SQL table
37222>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
37224>>>>>>>        Boolean bExists bIsSQLTable
37224>>>>>>>        String sDataPath sRootName
37224>>>>>>>
37224>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
37225>>>>>>>        If (bExists = False) Begin
37227>>>>>>>            Function_Return False
37228>>>>>>>        End
37228>>>>>>>>
37228>>>>>>>
37228>>>>>>>        Move False to bIsSQLTable
37229>>>>>>>        If (hTable > 0) Begin
37231>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
37234>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
37235>>>>>>>        End
37235>>>>>>>>
37235>>>>>>>        If (bIsSQLTable = True) Begin
37237>>>>>>>            Get UtilTableIsSQL hTable to bExists
37238>>>>>>>            Function_Return bExists
37239>>>>>>>        End
37239>>>>>>>>
37239>>>>>>>        Else Begin
37240>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
37241>>>>>>>            Get vFolderFormat sDataPath to sDataPath
37242>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
37243>>>>>>>        End
37243>>>>>>>>
37243>>>>>>>
37243>>>>>>>        Function_Return bExists
37244>>>>>>>    End_Function
37245>>>>>>>
37245>>>>>>>    // Pass a table handle
37245>>>>>>>    // Returns True if the table exists in filelist.cfg.
37245>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
37247>>>>>>>        Handle hTable
37247>>>>>>>        Boolean bFound
37247>>>>>>>
37247>>>>>>>        Move False to bFound
37248>>>>>>>        Move 0 to hTable
37249>>>>>>>        Repeat
37249>>>>>>>>
37249>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37252>>>>>>>            If (hTable > 0) Begin
37254>>>>>>>                If (hTable = hCheckTable) Begin
37256>>>>>>>                    Move True to bFound
37257>>>>>>>                End
37257>>>>>>>>
37257>>>>>>>            End
37257>>>>>>>>
37257>>>>>>>            If (bFound = True) ;                Break
37260>>>>>>>        Until (hTable = 0)
37262>>>>>>>
37262>>>>>>>        Function_Return (bFound = True)
37263>>>>>>>    End_Function
37264>>>>>>>
37264>>>>>>>    // Pass a table's logical name
37264>>>>>>>    // Returns True if the table exists in filelist.cfg.
37264>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
37266>>>>>>>        Handle hTable
37266>>>>>>>        Boolean bFound
37266>>>>>>>        String sCompareTable
37266>>>>>>>
37266>>>>>>>        Move False to bFound
37267>>>>>>>        Move 0 to hTable
37268>>>>>>>        Repeat
37268>>>>>>>>
37268>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37271>>>>>>>            If (hTable > 0) Begin
37273>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
37276>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
37278>>>>>>>                    Move True to bFound
37279>>>>>>>                End
37279>>>>>>>>
37279>>>>>>>            End
37279>>>>>>>>
37279>>>>>>>            If (bFound = True) ;                Break
37282>>>>>>>        Until (hTable = 0)
37284>>>>>>>
37284>>>>>>>        Function_Return (bFound = True)
37285>>>>>>>    End_Function
37286>>>>>>>
37286>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
37286>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
37288>>>>>>>        Boolean bOK bExists
37288>>>>>>>        String sDriverID
37288>>>>>>>
37288>>>>>>>        Get UtilTableExists hTable to bExists
37289>>>>>>>        If (bExists = False) Begin
37291>>>>>>>            Function_Return DATAFLEX_ID
37292>>>>>>>        End
37292>>>>>>>>
37292>>>>>>>        Get OpenTableExclusive hTable to bOK
37293>>>>>>>        If (bOK = False) Begin
37295>>>>>>>            Function_Return DATAFLEX_ID
37296>>>>>>>        End
37296>>>>>>>>
37296>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
37299>>>>>>>        Function_Return sDriverID
37300>>>>>>>    End_Function
37301>>>>>>>
37301>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
37301>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
37303>>>>>>>        Handle hTable
37303>>>>>>>        Integer iRetval
37303>>>>>>>
37303>>>>>>>        Move 0 to hTable
37304>>>>>>>        Move 0 to iRetval
37305>>>>>>>
37305>>>>>>>        Repeat
37305>>>>>>>>
37305>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37308>>>>>>>            If (hTable > 0) Begin
37310>>>>>>>                Increment iRetval
37311>>>>>>>            End
37311>>>>>>>>
37311>>>>>>>        Until (hTable = 0)
37313>>>>>>>
37313>>>>>>>        Function_Return iRetval
37314>>>>>>>    End_Function
37315>>>>>>>
37315>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
37315>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
37317>>>>>>>        Handle hTable
37317>>>>>>>        String sRoot sDriverID
37317>>>>>>>        Boolean bIsSQLTable
37317>>>>>>>        Integer iPos
37317>>>>>>>
37317>>>>>>>        Move 0 to hTable
37318>>>>>>>        Move "" to sDriverID
37319>>>>>>>        Move False to bIsSQLTable
37320>>>>>>>
37320>>>>>>>        Repeat
37320>>>>>>>>
37320>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37323>>>>>>>            If (hTable > 0) Begin
37325>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
37328>>>>>>>                If (sRoot contains ":") Begin
37330>>>>>>>                    Move (Pos(":", sRoot)) to iPos
37331>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
37332>>>>>>>                End
37332>>>>>>>>
37332>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
37333>>>>>>>            End
37333>>>>>>>>
37333>>>>>>>
37333>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
37335>>>>>>>
37335>>>>>>>        Function_Return sDriverID
37336>>>>>>>    End_Function
37337>>>>>>>
37337>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
37339>>>>>>>        String sRootName
37339>>>>>>>        Boolean bIsSQL
37339>>>>>>>        Handle hTable
37339>>>>>>>
37339>>>>>>>        Move False to bIsSQL
37340>>>>>>>        Move 0 to hTable
37341>>>>>>>        Repeat
37341>>>>>>>>
37341>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37344>>>>>>>            If (hTable > 0) Begin
37346>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
37349>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
37350>>>>>>>                If (bIsSQL = True) Begin
37352>>>>>>>                    Move 0 to hTable
37353>>>>>>>                End
37353>>>>>>>>
37353>>>>>>>            End
37353>>>>>>>>
37353>>>>>>>        Until (hTable = 0)
37355>>>>>>>
37355>>>>>>>        Function_Return (bIsSQL = False)
37356>>>>>>>    End_Function
37357>>>>>>>
37357>>>>>>>    // * Dummy function for the Studio's Code Explorer *
37357>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
37359>>>>>>>        Function_Return False
37360>>>>>>>    End_Function
37361>>>>>>>
37361>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
37363>>>>>>>        String  sRetval
37363>>>>>>>        String[] sOverlapFieldsArray
37364>>>>>>>        Integer iType iColumn iColumns
37364>>>>>>>        Boolean bOpen bOverlap
37364>>>>>>>
37364>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
37367>>>>>>>        If (bOpen = False) Begin
37369>>>>>>>            Open hTable
37371>>>>>>>        End
37371>>>>>>>>
37371>>>>>>>
37371>>>>>>>        Move "" to sRetval
37372>>>>>>>
37372>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
37375>>>>>>>
37375>>>>>>>        for iColumn from 0 to iColumns
37381>>>>>>>>
37381>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
37384>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
37386>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
37389>>>>>>>                If (bOverlap) Begin
37391>>>>>>>                    If (sRetval <> "") Begin
37393>>>>>>>                        Append sRetval ","
37394>>>>>>>                    End
37394>>>>>>>>
37394>>>>>>>                    Append sRetval iColumn
37395>>>>>>>                End
37395>>>>>>>>
37395>>>>>>>            End
37395>>>>>>>>
37395>>>>>>>        Loop
37396>>>>>>>>
37396>>>>>>>
37396>>>>>>>        If (bOpen = False) Begin
37398>>>>>>>            Close hTable
37399>>>>>>>        End
37399>>>>>>>>
37399>>>>>>>
37399>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
37400>>>>>>>
37400>>>>>>>        Function_Return sOverlapFieldsArray
37401>>>>>>>    End_Function
37402>>>>>>>
37402>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
37402>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
37404>>>>>>>        tColumnType[] ColumnType
37404>>>>>>>        tColumnType[] ColumnType
37405>>>>>>>
37405>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
37405>>>>>>>        // the dbType.
37405>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
37407>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
37409>>>>>>>                Move MDSMySQL to sDriverID
37410>>>>>>>            End
37410>>>>>>>>
37410>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
37412>>>>>>>                Move MSSQLDRV_ID to sDriverID
37413>>>>>>>            End
37413>>>>>>>>
37413>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
37415>>>>>>>                Move DB2_DRV_ID to sDriverID
37416>>>>>>>            End
37416>>>>>>>>
37416>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
37418>>>>>>>                Move MDSPgSQL to sDriverID
37419>>>>>>>            End
37419>>>>>>>>
37419>>>>>>>        End
37419>>>>>>>>
37419>>>>>>>
37419>>>>>>>        Case Begin
37419>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
37421>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
37422>>>>>>>                Case Break
37423>>>>>>>
37423>>>>>>>            Case (iDbType = EN_DbTypeDB2)
37426>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
37427>>>>>>>                Case Break
37428>>>>>>>
37428>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
37431>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
37432>>>>>>>                Case Break
37433>>>>>>>
37433>>>>>>>            Case (sDriverID = MDSMySQL)
37436>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
37437>>>>>>>                Case Break
37438>>>>>>>
37438>>>>>>>            Case (sDriverID = ORAFLEX)
37441>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
37442>>>>>>>                Case Break
37443>>>>>>>
37443>>>>>>>            Case (sDriverID = MDSPgSQL)
37446>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
37447>>>>>>>                Case Break
37448>>>>>>>        Case End
37448>>>>>>>
37448>>>>>>>        Function_Return ColumnType
37449>>>>>>>    End_Function
37450>>>>>>>
37450>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
37452>>>>>>>        Handle hoRegistry hoODBCDriverNames
37452>>>>>>>        Boolean bExists bKeyOpened
37452>>>>>>>        String sKey
37452>>>>>>>        String[] sDrivers
37453>>>>>>>        Integer iDriverNames iDriverName
37453>>>>>>>
37453>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
37454>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
37455>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
37456>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
37457>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
37458>>>>>>>        If (bExists) Begin
37460>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
37461>>>>>>>            If (bKeyOpened) Begin
37463>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
37464>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
37465>>>>>>>                If (iDriverNames > 0) Begin
37467>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
37468>>>>>>>                    Decrement iDriverNames
37469>>>>>>>                    for iDriverName from 0 to iDriverNames
37475>>>>>>>>
37475>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
37476>>>>>>>                    Loop
37477>>>>>>>>
37477>>>>>>>                End
37477>>>>>>>>
37477>>>>>>>                Send CloseKey of hoRegistry
37478>>>>>>>            End
37478>>>>>>>>
37478>>>>>>>        End
37478>>>>>>>>
37478>>>>>>>        Send Destroy of hoRegistry
37479>>>>>>>
37479>>>>>>>        Function_Return sDrivers
37480>>>>>>>    End_Function
37481>>>>>>>
37481>>>>>>>    // DataFlex Embedded Database Data Types:
37481>>>>>>>    // Helper function for UtilEnumerateColumnTypes
37481>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
37483>>>>>>>        tColumnType[] ColumnType
37483>>>>>>>        tColumnType[] ColumnType
37484>>>>>>>        Integer i
37484>>>>>>>
37484>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
37485>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
37486>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
37487>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
37488>>>>>>>        Move "254"              to ColumnType[i].sPrecision
37489>>>>>>>        Increment i
37490>>>>>>>
37490>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
37491>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
37492>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
37493>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
37494>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
37495>>>>>>>        Increment i
37496>>>>>>>
37496>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
37497>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
37498>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
37499>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
37500>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
37501>>>>>>>        Move True               to ColumnType[i].bCanEditSize
37502>>>>>>>        Increment i
37503>>>>>>>
37503>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
37504>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
37505>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
37506>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
37507>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
37508>>>>>>>        Increment i
37509>>>>>>>
37509>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
37510>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
37511>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
37512>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
37513>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
37514>>>>>>>        Increment i
37515>>>>>>>
37515>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
37516>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
37517>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
37518>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
37519>>>>>>>        Move "23"               to ColumnType[i].sPrecision
37520>>>>>>>        Move True               to ColumnType[i].bCanEditSize
37521>>>>>>>        Increment i
37522>>>>>>>
37522>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
37523>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
37524>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
37525>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
37526>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
37527>>>>>>>
37527>>>>>>>        Function_Return ColumnType
37528>>>>>>>    End_Function
37529>>>>>>>
37529>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
37531>>>>>>>        tColumnType[] aColumnType
37531>>>>>>>        tColumnType[] aColumnType
37532>>>>>>>        Integer i
37532>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
37532>>>>>>>>// Generated By The Database Update Framework
37532>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
37532>>>>>>>>// Driver COLUMN DATA TYPES
37532>>>>>>>>//
37532>>>>>>>>// Created: 2019-07-18 18:57:13.935
37532>>>>>>>>
37532>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
37533>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
37534>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37535>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37536>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37537>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37538>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37539>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37540>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37541>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37542>>>>>>>>            Increment i
37543>>>>>>>>
37543>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
37544>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
37545>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37546>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37547>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37548>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37549>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37550>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37551>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37552>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37553>>>>>>>>            Increment i
37554>>>>>>>>
37554>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
37555>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
37556>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37557>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37558>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37559>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37560>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37561>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37562>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37563>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37564>>>>>>>>            Increment i
37565>>>>>>>>
37565>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
37566>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
37567>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37568>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37569>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37570>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37571>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37572>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37573>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37574>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37575>>>>>>>>            Increment i
37576>>>>>>>>
37576>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
37577>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
37578>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37579>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37580>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37581>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37582>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37583>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37584>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37585>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37586>>>>>>>>            Increment i
37587>>>>>>>>
37587>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
37588>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
37589>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37590>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37591>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37592>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
37593>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
37594>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37595>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37596>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37597>>>>>>>>            Increment i
37598>>>>>>>>
37598>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
37599>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
37600>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37601>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37602>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
37603>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
37604>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
37605>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37606>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37607>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37608>>>>>>>>            Increment i
37609>>>>>>>>
37609>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
37610>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
37611>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37612>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37613>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
37614>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
37615>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
37616>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37617>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37618>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
37619>>>>>>>>            Increment i
37620>>>>>>>>
37620>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
37621>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
37622>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37623>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37624>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37625>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37626>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37627>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37628>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37629>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37630>>>>>>>>            Increment i
37631>>>>>>>>
37631>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
37632>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
37633>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37634>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37635>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37636>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37637>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37638>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37639>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37640>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37641>>>>>>>>            Increment i
37642>>>>>>>>
37642>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
37643>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
37644>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37645>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37646>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37647>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37648>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37649>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37650>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37651>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37652>>>>>>>>            Increment i
37653>>>>>>>>
37653>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
37654>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
37655>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37656>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37657>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
37658>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37659>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
37660>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37661>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37662>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
37663>>>>>>>>            Increment i
37664>>>>>>>>
37664>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
37665>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
37666>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37667>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37668>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37669>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37670>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37671>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37672>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37673>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37674>>>>>>>>            Increment i
37675>>>>>>>>
37675>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
37676>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
37677>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37678>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37679>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37680>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37681>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
37682>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37683>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37684>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
37685>>>>>>>>            Increment i
37686>>>>>>>>
37686>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
37687>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
37688>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37689>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37690>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37691>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37692>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37693>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37694>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37695>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37696>>>>>>>>            Increment i
37697>>>>>>>>
37697>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
37698>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
37699>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37700>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37701>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37702>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37703>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37704>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
37705>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
37706>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
37707>>>>>>>>            Increment i
37708>>>>>>>>
37708>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
37709>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
37710>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37711>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37712>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37713>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37714>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
37715>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37716>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37717>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
37718>>>>>>>>            Increment i
37719>>>>>>>>
37719>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
37720>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
37721>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37722>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37723>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37724>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37725>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37726>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37727>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37728>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37729>>>>>>>>            Increment i
37730>>>>>>>>
37730>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
37731>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
37732>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37733>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37734>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37735>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37736>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37737>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37738>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37739>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37740>>>>>>>>            Increment i
37741>>>>>>>>
37741>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
37742>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
37743>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37744>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37745>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37746>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37747>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37748>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37749>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37750>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37751>>>>>>>>            Increment i
37752>>>>>>>>
37752>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
37753>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
37754>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37755>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37756>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
37757>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37758>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
37759>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37760>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37761>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
37762>>>>>>>>            Increment i
37763>>>>>>>>
37763>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
37764>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
37765>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37766>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37767>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37768>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37769>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37770>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37771>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37772>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37773>>>>>>>>            Increment i
37774>>>>>>>>
37774>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
37775>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
37776>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37777>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37778>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37779>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37780>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37781>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37782>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37783>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37784>>>>>>>>            Increment i
37785>>>>>>>>
37785>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
37786>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
37787>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37788>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37789>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
37790>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
37791>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
37792>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37793>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37794>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
37795>>>>>>>>            Increment i
37796>>>>>>>>
37796>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
37797>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
37798>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37799>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37800>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
37801>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37802>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
37803>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37804>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37805>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
37806>>>>>>>>            Increment i
37807>>>>>>>>
37807>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
37808>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
37809>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37810>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37811>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37812>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37813>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37814>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37815>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37816>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37817>>>>>>>>            Increment i
37818>>>>>>>>
37818>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
37819>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
37820>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37821>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37822>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
37823>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37824>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37825>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37826>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37827>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37828>>>>>>>>            Increment i
37829>>>>>>>>
37829>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
37830>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
37831>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37832>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37833>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37834>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37835>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37836>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37837>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37838>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37839>>>>>>>>            Increment i
37840>>>>>>>>
37840>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
37841>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
37842>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37843>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37844>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37845>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37846>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37847>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37848>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37849>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37850>>>>>>>>            Increment i
37851>>>>>>>>
37851>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
37852>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
37853>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37854>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37855>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37856>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37857>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37858>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37859>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37860>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37861>>>>>>>>            Increment i
37862>>>>>>>>
37862>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
37863>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
37864>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37865>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37866>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37867>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37868>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37869>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37870>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37871>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37872>>>>>>>>            Increment i
37873>>>>>>>>
37873>>>>>>>>
37873>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
37873>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
37873>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
37873>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
37873>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        // ToDo: We need to change the sType when using this!
37873>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
37873>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
37873>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
37873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
37873>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
37873>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
37873>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
37873>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
37873>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
37873>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
37873>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
37873>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
37873>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
37873>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
37873>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
37873>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
37873>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
37873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
37873>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
37873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
37873>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        // ToDo: We need to change the sType when using this!
37873>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
37873>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
37873>>>>>>>//        Increment i
37873>>>>>>>//
37873>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
37873>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37873>>>>>>>//
37873>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
37873>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
37873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37873>>>>>>>
37873>>>>>>>        Function_Return aColumnType
37874>>>>>>>    End_Function
37875>>>>>>>
37875>>>>>>>    // Microsoft SQL Server Database Data Types:
37875>>>>>>>    // Helper function for UtilEnumerateColumnTypes
37875>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
37877>>>>>>>        tColumnType[] aColumnType
37877>>>>>>>        tColumnType[] aColumnType
37878>>>>>>>        Integer i
37878>>>>>>>
37878>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
37880>>>>>>>>// Generated By The Database Update Framework
37880>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
37880>>>>>>>>// Driver COLUMN DATA TYPES
37880>>>>>>>>//
37880>>>>>>>>// Created: 2019-11-15 21:57:51.001
37880>>>>>>>>
37880>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
37881>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
37882>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37883>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37884>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37885>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37886>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37887>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37888>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37889>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37890>>>>>>>>            Increment i
37891>>>>>>>>
37891>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
37892>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
37893>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37894>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37895>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37896>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37897>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37898>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37899>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37900>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37901>>>>>>>>            Increment i
37902>>>>>>>>
37902>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
37903>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
37904>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37905>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37906>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37907>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37908>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37909>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37910>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37911>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37912>>>>>>>>            Increment i
37913>>>>>>>>
37913>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
37914>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
37915>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37916>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37917>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37918>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37919>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37920>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37921>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37922>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37923>>>>>>>>            Increment i
37924>>>>>>>>
37924>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
37925>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
37926>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37927>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37928>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37929>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37930>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37931>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
37932>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
37933>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
37934>>>>>>>>            Increment i
37935>>>>>>>>
37935>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
37936>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
37937>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37938>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37939>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37940>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
37941>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
37942>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37943>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37944>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37945>>>>>>>>            Increment i
37946>>>>>>>>
37946>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
37947>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
37948>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37949>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37950>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
37951>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
37952>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
37953>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37954>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37955>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37956>>>>>>>>            Increment i
37957>>>>>>>>
37957>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
37958>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
37959>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37960>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37961>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
37962>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
37963>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
37964>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37965>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37966>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
37967>>>>>>>>            Increment i
37968>>>>>>>>
37968>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
37969>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
37970>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37971>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37972>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37973>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37974>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37975>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37976>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37977>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37978>>>>>>>>            Increment i
37979>>>>>>>>
37979>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
37980>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
37981>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37982>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37983>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37984>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37985>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37986>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37987>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37988>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37989>>>>>>>>            Increment i
37990>>>>>>>>
37990>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
37991>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
37992>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37993>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37994>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37995>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37996>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37997>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37998>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37999>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38000>>>>>>>>            Increment i
38001>>>>>>>>
38001>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38002>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38003>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38004>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38005>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
38006>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38007>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
38008>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38009>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38010>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
38011>>>>>>>>            Increment i
38012>>>>>>>>
38012>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
38013>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
38014>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38015>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38016>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
38017>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
38018>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
38019>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38020>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38021>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
38022>>>>>>>>            Increment i
38023>>>>>>>>
38023>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
38024>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
38025>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38026>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38027>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38028>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38029>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38030>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38031>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38032>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38033>>>>>>>>            Increment i
38034>>>>>>>>
38034>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
38035>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
38036>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38037>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38038>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38039>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38040>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38041>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38042>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38043>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38044>>>>>>>>            Increment i
38045>>>>>>>>
38045>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
38046>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
38047>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38048>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38049>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38050>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38051>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38052>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38053>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38054>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38055>>>>>>>>            Increment i
38056>>>>>>>>
38056>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
38057>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
38058>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38059>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38060>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38061>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38062>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38063>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38064>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38065>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38066>>>>>>>>            Increment i
38067>>>>>>>>
38067>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
38068>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
38069>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38070>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38071>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38072>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38073>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38074>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38075>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38076>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38077>>>>>>>>            Increment i
38078>>>>>>>>
38078>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
38079>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
38080>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38081>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38082>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38083>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38084>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38085>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38086>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38087>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38088>>>>>>>>            Increment i
38089>>>>>>>>
38089>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
38090>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
38091>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38092>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38093>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
38094>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
38095>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
38096>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38097>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38098>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
38099>>>>>>>>            Increment i
38100>>>>>>>>
38100>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
38101>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
38102>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38103>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38104>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
38105>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38106>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
38107>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38108>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38109>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
38110>>>>>>>>            Increment i
38111>>>>>>>>
38111>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
38112>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
38113>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38114>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38115>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
38116>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
38117>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
38118>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38119>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38120>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
38121>>>>>>>>            Increment i
38122>>>>>>>>
38122>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
38123>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
38124>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38125>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38126>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38127>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38128>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38129>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38130>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38131>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38132>>>>>>>>            Increment i
38133>>>>>>>>
38133>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
38134>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
38135>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38136>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38137>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
38138>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
38139>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
38140>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38141>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38142>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
38143>>>>>>>>            Increment i
38144>>>>>>>>
38144>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
38145>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
38146>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38147>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38148>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
38149>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38150>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
38151>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38152>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38153>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
38154>>>>>>>>            Increment i
38155>>>>>>>>
38155>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
38156>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
38157>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38158>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38159>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
38160>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
38161>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
38162>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38163>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38164>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
38165>>>>>>>>            Increment i
38166>>>>>>>>
38166>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
38167>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
38168>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38169>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38170>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
38171>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38172>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38173>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38174>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38175>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38176>>>>>>>>            Increment i
38177>>>>>>>>
38177>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
38178>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
38179>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38180>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38181>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38182>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38183>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38184>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38185>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38186>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38187>>>>>>>>            Increment i
38188>>>>>>>>
38188>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
38189>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38190>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38191>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38192>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38193>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38194>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38195>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38196>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38197>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38198>>>>>>>>            Increment i
38199>>>>>>>>
38199>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
38200>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
38201>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38202>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38203>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38204>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38205>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38206>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38207>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38208>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38209>>>>>>>>            Increment i
38210>>>>>>>>
38210>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
38211>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
38212>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38213>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38214>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38215>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38216>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38217>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38218>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38219>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38220>>>>>>>>            Increment i
38221>>>>>>>>
38221>>>>>>>>
38221>>>>>>>
38221>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
38221>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
38221>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
38221>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
38221>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
38221>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
38221>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
38221>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
38221>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
38221>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
38221>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
38221>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
38221>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
38221>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
38221>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
38221>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
38221>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
38221>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
38221>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
38221>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
38221>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
38221>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
38221>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
38221>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
38221>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
38221>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
38221>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
38221>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
38221>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
38221>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
38221>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
38221>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
38221>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
38221>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
38221>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>//
38221>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
38221>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
38221>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
38221>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
38221>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
38221>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38221>>>>>>>//            Increment i
38221>>>>>>>
38221>>>>>>>        End
38221>>>>>>>>
38221>>>>>>>
38221>>>>>>>        // Mertech SQLFlex driver
38221>>>>>>>        If (sDriverID = SQLFLEX) Begin
38223>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
38223>>>>>>>>// Generated By The Database Update Framework
38223>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
38223>>>>>>>>// Driver COLUMN DATA TYPES
38223>>>>>>>>//
38223>>>>>>>>// Created: 2018-03-14 23:47:46.885
38223>>>>>>>>
38223>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
38224>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
38225>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38226>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38227>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38228>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38229>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38230>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38231>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38232>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38233>>>>>>>>            Increment i
38234>>>>>>>>
38234>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
38235>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
38236>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38237>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38238>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38239>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38240>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38241>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38242>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38243>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38244>>>>>>>>            Increment i
38245>>>>>>>>
38245>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
38246>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
38247>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38248>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38249>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38250>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38251>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38252>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38253>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38254>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38255>>>>>>>>            Increment i
38256>>>>>>>>
38256>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38257>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
38258>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38259>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38260>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38261>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38262>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38263>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38264>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38265>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38266>>>>>>>>            Increment i
38267>>>>>>>>
38267>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38268>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
38269>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38270>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38271>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
38272>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38273>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38274>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38275>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38276>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38277>>>>>>>>            Increment i
38278>>>>>>>>
38278>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
38279>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
38280>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38281>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38282>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38283>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38284>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38285>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38286>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38287>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38288>>>>>>>>            Increment i
38289>>>>>>>>
38289>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
38290>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
38291>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38292>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38293>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38294>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38295>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38296>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38297>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38298>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38299>>>>>>>>            Increment i
38300>>>>>>>>
38300>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
38301>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
38302>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38303>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38304>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
38305>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
38306>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38307>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38308>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38309>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38310>>>>>>>>            Increment i
38311>>>>>>>>
38311>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
38312>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
38313>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38314>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38315>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38316>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38317>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38318>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38319>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38320>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38321>>>>>>>>            Increment i
38322>>>>>>>>
38322>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
38323>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
38324>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38325>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38326>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38327>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38328>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38329>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38330>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38331>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38332>>>>>>>>            Increment i
38333>>>>>>>>
38333>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
38334>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
38335>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38336>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38337>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38338>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38339>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38340>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38341>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38342>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38343>>>>>>>>            Increment i
38344>>>>>>>>
38344>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
38345>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
38346>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38347>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38348>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38349>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38350>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38351>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38352>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38353>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38354>>>>>>>>            Increment i
38355>>>>>>>>
38355>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
38356>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
38357>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38358>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38359>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38360>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38361>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38362>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38363>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38364>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38365>>>>>>>>            Increment i
38366>>>>>>>>
38366>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
38367>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
38368>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38369>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38370>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38371>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38372>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38373>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38374>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38375>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38376>>>>>>>>            Increment i
38377>>>>>>>>
38377>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38378>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38379>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38380>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38381>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
38382>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38383>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
38384>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38385>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38386>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
38387>>>>>>>>            Increment i
38388>>>>>>>>
38388>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
38389>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
38390>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38391>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38392>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38393>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38394>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38395>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38396>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38397>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38398>>>>>>>>            Increment i
38399>>>>>>>>
38399>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
38400>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
38401>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38402>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38403>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38404>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38405>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38406>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38407>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38408>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38409>>>>>>>>            Increment i
38410>>>>>>>>
38410>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
38411>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
38412>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38413>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38414>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38415>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38416>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38417>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38418>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38419>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38420>>>>>>>>            Increment i
38421>>>>>>>>
38421>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
38422>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
38423>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38424>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38425>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38426>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38427>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38428>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38429>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38430>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38431>>>>>>>>            Increment i
38432>>>>>>>>
38432>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
38433>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
38434>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38435>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38436>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38437>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38438>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38439>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38440>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38441>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38442>>>>>>>>            Increment i
38443>>>>>>>>
38443>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
38444>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
38445>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38446>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38447>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38448>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38449>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38450>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38451>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38452>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38453>>>>>>>>            Increment i
38454>>>>>>>>
38454>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
38455>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
38456>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38457>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38458>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
38459>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
38460>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38461>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38462>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38463>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38464>>>>>>>>            Increment i
38465>>>>>>>>
38465>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
38466>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
38467>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38468>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38469>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38470>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38471>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
38472>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38473>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38474>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38475>>>>>>>>            Increment i
38476>>>>>>>>
38476>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
38477>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
38478>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38479>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38480>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
38481>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38482>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38483>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38484>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38485>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38486>>>>>>>>            Increment i
38487>>>>>>>>
38487>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
38488>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
38489>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38490>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38491>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38492>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38493>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38494>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38495>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38496>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38497>>>>>>>>            Increment i
38498>>>>>>>>
38498>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
38499>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
38500>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38501>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38502>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
38503>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
38504>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
38505>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38506>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38507>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
38508>>>>>>>>            Increment i
38509>>>>>>>>
38509>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
38510>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
38511>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38512>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38513>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
38514>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38515>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38516>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38517>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38518>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38519>>>>>>>>            Increment i
38520>>>>>>>>
38520>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
38521>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
38522>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38523>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38524>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
38525>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38526>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
38527>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38528>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38529>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
38530>>>>>>>>            Increment i
38531>>>>>>>>
38531>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
38532>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
38533>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38534>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38535>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
38536>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38537>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38538>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38539>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38540>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38541>>>>>>>>            Increment i
38542>>>>>>>>
38542>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
38543>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
38544>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38545>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38546>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
38547>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38548>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38549>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38550>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38551>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38552>>>>>>>>            Increment i
38553>>>>>>>>
38553>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
38554>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
38555>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38556>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38557>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38558>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38559>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38560>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38561>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38562>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38563>>>>>>>>            Increment i
38564>>>>>>>>
38564>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
38565>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38566>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38567>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38568>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38569>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38570>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38571>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38572>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38573>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38574>>>>>>>>            Increment i
38575>>>>>>>>
38575>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
38576>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
38577>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38578>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38579>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38580>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38581>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38582>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38583>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38584>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38585>>>>>>>>            Increment i
38586>>>>>>>>
38586>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
38587>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
38588>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38589>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38590>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38591>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38592>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38593>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38594>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38595>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38596>>>>>>>>            Increment i
38597>>>>>>>>
38597>>>>>>>>
38597>>>>>>>
38597>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
38597>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
38597>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
38597>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
38597>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
38597>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
38597>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38597>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
38597>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
38597>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
38597>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
38597>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
38597>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
38597>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
38597>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
38597>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
38597>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
38597>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
38597>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38597>>>>>>>//            Increment i
38597>>>>>>>//
38597>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
38597>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
38597>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38597>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38597>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38597>>>>>>>        End
38597>>>>>>>>
38597>>>>>>>
38597>>>>>>>        Function_Return aColumnType
38598>>>>>>>    End_Function
38599>>>>>>>
38599>>>>>>>    // MySQL Data Types
38599>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
38601>>>>>>>        tColumnType[] aColumnType
38601>>>>>>>        tColumnType[] aColumnType
38602>>>>>>>        Integer i
38602>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
38602>>>>>>>>// Generated By The Database Update Framework
38602>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
38602>>>>>>>>// Driver COLUMN DATA TYPES
38602>>>>>>>>//
38602>>>>>>>>// Created: 2018-03-14 23:46:49.593
38602>>>>>>>>
38602>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
38603>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
38604>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38605>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38606>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38607>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38608>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38609>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38610>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38611>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38612>>>>>>>>            Increment i
38613>>>>>>>>
38613>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
38614>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
38615>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38616>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38617>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38618>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38619>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
38620>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38621>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38622>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
38623>>>>>>>>            Increment i
38624>>>>>>>>
38624>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
38625>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
38626>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38627>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38628>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38629>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38630>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38631>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38632>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38633>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38634>>>>>>>>            Increment i
38635>>>>>>>>
38635>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38636>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
38637>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38638>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38639>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38640>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38641>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38642>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38643>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38644>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38645>>>>>>>>            Increment i
38646>>>>>>>>
38646>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38647>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
38648>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38649>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38650>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38651>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38652>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38653>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
38654>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
38655>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38656>>>>>>>>            Increment i
38657>>>>>>>>
38657>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
38658>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38659>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38660>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38661>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38662>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38663>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38664>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38665>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38666>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38667>>>>>>>>            Increment i
38668>>>>>>>>
38668>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
38669>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
38670>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38671>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38672>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38673>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38674>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38675>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38676>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38677>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38678>>>>>>>>            Increment i
38679>>>>>>>>
38679>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
38680>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
38681>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38682>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38683>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38684>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38685>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38686>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38687>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38688>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38689>>>>>>>>            Increment i
38690>>>>>>>>
38690>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
38691>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
38692>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38693>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38694>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38695>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38696>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38697>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38698>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38699>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38700>>>>>>>>            Increment i
38701>>>>>>>>
38701>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
38702>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
38703>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38704>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38705>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38706>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38707>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38708>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38709>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38710>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38711>>>>>>>>            Increment i
38712>>>>>>>>
38712>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
38713>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38714>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38715>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38716>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
38717>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38718>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38719>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38720>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38721>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38722>>>>>>>>            Increment i
38723>>>>>>>>
38723>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38724>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
38725>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38726>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38727>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
38728>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38729>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
38730>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38731>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38732>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
38733>>>>>>>>            Increment i
38734>>>>>>>>
38734>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
38735>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
38736>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38737>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38738>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38739>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38740>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38741>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38742>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38743>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38744>>>>>>>>            Increment i
38745>>>>>>>>
38745>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
38746>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
38747>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38748>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38749>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38750>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38751>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38752>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38753>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38754>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38755>>>>>>>>            Increment i
38756>>>>>>>>
38756>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
38757>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
38758>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38759>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38760>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38761>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38762>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38763>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38764>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38765>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38766>>>>>>>>            Increment i
38767>>>>>>>>
38767>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
38768>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
38769>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38770>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38771>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
38772>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38773>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
38774>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38775>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38776>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
38777>>>>>>>>            Increment i
38778>>>>>>>>
38778>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
38779>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
38780>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38781>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38782>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38783>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38784>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38785>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38786>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38787>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38788>>>>>>>>            Increment i
38789>>>>>>>>
38789>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
38790>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
38791>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38792>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38793>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38794>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38795>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38796>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38797>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38798>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38799>>>>>>>>            Increment i
38800>>>>>>>>
38800>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
38801>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
38802>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38803>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38804>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
38805>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38806>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
38807>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38808>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38809>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38810>>>>>>>>            Increment i
38811>>>>>>>>
38811>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
38812>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
38813>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38814>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38815>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38816>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38817>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38818>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38819>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38820>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38821>>>>>>>>            Increment i
38822>>>>>>>>
38822>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
38823>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
38824>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38825>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38826>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
38827>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38828>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38829>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38830>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38831>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38832>>>>>>>>            Increment i
38833>>>>>>>>
38833>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
38834>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
38835>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38836>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38837>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38838>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38839>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38840>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38841>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38842>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38843>>>>>>>>            Increment i
38844>>>>>>>>
38844>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
38845>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
38846>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38847>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38848>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
38849>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38850>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38851>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38852>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38853>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38854>>>>>>>>            Increment i
38855>>>>>>>>
38855>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
38856>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
38857>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38858>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38859>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
38860>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38861>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
38862>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38863>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38864>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
38865>>>>>>>>            Increment i
38866>>>>>>>>
38866>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
38867>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
38868>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38869>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38870>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
38871>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38872>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38873>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38874>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38875>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38876>>>>>>>>            Increment i
38877>>>>>>>>
38877>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
38878>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
38879>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38880>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38881>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38882>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38883>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38884>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38885>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38886>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38887>>>>>>>>            Increment i
38888>>>>>>>>
38888>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
38889>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
38890>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38891>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38892>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
38893>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38894>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38895>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38896>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38897>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38898>>>>>>>>            Increment i
38899>>>>>>>>
38899>>>>>>>>
38899>>>>>>>
38899>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
38899>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
38899>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
38899>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
38899>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
38899>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
38899>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
38899>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
38899>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
38899>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
38899>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
38899>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
38899>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
38899>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
38899>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
38899>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
38899>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
38899>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
38899>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
38899>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
38899>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
38899>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
38899>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
38899>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
38899>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38899>>>>>>>//        Increment i
38899>>>>>>>//
38899>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
38899>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
38899>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38899>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
38899>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
38899>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38899>>>>>>>//        Increment i
38899>>>>>>>
38899>>>>>>>        Function_Return aColumnType
38900>>>>>>>    End_Function
38901>>>>>>>
38901>>>>>>>    // Oracle Data Types
38901>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
38903>>>>>>>        tColumnType[] aColumnType
38903>>>>>>>        tColumnType[] aColumnType
38904>>>>>>>        Integer i
38904>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
38904>>>>>>>>// Generated By The Database Update Framework
38904>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
38904>>>>>>>>// Driver COLUMN DATA TYPES
38904>>>>>>>>//
38904>>>>>>>>// Created: 2018-03-14 23:47:34.82
38904>>>>>>>>
38904>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
38905>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
38906>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38907>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38908>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38909>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38910>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38911>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38912>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38913>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38914>>>>>>>>            Increment i
38915>>>>>>>>
38915>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38916>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
38917>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38918>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38919>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38920>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38921>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
38922>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38923>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38924>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
38925>>>>>>>>            Increment i
38926>>>>>>>>
38926>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
38927>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
38928>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38929>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38930>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38931>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38932>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38933>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38934>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38935>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38936>>>>>>>>            Increment i
38937>>>>>>>>
38937>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38938>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38939>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38940>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38941>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38942>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38943>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38944>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
38945>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
38946>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38947>>>>>>>>            Increment i
38948>>>>>>>>
38948>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
38949>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38950>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38951>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38952>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38953>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38954>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38955>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38956>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38957>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38958>>>>>>>>            Increment i
38959>>>>>>>>
38959>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38960>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
38961>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38962>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38963>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38964>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38965>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38966>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38967>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38968>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38969>>>>>>>>            Increment i
38970>>>>>>>>
38970>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
38971>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
38972>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38973>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38974>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38975>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38976>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38977>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38978>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38979>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38980>>>>>>>>            Increment i
38981>>>>>>>>
38981>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
38982>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
38983>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38984>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38985>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38986>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38987>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38988>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38989>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38990>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38991>>>>>>>>            Increment i
38992>>>>>>>>
38992>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
38993>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
38994>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38995>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38996>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38997>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38998>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38999>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39000>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39001>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39002>>>>>>>>            Increment i
39003>>>>>>>>
39003>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
39004>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
39005>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39006>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39007>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
39008>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39009>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39010>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
39011>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
39012>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39013>>>>>>>>            Increment i
39014>>>>>>>>
39014>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
39015>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
39016>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39017>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39018>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39019>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39020>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
39021>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39022>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39023>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
39024>>>>>>>>            Increment i
39025>>>>>>>>
39025>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
39026>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
39027>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39028>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39029>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
39030>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39031>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39032>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
39033>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
39034>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39035>>>>>>>>            Increment i
39036>>>>>>>>
39036>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
39037>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
39038>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39039>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39040>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39041>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39042>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
39043>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39044>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39045>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
39046>>>>>>>>            Increment i
39047>>>>>>>>
39047>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
39048>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
39049>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39050>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39051>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39052>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39053>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
39054>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39055>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39056>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
39057>>>>>>>>            Increment i
39058>>>>>>>>
39058>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
39059>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
39060>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39061>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39062>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39063>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39064>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
39065>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
39066>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
39067>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
39068>>>>>>>>            Increment i
39069>>>>>>>>
39069>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
39070>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
39071>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39072>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39073>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39074>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39075>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39076>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
39077>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
39078>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39079>>>>>>>>            Increment i
39080>>>>>>>>
39080>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
39081>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
39082>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39083>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39084>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39085>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39086>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39087>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
39088>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
39089>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39090>>>>>>>>            Increment i
39091>>>>>>>>
39091>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
39092>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
39093>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39094>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39095>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39096>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39097>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39098>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
39099>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
39100>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39101>>>>>>>>            Increment i
39102>>>>>>>>
39102>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
39103>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
39104>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39105>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39106>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39107>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39108>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
39109>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39110>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39111>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
39112>>>>>>>>            Increment i
39113>>>>>>>>
39113>>>>>>>>
39113>>>>>>>
39113>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
39113>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
39113>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
39113>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
39113>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
39113>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
39113>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
39113>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
39113>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
39113>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
39113>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
39113>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
39113>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
39113>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
39113>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
39113>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
39113>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
39113>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
39113>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
39113>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
39113>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
39113>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
39113>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
39113>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
39113>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
39113>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
39113>>>>>>>//        Increment i
39113>>>>>>>//
39113>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
39113>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
39113>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39113>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39113>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39113>>>>>>>
39113>>>>>>>        Function_Return aColumnType
39114>>>>>>>    End_Function
39115>>>>>>>
39115>>>>>>>    // PostgreSQL Data Types
39115>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
39117>>>>>>>        tColumnType[] aColumnType
39117>>>>>>>        tColumnType[] aColumnType
39118>>>>>>>        Integer i
39118>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
39118>>>>>>>>// Generated By The Database Update Framework
39118>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
39118>>>>>>>>// Driver COLUMN DATA TYPES
39118>>>>>>>>//
39118>>>>>>>>// Created: 2018-03-14 23:47:02.984
39118>>>>>>>>
39118>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
39119>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
39120>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39121>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39122>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
39123>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39124>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
39125>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39126>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39127>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
39128>>>>>>>>            Increment i
39129>>>>>>>>
39129>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
39130>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
39131>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39132>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39133>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39134>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39135>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39136>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
39137>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
39138>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39139>>>>>>>>            Increment i
39140>>>>>>>>
39140>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
39141>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
39142>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39143>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39144>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39145>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39146>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39147>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39148>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39149>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39150>>>>>>>>            Increment i
39151>>>>>>>>
39151>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
39152>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
39153>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39154>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39155>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39156>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39157>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39158>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
39159>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
39160>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39161>>>>>>>>            Increment i
39162>>>>>>>>
39162>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
39163>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
39164>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39165>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39166>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39167>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39168>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39169>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39170>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39171>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39172>>>>>>>>            Increment i
39173>>>>>>>>
39173>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
39174>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
39175>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39176>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39177>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39178>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39179>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39180>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39181>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39182>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39183>>>>>>>>            Increment i
39184>>>>>>>>
39184>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
39185>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
39186>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39187>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39188>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
39189>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39190>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39191>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
39192>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
39193>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
39194>>>>>>>>            Increment i
39195>>>>>>>>
39195>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
39196>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
39197>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39198>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39199>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
39200>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39201>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
39202>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39203>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39204>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
39205>>>>>>>>            Increment i
39206>>>>>>>>
39206>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
39207>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
39208>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39209>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39210>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
39211>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39212>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
39213>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39214>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39215>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
39216>>>>>>>>            Increment i
39217>>>>>>>>
39217>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
39218>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
39219>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39220>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39221>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
39222>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39223>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
39224>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39225>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39226>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
39227>>>>>>>>            Increment i
39228>>>>>>>>
39228>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
39229>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
39230>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39231>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39232>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
39233>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39234>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
39235>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39236>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39237>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
39238>>>>>>>>            Increment i
39239>>>>>>>>
39239>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
39240>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
39241>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39242>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39243>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
39244>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39245>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39246>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
39247>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
39248>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39249>>>>>>>>            Increment i
39250>>>>>>>>
39250>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
39251>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
39252>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39253>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39254>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
39255>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39256>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
39257>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39258>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39259>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
39260>>>>>>>>            Increment i
39261>>>>>>>>
39261>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
39262>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
39263>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39264>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39265>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
39266>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39267>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39268>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39269>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39270>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39271>>>>>>>>            Increment i
39272>>>>>>>>
39272>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
39273>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
39274>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39275>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39276>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
39277>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39278>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
39279>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39280>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39281>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
39282>>>>>>>>            Increment i
39283>>>>>>>>
39283>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
39284>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
39285>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39286>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39287>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39288>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39289>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39290>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39291>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39292>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39293>>>>>>>>            Increment i
39294>>>>>>>>
39294>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
39295>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
39296>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39297>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39298>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
39299>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
39300>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
39301>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39302>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39303>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
39304>>>>>>>>            Increment i
39305>>>>>>>>
39305>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
39306>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
39307>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39308>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39309>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39310>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39311>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39312>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
39313>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
39314>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39315>>>>>>>>            Increment i
39316>>>>>>>>
39316>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
39317>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
39318>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39319>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39320>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39321>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39322>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39323>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39324>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39325>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39326>>>>>>>>            Increment i
39327>>>>>>>>
39327>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
39328>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
39329>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39330>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39331>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
39332>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39333>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39334>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39335>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39336>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39337>>>>>>>>            Increment i
39338>>>>>>>>
39338>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
39339>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
39340>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39341>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39342>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39343>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39344>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39345>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39346>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39347>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39348>>>>>>>>            Increment i
39349>>>>>>>>
39349>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
39350>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
39351>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39352>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39353>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39354>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39355>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39356>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39357>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39358>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39359>>>>>>>>            Increment i
39360>>>>>>>>
39360>>>>>>>>
39360>>>>>>>
39360>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
39360>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
39360>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
39360>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
39360>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
39360>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
39360>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
39360>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
39360>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
39360>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
39360>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
39360>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
39360>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
39360>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
39360>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
39360>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39360>>>>>>>//        Increment i
39360>>>>>>>//
39360>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
39360>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
39360>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39360>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
39360>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39360>>>>>>>//        Increment i
39360>>>>>>>
39360>>>>>>>        Function_Return aColumnType
39361>>>>>>>    End_Function
39362>>>>>>>
39362>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
39362>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
39364>>>>>>>        Integer iValue iSize iCount iStart
39364>>>>>>>        tColumnType[] ColumnTypeArray
39364>>>>>>>        tColumnType[] ColumnTypeArray
39365>>>>>>>        tColumnType RetvalType
39365>>>>>>>        tColumnType RetvalType
39365>>>>>>>        String sValue
39365>>>>>>>        Boolean bFrameworkDataFlexType
39365>>>>>>>
39365>>>>>>>        Move "Undefined" to RetvalType.sSQLType
39366>>>>>>>        Move -1999       to RetvalType.iSQLType
39367>>>>>>>
39367>>>>>>>        Move 0 to iStart
39368>>>>>>>        Move (Uppercase(sType)) to sType
39369>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
39370>>>>>>>        If (bFrameworkDataFlexType = True) Begin
39372>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
39373>>>>>>>            Function_Return RetvalType
39374>>>>>>>        End
39374>>>>>>>>
39374>>>>>>>
39374>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
39375>>>>>>>
39375>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
39376>>>>>>>        Decrement iSize
39377>>>>>>>
39377>>>>>>>        for iCount from iStart to iSize
39383>>>>>>>>
39383>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
39384>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
39385>>>>>>>            If (bIntegerInputType = True) Begin
39387>>>>>>>                If (iValue = iType) Begin
39389>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
39390>>>>>>>                    Move iType                                  to RetvalType.iSQLType
39391>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
39392>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
39393>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
39394>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
39395>>>>>>>                    Move iSize to iCount // We're done!
39396>>>>>>>                End
39396>>>>>>>>
39396>>>>>>>            End
39396>>>>>>>>
39396>>>>>>>            Else Begin
39397>>>>>>>                Move (Uppercase(sValue)) to sValue
39398>>>>>>>                If (sValue = sType) Begin
39400>>>>>>>                    Move sType                                  to RetvalType.sSQLType
39401>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
39402>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
39403>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
39404>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
39405>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
39406>>>>>>>                    Move iSize to iCount // We're done!
39407>>>>>>>                End
39407>>>>>>>>
39407>>>>>>>            End
39407>>>>>>>>
39407>>>>>>>        Loop
39408>>>>>>>>
39408>>>>>>>
39408>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
39408>>>>>>>        // In which case we search for a match in DataFlex standard types:
39408>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
39410>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
39411>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
39412>>>>>>>            Decrement iSize
39413>>>>>>>
39413>>>>>>>            for iCount from iStart to iSize
39419>>>>>>>>
39419>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
39420>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
39421>>>>>>>                If (iValue = iType) Begin
39423>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
39424>>>>>>>                    Move iType                                  to RetvalType.iSQLType
39425>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
39426>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
39427>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
39428>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
39429>>>>>>>                    Move iSize to iCount // We're done!
39430>>>>>>>                End
39430>>>>>>>>
39430>>>>>>>            Loop
39431>>>>>>>>
39431>>>>>>>        End
39431>>>>>>>>
39431>>>>>>>
39431>>>>>>>        Function_Return RetvalType
39432>>>>>>>    End_Function
39433>>>>>>>
39433>>>>>>>    Function _AllTablesToConvert Returns Integer[]
39435>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
39437>>>>>>>        Handle hTable
39437>>>>>>>        Integer iIndex
39437>>>>>>>        String sTableName
39437>>>>>>>        Boolean bFlexErrs
39437>>>>>>>
39437>>>>>>>        // a) Get the exception table array the developer has specified
39437>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
39438>>>>>>>
39438>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
39438>>>>>>>        Repeat
39438>>>>>>>>
39438>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39441>>>>>>>            If (hTable <> 0) Begin
39443>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39446>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
39447>>>>>>>                If (bFlexErrs = False) Begin
39449>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
39451>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
39452>>>>>>>                        If (iIndex = -1) Begin
39454>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
39455>>>>>>>                        End
39455>>>>>>>>
39455>>>>>>>                    End
39455>>>>>>>>
39455>>>>>>>                End
39455>>>>>>>>
39455>>>>>>>            End
39455>>>>>>>>
39455>>>>>>>        Until (hTable = 0)
39457>>>>>>>
39457>>>>>>>        Move 0 to hTable
39458>>>>>>>
39458>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
39458>>>>>>>        Repeat
39458>>>>>>>>
39458>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39461>>>>>>>            If (hTable > 0) Begin
39463>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39466>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
39467>>>>>>>                If (bFlexErrs = False) Begin
39469>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
39470>>>>>>>                    If (iIndex = -1) Begin
39472>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
39473>>>>>>>                    End
39473>>>>>>>>
39473>>>>>>>                End
39473>>>>>>>>
39473>>>>>>>            End
39473>>>>>>>>
39473>>>>>>>        Until (hTable = 0)
39475>>>>>>>
39475>>>>>>>        Function_Return iTablesArray
39476>>>>>>>    End_Function
39477>>>>>>>
39477>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
39479>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
39481>>>>>>>        Handle hTable
39481>>>>>>>        Integer iIndex
39481>>>>>>>        String sTableName
39481>>>>>>>        Boolean bFlexErrs
39481>>>>>>>
39481>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
39482>>>>>>>        Move 0 to hTable
39483>>>>>>>
39483>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
39483>>>>>>>        Repeat
39483>>>>>>>>
39483>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39486>>>>>>>            If (hTable > 0) Begin
39488>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39491>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
39492>>>>>>>                If (bFlexErrs = False) Begin
39494>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
39495>>>>>>>                    If (iIndex = -1) Begin
39497>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
39498>>>>>>>                    End
39498>>>>>>>>
39498>>>>>>>                End
39498>>>>>>>>
39498>>>>>>>            End
39498>>>>>>>>
39498>>>>>>>        Until (hTable = 0)
39500>>>>>>>
39500>>>>>>>        Function_Return iTablesArray
39501>>>>>>>    End_Function
39502>>>>>>>
39502>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
39504>>>>>>>        tAPIColumn NewAPIColumn
39504>>>>>>>        tAPIColumn NewAPIColumn
39504>>>>>>>
39504>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
39505>>>>>>>        Move iType      to NewAPIColumn.iType
39506>>>>>>>        Move iLength    to NewAPIColumn.iLength
39507>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
39508>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
39509>>>>>>>
39509>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
39510>>>>>>>
39510>>>>>>>        Function_Return aCurrent
39511>>>>>>>    End_Function
39512>>>>>>>
39512>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
39514>>>>>>>        String sRetval sFieldName
39514>>>>>>>        Integer iCount iSize
39514>>>>>>>
39514>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
39515>>>>>>>        Decrement iSize
39516>>>>>>>        for iCount from 0 to iSize
39522>>>>>>>>
39522>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
39523>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
39524>>>>>>>        Loop
39525>>>>>>>>
39525>>>>>>>        Move (Trim(sRetval)) to sRetval
39526>>>>>>>
39526>>>>>>>        Function_Return sRetval
39527>>>>>>>    End_Function
39528>>>>>>>
39528>>>>>>>    // *** Miscellaneous other functions ***
39528>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
39528>>>>>>>    //
39528>>>>>>>
39528>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
39528>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
39530>>>>>>>        Integer iPerc
39530>>>>>>>        Number nReady nTotal
39530>>>>>>>
39530>>>>>>>        Send DoAdvance of ghoProgressBar
39531>>>>>>>
39531>>>>>>>        If (sCallback_Text contains "Copy records") Begin
39533>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
39534>>>>>>>        End
39534>>>>>>>>
39534>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
39536>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
39537>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
39538>>>>>>>        End
39538>>>>>>>>
39538>>>>>>>        If (sCallback_Text contains "Creating index") Begin
39540>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
39541>>>>>>>        End
39541>>>>>>>>
39541>>>>>>>
39541>>>>>>>        Case Begin
39541>>>>>>>            Case (iCallback_Type = DF_Message_Text)
39543>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39544>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39545>>>>>>>                Case Break
39546>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
39549>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39550>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39551>>>>>>>                Case Break
39552>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
39555>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39556>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39557>>>>>>>                Case Break
39558>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
39561>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39562>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39563>>>>>>>                Case Break
39564>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
39567>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39568>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39569>>>>>>>                Case Break
39570>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
39573>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39574>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39575>>>>>>>                Case Break
39576>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
39579>>>>>>>                Send None
39580>>>>>>>                Case Break
39581>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
39584>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39585>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39586>>>>>>>                Case Break
39587>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
39590>>>>>>>                //*** Interpret numbers
39590>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
39591>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
39592>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
39593>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
39594>>>>>>>                Case Break
39595>>>>>>>            Case Else
39595>>>>>>>                Set Message_Text to ""
39596>>>>>>>                Set Action_Text  to ""
39597>>>>>>>        Case End
39597>>>>>>>
39597>>>>>>>        Send ProcessEvents of ghoStatusPanel
39598>>>>>>>        Function_Return False
39599>>>>>>>    End_Function
39600>>>>>>>
39600>>>>>>>    Procedure IncreaseSortBufferSize
39602>>>>>>>        String sNull
39602>>>>>>>        Integer iSortBufferSize
39602>>>>>>>        Boolean bBufferSet
39602>>>>>>>
39602>>>>>>>        Move "" to sNull
39603>>>>>>>        Move (1024 * 128) to iSortBufferSize
39604>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
39609>>>>>>>
39609>>>>>>>    End_Procedure
39610>>>>>>>
39610>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
39612>>>>>>>        Integer iLastIndex iIndex iNumSegments
39612>>>>>>>        Boolean bOK
39612>>>>>>>        String sDriverID
39612>>>>>>>
39612>>>>>>>        If (hTable > 0) Begin
39614>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
39615>>>>>>>            Close hTable
39616>>>>>>>            Get OpenTableExclusive hTable to bOK
39617>>>>>>>            If (bOK = False) Begin
39619>>>>>>>                Procedure_Return
39620>>>>>>>            End
39620>>>>>>>>
39620>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
39623>>>>>>>            Structure_Start hTable sDriverID
39624>>>>>>>                for iIndex from 1 to iLastIndex
39630>>>>>>>>
39630>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
39633>>>>>>>                    If (iNumSegments > 0) Begin
39635>>>>>>>                        If (bSetToBatch = True) Begin
39637>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
39640>>>>>>>                        End
39640>>>>>>>>
39640>>>>>>>                        Else Begin
39641>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
39644>>>>>>>                        End
39644>>>>>>>>
39644>>>>>>>                    End
39644>>>>>>>>
39644>>>>>>>                Loop
39645>>>>>>>>
39645>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
39647>>>>>>>        End
39647>>>>>>>>
39647>>>>>>>    End_Procedure
39648>>>>>>>
39648>>>>>>>    Function NextFreeFilelistSlot Returns Handle
39650>>>>>>>        Handle hTable
39650>>>>>>>
39650>>>>>>>        Move 0 to hTable
39651>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
39654>>>>>>>
39654>>>>>>>        Function_Return hTable
39655>>>>>>>    End_Function
39656>>>>>>>
39656>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
39656>>>>>>>    Procedure DebugPrint String sStmt String sFileName
39658>>>>>>>        Integer iCh
39658>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
39659>>>>>>>            Write channel iCh sStmt
39661>>>>>>>        Send Seq_Close_Channel iCh
39662>>>>>>>    End_Procedure
39663>>>>>>>
39663>>>>>>>    // Returns the integer number for the passed Driver ID that is
39663>>>>>>>    // needed by some database API calls.
39663>>>>>>>    Function DriverIndex String sDriverID Returns Integer
39665>>>>>>>        String  sCurrentDriver
39665>>>>>>>        Integer iNumberOfDrivers iDriver iCount
39665>>>>>>>
39665>>>>>>>        Move 0 to iDriver
39666>>>>>>>
39666>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
39669>>>>>>>        for iCount from 1 to iNumberOfDrivers
39675>>>>>>>>
39675>>>>>>>
39675>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
39678>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
39680>>>>>>>                Move iCount to iDriver
39681>>>>>>>            End
39681>>>>>>>>
39681>>>>>>>        Loop
39682>>>>>>>>
39682>>>>>>>
39682>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
39682>>>>>>>        If (iDriver = 0) Begin
39684>>>>>>>            Move False to Err
39685>>>>>>>            Load_Driver sDriverID
39686>>>>>>>            If (Err = False) Begin
39688>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
39691>>>>>>>            End
39691>>>>>>>>
39691>>>>>>>        End
39691>>>>>>>>
39691>>>>>>>
39691>>>>>>>        Function_Return iDriver
39692>>>>>>>    End_Function
39693>>>>>>>
39693>>>>>>>    
39693>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
39695>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
39695>>>>>>>        Integer iNumberOfDrivers iDriver iClient
39695>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
39695>>>>>>>        Boolean bOK
39695>>>>>>>        
39695>>>>>>>        Move "" to sRetval
39696>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
39697>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
39698>>>>>>>        Load_Driver MSSQLDRV_ID
39699>>>>>>>
39699>>>>>>>        // Loop through all loaded drivers.
39699>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
39702>>>>>>>        For iDriver from 1 to iNumberOfDrivers
39708>>>>>>>>
39708>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
39711>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
39713>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
39714>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
39717>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
39718>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
39719>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
39720>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
39721>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
39723>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
39724>>>>>>>                End                                
39724>>>>>>>>
39724>>>>>>>                Else Begin
39725>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
39726>>>>>>>                End
39726>>>>>>>>
39726>>>>>>>            End
39726>>>>>>>>
39726>>>>>>>        Loop
39727>>>>>>>>
39727>>>>>>>        Send Destroy of hoCLIHandler  
39728>>>>>>>        Send Destroy of hoMSSQLHandler  
39729>>>>>>>        If (bShowErrorDialog = True) Begin
39731>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
39732>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
39734>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
39735>>>>>>>                If (bExitProgram = True) Begin
39737>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
39738>>>>>>>                End
39738>>>>>>>>
39738>>>>>>>                Send Stop_Box sRetval  
39739>>>>>>>                If (bExitProgram = True) Begin
39741>>>>>>>                    Send Exit_Application
39742>>>>>>>                End
39742>>>>>>>>
39742>>>>>>>            End
39742>>>>>>>>
39742>>>>>>>        End
39742>>>>>>>>
39742>>>>>>>        
39742>>>>>>>        Function_Return sRetval
39743>>>>>>>    End_Function  
39744>>>>>>>    
39744>>>>>>>    // Returns True if first "." separated string is greater than the second.
39744>>>>>>>    // It checks from left to right, one part of the string at a time.
39744>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
39744>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
39746>>>>>>>        String[] asVersion asSQLVersion          
39748>>>>>>>        Integer iSize iCount iVersion iSQLVersion
39748>>>>>>>        
39748>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
39749>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
39750>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
39751>>>>>>>        // Make sure the two arrays are of the same size:
39751>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
39753>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
39754>>>>>>>        End
39754>>>>>>>>
39754>>>>>>>        Decrement iSize
39755>>>>>>>        for iCount from 0 to iSize
39761>>>>>>>>
39761>>>>>>>            Move asVersion[iCount]    to iVersion
39762>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
39763>>>>>>>            CompilerWarnings Off
39763>>>>>>>            If (iVersion > iSQLVersion) Break
39766>>>>>>>            CompilerWarnings On
39766>>>>>>>        Loop
39767>>>>>>>>
39767>>>>>>>        
39767>>>>>>>        Function_Return (iVersion > iSQLVersion)
39768>>>>>>>    End_Function
39769>>>>>>>
39769>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
39769>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
39769>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
39769>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
39771>>>>>>>        Integer iMode iErrorObject
39771>>>>>>>        Boolean bOpened
39771>>>>>>>        String sTableName 
39771>>>>>>>        Handle hoCurrentErrorHandler
39771>>>>>>>
39771>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
39772>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
39772>>>>>>>        // so we generate an error here:
39772>>>>>>>        If (IsDebuggerPresent()) Begin
39774>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
39775>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
39776>>>>>>>            If (iErrorObject <> 0) Begin
39778>>>>>>>                Move iErrorObject to Error_Object_Id
39779>>>>>>>            End
39779>>>>>>>>
39779>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
39780>>>>>>>>
39780>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
39781>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
39782>>>>>>>            Function_Return False
39783>>>>>>>        End
39783>>>>>>>>
39783>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
39786>>>>>>>        If (bOpened) Begin
39788>>>>>>>//            If (IsDebuggerPresent()) Begin
39788>>>>>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39788>>>>>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
39788>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
39788>>>>>>>//                    Function_Return True
39788>>>>>>>//                End
39788>>>>>>>//            End
39788>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
39791>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
39793>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39794>>>>>>>                Function_Return True
39795>>>>>>>            End
39795>>>>>>>>
39795>>>>>>>            Close hTable
39796>>>>>>>        End
39796>>>>>>>>
39796>>>>>>>        Else Begin
39797>>>>>>>            Open hTable
39799>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
39802>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
39804>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39807>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
39809>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39810>>>>>>>                    Function_Return True
39811>>>>>>>                End
39811>>>>>>>>
39811>>>>>>>            End
39811>>>>>>>>
39811>>>>>>>
39811>>>>>>>        End
39811>>>>>>>>
39811>>>>>>>
39811>>>>>>>        Close hTable
39812>>>>>>>        Open hTable Mode DF_EXCLUSIVE
39814>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
39817>>>>>>>
39817>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
39818>>>>>>>        Function_Return bOpened
39819>>>>>>>    End_Function
39820>>>>>>>
39820>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
39822>>>>>>>        String sConnectionID sConnectionString sDriverID
39822>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
39822>>>>>>>        Handle hoCLI hoDriver
39822>>>>>>>        Integer iRetval
39822>>>>>>>        tSQLConnection SQLConnection
39822>>>>>>>        tSQLConnection SQLConnection
39822>>>>>>>
39822>>>>>>>        Get psDriverID to sDriverID
39823>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
39824>>>>>>>        If (bSQLDriver = False) Begin
39826>>>>>>>            Function_Return True
39827>>>>>>>        End
39827>>>>>>>>
39827>>>>>>>
39827>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
39828>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
39829>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
39830>>>>>>>        Get IsMertechDriver sDriverID to bMertech
39831>>>>>>>        If (bMertech = True) Begin
39833>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
39834>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
39835>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
39836>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
39837>>>>>>>            Send Destroy of hoDriver
39838>>>>>>>            Function_Return bOK
39839>>>>>>>        End
39839>>>>>>>>
39839>>>>>>>
39839>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
39840>>>>>>>
39840>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
39841>>>>>>>        If (bExists = False) Begin
39843>>>>>>>            // We always start by deleting the current connection - if any - because the
39843>>>>>>>            // login details my have changed.
39843>>>>>>>            Get phoCLIHandler to hoCLI
39844>>>>>>>            Set psDriverID    of hoCLI to sDriverID
39845>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
39846>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
39847>>>>>>>            If (bOk = False) Begin
39849>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
39850>>>>>>>>
39850>>>>>>>                Function_Return False
39851>>>>>>>            End
39851>>>>>>>>
39851>>>>>>>            Move bOK to bExists
39852>>>>>>>        End
39852>>>>>>>>
39852>>>>>>>
39852>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
39853>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
39854>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
39855>>>>>>>        Send Destroy of hoDriver
39856>>>>>>>
39856>>>>>>>        Function_Return (bExists = True)
39857>>>>>>>    End_Function
39858>>>>>>>
39858>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
39858>>>>>>>    // Returns: False if nobody else is running
39858>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
39858>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
39858>>>>>>>    //      tables are not locked as DataFlex tables are.
39858>>>>>>>    Function IsDatabaseInUse Returns Boolean
39860>>>>>>>        Handle  hTable
39860>>>>>>>        String  sRootName
39860>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
39860>>>>>>>        Integer iCount iTables
39860>>>>>>>
39860>>>>>>>        Move 0 to iTables
39861>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
39862>>>>>>>        Get AutoConnectionIDLogin to bOK
39863>>>>>>>        Get UtilFilelistNoOfTables to iTables
39864>>>>>>>        Set piPosition   of ghoProgressBar to 0
39865>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
39866>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
39867>>>>>>>        Move 0 to hTable
39868>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39871>>>>>>>        Move False to bErr
39872>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
39873>>>>>>>
39873>>>>>>>        Repeat
39873>>>>>>>>
39873>>>>>>>            Set piPosition of ghoProgressBar to iCount
39874>>>>>>>            Increment iCount
39875>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
39878>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
39879>>>>>>>
39879>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
39879>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
39880>>>>>>>            Move False to bOpen
39881>>>>>>>            Get UtilTableExists hTable to bExists
39882>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
39882>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
39884>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
39885>>>>>>>                Open hTable
39887>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
39890>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
39891>>>>>>>                If (bOpen = True) Begin
39893>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
39893>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
39894>>>>>>>                    If (bAlias = False) Begin
39896>>>>>>>                        Close hTable
39897>>>>>>>                        Get OpenTableExclusive hTable to bOpen
39898>>>>>>>                        If (bOpen = False) Begin
39900>>>>>>>                            Move True to bErr
39901>>>>>>>                        End
39901>>>>>>>>
39901>>>>>>>                    End
39901>>>>>>>>
39901>>>>>>>                End
39901>>>>>>>>
39901>>>>>>>                Close hTable
39902>>>>>>>            End
39902>>>>>>>>
39902>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39905>>>>>>>            If (bErr = True ) ;                Break
39908>>>>>>>        Until (not(hTable))
39910>>>>>>>
39910>>>>>>>        Set Action_Text of ghoStatusPanel to ""
39911>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
39912>>>>>>>        Move False to Err
39913>>>>>>>
39913>>>>>>>        Function_Return bErr
39914>>>>>>>    End_Function
39915>>>>>>>
39915>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
39915>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
39915>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
39915>>>>>>>    // NOTE: Only applicable for DAW drivers.
39915>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
39917>>>>>>>        String sID sConnString
39917>>>>>>>        Integer iDriver iNumConn iCount
39917>>>>>>>        Handle hoCLI
39917>>>>>>>        Boolean bOK
39917>>>>>>>
39917>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
39918>>>>>>>        If (bOK = False) Begin
39920>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
39921>>>>>>>>
39921>>>>>>>            Function_Return False
39922>>>>>>>        End
39922>>>>>>>>
39922>>>>>>>
39922>>>>>>>        Move False to bOK
39923>>>>>>>        Get phoCLIHandler to hoCLI
39924>>>>>>>        If (hoCLI <> 0) Begin
39926>>>>>>>            Set psDriverID of hoCLI to sDriverID
39927>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
39928>>>>>>>
39928>>>>>>>            // If driver not loaded; load it.
39928>>>>>>>            If (iDriver = 0) Begin
39930>>>>>>>                Load_Driver sDriverID
39931>>>>>>>                Get DriverIndex sDriverID to iDriver
39932>>>>>>>            End
39932>>>>>>>>
39932>>>>>>>            If (iDriver <> 0) Begin
39934>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
39937>>>>>>>                Decrement iNumConn
39938>>>>>>>                for iCount from 0 to iNumConn
39944>>>>>>>>
39944>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
39947>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
39950>>>>>>>                    If (sID = sConnectionID) Begin
39952>>>>>>>                        Move True to bOK
39953>>>>>>>                    End
39953>>>>>>>>
39953>>>>>>>                Loop
39954>>>>>>>>
39954>>>>>>>            End
39954>>>>>>>>
39954>>>>>>>        End
39954>>>>>>>>
39954>>>>>>>
39954>>>>>>>        Function_Return bOK
39955>>>>>>>    End_Function
39956>>>>>>>
39956>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
39958>>>>>>>        Boolean bOK
39958>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
39959>>>>>>>        Function_Return bOK
39960>>>>>>>    End_Function
39961>>>>>>>
39961>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
39963>>>>>>>        Boolean bOK
39963>>>>>>>        Move False to bOK
39964>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
39965>>>>>>>        Function_Return bOK
39966>>>>>>>    End_Function
39967>>>>>>>
39967>>>>>>>    Function IsMSSQLDriver Returns Boolean
39969>>>>>>>        Integer iDriverIndex
39969>>>>>>>
39969>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
39970>>>>>>>
39970>>>>>>>        Function_Return (iDriverIndex <> 0)
39971>>>>>>>    End_Function
39972>>>>>>>
39972>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
39972>>>>>>>    // attempt to load the driver.
39972>>>>>>>    // Returns true if the passed driver is SQL based.
39972>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
39974>>>>>>>        Boolean bOK
39974>>>>>>>
39974>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
39975>>>>>>>
39975>>>>>>>        If (bOK = False) Begin
39977>>>>>>>            Get IsMertechDriver sDriverID to bOK
39978>>>>>>>        End
39978>>>>>>>>
39978>>>>>>>
39978>>>>>>>        Function_Return bOK
39979>>>>>>>    End_Function
39980>>>>>>>
39980>>>>>>>    // *** Error Handler ***
39980>>>>>>>    //
39980>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
39980>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
39980>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
39982>>>>>>>        Integer iSize iErrorMode
39982>>>>>>>        tSqlErrorArray aSqlErrorArray
39982>>>>>>>        tSqlErrorArray aSqlErrorArray
39982>>>>>>>
39982>>>>>>>        If (pbProcessingError(Self)) Begin
39984>>>>>>>            Procedure_Return
39985>>>>>>>        End
39985>>>>>>>>
39985>>>>>>>
39985>>>>>>>        Get Error_Report_Mode to iErrorMode
39986>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
39988>>>>>>>            Procedure_Return
39989>>>>>>>        End
39989>>>>>>>>
39989>>>>>>>
39989>>>>>>>        Set pbProcessingError to True
39990>>>>>>>        Set pbSqlError to True
39991>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
39992>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
39993>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
39994>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
39995>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
39996>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
39997>>>>>>>        Set pbProcessingError to False
39998>>>>>>>    End_Procedure
39999>>>>>>>
39999>>>>>>>    // *** Miscellanous Helper Functions ***
39999>>>>>>>    //
39999>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
39999>>>>>>>    // returns the table name only; stripped of any path or filename extension.
39999>>>>>>>    Function _TableNameOnly String sName Returns String
40001>>>>>>>        String sPath sExt
40001>>>>>>>
40001>>>>>>>        Get ParseFolderName sName to sPath
40002>>>>>>>        If (sPath <> "") Begin
40004>>>>>>>            Move (Replace(sPath, sName, "")) to sName
40005>>>>>>>        End
40005>>>>>>>>
40005>>>>>>>        Get ParseFileExtension sName to sExt
40006>>>>>>>        If (sExt <> "") Begin
40008>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
40009>>>>>>>        End
40009>>>>>>>>
40009>>>>>>>
40009>>>>>>>        Function_Return sName
40010>>>>>>>    End_Function
40011>>>>>>>
40011>>>>>>>    // Removes any prefix to a table name.
40011>>>>>>>    // Example mssqldrv:mytable returns mytable
40011>>>>>>>    //         dbo.mytable returns mytable
40011>>>>>>>    Function _TableNoPrefix String sName Returns String
40013>>>>>>>        Integer iPos
40013>>>>>>>
40013>>>>>>>        Move (Pos(":", sName)) to iPos
40014>>>>>>>        If (iPos <> 0) Begin
40016>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
40017>>>>>>>        End
40017>>>>>>>>
40017>>>>>>>        Move (Pos(".", sName)) to iPos
40018>>>>>>>        If (iPos <> 0) Begin
40020>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
40021>>>>>>>        End
40021>>>>>>>>
40021>>>>>>>
40021>>>>>>>        Function_Return sName
40022>>>>>>>    End_Function
40023>>>>>>>
40023>>>>>>>    // Returns the first datapath found in the psDataPath property.
40023>>>>>>>    // The returned path always ends with a "\"
40023>>>>>>>    Function psDataPathFirstPart Returns String
40025>>>>>>>        String sDataPath
40025>>>>>>>        Integer iCount
40025>>>>>>>
40025>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
40026>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
40027>>>>>>>        If (iCount > 1) Begin
40029>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
40030>>>>>>>        End
40030>>>>>>>>
40030>>>>>>>        If (sDataPath <> "") Begin
40032>>>>>>>            Get vFolderFormat sDataPath to sDataPath
40033>>>>>>>        End
40033>>>>>>>>
40033>>>>>>>
40033>>>>>>>        Function_Return sDataPath
40034>>>>>>>    End_Function
40035>>>>>>>
40035>>>>>>>    Function psLogTextFileWithPath Returns String
40037>>>>>>>        String sFileName
40037>>>>>>>        Handle hoLogFile
40037>>>>>>>        Get phoLogFile to hoLogFile
40038>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
40039>>>>>>>        Function_Return sFileName
40040>>>>>>>    End_Function
40041>>>>>>>
40041>>>>>>>    // *** Property Messages ***
40041>>>>>>>    //
40041>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
40041>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
40041>>>>>>>    //
40041>>>>>>>
40041>>>>>>>    Function pSQLConnection Returns tSQLConnection
40043>>>>>>>        tSQLConnection SQLConnection
40043>>>>>>>        tSQLConnection SQLConnection
40043>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40045>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
40045>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40046>>>>>>>>
40046>>>>>>>            Function_Return
40047>>>>>>>        End
40047>>>>>>>>
40047>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
40048>>>>>>>        Function_Return SQLConnection
40049>>>>>>>    End_Function
40050>>>>>>>
40050>>>>>>>    // * Dummy function for the Studio's Code Explorer *
40050>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
40052>>>>>>>        Function_Return False
40053>>>>>>>    End_Function
40054>>>>>>>
40054>>>>>>>    Procedure Set psServer String sValue
40056>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40058>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
40058>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40059>>>>>>>>
40059>>>>>>>            Procedure_Return
40060>>>>>>>        End
40060>>>>>>>>
40060>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
40061>>>>>>>    End_Procedure
40062>>>>>>>
40062>>>>>>>    Function psServer Returns String
40064>>>>>>>        String sValue
40064>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40066>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40067>>>>>>>>
40067>>>>>>>            Function_Return
40068>>>>>>>        End
40068>>>>>>>>
40068>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
40069>>>>>>>        Function_Return sValue
40070>>>>>>>    End_Function
40071>>>>>>>
40071>>>>>>>    Procedure Set psDatabase String sValue
40073>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40075>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40076>>>>>>>>
40076>>>>>>>            Procedure_Return
40077>>>>>>>        End
40077>>>>>>>>
40077>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
40078>>>>>>>    End_Procedure
40079>>>>>>>
40079>>>>>>>    Function psDatabase Returns String
40081>>>>>>>        String sValue
40081>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40083>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40084>>>>>>>>
40084>>>>>>>            Function_Return
40085>>>>>>>        End
40085>>>>>>>>
40085>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
40086>>>>>>>        Function_Return sValue
40087>>>>>>>    End_Function
40088>>>>>>>
40088>>>>>>>    Procedure Set psUserID String sValue
40090>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40092>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40093>>>>>>>>
40093>>>>>>>            Procedure_Return
40094>>>>>>>        End
40094>>>>>>>>
40094>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
40095>>>>>>>    End_Procedure
40096>>>>>>>
40096>>>>>>>    Function psUserID Returns String
40098>>>>>>>        String sValue
40098>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40100>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40101>>>>>>>>
40101>>>>>>>            Function_Return
40102>>>>>>>        End
40102>>>>>>>>
40102>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
40103>>>>>>>        Function_Return sValue
40104>>>>>>>    End_Function
40105>>>>>>>
40105>>>>>>>    Procedure Set psPassword String sValue
40107>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40109>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40110>>>>>>>>
40110>>>>>>>            Procedure_Return
40111>>>>>>>        End
40111>>>>>>>>
40111>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
40112>>>>>>>    End_Procedure
40113>>>>>>>
40113>>>>>>>    Function psPassword Returns String
40115>>>>>>>        String sValue
40115>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40117>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40118>>>>>>>>
40118>>>>>>>            Function_Return
40119>>>>>>>        End
40119>>>>>>>>
40119>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
40120>>>>>>>        Function_Return sValue
40121>>>>>>>    End_Function
40122>>>>>>>
40122>>>>>>>    Procedure Set pbTrusted Boolean bValue
40124>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40126>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40127>>>>>>>>
40127>>>>>>>            Procedure_Return
40128>>>>>>>        End
40128>>>>>>>>
40128>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
40129>>>>>>>    End_Procedure
40130>>>>>>>
40130>>>>>>>    Function pbTrusted Returns Boolean
40132>>>>>>>        Boolean bValue
40132>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40134>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40135>>>>>>>>
40135>>>>>>>            Function_Return
40136>>>>>>>        End
40136>>>>>>>>
40136>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
40137>>>>>>>        Function_Return bValue
40138>>>>>>>    End_Function
40139>>>>>>>
40139>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
40141>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40143>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40144>>>>>>>>
40144>>>>>>>            Procedure_Return
40145>>>>>>>        End
40145>>>>>>>>
40145>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
40146>>>>>>>    End_Procedure
40147>>>>>>>
40147>>>>>>>    Function pbSilentLogin Returns Boolean
40149>>>>>>>        Boolean bValue
40149>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40151>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40152>>>>>>>>
40152>>>>>>>            Function_Return
40153>>>>>>>        End
40153>>>>>>>>
40153>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
40154>>>>>>>        Function_Return bValue
40155>>>>>>>    End_Function
40156>>>>>>>
40156>>>>>>>    Procedure Set psConnectionID String sValue
40158>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40160>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40161>>>>>>>>
40161>>>>>>>            Procedure_Return
40162>>>>>>>        End
40162>>>>>>>>
40162>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
40163>>>>>>>    End_Procedure
40164>>>>>>>
40164>>>>>>>    Function psConnectionID Returns String
40166>>>>>>>        String sValue
40166>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40168>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40169>>>>>>>>
40169>>>>>>>            Function_Return
40170>>>>>>>        End
40170>>>>>>>>
40170>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
40171>>>>>>>        Function_Return sValue
40172>>>>>>>    End_Function
40173>>>>>>>
40173>>>>>>>    Procedure Set psConnectionString String sValue
40175>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40177>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40178>>>>>>>>
40178>>>>>>>            Procedure_Return
40179>>>>>>>        End
40179>>>>>>>>
40179>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
40180>>>>>>>    End_Procedure
40181>>>>>>>
40181>>>>>>>    Function psConnectionString Returns String
40183>>>>>>>        String sValue
40183>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40185>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40186>>>>>>>>
40186>>>>>>>            Function_Return
40187>>>>>>>        End
40187>>>>>>>>
40187>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
40188>>>>>>>        Function_Return sValue
40189>>>>>>>    End_Function
40190>>>>>>>
40190>>>>>>>    // The normal connection string looks something like this;
40190>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
40190>>>>>>>    // ...and the full connection string looks like this;
40190>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
40190>>>>>>>    Function psFullConnectionString Returns String
40192>>>>>>>        String sConnectionID sConnectionString
40192>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40194>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40195>>>>>>>>
40195>>>>>>>            Function_Return
40196>>>>>>>        End
40196>>>>>>>>
40196>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
40197>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
40198>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
40199>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
40200>>>>>>>    End_Function
40201>>>>>>>
40201>>>>>>>    Function piConnectionOptions Returns Integer
40203>>>>>>>        Integer iValue
40203>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40205>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40206>>>>>>>>
40206>>>>>>>            Function_Return
40207>>>>>>>        End
40207>>>>>>>>
40207>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
40208>>>>>>>        Function_Return iValue
40209>>>>>>>    End_Function
40210>>>>>>>
40210>>>>>>>    Procedure Set psSchema String sValue
40212>>>>>>>        tSQLConnection SQLConnection
40212>>>>>>>        tSQLConnection SQLConnection
40212>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40214>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40215>>>>>>>>
40215>>>>>>>            Procedure_Return
40216>>>>>>>        End
40216>>>>>>>>
40216>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
40217>>>>>>>    End_Procedure
40218>>>>>>>
40218>>>>>>>    Function psSchema Returns String
40220>>>>>>>        String sRetval
40220>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40222>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40223>>>>>>>>
40223>>>>>>>            Function_Return
40224>>>>>>>        End
40224>>>>>>>>
40224>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
40225>>>>>>>        Function_Return sRetval
40226>>>>>>>    End_Function
40227>>>>>>>
40227>>>>>>>    Procedure Set psBaseTableSpace String sValue
40229>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40231>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40232>>>>>>>>
40232>>>>>>>            Procedure_Return
40233>>>>>>>        End
40233>>>>>>>>
40233>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
40234>>>>>>>    End_Procedure
40235>>>>>>>
40235>>>>>>>    Function psBaseTableSpace Returns String
40237>>>>>>>        String sRetval
40237>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40239>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40240>>>>>>>>
40240>>>>>>>            Function_Return
40241>>>>>>>        End
40241>>>>>>>>
40241>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
40242>>>>>>>        Function_Return sRetval
40243>>>>>>>    End_Function
40244>>>>>>>
40244>>>>>>>    Procedure Set psLongTableSpace String sValue
40246>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40248>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40249>>>>>>>>
40249>>>>>>>            Procedure_Return
40250>>>>>>>        End
40250>>>>>>>>
40250>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
40251>>>>>>>    End_Procedure
40252>>>>>>>
40252>>>>>>>    Function psLongTableSpace Returns String
40254>>>>>>>        String sRetval
40254>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40256>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40257>>>>>>>>
40257>>>>>>>            Function_Return
40258>>>>>>>        End
40258>>>>>>>>
40258>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
40259>>>>>>>        Function_Return sRetval
40260>>>>>>>    End_Function
40261>>>>>>>
40261>>>>>>>    Procedure Set psIndexTableSpace String sValue
40263>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40265>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40266>>>>>>>>
40266>>>>>>>            Procedure_Return
40267>>>>>>>        End
40267>>>>>>>>
40267>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
40268>>>>>>>    End_Procedure
40269>>>>>>>
40269>>>>>>>    Function psIndexTableSpace Returns String
40271>>>>>>>        String sRetval
40271>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40273>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40274>>>>>>>>
40274>>>>>>>            Function_Return
40275>>>>>>>        End
40275>>>>>>>>
40275>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
40276>>>>>>>        Function_Return sRetval
40277>>>>>>>    End_Function
40278>>>>>>>
40278>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
40280>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40282>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40283>>>>>>>>
40283>>>>>>>            Procedure_Return
40284>>>>>>>        End
40284>>>>>>>>
40284>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
40285>>>>>>>    End_Procedure
40286>>>>>>>
40286>>>>>>>    Function pbUseConnectionID Returns Boolean
40288>>>>>>>        Boolean bState
40288>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40290>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40291>>>>>>>>
40291>>>>>>>            Function_Return
40292>>>>>>>        End
40292>>>>>>>>
40292>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
40293>>>>>>>        Function_Return bState
40294>>>>>>>    End_Function
40295>>>>>>>
40295>>>>>>>    Procedure Set pbToANSI Boolean bState
40297>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40299>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40300>>>>>>>>
40300>>>>>>>            Procedure_Return
40301>>>>>>>        End
40301>>>>>>>>
40301>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
40302>>>>>>>    End_Procedure
40303>>>>>>>
40303>>>>>>>    Function pbToANSI Returns Boolean
40305>>>>>>>        Boolean bState
40305>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40307>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40308>>>>>>>>
40308>>>>>>>            Function_Return
40309>>>>>>>        End
40309>>>>>>>>
40309>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
40310>>>>>>>        Function_Return bState
40311>>>>>>>    End_Function
40312>>>>>>>
40312>>>>>>>    Procedure Set pbRecnum Boolean bState
40314>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40316>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40317>>>>>>>>
40317>>>>>>>            Procedure_Return
40318>>>>>>>        End
40318>>>>>>>>
40318>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
40319>>>>>>>    End_Procedure
40320>>>>>>>
40320>>>>>>>    Function pbRecnum Returns Boolean
40322>>>>>>>        Boolean bState
40322>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40324>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40325>>>>>>>>
40325>>>>>>>            Function_Return
40326>>>>>>>        End
40326>>>>>>>>
40326>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
40327>>>>>>>        Function_Return bState
40328>>>>>>>    End_Function
40329>>>>>>>
40329>>>>>>>    Procedure Set pbCopyData Boolean bState
40331>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40333>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40334>>>>>>>>
40334>>>>>>>            Procedure_Return
40335>>>>>>>        End
40335>>>>>>>>
40335>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
40336>>>>>>>    End_Procedure
40337>>>>>>>
40337>>>>>>>    Function pbCopyData Returns Boolean
40339>>>>>>>        Boolean bState
40339>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40341>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40342>>>>>>>>
40342>>>>>>>            Function_Return
40343>>>>>>>        End
40343>>>>>>>>
40343>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
40344>>>>>>>        Function_Return bState
40345>>>>>>>    End_Function
40346>>>>>>>
40346>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
40348>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40350>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40351>>>>>>>>
40351>>>>>>>            Procedure_Return
40352>>>>>>>        End
40352>>>>>>>>
40352>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40353>>>>>>>    End_Procedure
40354>>>>>>>
40354>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
40356>>>>>>>        Boolean bState
40356>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40358>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40359>>>>>>>>
40359>>>>>>>            Function_Return
40360>>>>>>>        End
40360>>>>>>>>
40360>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40361>>>>>>>        Function_Return bState
40362>>>>>>>    End_Function
40363>>>>>>>
40363>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
40365>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40367>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40368>>>>>>>>
40368>>>>>>>            Procedure_Return
40369>>>>>>>        End
40369>>>>>>>>
40369>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40370>>>>>>>    End_Procedure
40371>>>>>>>
40371>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
40373>>>>>>>        Boolean bState
40373>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40375>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40376>>>>>>>>
40376>>>>>>>            Function_Return
40377>>>>>>>        End
40377>>>>>>>>
40377>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40378>>>>>>>        Function_Return bState
40379>>>>>>>    End_Function
40380>>>>>>>
40380>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
40382>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40384>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40385>>>>>>>>
40385>>>>>>>            Procedure_Return
40386>>>>>>>        End
40386>>>>>>>>
40386>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40387>>>>>>>    End_Procedure
40388>>>>>>>
40388>>>>>>>    Function pbCompareIndexAscending Returns Boolean
40390>>>>>>>        Boolean bState
40390>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40392>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40393>>>>>>>>
40393>>>>>>>            Function_Return
40394>>>>>>>        End
40394>>>>>>>>
40394>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40395>>>>>>>        Function_Return bState
40396>>>>>>>    End_Function
40397>>>>>>>
40397>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
40399>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40401>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40402>>>>>>>>
40402>>>>>>>            Procedure_Return
40403>>>>>>>        End
40403>>>>>>>>
40403>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
40404>>>>>>>    End_Procedure
40405>>>>>>>
40405>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
40407>>>>>>>        Boolean bState
40407>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40409>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40410>>>>>>>>
40410>>>>>>>            Function_Return
40411>>>>>>>        End
40411>>>>>>>>
40411>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
40412>>>>>>>        Function_Return bState
40413>>>>>>>    End_Function
40414>>>>>>>
40414>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
40416>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40418>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40419>>>>>>>>
40419>>>>>>>            Procedure_Return
40420>>>>>>>        End
40420>>>>>>>>
40420>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
40421>>>>>>>    End_Procedure
40422>>>>>>>
40422>>>>>>>    Function psDriverDefaultValueASCII Returns String
40424>>>>>>>        String sRetval
40424>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40426>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40427>>>>>>>>
40427>>>>>>>            Function_Return
40428>>>>>>>        End
40428>>>>>>>>
40428>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
40429>>>>>>>        Function_Return sRetval
40430>>>>>>>    End_Function
40431>>>>>>>
40431>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
40433>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40435>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40436>>>>>>>>
40436>>>>>>>            Procedure_Return
40437>>>>>>>        End
40437>>>>>>>>
40437>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
40438>>>>>>>    End_Procedure
40439>>>>>>>
40439>>>>>>>    Function psDriverDefaultValueBinary Returns String
40441>>>>>>>        String sRetval
40441>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40443>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40444>>>>>>>>
40444>>>>>>>            Function_Return
40445>>>>>>>        End
40445>>>>>>>>
40445>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
40446>>>>>>>        Function_Return sRetval
40447>>>>>>>    End_Function
40448>>>>>>>
40448>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
40450>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40452>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40453>>>>>>>>
40453>>>>>>>            Procedure_Return
40454>>>>>>>        End
40454>>>>>>>>
40454>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
40455>>>>>>>    End_Procedure
40456>>>>>>>
40456>>>>>>>    Function psDriverDefaultValueDate Returns String
40458>>>>>>>        String sRetval
40458>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40460>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40461>>>>>>>>
40461>>>>>>>            Function_Return
40462>>>>>>>        End
40462>>>>>>>>
40462>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
40463>>>>>>>        Function_Return sRetval
40464>>>>>>>    End_Function
40465>>>>>>>
40465>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
40467>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40469>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40470>>>>>>>>
40470>>>>>>>            Procedure_Return
40471>>>>>>>        End
40471>>>>>>>>
40471>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
40472>>>>>>>    End_Procedure
40473>>>>>>>
40473>>>>>>>    Function psDriverDefaultValueDateTime Returns String
40475>>>>>>>        String sRetval
40475>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40477>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40478>>>>>>>>
40478>>>>>>>            Function_Return
40479>>>>>>>        End
40479>>>>>>>>
40479>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
40480>>>>>>>        Function_Return sRetval
40481>>>>>>>    End_Function
40482>>>>>>>
40482>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
40484>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40486>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40487>>>>>>>>
40487>>>>>>>            Procedure_Return
40488>>>>>>>        End
40488>>>>>>>>
40488>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
40489>>>>>>>    End_Procedure
40490>>>>>>>
40490>>>>>>>    Function psDriverDefaultValueNumeric Returns String
40492>>>>>>>        String sRetval
40492>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40494>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40495>>>>>>>>
40495>>>>>>>            Function_Return
40496>>>>>>>        End
40496>>>>>>>>
40496>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
40497>>>>>>>        Function_Return sRetval
40498>>>>>>>    End_Function
40499>>>>>>>
40499>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
40501>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40503>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40504>>>>>>>>
40504>>>>>>>            Procedure_Return
40505>>>>>>>        End
40505>>>>>>>>
40505>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
40506>>>>>>>    End_Procedure
40507>>>>>>>
40507>>>>>>>    Function psDriverDefaultValueText Returns String
40509>>>>>>>        String sRetval
40509>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40511>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40512>>>>>>>>
40512>>>>>>>            Function_Return
40513>>>>>>>        End
40513>>>>>>>>
40513>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
40514>>>>>>>        Function_Return sRetval
40515>>>>>>>    End_Function
40516>>>>>>>
40516>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
40518>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40520>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40521>>>>>>>>
40521>>>>>>>            Procedure_Return
40522>>>>>>>        End
40522>>>>>>>>
40522>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
40523>>>>>>>    End_Procedure
40524>>>>>>>
40524>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
40526>>>>>>>        Boolean bState
40526>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40528>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40529>>>>>>>>
40529>>>>>>>            Function_Return
40530>>>>>>>        End
40530>>>>>>>>
40530>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
40531>>>>>>>        Function_Return bState
40532>>>>>>>    End_Function
40533>>>>>>>
40533>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
40535>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40537>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40538>>>>>>>>
40538>>>>>>>            Procedure_Return
40539>>>>>>>        End
40539>>>>>>>>
40539>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
40540>>>>>>>    End_Procedure
40541>>>>>>>
40541>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
40543>>>>>>>        Boolean bState
40543>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40545>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40546>>>>>>>>
40546>>>>>>>            Function_Return
40547>>>>>>>        End
40547>>>>>>>>
40547>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
40548>>>>>>>        Function_Return bState
40549>>>>>>>    End_Function
40550>>>>>>>
40550>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
40552>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40554>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40555>>>>>>>>
40555>>>>>>>            Procedure_Return
40556>>>>>>>        End
40556>>>>>>>>
40556>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
40557>>>>>>>    End_Procedure
40558>>>>>>>
40558>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
40560>>>>>>>        Boolean bState
40560>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40562>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40563>>>>>>>>
40563>>>>>>>            Function_Return
40564>>>>>>>        End
40564>>>>>>>>
40564>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
40565>>>>>>>        Function_Return bState
40566>>>>>>>    End_Function
40567>>>>>>>
40567>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
40569>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40571>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40572>>>>>>>>
40572>>>>>>>            Procedure_Return
40573>>>>>>>        End
40573>>>>>>>>
40573>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
40574>>>>>>>    End_Procedure
40575>>>>>>>
40575>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
40577>>>>>>>        Boolean bState
40577>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40579>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40580>>>>>>>>
40580>>>>>>>            Function_Return
40581>>>>>>>        End
40581>>>>>>>>
40581>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
40582>>>>>>>        Function_Return bState
40583>>>>>>>    End_Function
40584>>>>>>>
40584>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
40586>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40588>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40589>>>>>>>>
40589>>>>>>>            Procedure_Return
40590>>>>>>>        End
40590>>>>>>>>
40590>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
40591>>>>>>>    End_Procedure
40592>>>>>>>
40592>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
40594>>>>>>>        Boolean bState
40594>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40596>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40597>>>>>>>>
40597>>>>>>>            Function_Return
40598>>>>>>>        End
40598>>>>>>>>
40598>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
40599>>>>>>>        Function_Return bState
40600>>>>>>>    End_Function
40601>>>>>>>
40601>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
40603>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40605>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40606>>>>>>>>
40606>>>>>>>            Procedure_Return
40607>>>>>>>        End
40607>>>>>>>>
40607>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
40608>>>>>>>    End_Procedure
40609>>>>>>>
40609>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
40611>>>>>>>        Boolean bState
40611>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40613>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40614>>>>>>>>
40614>>>>>>>            Function_Return
40615>>>>>>>        End
40615>>>>>>>>
40615>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
40616>>>>>>>        Function_Return bState
40617>>>>>>>    End_Function
40618>>>>>>>
40618>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
40618>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
40618>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
40618>>>>>>>    //       for a connection string has the wrong format for that driver.
40618>>>>>>>    Procedure Set psDriverID String sValue
40620>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40621>>>>>>>        Delegate Set psDriverID to sValue
40623>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40624>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
40625>>>>>>>    End_Procedure
40626>>>>>>>
40626>>>>>>>    Function psDriverID Returns String
40628>>>>>>>        String sDriverID
40628>>>>>>>
40628>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40629>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
40629>>>>>>>        Delegate Get psDriverID to sDriverID
40631>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40632>>>>>>>        Move False to Err
40633>>>>>>>
40633>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
40633>>>>>>>        // probably used as "utilites" from a special made program and
40633>>>>>>>        // the ghoSQLConnectionHandler must have been setup
40633>>>>>>>        If (sDriverID = "") Begin
40635>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
40636>>>>>>>        End
40636>>>>>>>>
40636>>>>>>>        Function_Return sDriverID
40637>>>>>>>    End_Function
40638>>>>>>>
40638>>>>>>>    Procedure Set piDbType Integer iValue
40640>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40641>>>>>>>        Delegate Set piDbType to iValue
40643>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40644>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
40645>>>>>>>    End_Procedure
40646>>>>>>>
40646>>>>>>>    Function piDbType Returns Integer
40648>>>>>>>        Integer iRetval
40648>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
40649>>>>>>>        Function_Return iRetval
40650>>>>>>>    End_Function
40651>>>>>>>
40651>>>>>>>    Function phoLogFile Returns Handle
40653>>>>>>>        Handle hoLogFile   
40653>>>>>>>        Boolean bErr
40653>>>>>>>        
40653>>>>>>>        Move Err to bErr
40654>>>>>>>        Move 0 to hoLogFile
40655>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
40656>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40657>>>>>>>        Delegate Get phoLogFile to hoLogFile
40659>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40660>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
40661>>>>>>>        Move bErr to Err
40662>>>>>>>        
40662>>>>>>>        Function_Return hoLogFile
40663>>>>>>>    End_Function
40664>>>>>>>
40664>>>>>>>    Function pnCurrentVersionUpdate Returns Number
40666>>>>>>>        Number nCurrentVersionUpdate
40666>>>>>>>
40666>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
40667>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
40669>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
40670>>>>>>>
40670>>>>>>>        Function_Return nCurrentVersionUpdate
40671>>>>>>>    End_Function
40672>>>>>>>
40672>>>>>>>    Procedure LogError String sText Boolean bError
40674>>>>>>>        Handle hoLogFile
40674>>>>>>>        Number nCurrentVersionUpdate
40674>>>>>>>
40674>>>>>>>        Get phoLogFile to hoLogFile
40675>>>>>>>        If (hoLogFile = 0) Begin
40677>>>>>>>            Procedure_Return
40678>>>>>>>        End
40678>>>>>>>>
40678>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
40679>>>>>>>
40679>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
40680>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
40681>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
40682>>>>>>>    End_Procedure
40683>>>>>>>
40683>>>>>>>    Function pbContinueOnError Returns Boolean
40685>>>>>>>        Boolean bContinueOnError
40685>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
40687>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
40688>>>>>>>        End
40688>>>>>>>>
40688>>>>>>>        Function_Return bContinueOnError
40689>>>>>>>    End_Function
40690>>>>>>>
40690>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
40690>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
40690>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
40690>>>>>>>    // Good read about which collation to select:
40690>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
40690>>>>>>>    Procedure Set psCollation String sCollation
40692>>>>>>>        Set private.psCollation to sCollation
40693>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
40695>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
40696>>>>>>>        End
40696>>>>>>>>
40696>>>>>>>    End_Procedure
40697>>>>>>>
40697>>>>>>>    Function psCollation Returns String
40699>>>>>>>        String sCollation
40699>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
40701>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
40702>>>>>>>        End   
40702>>>>>>>>
40702>>>>>>>        Else Begin
40703>>>>>>>            Get private.psCollation to sCollation
40704>>>>>>>        End
40704>>>>>>>>
40704>>>>>>>        Function_Return sCollation
40705>>>>>>>    End_Function
40706>>>>>>>
40706>>>>>>>
40706>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
40708>>>>>>>        Integer iMax iPos
40708>>>>>>>        String sName
40708>>>>>>>
40708>>>>>>>        Move (Lowercase(sField)) to sField
40709>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
40712>>>>>>>        for iPos from 0 to iMax
40718>>>>>>>>
40718>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
40721>>>>>>>            Move (Lowercase(sName)) to sName
40722>>>>>>>            If (sName = sField) Begin
40724>>>>>>>                Function_Return iPos
40725>>>>>>>            End
40725>>>>>>>>
40725>>>>>>>        Loop
40726>>>>>>>>
40726>>>>>>>        Function_Return -1
40727>>>>>>>    End_Function
40728>>>>>>>
40728>>>>>>>
40728>>>>>>>    // * Dummy function for the Studio's Code Explorer *
40728>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
40730>>>>>>>        Function_Return False
40731>>>>>>>    End_Function
40732>>>>>>>
40732>>>>>>>    // *** Helper functions with compiled sql script code ***
40732>>>>>>>    //
40732>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
40732>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
40732>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
40732>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
40732>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
40732>>>>>>>    //   ALTER TABLE MyTable
40732>>>>>>>    //       REBUILD
40732>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
40734>>>>>>>        Boolean bOK
40734>>>>>>>
40734>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
40736>>>>>>>            Function_Return False
40737>>>>>>>        End
40737>>>>>>>>
40737>>>>>>>
40737>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
40737>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
40738>>>>>>>
40738>>>>>>>        Function_Return (bOK = True)
40739>>>>>>>    End_Function
40740>>>>>>>
40740>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
40740>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
40740>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
40740>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
40740>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
40740>>>>>>>    //   ALTER TABLE MyTable
40740>>>>>>>    //       REBUILD
40740>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
40742>>>>>>>        tSQLScriptArray SQLScriptArray
40742>>>>>>>        tSQLScriptArray SQLScriptArray
40742>>>>>>>        String sDriverID
40742>>>>>>>        Boolean bOK
40742>>>>>>>        Integer iSize iCount
40742>>>>>>>
40742>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
40744>>>>>>>            Function_Return False
40745>>>>>>>        End
40745>>>>>>>>
40745>>>>>>>
40745>>>>>>>        Get psDriverID to sDriverID
40746>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
40747>>>>>>>        If (SQLScriptArray.bError = True) Begin
40749>>>>>>>            Function_Return False
40750>>>>>>>        End
40750>>>>>>>>
40750>>>>>>>
40750>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
40751>>>>>>>        Decrement iSize
40752>>>>>>>
40752>>>>>>>        for iCount from 0 to iSize
40758>>>>>>>>
40758>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
40760>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
40761>>>>>>>            End
40761>>>>>>>>
40761>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
40763>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
40764>>>>>>>            End
40764>>>>>>>>
40764>>>>>>>        Loop
40765>>>>>>>>
40765>>>>>>>
40765>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
40766>>>>>>>
40766>>>>>>>        Function_Return (bOK = True)
40767>>>>>>>    End_Function
40768>>>>>>>
40768>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
40770>>>>>>>        tSQLScriptArray SQLScriptArray
40770>>>>>>>        tSQLScriptArray SQLScriptArray
40770>>>>>>>        String sDriverID sCollation
40770>>>>>>>        Boolean bOK
40770>>>>>>>        Integer iSize iCount
40770>>>>>>>
40770>>>>>>>        If (Trim(sDatabaseName) = "") Begin
40772>>>>>>>            Function_Return False
40773>>>>>>>        End
40773>>>>>>>>
40773>>>>>>>
40773>>>>>>>        Get psDriverID  to sDriverID
40774>>>>>>>        Get psCollation to sCollation
40775>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
40776>>>>>>>        If (SQLScriptArray.bError = True) Begin
40778>>>>>>>            Function_Return False
40779>>>>>>>        End
40779>>>>>>>>
40779>>>>>>>
40779>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
40780>>>>>>>        Decrement iSize
40781>>>>>>>
40781>>>>>>>        for iCount from 0 to iSize
40787>>>>>>>>
40787>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
40789>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
40790>>>>>>>            End
40790>>>>>>>>
40790>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
40792>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
40793>>>>>>>            End
40793>>>>>>>>
40793>>>>>>>        Loop
40794>>>>>>>>
40794>>>>>>>
40794>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
40795>>>>>>>
40795>>>>>>>        Function_Return (bOK = True)
40796>>>>>>>    End_Function
40797>>>>>>>
40797>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
40799>>>>>>>        tSQLScriptArray SQLScriptArray
40799>>>>>>>        tSQLScriptArray SQLScriptArray
40799>>>>>>>        String sDriverID sCollation
40799>>>>>>>        Boolean bOK
40799>>>>>>>        Integer iSize iCount
40799>>>>>>>
40799>>>>>>>        If (Trim(sDatabaseName) = "") Begin
40801>>>>>>>            Function_Return False
40802>>>>>>>        End
40802>>>>>>>>
40802>>>>>>>
40802>>>>>>>        Get psDriverID  to sDriverID
40803>>>>>>>        Get psCollation to sCollation
40804>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
40805>>>>>>>        If (SQLScriptArray.bError = True) Begin
40807>>>>>>>            Function_Return False
40808>>>>>>>        End
40808>>>>>>>>
40808>>>>>>>
40808>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
40809>>>>>>>        Decrement iSize
40810>>>>>>>
40810>>>>>>>        for iCount from 0 to iSize
40816>>>>>>>>
40816>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
40818>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
40819>>>>>>>            End
40819>>>>>>>>
40819>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
40821>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
40822>>>>>>>            End
40822>>>>>>>>
40822>>>>>>>        Loop
40823>>>>>>>>
40823>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
40823>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
40824>>>>>>>
40824>>>>>>>        Function_Return (bOK = True)
40825>>>>>>>    End_Function
40826>>>>>>>
40826>>>>>>>    // *** Helper functions for Mertech Drivers ***
40826>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
40826>>>>>>>    // and commands that the Studio editor knows nothing about.
40826>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
40828>>>>>>>        Integer iRetval
40828>>>>>>>        String sPath
40828>>>>>>>
40828>>>>>>>        If (sPath = "" or sTableName = "") Begin
40830>>>>>>>            Function_Return True
40831>>>>>>>        End
40831>>>>>>>>
40831>>>>>>>
40831>>>>>>>        Get vFolderFormat sPath to sPath
40832>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
40833>>>>>>>        Function_Return (iRetval = 0)
40834>>>>>>>    End_Function
40835>>>>>>>
40835>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
40837>>>>>>>        Boolean bOpen bOK
40837>>>>>>>        Move False to Err
40838>>>>>>>        Function_Return (Err = False)
40839>>>>>>>    End_Function
40840>>>>>>>
40840>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
40842>>>>>>>        Integer iNumItems iCount
40842>>>>>>>        String[] sReturnArray
40843>>>>>>>        String sServer
40843>>>>>>>
40843>>>>>>>
40843>>>>>>>        Function_Return sReturnArray
40844>>>>>>>    End_Function
40845>>>>>>>
40845>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
40847>>>>>>>        String[] sReturnArray
40848>>>>>>>        String sServer
40848>>>>>>>
40848>>>>>>>
40848>>>>>>>        Function_Return sReturnArray
40849>>>>>>>    End_Function
40850>>>>>>>
40850>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
40852>>>>>>>        Handle hoSQLHandler hoSQLConnect
40852>>>>>>>
40852>>>>>>>        Move 0 to hoSQLConnect
40853>>>>>>>
40853>>>>>>>        Function_Return hoSQLConnect
40854>>>>>>>    End_Function
40855>>>>>>>
40855>>>>>>>    // Returns the handle of the Mertech SQL handler.
40855>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
40855>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
40855>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
40857>>>>>>>        Handle hoSQLHandler
40857>>>>>>>        String sDriverID sServer sDatabase
40857>>>>>>>
40857>>>>>>>        Move 0 to hoSQLHandler
40858>>>>>>>        Get psDriverID to sDriverID
40859>>>>>>>        Get psServer   to sServer
40860>>>>>>>        Get psDatabase to sDatabase
40861>>>>>>>
40861>>>>>>>        Function_Return hoSQLHandler
40862>>>>>>>    End_Function
40863>>>>>>>
40863>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
40863>>>>>>>    // macro-commands <sigh!>
40863>>>>>>>    // Note: The function sets the Err flag.
40863>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
40865>>>>>>>
40865>>>>>>>        Move False to Err
40866>>>>>>>
40866>>>>>>>        Function_Return (Err = False)
40867>>>>>>>    End_Function
40868>>>>>>>
40868>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
40870>>>>>>>        Move False to Err
40871>>>>>>>        Function_Return (Err = False)
40872>>>>>>>    End_Function
40873>>>>>>>
40873>>>>>>>End_Class
40874>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 23.0\Pkg\for_all.pkg)
40874>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
40874>>>>>>>//
40874>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
40874>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
40874>>>>>>>// conjunction with constraint-clauses.
40874>>>>>>>//
40874>>>>>>>// SYNTAX:
40874>>>>>>>//
40874>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
40874>>>>>>>//    <Constraints...>
40874>>>>>>>//    {DO}
40874>>>>>>>//      <loop body>
40874>>>>>>>//  End_For_All
40874>>>>>>>//
40874>>>>>>>// This set of macros implements a constraint-oriented file enumeration
40874>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
40874>>>>>>>//
40874>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
40874>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
40874>>>>>>>//   End_For_All
40874>>>>>>>//
40874>>>>>>>// To list only Customers with a Balance greater than their credit limit:
40874>>>>>>>//
40874>>>>>>>//   For_All Customer BY Index.1
40874>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
40874>>>>>>>//     DO
40874>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
40874>>>>>>>//   End_For_All
40874>>>>>>>//
40874>>>>>>>// Constraint clauses are:
40874>>>>>>>//
40874>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
40874>>>>>>>//   CONSTRAIN <File> AS <Expression>
40874>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
40874>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
40874>>>>>>>//
40874>>>>>>>// For example, to list all customers with a bad status whose names start
40874>>>>>>>// with "A" and which have not made a payment in thirty days:
40874>>>>>>>//
40874>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
40874>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
40874>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
40874>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
40874>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
40874>>>>>>>//      DO
40874>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
40874>>>>>>>//    End_For_All
40874>>>>>>>//
40874>>>>>>>
40874>>>>>>>
40874>>>>>>>//This command starts the loop process body when constraints are used;
40874>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
40874>>>>>>>//command line, and not on a line by itself
40874>>>>>>>//
40874>>>>>>>
40874>>>>>>>//Ends a For_All loop
40874>>>>>>>//
40874>>>>>>>
40874>>>>>>>
40874>>>>>
40874>>>>>
40874>>>>>Class cDbUpdateVersion is a cObject
40875>>>>>
40875>>>>>    Procedure Construct_Object    
40877>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
40877>>>>>        String[] aSQLQueryMessages
40878>>>>>        
40878>>>>>        Forward Send Construct_Object
40880>>>>>
40880>>>>>        // cDbUpdateHandler object event.
40880>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
40882>>>>>        If (bOnCreateExecuted = False) Begin    
40884>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
40886>>>>>            If (bUseCustomDbVersion = False) Begin
40888>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
40890>>>>>            End
40890>>>>>>
40890>>>>>            Delegate Send CheckIntFilesIntegrity
40892>>>>>            Delegate Send OnCreate
40894>>>>>            Delegate Set Private.pbOnCreateExecuted to True
40896>>>>>        End
40896>>>>>>
40896>>>>>
40896>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
40896>>>>>        // event was triggered, thus an actual change of the database was made.
40896>>>>>        Property Boolean pbVersionUpdate False
40897>>>>>
40897>>>>>        // This property must be manually set within each cDbUpdateVersion object
40897>>>>>        // by the programmer, to a consecutive number.
40897>>>>>        Property Number pnVersionNumber
40898>>>>>
40898>>>>>        Property Boolean pbUseConnectionID True
40899>>>>>        Property Boolean private.pbToANSI   True
40900>>>>>        Property Boolean private.pbRecnum   True
40901>>>>>        Property Boolean private.pbCopyData True
40902>>>>>        Property Boolean private.pbApiTableUpdateAuto False
40903>>>>>        Property Boolean private.pbCompareDate_DateTime False
40904>>>>>        Property Boolean private.pbCompareIndexAscending False
40905>>>>>        Property Boolean private.pbCompareIndexUppercase False
40906>>>>>        Property String private.psSchema
40907>>>>>        Property String private.psBaseTableSpace
40908>>>>>        Property String private.psLongTableSpace
40909>>>>>        Property String private.psIndexTableSpace
40910>>>>>
40910>>>>>        // Driver default value settings:
40910>>>>>        Property String private.psDriverDefaultValueASCII    ""
40911>>>>>        Property String private.psDriverDefaultValueBinary   ""
40912>>>>>        Property String private.psDriverDefaultValueDate     ""
40913>>>>>        Property String private.psDriverDefaultValueDateTime ""
40914>>>>>        Property String private.psDriverDefaultValueNumeric  ""
40915>>>>>        Property String private.psDriverDefaultValueText     ""
40916>>>>>
40916>>>>>        // Driver "nullability" settings:
40916>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
40917>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
40918>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
40919>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
40920>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
40921>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
40922>>>>>
40922>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
40922>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
40922>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
40922>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
40922>>>>>        // We reset it here for each cDbUpdateVersion object
40922>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
40924>>>>>    End_Procedure
40925>>>>>
40925>>>>>    // *** Main hook event message ***
40925>>>>>    // Place your database update logic here!
40925>>>>>    Procedure OnUpdate
40927>>>>>    End_Procedure
40928>>>>>
40928>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
40928>>>>>    // imported to the cDbUpdateHandler container class which should be a
40928>>>>>    // parent object to this object. To have the Studio's Property Panel
40928>>>>>    // "behave" aka show these properties we need to duplicate them in this
40928>>>>>    // class and "relay" them to the parent object.
40928>>>>>    Procedure Set pbToANSI Boolean bState
40930>>>>>        Set private.pbToANSI  to bState
40931>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40932>>>>>        Delegate Set pbToANSI to bState
40934>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40935>>>>>    End_Procedure
40936>>>>>
40936>>>>>    Function pbToANSI Returns Boolean
40938>>>>>        Function_Return (private.pbToAnsi(Self))
40939>>>>>    End_Function
40940>>>>>
40940>>>>>    Procedure Set pbRecnum Boolean bState
40942>>>>>        Set private.pbRecnum  to bState
40943>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40944>>>>>        Delegate Set pbRecnum to bState
40946>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40947>>>>>    End_Procedure
40948>>>>>
40948>>>>>    Function pbRecnum Returns Boolean
40950>>>>>        Function_Return (private.pbRecnum(Self))
40951>>>>>    End_Function
40952>>>>>
40952>>>>>    Procedure Set pbCopyData Boolean bState
40954>>>>>        Set private.pbCopyData  to bState
40955>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40956>>>>>        Delegate Set pbCopyData to bState
40958>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40959>>>>>    End_Procedure
40960>>>>>
40960>>>>>    Function pbCopyData Returns Boolean
40962>>>>>        Function_Return (private.pbCopyData(Self))
40963>>>>>    End_Function
40964>>>>>
40964>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
40964>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
40966>>>>>        Set private.pbApiTableUpdateAuto  to bState
40967>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40968>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40969>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40970>>>>>    End_Procedure
40971>>>>>
40971>>>>>    Function pbApiTableUpdateAuto Returns Boolean
40973>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
40974>>>>>    End_Function
40975>>>>>
40975>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
40977>>>>>        Set private.pbCompareDate_DateTime  to bState
40978>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40979>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40980>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40981>>>>>    End_Procedure
40982>>>>>
40982>>>>>    Function pbCompareDate_DateTime Returns Boolean
40984>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
40985>>>>>    End_Function
40986>>>>>
40986>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
40988>>>>>        Set private.pbCompareIndexAscending  to bState
40989>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40990>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40991>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40992>>>>>    End_Procedure
40993>>>>>
40993>>>>>    Function pbCompareIndexAscending Returns Boolean
40995>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
40996>>>>>    End_Function
40997>>>>>
40997>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
40999>>>>>        Set private.pbCompareIndexUppercase  to bState
41000>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41001>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
41002>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41003>>>>>    End_Procedure
41004>>>>>
41004>>>>>    Function pbCompareIndexUppercase Returns Boolean
41006>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
41007>>>>>    End_Function
41008>>>>>
41008>>>>>    Procedure Set psSchema String sValue
41010>>>>>        Set private.psSchema  to sValue
41011>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41012>>>>>        Delegate Set psSchema to sValue
41014>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41015>>>>>    End_Procedure
41016>>>>>
41016>>>>>    // First retrieve the private value that might have been set in the object.
41016>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
41016>>>>>    // it might have been specified in the SQLConnections.ini file.
41016>>>>>    Function psSchema Returns String
41018>>>>>        String sValue
41018>>>>>        Get private.psSchema to sValue
41019>>>>>        If (sValue = "") Begin
41021>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
41022>>>>>        End
41022>>>>>>
41022>>>>>        Function_Return sValue
41023>>>>>    End_Function
41024>>>>>
41024>>>>>    Procedure Set psBaseTableSpace String sValue
41026>>>>>        Set private.psBaseTableSpace  to sValue
41027>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41028>>>>>        Delegate Set psBaseTableSpace to sValue
41030>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41031>>>>>    End_Procedure
41032>>>>>
41032>>>>>    // First retrieve the private value that might have been set in the object.
41032>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
41032>>>>>    // it might have been specified in the SQLConnections.ini file.
41032>>>>>    Function psBaseTableSpace Returns String
41034>>>>>        String sValue
41034>>>>>        Get private.psBaseTableSpace to sValue
41035>>>>>        If (sValue = "") Begin
41037>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
41038>>>>>        End
41038>>>>>>
41038>>>>>        Function_Return sValue
41039>>>>>    End_Function
41040>>>>>
41040>>>>>    Procedure Set psLongTableSpace String sValue
41042>>>>>        Set private.psLongTableSpace  to sValue
41043>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41044>>>>>        Delegate Set psLongTableSpace to sValue
41046>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41047>>>>>    End_Procedure
41048>>>>>
41048>>>>>    // First retrieve the private value that might have been set in the object.
41048>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
41048>>>>>    // it might have been specified in the SQLConnections.ini file.
41048>>>>>    Function psLongTableSpace Returns String
41050>>>>>        String sValue
41050>>>>>        Get private.psLongTableSpace to sValue
41051>>>>>        If (sValue = "") Begin
41053>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
41054>>>>>        End
41054>>>>>>
41054>>>>>        Function_Return sValue
41055>>>>>    End_Function
41056>>>>>
41056>>>>>    Procedure Set psIndexTableSpace String sValue
41058>>>>>        Set private.psIndexTableSpace  to sValue
41059>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41060>>>>>        Delegate Set psIndexTableSpace to sValue
41062>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41063>>>>>    End_Procedure
41064>>>>>
41064>>>>>    // First retrieve the private value that might have been set in the object.
41064>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
41064>>>>>    // it might have been specified in the SQLConnections.ini file.
41064>>>>>    Function psIndexTableSpace Returns String
41066>>>>>        String sValue
41066>>>>>        Get private.psIndexTableSpace to sValue
41067>>>>>        If (sValue = "") Begin
41069>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
41070>>>>>        End
41070>>>>>>
41070>>>>>        Function_Return sValue
41071>>>>>    End_Function
41072>>>>>
41072>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
41074>>>>>        Set private.psDriverDefaultValueASCII  to sValue
41075>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41076>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
41078>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41079>>>>>    End_Procedure
41080>>>>>
41080>>>>>    // First retrieve the private value that might have been set in the object.
41080>>>>>    // If blank; get it from the parent object
41080>>>>>    Function psDriverDefaultValueASCII Returns String
41082>>>>>        String sValue
41082>>>>>        Get private.psDriverDefaultValueASCII to sValue
41083>>>>>        If (sValue = "") Begin
41085>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
41087>>>>>        End
41087>>>>>>
41087>>>>>        Function_Return sValue
41088>>>>>    End_Function
41089>>>>>
41089>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
41091>>>>>        Set private.psDriverDefaultValueBinary  to sValue
41092>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41093>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
41095>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41096>>>>>    End_Procedure
41097>>>>>
41097>>>>>    // First retrieve the private value that might have been set in the object.
41097>>>>>    // If blank; get it from the parent object
41097>>>>>    Function psDriverDefaultValueBinary Returns String
41099>>>>>        String sValue
41099>>>>>        Get private.psDriverDefaultValueBinary to sValue
41100>>>>>        If (sValue = "") Begin
41102>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
41104>>>>>        End
41104>>>>>>
41104>>>>>        Function_Return sValue
41105>>>>>    End_Function
41106>>>>>
41106>>>>>    Procedure Set psDriverDefaultValueDate String sValue
41108>>>>>        Set private.psDriverDefaultValueDate  to sValue
41109>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41110>>>>>        Delegate Set psDriverDefaultValueDate to sValue
41112>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41113>>>>>    End_Procedure
41114>>>>>
41114>>>>>    // First retrieve the private value that might have been set in the object.
41114>>>>>    // If blank; get it from the parent object
41114>>>>>    Function psDriverDefaultValueDate Returns String
41116>>>>>        String sValue
41116>>>>>        Get private.psDriverDefaultValueDate to sValue
41117>>>>>        If (sValue = "") Begin
41119>>>>>            Delegate Get psDriverDefaultValueDate to sValue
41121>>>>>        End
41121>>>>>>
41121>>>>>        Function_Return sValue
41122>>>>>    End_Function
41123>>>>>
41123>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
41125>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
41126>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41127>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
41129>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41130>>>>>    End_Procedure
41131>>>>>
41131>>>>>    // First retrieve the private value that might have been set in the object.
41131>>>>>    // If blank; get it from the parent object
41131>>>>>    Function psDriverDefaultValueDateTime Returns String
41133>>>>>        String sValue
41133>>>>>        Get private.psDriverDefaultValueDateTime to sValue
41134>>>>>        If (sValue = "") Begin
41136>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
41138>>>>>        End
41138>>>>>>
41138>>>>>        Function_Return sValue
41139>>>>>    End_Function
41140>>>>>
41140>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
41142>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
41143>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41144>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
41146>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41147>>>>>    End_Procedure
41148>>>>>
41148>>>>>    // First retrieve the private value that might have been set in the object.
41148>>>>>    // If blank; get it from the parent object
41148>>>>>    Function psDriverDefaultValueNumeric Returns String
41150>>>>>        String sValue
41150>>>>>        Get private.psDriverDefaultValueNumeric to sValue
41151>>>>>        If (sValue = "") Begin
41153>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
41155>>>>>        End
41155>>>>>>
41155>>>>>        Function_Return sValue
41156>>>>>    End_Function
41157>>>>>
41157>>>>>    Procedure Set psDriverDefaultValueText String sValue
41159>>>>>        Set private.psDriverDefaultValueText  to sValue
41160>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41161>>>>>        Delegate Set psDriverDefaultValueText to sValue
41163>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41164>>>>>    End_Procedure
41165>>>>>
41165>>>>>    // First retrieve the private value that might have been set in the object.
41165>>>>>    // If blank; get it from the parent object
41165>>>>>    Function psDriverDefaultValueText Returns String
41167>>>>>        String sValue
41167>>>>>        Get private.psDriverDefaultValueText to sValue
41168>>>>>        If (sValue = "") Begin
41170>>>>>            Delegate Get psDriverDefaultValueText to sValue
41172>>>>>        End
41172>>>>>>
41172>>>>>        Function_Return sValue
41173>>>>>    End_Function
41174>>>>>
41174>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
41176>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
41177>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41178>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
41180>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41181>>>>>    End_Procedure
41182>>>>>
41182>>>>>    // First retrieve the private value that might have been set in the object.
41182>>>>>    // If blank; get it from the parent object
41182>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
41184>>>>>        Boolean bState
41184>>>>>        Get private.pbDriverDefaultNullableASCII to bState
41185>>>>>        If (bState = False) Begin
41187>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
41189>>>>>        End
41189>>>>>>
41189>>>>>        Function_Return bState
41190>>>>>    End_Function
41191>>>>>
41191>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
41193>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
41194>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41195>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
41197>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41198>>>>>    End_Procedure
41199>>>>>
41199>>>>>    // First retrieve the private value that might have been set in the object.
41199>>>>>    // If blank; get it from the parent object
41199>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
41201>>>>>        Boolean bState
41201>>>>>        Get private.pbDriverDefaultNullableBinary to bState
41202>>>>>        If (bState = False) Begin
41204>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
41206>>>>>        End
41206>>>>>>
41206>>>>>        Function_Return bState
41207>>>>>    End_Function
41208>>>>>
41208>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
41210>>>>>        Set private.pbDriverDefaultNullableDate  to bState
41211>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41212>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
41214>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41215>>>>>    End_Procedure
41216>>>>>
41216>>>>>    // First retrieve the private value that might have been set in the object.
41216>>>>>    // If blank; get it from the parent object
41216>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
41218>>>>>        Boolean bState
41218>>>>>        Get private.pbDriverDefaultNullableDate to bState
41219>>>>>        If (bState = False) Begin
41221>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
41223>>>>>        End
41223>>>>>>
41223>>>>>        Function_Return bState
41224>>>>>    End_Function
41225>>>>>
41225>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
41227>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
41228>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41229>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
41231>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41232>>>>>    End_Procedure
41233>>>>>
41233>>>>>    // First retrieve the private value that might have been set in the object.
41233>>>>>    // If blank; get it from the parent object
41233>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
41235>>>>>        Boolean bState
41235>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
41236>>>>>        If (bState = False) Begin
41238>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
41240>>>>>        End
41240>>>>>>
41240>>>>>        Function_Return bState
41241>>>>>    End_Function
41242>>>>>
41242>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
41244>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
41245>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41246>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
41248>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41249>>>>>    End_Procedure
41250>>>>>
41250>>>>>    // First retrieve the private value that might have been set in the object.
41250>>>>>    // If blank; get it from the parent object
41250>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
41252>>>>>        Boolean bState
41252>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
41253>>>>>        If (bState = False) Begin
41255>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
41257>>>>>        End
41257>>>>>>
41257>>>>>        Function_Return bState
41258>>>>>    End_Function
41259>>>>>
41259>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
41261>>>>>        Set private.pbDriverDefaultNullableText  to bState
41262>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41263>>>>>        Delegate Set pbDriverDefaultNullableText to bState
41265>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41266>>>>>    End_Procedure
41267>>>>>
41267>>>>>    // First retrieve the private value that might have been set in the object.
41267>>>>>    // If blank; get it from the parent object
41267>>>>>    Function pbDriverDefaultNullableText Returns Boolean
41269>>>>>        Boolean bState
41269>>>>>        Get private.pbDriverDefaultNullableText to bState
41270>>>>>        If (bState = False) Begin
41272>>>>>            Delegate Get pbDriverDefaultNullableText to bState
41274>>>>>        End
41274>>>>>>
41274>>>>>        Function_Return bState
41275>>>>>    End_Function
41276>>>>>
41276>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
41278>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
41278>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
41278>>>>>
41278>>>>>        Get psDriverID to sDriverID
41279>>>>>        Get psSchema to sSchema
41280>>>>>
41280>>>>>        Get psBaseTableSpace to sBaseTableSpace
41281>>>>>        If (sBaseTableSpace <> "") Begin
41283>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41284>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
41286>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41287>>>>>        End
41287>>>>>>
41287>>>>>
41287>>>>>        Get psLongTableSpace to sLongTableSpace
41288>>>>>        If (sLongTableSpace <> "") Begin
41290>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41291>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
41293>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41294>>>>>        End
41294>>>>>>
41294>>>>>
41294>>>>>        Get psIndexTableSpace to sIndexTableSpace
41295>>>>>        If (sIndexTableSpace <> "") Begin
41297>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41298>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
41300>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41301>>>>>        End
41301>>>>>>
41301>>>>>
41301>>>>>        Get pbUseConnectionID to bUseConnectionID
41302>>>>>        Get pbToANSI          to bToANSI
41303>>>>>        Get pbRecnum          to bRecnum
41304>>>>>        Get pbCopyData        to bCopyData
41305>>>>>
41305>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
41306>>>>>
41306>>>>>        Function_Return bOK
41307>>>>>    End_Function
41308>>>>>
41308>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
41308>>>>>//        Boolean bOK bExists
41308>>>>>//        String sDataPath sBackupFolder
41308>>>>>//        
41308>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
41308>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
41308>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
41308>>>>>//        Get vFolderFormat sDataPath to sDataPath
41308>>>>>//        
41308>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
41308>>>>>//        If (bExists = False) Begin
41308>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
41308>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
41308>>>>>//            If (bExists = False) Begin
41308>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
41308>>>>>//                Function_Return False
41308>>>>>//            End                                                                                                                                            
41308>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
41308>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
41308>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
41308>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
41308>>>>>//        End
41308>>>>>//        
41308>>>>>//        Set Message_Text of ghoStatusPanel to ""
41308>>>>>//        Function_Return bOK
41308>>>>>//    End_Function
41308>>>>>//
41308>>>>>    // This is automatically called after the OnUpdate
41308>>>>>    // event has been executed. It will automatically update the
41308>>>>>    // version database field/column with the "pnVersionNumber"
41308>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
41308>>>>>    Procedure UpdateVersionColumnValue
41310>>>>>        Number nVersion nCurrentValue
41310>>>>>        Integer hTable iColumn
41310>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
41310>>>>>
41310>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
41310>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
41310>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
41312>>>>>        Get pbVersionUpdate to bVersionUpdate
41313>>>>>
41313>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
41315>>>>>            Get pnVersionNumber to nVersion
41316>>>>>            Delegate Get piDbVersionFileNumber  to hTable
41318>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
41320>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
41320>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
41320>>>>>            Close DF_ALL DF_PERMANENT
41321>>>>>
41321>>>>>            Open hTable
41323>>>>>
41323>>>>>            // It is then the developer responsibility to take care of finding
41323>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
41323>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
41325>>>>>            If (bUseCustomDbVersion = True) Begin
41327>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
41329>>>>>            End
41329>>>>>>
41329>>>>>
41329>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
41332>>>>>            If (nCurrentValue < nVersion) Begin
41334>>>>>                Lock
41335>>>>>>
41335>>>>>                    If (bUseCustomDbVersion = False) Begin
41337>>>>>                        Vfind hTable Recnum GE                            
41339>>>>>                    End
41339>>>>>>
41339>>>>>                    Set_Field_Value hTable iColumn to nVersion
41342>>>>>                    SaveRecord hTable
41343>>>>>                Unlock
41344>>>>>>
41344>>>>>            End
41344>>>>>>
41344>>>>>            Close hTable
41345>>>>>        End
41345>>>>>>
41345>>>>>    End_Procedure
41346>>>>>
41346>>>>>// Property of the container object (cDbUpdateHandler)
41346>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
41346>>>>>
41346>>>>>    Procedure End_Construct_Object
41348>>>>>        Forward Send End_Construct_Object
41350>>>>>        Send ProcessUpdate True
41351>>>>>    End_Procedure
41352>>>>>    
41352>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
41354>>>>>        Number nVersion nCurrentValue
41354>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
41354>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
41354>>>>>        String sObjectName
41354>>>>>        tDbVersionInfo[] dbVersionInfoArray
41354>>>>>        tDbVersionInfo[] dbVersionInfoArray
41355>>>>>
41355>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
41357>>>>>
41357>>>>>        // If the programmer forgot to set the version number we do not allow for the application
41357>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
41357>>>>>        // one database update is depended on an earlier update and that earlier version
41357>>>>>        // update was never executed it could lead to disastrous results.
41357>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
41357>>>>>        Get pnVersionNumber to nVersion
41358>>>>>        If (nVersion = 0) Begin
41360>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
41361>>>>>            Move (Name(Self)) to sObjectName
41362>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
41363>>>>>>
41363>>>>>            Send Exit_Application
41364>>>>>        End
41364>>>>>>
41364>>>>>
41364>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
41364>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
41364>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
41366>>>>>        If (bOnPreUpdateExecuted = False) Begin
41368>>>>>            Delegate Send OnPreUpdate
41370>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
41372>>>>>        End
41372>>>>>>
41372>>>>>        
41372>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
41374>>>>>        
41374>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
41376>>>>>        If (bUseCustomDbVersion = False) Begin
41378>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
41378>>>>>        End
41378>>>>>>
41378>>>>>        Else Begin
41379>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
41380>>>>>            If (bTableExists = False) Begin
41382>>>>>                Delegate Send OnCreateCustomDbVersionTable
41384>>>>>            End
41384>>>>>>
41384>>>>>        End
41384>>>>>>
41384>>>>>        
41384>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
41384>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
41384>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
41386>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
41388>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
41389>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
41390>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
41391>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
41393>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
41395>>>>>        End
41395>>>>>>
41395>>>>>
41395>>>>>        Delegate Get piDbVersionFileNumber  to hTable
41397>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
41399>>>>>
41399>>>>>        Open hTable
41401>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
41404>>>>>        If (bOpened = False) Begin
41406>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
41407>>>>>            Send Exit_Application
41408>>>>>        End
41408>>>>>>
41408>>>>>        
41408>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
41408>>>>>        // in case we take care of it here.
41408>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
41411>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
41413>>>>>            Vfind hTable 0 GT
41415>>>>>        End
41415>>>>>>
41415>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
41418>>>>>        If (bSystemTable = True) Begin
41420>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
41423>>>>>        End
41423>>>>>>
41423>>>>>        Else Begin
41424>>>>>            If (bUseCustomDbVersion = True) Begin
41426>>>>>                Send OnFindVersionRecord
41427>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
41430>>>>>            End
41430>>>>>>
41430>>>>>        End
41430>>>>>>
41430>>>>>
41430>>>>>        Close hTable
41431>>>>>
41431>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
41431>>>>>        // If not set we do nothing.
41431>>>>>        If (nCurrentValue < nVersion) Begin
41433>>>>>
41433>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
41433>>>>>            // execution of database update code. So if true _and_ one error
41433>>>>>            // has already occured; we're out of here.
41433>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
41435>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
41437>>>>>            If (bStopOnFirstError = True) Begin
41439>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
41441>>>>>                    Procedure_Return
41442>>>>>                End
41442>>>>>>
41442>>>>>            End
41442>>>>>>
41442>>>>>
41442>>>>>            // This is send to the parent container object (cDbUpdateHandler)
41442>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
41444>>>>>
41444>>>>>            // If the parent property pbContinueOnError = False, an update
41444>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
41444>>>>>            Delegate Get pbContinueOnError to bContinueOnError
41446>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
41448>>>>>                Procedure_Return
41449>>>>>            End
41449>>>>>>
41449>>>>>
41449>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
41451>>>>>
41451>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
41452>>>>>
41452>>>>>            // *** Programmer's main hook event for database update functions:
41452>>>>>            Send OnUpdate
41453>>>>>
41453>>>>>            Set pbVersionUpdate to True
41454>>>>>            Send UpdateVersionColumnValue
41455>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
41457>>>>>        End
41457>>>>>>
41457>>>>>
41457>>>>>    End_Procedure
41458>>>>>
41458>>>>>End_Class
41459>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
41459>>>>>//****************************************************************************
41459>>>>>// $Module type: Class
41459>>>>>// $Module name: cDbUpdateUserCount.pkg
41459>>>>>// $Author     : Emil Stojanov Quantaris B.V.
41459>>>>>//
41459>>>>>//               Collected from DAW's newsgroups.
41459>>>>>//
41459>>>>>// Description : It uses the windows API to lock bytes in a file.
41459>>>>>//               If the application or PC craches it will release the lock
41459>>>>>//               automatically.
41459>>>>>//
41459>>>>>// Note 1      : It will count the number of running app's, so if a
41459>>>>>//               user starts the app twice on one machine it will count as two users.
41459>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
41459>>>>>//               However, to not conflict with any other usage of this class it was
41459>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
41459>>>>>//               and cDbUpdateVersion classes)
41459>>>>>//
41459>>>>>// $Rev History:
41459>>>>>//    2008-10-17  Module header created (Militaty data format)
41459>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
41459>>>>>//                for easy translation to other languages.
41459>>>>>//                Added the tUserCount struct for easier passing of parameters.
41459>>>>>//                Added the ApplicationPath message.
41459>>>>>//****************************************************************************
41459>>>>>Use LanguageText.pkg
41459>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
41459>>>>>>>Use GlobalFunctionsProcedures.pkg
41459>>>>>>>// Sample:
41459>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
41459>>>>>>>
41459>>>>>>>
41459>>>>>>>// Symbols used by UserCounting
41459>>>>>>>    Define GENERIC_READ         for |CI$80000000
41459>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
41459>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
41459>>>>>>>    Define GENERIC_ALL          for |CI$10000000
41459>>>>>>>    Define CREATE_NEW           for 1
41459>>>>>>>    Define CREATE_ALWAYS        for 2
41459>>>>>>>    Define OPEN_EXISTING        for 3
41459>>>>>>>    Define OPEN_ALWAYS          for 4
41459>>>>>>>    Define TRUNCATE_EXISTING    for 5
41459>>>>>>>    Define FILE_BEGIN           for 0
41459>>>>>>>    Define FILE_CURRENT         for 1
41459>>>>>>>    Define FILE_END             for 2
41459>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
41459>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
41459>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
41459>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
41459>>>>>>>    Define _MAX_PATH  for 260
41459>>>>>>>    Define _MAX_DRIVE for 3
41459>>>>>>>    Define _MAX_DIR   for 256
41459>>>>>>>    Define _MAX_FNAME for 256
41459>>>>>>>    Define _MAX_EXT   for 256
41459>>>>>>>
41459>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
41460>>>>>>>
41460>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
41461>>>>>>>
41461>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
41462>>>>>>>
41462>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
41463>>>>>>>
41463>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
41464>>>>>>>
41464>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
41465>>>>>>>
41465>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
41466>>>>>>>
41466>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
41467>>>>>>>// Sample:
41467>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
41467>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
41469>>>>>>>    Boolean bReturn
41469>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
41470>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
41471>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
41472>>>>>>>    Function_Return bReturn
41473>>>>>>>End_Function
41474>>>>>Use vWin32fh.pkg
41474>>>>>Use seq_chnl.pkg
41474>>>>>
41474>>>>>// User interface constant strings:
41474>>>>>    Define CS_UserCountError            for "User count error:"
41474>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
41474>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
41474>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
41474>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>
41474>>>>>    Struct tUserCount
41474>>>>>        Integer iUserCount
41474>>>>>        Integer iError
41474>>>>>        String  sErrorTxt
41474>>>>>    End_Struct
41474>>>>>
41474>>>>>    Define CI_UserCountMaxUsers for 9999
41474>>>>>
41474>>>>>Class cDbUpdateUserCount is a cObject
41475>>>>>    Procedure Construct_Object
41477>>>>>        Forward Send Construct_Object
41479>>>>>
41479>>>>>        Property String  psLockFileName
41480>>>>>        Property Integer piMaxUsers
41481>>>>>        Property Boolean pbCheckDataFlexUserCount True
41482>>>>>
41482>>>>>        Property Handle  phUserCountFile
41483>>>>>        Property Integer pdwLockPosition
41484>>>>>    End_Procedure
41485>>>>>
41485>>>>>    Function IsProgramRunning Returns Boolean
41487>>>>>        tUserCount UserCount
41487>>>>>        tUserCount UserCount
41487>>>>>
41487>>>>>        Get CheckUserCount to UserCount
41488>>>>>
41488>>>>>        Function_Return (UserCount.iUserCount > 1)
41489>>>>>    End_Function
41490>>>>>
41490>>>>>    // Returns the full path of the Application (no trailing "\")
41490>>>>>    Function ApplicationPath Returns String
41492>>>>>        String sApplicationFileName sPath
41492>>>>>        Integer iNumChars iRetval
41492>>>>>
41492>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
41493>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
41494>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
41495>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
41496>>>>>        Move (CString(sApplicationFileName)) to sPath
41497>>>>>
41497>>>>>        Function_Return sPath
41498>>>>>    End_Function
41499>>>>>
41499>>>>>    Function OpenUserCountFile String sFileName Returns Handle
41501>>>>>        Handle  hFile
41501>>>>>        Pointer pFileName
41501>>>>>        String sPath sFile
41501>>>>>        Integer iCh
41501>>>>>
41501>>>>>        Move (Addressof(sFileName)) to pFileName
41502>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
41503>>>>>
41503>>>>>        // If lock file doesn't exist, create it.
41503>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
41505>>>>>            Get ApplicationPath to sPath
41506>>>>>            Get vFolderFormat sPath to sPath
41507>>>>>            Move (sPath + psLockFileName(Self)) to sFile
41508>>>>>            Get Seq_Open_Output_Channel sFile to iCh
41509>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
41511>>>>>                Function_Return 0
41512>>>>>            End
41512>>>>>>
41512>>>>>            Direct_Output channel iCh sFile
41514>>>>>                Write channel iCh ""
41516>>>>>            Send Seq_Close_Channel iCh
41517>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
41518>>>>>        End
41518>>>>>>
41518>>>>>
41518>>>>>        Function_Return hFile
41519>>>>>    End_Function
41520>>>>>
41520>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
41522>>>>>        Integer iReturnValue 
41522>>>>>        Boolean bOK
41522>>>>>
41522>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
41523>>>>>        If (iReturnValue = 0) Begin
41525>>>>>            Move False to bOK
41526>>>>>        End
41526>>>>>>
41526>>>>>        Else Begin
41527>>>>>            Move True to bOK
41528>>>>>        End
41528>>>>>>
41528>>>>>        Function_Return bOK
41529>>>>>    End_Function
41530>>>>>
41530>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
41532>>>>>        Integer iReturnValue
41532>>>>>        Boolean bOK
41532>>>>>
41532>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
41533>>>>>        If (iReturnValue = 0) Begin
41535>>>>>            Move False to bOK
41536>>>>>        End
41536>>>>>>
41536>>>>>        Else Begin
41537>>>>>            Move True to bOK
41538>>>>>        End           
41538>>>>>>
41538>>>>>        Function_Return bOK
41539>>>>>    End_Function
41540>>>>>
41540>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
41542>>>>>        dWord dwCurrPos
41542>>>>>
41542>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
41543>>>>>        Function_Return dwCurrPos
41544>>>>>    End_Function
41545>>>>>
41545>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
41547>>>>>        DWord dwCurrPos
41547>>>>>
41547>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
41548>>>>>        Function_Return dwCurrPos
41549>>>>>    End_Function
41550>>>>>
41550>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
41552>>>>>        Integer iReturnValue                               
41552>>>>>        Boolean bOK
41552>>>>>        String  sBuffer
41552>>>>>        Pointer pBuffer
41552>>>>>        String  sSize
41552>>>>>        Pointer pSize
41552>>>>>
41552>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
41553>>>>>        Move (AddressOf(sBuffer)) to pBuffer
41554>>>>>
41554>>>>>        Move (Repeat((Character(0)),4)) to sSize
41555>>>>>        Move (AddressOf(sSize)) to pSize
41556>>>>>
41556>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
41557>>>>>        If (iReturnValue = 0) Begin
41559>>>>>            Move False to bOK
41560>>>>>        End
41560>>>>>>
41560>>>>>        Else Begin
41561>>>>>            Move True to bOK
41562>>>>>        End                 
41562>>>>>>
41562>>>>>        Function_Return bOK
41563>>>>>    End_Function
41564>>>>>
41564>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
41566>>>>>        Integer iReturnValue
41566>>>>>
41566>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
41567>>>>>        Function_Return iReturnValue
41568>>>>>    End_Function
41569>>>>>
41569>>>>>    Procedure DoCheckUserCount
41571>>>>>        tUserCount UserCount
41571>>>>>        tUserCount UserCount
41571>>>>>
41571>>>>>        Get CheckUserCount to UserCount
41572>>>>>        // If all is fine, we're done.
41572>>>>>        If (UserCount.iError = 0) Begin
41574>>>>>            Procedure_Return
41575>>>>>        End
41575>>>>>>
41575>>>>>
41575>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
41576>>>>>
41576>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
41578>>>>>            Abort
41579>>>>>>
41579>>>>>        End
41579>>>>>>
41579>>>>>    End_Procedure
41580>>>>>
41580>>>>>    Function CheckUserCount Returns tUserCount
41582>>>>>        Handle  hFile
41582>>>>>        String  sPath sFile
41582>>>>>        Integer iResult
41582>>>>>        DWord   dwFilePos
41582>>>>>        Integer bLocked
41582>>>>>        Integer iMaxUsers
41582>>>>>        Integer iCurUser
41582>>>>>        tUserCount UserCount
41582>>>>>        tUserCount UserCount
41582>>>>>
41582>>>>>        Move 0 to UserCount.iError
41583>>>>>
41583>>>>>        Get phUserCountFile to hFile
41584>>>>>        If (not(hFile)) Begin
41586>>>>>            Get ApplicationPath to sPath
41587>>>>>            Get vFolderFormat sPath to sPath
41588>>>>>            Move (sPath + psLockFileName(Self)) to sFile
41589>>>>>            Get OpenUserCountFile sFile to hFile
41590>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
41592>>>>>                Move 1 to UserCount.iUserCount
41593>>>>>                Move 1 to UserCount.iError
41594>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
41595>>>>>                Function_Return UserCount
41596>>>>>            End
41596>>>>>>
41596>>>>>            Else Begin
41597>>>>>                Move False to bLocked
41598>>>>>                Set phUserCountFile to hFile
41599>>>>>                Get piMaxUsers to iMaxUsers
41600>>>>>
41600>>>>>                // Set Filepointer to beginning of the file
41600>>>>>                Get ResetUserCountPointer hFile to dwFilePos
41601>>>>>                If (dwFilePos = -1) Begin
41603>>>>>                    Move 1 to UserCount.iUserCount
41604>>>>>                    Move 2 to UserCount.iError
41605>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
41606>>>>>                    Function_Return UserCount
41607>>>>>                End
41607>>>>>>
41607>>>>>                For iCurUser from 1 to iMaxUsers
41613>>>>>>
41613>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
41614>>>>>                    If (not(iResult)) Begin  // byte is locked
41616>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
41617>>>>>                        If (dwFilePos = -1) Begin
41619>>>>>                            Move 1 to UserCount.iUserCount
41620>>>>>                            Move 3 to UserCount.iError
41621>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
41622>>>>>                            Function_Return UserCount
41623>>>>>                        End
41623>>>>>>
41623>>>>>                    End
41623>>>>>>
41623>>>>>                    Else Begin  // byte is not locked
41624>>>>>                        Set pdwLockPosition to dwFilePos
41625>>>>>                        Move True to bLocked
41626>>>>>                        Move iMaxUsers to iCurUser
41627>>>>>                    End
41627>>>>>>
41627>>>>>                Loop
41628>>>>>>
41628>>>>>                If (not(bLocked)) Begin
41630>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
41631>>>>>                    Move 4 to UserCount.iError
41632>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
41633>>>>>                    Function_Return UserCount
41634>>>>>                End
41634>>>>>>
41634>>>>>            End
41634>>>>>>
41634>>>>>        End
41634>>>>>>
41634>>>>>
41634>>>>>        Function_Return UserCount
41635>>>>>    End_Function
41636>>>>>
41636>>>>>
41636>>>>>    Procedure DoReleaseUserCount
41638>>>>>        Integer iResult
41638>>>>>        Handle  hFile
41638>>>>>        DWord   dwLockPos
41638>>>>>
41638>>>>>        Get phUserCountFile to hFile
41639>>>>>        Get pdwLockPosition to dwLockPos
41640>>>>>        If (hFile) Begin
41642>>>>>            If (dwLockPos) Begin
41644>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
41645>>>>>            End
41645>>>>>>
41645>>>>>            Get CloseUserCountFile hFile to iResult
41646>>>>>        End
41646>>>>>>
41646>>>>>    End_Procedure
41647>>>>>
41647>>>>>    Function CurrentNumberOfUsers Returns Integer
41649>>>>>        Handle  hFile
41649>>>>>        Integer iMaxUsers
41649>>>>>        DWord   dwFilePos
41649>>>>>        Integer iCurUser
41649>>>>>        Integer iResult
41649>>>>>        Integer iNumberOfLocks
41649>>>>>        String  sPath sFile
41649>>>>>
41649>>>>>        Move 0 to iNumberOfLocks
41650>>>>>
41650>>>>>        Get ApplicationPath to sPath
41651>>>>>        Get vFolderFormat sPath to sPath
41652>>>>>        Move (sPath + psLockFileName(Self)) to sFile
41653>>>>>        Get OpenUserCountFile sFile to hFile
41654>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
41656>>>>>            Send UserError CS_UnableToInitUserCountSys
41657>>>>>            Abort
41658>>>>>>
41658>>>>>        End
41658>>>>>>
41658>>>>>
41658>>>>>        If (hFile > 0) Begin
41660>>>>>            Get piMaxUsers To iMaxUsers
41661>>>>>
41661>>>>>            // Set Filepointer to beginning of the file
41661>>>>>            Get ResetUserCountPointer hFile to dwFilePos
41662>>>>>            If (dwFilePos = -1) Begin
41664>>>>>                Send UserError CS_UnableResetUserCountSys
41665>>>>>                Abort
41666>>>>>>
41666>>>>>            End
41666>>>>>>
41666>>>>>            For iCurUser from 1 to iMaxUsers
41672>>>>>>
41672>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
41673>>>>>                If (Not(iResult)) Begin  // byte is locked
41675>>>>>                    Increment iNumberOfLocks
41676>>>>>                End
41676>>>>>>
41676>>>>>                Else Begin  // byte is not locked
41677>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
41678>>>>>                End
41678>>>>>>
41678>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
41679>>>>>                If (dwFilePos = -1) Begin
41681>>>>>                    Send UserError CS_ErrorAdvancingPointer
41682>>>>>                    Abort
41683>>>>>>
41683>>>>>                End
41683>>>>>>
41683>>>>>            Loop
41684>>>>>>
41684>>>>>        End
41684>>>>>>
41684>>>>>        Get CloseUserCountFile hFile to iResult
41685>>>>>        Function_Return iNumberOfLocks
41686>>>>>    End_Function
41687>>>>>
41687>>>>>End_Class
41688>>>Use cDbUpdateFunctionLibrary.pkg
41688>>>
41688>>>//{ DataBindable=True }
41688>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
41688>>>Class cDbUpdateHandler is a cObject
41689>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
41690>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
41691>>>
41691>>>    Procedure Construct_Object
41693>>>        tUserCount UserCount
41693>>>        tUserCount UserCount
41693>>>        Integer iUserCount
41693>>>        Handle ho                     
41693>>>
41693>>>        Forward Send Construct_Object
41695>>>        Move Self to ghoDbUpdateHandler  
41696>>>        
41696>>>        // Latin1_General_CI_AS = General Insensitive collation
41696>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
41696>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
41696>>>        // Good read about which collation to select:
41696>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
41696>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
41697>>>
41697>>>        // Struct array that will contain pnVersionNumbers & object id's of
41697>>>        // all child cDbVersion objects.
41697>>>        Property tDbVersionInfo[] paDbVersionInfoArray
41698>>>
41698>>>        Property Integer Error_Processing_State False  // internal usage
41699>>>        
41699>>>        Property Boolean Private.pbDbVersionCheckDone False
41700>>>
41700>>>        Property Boolean pbUseCustomDbVersion False  
41701>>>        
41701>>>        // If this property = True _and_ no DbVersion table exists 
41701>>>        // when the framework is started, a DbVersion table will be created automatically.
41701>>>        Property Boolean pbAutoCreateDbVersionTable True
41702>>>
41702>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
41702>>>        // the Filelist.cfg slot number indicated by this property will be used
41702>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
41702>>>        // an Unhandled Exception Error will be genereted and the program halted. So
41702>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
41702>>>        // to a value that corresponds to a free Filelist.cfg slot number.
41702>>>        Property Integer Private.piDbVersionFileNumber -1
41703>>>        Property Integer Private.piDbVersionFieldNumber 1
41704>>>
41704>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
41704>>>        // that creates all library properties
41704>>>        Send CreateDbUpdateLibraryProperties
41705>>>
41705>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
41706>>>
41706>>>        // Error handling:
41706>>>        Property Boolean Private.pbOnCreateExecuted False
41707>>>        Property Boolean Private.pbOnPreUpdateExecuted False
41708>>>        Property Boolean Private.pbProcessingError False
41709>>>        Property Boolean pbDbUpdateErrorHasOccured False
41710>>>        // Don't touch. It is being used by the cDbUpdateVersion
41710>>>        // subclass to tell if that particular update went OK or not.
41710>>>        Property Boolean Private.pbUpdateVersionObjectError False
41711>>>        Property String[] paSQLQueryMessages
41712>>>
41712>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
41713>>>        Move Self to Error_Object_Id
41714>>>        // Error handling:
41714>>>        // Temporarily redirect all errors to this object so we can silently
41714>>>        // log all errors that might appear while updating the database.
41714>>>        // We temporarily redirect all errors to this object so we can
41714>>>        // log and write errors to the log file. It will be reset after
41714>>>        // the database updates have been finished.
41714>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
41715>>>
41715>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
41716>>>
41716>>>        // Error Reporting Related
41716>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
41716>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
41717>>>
41717>>>        // If the pbContinueOnError = False, an update
41717>>>        // of another cDbUpdateVersion object will _not_ be
41717>>>        // performed if an error occured in a previous
41717>>>        // cDbUpdateVersion object.
41717>>>        Property Boolean pbContinueOnError False
41718>>>        // Stops execution in other cDbUpdateVersion objecs,
41718>>>        // if errors occurred in one cDbUpdateVersion object.
41718>>>        Property Boolean pbStopOnFirstError False
41719>>>        // If True errors that occured while updating the database
41719>>>        // will be shown in the default app for .txt files when done.
41719>>>        // Note: The log file will _always_ be created in the Data folder.
41719>>>        Property Boolean pbShowErrorLogPostRun True
41720>>>
41720>>>        // Be _very_ careful to set this property to true!
41720>>>        // If = True, no question will be asked if the update
41720>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
41720>>>        // the error log won't be shown. The logfile itself will still be created though.
41720>>>        // You have to know what you're doing!
41720>>>        Property Boolean pbSilentMode False
41721>>>        
41721>>>        Property Boolean pbEnableCancelButton False
41722>>>
41722>>>        // Don't touch! Very private. The value is used by the error log to write for which
41722>>>        // cDbUpdateVersion object an error occured.
41722>>>        Property Number pnCurrentVersionUpdate 0
41723>>>
41723>>>        // The user counting logic is used to safe-guard agains anybody else is
41723>>>        // using the application when a database update is to be performed.
41723>>>        // (Garters & suspenders!)
41723>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
41724>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
41725>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
41726>>>
41726>>>        // This lock file is used to guard against somebody else tries to start the
41726>>>        // application while updates are in progress.
41726>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
41727>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
41728>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
41729>>>                                                                                      // Only the current user allowed.
41729>>>        // Properties for the table & column of a system file field/column where
41729>>>        // the database version update number gets saved.
41729>>>        Property Integer Private.Data_File  0
41730>>>        Property Integer Private.Data_Field 0
41731>>>
41731>>>        // Property that is used to indicate that we have already
41731>>>        // started the database update.
41731>>>        Property Boolean Private.pbDatabaseUpdateStarted False
41732>>>
41732>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
41732>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
41732>>>        // change of the database has been made.
41732>>>        Property Boolean Private.pbDatabaseWasUpdated False
41733>>>
41733>>>        // We need to trigger the user counting system so that a bit in the
41733>>>        // user counting file is locked. This is to guard that not more than one user
41733>>>        // is currently runnning the program.
41733>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
41734>>>
41734>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
41735>>>        If (iUserCount > 0) Begin
41737>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
41738>>>            Send Exit_Application
41739>>>        End
41739>>>>
41739>>>
41739>>>        Set pbHandleQueryErrors to False
41740>>>            
41740>>>        // This can't be right?    
41740>>>//        If (ghoDbUpdateFunctionLibrary = 0) Begin
41740>>>//            Move Self to ghoDbUpdateFunctionLibrary
41740>>>//        End
41740>>>
41740>>>        Property Handle phoSQLConnectionHandler 0
41741>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
41741>>>        // we will create one as it is used for all ConnectionID, ConnectionString
41741>>>        // etc information.
41741>>>        If (ghoSQLConnectionHandler = 0) Begin
41743>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
41744>>>            Set phoSQLConnectionHandler to ho
41745>>>        End             
41745>>>>
41745>>>        
41745>>>        Property Boolean pbCheckIntFiles False   
41746>>>        Property Handle  phIntFilesTable 2048
41747>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
41748>>>        
41748>>>        Set Icon to "Default.ico"
41749>>>    End_Procedure
41750>>>
41750>>>    Procedure End_Construct_Object
41752>>>        Boolean bCheckIntFiles
41752>>>        
41752>>>        Forward Send End_Construct_Object
41754>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
41756>>>            Send OnCreate
41757>>>            Set Private.pbOnCreateExecuted to True
41758>>>        End
41758>>>>
41758>>>        Send Cleanup
41759>>>    End_Procedure
41760>>>    
41760>>>    // Programmers hook event.
41760>>>    Procedure OnCreate
41762>>>    End_Procedure        
41763>>>                                 
41763>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
41763>>>    //                                                
41763>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
41763>>>    // cDbUpdateHandler object.
41763>>>    //
41763>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
41763>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
41763>>>    //
41763>>>    // If not done previously the phIntFilesTable will be created and filled with data
41763>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
41763>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
41763>>>    // of Filelist.cfg is made for backup purposes.
41763>>>    //
41763>>>    // Note: If an error occurrs the application will exit, as it means that at least one
41763>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
41763>>>    Procedure CheckIntFilesIntegrity
41765>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
41765>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
41765>>>        String sFileListZipFile sParam sProgram sFile 
41765>>>        Integer iDataPaths iCount
41765>>>        Handle hTable hIntFilesTable                    
41765>>>        UChar[] asFileListArray 
41766>>>        String[] asSavedIntFile
41767>>>        tDUFIntFile[] DUFIntFiles
41767>>>        tDUFIntFile[] DUFIntFiles
41768>>>        
41768>>>        Get pbCheckIntFiles to bCheckIntFiles
41769>>>        If (bCheckIntFiles = False) Begin
41771>>>            Procedure_Return
41772>>>        End
41772>>>>
41772>>>        
41772>>>        Move True to bResult        
41773>>>        
41773>>>        // Note: Include_Resource is a compiler directive!
41773>>>        // It will embedd the Filelist.cfg from the developers machine
41773>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
41773>>>        // need to change the next code line.         
41773>>>        //
41773>>>        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
41773>>>        // when we get here and then the compiler can't embedd it!        
41773>>>        // ToDo: Change compiler directives in Project properties (?)
41773>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
41773>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
41773>>>        
41773>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
41774>>>        Get vFilePathExists sFileListName to bExists 
41775>>>        If (bExists = True) Begin
41777>>>            Get ParseFolderName sFileListName to sDataPath    
41778>>>            Get vFolderFormat sDataPath to sDataPath                              
41779>>>            Get ParseFileName sFileListName to sFile
41780>>>            // We need to create a backup copy of Filelist.cfg.
41780>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
41781>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
41782>>>            If (bOK = False) Begin
41784>>>                Move False to bResult
41785>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
41786>>>>
41786>>>            End
41786>>>>
41786>>>        End
41786>>>>
41786>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
41786>>>        Else Begin
41787>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
41788>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
41788>>>            If (bOK = False) Begin   
41790>>>                Move False to bResult
41791>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
41792>>>>
41792>>>            End
41792>>>>
41792>>>        End
41792>>>>
41792>>>        
41792>>>        Get phIntFilesTable to hIntFilesTable
41793>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
41796>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
41797>>>        // This will automatically create the phIntFilesTable if not exists.
41797>>>        // It is used to save data from the current set of .int files.
41797>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
41799>>>            Send AutoCreateIntFilesTable
41800>>>            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
41801>>>            If (bIntFilesTablesCheckDone = False) Begin
41803>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
41804>>>                Send Exit_Application of ghoApplication
41805>>>            End
41805>>>>
41805>>>        End                                                       
41805>>>>
41805>>>        
41805>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
41805>>>        // ToDo: Or should this always be attempted? Else the 
41805>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
41806>>>        Move (IsDebuggerPresent()) to bDevelop
41807>>>        If (bDevelop = False) Begin
41809>>>            Get vFolderExists sDDSrcPath to bDevelop
41810>>>        End
41810>>>>
41810>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
41811>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
41812>>>        For iCount from 1 to iDataPaths
41818>>>>
41818>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
41819>>>            Get vFolderFormat sDataPath to sDataPath 
41820>>>            Get vFolderExists sDataPath to bExists
41821>>>            If (bExists = True) Begin                  
41823>>>                Move 0 to hTable
41824>>>                Repeat
41824>>>>
41824>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
41827>>>                    If (hTable <> 0) Begin
41829>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
41832>>>                        Get UtilTableIsSqlByRootName sIntFileName to bIsSQL
41833>>>                        If (bIsSQL = True) Begin     
41835>>>                            Get _TableNameOnly sIntFileName to sIntFileName
41836>>>                            Move (sIntFileName + ".int")    to sIntFileName
41837>>>                            Get IsIntFileSaved sIntFileName to bSaved  
41838>>>                            Move True to bOK            
41839>>>                            
41839>>>                            // Save .int file to database if not done previously.
41839>>>                            // We only attempt to read .int files on a development machine.
41839>>>                            If (bDevelop = True) Begin
41841>>>                                If (bSaved = False) Begin
41843>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
41844>>>                                    If (bOK = False) Begin
41846>>>                                        Move False to bResult    
41847>>>                                    End
41847>>>>
41847>>>                                End         
41847>>>>
41847>>>                                If (bOK = True) Begin
41849>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
41850>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
41852>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
41853>>>                                        If (bOK = False) Begin
41855>>>                                            Move False to bResult
41856>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
41857>>>>
41857>>>                                        End
41857>>>>
41857>>>                                    End
41857>>>>
41857>>>                                End
41857>>>>
41857>>>                            End
41857>>>>
41857>>>                            
41857>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
41858>>>                            If (bExists = False) Begin                           
41860>>>                                // If the .int file is missing on disk; create it from database.
41860>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
41861>>>                                If (bOK = False) Begin         
41863>>>                                    Move False to bResult
41864>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
41865>>>>
41865>>>                                End
41865>>>>
41865>>>                            End
41865>>>>
41865>>>                        End
41865>>>>
41865>>>                    End
41865>>>>
41865>>>                Until (hTable = 0)
41867>>>            End
41867>>>>
41867>>>        Loop       
41868>>>>
41868>>>        
41868>>>        // If an error occured we need to exit the application.
41868>>>        If (bResult = False) Begin  
41870>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
41871>>>            Send Exit_Application
41872>>>        End
41872>>>>
41872>>>        
41872>>>    End_Procedure               
41873>>>
41873>>>    // To update currently saved IntFile data to the database.
41873>>>    // Because it is much easier, we first delete all current records and
41873>>>    // then saves the changed .int file to the database.
41873>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
41875>>>        Boolean bOK
41875>>>        
41875>>>        Move False to bOK
41876>>>
41876>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
41877>>>        If (bOK = True) Begin
41879>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
41880>>>        End
41880>>>>
41880>>>        
41880>>>        Function_Return bOK
41881>>>    End_Function
41882>>>    
41882>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
41884>>>        Handle hTable
41884>>>        Boolean bOK
41884>>>        Integer iColumn iIndex   
41884>>>        String sFileName
41884>>>        
41884>>>        Move False to bOK
41885>>>        Get phIntFilesTable to hTable
41886>>>        Move 2              to iColumn // This is the "InfFileName" field no.
41887>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
41888>>>
41888>>>        Open hTable
41890>>>        Set_Field_Value hTable iColumn to sIntFileName
41893>>>        Vfind hTable iIndex GE
41895>>>        Get_Field_Value hTable iColumn to sFileName
41898>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
41900>>>            Move True to bOK    
41901>>>        End
41901>>>>
41901>>>        Close hTable
41902>>>        
41902>>>        Function_Return bOK       
41903>>>    End_Function   
41904>>>    
41904>>>    // Checks that the passed .int file is the same as what is saved in the database.
41904>>>    // If not same, the return string array will contain the read .int file,
41904>>>    // else the returned array will be empty.
41904>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
41906>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
41910>>>        Boolean bIsSame
41910>>>        
41910>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
41911>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
41912>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
41913>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
41914>>>        
41914>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
41915>>>        If (bIsSame = False) Begin
41917>>>            Move asIntFileOrg to asReturnIntFile    
41918>>>        End
41918>>>>
41918>>>        
41918>>>        Function_Return asReturnIntFile    
41919>>>    End_Function                                   
41920>>>    
41920>>>    // Takes a string array as parameter and returns a new
41920>>>    // string array without any empty rows and all rows trimmed.
41920>>>    // This is e.g. used by the HasIntFileChanged message to compare
41920>>>    // two .int file arrays. 
41920>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
41922>>>        Integer iSize iCount iRow
41922>>>        String sVal        
41922>>>        String[] asRetValArray
41923>>>        
41923>>>        Move (SizeOfArray(asIntFile)) to iSize
41924>>>        If (iSize = 0) Begin
41926>>>            Function_Return asRetValArray
41927>>>        End                          
41927>>>>
41927>>>        Decrement iSize         
41928>>>        Move 0 to iRow
41929>>>        
41929>>>        For iCount from 0  to iSize
41935>>>>
41935>>>            Move asIntFile[iCount] to sVal
41936>>>            Move (Trim(sVal)) to sVal
41937>>>            If (sVal <> "") Begin
41939>>>                Move sVal to asRetValArray[iRow]
41940>>>                Increment iRow        
41941>>>            End
41941>>>>
41941>>>        Loop
41942>>>>
41942>>>        
41942>>>        Function_Return asRetValArray
41943>>>    End_Function
41944>>>    
41944>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
41946>>>        Handle hTable
41946>>>        Boolean bOK bErr
41946>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
41946>>>        Number iID
41946>>>        String sFileName
41946>>>        String[] asIntFile
41947>>>        
41947>>>        Move Err to bErr
41948>>>        Move False to Err
41949>>>        Move False to bOK
41950>>>        Get phIntFilesTable to hTable  
41951>>>        Move 1              to iIDCol
41952>>>        Move 2              to iFileCol
41953>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
41954>>>        Move 1              to iIDIdx   // Main ID index.
41955>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
41956>>>
41956>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
41957>>>        Move (SizeOfArray(asIntFile)) to iSize
41958>>>        If (iSize = 0) Begin
41960>>>            Function_Return False
41961>>>        End
41961>>>>
41961>>>        Decrement iSize
41962>>>        Open hTable  
41964>>>                  
41964>>>        // Find the last used ID no:
41964>>>        Fill_Field hTable iIDCol with DF_HIGH
41966>>>        Vfind hTable iIDIdx LE
41968>>>        Get_Field_Value hTable iIDCol to iID 
41971>>>        // This only happens the very first time we save a record.
41971>>>        If (iID = 999999999999) Begin
41973>>>            Move 0 to iID
41974>>>        End
41974>>>>
41974>>>        Increment iID        
41975>>>        
41975>>>        Lock
41976>>>>
41976>>>            For iCount from 0 to iSize
41982>>>>
41982>>>                Clear hTable
41983>>>                Set_Field_Value hTable iIDCol   to iID     
41986>>>                Set_Field_Value hTable iFileCol to sIntFileName
41989>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
41992>>>                SaveRecord hTable
41993>>>                Increment iID
41994>>>            Loop
41995>>>>
41995>>>        Unlock
41996>>>>
41996>>>        Close hTable
41997>>>        
41997>>>        Move (not(Err)) to bOK
41998>>>        Move bErr to Err
41999>>>        
41999>>>        Function_Return bOK
42000>>>    End_Function
42001>>>    
42001>>>    // Deletes all records for the passed sIntFileName value,
42001>>>    // from the phIntFilesTable.
42001>>>    // Returns True if no errors occured.
42001>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
42003>>>        Handle hTable
42003>>>        Boolean bOK bErr bFound
42003>>>        Integer iFileCol iIndex
42003>>>        String sVal
42003>>>        String[] asIntFile
42004>>>        
42004>>>        Move Err to bErr
42005>>>        Move False to Err
42006>>>        Move False to bOK
42007>>>        Move 2              to iFileCol
42008>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
42009>>>        Get phIntFilesTable to hTable  
42010>>>        Open hTable  
42012>>>                  
42012>>>        // Find the first record
42012>>>        Set_Field_Value hTable iFileCol to sIntFileName
42015>>>        Vfind hTable iIndex GE
42017>>>        Get_Field_Value hTable iFileCol to sVal
42020>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
42021>>>        While (bFound = True)
42025>>>            Delete hTable
42026>>>            Vfind hTable iIndex GT
42028>>>            Get_Field_Value hTable iFileCol to sVal
42031>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
42032>>>        Loop
42033>>>>
42033>>>        Unlock
42034>>>>
42034>>>        Close hTable
42035>>>        
42035>>>        Move (not(Err)) to bOK
42036>>>        Move bErr to Err
42037>>>        
42037>>>        Function_Return bOK
42038>>>    End_Function
42039>>>
42039>>>    // Returns all saved phIntFilesTable records for the passed 
42039>>>    // sIntFileName value as a string array.
42039>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
42041>>>        Handle hTable
42041>>>        Boolean bOK bErr bFound
42041>>>        Integer iFileCol iTextCol iIndex
42041>>>        String sVal sFileName
42041>>>        String[] asIntFile asEmptyArray
42043>>>        
42043>>>        Move Err to bErr
42044>>>        Move False to Err
42045>>>        Move False to bOK
42046>>>        Move 2              to iFileCol
42047>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
42048>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
42049>>>        Get phIntFilesTable to hTable  
42050>>>        Open hTable  
42052>>>
42052>>>        // Find the first record
42052>>>        Set_Field_Value hTable iFileCol to sIntFileName
42055>>>        Vfind hTable iIndex GE
42057>>>        Get_Field_Value hTable iFileCol to sFileName
42060>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
42061>>>        While (bFound = True)
42065>>>            Get_Field_Value hTable iFileCol to sFileName
42068>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
42069>>>            If (bFound = True) Begin
42071>>>                Get_Field_Value hTable iTextCol to sVal
42074>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
42075>>>            End
42075>>>>
42075>>>            Vfind hTable iIndex GT
42077>>>        Loop
42078>>>>
42078>>>        
42078>>>        Close hTable
42079>>>        Move (not(Err)) to bOK
42080>>>        If (bOK = False) Begin
42082>>>            Move asEmptyArray to asIntFile
42083>>>        End
42083>>>>
42083>>>        Move bErr to Err               
42084>>>        
42084>>>        Function_Return asIntFile
42085>>>    End_Function
42086>>>
42086>>>    // Reads the passed sIntFileName from disk and returns its value
42086>>>    // as a string array.
42086>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
42088>>>        String[] asIntFile       
42089>>>        String sFileName sLine
42089>>>        Integer iCh iSize iCount
42089>>>        
42089>>>        Get vFolderFormat sPath to sPath
42090>>>        If (not(sIntFileName contains ".")) Begin
42092>>>            Move (sIntFileName + ".int") to sIntFileName
42093>>>        End
42093>>>>
42093>>>        Move (sPath + sIntFileName) to sFileName
42094>>>        Get Seq_Open_input_Channel sFileName to iCh
42095>>>        If (iCh < 0) Begin
42097>>>            Function_Return asIntFile
42098>>>        End                                 
42098>>>>
42098>>>        
42098>>>        Repeat
42098>>>>
42098>>>            Readln channel iCh sLine
42100>>>            If (SeqEof = False) Begin
42102>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
42103>>>            End
42103>>>>
42103>>>        Until (SeqEof = True)
42105>>>        Send Seq_Close_Channel iCh    
42106>>>        
42106>>>        Function_Return asIntFile
42107>>>    End_Function
42108>>>    
42108>>>    // Reads the Filelist.cfg from memeory as a resource.
42108>>>    // The Filelist.cfg has been compiled into the program.
42108>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
42110>>>        Integer iCh iCount
42110>>>        Number nByteCount
42110>>>        String[] asFileListArray sEmptyArray
42112>>>        String sLine
42112>>>        UChar[] uCharData
42113>>>        
42113>>>        Move False to Err
42114>>>        Get Seq_New_Channel to iCh
42115>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
42117>>>            Error DFERR_PROGRAM 'No channel available...'
42118>>>>
42118>>>            Function_Return sEmptyArray
42119>>>        End
42119>>>>
42119>>>
42119>>>        // First decide the size of the script
42119>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
42121>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
42123>>>        Close_Input channel iCh
42125>>>        Send Seq_Release_Channel iCh
42126>>>
42126>>>        Function_Return uCharData
42127>>>    End_Function    
42128>>>    
42128>>>    // Writes a copy of the workspace Filelist.cfg to disk.
42128>>>    // It does so by reading from a memory resource, as the file has
42128>>>    // been compiled into the program.
42128>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
42130>>>        Boolean bOK bErr
42130>>>        Integer iSize iCh
42130>>>        
42130>>>        Move Err to bErr
42131>>>        Move False to Err
42132>>>        Move False to bOK
42133>>>        Move (SizeOfArray(asFileListArray)) to iSize
42134>>>        If (iSize = 0) Begin
42136>>>            Function_Return False
42137>>>        End
42137>>>>
42137>>>
42137>>>        Get Seq_New_Channel to iCh
42138>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
42140>>>            Error DFERR_PROGRAM 'No channel available...'
42141>>>>
42141>>>            Function_Return False
42142>>>        End                      
42142>>>>
42142>>>        
42142>>>        Direct_Output channel iCh sFileListName
42144>>>        Writeln channel iCh asFileListArray
42147>>>                
42147>>>        Close_Input channel iCh
42149>>>        Send Seq_Release_Channel iCh
42150>>>        Move (not(Err)) to bOK
42151>>>        Move bErr to Err
42152>>>        
42152>>>        Function_Return bOK
42153>>>    End_Function
42154>>>
42154>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
42154>>>    // It first deletes the .cch file (if any).
42154>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
42156>>>        Boolean bOK bFound bExists bErr
42156>>>        Integer iCh iSize iCount
42156>>>        String sFileName sCCHFileName sVal
42156>>>        String[] asIntFile
42157>>>        
42157>>>        Move Err to bErr   
42158>>>        Move False to Err
42159>>>        Move False to bOK
42160>>>
42160>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
42161>>>        Move (SizeOfArray(asIntFile)) to iSize
42162>>>        If (iSize = 0) Begin
42164>>>            Function_Return False        
42165>>>        End                      
42165>>>>
42165>>>        Decrement iSize
42166>>>        
42166>>>        Get Seq_New_Channel to iCh
42167>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
42169>>>            Function_Return False
42170>>>        End   
42170>>>>
42170>>>        
42170>>>        // Before we start to actually create the new .int file, make sure we delete
42170>>>        // the .cch file first.                                     
42170>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
42171>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
42172>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
42173>>>        If (bExists = True) Begin
42175>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
42176>>>            If (bOK = False) Begin
42178>>>                Function_Return False
42179>>>            End
42179>>>>
42179>>>        End
42179>>>>
42179>>>        
42179>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
42181>>>        For iCount from 0 to iSize
42187>>>>
42187>>>            Writeln channel iCh asIntFile[iCount]
42190>>>        Loop
42191>>>>
42191>>>        
42191>>>        Close_Input channel iCh
42193>>>        Send Seq_Release_Channel iCh
42194>>>        Move (not(Err)) to bOK
42195>>>        Move bErr to Err
42196>>>        
42196>>>        Function_Return bOK
42197>>>    End_Function   
42198>>>              
42198>>>    // Automatically writes .int files to disk that is missing.
42198>>>    // We only need to make this test this once, but because the message is called
42198>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
42198>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
42198>>>    Procedure AutoCreateIntFilesTable 
42200>>>        Integer hTable 
42200>>>        Boolean bIntFilesTablesCheckDone bTableExists
42200>>>        String sInfoTxt 
42200>>>        
42200>>>        Get phIntFilesTable to hTable  
42201>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
42202>>>        If (bIntFilesTablesCheckDone = True) Begin
42204>>>            Procedure_Return
42205>>>        End
42205>>>>
42205>>>
42205>>>        If (hTable < 1) Begin
42207>>>            Set Private.pbIntFilesTablesCheckDone to False
42208>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42209>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
42210>>>>
42210>>>            Procedure_Return
42211>>>        End
42211>>>>
42211>>>
42211>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
42212>>>        If (bTableExists = True) Begin
42214>>>            Set Private.pbIntFilesTablesCheckDone to True
42215>>>            Procedure_Return
42216>>>        End
42216>>>>
42216>>>
42216>>>        Send CreateIntFilesTable hTable
42217>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
42218>>>        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
42219>>>    End_Function
42220>>>                
42220>>>    Procedure CreateIntFilesTable Handle hTable
42222>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
42222>>>        Boolean bTableExists bOK bUseConnectionID bExists
42222>>>        tAPIColumn[] APIColumn
42222>>>        tAPIColumn[] APIColumn
42223>>>
42223>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
42224>>>        If (bTableExists = True) Begin
42226>>>            Procedure_Return
42227>>>        End
42227>>>>
42227>>>
42227>>>        Move False to Err
42228>>>        Get psDriverID to sDriverID
42229>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
42230>>>
42230>>>        Move CS_IntFilesTableRootName to sTableName
42231>>>
42231>>>        Move 1                  to APIColumn[0].iFieldNumber
42232>>>        Move "ID"               to APIColumn[0].sFieldName
42233>>>        Move DF_BCD             to APIColumn[0].iType
42234>>>        Move False              to APIColumn[0].bIsSQLType
42235>>>        Move 12                 to APIColumn[0].iLength
42236>>>        Move 0                  to APIColumn[0].iPrecision
42237>>>
42237>>>        Move 2                  to APIColumn[1].iFieldNumber
42238>>>        Move "IntFileName"      to APIColumn[1].sFieldName
42239>>>        Move DF_ASCII           to APIColumn[1].iType
42240>>>        Move False              to APIColumn[1].bIsSQLType
42241>>>        Move 50                 to APIColumn[1].iLength
42242>>>        Move 0                  to APIColumn[1].iPrecision
42243>>>
42243>>>        Move 3                  to APIColumn[2].iFieldNumber
42244>>>        Move "IntLineText"      to APIColumn[2].sFieldName
42245>>>        Move DF_ASCII           to APIColumn[2].iType
42246>>>        Move False              to APIColumn[2].bIsSQLType
42247>>>        Move 100                to APIColumn[2].iLength
42248>>>        Move 0                  to APIColumn[2].iPrecision
42249>>>
42249>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
42250>>>        
42250>>>        If (bOK = True and Err = False) Begin
42252>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
42253>>>        End
42253>>>>
42253>>>        Else Begin
42254>>>            Set Private.pbIntFilesTablesCheckDone to False
42255>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
42256>>>            Error DFERR_PROGRAM sInfoTxt
42257>>>>
42257>>>            Procedure_Return
42258>>>        End
42258>>>>
42258>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
42259>>>        
42259>>>        Open hTable
42261>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
42262>>>        If (bOK = True) Begin
42264>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
42265>>>        End
42265>>>>
42265>>>        If (bOK = False) Begin
42267>>>            Set Private.pbIntFilesTablesCheckDone to False
42268>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
42269>>>            Error DFERR_PROGRAM sInfoTxt
42270>>>>
42270>>>            Procedure_Return
42271>>>        End                    
42271>>>>
42271>>>        
42271>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
42271>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
42272>>>        Get vFolderFormat sDataPath to sDataPath
42273>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
42274>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
42275>>>        If (bExists = True) Begin
42277>>>            Move CS_IntFilesTableRootName to sTableName
42278>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
42279>>>            If (bExists = True) Begin
42281>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
42282>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
42283>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
42284>>>            End
42284>>>>
42284>>>        End
42284>>>>
42284>>>        
42284>>>        Set Private.pbIntFilesTablesCheckDone to True
42285>>>    End_Procedure
42286>>>
42286>>>    Procedure CheckAutoCreateDbVersionTable
42288>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
42288>>>        Integer iDbVersionFileNumber
42288>>>
42288>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
42289>>>        If (bDbVersionCheckDone = True) Begin
42291>>>            Procedure_Return
42292>>>        End
42292>>>>
42292>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
42293>>>        If (bUseCustomDbVersion = True) Begin
42295>>>            Procedure_Return
42296>>>        End
42296>>>>
42296>>>
42296>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
42297>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
42299>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42300>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
42301>>>>
42301>>>            Send Exit_Application
42302>>>        End
42302>>>>
42302>>>
42302>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
42303>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
42304>>>        If (bTableExists = True) Begin
42306>>>            Set Private.pbDbVersionCheckDone to True
42307>>>            Procedure_Return
42308>>>        End
42308>>>>
42308>>>
42308>>>        Send CreateDbVersionTable iDbVersionFileNumber
42309>>>
42309>>>        // We only need to these DbVersion checks once, but because this message is called
42309>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
42309>>>        // we use a property to only run these tests once.
42309>>>        Set Private.pbDbVersionCheckDone to True
42310>>>    End_Procedure
42311>>>
42311>>>    Procedure CreateDbVersionTable Handle hTable
42313>>>        String sTableName sColumnName sInfoTxt sDriverID 
42313>>>        Boolean bTableExists bOK bUseConnectionID
42313>>>        tAPIColumn[] APIColumn
42313>>>        tAPIColumn[] APIColumn
42314>>>
42314>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
42315>>>        If (bTableExists = True) Begin
42317>>>            Procedure_Return
42318>>>        End
42318>>>>
42318>>>
42318>>>        Get psDriverID to sDriverID
42319>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
42320>>>
42320>>>        Move "DbVersion"        to sTableName
42321>>>        Move 1                  to APIColumn[0].iFieldNumber
42322>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
42323>>>        Move DF_BCD             to APIColumn[0].iType
42324>>>        Move False              to APIColumn[0].bIsSQLType
42325>>>        Move 4                  to APIColumn[0].iLength
42326>>>        Move 2                  to APIColumn[0].iPrecision
42327>>>
42327>>>        Move False to Err                                
42328>>>        
42328>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
42328>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
42328>>>        Set psDriverID to DATAFLEX_ID
42329>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
42330>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
42331>>>        Set psDriverID to sDriverID
42332>>>        
42332>>>        If (bOK = True and Err = False) Begin
42334>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
42334>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
42335>>>        End
42335>>>>
42335>>>        Else Begin
42336>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
42337>>>        End
42337>>>>
42337>>>
42337>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
42338>>>    End_Procedure
42339>>>
42339>>>    Procedure Set pbVerboseState Boolean bVerboseState
42341>>>        Handle ho
42341>>>        Get phoLogFile to ho
42342>>>        Set pbVerboseState of ho to bVerboseState
42343>>>    End_Procedure
42344>>>
42344>>>    Function pbVerboseState Returns Boolean
42346>>>        Boolean bVerboseState
42346>>>        Handle ho
42346>>>        Get phoLogFile to ho
42347>>>        Get pbVerboseState of ho to bVerboseState
42348>>>        Function_Return bVerboseState
42349>>>    End_Function
42350>>>
42350>>>    // Callback functionality used when e.g. calling driver functions directly.
42350>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
42350>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
42352>>>        Integer iPerc
42352>>>        Number nReady nTotal nVersion
42352>>>        Boolean bVerboseState
42352>>>        Handle hoLogFile
42352>>>
42352>>>        Get pbVerboseState to bVerboseState
42353>>>        Get pnCurrentVersionUpdate to nVersion
42354>>>        Get phoLogFile     to hoLogFile
42355>>>        Send DoAdvance of ghoProgressBar
42356>>>
42356>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
42358>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
42359>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
42360>>>        End
42360>>>>
42360>>>        If (sCallback_Text contains "Creating index") Begin
42362>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
42363>>>        End
42363>>>>
42363>>>
42363>>>        Case Begin
42363>>>            Case (iCallback_Type = DF_Message_Text)
42365>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42366>>>                Set Action_Text  of ghoStatusPanel to ""
42367>>>                If (bVerboseState = True) Begin
42369>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42370>>>                End
42370>>>>
42370>>>                Case Break
42371>>>            Case (iCallback_Type = DF_Message_Heading_1)
42374>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42375>>>                If (bVerboseState = True) Begin
42377>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42378>>>                End
42378>>>>
42378>>>                Case Break
42379>>>            Case (iCallback_Type = DF_Message_Heading_2)
42382>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42383>>>                Set Action_Text  of ghoStatusPanel to ""
42384>>>                If (bVerboseState = True) Begin
42386>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42387>>>                End
42387>>>>
42387>>>                Case Break
42388>>>            Case (iCallback_Type = DF_Message_Heading_3)
42391>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42392>>>                Set Action_Text  of ghoStatusPanel to ""
42393>>>                If (bVerboseState = True) Begin
42395>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42396>>>                End
42396>>>>
42396>>>                Case Break
42397>>>            Case (iCallback_Type = DF_Message_Heading_4)
42400>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42401>>>                Set Action_Text  of ghoStatusPanel to ""
42402>>>                If (bVerboseState = True) Begin
42404>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42405>>>                End
42405>>>>
42405>>>                Case Break
42406>>>            Case (iCallback_Type = DF_Message_Heading_5)
42409>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42410>>>                Set Action_Text  of ghoStatusPanel to ""
42411>>>                If (bVerboseState = True) Begin
42413>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42414>>>                End
42414>>>>
42414>>>                Case Break
42415>>>            Case (iCallback_Type = DF_Message_Warning)
42418>>>                If (bVerboseState = True) Begin
42420>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42421>>>                End
42421>>>>
42421>>>                Case Break
42422>>>            Case (iCallback_Type = DF_Message_Progress_Title)
42425>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42426>>>                Set Action_Text  of ghoStatusPanel to ""
42427>>>                If (bVerboseState = True) Begin
42429>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42430>>>                End
42430>>>>
42430>>>                Case Break
42431>>>            Case (iCallback_Type = DF_Message_Progress_Value)
42434>>>                //*** Interpret numbers
42434>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
42435>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
42436>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
42437>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
42438>>>                Set piPosition of ghoProgressBar to iPerc
42439>>>                Case Break
42440>>>            Case Else
42440>>>                Set Message_Text to ""
42441>>>                Set Action_Text  to ""
42442>>>        Case End
42442>>>
42442>>>        Send ProcessEvents of ghoStatusPanel
42443>>>        Function_Return False
42444>>>    End_Function
42445>>>
42445>>>    // This was made to be a procedure/function pair so we
42445>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
42445>>>
42445>>>    Procedure Set piDbType Integer iDbType
42447>>>        If (ghoSQLConnectionHandler = 0) Begin
42449>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42450>>>>
42450>>>            Procedure_Return
42451>>>        End
42451>>>>
42451>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
42452>>>    End_Procedure
42453>>>
42453>>>    Function piDbType Returns Integer
42455>>>        Integer iDbType
42455>>>        If (ghoSQLConnectionHandler = 0) Begin
42457>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42458>>>>
42458>>>            Function_Return ""
42459>>>        End
42459>>>>
42459>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
42460>>>        Function_Return iDbType
42461>>>    End_Function
42462>>>
42462>>>    Procedure Set psDriverID String sDriverID
42464>>>        If (ghoSQLConnectionHandler = 0) Begin
42466>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42467>>>>
42467>>>            Procedure_Return
42468>>>        End
42468>>>>
42468>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
42469>>>    End_Procedure
42470>>>
42470>>>    Function psDriverID Returns String
42472>>>        String sValue
42472>>>        If (ghoSQLConnectionHandler = 0) Begin
42474>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42475>>>>
42475>>>            Function_Return ""
42476>>>        End
42476>>>>
42476>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
42477>>>        Function_Return sValue
42478>>>    End_Function
42479>>>
42479>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
42481>>>        If (ghoSQLConnectionHandler = 0) Begin
42483>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42484>>>>
42484>>>            Procedure_Return
42485>>>        End
42485>>>>
42485>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
42486>>>    End_Procedure
42487>>>
42487>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
42489>>>        Integer iRetval
42489>>>        If (ghoSQLConnectionHandler = 0) Begin
42491>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42492>>>>
42492>>>            Function_Return 2
42493>>>        End
42493>>>>
42493>>>
42493>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
42494>>>        Function_Return iRetval
42495>>>    End_Function
42496>>>
42496>>>    Procedure Set psConnectionID String sValue
42498>>>        If (ghoSQLConnectionHandler = 0) Begin
42500>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42501>>>>
42501>>>            Procedure_Return
42502>>>        End
42502>>>>
42502>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
42503>>>    End_Procedure
42504>>>
42504>>>    Function psConnectionID Returns String
42506>>>        String sValue
42506>>>        If (ghoSQLConnectionHandler = 0) Begin
42508>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42509>>>>
42509>>>            Function_Return ""
42510>>>        End
42510>>>>
42510>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
42511>>>
42511>>>        Function_Return sValue
42512>>>    End_Function
42513>>>
42513>>>    // These "properties" are settings of the cCLIHandler class, but are being
42513>>>    // relayed to the ghoSQLConnectionHandler object
42513>>>    // simply by changing one of its parameters.
42513>>>    Procedure Set psServer String sValue
42515>>>        If (ghoSQLConnectionHandler = 0) Begin
42517>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42518>>>>
42518>>>            Procedure_Return
42519>>>        End
42519>>>>
42519>>>        Set psServer of ghoSQLConnectionHandler to sValue
42520>>>    End_Procedure
42521>>>
42521>>>    Function psServer Returns String
42523>>>        String sValue
42523>>>        If (ghoSQLConnectionHandler = 0) Begin
42525>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42526>>>>
42526>>>            Function_Return ""
42527>>>        End
42527>>>>
42527>>>        Get psServer of ghoSQLConnectionHandler to sValue
42528>>>
42528>>>        Function_Return sValue
42529>>>    End_Function
42530>>>
42530>>>    Procedure Set psDatabase String sValue
42532>>>        If (ghoSQLConnectionHandler = 0) Begin
42534>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42535>>>>
42535>>>            Procedure_Return
42536>>>        End
42536>>>>
42536>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
42537>>>    End_Procedure
42538>>>
42538>>>    Function psDatabase Returns String
42540>>>        String sValue
42540>>>        If (ghoSQLConnectionHandler = 0) Begin
42542>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42543>>>>
42543>>>            Function_Return ""
42544>>>        End
42544>>>>
42544>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
42545>>>
42545>>>        Function_Return sValue
42546>>>    End_Function
42547>>>
42547>>>    Procedure Set psUserID String sValue
42549>>>        If (ghoSQLConnectionHandler = 0) Begin
42551>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42552>>>>
42552>>>            Procedure_Return
42553>>>        End
42553>>>>
42553>>>        Set psUserID of ghoSQLConnectionHandler to sValue
42554>>>    End_Procedure
42555>>>
42555>>>    Function psUserID Returns String
42557>>>        String sValue
42557>>>        If (ghoSQLConnectionHandler = 0) Begin
42559>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42560>>>>
42560>>>            Function_Return ""
42561>>>        End
42561>>>>
42561>>>        Get psUserID of ghoSQLConnectionHandler to sValue
42562>>>
42562>>>        Function_Return sValue
42563>>>    End_Function
42564>>>
42564>>>    Procedure Set psPassword String sValue
42566>>>        If (ghoSQLConnectionHandler = 0) Begin
42568>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42569>>>>
42569>>>            Procedure_Return
42570>>>        End
42570>>>>
42570>>>        Set psPassword of ghoSQLConnectionHandler to sValue
42571>>>    End_Procedure
42572>>>
42572>>>    Function psPassword Returns String
42574>>>        String sValue
42574>>>        If (ghoSQLConnectionHandler = 0) Begin
42576>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42577>>>>
42577>>>            Function_Return ""
42578>>>        End
42578>>>>
42578>>>        Get psPassword of ghoSQLConnectionHandler to sValue
42579>>>
42579>>>        Function_Return sValue
42580>>>    End_Function
42581>>>
42581>>>    Procedure Set pbTrusted Boolean bValue
42583>>>        If (ghoSQLConnectionHandler = 0) Begin
42585>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42586>>>>
42586>>>            Procedure_Return
42587>>>        End
42587>>>>
42587>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
42588>>>    End_Procedure
42589>>>
42589>>>    Function pbTrusted Returns Boolean
42591>>>        Boolean bValue
42591>>>        If (ghoSQLConnectionHandler = 0) Begin
42593>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42594>>>>
42594>>>            Function_Return False
42595>>>        End
42595>>>>
42595>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
42596>>>
42596>>>        Function_Return bValue
42597>>>    End_Function
42598>>>
42598>>>    Procedure Set psConnectionString String sValue
42600>>>        If (ghoSQLConnectionHandler = 0) Begin
42602>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42603>>>>
42603>>>            Procedure_Return
42604>>>        End
42604>>>>
42604>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
42605>>>    End_Procedure
42606>>>
42606>>>    Function psConnectionString Returns String
42608>>>        String sValue
42608>>>        If (ghoSQLConnectionHandler = 0) Begin
42610>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42611>>>>
42611>>>            Function_Return ""
42612>>>        End
42612>>>>
42612>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
42613>>>
42613>>>        Function_Return sValue
42614>>>    End_Function
42615>>>
42615>>>    Function piConnectionOptions Returns Integer
42617>>>        Integer iValue
42617>>>        If (ghoSQLConnectionHandler = 0) Begin
42619>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42620>>>>
42620>>>            Function_Return 0
42621>>>        End
42621>>>>
42621>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
42622>>>
42622>>>        Function_Return iValue
42623>>>    End_Function
42624>>>
42624>>>
42624>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
42626>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
42627>>>    End_Procedure
42628>>>
42628>>>    Function pbCheckDataFlexUserCount Returns Boolean
42630>>>        Boolean bState
42630>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
42631>>>        Function_Return bState
42632>>>    End_Function
42633>>>
42633>>>    Procedure Set psLogTextFile String sValue
42635>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
42636>>>    End_Procedure
42637>>>
42637>>>    Function psLogTextFile Returns String
42639>>>        String sValue
42639>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
42640>>>        Function_Return sValue
42641>>>    End_Function
42642>>>
42642>>>    Procedure Set psEditorProgram String sValue
42644>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
42645>>>    End_Procedure
42646>>>
42646>>>    Function psEditorProgram Returns String
42648>>>        String sValue
42648>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
42649>>>        Function_Return sValue
42650>>>    End_Function
42651>>>
42651>>>    Procedure Set pbUseDataTableLog Boolean bState
42653>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
42654>>>    End_Procedure
42655>>>
42655>>>    Function pbUseDataTableLog Returns Boolean
42657>>>        Boolean bState
42657>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
42658>>>        Function_Return bState
42659>>>    End_Function
42660>>>
42660>>>    Procedure Set pbQuickWrite Boolean bState
42662>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
42663>>>    End_Procedure
42664>>>
42664>>>    Function pbQuickWrite Returns Boolean
42666>>>        Boolean bState
42666>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
42667>>>        Function_Return bState
42668>>>    End_Function
42669>>>
42669>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
42671>>>        Boolean bUpdateVersionObjectError bVerboseState
42671>>>        Integer iSize iCount
42671>>>        Number nVersion
42671>>>        String[] aSQLQueryMessages
42672>>>
42672>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
42673>>>        Set Private.pbDatabaseWasUpdated to bState
42674>>>        // If no errors occurred in the current cDbUpdateVersion object - write
42674>>>        // to the log that it was OK.
42674>>>        If (bUpdateVersionObjectError = False) Begin
42676>>>            Get pnCurrentVersionUpdate to nVersion
42677>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
42678>>>        End
42678>>>>
42678>>>
42678>>>        Get pbVerboseState to bVerboseState
42679>>>        If (bVerboseState = True) Begin
42681>>>            Get paSQLQueryMessages to aSQLQueryMessages
42682>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
42683>>>            Decrement iSize
42684>>>            For iCount from 0 to iSize
42690>>>>
42690>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
42691>>>            Loop
42692>>>>
42692>>>        End
42692>>>>
42692>>>
42692>>>    End_Procedure 
42693>>>    
42693>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
42695>>>        Set Private.piDbVersionFileNumber to iFileNumber
42696>>>    End_Procedure                                         
42697>>>    
42697>>>    Function piDbVersionFileNumber Returns Integer
42699>>>        Function_Return (Private.piDbVersionFileNumber(Self))
42700>>>    End_Function
42701>>>
42701>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
42703>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
42704>>>    End_Procedure                                         
42705>>>    
42705>>>    Function piDbVersionFieldNumber Returns Integer
42707>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
42708>>>    End_Function
42709>>>
42709>>>    Function pbDatabaseWasUpdated Returns Boolean
42711>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
42712>>>    End_Function
42713>>>    
42713>>>    //
42713>>>    Procedure ReinitializeFramework  
42715>>>        tDbVersionInfo[] aDbVersionInfoArray
42715>>>        tDbVersionInfo[] aDbVersionInfoArray
42716>>>        Handle hoDbVersionObject
42716>>>        Integer iSize iCount
42716>>>        
42716>>>        Set Private.pbDatabaseUpdateStarted to False
42717>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
42718>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
42719>>>        Decrement iSize
42720>>>        
42720>>>        For iCount from 0 to iSize
42726>>>>
42726>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
42727>>>            Send ProcessUpdate                  of hoDbVersionObject False
42728>>>        Loop
42729>>>>
42729>>>        Send Cleanup
42730>>>    End_Procedure
42731>>>    
42731>>>    // This event is triggered by the cDbUpdateVersion child class when
42731>>>    // a database change is to be started, and is considered private.
42731>>>    // It is only executed once for the first cDbUpateVersion object!
42731>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
42733>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
42733>>>        Integer iRetval iDataFlexUsers iUserCount
42733>>>        Handle hoUserCountSystem
42733>>>        tUserCount UserCount
42733>>>        tUserCount UserCount
42733>>>        DateTime dtUpdateStarted
42733>>>        tSQLConnection SQLConnection
42733>>>        tSQLConnection SQLConnection
42733>>>
42733>>>        // *Important:* If we already started the update; we do no further checking.
42733>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
42734>>>        If (bDatabaseUpdateStarted = True) Begin
42736>>>            Procedure_Return
42737>>>        End
42737>>>>
42737>>>
42737>>>        // If not silent mode; Ask user if OK to start database update.
42737>>>        If (pbSilentMode(Self) = False) Begin
42739>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
42740>>>            If (iRetval <> MBR_Yes) Begin
42742>>>                Send Exit_Application
42743>>>            End
42743>>>>
42743>>>        End
42743>>>>
42743>>>        
42743>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
42744>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
42745>>>        Send Start_StatusPanel      of ghoStatusPanel
42746>>>
42746>>>        // This will save the status of all open tables including Master/Alias settings,
42746>>>        // so we can restore them later;
42746>>>        Send SaveOpenTables
42747>>>
42747>>>        Move 0 to iDataFlexUsers
42748>>>        // Make various tests to check that the database is not in use.
42748>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
42749>>>        // We also use our own user counting mechanism to guard against the
42749>>>        // database isn't opened already as we need exclusive access to the tables.:
42749>>>        Get phoUserCountSystem to hoUserCountSystem
42750>>>        Get CheckUserCount of hoUserCountSystem to UserCount
42751>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
42752>>>
42752>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
42753>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
42753>>>        If (bCheckDataFlexUserCount = True) Begin
42755>>>            Get_Current_User_Count to iDataFlexUsers
42756>>>            // For some reason DataFlex - in some cases - might think that 2 users
42756>>>            // are in use while debugging from the Studio.
42756>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
42758>>>                Decrement iDataFlexUsers
42759>>>            End
42759>>>>
42759>>>        End 
42759>>>>
42759>>>        Else Begin
42760>>>            Move 1 to iDataFlexUsers 
42761>>>            Move 1 to iUserCount
42762>>>            Move False to bInUse
42763>>>        End
42763>>>>
42763>>>
42763>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
42765>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
42766>>>            If (iRetval <> MBR_Yes) Begin
42768>>>                Send Exit_Application
42769>>>            End
42769>>>>
42769>>>        End
42769>>>>
42769>>>
42769>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
42771>>>            Send Stop_Box CS_DUF_DatabaseInUseText
42772>>>            Send Exit_Application
42773>>>        End
42773>>>>
42773>>>
42773>>>        // This will put a look on the DbUpdateLock.ucf file.
42773>>>        // It is released when the update process is finished
42773>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
42774>>>
42774>>>        Move (CurrentDateTime()) to dtUpdateStarted
42775>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
42776>>>        Set Private.pbDatabaseUpdateStarted to True
42777>>>
42777>>>        // We need to close all tables before starting to make changes.
42777>>>        Close DF_ALL DF_PERMANENT
42778>>>
42778>>>        // If these properties has not exclicitly been set in the object, set them
42778>>>        // to settings from the SQLConnections.ini file;
42778>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
42779>>>        If (psSchema(Self) = "") Begin
42781>>>            Set psSchema            to SQLConnection.sSchema
42782>>>        End
42782>>>>
42782>>>        If (psBaseTableSpace(Self) = "") Begin
42784>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
42785>>>        End
42785>>>>
42785>>>        If (psLongTableSpace(Self) = "") Begin
42787>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
42788>>>        End
42788>>>>
42788>>>        If (psIndexTableSpace(Self) = "") Begin
42790>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
42791>>>        End
42791>>>>
42791>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
42793>>>            Procedure_Return
42794>>>        End
42794>>>>
42794>>>
42794>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
42795>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
42797>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42798>>>            Send Stop_StatusPanel of ghoStatusPanel
42799>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
42799>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
42800>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
42800>>>            Send Exit_Application
42801>>>        End
42801>>>>
42801>>>    End_Procedure
42802>>>
42802>>>    // *** Hook message for pre-processing ***
42802>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
42802>>>    // Aka, when another table than the standard "DbVersion" is used.
42802>>>    Procedure OnCreateCustomDbVersionTable
42804>>>    End_Procedure
42805>>>    
42805>>>    // *** Hook message for pre-processing ***
42805>>>    // The programmer can use this event for putting code that
42805>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
42805>>>    // child objects are executed.
42805>>>    Procedure OnPreUpdate
42807>>>    End_Procedure
42808>>>
42808>>>    // *** Hook message for post-processing ***
42808>>>    // The programmer should use this event for putting code that
42808>>>    // needs to be executed _after_ all database updates have finished.
42808>>>    Procedure OnPostUpdate
42810>>>    End_Procedure
42811>>>
42811>>>    // *** Hook message for custom DbVersion record find ***
42811>>>    // The programmer can use this event for putting code that
42811>>>    // needs to be executed to find a *custom* DbVersion table record.
42811>>>    // By default the DbVersion table is used but this can be
42811>>>    // customized by adding this line to the code;
42811>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
42811>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
42811>>>    //       to save the current database version to. Only if you use your own
42811>>>    //       table _and_ it is not a system table (contains only one record).
42811>>>    Procedure OnFindVersionRecord
42813>>>        // Open MyTable
42813>>>        // Move xx to MyTable.Field1
42813>>>        // Move yy to MyTable.Field2
42813>>>        // Find le MyTable by Index.x
42813>>>    End_Procedure
42814>>>
42814>>>    // Hook event for writing header error text (pre-update) to
42814>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
42814>>>    // Don't forget to Open the table first (!) as all
42814>>>    // tables have been closed at this stage.
42814>>>    // The start date & time is passed.
42814>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
42816>>>    End_Procedure
42817>>>
42817>>>    // Hook event to log errors to a database table.
42817>>>    // Only called if the pbUseDataTableLog = True.
42817>>>    // Don't forget to Open the table first (!) as all
42817>>>    // tables have been closed at this stage.
42817>>>    // If pbQuickWrite = True the DbUpdateErrorArray
42817>>>    // will contain just one row, as it is called for each error
42817>>>    // that occurred. Else it is called once at the end after all updates
42817>>>    // have run and contains all errors.
42817>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
42819>>>    End_Procedure
42820>>>
42820>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
42820>>>    Procedure Cleanup
42822>>>        Boolean bDatabaseWasUpdated bError
42822>>>
42822>>>        Send CheckAutoCreateDbVersionTable
42823>>>        Send RestoreOpenTables
42824>>>
42824>>>        // The function library have two purposes; one is to use it in the
42824>>>        // Database Update Framework, but it can also be used on its own.
42824>>>        // If that is the case it has its own error handling system, which
42824>>>        // we temporarily disbled when running updates because we have
42824>>>        // error handling/logging here too... We now restore its setting.
42824>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
42826>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
42827>>>        End
42827>>>>
42827>>>        Set pbHandleQueryErrors to True
42828>>>
42828>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
42829>>>        Get pbDbUpdateErrorHasOccured to bError
42830>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
42832>>>
42832>>>            // We should always create the log as it also contains info about
42832>>>            // the update being successful.
42832>>>            Send WriteErrorLog of (phoLogFile(Self))
42833>>>
42833>>>            // This is a programmer's hook message:
42833>>>            Send OnPostUpdate
42834>>>
42834>>>            Send Stop_StatusPanel of ghoStatusPanel
42835>>>
42835>>>            If (pbSilentMode(Self) = False) Begin
42837>>>                If (bError = True) Begin
42839>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
42841>>>                        Send ShowErrorLog of (phoLogFile(Self))
42842>>>                    End
42842>>>>
42842>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
42843>>>                    Send Exit_Application
42844>>>                End
42844>>>>
42844>>>                Else Begin
42845>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
42847>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
42848>>>                    End
42848>>>>
42848>>>                    Else Begin
42849>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
42850>>>                    End
42850>>>>
42850>>>
42850>>>                End
42850>>>>
42850>>>            End
42850>>>>
42850>>>        End
42850>>>>
42850>>>
42850>>>        // Restore the standard error handler:
42850>>>        Get piOrgErrorHandlerID to Error_Object_Id
42851>>>    End_Procedure
42852>>>
42852>>>    // We do this _before_ we close the database to make changes, and save
42852>>>    // all 'Master' & 'Alias' tables settings so we can restore when
42852>>>    // we reopen the database.
42852>>>    Procedure SaveOpenTables
42854>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42854>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42855>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
42856>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
42857>>>    End_Procedure
42858>>>
42858>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
42858>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
42858>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
42860>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42860>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42861>>>        Integer hTable iMasterAliasType iSize
42861>>>        Boolean bOpen
42861>>>
42861>>>        Move 0 to hTable
42862>>>        Repeat
42862>>>>
42862>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
42865>>>            If (hTable <> 0) Begin
42867>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
42870>>>                If (bOpen = True) Begin
42872>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
42875>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
42876>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
42877>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
42878>>>                End
42878>>>>
42878>>>            End
42878>>>>
42878>>>        Until (hTable = 0)
42880>>>
42880>>>        Function_Return aDbUpdateHandlerMasterAlias
42881>>>    End_Function
42882>>>
42882>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
42882>>>    // Takes one parameter:
42882>>>    //   A struct array with all master & alias
42882>>>    Procedure RestoreOpenTables
42884>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42884>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42885>>>        Integer hTable iFileAlias iSize iCount
42885>>>        Boolean bOpen
42885>>>        String sRootName
42885>>>
42885>>>        Move 0 to hTable
42886>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
42887>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
42888>>>        Decrement iSize
42889>>>        For iCount from 0 to iSize
42895>>>>
42895>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
42896>>>            // We also need to check that the table hasn't been removed...
42896>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
42899>>>            If (hTable <> 0 and sRootName <> "") Begin
42901>>>                Open hTable
42903>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
42906>>>                If (bOpen = True) Begin
42908>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
42909>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
42911>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
42914>>>                    End
42914>>>>
42914>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
42917>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
42920>>>                    End
42920>>>>
42920>>>                End
42920>>>>
42920>>>            End
42920>>>>
42920>>>        Loop
42921>>>>
42921>>>    End_Procedure
42922>>>
42922>>>    // This checks for both duplicate pnVersionNumbers _and_ that
42922>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
42922>>>    Procedure CheckForDuplicates Number nVersion
42924>>>        tDbVersionInfo[] DbVersionInfoArray
42924>>>        tDbVersionInfo[] DbVersionInfoArray
42925>>>        Integer iCount iSize iHits iDuplicateIndex
42925>>>        Number nCompare
42925>>>        Handle hObject1 hObject2
42925>>>        String sObjectName1 sObjectName2
42925>>>        Boolean bObjectOrderError
42925>>>
42925>>>        Get paDbVersionInfoArray to DbVersionInfoArray
42926>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
42927>>>        Decrement iSize
42928>>>        Move 0 to iHits
42929>>>        Move 0 to nCompare
42930>>>        Move False to bObjectOrderError
42931>>>        For iCount from 0 to iSize
42937>>>>
42937>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
42939>>>                Increment iHits
42940>>>                If (iHits > 1) Begin
42942>>>                    Move iCount to iDuplicateIndex
42943>>>                    If (nCompare <> 0) Begin
42945>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
42946>>>                    End
42946>>>>
42946>>>                End
42946>>>>
42946>>>            End
42946>>>>
42946>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
42947>>>        Loop
42948>>>>
42948>>>        If (iHits > 1) Begin
42950>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42951>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
42952>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
42953>>>            Move (Name(hObject1)) to sObjectName1
42954>>>            Move (Name(hObject2)) to sObjectName2
42955>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
42956>>>>
42956>>>            Send Exit_Application
42957>>>        End
42957>>>>
42957>>>        Else If (bObjectOrderError = True) Begin
42960>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42961>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
42962>>>>
42962>>>            Send Exit_Application
42963>>>        End
42963>>>>
42963>>>    End_Procedure
42964>>>
42964>>>    // We take care of all errors in the Error_Report below and
42964>>>    // collect them all to an array property. So just ignore any
42964>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
42964>>>    // in some other package.
42964>>>    Procedure Ignore_Error Integer iError
42966>>>    End_Procedure
42967>>>
42967>>>    Procedure Trap_Error Integer iError
42969>>>    End_Procedure
42970>>>
42970>>>    // Build complete error description from Flexerrs and user error message.
42970>>>    Function Error_Description Integer Error# String ErrMsg Returns String
42972>>>        String Full_Error_Text
42972>>>        
42972>>>        Move (Trim(ErrMsg)) to ErrMsg
42973>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
42974>>>        
42974>>>        If (ErrMsg <> "") Begin
42976>>>            
42976>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
42978>>>                // Make sure last character of error text is a separating symbol.
42978>>>                // if not, add a "." So we have format of "error-text. error-detail"
42978>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
42981>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
42982>>>            End
42982>>>>
42982>>>            Else ;                Move ErrMsg to Full_Error_Text
42984>>>            
42984>>>        End
42984>>>>
42984>>>        
42984>>>        Function_Return Full_Error_Text
42985>>>    End_Function
42986>>>
42986>>>    // While we update the database we collect all errors in
42986>>>    // the struct array paDbUpdateErrorArray.
42986>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
42988>>>        Number nVersion
42988>>>        Handle hoLogFile 
42988>>>//        String sErrExtraText
42988>>>        
42988>>>        If (Private.pbProcessingError(Self)) Begin
42990>>>            Procedure_Return
42991>>>        End
42991>>>>
42991>>>
42991>>>        // The UtilTableNameFromHandleToString function does a:
42991>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
42991>>>        // and it generates an error if the table is of the embedded type.
42991>>>        // As we don't want to trigger an error in that very specific case,
42991>>>        // we just ignore it here.
42991>>>        //
42991>>>        // If no report mode, just set the err indicator to true.
42991>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
42993>>>            Move False to Err
42994>>>            Procedure_Return
42995>>>        End
42995>>>>
42995>>>
42995>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
42997>>>            Procedure_Return
42998>>>        End
42998>>>>
42998>>>
42998>>>        Set Private.pbProcessingError to True
42999>>>        Set Private.pbUpdateVersionObjectError to True
43000>>>
43000>>>        Set pbDbUpdateErrorHasOccured to True
43001>>>        Get pnCurrentVersionUpdate to nVersion
43002>>>        Get phoLogFile to hoLogFile
43003>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
43004>>>
43004>>>        Set Private.pbProcessingError to False
43005>>>    End_Procedure
43006>>>
43006>>>End_Class
43007>
43007>Object oApplication is a cApplication
43009>    Set psCompany to 'RDC Tools International'
43010>    Set psProduct to 'DUF Auto Update Program'
43011>    Set psProgram to 'Internal use/test of a DUF Update Package'
43012>    Set psVersion to '20.1'
43013>    Property String psCompileDateAndTime
43015>End_Object
43016>
43016>Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: 1 now?") to WindowIndex
43017>If (WindowIndex <> MBR_Yes) Begin
43019>    Send Exit_Application
43020>End
43020>
43020>Object oDbUpdateHandler is a cDbUpdateHandler
43022>    Set piDbVersionFileNumber  to 1
43023>    Set piDbVersionFieldNumber to 1
43024>    Set pbAutoCreateDbVersionTable to True  
43025>    Set pbCheckIntFiles to True
43026>
43026>//    Use DUF_MultipleTables1_0.pkg
43026>
43026>End_Object
43027>
43027>If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin
43029>   Send Info_Box 'Nothing to update. (Version number has not changed)'
43030>End
43030>
43030>Send Exit_Application
43031>// *** End-Of-Program Code ***
43031>
Including Resources...
Summary
Memory Available: 100859592704
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 25392
Total Resources: 6
Total Commands : 43030
Total Windows  : 0
Total Pages    : 0
Static Data    : 503549
Message area   : 203407
Total Blocks   : 17580
