Compiling Program: C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DUFInternalUpdateProgram.src
Memory Available: 30593183744
1>// *** DUF Auto-Generated Program - For Internal Usage Only! ***
1>// *** Use it to send to a collegue that is working on the same project, ***
1>// *** to update his/her database with database changes you have made. ***
1>    CompilerLevelWarning All On
1>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cApplication.pkg)
1>>>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 20.1\Pkg\windows.x64.pkd)
8163>>>
8163>>>Use LanguageText.pkg
8163>>>Use WinUser.pkg
8163>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files\DataFlex 20.1\Pkg\WinShell.pkg)
8163>>>>>Use DLL.pkg
8163>>>>>
8163>>>>>Define S_OK                                     for |CI$00000000 // Operation successful
8163>>>>>Define E_ABORT                                  for |CI$80004004 // Operation aborted
8163>>>>>Define E_ACCESSDENIED                               for |CI$80070005 // General access denied error 
8163>>>>>Define E_FAIL                                   for |CI$80004005 // Unspecified failure
8163>>>>>Define E_HANDLE                                 for |CI$80070006 // Handle that is not valid
8163>>>>>Define E_INVALIDARG                             for |CI$80070057 // One or more arguments are not valid
8163>>>>>Define E_NOINTERFACE                            for |CI$80004002 // No such interface supported
8163>>>>>Define E_NOTIMPL                                for |CI$80004001 // not implemented
8163>>>>>Define E_OUTOFMEMORY                            for |CI$8007000E // Failed to allocate necessary memory
8163>>>>>Define E_POINTER                                for |CI$80004003 // Pointer that is not valid
8163>>>>>Define E_UNEXPECTED                             for |CI$8000FFFF // Unexpected failure
8163>>>>>
8163>>>>>External_Function PathFileExists "PathFileExistsW" shlwapi.dll ;    WString wsPath ;    Returns Integer // Boolean
8164>>>>>
8164>>>>>External_Function PathIsRelative "PathIsRelativeW" shlwapi.dll ;    WString wsPath ;    Returns Integer // Boolean
8165>>>>>
8165>>>>>// When called directly, be sure to use WString types.
8165>>>>>External_Function PathRemoveExtensionW "PathRemoveExtensionW" shlwapi.dll ;    Pointer lpwPath ;    Returns Integer // void
8166>>>>>
8166>>>>>// Compatibility Wrapper Function PathRemoveExtension
8166>>>>>Function PathRemoveExtension Global ;    Pointer lpPath ;    Returns Integer // Boolean
8168>>>>>    
8168>>>>>    Integer iResult
8168>>>>>    UWide   uwPath
8168>>>>>    UWide   uwPath
8168>>>>>
8168>>>>>    Send StringToWide lpPath (&uwPath)
8169>>>>>                    
8169>>>>>    Move (PathRemoveExtensionW (uwPath.lpUText)) to iResult 
8170>>>>>    
8170>>>>>    Send WideToString (&uwPath) lpPath
8171>>>>>        
8171>>>>>    Function_Return iResult
8172>>>>>End_Function
8173>>>>>
8173>>>>>// When called directly, be sure to use WString types.
8173>>>>>External_Function PathRemoveFileSpecW "PathRemoveFileSpecW" shlwapi.dll ;    Pointer lpwPath ;    Returns Integer
8174>>>>>    
8174>>>>>// Compatibility Wrapper Function PathRemoveFileSpec
8174>>>>>Function PathRemoveFileSpec Global ;    Pointer lpPath ;    Returns Integer // Boolean
8176>>>>>    
8176>>>>>    Integer iResult
8176>>>>>    UWide   uwPath
8176>>>>>    UWide   uwPath
8176>>>>>
8176>>>>>    Send StringToWide lpPath (&uwPath)
8177>>>>>                    
8177>>>>>    Move (PathRemoveFileSpecW (uwPath.lpUText)) to iResult 
8178>>>>>
8178>>>>>    Send WideToString (&uwPath) lpPath
8179>>>>>        
8179>>>>>    Function_Return iResult
8180>>>>>End_Function 
8181>>>>>
8181>>>>>Define URL_UNESCAPE_INPLACE                     for |CI$00100000
8181>>>>>Define URL_UNESCAPE_AS_UTF8                     for |CI$00040000
8181>>>>>Define URL_ESCAPE_SEGMENT_ONLY                  for |CI$00002000
8181>>>>>
8181>>>>>// When called directly, be sure to use WString types.
8181>>>>>External_Function UrlUnescapeW "UrlUnescapeW" shlwapi.dll;    Pointer pszwURL;    Pointer pszwUnescaped;    Pointer pcchUnescaped;    DWord   dwFlags;    Returns Integer // S_OK if succesfull
8182>>>>>
8182>>>>>// Compatibility Wrapper Function UrlUnescape
8182>>>>>Function UrlUnescape Global ;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord   dwFlags;    Returns Integer // S_OK if succesfull
8184>>>>>    
8184>>>>>    Integer iResult
8184>>>>>    UWide   uwUrl uwUnescaped
8184>>>>>    UWide   uwUrl uwUnescaped
8184>>>>>
8184>>>>>    Send StringToWide pszURL (&uwUrl)
8185>>>>>
8185>>>>>    Send WideSetBuffer pszUnescaped pcchUnescaped (&uwUnescaped)
8186>>>>>                        
8186>>>>>    Move (UrlUnescapeW (uwUrl.lpUText, uwUnescaped.lpUText, uwUnescaped.lpSize, dwFlags)) to iResult
8187>>>>>    
8187>>>>>    If (dwFlags = URL_UNESCAPE_INPLACE) Begin
8189>>>>>        Send WideToString (&uwUrl) pszUrl 
8190>>>>>    End
8190>>>>>>
8190>>>>>    Else Begin
8191>>>>>        Send WideToString (&uwUnescaped) pszUnescaped  
8192>>>>>    End    
8192>>>>>>
8192>>>>>    
8192>>>>>    Function_Return iResult
8193>>>>>End_Function  
8194>>>>>
8194>>>>>// When called directly, be sure to use WString types.
8194>>>>>External_Function UrlEscapeW "UrlEscapeW" shlwapi.dll;    Pointer pszwUrl;    Pointer pszwEscaped;    Pointer pcchEscaped;    DWord   dwFlags;    Returns Integer
8195>>>>>    
8195>>>>>// Compatibility Wrapper Function UrlEscape
8195>>>>>Function UrlEscape Global ;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord   dwFlags;    Returns Integer
8197>>>>>    
8197>>>>>    Integer iResult
8197>>>>>    UWide   uwUrl uwEscaped
8197>>>>>    UWide   uwUrl uwEscaped
8197>>>>>
8197>>>>>    Send StringToWide pszURL (&uwUrl)
8198>>>>>
8198>>>>>    Send WideSetBuffer pszEscaped pcchEscaped (&uwEscaped)
8199>>>>>                        
8199>>>>>    Move (UrlEscapeW (uwUrl.lpUText, uwEscaped.lpUText, pcchEscaped, dwFlags)) to iResult
8200>>>>>
8200>>>>>    Send WideToString (&uwEscaped) pszEscaped      
8201>>>>>    
8201>>>>>    Function_Return iResult
8202>>>>>End_Function 
8203>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cWorkspace.pkg)
8203>>>>>Use VdfBase.pkg
8203>>>>>Use tWinStructs.pkg
8203>>>>>Use LanguageText.pkg
8203>>>>>Use WinShell.pkg // Shell API functions
8203>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\seq_chnl.pkg)
8203>>>>>>>Use LanguageText.pkg
8203>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 20.1\Pkg\errornum.inc)
8203>>>>>>>>
8203>>>>>>>>//
8203>>>>>>>>// these will get defined in fmac
8203>>>>>>>>//
8203>>>>>>>>// already defined
8203>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
8203>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
8203>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
8203>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
8203>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
8203>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
8203>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
8203>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
8203>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
8203>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
8203>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
8203>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
8203>>>>>>>>// new compiler errors used by fmac
8203>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
8203>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
8203>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
8203>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
8203>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
8203>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
8203>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
8203>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
8203>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
8203>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
8203>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
8203>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
8203>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
8203>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
8203>>>>>>>>
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_STRING_CMD       |CI4531 // pertaining to string commands
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TYPE_CMD         |CI4532 // pertaining to type/end_type commands
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CMD              |CI4533 // pertaining to a more generic obsolete command 
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_GLOBAL_FUNCTION  |CI4534 // Global function is obsolete
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TECHNIQUE        |CI4535 // Using some older technique
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_PACKAGE          |CI4536 // Package is obsolete, remove it if you can
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CLASS            |CI4537 // Class is obsolete, remove it if you can
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_INDICATOR_USE    |CI4538 // Using indicators anywhere
8203>>>>>>>>//    
8203>>>>>>>>//    #Replace DFERR_COMP_ILLEGAL_CONVERSION                            |CI4539 // Datatype conversion is illegal, would cause runtime-error
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_OBJECT_FUNCTION  |CI4540 // Global function is obsolete
8203>>>>>>>>//    #Replace DFERR_INVALID_LOCALE_CODE                    |CI4541 // Error thown by Set_Attribute DF_LOCALE_CODE on invalid value
8203>>>>>>>>//    #Replace DFERR_STRING_COMPARISON_ERROR                |CI4542 // Error during string comparison (ICU returned an error)
8203>>>>>>>>//    #Replace DFERR_COMP_WARNING_REDEFINING_RETURN_TYPE    |CI4543 // Warning when redefining a function with a different return type
8203>>>>>>>>//    #Replace DFERR_COMP_AMBIGUOUS_FUNCTION_EXPRESSION     |CI4544 // Error when using ambiguous function in expression
8203>>>>>>>>    
8203>>>>>>>>
8203>>>>>>>>
8203>>>>>>>
8203>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8203>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8203>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8203>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8203>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8203>>>>>>>// so that programs that use direct_input/output
8203>>>>>>>// w/o specifying a channel will work.
8203>>>>>>>Enum_List
8203>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8203>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8203>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8203>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8203>>>>>>>End_Enum_List
8203>>>>>>>
8203>>>>>>>Enum_List
8203>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8203>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8203>>>>>>>End_Enum_List
8203>>>>>>>
8203>>>>>>>Integer Seq$Channel$Error$Mode
8203>>>>>>>
8203>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
8205>>>>>>>    Move Mode to Seq$Channel$Error$Mode
8206>>>>>>>End_Procedure
8207>>>>>>>
8207>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8209>>>>>>>    Function_Return Seq$Channel$Error$Mode
8210>>>>>>>End_Function
8211>>>>>>>
8211>>>>>>>Object Seq_Channel_List is an Array
8213>>>>>>>    Procedure Initialize
8216>>>>>>>        Integer Itm
8216>>>>>>>        
8216>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
8217>>>>>>>        
8217>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
8221>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
8222>>>>>>>            Increment Itm
8223>>>>>>>        Loop
8224>>>>>>>>
8224>>>>>>>    End_Procedure
8225>>>>>>>    
8225>>>>>>>    Send Initialize
8226>>>>>>>End_Object
8227>>>>>>>
8227>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8228>>>>>>>
8228>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
8230>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
8231>>>>>>>End_Function
8232>>>>>>>
8232>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
8234>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
8235>>>>>>>End_Procedure
8236>>>>>>>
8236>>>>>>>Function Seq_New_Channel Global Returns Integer
8238>>>>>>>    Integer Obj Chnl
8238>>>>>>>    
8238>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
8239>>>>>>>    
8239>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
8243>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8245>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
8246>>>>>>>            Function_Return Chnl
8247>>>>>>>        End
8247>>>>>>>>
8247>>>>>>>        
8247>>>>>>>        Increment Chnl
8248>>>>>>>    Loop
8249>>>>>>>>
8249>>>>>>>    
8249>>>>>>>    // wrap back to beginning
8249>>>>>>>    Move 0 to Chnl
8250>>>>>>>    
8250>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
8254>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8256>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
8257>>>>>>>            Function_Return Chnl
8258>>>>>>>        End
8258>>>>>>>>
8258>>>>>>>        
8258>>>>>>>        Increment Chnl
8259>>>>>>>    Loop
8260>>>>>>>>
8260>>>>>>>    
8260>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8261>>>>>>>End_Function
8262>>>>>>>
8262>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
8264>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
8267>>>>>>>End_Procedure
8268>>>>>>>
8268>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
8270>>>>>>>    Integer Chnl
8270>>>>>>>    
8270>>>>>>>    Move (Seq_New_Channel()) to Chnl
8271>>>>>>>    
8271>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8273>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
8276>>>>>>>        Function_Return Chnl
8277>>>>>>>    End
8277>>>>>>>>
8277>>>>>>>    
8277>>>>>>>    Move False to Err
8278>>>>>>>    Direct_Input channel Chnl Dvc
8280>>>>>>>    
8280>>>>>>>    If (Err) Begin
8282>>>>>>>        Send Seq_Release_Channel Chnl
8283>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8284>>>>>>>    End
8284>>>>>>>>
8284>>>>>>>    
8284>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
8285>>>>>>>    
8285>>>>>>>    Function_Return Chnl
8286>>>>>>>End_Function
8287>>>>>>>
8287>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
8289>>>>>>>    Integer Chnl
8289>>>>>>>    
8289>>>>>>>    Move (Seq_New_Channel()) to Chnl
8290>>>>>>>    
8290>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8292>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8294>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
8295>>>>>>>>
8295>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
8296>>>>>>>        End
8296>>>>>>>>
8296>>>>>>>        
8296>>>>>>>        Function_Return Chnl
8297>>>>>>>    End
8297>>>>>>>>
8297>>>>>>>    
8297>>>>>>>    Move False to Err
8298>>>>>>>    Direct_Output channel Chnl Dvc
8300>>>>>>>    
8300>>>>>>>    If (Err) Begin
8302>>>>>>>        Send Seq_Release_Channel Chnl
8303>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8304>>>>>>>    End
8304>>>>>>>>
8304>>>>>>>    
8304>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
8305>>>>>>>    
8305>>>>>>>    Function_Return Chnl
8306>>>>>>>End_Function
8307>>>>>>>
8307>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
8309>>>>>>>    Integer Chnl
8309>>>>>>>    
8309>>>>>>>    Move (Seq_New_Channel()) to Chnl
8310>>>>>>>    
8310>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
8312>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8314>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
8315>>>>>>>>
8315>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
8316>>>>>>>        End
8316>>>>>>>>
8316>>>>>>>        
8316>>>>>>>        Function_Return Chnl
8317>>>>>>>    End
8317>>>>>>>>
8317>>>>>>>    
8317>>>>>>>    Move False to Err
8318>>>>>>>    Append_Output channel Chnl Dvc
8320>>>>>>>    
8320>>>>>>>    If (Err) Begin
8322>>>>>>>        Send Seq_Release_Channel Chnl
8323>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8324>>>>>>>    End
8324>>>>>>>>
8324>>>>>>>    
8324>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
8325>>>>>>>    
8325>>>>>>>    Function_Return Chnl
8326>>>>>>>End_Function
8327>>>>>>>
8327>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
8329>>>>>>>    Integer Mode
8329>>>>>>>    
8329>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
8331>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
8332>>>>>>>        
8332>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
8336>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
8341>>>>>>>        // If channel not open, release it! No (fatal) Error.
8341>>>>>>>        Send Seq_Release_Channel Chnl
8342>>>>>>>    End
8342>>>>>>>>
8342>>>>>>>End_Procedure
8343>>>>>>>
8343>>>>>Use GlobalFunctionsProcedures.pkg
8343>>>>>
8343>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8343>>>>>Register_Function VdfSystemDfPath   Returns String
8343>>>>>Register_Function VdfSystemMakePath Returns String
8343>>>>>
8343>>>>>Enum_List
8343>>>>>    Define wsWorkspaceOpened       // WS opened ok
8343>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8343>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8343>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8343>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8343>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8343>>>>>End_Enum_List
8343>>>>>
8343>>>>>
8343>>>>>Define INVALID_HANDLE_VALUE for -1
8343>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8343>>>>>
8343>>>>>
8343>>>>>// Wide version
8343>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8344>>>>>
8344>>>>>// Wrapper Function winFindFirstFile
8344>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8346>>>>>    
8346>>>>>    Handle  hResult
8346>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8346>>>>>    Integer iSizeOfStructWithoutStrings
8346>>>>>    String  sFileName sAlternateFileName
8346>>>>>    WString wFileName wAlternateFileName
8346>>>>>    Pointer pWFD
8346>>>>>    tWin32FindDataW tWFD
8346>>>>>    tWin32FindDataW tWFD
8346>>>>>    
8346>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8346>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8346>>>>>
8346>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8347>>>>>    Move (AddressOf(tWFD)) to pWFD
8348>>>>>    
8348>>>>>    // Call the function
8348>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8349>>>>>
8349>>>>>    // Copy the struct contents back to the incoming one.
8349>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8350>>>>>    
8350>>>>>    // But do the strings separately and convert them to UTF8
8350>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8351>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8352>>>>>    
8352>>>>>    // Extend string with 0 to the maximum number of characters
8352>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8355>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8358>>>>>        
8358>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8359>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8360>>>>>    
8360>>>>>    Function_Return hResult
8361>>>>>End_Function
8362>>>>>
8362>>>>>// When used directly, be sure to use WString types (UTF16).
8362>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8363>>>>>
8363>>>>>// Wrapper Function winFindNextFile
8363>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8365>>>>>    
8365>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8365>>>>>    Integer iSizeOfStructWithoutStrings
8365>>>>>    String  sFileName sAlternateFileName
8365>>>>>    WString wFileName wAlternateFileName
8365>>>>>    Pointer pWFD
8365>>>>>    tWin32FindDataW tWFD
8365>>>>>    tWin32FindDataW tWFD
8365>>>>>
8365>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8365>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8365>>>>>
8365>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8365>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8366>>>>>    Move (AddressOf(tWFD)) to pWFD
8367>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8368>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8368>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8369>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8370>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8371>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8372>>>>>    
8372>>>>>    // Call the function
8372>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8373>>>>>
8373>>>>>    // Copy the struct contents back to the incoming one.
8373>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8374>>>>>    
8374>>>>>    // But do the strings separately and convert them to UTF8
8374>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8375>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8376>>>>>    
8376>>>>>    // Extend string with 0 to the maximum number of characters
8376>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8379>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8382>>>>>        
8382>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8383>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8384>>>>>    
8384>>>>>    Function_Return iResult
8385>>>>>End_Function
8386>>>>>
8386>>>>>
8386>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8387>>>>>
8387>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8389>>>>>    tWin32FindDataW Win32FindData
8389>>>>>    tWin32FindDataW Win32FindData
8389>>>>>    String sMask
8389>>>>>    Integer iVoid
8389>>>>>    Handle hFileFind
8389>>>>>    
8389>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8390>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8392>>>>>        Move (winFindClose(hFileFind)) to iVoid
8393>>>>>    End
8393>>>>>>
8393>>>>>    
8393>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8394>>>>>End_Function
8395>>>>>
8395>>>>>
8395>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cIniFile.pkg)
8395>>>>>>>Use Dll.pkg
8395>>>>>>>Use errornum.inc
8395>>>>>>>Use LanguageText.pkg
8395>>>>>>>Use GlobalFunctionsProcedures.pkg
8395>>>>>>>Use seq_chnl.pkg
8395>>>>>>>Use CharTranslate.pkg
8395>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCharTranslate.pkg)
8395>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Variant.pkg)
8395>>>>>>>>>>>Use ui
8395>>>>>>>>>>>Use errornum.inc
8395>>>>>>>>>>>
8395>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8395>>>>>>>>>>>
8395>>>>>>>>>>>
8395>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8396>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8397>>>>>>>>>>>
8397>>>>>>>>>>>// Returns the character length of the variant string. 
8397>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8399>>>>>>>>>>>    Pointer pVariant
8399>>>>>>>>>>>    Integer iLen iType
8399>>>>>>>>>>>
8399>>>>>>>>>>>    Move (AddressOf(bStr)) to pVariant
8400>>>>>>>>>>>    Move (DeRefW(pVariant,0)) to iType
8401>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8403>>>>>>>>>>>        Function_Return 0
8404>>>>>>>>>>>    End
8404>>>>>>>>>>>>
8404>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8406>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8407>>>>>>>>>>>>
8407>>>>>>>>>>>        Function_Return 0
8408>>>>>>>>>>>    End
8408>>>>>>>>>>>>
8408>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(pVariant,8))) to iLen
8409>>>>>>>>>>>    Function_Return iLen
8410>>>>>>>>>>>End_Function
8411>>>>>>>>>>>
8411>>>>>>>>>>>
8411>>>>>>>>>>>// returns true if char string in the buffer can fit into a string.
8411>>>>>>>>>>>// Changed this to always return True, because the Max_Argument_Size limitation has been removed.
8411>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8413>>>>>>>>>>>    Function_Return True
8414>>>>>>>>>>>End_Function
8415>>>>>>>>>>>    
8415>>>>>>>>>Use CharTranslate.pkg
8415>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8415>>>>>>>>>
8415>>>>>>>>>// special for UTF16, which is really not a code page at all
8415>>>>>>>>>Define CP_UTF16 for -1
8415>>>>>>>>>
8415>>>>>>>>>Class cCharTranslate is a cObject
8416>>>>>>>>>    
8416>>>>>>>>>    
8416>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8416>>>>>>>>>    
8416>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8416>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8416>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8418>>>>>>>>>        Pointer pWideBuf
8418>>>>>>>>>        Integer iWideBufLen iStrLen
8418>>>>>>>>>        Move 0 to pWideBuf
8419>>>>>>>>>        Move 0 to iLen
8420>>>>>>>>>        If (pMultiCharBuffer) Begin
8422>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8423>>>>>>>>>            If (iStrLen) Begin
8425>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8426>>>>>>>>>                If (iLen=0) Begin
8428>>>>>>>>>                    Function_Return 0
8429>>>>>>>>>                End
8429>>>>>>>>>>
8429>>>>>>>>>            End
8429>>>>>>>>>>
8429>>>>>>>>>        End
8429>>>>>>>>>>
8429>>>>>>>>>        Function_Return pWideBuf
8430>>>>>>>>>    End_Function
8431>>>>>>>>>    
8431>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8433>>>>>>>>>        Pointer pValue
8433>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8434>>>>>>>>>        Function_Return pValue
8435>>>>>>>>>    End_Function
8436>>>>>>>>>    
8436>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8436>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8436>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8438>>>>>>>>>        Pointer pRetBuf
8438>>>>>>>>>        Integer iRetBufLen
8438>>>>>>>>>        Move 0 to pRetBuf
8439>>>>>>>>>        If (pWideBuf and iLen) Begin
8441>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8442>>>>>>>>>            If (iRetBufLen=0) Begin
8444>>>>>>>>>                Function_Return 0
8445>>>>>>>>>            End
8445>>>>>>>>>>
8445>>>>>>>>>        End
8445>>>>>>>>>>
8445>>>>>>>>>        Function_Return pRetBuf
8446>>>>>>>>>    End_Function
8447>>>>>>>>>    
8447>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8449>>>>>>>>>        String sValue
8449>>>>>>>>>        Pointer pValue
8449>>>>>>>>>        Boolean bOk
8449>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8450>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8452>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8453>>>>>>>>>>
8453>>>>>>>>>        End
8453>>>>>>>>>>
8453>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8454>>>>>>>>>        Move (Free(pValue)) to bOk
8455>>>>>>>>>        Function_Return sValue
8456>>>>>>>>>    End_Function
8457>>>>>>>>>    
8457>>>>>>>>>    
8457>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8457>>>>>>>>>    
8457>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8459>>>>>>>>>        Pointer pWideBuf
8459>>>>>>>>>        Pointer pUtf8Buf
8459>>>>>>>>>        Integer iLen iMultiBufLen
8459>>>>>>>>>        Boolean bOk
8459>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8460>>>>>>>>>        If (iLen=0) Begin
8462>>>>>>>>>            Function_Return 0
8463>>>>>>>>>        End
8463>>>>>>>>>>
8463>>>>>>>>>        Move 0 to pUtf8Buf
8464>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8465>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8466>>>>>>>>>        Function_Return pUtf8Buf
8467>>>>>>>>>    End_Function
8468>>>>>>>>>    
8468>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8470>>>>>>>>>        Pointer pValue
8470>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8471>>>>>>>>>        Function_Return pValue
8472>>>>>>>>>    End_Function
8473>>>>>>>>>    
8473>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8475>>>>>>>>>        Pointer pRetBuf pWideBuf
8475>>>>>>>>>        Integer iWideBufLen
8475>>>>>>>>>        Integer iRetBufLen
8475>>>>>>>>>        Boolean bOk
8475>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8476>>>>>>>>>        If (iWideBufLen=0) Begin
8478>>>>>>>>>            Function_Return 0
8479>>>>>>>>>        End
8479>>>>>>>>>>
8479>>>>>>>>>        Move 0 to pRetBuf
8480>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8481>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8482>>>>>>>>>        Function_Return pRetBuf
8483>>>>>>>>>    End_Function
8484>>>>>>>>>    
8484>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8486>>>>>>>>>        String sValue
8486>>>>>>>>>        Pointer pValue
8486>>>>>>>>>        Boolean bOk
8486>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8487>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8489>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8490>>>>>>>>>>
8490>>>>>>>>>        End
8490>>>>>>>>>>
8490>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8491>>>>>>>>>        Move (Free(pValue)) to bOk
8492>>>>>>>>>        Function_Return sValue
8493>>>>>>>>>    End_Function
8494>>>>>>>>>    
8494>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8494>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8494>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8494>>>>>>>>>    
8494>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8494>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8496>>>>>>>>>        Pointer pBSTR pRetStr
8496>>>>>>>>>        Integer iLen iBufLen
8496>>>>>>>>>        Boolean bOk
8496>>>>>>>>>        Move 0 to pRetStr
8497>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8498>>>>>>>>>        If (iLen) Begin
8500>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8501>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8502>>>>>>>>>        End
8502>>>>>>>>>>
8502>>>>>>>>>        Function_Return pRetStr
8503>>>>>>>>>    End_Function
8504>>>>>>>>>    
8504>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8504>>>>>>>>>    
8504>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8506>>>>>>>>>        String sValue
8506>>>>>>>>>        Pointer pValue
8506>>>>>>>>>        Boolean bOk
8506>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8507>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8509>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8510>>>>>>>>>>
8510>>>>>>>>>        End
8510>>>>>>>>>>
8510>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8511>>>>>>>>>        Move (Free(pValue)) to bOk
8512>>>>>>>>>        Function_Return sValue
8513>>>>>>>>>    End_Function
8514>>>>>>>>>    
8514>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8514>>>>>>>>>    
8514>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8516>>>>>>>>>        Variant vValue
8516>>>>>>>>>        Pointer pvValue
8516>>>>>>>>>        Boolean bOk
8516>>>>>>>>>        Pointer pWStr
8516>>>>>>>>>        Move "" to vValue
8517>>>>>>>>>        If (pSource) Begin
8519>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8519>>>>>>>>>            Move 0 to pWStr
8520>>>>>>>>>            //Convert the Ansi string to Unicode
8520>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8521>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8521>>>>>>>>>            Move 0 to vValue
8522>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8523>>>>>>>>>            //Change the Variant type to VT_BSTR
8523>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8524>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8524>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8525>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8525>>>>>>>>>            Move (Free(pWStr)) to bOk
8526>>>>>>>>>        End
8526>>>>>>>>>>
8526>>>>>>>>>        Function_Return vValue
8527>>>>>>>>>    End_Function
8528>>>>>>>>>    
8528>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8528>>>>>>>>>    
8528>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8530>>>>>>>>>        Variant vValue
8530>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8531>>>>>>>>>        Function_Return vValue
8532>>>>>>>>>    End_Function
8533>>>>>>>>>    
8533>>>>>>>>>    // Create buffer of utf16 data from variant.
8533>>>>>>>>>    // Returns newly created memory address and length (by reference)
8533>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8535>>>>>>>>>        Pointer pBSTR pRetStr
8535>>>>>>>>>        Boolean bOk
8535>>>>>>>>>        Move 0 to pRetStr
8536>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8537>>>>>>>>>        If (iLen) Begin
8539>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8540>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8541>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8542>>>>>>>>>        End
8542>>>>>>>>>>
8542>>>>>>>>>        Function_Return pRetStr
8543>>>>>>>>>    End_Function
8544>>>>>>>>>    
8544>>>>>>>>>    // Create variant from buffer of utf16 data
8544>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8546>>>>>>>>>        Variant vValue
8546>>>>>>>>>        Pointer pvValue
8546>>>>>>>>>        Boolean bOk
8546>>>>>>>>>        Move "" to vValue
8547>>>>>>>>>        If (pSource) Begin
8549>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8549>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8549>>>>>>>>>            Move 0 to vValue
8550>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8551>>>>>>>>>            //Change the Variant type to VT_BSTR
8551>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8552>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8552>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8553>>>>>>>>>        End
8553>>>>>>>>>>
8553>>>>>>>>>        Function_Return vValue
8554>>>>>>>>>    End_Function
8555>>>>>>>>>    
8555>>>>>>>>>    // Create Uchar array from variant string.
8555>>>>>>>>>    // Data buffer is encoded by eCharType
8555>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8557>>>>>>>>>        Pointer pBSTR pRetStr
8557>>>>>>>>>        Integer iLen iBufLen
8557>>>>>>>>>        Boolean bOk
8557>>>>>>>>>        UChar[] UC1
8558>>>>>>>>>        Move 0 to pRetStr
8559>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8560>>>>>>>>>        If (iLen) Begin
8562>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8563>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8565>>>>>>>>>                Move (iLen*2) to iBufLen
8566>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8567>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8568>>>>>>>>>            End
8568>>>>>>>>>>
8568>>>>>>>>>            Else Begin
8569>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8570>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8571>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8572>>>>>>>>>                Move (Free(pRetStr)) to bOk
8573>>>>>>>>>            End
8573>>>>>>>>>>
8573>>>>>>>>>        End
8573>>>>>>>>>>
8573>>>>>>>>>        Function_Return UC1
8574>>>>>>>>>    End_Function
8575>>>>>>>>>    
8575>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8575>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8577>>>>>>>>>        Variant vValue
8577>>>>>>>>>        Pointer pvValue
8577>>>>>>>>>        Boolean bOk
8577>>>>>>>>>        Pointer pWStr
8577>>>>>>>>>        Move "" to vValue
8578>>>>>>>>>        
8578>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8578>>>>>>>>>        Move 0 to pWStr
8579>>>>>>>>>        //Convert the Ansi string to Unicode
8579>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8581>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8582>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8583>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8584>>>>>>>>>        End
8584>>>>>>>>>>
8584>>>>>>>>>        Else Begin
8585>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8586>>>>>>>>>        End
8586>>>>>>>>>>
8586>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8586>>>>>>>>>        Move 0 to vValue
8587>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8588>>>>>>>>>        //Change the Variant type to VT_BSTR
8588>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8589>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8589>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8590>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8590>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8592>>>>>>>>>            Move (Free(pWStr)) to bOk
8593>>>>>>>>>        End
8593>>>>>>>>>>
8593>>>>>>>>>        Function_Return vValue
8594>>>>>>>>>    End_Function
8595>>>>>>>>>    
8595>>>>>>>>>    
8595>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8595>>>>>>>>>    // a new UChar array with to-encoding
8595>>>>>>>>>    
8595>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8597>>>>>>>>>        Pointer pFromBuf pToBuf
8597>>>>>>>>>        Integer iBytes iChars
8597>>>>>>>>>        Boolean bOk
8597>>>>>>>>>        
8597>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8598>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8600>>>>>>>>>            Function_Return UCharData
8601>>>>>>>>>        End
8601>>>>>>>>>>
8601>>>>>>>>>        
8601>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8603>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8604>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8605>>>>>>>>>        End
8605>>>>>>>>>>
8605>>>>>>>>>        Else Begin
8606>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8607>>>>>>>>>        End
8607>>>>>>>>>>
8607>>>>>>>>>        
8607>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8609>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8611>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8612>>>>>>>>>            End
8612>>>>>>>>>>
8612>>>>>>>>>            Else Begin
8613>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8614>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8615>>>>>>>>>            End
8615>>>>>>>>>>
8615>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8616>>>>>>>>>        End
8616>>>>>>>>>>
8616>>>>>>>>>        Else Begin
8617>>>>>>>>>            Move (iChars*2) to iBytes
8618>>>>>>>>>            Move pFromBuf to pToBuf
8619>>>>>>>>>        End
8619>>>>>>>>>>
8619>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8620>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8621>>>>>>>>>        Move (Free(pToBuf)) to bOk
8622>>>>>>>>>        Function_Return UCharData
8623>>>>>>>>>    End_Function
8624>>>>>>>>>    
8624>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8624>>>>>>>>>    // Variant strings. Binary data is always buffer
8624>>>>>>>>>    
8624>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8626>>>>>>>>>        Pointer pBase64
8626>>>>>>>>>        String sResult
8626>>>>>>>>>        Integer iVoid
8626>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8627>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8628>>>>>>>>>        Move (Free(pBase64)) to iVoid
8629>>>>>>>>>        Function_Return sResult
8630>>>>>>>>>    End_Function
8631>>>>>>>>>    
8631>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8633>>>>>>>>>        Pointer pBinaryData
8633>>>>>>>>>        String sBinary
8633>>>>>>>>>        Integer iVoid
8633>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8634>>>>>>>>>        Function_Return pBinaryData
8635>>>>>>>>>    End_Function
8636>>>>>>>>>    
8636>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8638>>>>>>>>>        Pointer pBase64
8638>>>>>>>>>        Variant vVar
8638>>>>>>>>>        Integer iBase64Len iVoid
8638>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8640>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8641>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8642>>>>>>>>>            Move (Free(pBase64)) to iVoid
8643>>>>>>>>>        End
8643>>>>>>>>>>
8643>>>>>>>>>        Function_Return vVar
8644>>>>>>>>>    End_Function
8645>>>>>>>>>    
8645>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8647>>>>>>>>>        Pointer pBase64 pBinaryData
8647>>>>>>>>>        Integer iVoid
8647>>>>>>>>>        Move 0 to iBinaryLen
8648>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8649>>>>>>>>>        If (pBase64) Begin
8651>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8652>>>>>>>>>            Move (Free(pBase64)) to iVoid
8653>>>>>>>>>        End
8653>>>>>>>>>>
8653>>>>>>>>>        Function_Return pBinaryData
8654>>>>>>>>>    End_Function
8655>>>>>>>>>    
8655>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8655>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8657>>>>>>>>>        Pointer pBase64
8657>>>>>>>>>        Integer iLen
8657>>>>>>>>>        Boolean bOk
8657>>>>>>>>>        
8657>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8658>>>>>>>>>        If (iLen) Begin
8660>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8661>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8662>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8663>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8664>>>>>>>>>            Move (Free(pBase64)) to bOk
8665>>>>>>>>>        End
8665>>>>>>>>>>
8665>>>>>>>>>        Function_Return UCharData
8666>>>>>>>>>    End_Function
8667>>>>>>>>>    
8667>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8667>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8669>>>>>>>>>        Pointer pData
8669>>>>>>>>>        Integer iLen
8669>>>>>>>>>        Boolean bOk
8669>>>>>>>>>        
8669>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8670>>>>>>>>>        If (iLen) Begin
8672>>>>>>>>>            Move 0 to UCharData[iLen]
8673>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8674>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8675>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8676>>>>>>>>>            Move (Free(pData)) to bOk
8677>>>>>>>>>        End
8677>>>>>>>>>>
8677>>>>>>>>>        Function_Return UCharData
8678>>>>>>>>>    End_Function
8679>>>>>>>>>    
8679>>>>>>>>>End_Class
8680>>>>>>>>>
8680>>>>>>>>>
8680>>>>>>>
8680>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8680>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8680>>>>>>>
8680>>>>>>>
8680>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8681>>>>>>>
8681>>>>>>>
8681>>>>>>>// When called directly, be sure to use WString types.
8681>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8682>>>>>>>
8682>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8683>>>>>>>    
8683>>>>>>>// When called directly, be sure to use String types.
8683>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8684>>>>>>>    
8684>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8684>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8684>>>>>>>    
8684>>>>>>>
8684>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8684>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8686>>>>>>>    
8686>>>>>>>    Integer iResult
8686>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8686>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8686>>>>>>>
8686>>>>>>>    Send StringToWide pSection (&uwSection)
8687>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8688>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8689>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8690>>>>>>>                           
8690>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8691>>>>>>>       
8691>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8692>>>>>>>        
8692>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8693>>>>>>>    
8693>>>>>>>    Function_Return iResult
8694>>>>>>>End_Function
8695>>>>>>> 
8695>>>>>>>
8695>>>>>>>Class cIniFile is a cObject
8696>>>>>>>    Procedure Construct_Object
8698>>>>>>>        Forward Send Construct_Object
8700>>>>>>>        
8700>>>>>>>        
8700>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8700>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8700>>>>>>>        Property Boolean pbWideAPI True
8701>>>>>>>        
8701>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8701>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8701>>>>>>>        // converted on first write (WriteString).
8701>>>>>>>        Property Boolean pbStoreAsUTF16 False
8702>>>>>>>        
8702>>>>>>>        Property String psPrivate_FileName ""
8703>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8704>>>>>>>    End_Procedure
8705>>>>>>>    
8705>>>>>>>    Procedure Set psFileName String sVal
8707>>>>>>>        Set pbPrivate_FirstWrite to True
8708>>>>>>>        Set psPrivate_FileName to sVal
8709>>>>>>>    End_Procedure
8710>>>>>>>    
8710>>>>>>>    Function psFileName Returns String
8712>>>>>>>        Function_Return (psPrivate_FileName(Self))
8713>>>>>>>    End_Function
8714>>>>>>>    
8714>>>>>>>    Procedure InitFile
8716>>>>>>>        Boolean bExists bHasBom
8716>>>>>>>        Integer iChnl
8716>>>>>>>        UChar[] ucData
8717>>>>>>>        Handle hoTranslate
8717>>>>>>>        
8717>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8719>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8720>>>>>>>            If (not(bExists)) Begin
8722>>>>>>>                //  Create the file with a UTF-16 BOM so
8722>>>>>>>                Move (Seq_New_Channel()) to iChnl
8723>>>>>>>                Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8725>>>>>>>                Write channel iChnl C_BOM_UTF16LE
8727>>>>>>>                Close_Output channel iChnl
8729>>>>>>>                Send Seq_Release_Channel iChnl
8730>>>>>>>            End
8730>>>>>>>>
8730>>>>>>>            Else Begin
8731>>>>>>>                //  Check for BOM
8731>>>>>>>                Move (Seq_New_Channel()) to iChnl
8732>>>>>>>                Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8734>>>>>>>                Read_Block channel iChnl ucData 2
8736>>>>>>>                
8736>>>>>>>                Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8737>>>>>>>                
8737>>>>>>>                //  If no BOM we'll have to read the entire file to convert it
8737>>>>>>>                If (not(bHasBom)) Begin
8739>>>>>>>                    Set_Channel_Position iChnl to 0
8740>>>>>>>>
8740>>>>>>>                    Read_Block ucData -1
8741>>>>>>>                End
8741>>>>>>>>
8741>>>>>>>
8741>>>>>>>                Close_Input channel iChnl
8743>>>>>>>                
8743>>>>>>>                If (not(bHasBom)) Begin
8745>>>>>>>                    //  Convert thedata
8745>>>>>>>                    Get Create (RefClass(cCharTranslate)) to hoTranslate
8746>>>>>>>                    Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8747>>>>>>>                    
8747>>>>>>>                    //  Write out the UTF 16 file with BOM
8747>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8749>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8751>>>>>>>                    
8751>>>>>>>                    Write channel iChnl ucData
8753>>>>>>>                    
8753>>>>>>>                    Close_Output channel iChnl
8755>>>>>>>                    
8755>>>>>>>                    Send Destroy of hoTranslate
8756>>>>>>>                End
8756>>>>>>>>
8756>>>>>>>                
8756>>>>>>>                Send Seq_Release_Channel iChnl
8757>>>>>>>            End
8757>>>>>>>>
8757>>>>>>>            
8757>>>>>>>            Set pbPrivate_FirstWrite to False
8758>>>>>>>        End
8758>>>>>>>>
8758>>>>>>>    End_Procedure
8759>>>>>>>    
8759>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8761>>>>>>>        Boolean bSuccess
8761>>>>>>>        String sFileName
8761>>>>>>>        
8761>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8763>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8764>>>>>>>>
8764>>>>>>>            Procedure_Return
8765>>>>>>>        End
8765>>>>>>>>
8765>>>>>>>        
8765>>>>>>>        Send InitFile
8766>>>>>>>        
8766>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8766>>>>>>>        If (pbWideAPI(Self)) Begin
8768>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8769>>>>>>>        End
8769>>>>>>>>
8769>>>>>>>        Else Begin
8770>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8771>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8772>>>>>>>        End
8772>>>>>>>>
8772>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8775>>>>>>>    End_Procedure
8776>>>>>>>    
8776>>>>>>>    
8776>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8778>>>>>>>        Integer iNumChars iSizeValue
8778>>>>>>>        WString wValue wFileName wSection wKey wDefault
8778>>>>>>>        String sFileName sValue
8778>>>>>>>        
8778>>>>>>>        Move 2047 to iSizeValue
8779>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8780>>>>>>>        
8780>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8782>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8783>>>>>>>>
8783>>>>>>>            Function_Return ''
8784>>>>>>>        End
8784>>>>>>>>
8784>>>>>>>        
8784>>>>>>>        If (pbWideAPI(Self)) Begin
8786>>>>>>>            Move sSection to wSection
8787>>>>>>>            Move sKey to wKey
8788>>>>>>>            Move sDefault to wDefault
8789>>>>>>>            Move sValue to wValue
8790>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8791>>>>>>>            Move wValue to sValue
8792>>>>>>>        End
8792>>>>>>>>
8792>>>>>>>        Else Begin
8793>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8794>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8795>>>>>>>        End
8795>>>>>>>>
8795>>>>>>>        
8795>>>>>>>        Function_Return  (CString(sValue))
8796>>>>>>>    End_Function
8797>>>>>>>    
8797>>>>>>>    Function SectionExists String sSection Returns Boolean
8799>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8799>>>>>>>        Handle hoKeys
8799>>>>>>>        Integer icKey iKey
8799>>>>>>>        
8799>>>>>>>        Get Create U_ARRAY to hoKeys
8800>>>>>>>        Send ReadSection sSection hoKeys
8801>>>>>>>        Get Item_Count of hoKeys to icKey
8802>>>>>>>        Send Destroy of hoKeys
8803>>>>>>>        
8803>>>>>>>        Function_Return (icKey >0)
8804>>>>>>>    End_Function
8805>>>>>>>    
8805>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8807>>>>>>>        Integer iNumChars iSizeValue iPos
8807>>>>>>>        Pointer lpsKeys
8807>>>>>>>        WString wKeys wKey
8807>>>>>>>        
8807>>>>>>>        Move 16384 to iSizeValue
8808>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wKeys
8809>>>>>>>        
8809>>>>>>>        Move (AddressOf(wKeys)) to lpsKeys
8810>>>>>>>        
8810>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8812>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8813>>>>>>>>
8813>>>>>>>            Procedure_Return
8814>>>>>>>        End
8814>>>>>>>>
8814>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8814>>>>>>>        Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8815>>>>>>>        If (iNumChars >0) Begin
8817>>>>>>>            Repeat
8817>>>>>>>>
8817>>>>>>>                Move (Pos(Character(0),wKeys)) to iPos
8818>>>>>>>                If (iPos >1) Begin
8820>>>>>>>                    Move (Left(wKeys,iPos -1))  to wKey
8821>>>>>>>                    Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8822>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to wKey
8823>>>>>>>                End
8823>>>>>>>>
8823>>>>>>>            Until (iPos <=1)
8825>>>>>>>        End
8825>>>>>>>>
8825>>>>>>>    End_Procedure
8826>>>>>>>    
8826>>>>>>>    Procedure ReadSections Handle hoArray
8828>>>>>>>        Integer iNumChars iSizeValue iPos
8828>>>>>>>        Pointer lpwSections
8828>>>>>>>        WString wSections
8828>>>>>>>        String sSection
8828>>>>>>>        
8828>>>>>>>        Move 16384 to iSizeValue
8829>>>>>>>        
8829>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8830>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8831>>>>>>>        
8831>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8833>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8834>>>>>>>>
8834>>>>>>>            Procedure_Return
8835>>>>>>>        End
8835>>>>>>>>
8835>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8835>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8836>>>>>>>        If (iNumChars >0) Begin
8838>>>>>>>            Repeat
8838>>>>>>>>
8838>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8839>>>>>>>                If (iPos >1) Begin
8841>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8842>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8843>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8844>>>>>>>                End
8844>>>>>>>>
8844>>>>>>>            Until (iPos <=1)
8846>>>>>>>        End
8846>>>>>>>>
8846>>>>>>>        
8846>>>>>>>    End_Procedure
8847>>>>>>>    
8847>>>>>>>    Procedure DeleteSection String sSection
8849>>>>>>>        
8849>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8851>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8852>>>>>>>>
8852>>>>>>>            Procedure_Return
8853>>>>>>>        End
8853>>>>>>>>
8853>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8856>>>>>>>    End_Procedure
8857>>>>>>>    
8857>>>>>>>    Procedure DeleteKey String sSection String sKey
8859>>>>>>>        Integer iVoid
8859>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8861>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8862>>>>>>>>
8862>>>>>>>            Procedure_Return
8863>>>>>>>        End
8863>>>>>>>>
8863>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8864>>>>>>>    End_Procedure
8865>>>>>>>    
8865>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
8867>>>>>>>        Handle hoKeys
8867>>>>>>>        Integer iKey
8867>>>>>>>        Boolean bExists
8867>>>>>>>        
8867>>>>>>>        Move (False) to bExists
8868>>>>>>>        
8868>>>>>>>        Move (Uppercase(sKey)) to sKey
8869>>>>>>>        
8869>>>>>>>        Get Create U_ARRAY to hoKeys
8870>>>>>>>        
8870>>>>>>>        Send ReadSection sSection hoKeys
8871>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
8877>>>>>>>>
8877>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
8879>>>>>>>                Move (True) to bExists
8880>>>>>>>            End
8880>>>>>>>>
8880>>>>>>>        Loop
8881>>>>>>>>
8881>>>>>>>        
8881>>>>>>>        Send Destroy of hoKeys
8882>>>>>>>        
8882>>>>>>>        Function_Return bExists
8883>>>>>>>    End_Function
8884>>>>>>>    
8884>>>>>>>End_Class
8885>>>>>
8885>>>>>Class cWorkspace is a cObject
8886>>>>>    
8886>>>>>    Procedure Construct_Object
8888>>>>>        Forward Send Construct_Object
8890>>>>>        
8890>>>>>        
8890>>>>>        Property String psAppSrcPath
8891>>>>>        Property String psBitmapPath
8892>>>>>        Property String psDataPath
8893>>>>>        Property String psDdSrcPath
8894>>>>>        Property String psDescription
8895>>>>>        Property String psFileList
8896>>>>>        Property String psHelpPath
8897>>>>>        Property String psHome
8898>>>>>        Property String psIdeSrcPath
8899>>>>>        Property String psProgramPath
8900>>>>>        Property String psAppHtmlPath
8901>>>>>        Property String psWorkspaceName
8902>>>>>        Property String psWorkspaceWSFile
8903>>>>>        Property String psConnectionIni
8904>>>>>        
8904>>>>>        Property String psSystemDfPath // took from the Registry!
8905>>>>>        Property String psSystemMakePath // took from the Registry!
8906>>>>>        Property String psDfPath        // Calculated
8907>>>>>        
8907>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
8908>>>>>        
8908>>>>>    End_Procedure
8909>>>>>    
8909>>>>>    Function FullPathNames String sShortPathNames Returns String
8911>>>>>        String sFileName
8911>>>>>        String sFullPathNames 
8911>>>>>        WString sFullPathName sShortPathName
8911>>>>>        Pointer lpsFilePart
8911>>>>>        Integer icChar // the number of characters returned
8911>>>>>        Integer iPos
8911>>>>>        
8911>>>>>        Move (Pos(";", sShortPathNames)) to iPos
8912>>>>>        While (length(sShortPathNames) >0)
8916>>>>>            If (iPos =0) Begin
8918>>>>>                Move sShortPathNames to sShortPathName
8919>>>>>                Move "" to sShortPathNames
8920>>>>>            End
8920>>>>>>
8920>>>>>            Else Begin // multiple paths
8921>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
8922>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
8923>>>>>            End
8923>>>>>>
8923>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
8924>>>>>            Move -1 to lpsFilePart
8925>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
8926>>>>>            Append sFullPathNames (CString(sFullPathName))
8927>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
8930>>>>>            Move (Pos(";", sShortPathNames)) to iPos
8931>>>>>        Loop
8932>>>>>>
8932>>>>>        
8932>>>>>        Function_Return sFullPathNames
8933>>>>>    End_Function
8934>>>>>    
8934>>>>>    Function GetApplicationPath Returns String
8936>>>>>        // Returns the path of the Application (no trailing "\")
8936>>>>>        WString wApplicationFileName 
8936>>>>>        Boolean bRemoved
8936>>>>>        Integer iNumChars
8936>>>>>        String sFilename sPath
8936>>>>>        
8936>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
8937>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
8938>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
8939>>>>>        
8939>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
8940>>>>>        Move (CString(wApplicationFileName)) to sPath
8941>>>>>        
8941>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8944>>>>>        Function_Return sPath
8945>>>>>    End_Function
8946>>>>>    
8946>>>>>    Procedure DoClearPaths
8948>>>>>        // Call this prior to changing from one WorkspAce to another
8948>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
8948>>>>>        Set psHome           to ""
8949>>>>>        Set psAppSrcPath     to ""
8950>>>>>        Set psBitmapPath     to ""
8951>>>>>        Set psDataPath       to ""
8952>>>>>        Set psDdSrcPath      to ""
8953>>>>>        Set psDescription    to ""
8954>>>>>        Set psFileList       to ""
8955>>>>>        Set psHelpPath       to ""
8956>>>>>        Set psIdeSrcPath     to ""
8957>>>>>        Set psAppHtmlPath    to ""
8958>>>>>        Set psProgramPath    to ""
8959>>>>>        Set psWorkspaceName  to ""
8960>>>>>        Set psSystemDfPath   to ""
8961>>>>>        Set psSystemMakePath to ""
8962>>>>>        Set psWorkspaceWSFile to ""
8963>>>>>        Set psConnectionIni to ""
8964>>>>>    End_Procedure
8965>>>>>    
8965>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
8967>>>>>        WString wApplicationStartPath
8967>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
8967>>>>>        Boolean bRemoved
8967>>>>>        Handle hoIniFile
8967>>>>>        Boolean bSuccess // call succeeded?
8967>>>>>        String sOldDirectory
8967>>>>>        String sSystemDfPath sSystemMakePath
8967>>>>>        Boolean bExist // does the WS file exist?
8967>>>>>        Boolean bChangingWorkspace
8967>>>>>        
8967>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
8967>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
8967>>>>>        
8967>>>>>        Set psWorkspaceWSFile to ""
8968>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
8971>>>>>        
8971>>>>>        // Append extension if not supplied...
8971>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
8973>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
8974>>>>>        End
8974>>>>>>
8974>>>>>        
8974>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
8975>>>>>        
8975>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
8977>>>>>            // Set the properties to the paths of the Workspace
8977>>>>>            // Find the WS file (with program)...
8977>>>>>            Get GetApplicationPath to wApplicationStartPath
8978>>>>>            
8978>>>>>            Move sWorkspaceFile to sWsName
8979>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
8980>>>>>        End
8980>>>>>>
8980>>>>>        Else Begin
8981>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
8982>>>>>            
8982>>>>>            Move sWorkspaceFile to wApplicationStartPath
8983>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
8984>>>>>        End
8984>>>>>>
8984>>>>>        
8984>>>>>        // Ensure that the file can be found...
8984>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
8984>>>>>        // [JVH] Turn off support for
8984>>>>>        // Ansi extended characters in workspace until we can
8984>>>>>        // resolve all open issues
8984>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
8985>>>>>        File_Exist sWorkspaceFile bExist
8986>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
8989>>>>>        
8989>>>>>        Get psHome           to sHome
8990>>>>>        Get psAppSrcPath     to sAppSrcPath
8991>>>>>        Get psAppHtmlPath    to sAppHtmlPath
8992>>>>>        Get psBitmapPath     to sBitmapPath
8993>>>>>        Get psDataPath       to sDataPath
8994>>>>>        Get psDdSrcPath      to sDdSrcPath
8995>>>>>        Get psDescription    to sDescription
8996>>>>>        Get psFileList       to sFileList
8997>>>>>        Get psHelpPath       to sHelpPath
8998>>>>>        Get psIdeSrcPath     to sIdeSrcPath
8999>>>>>        Get psProgramPath    to sProgramPath
9000>>>>>        Get psSystemDfPath   to sSystemDfPath
9001>>>>>        Get psSystemMakePath to sSystemMakePath
9002>>>>>        Get psWorkspaceName  to sWorkspaceName
9003>>>>>        Get psConnectionIni to sConnectionIni
9004>>>>>        
9004>>>>>        Get_Current_Directory to sOldDirectory
9005>>>>>        // Note- this conversion is temporarily rolled back
9005>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9005>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9006>>>>>        
9006>>>>>        Get Create U_cIniFile to hoIniFile
9007>>>>>        Set pbWideAPI of hoIniFile to False
9008>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9009>>>>>        
9009>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9012>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9015>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9018>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9021>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9024>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9027>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9030>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9033>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9036>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9039>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9042>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9045>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9048>>>>>        
9048>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9051>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9054>>>>>        
9054>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9055>>>>>        
9055>>>>>        // Set CWD to Home...
9055>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9056>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9057>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9058>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9059>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9060>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9061>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9062>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9063>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9064>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9065>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9066>>>>>        
9066>>>>>        Set psWorkspaceName to sWorkspaceName
9067>>>>>        Set psDescription   to sDescription
9068>>>>>        
9068>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9069>>>>>        
9069>>>>>        // Restore CWD...
9069>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9070>>>>>        
9070>>>>>        // Check for error conditions:
9070>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9070>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9073>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9076>>>>>        
9076>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9077>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9080>>>>>        
9080>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9083>>>>>        
9083>>>>>        Send DoAssignPaths // set psDfPath
9084>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9085>>>>>        Set pbWorkspaceOpened to True
9086>>>>>        
9086>>>>>        Function_Return wsWorkspaceOpened
9087>>>>>    End_Function
9088>>>>>    
9088>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9090>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9090>>>>>        
9090>>>>>        Handle hoSections hoIniFile
9090>>>>>        Integer iWorkspace eOpened
9090>>>>>        String sWorkspaceName sPath
9090>>>>>        String sVdfRootDir
9090>>>>>        
9090>>>>>        Get Create U_Array    to hoSections
9091>>>>>        Get Create U_cIniFile to hoIniFile
9092>>>>>        
9092>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9095>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9098>>>>>        
9098>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9099>>>>>        
9099>>>>>        Send ReadSections of hoIniFile hoSections
9100>>>>>        
9100>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9106>>>>>>
9106>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9107>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9109>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9110>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9113>>>>>                
9113>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9114>>>>>                Send Destroy of hoSections
9115>>>>>                Send Destroy of hoIniFile
9116>>>>>                Function_Return eOpened
9117>>>>>            End
9117>>>>>>
9117>>>>>        Loop
9118>>>>>>
9118>>>>>        
9118>>>>>        Send Destroy of hoSections
9119>>>>>        Send Destroy of hoIniFile
9120>>>>>        Function_Return wsWorkspaceNotFound
9121>>>>>    End_Function
9122>>>>>    
9122>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9124>>>>>        Boolean bRegistered
9124>>>>>        Handle hoIniFile
9124>>>>>        String sVdfRootDir
9124>>>>>        
9124>>>>>        Get Create U_cIniFile to hoIniFile
9125>>>>>        
9125>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9128>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9131>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9132>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9133>>>>>        
9133>>>>>        Send Destroy of hoIniFile
9134>>>>>        
9134>>>>>        Function_Return bRegistered
9135>>>>>    End_Function
9136>>>>>    
9136>>>>>    Function VdfSystemDfPath Returns String
9138>>>>>        String sSystemDfPath
9138>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9141>>>>>        
9141>>>>>        Function_Return sSystemDfPath
9142>>>>>    End_Function
9143>>>>>    
9143>>>>>    Function VdfSystemMakePath Returns String
9145>>>>>        String sSystemMakePath
9145>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9148>>>>>        
9148>>>>>        Function_Return sSystemMakePath
9149>>>>>    End_Function
9150>>>>>    
9150>>>>>    Procedure DoAssignPaths
9152>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9152>>>>>        
9152>>>>>        Get psDataPath     to sDataPath
9153>>>>>        Get psBitmapPath   to sBitmapPath
9154>>>>>        Get psHelpPath     to sHelpPath
9155>>>>>        Get psProgramPath  to sProgramPath
9156>>>>>        Get psSystemDfPath to sSystemDfPath
9157>>>>>        
9157>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9158>>>>>        
9158>>>>>    End_Procedure
9159>>>>>    
9159>>>>>    Procedure DoSetPaths
9161>>>>>        // [JVH] must convert paths to Ansi before setting these values
9161>>>>>        // Note- this conversion is temporarily rolled back
9161>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9161>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9161>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9164>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9167>>>>>    End_Procedure
9168>>>>>    
9168>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9170>>>>>        String sPath
9170>>>>>        
9170>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9173>>>>>        Else Begin
9174>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9175>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9176>>>>>            Send hmGeneric to hoCallBack ""
9177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9179>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9180>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9181>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9182>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9183>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9184>>>>>        End
9184>>>>>>
9184>>>>>    End_Procedure
9185>>>>>    
9185>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9187>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9187>>>>>        // returns a corresponding message string.
9187>>>>>        String sError
9187>>>>>        
9187>>>>>        Case Begin
9187>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9189>>>>>                Move C_$NoErrors to sError
9190>>>>>                Case Break
9191>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9194>>>>>                Move C_$NoWsName to sError
9195>>>>>                Case Break
9196>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9199>>>>>                Move C_$NoWsFileFound to sError
9200>>>>>                Case Break
9201>>>>>            Case (eErrorCode = wsDataPathEmpty)
9204>>>>>                Move C_$NoWsDataPath to sError
9205>>>>>                Case Break
9206>>>>>            Case (eErrorCode = wsFileListEmpty)
9209>>>>>                Move C_$NoWsFileList to sError
9210>>>>>                Case Break
9211>>>>>            Case (eErrorCode = wsFileListNotExist)
9214>>>>>                Move C_$NoFileListCfg to sError
9215>>>>>                Case Break
9216>>>>>            Case Else
9216>>>>>                Move C_$UnknownError to sError
9217>>>>>                Case Break
9218>>>>>        Case End
9218>>>>>        
9218>>>>>        Function_Return (sError-".")
9219>>>>>    End_Function
9220>>>>>    
9220>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9222>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9222>>>>>        String sVdfRootDir
9222>>>>>        Handle hoIniFile
9222>>>>>        String sPath
9222>>>>>        String sFileName
9222>>>>>        String sWorkspacePath
9222>>>>>        
9222>>>>>        Move "" to sFileName
9223>>>>>        
9223>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9226>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9229>>>>>        
9229>>>>>        Get Create U_cIniFile to hoIniFile
9230>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9231>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9232>>>>>        If (sWorkspacePath <>"") Begin
9234>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9237>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9238>>>>>        End
9238>>>>>>
9238>>>>>        Send Destroy of hoIniFile
9239>>>>>        
9239>>>>>        Function_Return sFileName
9240>>>>>    End_Function
9241>>>>>    
9241>>>>>    Function CountOfPaths String sPaths Returns Integer
9243>>>>>        // Returns the number of paths defined in a string of paths
9243>>>>>        Integer iChar icChar icPath
9243>>>>>        
9243>>>>>        If (sPaths ="") ;            Function_Return 0
9246>>>>>        
9246>>>>>        Move (Length(sPaths) -1) to icChar
9247>>>>>        For iChar from 1 to icChar
9253>>>>>>
9253>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9256>>>>>        Loop
9257>>>>>>
9257>>>>>        
9257>>>>>        Function_Return (icPath +1)
9258>>>>>    End_Function
9259>>>>>    
9259>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9261>>>>>        // Returns the path at the 1-based index of passed paths.
9261>>>>>        // If the path contains a trailing "\", it will be removed
9261>>>>>        Integer iChar icPath iPath iPos
9261>>>>>        String sPath
9261>>>>>        
9261>>>>>        Move (sPaths +";") to sPaths
9262>>>>>        For iPath from 1 to iIndex
9268>>>>>>
9268>>>>>            Move (Pos(";", sPaths)) to iPos
9269>>>>>            If iPos Begin
9271>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9272>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9275>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9276>>>>>            End
9276>>>>>>
9276>>>>>            Else ;                Function_Return "" // index past number of paths
9278>>>>>        Loop
9279>>>>>>
9279>>>>>        
9279>>>>>        Function_Return sPath
9280>>>>>    End_Function
9281>>>>>    
9281>>>>>End_Class
9282>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCommandLine.pkg)
9282>>>>>Use VDFBase.pkg
9282>>>>>
9282>>>>>Class cCommandLine is a cObject
9283>>>>>    
9283>>>>>    Procedure Construct_Object
9285>>>>>        Forward Send Construct_Object
9287>>>>>        
9287>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9288>>>>>    End_Procedure
9289>>>>>    
9289>>>>>    Procedure Private_DoCreateArgsArray
9291>>>>>        // creates the array for holding the arguments. Created upon demand only!
9291>>>>>        Integer icArg
9291>>>>>        String sArg
9291>>>>>        
9291>>>>>        Object oArgs is an Array
9293>>>>>            Delegate Set phoArgs to Self
9295>>>>>            Repeat
9295>>>>>>
9295>>>>>                CmdLine sArg
9296>>>>>>
9296>>>>>                If (sArg <> "") Begin
9298>>>>>                    Increment icArg
9299>>>>>                    Set Value  (icArg -1) to sArg
9300>>>>>                End
9300>>>>>>
9300>>>>>            Until (sArg = "")
9302>>>>>        End_Object
9303>>>>>    End_Procedure
9304>>>>>    
9304>>>>>    Function CountOfArgs Returns Integer
9306>>>>>        //Returns the number of arguments passed
9306>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9309>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9310>>>>>    End_Function
9311>>>>>    
9311>>>>>    Function Argument Integer iIndex Returns String
9313>>>>>        //Returns the one-based argument string
9313>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9316>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9317>>>>>    End_Function
9318>>>>>    
9318>>>>>End_Class
9319>>>>>
9319>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cRegistry.pkg)
9319>>>>>Use Dll.pkg
9319>>>>>Use RegistryAPI.pkg
9319>>>>>Use tWinStructs.pkg
9319>>>>>
9319>>>>>Enum_List // Registry Data types
9319>>>>>    Define rdString
9319>>>>>    Define rdDword
9319>>>>>    Define rdBinary
9319>>>>>    Define rdUnknown
9319>>>>>End_Enum_List
9319>>>>>
9319>>>>>
9319>>>>>Class cRegistry is a cObject
9320>>>>>    Procedure Construct_Object
9322>>>>>        Forward Send Construct_Object
9324>>>>>        
9324>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9325>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9326>>>>>        Property Handle phCurrentKey
9327>>>>>        Property Boolean pbLazyWrite True
9328>>>>>    End_Procedure
9329>>>>>    
9329>>>>>    Function CountOfSubkeys Returns Integer
9331>>>>>        Integer dwCountOfSubkeys
9331>>>>>        Integer iError
9331>>>>>        String sError
9331>>>>>        
9331>>>>>        Move 0 to dwCountOfSubkeys
9332>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9333>>>>>        If iError Begin
9335>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9336>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9337>>>>>>
9337>>>>>        End
9337>>>>>>
9337>>>>>        Function_Return dwCountOfSubkeys
9338>>>>>    End_Function
9339>>>>>    
9339>>>>>    Function CountOfValues Returns Integer
9341>>>>>        Integer dwCountOfValues
9341>>>>>        Integer iError
9341>>>>>        String sError
9341>>>>>        
9341>>>>>        Move 0 to dwCountOfValues
9342>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9343>>>>>        If iError Begin
9345>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9346>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9347>>>>>>
9347>>>>>        End
9347>>>>>>
9347>>>>>        
9347>>>>>        Function_Return dwCountOfValues
9348>>>>>    End_Function
9349>>>>>    
9349>>>>>    Function LongestSubkeyLength Returns Integer
9351>>>>>        Integer dwLongestSubkeyLength
9351>>>>>        Integer iError
9351>>>>>        String sError
9351>>>>>        
9351>>>>>        Move 0 to dwLongestSubkeyLength
9352>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9353>>>>>        If iError Begin
9355>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9356>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9357>>>>>>
9357>>>>>        End
9357>>>>>>
9357>>>>>        
9357>>>>>        Function_Return dwLongestSubkeyLength
9358>>>>>    End_Function
9359>>>>>    
9359>>>>>    Function LongestValueLength Returns Integer
9361>>>>>        Integer dwLongestValueLength
9361>>>>>        Integer iError
9361>>>>>        String sError
9361>>>>>        
9361>>>>>        Move 0 to dwLongestValueLength
9362>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9363>>>>>        If iError Begin
9365>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9366>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9367>>>>>>
9367>>>>>        End
9367>>>>>>
9367>>>>>        
9367>>>>>        Function_Return dwLongestValueLength
9368>>>>>    End_Function
9369>>>>>    
9369>>>>>    Function LongestDataLength Returns Integer
9371>>>>>        Integer dwLongestDataLength
9371>>>>>        Integer iError
9371>>>>>        String sError
9371>>>>>        
9371>>>>>        Move 0 to dwLongestDataLength
9372>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9373>>>>>        If iError Begin
9375>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9376>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9377>>>>>>
9377>>>>>        End
9377>>>>>>
9377>>>>>        
9377>>>>>        Function_Return dwLongestDataLength
9378>>>>>    End_Function
9379>>>>>    
9379>>>>>    Function ValueType String sValueName Returns Integer
9381>>>>>        Integer dwType
9381>>>>>        Integer iError eType
9381>>>>>        String sError
9381>>>>>        
9381>>>>>        Move 0 to dwType
9382>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9383>>>>>        If iError Begin
9385>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9386>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9387>>>>>>
9387>>>>>        End
9387>>>>>>
9387>>>>>        
9387>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9390>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9394>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9398>>>>>        Else ;            Move rdUnknown to eType
9400>>>>>        
9400>>>>>        Function_Return eType
9401>>>>>    End_Function
9402>>>>>    
9402>>>>>    Function ValueLength String sValueName Returns Integer
9404>>>>>        Integer dwSize
9404>>>>>        Integer iError
9404>>>>>        String sError
9404>>>>>        
9404>>>>>        Move 0 to dwSize
9405>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9406>>>>>        If iError Begin
9408>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9409>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9410>>>>>>
9410>>>>>        End
9410>>>>>>
9410>>>>>        
9410>>>>>        Function_Return dwSize
9411>>>>>    End_Function
9412>>>>>    
9412>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9414>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9414>>>>>        Handle hKey hKeyOpened
9414>>>>>        Integer iError
9414>>>>>        String sError
9414>>>>>        
9414>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9415>>>>>        
9415>>>>>        Get phRootKey to hKey
9416>>>>>        
9416>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9417>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9420>>>>>        Else Begin
9421>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9422>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9423>>>>>>
9423>>>>>        End
9423>>>>>>
9423>>>>>        Function_Return iError
9424>>>>>    End_Function
9425>>>>>    
9425>>>>>    Procedure CloseKey
9427>>>>>        Integer iError
9427>>>>>        Handle hKey
9427>>>>>        
9427>>>>>        Get phCurrentKey to hKey
9428>>>>>        
9428>>>>>        If (hKey <>0) Begin
9430>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9433>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9435>>>>>            
9435>>>>>            Set phCurrentKey to 0
9436>>>>>        End
9436>>>>>>
9436>>>>>    End_Procedure
9437>>>>>    
9437>>>>>    Function OpenKey String sKeyName Returns Boolean
9439>>>>>        Handle hKey hKeyOpened
9439>>>>>        Integer iError
9439>>>>>        
9439>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9440>>>>>        
9440>>>>>        Get phRootKey to hKey
9441>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9442>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9445>>>>>        
9445>>>>>        Function_Return (iError=0)
9446>>>>>    End_Function
9447>>>>>    
9447>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9449>>>>>        Handle hKey
9449>>>>>        Integer iError
9449>>>>>        Integer iData
9449>>>>>        String sError
9449>>>>>        
9449>>>>>        Move iValueData to iData
9450>>>>>        Get phCurrentKey to hKey
9451>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9452>>>>>        If iError Begin
9454>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9455>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9456>>>>>>
9456>>>>>        End
9456>>>>>>
9456>>>>>    End_Procedure
9457>>>>>    
9457>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9457>>>>>    Procedure WriteDword String sValue Integer iValueData
9459>>>>>        Send WriteInteger of Self sValue iValueData
9460>>>>>    End_Procedure
9461>>>>>    
9461>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9463>>>>>        Handle hKey
9463>>>>>        Integer iError
9463>>>>>        UInteger uData
9463>>>>>        String sError
9463>>>>>        
9463>>>>>        Move uValueData to uData
9464>>>>>        Get phCurrentKey to hKey
9465>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9466>>>>>        If iError Begin
9468>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9469>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9470>>>>>>
9470>>>>>        End
9470>>>>>>
9470>>>>>    End_Procedure
9471>>>>>
9471>>>>>    Procedure WriteString WString sValue WString wValueData
9473>>>>>        Handle hKey
9473>>>>>        Integer iError cbData
9473>>>>>        String sError
9473>>>>>        
9473>>>>>        If (wValueData = "") Begin
9475>>>>>            Move (Character(0)) to wValueData
9476>>>>>            Move 1 to cbData
9477>>>>>        End
9477>>>>>>
9477>>>>>        Else Begin
9478>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9479>>>>>        End
9479>>>>>>
9479>>>>>        Get phCurrentKey to hKey
9480>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9481>>>>>        If iError Begin
9483>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9484>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9485>>>>>>
9485>>>>>        End
9485>>>>>>
9485>>>>>    End_Procedure
9486>>>>>    
9486>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9488>>>>>        Handle hKey
9488>>>>>        Integer iError
9488>>>>>        String sError
9488>>>>>        
9488>>>>>        Get phCurrentKey to hKey
9489>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9490>>>>>        If iError Begin
9492>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9493>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9494>>>>>>
9494>>>>>        End
9494>>>>>>
9494>>>>>    End_Procedure
9495>>>>>    
9495>>>>>    Function ReadInteger WString sValueName Returns Integer
9497>>>>>        Handle hKey
9497>>>>>        Integer iError
9497>>>>>        Integer iValueData iValueDataLength
9497>>>>>        String sError
9497>>>>>        
9497>>>>>        Move 0           to iValueData
9498>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9499>>>>>        
9499>>>>>        Get phCurrentKey to hKey
9500>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9501>>>>>        If iError Begin
9503>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9504>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9505>>>>>>
9505>>>>>        End
9505>>>>>>
9505>>>>>        
9505>>>>>        Function_Return iValueData
9506>>>>>    End_Function
9507>>>>>    
9507>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9507>>>>>    Function ReadDword String sValueName Returns Integer
9509>>>>>        Function_Return (ReadInteger(Self, sValueName))
9510>>>>>    End_Function
9511>>>>>
9511>>>>>    Function ReadUInt WString sValueName Returns UInteger
9513>>>>>        Handle hKey
9513>>>>>        Integer iError
9513>>>>>        UInteger uValueData uValueDataLength
9513>>>>>        String sError
9513>>>>>        
9513>>>>>        Move 0           to uValueData
9514>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9515>>>>>        
9515>>>>>        Get phCurrentKey to hKey
9516>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9517>>>>>        If iError Begin
9519>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9520>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9521>>>>>>
9521>>>>>        End
9521>>>>>>
9521>>>>>        
9521>>>>>        Function_Return uValueData
9522>>>>>    End_Function
9523>>>>>    
9523>>>>>    Function ReadString String sValueName Returns String
9525>>>>>        Handle hKey
9525>>>>>        Integer iError
9525>>>>>        WString wValueData
9525>>>>>        DWord dwValueDataLength dwType
9525>>>>>        Pointer lpsValueData
9525>>>>>        String sError
9525>>>>>        
9525>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9526>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9527>>>>>        
9527>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9528>>>>>        
9528>>>>>        Move REG_SZ to dwType
9529>>>>>        
9529>>>>>        Get phCurrentKey to hKey
9530>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9531>>>>>        If iError Begin
9533>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9534>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9535>>>>>>
9535>>>>>        End
9535>>>>>>
9535>>>>>        
9535>>>>>        Function_Return (CString(wValueData))
9536>>>>>    End_Function
9537>>>>>    
9537>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9539>>>>>        Handle hKey
9539>>>>>        Integer iError
9539>>>>>        String sError
9539>>>>>        
9539>>>>>        Get phCurrentKey to hKey
9540>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9541>>>>>        If iError Begin
9543>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9544>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9545>>>>>>
9545>>>>>        End
9545>>>>>>
9545>>>>>        
9545>>>>>        Function_Return (iDataLength >0)
9546>>>>>    End_Function
9547>>>>>    
9547>>>>>    
9547>>>>>    // Private....
9547>>>>>    Function GetBaseKey Returns Handle
9549>>>>>        Handle hBaseKey
9549>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9552>>>>>        Else ;            Get phCurrentKey to hBaseKey
9554>>>>>        
9554>>>>>        Function_Return hBaseKey
9555>>>>>    End_Function
9556>>>>>    
9556>>>>>    Function GetKey String sKeyName Returns Handle
9558>>>>>        Handle hKeyOpened
9558>>>>>        Integer iError
9558>>>>>        
9558>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9559>>>>>        
9559>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9560>>>>>        
9560>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9563>>>>>        Else ;            Function_Return 0
9565>>>>>    End_Function
9566>>>>>    
9566>>>>>    // Public
9566>>>>>    Function KeyExists String sKeyName Returns Boolean
9568>>>>>        Handle hKey
9568>>>>>        Integer iVoid
9568>>>>>        
9568>>>>>        If (Trim(sKeyName) = "") ;            Function_Return False
9571>>>>>        
9571>>>>>        Get GetKey sKeyName to hKey
9572>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9575>>>>>        Function_Return (hKey <>0)
9576>>>>>    End_Function
9577>>>>>    
9577>>>>>    Function ValueExists String sValueName Returns Boolean
9579>>>>>        // Determines whether a Value exists for the currently-opened Key.
9579>>>>>        Integer iError
9579>>>>>        DWord dwDataType
9579>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9580>>>>>        
9580>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9581>>>>>        
9581>>>>>        Function_Return (iError=0)
9582>>>>>    End_Function
9583>>>>>    
9583>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9585>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9586>>>>>    End_Function
9587>>>>>    
9587>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9589>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9590>>>>>    End_Function
9591>>>>>    
9591>>>>>    Function Subkeys Returns String[]
9593>>>>>        Integer iError
9593>>>>>        Integer icValue iLongestSubkey
9593>>>>>        Handle hKey
9593>>>>>        DWord dwSubkeyNameLength
9593>>>>>        String sSubkeyName sFileTime
9593>>>>>        Pointer lpsSubkeyName
9593>>>>>        String[] aResult
9594>>>>>        tWinFileTime fileTime
9594>>>>>        tWinFileTime fileTime
9594>>>>>
9594>>>>>        Get LongestSubkeyLength to iLongestSubkey
9595>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
9596>>>>>        Move (AddressOf(sSubkeyName)) to lpsSubkeyName
9597>>>>>
9597>>>>>        Get phCurrentKey to hKey
9598>>>>>        Repeat
9598>>>>>>
9598>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9599>>>>>
9599>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(fileTime))) to iError
9600>>>>>            If (iError =0) Begin
9602>>>>>                Move (CString(sSubkeyName)) to aResult[icValue]
9603>>>>>                Increment icValue
9604>>>>>            End
9604>>>>>>
9604>>>>>        Until (iError)
9606>>>>>        Function_Return aResult
9607>>>>>    End_Function
9608>>>>>    
9608>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9610>>>>>        Integer iError
9610>>>>>        Integer icValue iLongestSubkey
9610>>>>>        Handle hKey
9610>>>>>        DWord dwSubkeyNameLength
9610>>>>>        WString wSubkeyName
9610>>>>>        tWinFileTime FileTime
9610>>>>>        tWinFileTime FileTime
9610>>>>>        
9610>>>>>        Get LongestSubkeyLength to iLongestSubkey
9611>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9612>>>>>        
9612>>>>>        Get phCurrentKey to hKey
9613>>>>>        Repeat
9613>>>>>>
9613>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9614>>>>>            
9614>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9615>>>>>            If (iError =0) Begin
9617>>>>>                Increment icValue
9618>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9619>>>>>            End
9619>>>>>>
9619>>>>>        Until (iError)
9621>>>>>        Function_Return icValue
9622>>>>>        
9622>>>>>    End_Function
9623>>>>>    
9623>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9625>>>>>        Integer iError
9625>>>>>        Integer icValue iLongestValue
9625>>>>>        Handle hKey
9625>>>>>        DWord dwValueNameLength
9625>>>>>        WString wValueName 
9625>>>>>        String sValueNameSize
9625>>>>>        Pointer lpsValueName
9625>>>>>        
9625>>>>>        Get LongestValueLength to iLongestValue
9626>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9627>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9628>>>>>        
9628>>>>>        Get phCurrentKey to hKey
9629>>>>>        Repeat
9629>>>>>>
9629>>>>>            Move (iLongestValue +1) to dwValueNameLength
9630>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9631>>>>>            If (iError =0) Begin
9633>>>>>                Increment icValue
9634>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9635>>>>>            End
9635>>>>>>
9635>>>>>        Until (iError)
9637>>>>>        Function_Return icValue
9638>>>>>        
9638>>>>>    End_Function
9639>>>>>    
9639>>>>>End_Class
9640>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cVersionInfo.pkg)
9640>>>>>Use VdfBase.pkg
9640>>>>>Use DLL.pkg
9640>>>>>Use tWinStructs.pkg
9640>>>>>Use WinKern.pkg
9640>>>>>
9640>>>>>Define VS_FF_DEBUG         for |CI$00000001
9640>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9640>>>>>Define VS_FF_PATCHED       for |CI$00000004
9640>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9640>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9640>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9640>>>>>
9640>>>>>// Note: String pointer lpFilename must refer to WString type.
9640>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9641>>>>>    
9641>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9641>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9643>>>>>    
9643>>>>>    DWord  dwResult
9643>>>>>    UWide  uwFileName
9643>>>>>    UWide  uwFileName
9643>>>>>
9643>>>>>    Send StringToWide aFilename (&uwFileName)
9644>>>>>    
9644>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9645>>>>>    Function_Return dwResult
9646>>>>>End_Function
9647>>>>>
9647>>>>>// Note: String pointers should be referring to WString items.
9647>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9648>>>>>    
9648>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9648>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9650>>>>>    
9650>>>>>    Integer iResult
9650>>>>>    UWide   uwFileName
9650>>>>>    UWide   uwFileName
9650>>>>>
9650>>>>>    Send StringToWide aFilename (&uwFileName)
9651>>>>>    
9651>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9652>>>>>    Function_Return iResult
9653>>>>>End_Function    
9654>>>>>
9654>>>>>// Note: String pointers should be referring to WString items.
9654>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9655>>>>>
9655>>>>>// Wrapper Function VerQueryValue (when using strings)
9655>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9657>>>>>    
9657>>>>>    Integer iResult
9657>>>>>    UWide   uwSubBlock
9657>>>>>    UWide   uwSubBlock
9657>>>>>    
9657>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9658>>>>>    
9658>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9659>>>>>    
9659>>>>>    Function_Return iResult
9660>>>>>End_Function
9661>>>>>
9661>>>>>
9661>>>>>Class cVersionInfo is a cObject
9662>>>>>    Procedure Construct_Object
9664>>>>>        Forward Send Construct_Object
9666>>>>>        
9666>>>>>        
9666>>>>>        Property Integer piVersionMajor
9667>>>>>        Property Integer piVersionMinor
9668>>>>>        Property Integer piVersionRelease
9669>>>>>        Property Integer piVersionBuild
9670>>>>>        
9670>>>>>        Property Boolean pbIncluded
9671>>>>>        Property Boolean pbSpecialBuild
9672>>>>>        Property Boolean pbPrivateBuild
9673>>>>>        
9673>>>>>    End_Procedure
9674>>>>>    
9674>>>>>    Procedure DoCreate WString sFileName
9676>>>>>        DWord dwHandle
9676>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9676>>>>>        WString sData
9676>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9676>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9676>>>>>        WString sSubBlock
9676>>>>>        Pointer pVsFixedFileInfo
9676>>>>>        
9676>>>>>        Move 0 to pVsFixedFileInfo
9677>>>>>        Move 0 to dwHandle
9678>>>>>        Move 0 to iVerSize
9679>>>>>        
9679>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9680>>>>>        Set pbIncluded to (iInfoSize <>0)
9681>>>>>        
9681>>>>>        If (pbIncluded(Self)) Begin
9683>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9684>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9685>>>>>            
9685>>>>>            If (iSuccess <>0) Begin
9687>>>>>                Move "\" to sSubBlock
9688>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9690>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9691>>>>>                    
9691>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9692>>>>>                    Set piVersionMajor to (Hi(iVersion))
9693>>>>>                    Set piVersionMinor to (Low(iVersion))
9694>>>>>                    
9694>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9695>>>>>                    Set piVersionRelease to (Hi(iVersion))
9696>>>>>                    Set piVersionBuild   to (Low(iVersion))
9697>>>>>                    
9697>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9698>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9699>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9700>>>>>                End
9700>>>>>>
9700>>>>>            End
9700>>>>>>
9700>>>>>            
9700>>>>>        End
9700>>>>>>
9700>>>>>    End_Procedure
9701>>>>>    
9701>>>>>End_Class
9702>>>Use GlobalFunctionsProcedures.pkg
9702>>>Use tWinStructs.pkg
9702>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9702>>>
9702>>>Register_Function phoWorkspace Returns Handle
9702>>>Register_Function phoCommandLine Returns Handle
9702>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9702>>>Register_Function GetApplicationName Returns String
9702>>>Register_Function GetApplicationFileName Returns String
9702>>>
9702>>>Register_Function Statusbar_State Returns Integer
9702>>>Register_Function Toolbar_State Returns Integer
9702>>>Register_Procedure Set Statusbar_State
9702>>>Register_Procedure Set Toolbar_State
9702>>>
9702>>>
9702>>>Class cApplication is a cObject
9703>>>    Procedure Construct_Object
9705>>>        Forward Send Construct_Object
9707>>>        
9707>>>        Move Self to ghoApplication
9708>>>        
9708>>>        Property Handle phoVersionInfo
9709>>>        Property Handle phoWorkspace
9710>>>        Property Handle phoCommandLine
9711>>>        Property Handle phoMainPanel       // main panel will set this for us.
9712>>>        Property String psHelpFile         // type of file is determined by peHelpType
9713>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9714>>>        
9714>>>        Property String psCompany "Data Access Worldwide"
9715>>>        Property String psProduct "DataFlex Applications"
9716>>>        Property String psVersion C_DFVersion
9717>>>        Property String psProgram (Module_Name(desktop))
9718>>>        
9718>>>        // set to '' to stop the auto open workspace behavior
9718>>>        Property String psAutoOpenWorkspace 'Config.ws'
9719>>>        
9719>>>        
9719>>>        Property Boolean pbPreserveEnvironment True
9720>>>        
9720>>>        Object oCommandLine is a cCommandLine
9722>>>            Delegate Set phoCommandLine to Self
9724>>>        End_Object
9725>>>        
9725>>>        Object oWorkspace is a cWorkspace
9727>>>            Delegate Set phoWorkspace to Self
9729>>>        End_Object
9730>>>        
9730>>>        Object oVersionInfo is a cVersionInfo
9732>>>            Delegate Set phoVersionInfo to Self
9734>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9735>>>        End_Object
9736>>>        
9736>>>        Set pbUseWindowsFont to True
9737>>>        
9737>>>    End_Procedure
9738>>>    
9738>>>    Procedure Destroy_Object
9740>>>        If (ghoApplication=Self) Begin
9742>>>            Move 0 to ghoApplication
9743>>>        End
9743>>>>
9743>>>        Forward Send Destroy_Object
9745>>>    End_Procedure
9746>>>    
9746>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9746>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9746>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9748>>>        Move bNext to gbKEnterNext
9749>>>    End_Procedure
9750>>>    
9750>>>    Function pbEnterKeyAsTabKey Returns Boolean
9752>>>        Function_Return gbKEnterNext
9753>>>    End_Function
9754>>>    
9754>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9756>>>// not used with webapp
9756>>>        Handle hoRegistry hoCommandBars
9756>>>        Handle hMonitor
9756>>>        Integer iError cxy
9756>>>        tWinWindowPlacement WindowPlacement
9756>>>        tWinWindowPlacement WindowPlacement
9756>>>        String sKey
9756>>>        Boolean bSuccess
9756>>>        String sObjectName
9756>>>        
9756>>>        If (pbPreserveEnvironment(Self)) Begin
9758>>>            Get Create U_cRegistry to hoRegistry
9759>>>            Set pfAccessRights of hoRegistry to KEY_READ
9760>>>            
9760>>>            Get RegistryKeyString to sKey
9761>>>            
9761>>>            If (bProgram = False) Begin
9763>>>                Move (sKey +"\WINDOWS") to sKey
9764>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9765>>>                Move (sKey +"\" +sObjectName) to sKey
9766>>>            End
9766>>>>
9766>>>            Else ;                Move (sKey + "\Preferences") to sKey
9768>>>            
9768>>>            Get OpenKey of hoRegistry sKey to bSuccess
9769>>>            
9769>>>            If bSuccess Begin
9771>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9773>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9774>>>                    If bSuccess Begin
9776>>>                        // Do not restore size if the window is not resizable
9776>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9778>>>                            // restore always works with outer size
9778>>>                            Get GuiWindowSize     of hoContainer to cxy
9779>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9780>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9781>>>                        End
9781>>>>
9781>>>                        
9781>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9781>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9781>>>                        If (bProgram) Begin
9783>>>                            // Test the top left point
9783>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9784>>>                            
9784>>>                            If (hMonitor = 0) Begin
9786>>>                                // test the bottom right point
9786>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9787>>>                            End
9787>>>>
9787>>>                            
9787>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9787>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9787>>>                            If (hMonitor = 0) Begin
9789>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9790>>>                            End
9790>>>>
9790>>>                        End
9790>>>>
9790>>>                        
9790>>>                        // Set the placement
9790>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9791>>>                    End
9791>>>>
9791>>>                End
9791>>>>
9791>>>                If bProgram Begin
9793>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9794>>>                    If not hoCommandBars Begin
9796>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9799>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9802>>>                    End
9802>>>>
9802>>>                End
9802>>>>
9802>>>                
9802>>>                Send CloseKey of hoRegistry
9803>>>            End
9803>>>>
9803>>>            
9803>>>            Send Destroy of hoRegistry
9804>>>        End
9804>>>>
9804>>>    End_Procedure
9805>>>    
9805>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9807>>>// not used with webapp
9807>>>        Handle hoRegistry
9807>>>        Integer iError
9807>>>        tWinWindowPlacement WindowPlacement
9807>>>        tWinWindowPlacement WindowPlacement
9807>>>        String sKey
9807>>>        Boolean bSuccess
9807>>>        Integer eShowCmd
9807>>>        String sObjectName
9807>>>        
9807>>>        If (pbPreserveEnvironment(Self)) Begin
9809>>>            Get Create U_cRegistry to hoRegistry
9810>>>            Get RegistryKeyString to sKey
9811>>>            
9811>>>            If (bProgram = False) Begin
9813>>>                Move (sKey +"\WINDOWS") to sKey
9814>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9815>>>                Move (sKey +"\" +sObjectName) to sKey
9816>>>            End
9816>>>>
9816>>>            Else ;                Move (sKey +"\Preferences") to sKey
9818>>>            
9818>>>            Get CreateKey of hoRegistry sKey to iError
9819>>>            If (iError = 0) Begin
9821>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9822>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9823>>>                If bSuccess Begin
9825>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9825>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9827>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9828>>>                    End
9828>>>>
9828>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9829>>>                End
9829>>>>
9829>>>                
9829>>>                If bProgram Begin
9831>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9832>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9833>>>                End
9833>>>>
9833>>>                
9833>>>                
9833>>>                Send CloseKey of hoRegistry
9834>>>            End
9834>>>>
9834>>>            
9834>>>            Send Destroy of hoRegistry
9835>>>        End
9835>>>>
9835>>>    End_Procedure
9836>>>    
9836>>>    
9836>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9838>>>        Integer ixySize ixSize iySize
9838>>>        Integer ixOffset iyOffset
9838>>>        
9838>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9838>>>        Move (0 - WindowPos.left) to ixOffset
9839>>>        Move (0 - WindowPos.top) to iyOffset
9840>>>        
9840>>>        Move 0 to WindowPos.left
9841>>>        Move 0 to WindowPos.top
9842>>>        
9842>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9843>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9844>>>        
9844>>>        // also make sure that the size of the window is <= the size of the main monitor
9844>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9845>>>        Move (low(ixySize))      to ixSize
9846>>>        Move (hi(ixySize))       to iySize
9847>>>        
9847>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9848>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9849>>>    End_Procedure
9850>>>    
9850>>>    
9850>>>    Function RegistryKeyString Returns String
9852>>>        String sCompany sProduct sVersion sProgram
9852>>>        
9852>>>        Get psCompany to sCompany
9853>>>        Get psProduct to sProduct
9854>>>        Get psVersion to sVersion
9855>>>        Get psProgram to sProgram
9856>>>        
9856>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9859>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9862>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
9865>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
9868>>>        
9868>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
9869>>>    End_Function
9870>>>    
9870>>>    Procedure WriteString String sSubKey String sValueName String sValueData
9872>>>        String sKey
9872>>>        Handle hoRegistry
9872>>>        Integer iError
9872>>>        
9872>>>        Get Create U_cRegistry to hoRegistry
9873>>>        Get RegistryKeyString to sKey
9874>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9877>>>        Get CreateKey of hoRegistry sKey to iError
9878>>>        If (iError = 0) Begin
9880>>>            Send WriteString of hoRegistry sValueName sValueData
9881>>>            Send CloseKey of hoRegistry
9882>>>        End
9882>>>>
9882>>>        
9882>>>        Send Destroy of hoRegistry
9883>>>    End_Procedure
9884>>>    
9884>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
9886>>>        String sKey
9886>>>        Handle hoRegistry
9886>>>        Integer iError
9886>>>        
9886>>>        Get Create U_cRegistry to hoRegistry
9887>>>        Get RegistryKeyString to sKey
9888>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9891>>>        Get CreateKey of hoRegistry sKey to iError
9892>>>        If (iError = 0) Begin
9894>>>            Send WriteInteger of hoRegistry sValueName iValueData
9895>>>            Send CloseKey of hoRegistry
9896>>>        End
9896>>>>
9896>>>        
9896>>>        Send Destroy of hoRegistry
9897>>>    End_Procedure
9898>>>    
9898>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9898>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
9900>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
9901>>>    End_Procedure
9902>>>    
9902>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
9904>>>        String sKey
9904>>>        Handle hoRegistry
9904>>>        Integer iError
9904>>>        
9904>>>        Get Create U_cRegistry to hoRegistry
9905>>>        Get RegistryKeyString to sKey
9906>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9909>>>        Get CreateKey of hoRegistry sKey to iError
9910>>>        If (iError = 0) Begin
9912>>>            Send WriteUInt of hoRegistry sValueName uValueData
9913>>>            Send CloseKey of hoRegistry
9914>>>        End
9914>>>>
9914>>>        
9914>>>        Send Destroy of hoRegistry
9915>>>    End_Procedure
9916>>>
9916>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
9918>>>        String sKey
9918>>>        Handle hoRegistry
9918>>>        Integer iError
9918>>>        
9918>>>        Get Create U_cRegistry to hoRegistry
9919>>>        Get RegistryKeyString to sKey
9920>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9923>>>        Get CreateKey of hoRegistry sKey to iError
9924>>>        If (iError = 0) Begin
9926>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
9927>>>            Send CloseKey of hoRegistry
9928>>>        End
9928>>>>
9928>>>        
9928>>>        Send Destroy of hoRegistry
9929>>>    End_Procedure
9930>>>    
9930>>>    // returns true if both sub-key and value exists.
9930>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
9932>>>        String sKey
9932>>>        Handle hoRegistry
9932>>>        Boolean bOK
9932>>>        Get Create U_cRegistry to hoRegistry
9933>>>        Get RegistryKeyString to sKey
9934>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9937>>>        Get OpenKey of hoRegistry sKey to bOk
9938>>>        If (bOK) Begin
9940>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
9941>>>            Send CloseKey of hoRegistry
9942>>>        End
9942>>>>
9942>>>        Send Destroy of hoRegistry
9943>>>        Function_Return bOk
9944>>>    End_Function
9945>>>    
9945>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
9947>>>        String sKey sData
9947>>>        Handle hoRegistry
9947>>>        Boolean bOK
9947>>>        
9947>>>        Move sDefault to sData
9948>>>        Get Create U_cRegistry to hoRegistry
9949>>>        Get RegistryKeyString to sKey
9950>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9953>>>        Get OpenKey of hoRegistry sKey to bOk
9954>>>        If (bOK) Begin
9956>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
9959>>>            Send CloseKey of hoRegistry
9960>>>        End
9960>>>>
9960>>>        
9960>>>        Send Destroy of hoRegistry
9961>>>        Function_Return sData
9962>>>    End_Function
9963>>>    
9963>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
9965>>>        String sKey
9965>>>        Integer iData
9965>>>        Handle hoRegistry
9965>>>        Boolean bOK
9965>>>        
9965>>>        Move iDefault to iData
9966>>>        Get Create U_cRegistry to hoRegistry
9967>>>        Get RegistryKeyString to sKey
9968>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9971>>>        Get OpenKey of hoRegistry sKey to bOk
9972>>>        If bOK Begin
9974>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
9977>>>            Send CloseKey of hoRegistry
9978>>>        End
9978>>>>
9978>>>        
9978>>>        Send Destroy of hoRegistry
9979>>>        Function_Return iData
9980>>>    End_Function
9981>>>
9981>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9981>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
9983>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
9984>>>    End_Function
9985>>>    
9985>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
9987>>>        String sKey
9987>>>        UInteger uData
9987>>>        Handle hoRegistry
9987>>>        Boolean bOK
9987>>>        
9987>>>        Move uDefault to uData
9988>>>        Get Create U_cRegistry to hoRegistry
9989>>>        Get RegistryKeyString to sKey
9990>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9993>>>        Get OpenKey of hoRegistry sKey to bOk
9994>>>        If bOK Begin
9996>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
9999>>>            Send CloseKey of hoRegistry
10000>>>        End
10000>>>>
10000>>>        
10000>>>        Send Destroy of hoRegistry
10001>>>        Function_Return uData
10002>>>    End_Function
10003>>>    
10003>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
10005>>>        String sKey
10005>>>        Handle hoRegistry
10005>>>        Boolean bOK bSuccess
10005>>>        
10005>>>        Get Create U_cRegistry to hoRegistry
10006>>>        Get RegistryKeyString to sKey
10007>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10010>>>        Get OpenKey of hoRegistry sKey to bOk
10011>>>        If bOK Begin
10013>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
10014>>>            Send CloseKey of hoRegistry
10015>>>        End
10015>>>>
10015>>>        
10015>>>        Send Destroy of hoRegistry
10016>>>        Function_Return bSuccess
10017>>>    End_Function
10018>>>    
10018>>>    Procedure DoOpenWorkspace String sWorkspace
10020>>>        // Tries to open in this order:
10020>>>        // 1) if absolute path, use that; otherwise
10020>>>        // 2) try to open in the path of the EXE; otherwise
10020>>>        // 3) load it via the Registered list
10020>>>        
10020>>>        Integer eOpened
10020>>>        String sError sWSFile
10020>>>        Handle hoWorkspace
10020>>>        Boolean bChangingWorkspace
10020>>>        
10020>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10020>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10020>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10020>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10020>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10020>>>        // that there should be no automatic opening of a worskpace.
10020>>>        Set psAutoOpenWorkspace to ""
10021>>>        
10021>>>        Get phoWorkspace to hoWorkspace
10022>>>        
10022>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10023>>>        If (bChangingWorkspace and ghoConnection) Begin
10025>>>            Send AutoDisconnect
10026>>>        End
10026>>>>
10026>>>        
10026>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10027>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10029>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10031>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10032>>>            End
10032>>>>
10032>>>        End
10032>>>>
10032>>>        If (eOpened <> wsWorkspaceOpened) Begin
10034>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10035>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10036>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10037>>>>
10037>>>            Abort
10038>>>>
10038>>>        End
10038>>>>
10038>>>        Else Begin
10039>>>            Send AutoConnect
10040>>>            Send OnWorkspaceOpened
10041>>>        End
10041>>>>
10041>>>    End_Procedure
10042>>>    
10042>>>    Procedure AutoConnect
10044>>>        If (ghoConnection) Begin
10046>>>            Send AutoConnect of ghoConnection
10047>>>        End
10047>>>>
10047>>>    End_Procedure
10048>>>    
10048>>>    Procedure AutoDisconnect
10050>>>        If (ghoConnection) Begin
10052>>>            Send AutoDisconnect of ghoConnection
10053>>>        End
10053>>>>
10053>>>    End_Procedure
10054>>>    
10054>>>    // send after a workspace is successfully opened and connected
10054>>>    Procedure OnWorkspaceOpened
10056>>>    End_Procedure
10057>>>    
10057>>>    Procedure OnCreate
10059>>>        // Event called when the Application object is ready to be used
10059>>>        // to open a Workspace, etc.
10059>>>    End_Procedure
10060>>>    
10060>>>    Procedure End_Construct_Object
10062>>>        String sName
10062>>>        Forward Send End_Construct_Object
10064>>>        Send OnCreate
10065>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10065>>>        Get psAutoOpenWorkspace to sName
10066>>>        If (sName<>"") Begin
10068>>>            Send DoOpenWorkspace sName
10069>>>        End
10069>>>>
10069>>>    End_Procedure
10070>>>    
10070>>>    Function GetApplicationFileName Returns String
10072>>>        // Returns the filename from Windows
10072>>>        Integer iNumChars
10072>>>        WString wFilename
10072>>>                
10072>>>        Move (Repeat(Character(0), 1024)) to wFilename
10073>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10074>>>        
10074>>>        Function_Return (CString(wFilename))
10075>>>    End_Function
10076>>>    
10076>>>    Function GetApplicationPath Returns String
10078>>>        // Returns the path of the Application (no trailing "\")
10078>>>        WString wApplicationFileName 
10078>>>        String sPath
10078>>>        Boolean bRemoved
10078>>>        
10078>>>        Get GetApplicationFileName  to wApplicationFileName
10079>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10080>>>        Move (CString(wApplicationFileName)) to sPath
10081>>>        
10081>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10084>>>        Function_Return sPath
10085>>>    End_Function
10086>>>    
10086>>>    Function GetApplicationName Returns String
10088>>>        // Returns the name of the Application (without its Path or Extension)
10088>>>        String sApplicationFileName 
10088>>>        WString wApplicationName
10088>>>        Boolean bRemoved
10088>>>        Integer iVoid
10088>>>        
10088>>>        Get GetApplicationFileName to sApplicationFileName
10089>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10090>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10091>>>        Function_Return (CString(wApplicationName))
10092>>>    End_Function
10093>>>    
10093>>>    Function DFRootPath Returns String
10095>>>        String sRoot
10095>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10098>>>        // Ensure it does not contain a trailing "\"
10098>>>        If (Right(sRoot,1) = "\") Begin
10100>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10101>>>        End
10101>>>>
10101>>>        Function_Return sRoot
10102>>>    End_Function
10103>>>    
10103>>>    Function DFBinPath Returns String
10105>>>        String sRoot
10105>>>        Get DFRootPath to sRoot
10106>>>        If (sRoot<>"") Begin
10108>>>            Move (sRoot+"\bin") to sRoot
10109>>>        End
10109>>>>
10109>>>        Else Begin
10110>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10110>>>            // bin path must be the same as the application path.
10110>>>            Get GetApplicationPath to sRoot
10111>>>        End
10111>>>>
10111>>>        Function_Return sRoot
10112>>>    End_Function
10113>>>    
10113>>>    // this just directs to the desktop property. If you are using an application object you are
10113>>>    // encouraged to set this here.
10113>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10115>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10116>>>    End_Procedure
10117>>>    
10117>>>    Function pbUseWindowsFont Returns Boolean
10119>>>        Boolean bUseWindowsFont
10119>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10120>>>        Function_Return bUseWindowsFont
10121>>>    End_Function
10122>>>    
10122>>>    // this just directs to the desktop property. If you are using an application object you are
10122>>>    // encouraged to set this here.
10122>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10124>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10125>>>    End_Procedure
10126>>>    
10126>>>    Function pbLegacyDialogRatio Returns Boolean
10128>>>        Boolean bLegacy
10128>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10129>>>        Function_Return bLegacy
10130>>>    End_Function
10131>>>End_Class
10132>>>
10132>>>
10132>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateHandler.pkg)
10132>>>//****************************************************************************
10132>>>// $Module type: Class
10132>>>// $Module name: cDbUpdateHandler
10132>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
10132>>>// Web-site    : http://www.rdctools.com
10132>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
10132>>>//
10132>>>// Purpose     : A framework for doing automated code based updates of a database from within
10132>>>//               a program, when it is started.
10132>>>//
10132>>>// Description : Place _one_ object of this class right after the cApplication object.
10132>>>//               Then inside this object place a series of cDbUpdateVersion objects
10132>>>//               as childs. One child object for each new database update.
10132>>>//
10132>>>//               - OnPreUpdate is a pre-processing event called
10132>>>//               before any database changes are started.
10132>>>//               - OnPostUpdate is a post-processing event called after all
10132>>>//               database changes have taken place.
10132>>>//
10132>>>// Note        : If tables have been opened prior to an object of this class
10132>>>//               (e.g. in the cApplication object), those tables will be closed.
10132>>>//               In that case you need to use the OnPostUpdate hook event to re-open
10132>>>//               tables after the last update has finished.
10132>>>//
10132>>>// Security    : Before an update is attempted; three things are checked to ensure the
10132>>>//               database is not in use. Aka nobody else is running the application.
10132>>>//               - All tables are tested for "Open in Exclusive_Mode"
10132>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
10132>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
10132>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
10132>>>//                 folder and a bit-lock is performed for each start of the application and this
10132>>>//                 user counter is checked before an update is attempted.
10132>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
10132>>>//                            against the database being "in use", there is no such guarantee! The
10132>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
10132>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
10132>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
10132>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
10132>>>//                 automatically be released after the update is completed.
10132>>>//
10132>>>//
10132>>>// Usage       :  Use cDbUpdateHandler.pkg
10132>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
10132>>>//                    // Declare the table that contains a "database version" field.
10132>>>//                    Declare_Datafile Sys
10132>>>//                    // Either one of these syntaxes is fine:
10132>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
10132>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
10132>>>//
10132>>>//                    // Don't forget to increase the pnVersionNumber property for each
10132>>>//                    // cDbUpdateVersion object!
10132>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
10132>>>//                    // with the value of pnVersionNumber after each update has been finished.
10132>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
10132>>>//                        Set pnVersionNumber to 1.1
10132>>>//                        Use VersionUpdate1_1.pkg
10132>>>//                    End_Object
10132>>>//
10132>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
10132>>>//                        Set pnVersionNumber to 1.2
10132>>>//                        Use VersionUpdate1_2.pkg
10132>>>//                    End_Object
10132>>>//
10132>>>//                End_Object
10132>>>//
10132>>>//
10132>>>// $Rev History:
10132>>>//    2016-09-27  Module header created
10132>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
10132>>>//                take place before any tables have been opened, or errors
10132>>>//                could occur if the client database is out of sync with the
10132>>>//                compiled program.
10132>>>//                Added user counting checks + lockout while database is being
10132>>>//                updated.
10132>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
10132>>>//                as it is more in line with the child class cDbUpdateVersion name.
10132>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
10132>>>//****************************************************************************
10132>>>Use VdfBase.pkg
10132>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dferror.pkg)
10132>>>>>Use LanguageText.pkg
10132>>>>>Use Windows.pkg
10132>>>>>Use msgbox.pkg
10132>>>>>Use GlobalFunctionsProcedures.pkg
10132>>>>>
10132>>>>>// Include or define all useful symbols.
10132>>>>>Use errornum.inc
10132>>>>>// these are kept for compatibility. Don't use them
10132>>>>>
10132>>>>>// used by error handler and UserError to pull a caption out of the error string
10132>>>>>Define C_ErrorCaption for "*CAPTION*="
10132>>>>>
10132>>>>>// This array stores the set of trapped errors as toggled ranges starting
10132>>>>>// with the errors that are trapped. The array should always contain 0 and
10132>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10132>>>>>// following items...
10132>>>>>//
10132>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10132>>>>>//
10132>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10132>>>>>// 10 through the rest are trapped.
10132>>>>>//
10132>>>>>Class Trapped_Errors_Array is an array
10133>>>>>    
10133>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10133>>>>>    Function findErrorLE Integer targetError Returns Integer
10135>>>>>        
10135>>>>>        Integer lowIndex hiIndex midIndex currError
10135>>>>>        
10135>>>>>        // If error is outside of boudary conditions, use
10135>>>>>        // value of closest valid error# instead.
10135>>>>>        If (targetError <= 0);            Move 1 to targetError
10138>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10142>>>>>        
10142>>>>>        Move 0 to lowIndex
10143>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10144>>>>>        
10144>>>>>        // midIndex will contain the closest error LE to target upon exit.
10144>>>>>        Repeat
10144>>>>>>
10144>>>>>            
10144>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10145>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10146>>>>>            
10146>>>>>            // midIndex is targetIndex if a match occurs
10146>>>>>            If (currError = targetError) ;                Function_Return midIndex
10149>>>>>            
10149>>>>>            // We are either on it or just below it.
10149>>>>>            If ( lowIndex = midIndex ) Begin
10151>>>>>                
10151>>>>>                If ( integer_value( Self, hiIndex ) <= targetError ) ;                    Move hiIndex to midIndex
10154>>>>>                
10154>>>>>                Function_Return midIndex
10155>>>>>                
10155>>>>>            End
10155>>>>>>
10155>>>>>            
10155>>>>>            // No match, so move the boundaries.
10155>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10158>>>>>            Else ;                Move midIndex to lowIndex
10160>>>>>            
10160>>>>>        Until (lowIndex > hiIndex)
10162>>>>>        
10162>>>>>        Function_Return midIndex        
10163>>>>>    End_Function
10164>>>>>    
10164>>>>>    // Boundaries of the table are assumed to hold error limits.
10164>>>>>    Procedure initArray
10166>>>>>        Send delete_data
10167>>>>>        Set array_value 0 to 0
10168>>>>>        Set array_value 1 to ( MAX_ERROR_NUMBER + 1 )
10169>>>>>    End_Procedure
10170>>>>>    
10170>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10170>>>>>    Function IsTrapped Integer Error# Returns Integer
10172>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10173>>>>>    End_Function
10174>>>>>    
10174>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10174>>>>>    // This routine leaves the array unsorted.
10174>>>>>    Procedure addError Integer Error#
10176>>>>>        If ( ( Error# < MAX_ERROR_NUMBER ) and ( Error# > 0 ) ) ;            Set array_value ( item_count( Self ) ) to ( Integer( Error# ) )
10179>>>>>    End_Procedure
10180>>>>>    
10180>>>>>    // Set error to flagged state.
10180>>>>>    Procedure handleError Integer Error# Integer trapFlag
10182>>>>>        
10182>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10182>>>>>        
10182>>>>>        If ( ( Error# > MAX_ERROR_NUMBER ) or ( Error# < 0 ) ) Begin
10184>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10185>>>>>>
10185>>>>>            Procedure_Return
10186>>>>>        End
10186>>>>>>
10186>>>>>        
10186>>>>>        Get findErrorLE Error# to prevErrIndex
10187>>>>>        Get isTrapped   Error# to prevErrFlag
10188>>>>>        
10188>>>>>        // if eq, Error already handled in some range.
10188>>>>>        If (prevErrFlag <> trapFlag) Begin
10190>>>>>            
10190>>>>>            // This is kind of complicated. If we are adding an error,
10190>>>>>            // we have to account for the error already being in the
10190>>>>>            // array as well as rejoining ranges that have been previously
10190>>>>>            // split and splitting ranges when adding a new flag.
10190>>>>>            
10190>>>>>            Get integer_value ( prevErrIndex + 1 ) to nextErrValue
10191>>>>>            Get integer_value prevErrIndex         to prevErrValue
10192>>>>>            
10192>>>>>            // Do this first so prevErrIndex stays valid.
10192>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10195>>>>>            Else ;                Send addError ( Error# + 1 )
10197>>>>>            
10197>>>>>            If ( prevErrValue < Error# ) ;                Send addError Error#
10200>>>>>            Else ;                Send delete_item prevErrIndex
10202>>>>>        End
10202>>>>>>
10202>>>>>        Send sort_items UPWARD_DIRECTION
10203>>>>>        
10203>>>>>    End_Procedure
10204>>>>>    
10204>>>>>    // Flag error as trappable
10204>>>>>    Procedure Trap_Error Integer Error#
10206>>>>>        Send handleError Error# 1
10207>>>>>    End_Procedure
10208>>>>>    
10208>>>>>    // Flag error as non-trappable
10208>>>>>    Procedure Ignore_Error Integer Error#
10210>>>>>        Send handleError Error# 0
10211>>>>>    End_Procedure
10212>>>>>    
10212>>>>>    // Flag all errors as trappable
10212>>>>>    Procedure Trap_All
10214>>>>>        Send initArray
10215>>>>>    End_Procedure
10216>>>>>    
10216>>>>>    // Flag all errors as non-trappable
10216>>>>>    Procedure Ignore_All
10218>>>>>        Send delete_data
10219>>>>>        Set array_value 0 to 0
10220>>>>>        Set array_value 1 to 1
10221>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10222>>>>>    End_Procedure
10223>>>>>    
10223>>>>>End_Class
10224>>>>>
10224>>>>>
10224>>>>>Class ErrorSystem is a cObject
10225>>>>>    
10225>>>>>    Procedure construct_object
10227>>>>>        Forward Send construct_object
10229>>>>>        
10229>>>>>        Set delegation_mode to no_delegate_or_error
10230>>>>>        
10230>>>>>        Property Integer Verbose_State            True
10231>>>>>        Property Integer Current_Error_Number     0
10232>>>>>        Property Integer Error_Line_Number        0
10233>>>>>        
10233>>>>>        // If set false, this makes the error handler work the old way which
10233>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10233>>>>>        Property Boolean pbUnhandledErrorSupport       True
10234>>>>>        
10234>>>>>        // shows error numbers with user errors. Only set this true if your
10234>>>>>        // application has meaningful numbers that helps the end user. Note that
10234>>>>>        // unhandled errors always show numbers.
10234>>>>>        // this is ignored if pbUnhandledErrorSupport is false
10234>>>>>        Property Boolean pbShowErrorNumber        False
10235>>>>>        
10235>>>>>        
10235>>>>>        // This is the caption that appears for unhandled errors dialog box
10235>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10236>>>>>        
10236>>>>>        // This is the caption that appears for standard user errors
10236>>>>>        Property String psUserErrorCaption C_$Error
10237>>>>>        
10237>>>>>        // Flag which is sent when error is being processed. This
10237>>>>>        // stops error recursion.
10237>>>>>        Property Integer Error_Processing_State  False
10238>>>>>        
10238>>>>>        // array of errors that we consider User Errors
10238>>>>>        Property Integer[] pUserErrorsArray
10239>>>>>        
10239>>>>>        //  This allows us to skip find errors (GT & LT) and to only
10239>>>>>        //  ring a bell when these occur.
10239>>>>>        //
10239>>>>>        Property Integer Bell_on_Find_Error_State True
10240>>>>>        
10240>>>>>        Object TrappedErrors is a Trapped_Errors_Array
10242>>>>>            Send initArray
10243>>>>>        End_Object
10244>>>>>        
10244>>>>>        Send Trap_All
10245>>>>>        
10245>>>>>        // define the standard user error numbers
10245>>>>>        Send AddUserError 0
10246>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE
10247>>>>>        Send AddUserError DFERR_WINDOW_RANGE
10248>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED
10249>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER
10250>>>>>        Send AddUserError DFERR_BAD_ENTRY
10251>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE
10252>>>>>        Send AddUserError DFERR_NUMERIC_RANGE
10253>>>>>        Send AddUserError DFERR_DUPLICATE_REC
10254>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG
10255>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE
10256>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE
10257>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
10258>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys
10259>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE
10260>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID
10261>>>>>        Send AddUserError DFERR_OPERATOR_ERROR
10262>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD
10263>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
10264>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED
10265>>>>>        Send AddUserError DFERR_OPERATOR
10266>>>>>        Send AddUserError DFERR_XML_HTTP
10267>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER
10268>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT
10269>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD
10270>>>>>        Send AddUserError DFERR_WINPRINT
10271>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
10272>>>>>        Send AddUserError DFERR_MAPI
10273>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
10274>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
10275>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
10276>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
10277>>>>>        // number of DDs.
10277>>>>>        Move Self to Error_Object_Id
10278>>>>>    End_Procedure
10279>>>>>    
10279>>>>>    Function Help_Context Integer Context_Type Returns String
10281>>>>>        Function_Return (Current_Error_Number(Self))
10282>>>>>    End_Function
10283>>>>>    
10283>>>>>    // Return true if Error is trapped, false otherwise.
10283>>>>>    Function IsTrapped Integer iError  Returns Boolean
10285>>>>>        Function_Return (IsTrapped(TrappedErrors(Self),iError))
10286>>>>>    End_Function
10287>>>>>    
10287>>>>>    // Pass error iError on to the regular DataFlex error handler.
10287>>>>>    Procedure IgnoreError Integer iError
10289>>>>>        Send Ignore_Error of (TrappedErrors(Self)) iError
10290>>>>>    End_Procedure
10291>>>>>    
10291>>>>>    // Catch and display error iError
10291>>>>>    Procedure TrapError Integer iError
10293>>>>>        Send Trap_Error of (TrappedErrors(Self)) iError
10294>>>>>    End_Procedure
10295>>>>>    
10295>>>>>    // Forward all error to regular DataFlex error handler.
10295>>>>>    Procedure IgnoreAllErrors
10297>>>>>        Send Ignore_All of (TrappedErrors(Self))
10298>>>>>    End_Procedure
10299>>>>>    
10299>>>>>    // Catch and display all errors.
10299>>>>>    Procedure TrapAllErrors
10301>>>>>        Send Trap_All of (TrappedErrors(Self))
10302>>>>>    End_Procedure
10303>>>>>        
10303>>>>>    // Catch and display error Error#.
10303>>>>>    Procedure Trap_Error Integer Error#
10305>>>>>        Send TrapError Error#
10306>>>>>    End_Procedure
10307>>>>>    
10307>>>>>    // Pass error Error# on to the regular DataFlex error handler.
10307>>>>>    Procedure Ignore_Error Integer Error#
10309>>>>>        Send IgnoreError Error#
10310>>>>>    End_Procedure
10311>>>>>    
10311>>>>>    // Catch and display all errors.
10311>>>>>    Procedure Trap_All
10313>>>>>        Send TrapAllErrors
10314>>>>>    End_Procedure
10315>>>>>    
10315>>>>>    // Forward all error to regular DataFlex error handler.
10315>>>>>    Procedure Ignore_All
10317>>>>>        Send IgnoreAllErrors
10318>>>>>    End_Procedure
10319>>>>>    
10319>>>>>    // Build complete error description from Flexerrs and user error message.
10319>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
10321>>>>>        String Full_Error_Text
10321>>>>>        
10321>>>>>        Move (Trim(ErrMsg)) to ErrMsg
10322>>>>>        Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
10323>>>>>        
10323>>>>>        If (ErrMsg<>"") Begin
10325>>>>>            
10325>>>>>            If ( ( Full_Error_Text<>"" ) and ;                error_text_available( DESKTOP, Error# ) ) Begin
10327>>>>>                // Make sure last character of error text is a separating symbol.
10327>>>>>                // if not, add a "." So we have format of "error-text. error-detail"
10327>>>>>                If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
10330>>>>>                Move (Full_Error_Text * ErrMsg) to Full_Error_Text
10331>>>>>            End
10331>>>>>>
10331>>>>>            Else ;                Move ErrMsg to Full_Error_Text
10333>>>>>            
10333>>>>>        End
10333>>>>>>
10333>>>>>        
10333>>>>>        Function_Return Full_Error_Text
10334>>>>>    End_Function
10335>>>>>    
10335>>>>>    // return true if an error number is critical
10335>>>>>    Function Is_Critical Integer Error# Returns Integer
10337>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(Error#)+"."))
10338>>>>>    End_Function
10339>>>>>    
10339>>>>>    // adds a user error to the array
10339>>>>>    Procedure AddUserError Integer iError
10341>>>>>        Integer[] UserErrors
10342>>>>>        Get pUserErrorsArray to UserErrors
10343>>>>>        // We assume that there are few enough user errors to worry about speed of finding
10343>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
10343>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
10345>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
10346>>>>>            Set pUserErrorsArray to UserErrors
10347>>>>>        End
10347>>>>>>
10347>>>>>    End_Procedure
10348>>>>>    
10348>>>>>    // removes an error from the user array
10348>>>>>    Procedure RemoveUserError Integer iError
10350>>>>>        Integer[] UserErrors
10351>>>>>        Integer iIndex iSize
10351>>>>>        Get pUserErrorsArray to UserErrors
10352>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
10353>>>>>        If (iIndex<>-1) Begin
10355>>>>>            // replace the removed error with the last error and resize the array
10355>>>>>            Move (SizeOfArray(UserErrors)) to iSize
10356>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
10357>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
10358>>>>>        End
10358>>>>>>
10358>>>>>    End_Procedure
10359>>>>>    
10359>>>>>    // removes all user errors
10359>>>>>    Procedure RemoveAllUserErrors
10361>>>>>        Integer[] UserErrors
10362>>>>>        Set pUserErrorsArray to UserErrors
10363>>>>>    End_Procedure
10364>>>>>    
10364>>>>>    // returns true if this is an unhandled error (i.e., not a user error
10364>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10366>>>>>        Integer[] UserErrors
10367>>>>>        Get pUserErrorsArray to UserErrors
10368>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10369>>>>>    End_Function
10370>>>>>    
10370>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
10372>>>>>        String sCaption sCRLF
10372>>>>>        Move (Character(13)+Character(10)) to sCRLF
10373>>>>>        Get psUnhandledErrorCaption to sCaption
10374>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
10375>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
10376>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
10377>>>>>    End_Procedure
10378>>>>>    
10378>>>>>    // Handle error event, displaying error info to user.
10378>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
10380>>>>>        Integer iReply iIcon
10380>>>>>        String  sErrorText sMess
10380>>>>>        String  sSource sCaption
10380>>>>>        Integer iSrcPos iSrc iTxtLen
10380>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
10380>>>>>        
10380>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
10382>>>>>            Procedure_Return                     // recursion
10383>>>>>        End
10383>>>>>>
10383>>>>>        
10383>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
10384>>>>>        
10384>>>>>        Set Current_Error_Number to ErrNum
10385>>>>>        Set Error_Line_Number    to Err_Line
10386>>>>>        
10386>>>>>        // if this is false, this will work old-style -- all errors go through message box
10386>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
10387>>>>>        
10387>>>>>        Get Is_Critical errnum to bCritical
10388>>>>>        Get IsUnhandledError ErrNum to bIsUnhandled
10389>>>>>        
10389>>>>>        
10389>>>>>        //
10389>>>>>        //   Changes made so find errors don't report - just beep
10389>>>>>        //
10389>>>>>        
10389>>>>>        If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
10391>>>>>            Send Bell
10392>>>>>        End
10392>>>>>>
10392>>>>>        Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
10395>>>>>            // if not trapped, do nothing
10395>>>>>            
10395>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
10395>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
10395>>>>>            // An easier way to do nothing, is to do nothing, hence this line if removed
10395>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
10395>>>>>        End
10395>>>>>>
10395>>>>>        Else Begin
10396>>>>>            
10396>>>>>            // See if source information is provided (Source = module.function). If so remove
10396>>>>>            // as detail. Must find last instance of this in string
10396>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
10397>>>>>            If iSrc Begin
10399>>>>>                Move (iSrc-1) to iSrcPos
10400>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
10401>>>>>                Move ErrMsg to sSource
10402>>>>>                Repeat // this makes sure we find last instance of this
10402>>>>>>
10402>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
10403>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
10404>>>>>                    If iSrc ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
10407>>>>>                Until (iSrc=0)
10409>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
10410>>>>>                If (right(ErrMsg,1)=',') ;                    Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
10413>>>>>            End
10413>>>>>>
10413>>>>>            
10413>>>>>            // the caption normally used for handled user errors
10413>>>>>            Get psUserErrorCaption to sCaption
10414>>>>>            // if an operator error this may be a Procedure UserError situation where the
10414>>>>>            // caption is passed in the error text. If so, get the caption
10414>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
10416>>>>>                Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
10417>>>>>                If iSrc Begin
10419>>>>>                    Move (length(C_ErrorCaption)) to  iTxtLen
10420>>>>>                    Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
10421>>>>>                    Move (Left(ErrMsg,iSrc-1)) to ErrMsg
10422>>>>>                End
10422>>>>>>
10422>>>>>            End
10422>>>>>>
10422>>>>>            
10422>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
10423>>>>>            
10423>>>>>            // if the error source is identified we can get extended error
10423>>>>>            // text for our error message
10423>>>>>            If ghoErrorSource Begin
10425>>>>>                Get extended_error_Message of ghoErrorSource to sMess
10426>>>>>                If (sMess <> '') ;                    Move (sErrorText + "\n\n" + sMess ) to sErrorText
10429>>>>>            End
10429>>>>>>
10429>>>>>            
10429>>>>>            If (bUnhandledSupport) Begin
10431>>>>>                // as of 14.1, this is the preferred way to do errors
10431>>>>>                If ( bCritical or bIsUnhandled) Begin
10433>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10434>>>>>                    If (sSource<>"") Begin
10436>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10437>>>>>                    End
10437>>>>>>
10437>>>>>                End
10437>>>>>>
10437>>>>>                Else If (pbShowErrorNumber(Self)) Begin
10440>>>>>                    // if a user error, we provide a way to see error numbers.
10440>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10441>>>>>                End
10441>>>>>>
10441>>>>>            End
10441>>>>>>
10441>>>>>            Else Begin
10442>>>>>                // we get here if we want it to work the old (less good) way. This is provided
10442>>>>>                // only for backwards compatibility. All errors go through the message box
10442>>>>>                Get Verbose_State to bVerbose
10443>>>>>                If (bVerbose)  Begin
10445>>>>>                    Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
10446>>>>>                    If (sSource<>"") Begin
10448>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10449>>>>>                    End
10449>>>>>>
10449>>>>>                End
10449>>>>>>
10449>>>>>            End
10449>>>>>>
10449>>>>>            
10449>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
10451>>>>>                Send UnhandledErrorDisplay Err_Line sErrorText
10452>>>>>            End
10452>>>>>>
10452>>>>>            Else Begin
10453>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
10454>>>>>                Move (Message_Box(sErrorText, sCaption, MB_Ok, iIcon)) to iReply
10455>>>>>            End
10455>>>>>>
10455>>>>>            
10455>>>>>            // abort on critical errors
10455>>>>>            If bCritical ;                Abort
10458>>>>>            
10458>>>>>        End
10458>>>>>>
10458>>>>>        Move 0 to ghoErrorSource
10459>>>>>        Set Error_Processing_State to False // no longer reporting an error
10460>>>>>    End_Procedure
10461>>>>>    
10461>>>>>    
10461>>>>>    // The following functions are rarely or never used.
10461>>>>>    
10461>>>>>    // The functions below are used to construct a general help
10461>>>>>    // name for errors that are generated by the system.  If processing
10461>>>>>    // comes here, then there was no module specific help found.  These
10461>>>>>    // functions will provide a more general help name that appears in
10461>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
10461>>>>>    // places in the help file under this application and module name.
10461>>>>>    
10461>>>>>    // Returns "ERROR:errornum" to supply error help.
10461>>>>>    Function Help_Name Returns String
10463>>>>>        Function_Return (Append("ERROR:",lastErr))
10464>>>>>    End_Function
10465>>>>>    
10465>>>>>    Function Application_Name Returns String
10467>>>>>        Function_Return 'SYSTEM'
10468>>>>>    End_Function
10469>>>>>    
10469>>>>>    Function Module_Name Returns String
10471>>>>>        Function_Return ''
10472>>>>>    End_Function
10473>>>>>End_Class
10474>>>>>
10474>>>>>Object Error_Info_Object is a ErrorSystem
10476>>>>>End_Object
10477>>>>>
10477>>>>>Procedure UserError Global String sMessage String sCaption
10479>>>>>    String sCapt
10479>>>>>    If (Error_Object_Id=0) Begin
10481>>>>>        Error DFERR_PROGRAM "No Error Handler"
10482>>>>>>
10482>>>>>        Procedure_Return
10483>>>>>    End
10483>>>>>>
10483>>>>>    
10483>>>>>    // Accept not passing a caption in which case the error handler's
10483>>>>>    // default caption. It had been the intention to require a caption ("" if none)
10483>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
10483>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
10483>>>>>    If (num_arguments>1) Begin
10485>>>>>        Move sCaption to sCapt
10486>>>>>    End
10486>>>>>>
10486>>>>>    
10486>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
10487>>>>>>
10487>>>>>End_Procedure
10488>>>Use seq_chnl.pkg
10488>>>Use Datadict.pkg
Including file: Datadict.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Datadict.pkg)
10488>>>>>Use VDFBase.pkg
10488>>>>>Use LanguageText.pkg // language support VDF pkg replacement strings
10488>>>>>
10488>>>>>Register_Procedure File_Field_Value_Changed
10488>>>>>Register_Procedure File_Field_Mask_Changed
10488>>>>>Register_Procedure File_Field_Label_Changed
10488>>>>>Register_Procedure File_Field_Option_Changed
10488>>>>>Register_Function  Extended_DEO_State Returns Integer
10488>>>>>Register_Function  Entry_Refresh_State Returns Integer
10488>>>>>Register_Procedure Set Entry_Refresh_State Integer iState
10488>>>>>Register_Function  Allow_Foreign_New_Save_State Returns Integer
10488>>>>>Register_Function  Server Returns Integer
10488>>>>>
10488>>>>>Use Data_Set.pkg
Including file: Data_set.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Data_set.pkg)
10488>>>>>>>Use VDFBase.pkg
10488>>>>>>>Use fndmodes.pkg
Including file: fndmodes.pkg    (C:\Program Files\DataFlex 20.1\Pkg\fndmodes.pkg)
10488>>>>>>>>>//
10488>>>>>>>>>// special find modes
10488>>>>>>>>>//
10488>>>>>>>>>Define NEXT_RECORD  for 5 // find-next
10488>>>>>>>>>Define FIRST_RECORD for 6 // find-first
10488>>>>>>>>>Define LAST_RECORD  for 7 // find-last 
10488>>>>>>>Use refmodes.pkg
Including file: refmodes.pkg    (C:\Program Files\DataFlex 20.1\Pkg\refmodes.pkg)
10488>>>>>>>>>//
10488>>>>>>>>>// constants for REFRESH message parameter values
10488>>>>>>>>>//
10488>>>>>>>>>Define MODE_CLEAR             for 1  //notification from origin of clear
10488>>>>>>>>>Define MODE_FIND_OR_CLEAR_SET for 2  //notification from find or clear
10488>>>>>>>>>Define MODE_CLEAR_ALL         for 3  //notification from clear-all
10488>>>>>>>>>Define MODE_DELETE            for 4  //notification after successful delete
10488>>>>>>>>>Define MODE_SAVE              for 5  //notification after successful save
10488>>>>>>>>>
10488>>>>>>>
10488>>>>>>>
10488>>>>>>>//
10488>>>>>>>//Global integer status values
10488>>>>>>>//
10488>>>>>>>Define OPERATION_MODE   for |VI99  //status of data-sets in application
10488>>>>>>>Define OPERATION_ORIGIN for |VI108 //origin of current of data-set operation
10488>>>>>>>
10488>>>>>>>//
10488>>>>>>>//Constants for Operation_Mode global int values
10488>>>>>>>//
10488>>>>>>>Define MODE_WAITING  for 0  //wait-mode
10488>>>>>>>Define MODE_FINDING  for 1  //find-mode
10488>>>>>>>Define MODE_CLEARING for 2  //clear-mode
10488>>>>>>>Define MODE_CREATING for 3  //create-mode
10488>>>>>>>Define MODE_SAVING   for 4  //save-mode
10488>>>>>>>Define MODE_DELETING for 5  //delete-mode
10488>>>>>>>Define MODE_ABORTING for 6  //abort-mode
10488>>>>>>>Define MODE_VALIDATING for 7  //request_validate-mode : added for VDF7
10488>>>>>>>Define MODE_CLEARINGALL for 8 //clear-all mode (added in VDF8)
10488>>>>>>>
10488>>>>>>>//   The Data_Set class is implemented as a subclass of Entry_Client, with
10488>>>>>>>//   a C language handler providing the majority of new behavior.  The
10488>>>>>>>//   Data_Set class is intended to be a grouping agent for data-entry objects
10488>>>>>>>//   and a container for subordinate Data_Sets.
10488>>>>>>>//
10488>>>>>>>Use BaseData_Set.pkg
10488>>>>>>>
10488>>>>>>>// Data_Set class definition, public class layer. (Extra class layer needed
10488>>>>>>>// to augment C-based (Constrain) procedure(s).)
10488>>>>>>>
10488>>>>>>>Class DataSet is a BaseData_Set
10489>>>>>>>    
10489>>>>>>>    
10489>>>>>>>    // maintain old name for the time being to maximize compatability
10489>>>>>>>    // between character mode and windows versions. Developers should be
10489>>>>>>>    // able to move DS classes back and forth without changes.
10489>>>>>>>    Replace_Class_Name Data_Set DataSet
10489>>>>>>>    
10489>>>>>>>    Procedure Construct_Object //Integer Img#
10491>>>>>>>        Forward Send Construct_Object No_Image //Img#
10493>>>>>>>        
10493>>>>>>>        Property Integer Constrain_File 0
10494>>>>>>>        Property Integer Auto_Fill_State False
10495>>>>>>>        Property Integer Change_Disabled_State  False
10496>>>>>>>        // RT sets this inside of Mark_components a part of old entry_client DSO behavior. Now it is never used
10496>>>>>>>        Property Integer Component_State False
10497>>>>>>>        
10497>>>>>>>    End_Procedure
10498>>>>>>>    
10498>>>>>>>    
10498>>>>>>>    //
10498>>>>>>>    // This may be called by legacy DSO and DDO code
10498>>>>>>>    //
10498>>>>>>>    // IMPORTANT NOTE of change for 8.2:
10498>>>>>>>    //         DO NOT call or augment this anymore.
10498>>>>>>>    //
10498>>>>>>>    //         for sending: Find all cases of Field_main_index and change it to File_Field_Index
10498>>>>>>>    //
10498>>>>>>>    //         for augmenting: In DSOs - replace Field_main_index with File_field_index
10498>>>>>>>    //                         In DDOs - replace Field_main_Index with Field_Index and do not pass
10498>>>>>>>    //                                   the file parameter.
10498>>>>>>>    //                                   See DDOs Field_index and File_field_Index for more
10498>>>>>>>    //
10498>>>>>>>    Function Field_Main_Index Integer file Integer Field Returns Integer
10500>>>>>>>        Integer dataType fldNdx retval ordr
10500>>>>>>>        Move -1 to retval      //field has no main index (default)
10501>>>>>>>        If (file <> 0) Begin
10503>>>>>>>//      FIELD_DEF file field to dataType fldNdx
10503>>>>>>>            Get_Attribute DF_FIELD_INDEX of file Field to fldNdx // main index field
10506>>>>>>>            If (fldNdx > 0 or Field = 0) ;                Move fldNdx to retval //field has main index
10509>>>>>>>        End
10509>>>>>>>>
10509>>>>>>>        If (file = main_file(Self)) Begin
10511>>>>>>>            Get ordering to ordr
10512>>>>>>>            If (ordr >= 0) ;                Move ordr to retval  //ordering takes precedence over main index
10515>>>>>>>        End
10515>>>>>>>>
10515>>>>>>>        Function_Return retval
10516>>>>>>>    End_Function
10517>>>>>>>    
10517>>>>>>>    // This allows packages that still use data-sets instead of DDOs to use this
10517>>>>>>>    // message syntax.
10517>>>>>>>    // Note that this will never get here if the DD class is used as
10517>>>>>>>    // it has its own handler for this. It only is called if DSOs are used in which
10517>>>>>>>    // case it calls the old message field_main_index above.
10517>>>>>>>    // DDO based objects will NEVER call this code
10517>>>>>>>    //
10517>>>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
10519>>>>>>>        Function_Return (Field_main_Index(Self,iFile,iField))
10520>>>>>>>    End_Function
10521>>>>>>>    
10521>>>>>>>    
10521>>>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
10523>>>>>>>        
10523>>>>>>>        RowID   riRow
10523>>>>>>>        Integer iIndex
10523>>>>>>>        Handle  hoServer
10523>>>>>>>        Integer iSegments iSeg iSegFld iSegFldMainIndex
10523>>>>>>>        Boolean bChanged bDoCheck bOk
10523>>>>>>>        
10523>>>>>>>        //Get Field_Main_Index iFile iField to iIndex
10523>>>>>>>        Get File_Field_Index iFile iField to iIndex
10524>>>>>>>        If (iIndex<>-1) Begin
10526>>>>>>>            // get prior rowId before it get cleared
10526>>>>>>>            Move (GetRowID(iFile)) to riRow
10527>>>>>>>            //  'hold' buffer to prepare for entry_update
10527>>>>>>>            Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
10530>>>>>>>            If bDoEntryUpdate Begin
10532>>>>>>>                Send Request_Entry_Update iFile 1  //entUpdt all DEOs as required
10533>>>>>>>                
10533>>>>>>>                // If the buffer is cleared (no record and no changed data) then we want
10533>>>>>>>                // to do a constrained_clear which will force the buffer to get cleared
10533>>>>>>>                // according to the rules of the current constraints.
10533>>>>>>>                //Get_field_value iFile 0 to iRec
10533>>>>>>>                //Move (GetRowID(iFile)) to riRow // 12.1 moved above the set file inactive
10533>>>>>>>                
10533>>>>>>>                // If there was an active record to begin with we consider this changed (not cleared)
10533>>>>>>>                If (not(IsNullRowId(riRow))) Begin
10535>>>>>>>                    Move True to bChanged
10536>>>>>>>                End
10536>>>>>>>>
10536>>>>>>>                Else Begin
10537>>>>>>>                    // or, if the record was already changed or the entry_update created a change
10537>>>>>>>                    // we consider this changed
10537>>>>>>>                    Get_Attribute DF_FILE_CHANGED of iFile to bChanged
10540>>>>>>>                End
10540>>>>>>>>
10540>>>>>>>                
10540>>>>>>>                If not bChanged Begin
10542>>>>>>>                    // if buffer is unchanged, do a constrained clear. It is unchanged if there was not
10542>>>>>>>                    // active record, the record was unchanged, and the update didn't change anything.
10542>>>>>>>                    Constrained_Clear eFindMode iFile by iIndex
10545>>>>>>>                End
10545>>>>>>>>
10545>>>>>>>                Else If (eFindMode=GE or eFindMode=LE and iIndex>0) Begin
10548>>>>>>>                    
10548>>>>>>>                    // If mode is GE or LE we need to do some extra processing. We want to clear
10548>>>>>>>                    // all index segemnt fields that occur after this field in the index. This way
10548>>>>>>>                    // dbList searches and find ge searches (f9) will always find the first record
10548>>>>>>>                    // that matches the data in the field being searched. This was if an index like
10548>>>>>>>                    // customer.name x customer.number where you had 10 identical names "john" typing
10548>>>>>>>                    // john will find the first record, because customer.number will get cleared.
10548>>>>>>>                    // Note we can no do this with GT or LT or you'd get stuck in fields
10548>>>>>>>                    
10548>>>>>>>                    // check all fields for index. Once you find the iField field, clear all
10548>>>>>>>                    // fields that follow it. Only do this if the other fields do not use the
10548>>>>>>>                    // same index as its primary index (in which case we assume the data is intentional).
10548>>>>>>>                    // This should handle most cases.
10548>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
10551>>>>>>>                    For iSeg from 1 to iSegments
10557>>>>>>>>
10557>>>>>>>                        Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSeg to iSegFld
10560>>>>>>>                        If not bDoCheck Begin
10562>>>>>>>                            If (iSegFld=iField) ;                                Move True to bDoCheck // marked after we find the find field in the index
10565>>>>>>>                        End
10565>>>>>>>>
10565>>>>>>>                        Else Begin // we get here after we've found the main field segment
10566>>>>>>>                            // if main index if this segment is same as our find index, do nothing
10566>>>>>>>                            Get File_Field_Index iFile iSegFld to iSegFldMainIndex
10567>>>>>>>                            If (iSegFldMainIndex<>iIndex) ;                                Set_Field_Value iFile iSegFld to ''
10572>>>>>>>                        End
10572>>>>>>>>
10572>>>>>>>                    Loop
10573>>>>>>>>
10573>>>>>>>                End
10573>>>>>>>>
10573>>>>>>>                
10573>>>>>>>                Get Which_Data_Set iFile to hoServer
10574>>>>>>>                If (hoServer and iFile=main_file(hoServer)) ;                    Send Attach_Main_File to hoServer
10577>>>>>>>                Else ;                    Attach iFile
10579>>>>>>>            End
10579>>>>>>>>
10579>>>>>>>            
10579>>>>>>>            Move False to Err
10580>>>>>>>            
10580>>>>>>>            If (Is_SuperFind_Required(Self,iFile)) ;                Send Request_SuperFind eFindMode iFile iField
10583>>>>>>>            Else If bDeferred ;                Send Request_Read eFindMode iFile iIndex
10587>>>>>>>            Else ;                Send Request_Find eFindMode iFile iIndex
10589>>>>>>>            
10589>>>>>>>            If (not(Found) and not(err)) Begin
10591>>>>>>>                // refind original record (or leave it cleared if not record)
10591>>>>>>>                Move (FindByRowId(iFile,riRow)) to bOk
10592>>>>>>>                
10592>>>>>>>                If bShowFindErr ;                    Error (If(eFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
10595>>>>>>>                Move False to Found
10596>>>>>>>            End
10596>>>>>>>>
10596>>>>>>>        End
10596>>>>>>>>
10596>>>>>>>        Else ;            If bShowFindErr ;                Error DFERR_FIELD_NOT_INDEXED
10600>>>>>>>    End_Procedure
10601>>>>>>>    
10601>>>>>>>    
10601>>>>>>>    // We only care about should_saves of DEOs and not DSOs when
10601>>>>>>>    // exiting the app. Create a handler for data set class. We still
10601>>>>>>>    // broadcast in case we've got nested deos in the dso (hopefully not).
10601>>>>>>>    //
10601>>>>>>>    Function Exit_Application_Check Returns Integer
10603>>>>>>>        Integer rVal
10603>>>>>>>        Broadcast Get Exit_Application_Check to Rval // check w/ kids
10605>>>>>>>        Function_Return rVal
10606>>>>>>>    End_Function
10607>>>>>>>    
10607>>>>>>>    Procedure Constrain
10609>>>>>>>        Integer iFile
10609>>>>>>>        Send OnConstrain
10610>>>>>>>        Forward Send Constrain
10612>>>>>>>        Get Constrain_File to iFile
10613>>>>>>>        If iFile ;            Constrain (Main_file(Self)) relates to iFile
10616>>>>>>>    End_Procedure
10617>>>>>>>    
10617>>>>>>>    Procedure OnConstrain
10619>>>>>>>    End_Procedure
10620>>>>>>>    
10620>>>>>>>    // Less confusing Message for adding Updating servers
10620>>>>>>>    //
10620>>>>>>>    Procedure Set DDO_Server Handle ObjId
10622>>>>>>>        Send Attach_Server ObjId
10623>>>>>>>    End_Procedure
10624>>>>>>>    
10624>>>>>>>    // This is called when a view takes or retakes the
10624>>>>>>>    // focus. If DD not in use, do nothing.
10624>>>>>>>    //
10624>>>>>>>    Procedure Refind_DD_Records
10626>>>>>>>        If (in_use_state(Self)) ;            Send refind_records
10629>>>>>>>    End_Procedure
10630>>>>>>>    
10630>>>>>>>    // this returns true if the data-set is changed AND there are attached
10630>>>>>>>    // DEO objects. Without this you can get "changes exist" condition reported
10630>>>>>>>    // that the user will have no way of saving.
10630>>>>>>>    //
10630>>>>>>>    Function Data_Set_Should_Save Returns Integer
10632>>>>>>>        Function_Return (Should_Save(Self) and ;            Data_Set_User_interface_count(Self))
10633>>>>>>>    End_Function
10634>>>>>>>    
10634>>>>>>>    // returns 0 indicating that this is not DD enabled. DataDictionary objects will return 1.
10634>>>>>>>    // Add DSOs and DDOs must understand this message
10634>>>>>>>    
10634>>>>>>>    Function Extended_DSO_State Returns Integer
10636>>>>>>>        Function_Return 0
10637>>>>>>>    End_Function
10638>>>>>>>    
10638>>>>>>>    
10638>>>>>>>End_Class
10639>>>>>>>
10639>>>>>>>
10639>>>>>>>
10639>>>>>Use DDValtbl.pkg  // validation table classes
Including file: Ddvaltbl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Ddvaltbl.pkg)
10639>>>>>>>//  Validation Table Support for Extended Data-Sets. Fields may
10639>>>>>>>//  attached to validation tables which can then be used for
10639>>>>>>>//  validation (if Validate_state is true) or list loading.
10639>>>>>>>//  Developers can create their own validation tables as long as they
10639>>>>>>>//  conform to the following external interface:
10639>>>>>>>//
10639>>>>>>>// Properties
10639>>>>>>>//   Static_State       - if list must be rebuilt each validation, load
10639>>>>>>>//   Allow_Blank_state  - If Blank or 0 is a valid response
10639>>>>>>>//   Validate_State     - should table be used for validation
10639>>>>>>>//   Table_Loaded_State - is the validation table initialized?
10639>>>>>>>//
10639>>>>>>>// Methods
10639>>>>>>>//  Get Validate_Value sValue to iVal - if iVal=0, it is legal
10639>>>>>>>//  Send Fill_list                    - fills a static list
10639>>>>>>>//  Send Request_Fill_From_List iObject iMessage
10639>>>>>>>//        This is a callback that will fill an external list by sending
10639>>>>>>>//        the passed message (iMessage) back to the requesting object
10639>>>>>>>//        (iObject). It will send this message for each item in the
10639>>>>>>>//        validation table. It always passes back four params. Those are:
10639>>>>>>>//                     iItem - Item count being passed back
10639>>>>>>>//                     sData - The Database value of the item
10639>>>>>>>//                     sDesc - The Value's description, "" if none
10639>>>>>>>//                     iFile - File number associated with the item (if any)
10639>>>>>>>//                     iRec  - Record associated with the item (if any)
10639>>>>>>>// Developers can create classes of any complexity to support validation
10639>>>>>>>// tables. We have provided the following four classes.
10639>>>>>>>//
10639>>>>>>>//  ValidationTable is an Array
10639>>>>>>>//           Provides simple one dimensional table support. The table must be
10639>>>>>>>//           loaded manually by creating fill_list and sending the message
10639>>>>>>>//           Add_Table_Value (send Add_Table_Value Value). If list is static
10639>>>>>>>//           it is filled once. If non-static it is filled each time it is
10639>>>>>>>//           requested to validate or fill a foreign lis.
10639>>>>>>>//
10639>>>>>>>//  DescriptionValidationTable is a ValidationTable
10639>>>>>>>//           Provides a more complex three dimension array allowing the
10639>>>>>>>//           object to store a data value, description value and a record
10639>>>>>>>//           number. The developer must fill this list using the Add_table_
10639>>>>>>>//           value message passing up to three values (data, desc, record).
10639>>>>>>>//
10639>>>>>>>//  FileValidationTable is a DescriptionValidationTable
10639>>>>>>>//           Provides a data aware table. This can be used to load data from
10639>>>>>>>//           data-files, from data-sets. If you use data-sets you can place
10639>>>>>>>//           constraints within the data-set. You must define the file-number,
10639>>>>>>>//           data-set (if any), the file index, the file's data field, and
10639>>>>>>>//           the file's description field. You can also define an optional
10639>>>>>>>//           "Type". All records are constrained to this type (with or with-
10639>>>>>>>//           data-sets). If is assumed that this file has an optimized finding
10639>>>>>>>//           index.
10639>>>>>>>//
10639>>>>>>>//  CodeValidationTable is a FileValidationTable
10639>>>>>>>//           Used for Code lists. Simply set Type_Value to the "type"
10639>>>>>>>//
10639>>>>>>>Use VDFBase.pkg
10639>>>>>>>
10639>>>>>>>
10639>>>>>>>Class ValidationTable is an Array
10640>>>>>>>    
10640>>>>>>>    Procedure Construct_Object
10642>>>>>>>        Forward Send Construct_Object
10644>>>>>>>        Property Integer Static_State        True
10645>>>>>>>        
10645>>>>>>>        Property Integer Table_Loaded_State  False
10646>>>>>>>        
10646>>>>>>>        Property Integer Validate_State      True
10647>>>>>>>        Property Integer Allow_Blank_State   False
10648>>>>>>>        Property Integer Main_File           0
10649>>>>>>>        Property String  Table_Title         DD_VALIDATION_LIST_TITLE
10650>>>>>>>        
10650>>>>>>>        Property Integer Number_Elements     1
10651>>>>>>>        
10651>>>>>>>        // System maintained. Sub-classes use these
10651>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
10651>>>>>>>        
10651>>>>>>>        Property String  Current_Code            ''
10652>>>>>>>        
10652>>>>>>>        Property String  Current_Description     ''
10653>>>>>>>        
10653>>>>>>>        Property RowID Current_RowId
10654>>>>>>>    End_Procedure
10655>>>>>>>    
10655>>>>>>>    Function Data_Item_Count Returns Integer
10657>>>>>>>        Function_Return (Item_Count(Self))
10658>>>>>>>    End_Function
10659>>>>>>>    
10659>>>>>>>    Function Data_Value Integer iItem Returns String
10661>>>>>>>        Function_Return (Value(Self,iItem))
10662>>>>>>>    End_Function
10663>>>>>>>    
10663>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
10665>>>>>>>        Set Value  iItem to sValue
10666>>>>>>>    End_Procedure
10667>>>>>>>    
10667>>>>>>>    Function Data_Description Integer iItem Returns String
10669>>>>>>>        Function_Return ''
10670>>>>>>>    End_Function
10671>>>>>>>    
10671>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
10673>>>>>>>    End_Procedure
10674>>>>>>>    
10674>>>>>>>    Function Data_RowId Integer iItem Returns RowID
10676>>>>>>>        Function_Return (NullRowId())
10677>>>>>>>    End_Function
10678>>>>>>>    
10678>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
10680>>>>>>>    End_Procedure
10681>>>>>>>    
10681>>>>>>>    
10681>>>>>>>    Procedure Add_Table_Value String sValue
10683>>>>>>>        Set Data_Value  (Data_Item_Count(Self)) to sValue
10684>>>>>>>    End_Procedure
10685>>>>>>>    
10685>>>>>>>    Function Validate_Value String sCode Returns Integer
10687>>>>>>>        Integer iMax
10687>>>>>>>        Integer iCnt
10687>>>>>>>        If (sCode = '');            Function_Return (not(Allow_Blank_State(Self)))
10690>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10692>>>>>>>            Send Delete_Data
10693>>>>>>>            Send Fill_list
10694>>>>>>>            Set Table_Loaded_State to True
10695>>>>>>>        End
10695>>>>>>>>
10695>>>>>>>        Get Data_Item_Count to iMax
10696>>>>>>>        Decrement iMax
10697>>>>>>>        For iCnt from 0 to iMax
10703>>>>>>>>
10703>>>>>>>            If (sCode=Data_Value(Self,iCnt)) Begin
10705>>>>>>>                Set Current_Code        to sCode
10706>>>>>>>                Set Current_Description to (Data_Description(Self,iCnt))
10707>>>>>>>                Set Current_RowId       to (Data_RowId(Self,iCnt))
10708>>>>>>>                Function_Return 0
10709>>>>>>>            End
10709>>>>>>>>
10709>>>>>>>        Loop
10710>>>>>>>>
10710>>>>>>>        Function_Return 1 // 0=OK
10711>>>>>>>    End_Function
10712>>>>>>>    
10712>>>>>>>    Function Find_Code_Description String sCode Returns String
10714>>>>>>>        If (sCode='' or ;            (sCode<>Current_Code(Self) and ;            Validate_Value(Self,sCode) ) );            Function_Return ''
10717>>>>>>>        Function_Return (Current_Description(Self))
10718>>>>>>>    End_Function
10719>>>>>>>    
10719>>>>>>>    
10719>>>>>>>    //  The deveveloper (or a sub-class) must fill this list. It is done
10719>>>>>>>    //  by finding the item and sending the Message:
10719>>>>>>>    //    Send Add_Table_Value sValue {sDescr}
10719>>>>>>>    //
10719>>>>>>>    Procedure Fill_List
10721>>>>>>>        Set Table_Loaded_State to True
10722>>>>>>>    End_Procedure
10723>>>>>>>    
10723>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
10725>>>>>>>        Integer iMax
10725>>>>>>>        Integer iCnt
10725>>>>>>>        Integer iFile
10725>>>>>>>        
10725>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
10728>>>>>>>        
10728>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10730>>>>>>>            Send Delete_Data
10731>>>>>>>            Send Fill_list
10732>>>>>>>            Set Table_Loaded_State to True
10733>>>>>>>        End
10733>>>>>>>>
10733>>>>>>>        Get Main_File to iFile
10734>>>>>>>        Get Data_Item_Count to iMax
10735>>>>>>>        Decrement iMax
10736>>>>>>>        For iCnt from 0 to iMax
10742>>>>>>>>
10742>>>>>>>            Send iMsg to iObj iCnt (Data_Value(Self,iCnt)) ;                (Data_Description(Self,iCnt)) iFile ;                (Data_RowId(Self,iCnt))
10743>>>>>>>        Loop
10744>>>>>>>>
10744>>>>>>>    End_Procedure
10745>>>>>>>    
10745>>>>>>>    
10745>>>>>>>    // returns all data in a two dimension variant array.
10745>>>>>>>    // [i][0] = data
10745>>>>>>>    // [i][1] = description
10745>>>>>>>    // This can be used by Crystal CDO classes (this is why a variant array is used)
10745>>>>>>>    Function TableData Returns Variant[][]
10747>>>>>>>        Variant[][2] vData
10748>>>>>>>        Integer iMax i
10748>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10750>>>>>>>            Send Delete_Data
10751>>>>>>>            Send Fill_list
10752>>>>>>>            Set Table_Loaded_State to True
10753>>>>>>>        End
10753>>>>>>>>
10753>>>>>>>        Get Data_Item_Count to iMax
10754>>>>>>>        For i from 0 to (iMax-1)
10760>>>>>>>>
10760>>>>>>>            Get Data_Value       i to vData[i][0]
10761>>>>>>>            Get Data_Description i to vData[i][1]
10762>>>>>>>        Loop
10763>>>>>>>>
10763>>>>>>>        Function_Return vData
10764>>>>>>>    End_Function
10765>>>>>>>    
10765>>>>>>>End_Class
10766>>>>>>>
10766>>>>>>>
10766>>>>>>>
10766>>>>>>>Class DescriptionValidationTable is an ValidationTable
10767>>>>>>>    
10767>>>>>>>    Procedure Construct_Object
10769>>>>>>>        Forward Send Construct_Object
10771>>>>>>>        Set Number_Elements to 2
10772>>>>>>>    End_Procedure
10773>>>>>>>    
10773>>>>>>>    Function Data_Item_Count Returns Integer
10775>>>>>>>        Function_Return (item_count(Self)/3)
10776>>>>>>>    End_Function
10777>>>>>>>    
10777>>>>>>>    Function Data_Value Integer iItem Returns String
10779>>>>>>>        Function_Return (Value(Self,iItem*3))
10780>>>>>>>    End_Function
10781>>>>>>>    
10781>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
10783>>>>>>>        Set Value  (iItem*3) to sValue
10784>>>>>>>    End_Procedure
10785>>>>>>>    
10785>>>>>>>    Function Data_Description Integer iItem Returns String
10787>>>>>>>        Function_Return (Value(Self,iItem*3+1))
10788>>>>>>>    End_Function
10789>>>>>>>    
10789>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
10791>>>>>>>        Set Value  (iItem*3+1) to sValue
10792>>>>>>>    End_Procedure
10793>>>>>>>    
10793>>>>>>>    Function Data_RowId Integer iItem Returns RowID
10795>>>>>>>        String sRowId
10795>>>>>>>        Get Value (iItem*3+2) to sRowId
10796>>>>>>>        Function_Return (DeSerializeRowId(sRowId))
10797>>>>>>>    End_Function
10798>>>>>>>    
10798>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
10800>>>>>>>        Set Value  (iItem*3+2) to (SerializeRowId(riValue))
10801>>>>>>>    End_Procedure
10802>>>>>>>    
10802>>>>>>>    Procedure Add_Table_Value String sData String sDescr RowID riRec
10804>>>>>>>        String  sVal
10804>>>>>>>        RowID   riRecVal
10804>>>>>>>        Integer iCnt
10804>>>>>>>        Get Data_Item_Count to iCnt
10805>>>>>>>        Set Data_Value iCnt to sData
10806>>>>>>>        
10806>>>>>>>        // If one param passed use it for both display and database values
10806>>>>>>>        If (num_arguments <= 1);            Move sData  to sVal
10809>>>>>>>        Else ;            Move sDescr to sVal
10811>>>>>>>        Set Data_Description iCnt to sVal
10812>>>>>>>        
10812>>>>>>>        If (num_arguments <= 2) ;            Move (NullRowId()) to riRecVal
10815>>>>>>>        Else ;            Move riRec        to riRecVal
10817>>>>>>>        Set Data_RowId iCnt to riRecVal
10818>>>>>>>    End_Procedure
10819>>>>>>>End_Class
10820>>>>>>>
10820>>>>>>>
10820>>>>>>>Class FileValidationTable is an DescriptionValidationTable
10821>>>>>>>    
10821>>>>>>>    Procedure Construct_Object
10823>>>>>>>        Forward Send Construct_Object
10825>>>>>>>        Property Integer No_Fill_State     False // this is never used and is obsolete. (JJT)
10826>>>>>>>        Property Integer Ordering          1   // Indx1 is a good guess.
10827>>>>>>>        Property String  Type_Value        ''  // default these two to
10828>>>>>>>        Property Integer Type_Field        0   // Undefined (none).
10829>>>>>>>        Property Integer Code_Field        1   // Fld 1=code, 2=descr
10830>>>>>>>        Property Integer Description_Field 2   // are good guesses.
10831>>>>>>>        
10831>>>>>>>        Property Integer Code_Load_Object  0   // or (Code_Loader(Self))
10832>>>>>>>    End_Procedure
10833>>>>>>>    
10833>>>>>>>    Function Table_Loaded_State Returns Integer
10835>>>>>>>        Integer iRVal
10835>>>>>>>        Get No_fill_State to iRVal // if true, table always is loaded
10836>>>>>>>        If not iRval ;            Forward Get table_loaded_State to iRVal
10840>>>>>>>        Function_Return iRval
10841>>>>>>>    End_Function
10842>>>>>>>    
10842>>>>>>>    Function Validate_Value String sCode Returns Integer
10844>>>>>>>        Integer iRVal
10844>>>>>>>        Integer iDSO
10844>>>>>>>        Get Code_Load_Object  to iDSO
10845>>>>>>>        // we use standard validate, if code is blank, OR if
10845>>>>>>>        //   1. if no code DSO or the code DSO exists but is not busy.
10845>>>>>>>        //   2. AND it is not no-fill
10845>>>>>>>        //   3. AND it is static
10845>>>>>>>        // Else we find the record directly
10845>>>>>>>        // Note that the operation mode is busy during request_validate (the
10845>>>>>>>        // ddo does this). WHen operation mode is busy we must not use
10845>>>>>>>        // the code dso (must find manually).
10845>>>>>>>        If (sCode='' or ;            ( (iDSO=0 or Operation_Mode=0)    and ; // if no code DSO or DSO not busy            No_Fill_State(Self)=0 and ;            Static_State(Self) ) ) ;            Forward Get Validate_Value sCode to iRVal
10849>>>>>>>        Else If (sCode<>Current_Code(Self)) ;            Get Find_Value sCode to iRVal
10853>>>>>>>        Function_Return iRVal // OK
10854>>>>>>>    End_Function
10855>>>>>>>    
10855>>>>>>>    Procedure Initialize_File
10857>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
10857>>>>>>>        Get Code_Load_Object  to iDSO
10858>>>>>>>        Get Main_File         to iFile
10859>>>>>>>        Get Code_Field        to iCodeField
10860>>>>>>>        Get Description_Field to iDescField
10861>>>>>>>        Get Ordering          to iIndex
10862>>>>>>>        Get Type_Field        to iTypeField
10863>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Initialize_File to iDSO ;            iFile iIndex iCodeField iDescField ;            iTypeField (Type_Value(Self))
10866>>>>>>>        Else Begin
10867>>>>>>>            Clear iFile
10868>>>>>>>            // if Type exists, seed the type value
10868>>>>>>>            If iTypeField ;                Set_Field_Value iFile iTypeField to (Type_Value(Self))
10873>>>>>>>        End
10873>>>>>>>>
10873>>>>>>>    End_Procedure
10874>>>>>>>    
10874>>>>>>>    Function Find_Value String Code Returns Integer
10876>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
10876>>>>>>>        Get Code_Load_Object  to iDSO
10877>>>>>>>        Get Main_File         to iFile
10878>>>>>>>        Get Ordering          to iIndex
10879>>>>>>>        Get Code_Field        to iCodeField
10880>>>>>>>        Get Description_Field to iDescField
10881>>>>>>>        Get Type_Field        to iTypeField
10882>>>>>>>        Send Initialize_File
10883>>>>>>>        //
10883>>>>>>>        Set_Field_Value iFile iCodeField to Code
10886>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Request_Find to iDSO EQ iFile iIndex
10889>>>>>>>        Else ;            Vfind iFile iIndex EQ
10892>>>>>>>        If not (Found) ;            Function_Return 1
10895>>>>>>>        // Set properties Current_code and Current_Description
10895>>>>>>>        Send Store_Current_Data iFile iCodeField iDescField
10896>>>>>>>        Function_Return 0
10897>>>>>>>    End_Function
10898>>>>>>>    
10898>>>>>>>    // internal
10898>>>>>>>    Procedure Store_Current_Data Integer iFile Integer iCodeField Integer iDescField
10900>>>>>>>        String sVal
10900>>>>>>>        Get_Field_Value iFile iCodeField to sVal
10903>>>>>>>        Set Current_Code to (trim(sVal))
10904>>>>>>>        If iDescField Begin
10906>>>>>>>            Get_Field_Value iFile iDescField to sVal
10909>>>>>>>            Set Current_Description to (trim(sVal))
10910>>>>>>>        End
10910>>>>>>>>
10910>>>>>>>        Set Current_RowId to (GetRowId(iFile))
10911>>>>>>>    End_Procedure
10912>>>>>>>    
10912>>>>>>>    Function Next_Code_Record Returns Boolean
10914>>>>>>>        Integer iFile iCodeField iDescField iIndex
10914>>>>>>>        Integer iTypeField
10914>>>>>>>        String sTypeValue sFoundTypeValue
10914>>>>>>>        Boolean bFound
10914>>>>>>>        Handle hoDSO
10914>>>>>>>        Get Code_Load_Object  to hoDSO
10915>>>>>>>        Get Description_Field to iDescField
10916>>>>>>>        Get Code_Field        to iCodeField
10917>>>>>>>        Get Main_File         to iFile
10918>>>>>>>        
10918>>>>>>>        If hoDSO Begin
10920>>>>>>>            Get Next_Code_record of hoDSO to bFound
10921>>>>>>>        End
10921>>>>>>>>
10921>>>>>>>        Else Begin
10922>>>>>>>            Get Ordering to iIndex
10923>>>>>>>            Vfind iFile iIndex GT
10925>>>>>>>            Move (Found) to bFound
10926>>>>>>>            If bFound Begin
10928>>>>>>>                // if found see if we are at the end of the valid list of types
10928>>>>>>>                Get Type_Field to iTypeField
10929>>>>>>>                Get Type_Value to sTypeValue
10930>>>>>>>                If ((iTypeField<>0) and (sTypeValue<>"")) Begin
10932>>>>>>>                    Get_Field_Value iFile iTypeField to sFoundTypeValue
10935>>>>>>>                    Move (Trim(sTypeValue)=Trim(sFoundTypeValue)) to bFound
10936>>>>>>>                End
10936>>>>>>>>
10936>>>>>>>            End
10936>>>>>>>>
10936>>>>>>>        End
10936>>>>>>>>
10936>>>>>>>        If bFound Begin
10938>>>>>>>            Send Store_Current_Data iFile iCodeField iDescField
10939>>>>>>>        End
10939>>>>>>>>
10939>>>>>>>        Function_Return bFound
10940>>>>>>>    End_Function
10941>>>>>>>    
10941>>>>>>>    Procedure Fill_List
10943>>>>>>>        RowID riId
10943>>>>>>>        Boolean bFound
10943>>>>>>>        String sCode sDesc
10943>>>>>>>        If (Static_State(Self)=0 or No_Fill_State(Self)) ;            Procedure_Return
10946>>>>>>>        //
10946>>>>>>>        Send Delete_Data
10947>>>>>>>        Send Initialize_File
10948>>>>>>>        Get Next_Code_Record to bFound
10949>>>>>>>        While bFound
10953>>>>>>>            Get Current_Code        to sCode
10954>>>>>>>            Get Current_Description to sDesc
10955>>>>>>>            Get Current_RowId       to riId
10956>>>>>>>            Send Add_Table_Value sCode sDesc riId
10957>>>>>>>            Get Next_Code_Record to bFound
10958>>>>>>>        Loop
10959>>>>>>>>
10959>>>>>>>        Set Table_Loaded_State to True
10960>>>>>>>    End_Procedure
10961>>>>>>>    
10961>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
10963>>>>>>>        Integer iItem
10963>>>>>>>        Integer iFile
10963>>>>>>>        RowID   riId
10963>>>>>>>        Boolean bFound
10963>>>>>>>        String sCode sDesc
10963>>>>>>>        
10963>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
10966>>>>>>>        
10966>>>>>>>        If (Static_State(Self) and No_Fill_State(Self)=0 ) ;            Forward Send Request_Fill_From_List iObj iMsg
10970>>>>>>>        Else Begin
10971>>>>>>>            Get Main_File to iFile
10972>>>>>>>            Send Initialize_File
10973>>>>>>>            Get Next_Code_Record to bFound
10974>>>>>>>            While bFound
10978>>>>>>>                Get Current_Code        to sCode
10979>>>>>>>                Get Current_Description to sDesc
10980>>>>>>>                Get Current_RowId       to riId
10981>>>>>>>                Send iMSG to iObj iItem sCode sDesc iFile riId
10982>>>>>>>                Increment iItem
10983>>>>>>>                Get Next_Code_Record to bFound
10984>>>>>>>            Loop
10985>>>>>>>>
10985>>>>>>>        End
10985>>>>>>>>
10985>>>>>>>    End_Procedure
10986>>>>>>>End_Class
10987>>>>>>>
10987>>>>>>>Use CodeLoad.pkg
Including file: codeload.pkg    (C:\Program Files\DataFlex 20.1\Pkg\codeload.pkg)
10987>>>>>>>>>// Interface:
10987>>>>>>>>>//
10987>>>>>>>>>//  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;
10987>>>>>>>>>//                            Integer Desc# Integer Type# String Type
10987>>>>>>>>>//
10987>>>>>>>>>//      This initializes the data-set for finding. You MUST pass all five
10987>>>>>>>>>//      parameters here. They are:
10987>>>>>>>>>//          File#  -  main file to use
10987>>>>>>>>>//         Index#  - Index to use for finding
10987>>>>>>>>>//          Code#  - field number of the code
10987>>>>>>>>>//          Desc#  - field number of the code's description
10987>>>>>>>>>//          Type#  - field number of the constraining Type (0 if none)
10987>>>>>>>>>//           Type  - the constrain type value ('' = allow all records)
10987>>>>>>>>>//
10987>>>>>>>>>//      You MUST send this message before finding records. Alternately,
10987>>>>>>>>>//      you could set the individual properties and send rebuild_constraints
10987>>>>>>>>>//      and CLEAR to initalize the file (see code on how to do this).
10987>>>>>>>>>//
10987>>>>>>>>>//    Get Next_Code_record to ret_Int
10987>>>>>>>>>//
10987>>>>>>>>>//      Returns the next record number. 0 if no more. If record exists it
10987>>>>>>>>>//      sets the value of Current_Code and Crnt_Description.
10987>>>>>>>>>//
10987>>>>>>>>>//    Get Current_Code to Ret_String
10987>>>>>>>>>//    Get Crnt_Description to Ret_String
10987>>>>>>>>>//
10987>>>>>>>>>//      Returns the code and description of the last valid record found
10987>>>>>>>>>//      with the Next_Code_Record Message
10987>>>>>>>>>//
10987>>>>>>>>>//   Sample Usage:  This was created primarily to be used by the
10987>>>>>>>>>//                  radio-entry-form classes. In particular those using
10987>>>>>>>>>//                  the "code" look up file. Look at those packages if
10987>>>>>>>>>//                  you wish to use them yourself.
10987>>>>>>>>>//
10987>>>>>>>>>Use Data_Set.pkg
10987>>>>>>>>>
10987>>>>>>>>>Class Code_Loader_Data_Set is a DataSet
10988>>>>>>>>>    
10988>>>>>>>>>    Procedure Construct_Object Integer Img#
10990>>>>>>>>>        Forward Send Construct_Object Img#
10992>>>>>>>>>        // These should be set by the Initialize_File message
10992>>>>>>>>>        Property String  Type_Value           '' // assume no defaults.
10993>>>>>>>>>        Property Integer Type_Field           0  // These values should be
10994>>>>>>>>>        Property Integer Code_Field           0  // set by initialize_file
10995>>>>>>>>>        Property Integer Description_Field    0  //
10996>>>>>>>>>        
10996>>>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
10996>>>>>>>>>        Property String  Current_Code         ''
10997>>>>>>>>>        Property String  Current_Description  ''
10998>>>>>>>>>    End_Procedure
10999>>>>>>>>>    
10999>>>>>>>>>    // If a Type exists (not a '') and there is a type field and a
10999>>>>>>>>>    // main_file constrain to the type. Else no constraints
10999>>>>>>>>>    Procedure OnConstrain
11001>>>>>>>>>        String sType
11001>>>>>>>>>        Integer iFile iField
11001>>>>>>>>>        Get Type_Value to sType
11002>>>>>>>>>        Get Main_File  to iFile
11003>>>>>>>>>        Get Type_Field to iField
11004>>>>>>>>>        If (sType<>'' and iFile<>0 and iField<>0) ;            Vconstrain iFile iField eq sType
11009>>>>>>>>>    End_Procedure
11010>>>>>>>>>    
11010>>>>>>>>>    //  This initializes the data-set for finding. You MUST pass all five
11010>>>>>>>>>    //  parameters here. They are:
11010>>>>>>>>>    //     File#  -  main file to use
11010>>>>>>>>>    //    Index#  - Index to use for finding
11010>>>>>>>>>    //     Code#  - field number of the code
11010>>>>>>>>>    //     Desc#  - field number of the code's description
11010>>>>>>>>>    //     Type#  - field number of the constraining Type (0 if none)
11010>>>>>>>>>    //      Type  - the constrain type value ('' = allow all records)
11010>>>>>>>>>    //
11010>>>>>>>>>    Procedure Initialize_File Integer File# Integer Index# Integer Code# ;            Integer Desc# Integer Type# String Type
11012>>>>>>>>>        // note: all params are required!
11012>>>>>>>>>        Set Main_File         to File#
11013>>>>>>>>>        Set Ordering          to Index#
11014>>>>>>>>>        Set Code_Field        to Code#
11015>>>>>>>>>        Set Description_Field to Desc#
11016>>>>>>>>>        Set Type_Field        to Type#
11017>>>>>>>>>        Set Type_Value        to Type
11018>>>>>>>>>        //
11018>>>>>>>>>        Send Rebuild_Constraints // set up constraints
11019>>>>>>>>>        Send Clear               // initialize the file
11020>>>>>>>>>    End_Procedure
11021>>>>>>>>>    
11021>>>>>>>>>    //  Find the next record: Return 0 if no record, 1 if record exists
11021>>>>>>>>>    //   if record exists set Current_Code and Current_Description
11021>>>>>>>>>    //
11021>>>>>>>>>    Function Next_Code_Record Returns Boolean
11023>>>>>>>>>        Integer iFile iField
11023>>>>>>>>>        String sValue
11023>>>>>>>>>        Send Request_Find GT (Main_File(Self)) (Ordering(Self))
11024>>>>>>>>>        If not (Found) ;            Function_Return False
11027>>>>>>>>>        // Set properties Current_code and Current_Description
11027>>>>>>>>>        Get Main_File to iFile
11028>>>>>>>>>        
11028>>>>>>>>>        Get Code_Field to iField
11029>>>>>>>>>        Get_Field_Value iFile iField to sValue
11032>>>>>>>>>        Set Current_Code to sValue
11033>>>>>>>>>        
11033>>>>>>>>>        Get Description_Field to iField
11034>>>>>>>>>        Get_Field_Value iFile iField to sValue
11037>>>>>>>>>        Set Current_Description to sValue
11038>>>>>>>>>        Function_Return True
11039>>>>>>>>>    End_Function
11040>>>>>>>>>    
11040>>>>>>>>>End_Class
11041>>>>>>>Use cCodeMaintOpen_Mixin.pkg
Including file: cCodeMaintOpen_Mixin.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCodeMaintOpen_Mixin.pkg)
11041>>>>>>>>>// Mixin class to support transistion support for CodeType and CodeMast files.
11041>>>>>>>>>// These files used to be in filelist and they used to reside at 207 and 208 and they
11041>>>>>>>>>// were always opened with "open as"
11041>>>>>>>>>// We want these to be in the filelist at 253 and 254. These open methods will attempt to open these files
11041>>>>>>>>>// as such. If these are old files (not in filelist or wrong number) they will get loaded with the old
11041>>>>>>>>>// open as - thus keeping this backwards compatible.
11041>>>>>>>>>// By adding to filelist, we can sort the files and we can open them as other database sources.
11041>>>>>>>>>Use VDFBase.pkg
11041>>>>>>>>>
11041>>>>>>>>>Declare_Datafile CodeType
Including file: CodeType.fd    (C:\Projects\DF20\DbUpdateFramework2.0\DDSrc\CodeType.fd)
11041>>>>>>>>>Declare_Datafile CodeMast
Including file: CodeMast.fd    (C:\Projects\DF20\DbUpdateFramework2.0\DDSrc\CodeMast.fd)
11041>>>>>>>>>Define C_Expected_CodeType_FileNumber for 253  // and the logical name must be CODETYPE
11041>>>>>>>>>Define C_Expected_CodeMast_FileNumber for 254  // and the logical name must be CODEMAST
11041>>>>>>>>>
11041>>>>>>>>>Class cCodeMaintOpen_Mixin is a Mixin
11042>>>>>>>>>    
11042>>>>>>>>>    Procedure OpenCodeMast
11044>>>>>>>>>        String sName
11044>>>>>>>>>        If (Codemast.File_number=C_Expected_CodeMast_FileNumber) Begin
11046>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of Codemast.File_number to sName
11049>>>>>>>>>            If (uppercase(trim(sName))="CODEMAST") Begin
11051>>>>>>>>>                Open CodeMast
11053>>>>>>>>>                Procedure_Return
11054>>>>>>>>>            End
11054>>>>>>>>>>
11054>>>>>>>>>        End
11054>>>>>>>>>>
11054>>>>>>>>>        Open "CodeMast" as Codemast.File_number
11056>>>>>>>>>    End_Procedure
11057>>>>>>>>>    
11057>>>>>>>>>    Procedure OpenCodeType
11059>>>>>>>>>        String sName
11059>>>>>>>>>        If (Codetype.File_number=C_Expected_CodeType_FileNumber) Begin
11061>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of CodeType.File_number to sName
11064>>>>>>>>>            If (uppercase(trim(sName))="CODETYPE") Begin
11066>>>>>>>>>                Open CodeType
11068>>>>>>>>>                Procedure_Return
11069>>>>>>>>>            End
11069>>>>>>>>>>
11069>>>>>>>>>        End
11069>>>>>>>>>>
11069>>>>>>>>>        Open "CodeType" as CodeType.File_number
11071>>>>>>>>>    End_Procedure
11072>>>>>>>>>    
11072>>>>>>>>>End_Class
11073>>>>>>>
11073>>>>>>>//
11073>>>>>>>//  This is the object we need for loading files.
11073>>>>>>>//
11073>>>>>>>Object Code_loader is a Code_loader_Data_Set no_Image
11075>>>>>>>End_Object
11076>>>>>>>
11076>>>>>>>
11076>>>>>>>Class CodeValidationTable is an FileValidationTable
11077>>>>>>>    
11077>>>>>>>    // supports opening of file in reserved filelist area.
11077>>>>>>>    Import_Class_Protocol cCodeMaintOpen_Mixin
11078>>>>>>>    
11078>>>>>>>    Procedure Construct_Object
11080>>>>>>>        Forward Send Construct_Object
11082>>>>>>>        
11082>>>>>>>        Send OpenCodeMast                       // methods supports w/ filelist (new) and without (old)
11083>>>>>>>        
11083>>>>>>>        Set Main_File to CodeMast.File_Number   // name of file is CODEMAST
11084>>>>>>>        Set Ordering to 1                       // Index 1: Types x Code
11085>>>>>>>        Set Type_Field to 1                     // Fld 1: Type
11086>>>>>>>        Set Code_Field to 2                     // Fld 2: Code
11087>>>>>>>        Set Description_Field to 3              // Fld 3: Description
11088>>>>>>>        Set Code_load_Object to (Code_Loader(Self))
11089>>>>>>>    End_Procedure
11090>>>>>>>    
11090>>>>>>>End_Class
11091>>>>>
11091>>>>>// Used to by DDOConstraintFindMeta to return constraint expression info in a friendlier fashion
11091>>>>>Struct tDDOConstraintFindMeta
11091>>>>>    Integer iJumpInSegments
11091>>>>>    Boolean bJumpOut
11091>>>>>    Boolean bPreRelate
11091>>>>>    Boolean bPostRelate
11091>>>>>End_Struct
11091>>>>>
11091>>>>>// used by webapp resynchs
11091>>>>>Struct tDDChangedParentInfo
11091>>>>>    Integer iTable
11091>>>>>    Boolean bSwitched
11091>>>>>End_Struct
11091>>>>>
11091>>>>>// used by webapp resynchs
11091>>>>>Struct tDDChangedInfo
11091>>>>>    Boolean bChanged
11091>>>>>    tDDChangedParentInfo[] ParentChanged
11091>>>>>    tDDChangedParentInfo[] ParentChanged
11091>>>>>End_Struct
11091>>>>>
11091>>>>>Enum_List
11091>>>>>    Define CONST_EXP_JUMPOUT     for 1
11091>>>>>    Define CONST_EXP_PRE_RELATE  for 2
11091>>>>>    Define CONST_EXP_POST_RELATE for 4
11091>>>>>End_Enum_List
11091>>>>>
11091>>>>>// Constraint Find Types
11091>>>>>Enum_List
11091>>>>>    Define CONST_VALUE for 0    // Constrain File.Field eq sValue
11091>>>>>    Define CONST_CHILD          // Constrain File Relates to iOtherFile
11091>>>>>    Define CONST_FIELD          // Constrain File.field eq OtherFile.OtherField
11091>>>>>    Define CONST_EXP            // Constrain File as (Expression) - expression is internal
11091>>>>>    Define CONST_RELATES        // Sames a CONST_CHILD - should never be used
11091>>>>>End_Enum_List
11091>>>>>
11091>>>>>// Constraint Find Modes
11091>>>>>Enum_List
11091>>>>>    Define CONST_LT for 0
11091>>>>>    Define CONST_LE for 1
11091>>>>>    Define CONST_EQ for 2
11091>>>>>    Define CONST_GE for 3
11091>>>>>    Define CONST_GT for 4
11091>>>>>    Define CONST_NE for 5
11091>>>>>    Define CONST_Matches for 6       // a matches not capable of a jump in e.g., "?A*"
11091>>>>>    Define CONST_Contains for 7      // a contains
11091>>>>>    Define CONST_MatchesJumpIn for 9 // a matches which is capable of a jump in e.g., "A*"
11091>>>>>    // note that BETWEEN is actually two constraints a GE and LE
11091>>>>>End_Enum_List
11091>>>>>
11091>>>>>// Struct used to DDOConstraints to return current constraints in an array
11091>>>>>Struct tConstraintDef
11091>>>>>    Integer eType // constraint Find type
11091>>>>>    Integer eMode // constrain file mode
11091>>>>>    Integer iFile
11091>>>>>    Integer iField
11091>>>>>    String sValue
11091>>>>>    Integer iOtherFile
11091>>>>>    Integer iOtherField
11091>>>>>End_Struct
11091>>>>>
11091>>>>>// values passed to OnPre/PostFind to indicate the operation type
11091>>>>>Enum_List
11091>>>>>    Define DDFindRequestFind    // request_find
11091>>>>>    Define DDFindFindByRowRec   // FindByRowId, Find_By_Recnum
11091>>>>>    Define DDFindRequestAssign  // Request_assign
11091>>>>>    Define DDFindClear          // Clear (note Clear_All doesn't do this)
11091>>>>>End_Enum_List
11091>>>>>
11091>>>>>
11091>>>>>// these are private
11091>>>>>Define DD_RememberLast for "_REMEMBER$LAST_"
11091>>>>>Use tDDRemembered.pkg
Including file: tDDRemembered.pkg    (C:\Program Files\DataFlex 20.1\Pkg\tDDRemembered.pkg)
11091>>>>>>>// DDRemember Struct used for DataDictionary Class
11091>>>>>>>
11091>>>>>>>// private
11091>>>>>>>
11091>>>>>>>Struct tDDRemembered
11091>>>>>>>    Integer iField // searches are performed on this segement - it must be first
11091>>>>>>>    String sDefault
11091>>>>>>>    String sLastValue
11091>>>>>>>End_Struct
11091>>>>>>>
11091>>>>>
11091>>>>>// Used to assign a global validation_object. This can be used for
11091>>>>>// automatic prompt object on non-relational validations (checks, validation_
11091>>>>>// tables, etc.)
11091>>>>>Integer DD_Global_Validation_Prompt_Object
11091>>>>>Move 0 to DD_Global_Validation_Prompt_Object
11092>>>>>
11092>>>>>// Used for Dso traversal marking - Private (do not use)
11092>>>>>Integer   DD_Current_Mark_Id
11092>>>>>Move 0 to DD_Current_Mark_Id
11093>>>>>
11093>>>>>// Used to validate DSO structures during Save and deletes
11093>>>>>Enumeration_List
11093>>>>>    Define DD_VALIDATE_STRUCTURE_ALWAYS // Validate each save/delete operation.
11093>>>>>    Define DD_VALIDATE_STRUCTURE_NEVER  // Never validate these operations.
11093>>>>>    Define DD_VALIDATE_STRUCTURE_ONCE   // Validate Once (first save or delete).
11093>>>>>End_Enumeration_List
11093>>>>>
11093>>>>>// Used as a start for error handing in DSOs. Only affects errors that go
11093>>>>>// through operation_not_allowed and Field_Error. Used by Error_Report_Mode
11093>>>>>Enumeration_List
11093>>>>>    Define DD_ERROR_REPORT              // Report Error on screen
11093>>>>>    Define DD_ERROR_NO_REPORT           // Show no Error..
11093>>>>>End_Enumeration_List
11093>>>>>
11093>>>>>Enumeration_List
11093>>>>>    Define DD_Lock_on_All             for  7  // 111
11093>>>>>    Define DD_Lock_on_New_Save_Delete for  5  // 101
11093>>>>>    Define DD_Lock_on_Delete          for  4  // 100
11093>>>>>    Define DD_Lock_on_Save            for  2  // 010
11093>>>>>    Define DD_Lock_on_New_Save        for  1  // 001
11093>>>>>End_Enumeration_List
11093>>>>>
11093>>>>>
11093>>>>>Define DD_DEFAULT_ERROR_NUMBER  for 999
11093>>>>>
11093>>>>>
11093>>>>>
11093>>>>>
11093>>>>>// The next replaces will be used to indicate default item-options
11093>>>>>// instead of a fieldnumber which is normally used.
11093>>>>>
11093>>>>>// these are the DD bits that pertain to DEO Item options.
11093>>>>>Define DD_DEO_MASK for (DD_NOENTER ior DD_SKIPFOUND ior DD_CAPSLOCK ior DD_ZERO_SUPPRESS ior DD_AUTORETURN ior DD_AUTOBACK ior DD_AUTOCLEAR)
11093>>>>>
11093>>>>>
11093>>>>>// Special parameter options that can get passed to Set Field_Options. The
11093>>>>>// purpose is to clear all fields or the remaining passed parameters. Normally,
11093>>>>>// these are not used so it does not matter if their interface is a bit odd.
11093>>>>>Enumeration_List
11093>>>>>    Define DD_CLEAR_FIELD_OPTIONS      for -1
11093>>>>>    Define DD_CLEAR_ALL_FIELD_OPTIONS  for -2
11093>>>>>End_Enumeration_List
11093>>>>>
11093>>>>>// used to keep track of extra server file information.
11093>>>>>Struct tDDServerInformation
11093>>>>>    Integer iParent             // parent file number
11093>>>>>    Boolean bAllowNullParent    // does this DD (child) allow a null parent
11093>>>>>    Integer bParentNoSwitchIfCommitted // does this DD (child) allow switching committed parents
11093>>>>>    Boolean bNoCascadeDelete           // when a child record exists should cascade delete stop the action
11093>>>>>    Boolean bCascadeDeleteNullTheParent // when a child record exists that is null parent allowed, should we delete or null the parent
11093>>>>>End_Struct
11093>>>>>
11093>>>>>Use DDExtFld.pkg // adds extended field/pointer support
Including file: DDExtFld.pkg    (C:\Program Files\DataFlex 20.1\Pkg\DDExtFld.pkg)
11093>>>>>>>// This is used by the DataDictionary class and provides a method for
11093>>>>>>>// windows DDs (for now) to support local buffers for text and binary buffers.
11093>>>>>>>// Field objects are created within the DD by sending the message:
11093>>>>>>>// The DD interface is:
11093>>>>>>>//
11093>>>>>>>//      Get  Field_Object iField to hExtFieldObject
11093>>>>>>>//      Send DefineExtendedField iField
11093>>>>>>>//      Send DefineAllExtendedFields
11093>>>>>>>//      Send ExtendedFieldsUpdate bSave
11093>>>>>>>//      Send ExtendedFieldsRefresh bCleared
11093>>>>>>>//      Set  File_Field_Current_Pointer_Value iFile iField iLen to pValue
11093>>>>>>>//      Set  Field_Current_Pointer_Value iField iLen to pValue
11093>>>>>>>//      Set  File_Field_Pointer_Entry iFile iField iLen bShowErr to pValue
11093>>>>>>>//      Set  Field_Pointer_Entry iField iOpts iLen bShowErr to pValue
11093>>>>>>>//      Get  File_Field_Current_Pointer_Value iFile iField to pData
11093>>>>>>>//      Get  Field_Current_Pointer_Value iField to pData
11093>>>>>>>//
11093>>>>>>>// Once object is identified, the following interface can be used
11093>>>>>>>//      Get FieldPointer of hExtFieldObject to iMemoryPointer
11093>>>>>>>//      Get FieldLength  of hExtFieldObject to iLen
11093>>>>>>>//      Get File_Number  of hExtFieldObject to iFile
11093>>>>>>>//      Get Field_Number of hExtFieldObject to iFile
11093>>>>>>>//      Set Update_Save_State of hExtFieldObject to bState         // be careful!
11093>>>>>>>//      Set Update_Find_State of hExtFieldObject to bState         // be careful
11093>>>>>>>//      Set FieldRefresh_Save_State of hExtFieldObject to bState   // be careful
11093>>>>>>>//
11093>>>>>>>
11093>>>>>>>//
11093>>>>>>>//  DD structure:
11093>>>>>>>//       DD Object           (property Field_objects points to child)
11093>>>>>>>//           FieldObjects    (array of field#s and field objs)
11093>>>>>>>//              FieldObject1 (heap alloc for each field)
11093>>>>>>>//              FieldObjectn
11093>>>>>>>//
11093>>>>>>>
11093>>>>>>>//
11093>>>>>>>// This is used to create a single extended field object.
11093>>>>>>>//
11093>>>>>>>// Interface
11093>>>>>>>//      Get FieldPointer to iMemoryPointer
11093>>>>>>>//      Get FieldLength  to iLen
11093>>>>>>>//      Get File_Number  to iFile
11093>>>>>>>//      Get Field_Number to iFile
11093>>>>>>>//      get/Set Update_Save_State to bState         // be careful!
11093>>>>>>>//      get/Set Update_Find_State to bState         // be careful
11093>>>>>>>//      get/Set FieldRefresh_Save_State to bState   // be careful
11093>>>>>>>//      get/set FieldChangedState
11093>>>>>>>//      send defineField  iFile iField
11093>>>>>>>//      Send FieldUpdate  bSave
11093>>>>>>>//      Send FieldRefresh bCleared bClearFieldChange
11093>>>>>>>//      Set  Field_pEntry iOpts iLen to pValue
11093>>>>>>>//      Set  Field_pValue iLen to pValue
11093>>>>>>>//
11093>>>>>>>Use VDFBase.pkg
11093>>>>>>>
11093>>>>>>>Class FieldObject is a cObject
11094>>>>>>>    
11094>>>>>>>    Procedure Construct_Object
11096>>>>>>>        Forward Send construct_object
11098>>>>>>>        // these are all set by DefineField and should not be changed
11098>>>>>>>        Property Integer File_Number        0
11099>>>>>>>        Property Integer Field_Number       0
11100>>>>>>>        Property Integer FieldLength        0
11101>>>>>>>        
11101>>>>>>>        // maintained by object
11101>>>>>>>        Property UChar[] pFieldArray
11102>>>>>>>        
11102>>>>>>>        // these can be changed, with care, by the developer
11102>>>>>>>        Property Integer Update_Save_State  True
11103>>>>>>>        Property Integer Update_Find_State  False // usually no point for finds
11104>>>>>>>        Property Integer FieldRefresh_State True
11105>>>>>>>        
11105>>>>>>>        // hopefully never used
11105>>>>>>>        Property Pointer pLegacyFieldPointer       0
11106>>>>>>>        
11106>>>>>>>    End_Procedure
11107>>>>>>>    
11107>>>>>>>    Procedure Set FieldChangedState Integer bState
11109>>>>>>>        Integer iField
11109>>>>>>>        Get Field_Number to iField
11110>>>>>>>        Delegate Set Field_Changed_state iField to bState
11112>>>>>>>    End_Procedure
11113>>>>>>>    
11113>>>>>>>    Function FieldChangedState Returns Integer
11115>>>>>>>        Integer iField  bState
11115>>>>>>>        Get Field_Number to iField
11116>>>>>>>        Delegate Get Field_Changed_state iField to bState
11118>>>>>>>        Function_Return bState
11119>>>>>>>    End_Function
11120>>>>>>>    
11120>>>>>>>    // return the field option specified
11120>>>>>>>    Function IsSaveNoPut Returns Boolean
11122>>>>>>>        Integer iField
11122>>>>>>>        Boolean  bState
11122>>>>>>>        Get Field_Number to iField
11123>>>>>>>        Delegate Get FieldSaveNoPut iField to bState
11125>>>>>>>        Function_Return bState
11126>>>>>>>    End_Function
11127>>>>>>>    
11127>>>>>>>    // for object: define file, field, fieldlength and allocate heap memory
11127>>>>>>>    //             and set memory pointer
11127>>>>>>>    Procedure DefineField Integer iFile Integer iField
11129>>>>>>>        Integer iFldLen
11129>>>>>>>        Set File_Number  to iFile
11130>>>>>>>        Set Field_Number to iField
11131>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldLen
11134>>>>>>>        Set FieldLength  to iFldLen
11135>>>>>>>    End_Procedure
11136>>>>>>>    
11136>>>>>>>    // Move from the DD Buffer to the file buffer
11136>>>>>>>    Procedure FieldUpdate Integer bSave
11138>>>>>>>        Integer iFile iField iFieldLen
11138>>>>>>>        UChar[] FieldArray
11139>>>>>>>        Integer iType
11139>>>>>>>        Boolean bNoPut
11139>>>>>>>        
11139>>>>>>>        // if bSave, part of save which means only update if changed
11139>>>>>>>        // if not bsave, part of find. You usually would not update this. You
11139>>>>>>>        // don't index on these types of fields
11139>>>>>>>        If ( (bSave and Update_Save_State(Self) and FieldChangedState(Self)) or ;            (not(bSave) and Update_Find_state(Self) ) ) Begin
11141>>>>>>>            // if save, we must respect DD_NoPut
11141>>>>>>>            If (bSave) Begin
11143>>>>>>>                // we are looking at the DD's field buffer itemoptions for, which
11143>>>>>>>                // should be set appropriately before a save. This setting has any
11143>>>>>>>                // changes made to support dd_commit
11143>>>>>>>                Get IsSaveNoPut to bNoPut
11144>>>>>>>                If bNoPut Begin
11146>>>>>>>                    Procedure_Return
11147>>>>>>>                End
11147>>>>>>>>
11147>>>>>>>            End
11147>>>>>>>>
11147>>>>>>>            Get pFieldArray to FieldArray
11148>>>>>>>            Get File_Number to iFile
11149>>>>>>>            Get Field_Number to iField
11150>>>>>>>            If iFile Begin
11152>>>>>>>                Set_Field_Value iFile iField to FieldArray // LENGTH iFieldLen
11155>>>>>>>            End
11155>>>>>>>>
11155>>>>>>>        End
11155>>>>>>>>
11155>>>>>>>    End_Procedure
11156>>>>>>>    
11156>>>>>>>    // Move from File buffer to local DD Buffer
11156>>>>>>>    // bCleared determines if this is a find or a clear.
11156>>>>>>>    // bClearFieldChange determines if we should clear the FieldChangedState.
11156>>>>>>>    Procedure FieldRefresh Boolean bCleared Boolean bClearFieldChange
11158>>>>>>>        Integer iFile iField
11158>>>>>>>        Integer bOk
11158>>>>>>>        UChar[] FieldArray
11159>>>>>>>        If (FieldRefresh_state(Self)) Begin
11161>>>>>>>            //Get FieldPointer to pField
11161>>>>>>>            Get File_Number to iFile
11162>>>>>>>            Get Field_Number to iField
11163>>>>>>>            // move from file buffer to memory pointed to by pField
11163>>>>>>>            If (iFile) Begin
11165>>>>>>>                If not bCleared Begin
11167>>>>>>>                    Get_Field_Value iFile iField to FieldArray
11170>>>>>>>                End
11170>>>>>>>>
11170>>>>>>>                Set Field_UCValue to FieldArray
11171>>>>>>>            End
11171>>>>>>>>
11171>>>>>>>        End
11171>>>>>>>>
11171>>>>>>>        If bClearFieldChange Begin
11173>>>>>>>            Set FieldChangedstate to False
11174>>>>>>>        End
11174>>>>>>>>
11174>>>>>>>    End_Procedure
11175>>>>>>>    
11175>>>>>>>    Procedure Set Field_pEntry Integer iOpts Integer iLen Integer bShowErr Pointer pValue
11177>>>>>>>        Integer iFile iField iFldLen iMemLen
11177>>>>>>>        Integer bChanged
11177>>>>>>>        UChar[] FieldArray
11178>>>>>>>        
11178>>>>>>>        // currently we do nothing with bShowErr because we don't checkfor errors!
11178>>>>>>>        
11178>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. For now we will
11178>>>>>>>        // let NoPut through, since a user might need it for finding.
11178>>>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
11181>>>>>>>        
11181>>>>>>>        // maybe in the future
11181>>>>>>>        // Force a caplsock if required
11181>>>>>>>        //If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
11181>>>>>>>        
11181>>>>>>>        Get File_Number  to iFile
11182>>>>>>>        Get Field_Number to iField
11183>>>>>>>        If (iFile) Begin
11185>>>>>>>            Get Is_pValueChanged iLen pValue to bChanged
11186>>>>>>>            If ( bChanged or (iOpts iand DD_FORCEPUT) ) Begin
11188>>>>>>>                Set Field_pValue iLen to pValue
11189>>>>>>>            End
11189>>>>>>>>
11189>>>>>>>            
11189>>>>>>>            
11189>>>>>>>            // Set changed state if changed and it is not No_put. This
11189>>>>>>>            // is an improvement on DEOs which would set changed-state for
11189>>>>>>>            // a no-put. This way, finds use the changed value but saves will
11189>>>>>>>            // not trigger a phony data loss
11189>>>>>>>            //If ( bChanged ) ;
11189>>>>>>>            If ( bChanged and not(iOpts iand DD_NOPUT) ) ;                Set FieldChangedState to True
11192>>>>>>>            
11192>>>>>>>            // The following is really highly unlikely!!!
11192>>>>>>>            // perform autofinds if needed. Note that required checking will occur as
11192>>>>>>>            // part of validation.
11192>>>>>>>            // We will only autofind if the field value is changed. This is consistent with
11192>>>>>>>            // DEOs which do not autofind on unchanged values. This provides optimizations
11192>>>>>>>            // when a parent record is already loaded.
11192>>>>>>>            If (bChanged or FieldChangedState(Self)) Begin
11194>>>>>>>                If (iOpts iand DD_AUTOFIND) ;                    Delegate Send File_Field_AutoFind iFile iField EQ
11198>>>>>>>                Else If (iOpts iand DD_AUTOFIND_GE) ;                    Delegate Send File_Field_AutoFind iFile iField GE
11203>>>>>>>            End
11203>>>>>>>>
11203>>>>>>>        End
11203>>>>>>>>
11203>>>>>>>        
11203>>>>>>>    End_Procedure
11204>>>>>>>    
11204>>>>>>>    // convert pointer to UChar[]
11204>>>>>>>    Function PointerToUCharArray Pointer pValue Integer iLen Returns UChar[]
11206>>>>>>>        UChar[] FieldArray
11207>>>>>>>        Boolean bOk
11207>>>>>>>        Move (ResizeArray(FieldArray,iLen)) to FieldArray
11208>>>>>>>        Move (MemCopy(AddressOf(FieldArray),pValue,iLen)) to bOK
11209>>>>>>>        Function_Return FieldArray
11210>>>>>>>    End_Function
11211>>>>>>>    
11211>>>>>>>    // Raw update of pValue
11211>>>>>>>    Procedure Set Field_UCValue UChar[] FieldArray
11213>>>>>>>        Set pFieldArray to FieldArray
11214>>>>>>>        Send DestroyLegacyFieldHeap
11215>>>>>>>    End_Procedure
11216>>>>>>>    
11216>>>>>>>    // Raw update of pValue
11216>>>>>>>    Procedure Set Field_pValue Integer iLen Pointer pValue
11218>>>>>>>        UChar[] FieldArray
11219>>>>>>>        Get PointerToUCharArray pValue iLen to FieldArray
11220>>>>>>>        Set Field_UCValue to FieldArray
11221>>>>>>>    End_Procedure
11222>>>>>>>    
11222>>>>>>>    Function Is_pValueChanged Integer iLen Pointer pValue Returns Boolean
11224>>>>>>>        Boolean bChanged
11224>>>>>>>        UChar[] FieldArray
11225>>>>>>>        Integer iFldLen
11225>>>>>>>        Get pFieldArray to FieldArray
11226>>>>>>>        Move (SizeOfArray(FieldArray)) to iFldLen
11227>>>>>>>        If (iLen <> SizeOfArray(FieldArray)) Begin
11229>>>>>>>            Move True to bChanged
11230>>>>>>>        End
11230>>>>>>>>
11230>>>>>>>        Else If (iLen) Begin // check for empty pointer
11233>>>>>>>            Move (MemCompare(AddressOf(FieldArray),pValue,iLen)) to bChanged
11234>>>>>>>        End
11234>>>>>>>>
11234>>>>>>>        Function_Return bChanged
11235>>>>>>>    End_Function
11236>>>>>>>    
11236>>>>>>>    // returns data as UChar array - best way to access the data
11236>>>>>>>    Function FieldArray Returns UChar[]
11238>>>>>>>        UChar[] FieldArray
11239>>>>>>>        Get pFieldArray to FieldArray
11240>>>>>>>        Function_Return FieldArray
11241>>>>>>>    End_Function
11242>>>>>>>    
11242>>>>>>>    // legacy method. Hopefully this is never called.
11242>>>>>>>    Function FieldPointer Returns Pointer
11244>>>>>>>        Pointer pValue pOldValue
11244>>>>>>>        Integer iLen
11244>>>>>>>        UChar[] FieldArray
11245>>>>>>>        Boolean bOk
11245>>>>>>>        Get pFieldArray to FieldArray
11246>>>>>>>        Move (SizeOfArray(FieldArray)) to iLen
11247>>>>>>>        Move (Alloc(iLen)) to pValue
11248>>>>>>>        Move (MemCopy(pValue,AddressOf(FieldArray),iLen)) to bOk
11249>>>>>>>        Send DestroyLegacyFieldHeap
11250>>>>>>>        Set pLegacyFieldPointer to pValue
11251>>>>>>>        Function_Return pValue
11252>>>>>>>    End_Function
11253>>>>>>>    
11253>>>>>>>    Procedure DestroyLegacyFieldHeap
11255>>>>>>>        Integer bOK
11255>>>>>>>        Pointer pField
11255>>>>>>>        Get pLegacyFieldPointer to pField
11256>>>>>>>        If (pField ) Begin
11258>>>>>>>            Move (Free(pField)) to bOk
11259>>>>>>>            Set pLegacyFieldPointer to 0
11260>>>>>>>        End
11260>>>>>>>>
11260>>>>>>>    End_Procedure
11261>>>>>>>    
11261>>>>>>>    // augment to release heap allocation
11261>>>>>>>    Procedure Destroy_Object
11263>>>>>>>        Send DestroyLegacyFieldHeap
11264>>>>>>>        Forward Send Destroy_object
11266>>>>>>>    End_Procedure
11267>>>>>>>    
11267>>>>>>>End_Class
11268>>>>>>>
11268>>>>>>>// This contains all extended field objects.
11268>>>>>>>// The array contains a list of all objects where item=field#
11268>>>>>>>// and item+1=field object.
11268>>>>>>>//
11268>>>>>>>// Interface is:
11268>>>>>>>//     Get Field_object iField to hFldObj
11268>>>>>>>//     Send DefineFieldObject iField
11268>>>>>>>//     Send ExtendedFieldsUpdate bSave
11268>>>>>>>//     Send ExtendedFieldsRefresh bCleared
11268>>>>>>>//
11268>>>>>>>Class FieldObjects is an Array
11269>>>>>>>    
11269>>>>>>>    // return object Id for iField. 0 if none.
11269>>>>>>>    Function Field_Object Integer iField Returns Integer
11271>>>>>>>        Integer iItm iCnt
11271>>>>>>>        Get Item_Count to iCnt
11272>>>>>>>        Move 0 to iItm
11273>>>>>>>        While iItm lt iCnt
11277>>>>>>>            If (Value(Self,iItm)=iField) ;                Function_Return (Value(Self,iItm+1))
11280>>>>>>>            Increment iItm
11281>>>>>>>            Increment iItm
11282>>>>>>>        Loop
11283>>>>>>>>
11283>>>>>>>        Function_Return 0
11284>>>>>>>    End_Function
11285>>>>>>>    
11285>>>>>>>    // define an extended object for field
11285>>>>>>>    Procedure DefineFieldObject Integer iField
11287>>>>>>>        Integer hFld
11287>>>>>>>        Integer iCnt  iFile
11287>>>>>>>        Boolean bInUse
11287>>>>>>>        Boolean bHasRecord
11287>>>>>>>        Delegate Get Main_File to iFile
11289>>>>>>>        Get Field_Object iField to hFld // this shouldn't exist yet
11290>>>>>>>        If not hFld Begin
11292>>>>>>>            Get Create U_FieldObject to hFld
11293>>>>>>>            Send DefineField to hFld iFile iField
11294>>>>>>>            Get Item_Count to iCnt          // add to array
11295>>>>>>>            Set Value  iCnt to iField   // Pos   = field#
11296>>>>>>>            Set Value  (iCnt+1) to hFld // Pos+1 = field object
11297>>>>>>>            Delegate Get In_Use_State to bInUse
11299>>>>>>>            If bInUse Begin
11301>>>>>>>                Delegate Send Refind_Records
11303>>>>>>>                Delegate Get HasRecord to bHasRecord
11305>>>>>>>                // updating the newly created field with the file buffer contents we don't
11305>>>>>>>                // want to change the field's changed state, which might have been set already.
11305>>>>>>>                Send FieldRefresh of hFld (not(bHasRecord)) False
11306>>>>>>>            End
11306>>>>>>>>
11306>>>>>>>        End
11306>>>>>>>>
11306>>>>>>>    End_Procedure
11307>>>>>>>    
11307>>>>>>>    // update all extended fields. Field buffer <-- DD buffer
11307>>>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
11309>>>>>>>        Integer iItm iCnt
11309>>>>>>>        Get Item_Count to iCnt
11310>>>>>>>        Move 0 to iItm
11311>>>>>>>        While iItm lt iCnt
11315>>>>>>>            Increment iItm
11316>>>>>>>            Send FieldUpdate to (Value(Self,iItm)) bSave
11317>>>>>>>            Increment iItm
11318>>>>>>>        Loop
11319>>>>>>>>
11319>>>>>>>    End_Procedure
11320>>>>>>>    
11320>>>>>>>    // refresh all extended fields. Field buffer --> DD buffer
11320>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
11322>>>>>>>        Integer iItm iCnt
11322>>>>>>>        Get Item_Count to iCnt
11323>>>>>>>        Move 0 to iItm
11324>>>>>>>        While iItm lt iCnt
11328>>>>>>>            Increment iItm
11329>>>>>>>            Send FieldRefresh to (Value(Self,iItm)) bCleared True
11330>>>>>>>            Increment iItm
11331>>>>>>>        Loop
11332>>>>>>>>
11332>>>>>>>    End_Procedure
11333>>>>>>>    
11333>>>>>>>    //
11333>>>>>>>    // these are sent from the child field object. We need to direct them
11333>>>>>>>    // to the DDO (the parent).
11333>>>>>>>    Procedure Set Field_Changed_State Integer iField Integer bState
11335>>>>>>>        Delegate Set Field_Changed_state iField to bState
11337>>>>>>>    End_Procedure
11338>>>>>>>    
11338>>>>>>>    Function Field_Changed_State Integer iField Returns Integer
11340>>>>>>>        Integer bState
11340>>>>>>>        Delegate Get Field_Changed_state iField to bState
11342>>>>>>>        Function_Return bState
11343>>>>>>>    End_Function
11344>>>>>>>    
11344>>>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iMode
11346>>>>>>>        Delegate Send File_field_AutoFind iFile iField iMode
11348>>>>>>>    End_Procedure
11349>>>>>>>    
11349>>>>>>>    Function FieldSaveNoPut Integer iField Returns Boolean
11351>>>>>>>        Boolean bIsCommited bNoPut
11351>>>>>>>        Delegate Get IsCommitted to bIsCommited
11353>>>>>>>        // we don't know if this is foreign or not (DDOs never do by themselves). We
11353>>>>>>>        // will test for regular. This should never be an issue as the DEO itself
11353>>>>>>>        // will be DisplayOnly as needed (we don't have indexed NoEnter=T/Noput=F issues)
11353>>>>>>>        Delegate Get FieldNoPut iField bIsCommited False to bNoPut
11355>>>>>>>        Function_Return bNoPut
11356>>>>>>>    End_Function
11357>>>>>>>    
11357>>>>>>>    Procedure Destroy_Object
11359>>>>>>>        Delegate Set Field_Objects to 0
11361>>>>>>>        Forward Send Destroy_object
11363>>>>>>>    End_Procedure
11364>>>>>>>    
11364>>>>>>>    
11364>>>>>>>End_Class
11365>>>>>// for text and binary. Must support Address Type
11365>>>>>
11365>>>>>
11365>>>>>// we need these from CLI.pkg for DAW drivers. These values must match what is defined
11365>>>>>// in cli.pkg
11365>>>>>Define DF_FILE_SQL_FILTER for 611
11365>>>>>Define DF_FILE_SQL_FILTER_ACTIVE for 624
11365>>>>>Define DF_FILE_SQL_FILTER_EQ for 636
11365>>>>>// same a CLI.pkg DF_FILE_TABLE_NAME but with a different name
11365>>>>>// used to avoid naming conflict. Must match cli.pkg df_file_table_name
11365>>>>>Define DF_FILE_SQL_TABLE_NAME for 609
11365>>>>>
11365>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE     for 1085
11365>>>>>Define DF_FILE_DATABASE_ID              for 622
11365>>>>>
11365>>>>>// Class helper for SQL/driver assistance.
11365>>>>>// This can only be used within a DataDictionary Class as it expects that
11365>>>>>// certain properties can be Get and Set via delegation.
11365>>>>>Class cDAWSQLDriverHelper is a cObject
11366>>>>>    
11366>>>>>    Function DriverIndex String sDriver Returns Integer
11368>>>>>        String  sCurrentDriver
11368>>>>>        Integer iNumberOfDrivers iDriver iCount
11368>>>>>        Move 0 to iDriver
11369>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
11372>>>>>        For iCount from 1 to iNumberOfDrivers
11378>>>>>>
11378>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
11381>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
11383>>>>>                Function_Return iCount
11384>>>>>            End
11384>>>>>>
11384>>>>>        Loop
11385>>>>>>
11385>>>>>        Function_Return 0
11386>>>>>    End_Function
11387>>>>>    
11387>>>>>    
11387>>>>>    // returns true if this table supports SQL filter interface
11387>>>>>    Function SupportsSQLFilters Returns Boolean
11389>>>>>        String sDriver
11389>>>>>        Integer iFile iDriver iConformance
11389>>>>>        Delegate Get Main_File to iFile
11391>>>>>        Get_Attribute DF_FILE_DRIVER of iFile to sDriver
11394>>>>>        Get DriverIndex sDriver to iDriver
11395>>>>>        If (iDriver) Begin
11397>>>>>            Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
11400>>>>>        End
11400>>>>>>
11400>>>>>        Function_Return (iConformance iand 4)
11401>>>>>    End_Function
11402>>>>>    
11402>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
11402>>>>>    
11402>>>>>    // Escape character to escape LIKE wildcards
11402>>>>>    
11402>>>>>    
11402>>>>>    Function SQLEscapedStr String sSQL Returns String
11404>>>>>        String sEscapedSQL
11404>>>>>        // Replace one single quote by 2 single quotes
11404>>>>>        Move (Replaces("'",sSQL,"''")) to sEscapedSQL
11405>>>>>        Function_Return sEscapedSQL
11406>>>>>    End_Function
11407>>>>>    
11407>>>>>    
11407>>>>>    Function SQLEscapeLikeWildcards String sSQL Returns String
11409>>>>>        
11409>>>>>        // Escape the wildcard characters than can be used in a LIKE
11409>>>>>        If (Pos("%",sSQL)) ;            Move (Replaces("%",sSQL,(SQL_LIKE_ESC + "%"))) to sSQL
11412>>>>>        If (Pos("_",sSQL)) ;            Move (Replaces("_",sSQL,(SQL_LIKE_ESC + "_"))) to sSQL
11415>>>>>        
11415>>>>>        Function_Return sSQL
11416>>>>>    End_Function
11417>>>>>    
11417>>>>>    
11417>>>>>    
11417>>>>>    // Creates an SQL Like Filter for this field and search target
11417>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
11419>>>>>        String sFilter sOrigFilter sField
11419>>>>>        Integer iFile
11419>>>>>        Integer iHasLikeEscape
11419>>>>>        String  sPrefix
11419>>>>>        
11419>>>>>        Delegate Get Main_File to iFile
11421>>>>>        Delegate Get psSQLFilter to sOrigFilter
11423>>>>>        Get SQLStrFieldName iField to sField
11424>>>>>        Get SQLEscapedStr sSearch to sSearch
11425>>>>>        
11425>>>>>        Move (Pos(SQL_LIKE_ESC,sSearch)) to iHasLikeEscape
11426>>>>>        If (not(iHasLikeEscape)) Begin
11428>>>>>            Get SQLEscapeLikeWildcards sSearch to sSearch
11429>>>>>        End
11429>>>>>>
11429>>>>>        
11429>>>>>        // Add the N prefix to properly handle Unicode data
11429>>>>>        Move 'N' to sPrefix
11430>>>>>        Move (sField + " LIKE " + sPrefix + "'%" + sSearch + "%'") to sFilter
11431>>>>>        
11431>>>>>        If (not(iHasLikeEscape)) Begin
11433>>>>>            If (Pos(SQL_LIKE_ESC,sFilter)) Begin
11435>>>>>                Move (sFilter + " ESCAPE '" + SQL_LIKE_ESC + "' "  ) to sFilter
11436>>>>>            End
11436>>>>>>
11436>>>>>        End
11436>>>>>>
11436>>>>>        
11436>>>>>        Function_Return sFilter
11437>>>>>    End_Function
11438>>>>>    
11438>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
11438>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
11440>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
11442>>>>>            Move ( "(" + sOrigFilter + ") AND " + sFilter) to sFilter
11443>>>>>        End
11443>>>>>>
11443>>>>>        Else If (sFilter="") Begin
11446>>>>>            Move sOrigFilter to sFilter
11447>>>>>        End
11447>>>>>>
11447>>>>>        Function_Return sFilter
11448>>>>>    End_Function
11449>>>>>    
11449>>>>>    // Appends two filters with an or clause. Both or either can be empty.
11449>>>>>    // This may be used in OnConstrain methods when building SQL WHERE clauses in string values.
11449>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
11451>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
11453>>>>>            Move ("(" + sOrigFilter + ") OR (" + sFilter + ")") to sFilter
11454>>>>>        End
11454>>>>>>
11454>>>>>        Else If (sFilter="") Begin
11457>>>>>            Move sOrigFilter to sFilter
11458>>>>>        End
11458>>>>>>
11458>>>>>          Function_Return sFilter 
11459>>>>>    End_Function
11460>>>>>
11460>>>>>
11460>>>>>    Function SQLIdentifierQuote Handle hTable Returns String
11462>>>>>
11462>>>>>        String  sDriver        
11462>>>>>        Integer iDriverIndex
11462>>>>>        Handle  hDatabase
11462>>>>>        String  sIdentifierQuote
11462>>>>>        
11462>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriver
11465>>>>>        
11465>>>>>        Get DriverIndex sDriver to iDriverIndex        
11466>>>>>        If (iDriverIndex) Begin
11468>>>>>            Get_Attribute DF_FILE_DATABASE_ID of hTable to hDatabase            
11471>>>>>            If (hDatabase) Begin
11473>>>>>                Get_Attribute DF_DATABASE_IDENTIFIER_QUOTE of iDriverIndex hDatabase to sIdentifierQuote
11476>>>>>            End
11476>>>>>>
11476>>>>>        End
11476>>>>>>
11476>>>>>        
11476>>>>>        Function_Return sIdentifierQuote
11477>>>>>        
11477>>>>>    End_Function
11478>>>>>
11478>>>>>
11478>>>>>
11478>>>>>    // returns the name of the File and Field suitable for an SQL where statement ("Table"."Column")
11478>>>>>    Function SQLStrFileFieldName Integer iField Returns String
11480>>>>>        String sFile sField
11480>>>>>        Integer iFile
11480>>>>>        String  sIdentifierQuote
11480>>>>>        
11480>>>>>        Get Main_File to iFile
11481>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11484>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
11487>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11488>>>>>        
11488>>>>>        Function_Return (sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11489>>>>>    End_Function
11490>>>>>
11490>>>>>    // returns the name of the Field suitable for an SQL where statement ("Column")
11490>>>>>    Function SQLStrFieldName Integer iField Returns String
11492>>>>>        String sField 
11492>>>>>        Integer iFile
11492>>>>>        String sIdentifierQuote
11492>>>>>        Get Main_File to iFile
11493>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
11496>>>>>        
11496>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11497>>>>>        
11497>>>>>        Function_Return (sIdentifierQuote + sField + sIdentifierQuote ) 
11498>>>>>
11498>>>>>    End_Function
11499>>>>>
11499>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement ("Schema"."Table"."Column")
11499>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
11501>>>>>        String sFile sField sSchema
11501>>>>>        Integer iFile
11501>>>>>        String sIdentifierQuote
11501>>>>>        
11501>>>>>        Get Main_File to iFile
11502>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11505>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
11508>>>>>        Get_Attribute DF_FILE_OWNER of iFile to sSchema
11511>>>>>
11511>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11512>>>>>            
11512>>>>>        If (Trim(sSchema) <> "") ;            Function_Return (sIdentifierQuote + sSchema + sIdentifierQuote + '.' + sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11515>>>>>        Else ;            Function_Return (sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11517>>>>>            
11517>>>>>            
11517>>>>>            
11517>>>>>    End_Function
11518>>>>>    
11518>>>>>    //  returns the name of a file suitable for a SQL statement
11518>>>>>    Function SQLStrFileName Integer iField Returns String
11520>>>>>        String sFile
11520>>>>>        Integer iFile
11520>>>>>        String sIdentifierQuote
11520>>>>>        
11520>>>>>        Get Main_File to iFile
11521>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11524>>>>>        
11524>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11525>>>>>        
11525>>>>>        Function_Return (sIdentifierQuote + sFile + sIdentifierQuote)
11526>>>>>    End_Function
11527>>>>>    
11527>>>>>    // called before an SQL Filter find. Make sure that any global and table attributes are
11527>>>>>    // stored.
11527>>>>>    Procedure StoreDefaultSQLFilters
11529>>>>>        String sOldFilter
11529>>>>>        Boolean bOldFilterActive bOldFilterEQ
11529>>>>>        Integer iMain
11529>>>>>        Get Main_File to iMain
11530>>>>>        Get_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
11533>>>>>        Get_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
11536>>>>>        Get_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
11539>>>>>        Delegate Set psOldFilter to sOldFilter
11541>>>>>        Delegate Set pbOldFilterActive to bOldFilterActive
11543>>>>>        Delegate Set pbOldFilterEq to bOldFilterEQ
11545>>>>>    End_Procedure
11546>>>>>    
11546>>>>>    // called after an SQL find. Must restore the global and table SQL filter attributes
11546>>>>>    Procedure RestoreDefaultSQLFilters
11548>>>>>        String sOldFilter
11548>>>>>        Boolean bOldFilterActive bOldFilterEQ
11548>>>>>        Integer iMain
11548>>>>>        Delegate Get Main_File to iMain
11550>>>>>        Delegate Get psOldFilter to sOldFilter
11552>>>>>        Delegate Get pbOldFilterActive to bOldFilterActive
11554>>>>>        Delegate Get pbOldFilterEq to bOldFilterEQ
11556>>>>>        Set_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
11559>>>>>        Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
11562>>>>>        Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
11565>>>>>    End_Procedure
11566>>>>>    
11566>>>>>    // applies the passed SQL filter. If empty, it should make sure that no filter
11566>>>>>    // is applied. If non-empty it should set the filter active, set the filter string
11566>>>>>    // and make sure this is applied to all finds (including find EQ)
11566>>>>>    Procedure ApplySQLFilterStr String sFilter
11568>>>>>        Integer iMain
11568>>>>>        Delegate Get Main_File to iMain
11570>>>>>        If (sFilter<>"") Begin
11572>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to True
11575>>>>>            Set_Attribute DF_FILE_SQL_FILTER of iMain to sFilter
11578>>>>>            Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to True
11581>>>>>        End
11581>>>>>>
11581>>>>>        Else Begin
11582>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to False
11585>>>>>        End
11585>>>>>>
11585>>>>>    End_Procedure
11586>>>>>    
11586>>>>>End_Class
11587>>>>>
11587>>>>>// Every data_set will have a object based on this class. It will hold
11587>>>>>// the values for the fields, the entry_options and the messages IDs of the
11587>>>>>// iEntry, iExit and iValidate messages for each field.
11587>>>>>// It is assumed that an object of this class will always be used as a
11587>>>>>// child object of a Data_Set object.
11587>>>>>//
11587>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.
11587>>>>>//
11587>>>>>// ITEM-PROPERTY   ASSIGNED-FUNCTION
11587>>>>>//
11587>>>>>// Value           The value of the field. Will be updated whenever the
11587>>>>>//                 value of a field changes due to data-entry or a found
11587>>>>>//                 record.
11587>>>>>// Data_File       Contains the filenumber. Is the same for every item.
11587>>>>>// Data_Field      Contains the fieldnumber for the item. Is equal to the
11587>>>>>//                 items' itemnumber.
11587>>>>>// Item_Options    Used to store the standard item-options of a field.
11587>>>>>// Aux_Value       Used to store the foreign-item-options of a field.
11587>>>>>Class cRecordBuffer is an cDDBuffer
11588>>>>>    
11588>>>>>    // This procedure will be called from the Data_Set when the Main_File is
11588>>>>>    // being set. It will create an item for each field of the file in this
11588>>>>>    // object. Fields of the types DF_OVERLAP, DF_TEXT and DF_BINARY are
11588>>>>>    // currently not added.
11588>>>>>    Procedure Create_Items Integer iFile
11590>>>>>        Integer iField_Count iField
11590>>>>>        
11590>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iField_Count
11593>>>>>        Set Main_File to iFile
11594>>>>>        Send Delete_Data
11595>>>>>        Set Item_Count to (iField_Count+1)
11596>>>>>        For iField from 0 to iField_Count
11602>>>>>>
11602>>>>>            // will skip recnum (field 0) if non-recnum table
11602>>>>>            // will set to skip if binary, text or overlap
11602>>>>>            Set Data_Field iField to iField
11603>>>>>        Loop
11604>>>>>>
11604>>>>>    End_Procedure
11605>>>>>    
11605>>>>>    // when an alias is created, we want to clear any values that will not be applied to
11605>>>>>    // this alias DD such as prompt and zoom objects (which would point to the superclass master)
11605>>>>>    Procedure ReDefineAliasItems Integer iFile
11607>>>>>        Integer i iItems
11607>>>>>        
11607>>>>>        Set Main_File to iFile
11608>>>>>        Get item_count to iItems
11609>>>>>        For i from 0 to (iItems-1)
11615>>>>>>
11615>>>>>            Set Prompt_Object i to 0
11616>>>>>            Set Zoom_Object i to 0
11617>>>>>        Loop
11618>>>>>>
11618>>>>>    End_Procedure
11619>>>>>    
11619>>>>>    
11619>>>>>    // This procedure will be called from the parent Data_Set whenever the
11619>>>>>    // Data_Set changes its Current_Record property, or after a Save, Delete
11619>>>>>    // or Clear operation.
11619>>>>>    // We use this event to store the values of the fields in our local
11619>>>>>    // record buffer.
11619>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
11621>>>>>        Integer iMain_File
11621>>>>>        Integer iOldState
11621>>>>>        tDDRemembered[] DefaultValues
11621>>>>>        tDDRemembered[] DefaultValues
11622>>>>>        Boolean bRetain bInReSync
11622>>>>>        Integer iFld iFlds iIndex
11622>>>>>        Handle hoDD
11622>>>>>        
11622>>>>>        Get Parent to hoDD
11623>>>>>        Delegate Get Main_File to iMain_File
11625>>>>>        
11625>>>>>        If not (IsNullRowId(riNew)) ;            Send Entry_Display
11628>>>>>        Else Begin
11629>>>>>            
11629>>>>>            If (OPERATION_ORIGIN) Begin
11631>>>>>                // this gets set by webapp during a resync. During resyncs you don't want to rely
11631>>>>>                // on the values in the buffers (as they may not be yours) so you cannot do retain
11631>>>>>                // of rememberlast. Fortunately, you don't need to as this information is not
11631>>>>>                // needed during a resync.
11631>>>>>                Get pbInResync of operation_origin to bInResync
11632>>>>>            End
11632>>>>>>
11632>>>>>            
11632>>>>>            // if we have any 17.0 Remember last value items, we must add those items to our array
11632>>>>>            // only do this if this is the operation origin or a parent (i.e., skip if a child DDO)
11632>>>>>            // Also skip if a resync. See above
11632>>>>>            If ( not(bInReSync) and ;                ( (Operation_Origin=hoDD) or ;                ( OPERATION_ORIGIN and (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ) Begin
11634>>>>>                Delegate Get pDDDefaults to DefaultValues
11636>>>>>                Move (SizeOfArray(DefaultValues)) to iFlds
11637>>>>>                For iFld from 0 to (iFlds-1)
11643>>>>>>
11643>>>>>                    Move (DefaultValues[iFld].sDefault=DD_RememberLast) to bRetain // if this is a dynamically assigned remember-last
11644>>>>>// I don't think this test is needed
11644>>>>>//              // if a parent DD and not allow-foreign we want to ignore this if this is not an indexed field (for autofind)
11644>>>>>//              If ( bRetain and (Operation_Origin<>hoDD) and not(Allow_Foreign_New_Save_State(hoDD))) Begin
11644>>>>>//                 Get_Attribute DF_FIELD_INDEX of iMain_File DefaultValues[iFld].iField to iIndex
11644>>>>>//                 Move (iIndex<>0) to bRetain
11644>>>>>//              End
11644>>>>>                    If bRetain Begin
11646>>>>>                        Get Value DefaultValues[iFld].iField to DefaultValues[iFld].sLastValue
11647>>>>>                    End
11647>>>>>>
11647>>>>>                    Else Begin
11648>>>>>                        Move '' to DefaultValues[iFld].sLastValue
11649>>>>>                    End
11649>>>>>>
11649>>>>>                Loop
11650>>>>>>
11650>>>>>                Delegate Set pDDDefaults to DefaultValues
11652>>>>>            End
11652>>>>>>
11652>>>>>            
11652>>>>>            // we must do this to make retains not set changed_state
11652>>>>>            Delegate Get Change_Disabled_State to iOldState
11654>>>>>            Delegate Set Change_Disabled_State to True
11656>>>>>            // if mode is anything other than clear we do a clear all (clear keeps retains, clear all does not)
11656>>>>>            // also do clear-all if the DDO is foreign.
11656>>>>>            
11656>>>>>            // If bInReSync, we never use retains as the buffer is not ours yet.
11656>>>>>            // The Entry_Clear, Entry_Clear_All parameter is bIgnoreRetains.
11656>>>>>            // When True retain and retain_all states are ignored and cleared.
11656>>>>>            If (Operation_mode=MODE_CLEARING and ;                ( (Operation_Origin=parent(Self)) or ;                (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) Begin
11658>>>>>                Send Entry_Clear bInReSync
11659>>>>>            End
11659>>>>>>
11659>>>>>            Else Begin
11660>>>>>                Send Entry_Clear_all bInResync
11661>>>>>            End
11661>>>>>>
11661>>>>>            Delegate Set Change_Disabled_State to iOldState
11663>>>>>            Set Changed_State to False
11664>>>>>        End
11664>>>>>>
11664>>>>>    End_Procedure
11665>>>>>    
11665>>>>>    // Make sure to set the Changed_State of the Data_Set to TRUE when a
11665>>>>>    // field value changes and it's not during the Setting of the Defaults.
11665>>>>>    Procedure Set Changed_State Integer iState
11667>>>>>        Integer iNoChange
11667>>>>>        // Server.pkg in dso already knows this property
11667>>>>>        Delegate Get Change_disabled_State to iNoChange
11669>>>>>        If not iNoChange Begin
11671>>>>>            Forward Set Changed_State to iState
11673>>>>>            Delegate Set Changed_State to iState
11675>>>>>        End
11675>>>>>>
11675>>>>>    End_Procedure
11676>>>>>    
11676>>>>>End_Class
11677>>>>>
11677>>>>>
11677>>>>>// Objects of this class will be used to store all kinds of attributes
11677>>>>>// which belong to a field.
11677>>>>>//
11677>>>>>// FA_MIN_VALUE
11677>>>>>// Used to store the mininum value of field.
11677>>>>>//
11677>>>>>// FA_MAX_VALUE
11677>>>>>// Used to store the maximum value of a field.
11677>>>>>//
11677>>>>>// FA_CHECK_VALUE
11677>>>>>// Used to store a string which contains all possible values of a field.
11677>>>>>//
11677>>>>>// FA_CHECKBOX_TRUE
11677>>>>>// Used to store the TRUE value for a checkbox field
11677>>>>>//
11677>>>>>// FA_CHECKBOX_FALSE
11677>>>>>// Used to store the FALSE value of a checkbox field
11677>>>>>//
11677>>>>>// FA_TABLE_OBJECT
11677>>>>>// Stores object Id of a validation table.
11677>>>>>//
11677>>>>>// FA_ERROR_MESSAGE
11677>>>>>// Used to store a error text which will be shown to a user when a fields
11677>>>>>// value violates one of the rules defined for it.
11677>>>>>// This field may contain the special strings @MIN, @MAX and @CHECK. When
11677>>>>>// these are used, these will be replaced by the actual value of MIN_VALUE,
11677>>>>>// MAX_VALUE or CHECK_VALUE.
11677>>>>>//
11677>>>>>
11677>>>>>
11677>>>>>// Validation Types
11677>>>>>Enumeration_List
11677>>>>>    Define FA_VALIDATION_TYPE_NONE
11677>>>>>    Define FA_VALIDATION_TYPE_RANGE
11677>>>>>    Define FA_VALIDATION_TYPE_CHECK
11677>>>>>    Define FA_VALIDATION_TYPE_CHECKBOX
11677>>>>>    Define FA_VALIDATION_TYPE_TABLE
11677>>>>>End_Enumeration_List
11677>>>>>
11677>>>>>
11677>>>>>Class Field_Attributes is a Array
11678>>>>>    
11678>>>>>    Procedure Construct_Object
11680>>>>>        Forward Send Construct_Object
11682>>>>>        // Private: This replaces the use of arrays to get at this value. This
11682>>>>>        // allows us to find specific validation types (like checkboxes) more
11682>>>>>        // quickly than scanning an array
11682>>>>>        Property String Private.Validation_Types     ''
11683>>>>>    End_Procedure
11684>>>>>    
11684>>>>>    // Returns the extended validation type for the passed field.
11684>>>>>    Function Field_Validation_Type Integer iField Returns Integer
11686>>>>>        Integer iType
11686>>>>>        If iField ;            Move (mid(Private.Validation_Types(Self),1,iField)) to iType
11689>>>>>        Else ;            Move FA_VALIDATION_TYPE_NONE to iType
11691>>>>>        Function_Return iType
11692>>>>>    End_Function
11693>>>>>    
11693>>>>>    Procedure Set Field_Validation_Type Integer iField String sType
11695>>>>>        Integer iType
11695>>>>>        String sTypes
11695>>>>>        If iField Begin
11697>>>>>            Get Private.Validation_Types to sTypes
11698>>>>>            Set Private.Validation_Types to (Overstrike(sType, sTypes, iField))
11699>>>>>        End
11699>>>>>>
11699>>>>>    End_Procedure
11700>>>>>    
11700>>>>>    // Set any defaults required by this class when the main file is created.
11700>>>>>    // Create a string which contains all validation types. Set all to
11700>>>>>    // No extended validation type.
11700>>>>>    Procedure Create_Items
11702>>>>>        String  sType
11702>>>>>        Integer iCount
11702>>>>>        Delegate Get Field_Count to iCOunt
11704>>>>>        Move FA_VALIDATION_TYPE_NONE to sType
11705>>>>>        Set Private.Validation_Types to (Repeat(sType,iCount))
11706>>>>>    End_Procedure
11707>>>>>    
11707>>>>>    // Return field number of next field matching the passed validation type.
11707>>>>>    // Pass validation type and last position checked. Return 0 if no match
11707>>>>>    Function Next_Validation_Type String sType Integer iOffset Returns Integer
11709>>>>>        String sTypes
11709>>>>>        Integer iPos
11709>>>>>        Get Private.Validation_Types to sTypes
11710>>>>>        Move (Pos(sType, mid(sTypes,255,iOffset+1))) to iPos
11711>>>>>        If iPos ;            Add iOffset to iPos
11714>>>>>        Function_Return iPos
11715>>>>>    End_Function
11716>>>>>    
11716>>>>>    // This procedure will be called by the Extended_Data_Set to set the
11716>>>>>    // errornumber and message which will be triggered when it needs to.
11716>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
11718>>>>>        Integer iBase
11718>>>>>        Move (iField * FA_COUNT) to iBase
11719>>>>>        Set Value (iBase + FA_ERROR_NUMBER) to iErr
11720>>>>>        Set Value (iBase + FA_ERROR_MESSAGE) to sMsg
11721>>>>>    End_Procedure
11722>>>>>    
11722>>>>>    // Used to retreive the error number and message for a particular field
11722>>>>>    Function Field_Error_Number Integer iField Returns Integer
11724>>>>>        Integer iErr
11724>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_NUMBER)  to iErr
11725>>>>>        Function_Return iErr
11726>>>>>    End_Function
11727>>>>>    
11727>>>>>    Function Field_Error_Message Integer iField Returns String
11729>>>>>        String sValue
11729>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_MESSAGE) to sValue
11730>>>>>        Function_Return sValue
11731>>>>>    End_Function
11732>>>>>    
11732>>>>>    
11732>>>>>    // This function manages the validation of a field against its extended
11732>>>>>    // validations.
11732>>>>>    Function Validate_Field Integer iField Returns Integer
11734>>>>>        Integer iType
11734>>>>>        Integer iResult
11734>>>>>        Get Field_Validation_Type iField to iType
11735>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Get Validate_Field_Range iField to iResult
11738>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Get Validate_Field_Check iField to iResult
11742>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Get Validate_Field_Checkbox iField to iResult
11746>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Validate_Field_Table iField to iResult
11750>>>>>        Function_Return iResult
11751>>>>>    End_Function
11752>>>>>    
11752>>>>>    // All extended validations know how to send callback messages (iMsg) to
11752>>>>>    // the calling object (iObj). This allows external lists to get filled w/
11752>>>>>    // the contents of a range. Used by combo boxes, spinners, etc.
11752>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
11754>>>>>        Integer iType
11754>>>>>        Integer iResult
11754>>>>>        Get Field_Validation_Type iField to iType
11755>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Send Field_Fill_List_Field_Range iField iObj iMsg
11758>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Send Field_Fill_List_Field_Check iField iObj iMsg
11762>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Send Field_Fill_List_Field_Checkbox iField iObj iMsg
11766>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Send Field_Fill_List_Field_Table iField iObj iMsg
11770>>>>>    End_Procedure
11771>>>>>    
11771>>>>>    // Return the id of the validation table if one exists. Otherwise return
11771>>>>>    // a zero.
11771>>>>>    Function Field_Table_Object Integer iField Returns Integer
11773>>>>>        Integer iType
11773>>>>>        Integer iObj
11773>>>>>        Integer iBase
11773>>>>>        Move (iField * FA_COUNT) to iBase
11774>>>>>        Get Field_Validation_Type iField to iType
11775>>>>>        If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Value (iBase + FA_TABLE_OBJECT) to iObj
11778>>>>>        Function_Return iObj
11779>>>>>    End_Function
11780>>>>>    
11780>>>>>    // Procedure to set the range for a field. It will automatically set the
11780>>>>>    // validation type of the field as well.
11780>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
11782>>>>>        Integer iBase
11782>>>>>        Move (iField * FA_COUNT) to iBase
11783>>>>>        Set Value (iBase + FA_MIN_VALUE) to sMin
11784>>>>>        Set Value (iBase + FA_MAX_VALUE) to sMax
11785>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_RANGE
11786>>>>>    End_Procedure
11787>>>>>    
11787>>>>>    // Function to check a fields value agains a given check string.
11787>>>>>    Function Validate_Field_Range Integer iField Returns Integer
11789>>>>>        String  sMin
11789>>>>>        String  sMax
11789>>>>>        String  sValue
11789>>>>>        Integer iField_Type
11789>>>>>        Integer iResult
11789>>>>>        Integer iFile
11789>>>>>        Integer iBase
11789>>>>>        Move (iField * FA_COUNT) to iBase
11790>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
11791>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
11792>>>>>        Delegate Get Field_Current_Value iField to sValue
11794>>>>>        Delegate Get Main_File to iFile
11796>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
11799>>>>>        Move 0 to iResult
11800>>>>>        If (iField_Type=DF_ASCII) ;            Move (sValue < sMin or sValue > sMax) to iResult
11803>>>>>        Else If (iField_Type=DF_BCD) ;            Move (Number(sValue) < Number(sMin) or ;            Number(sValue) > Number(sMax)) to iResult
11807>>>>>        Else If (iField_Type=DF_DATE) ;            Move (Date(sValue) < Date(sMin) or Date(sValue) > Date(sMax)) to iResult
11811>>>>>        Else If (iField_Type=DF_DATETIME) ;            Move (Cast(sValue,DateTime) < Cast(sMin,DateTime) or Cast(sValue,DateTime) > Cast(sMax,DateTime)) to iResult
11815>>>>>        If iResult Begin
11817>>>>>            Delegate Send Field_Error iField DD_INVALID_RANGE sMin sMax
11819>>>>>            Function_Return 1
11820>>>>>        End
11820>>>>>>
11820>>>>>    End_Function
11821>>>>>    
11821>>>>>    // Callback to provide all valid value for this validation.
11821>>>>>    // Just call back with the two range values
11821>>>>>    Procedure Field_Fill_List_Field_Range Integer iField Integer iObj Integer iMsg
11823>>>>>        String  sMin
11823>>>>>        String  sMax
11823>>>>>        Integer iBase
11823>>>>>        Move (iField * FA_COUNT) to iBase
11824>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
11825>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
11826>>>>>        Send iMsg to iObj 0 sMin '' 0 (NullrowId())
11827>>>>>        Send iMsg to iObj 1 sMax '' 0 (NullrowId())
11828>>>>>    End_Procedure
11829>>>>>    
11829>>>>>    // Procedure to set the check for a field. It will automatically set the
11829>>>>>    // validation type of the field as well.
11829>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
11831>>>>>        Integer iBase
11831>>>>>        Move (iField * FA_COUNT) to iBase
11832>>>>>        Set Value (iBase + FA_CHECK_VALUE) to sCheck
11833>>>>>        //Set Value iBase to FA_VALIDATION_TYPE_CHECK
11833>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECK
11834>>>>>    End_Procedure
11835>>>>>    
11835>>>>>    // Function to check a fields value agains a given check string.
11835>>>>>    Function Validate_Field_Check Integer iField Returns Integer
11837>>>>>        String  sCheck
11837>>>>>        String  sValue
11837>>>>>        Integer iBase
11837>>>>>        Integer iPos
11837>>>>>        Integer iLength
11837>>>>>        Integer iResult
11837>>>>>        Integer iFile
11837>>>>>        Move (iField * FA_COUNT) to iBase
11838>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
11839>>>>>        Delegate Get Field_Current_Value iField to sValue
11841>>>>>        Delegate Get Main_File to iFile
11843>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
11846>>>>>        Move (Pad( sValue,iLength)) to sValue
11847>>>>>        // Replace the seperation characters with two of them so the user
11847>>>>>        // can't bypass the check by entering a seperation character.
11847>>>>>        Move (Replaces("|", sValue, "||")) to sValue
11848>>>>>        // Report an error if rules are violated.
11848>>>>>        Move (Pos( sValue, sCheck)) to iPos
11849>>>>>        If not iPos Begin
11851>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECK sCheck
11853>>>>>            Function_Return 1
11854>>>>>        End
11854>>>>>>
11854>>>>>    End_Function
11855>>>>>    
11855>>>>>    // Callback to provide all valid value for this validation.
11855>>>>>    // Call back with all valid check values
11855>>>>>    Procedure Field_Fill_List_Field_Check Integer iField Integer iObj Integer iMsg
11857>>>>>        String  sCheck
11857>>>>>        Integer iBase
11857>>>>>        Integer iPos
11857>>>>>        Integer iItem
11857>>>>>        Move (iField * FA_COUNT) to iBase
11858>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
11859>>>>>        Append sCheck "|"
11860>>>>>        Move (Pos( "|", sCheck)) to iPos
11861>>>>>        While iPos
11865>>>>>            If (iPos > 1) Begin
11867>>>>>                Send iMsg to iObj iItem (Left(sCheck,iPos-1)) '' 0 (NullrowId())
11868>>>>>                Increment iItem
11869>>>>>            End
11869>>>>>>
11869>>>>>            Move (Mid( sCheck, 255, iPos+1))  to sCheck
11870>>>>>            Move (Pos( "|", sCheck)) to iPos
11871>>>>>        Loop
11872>>>>>>
11872>>>>>    End_Procedure
11873>>>>>    
11873>>>>>    // Procedure to set up a checkbox field. We will store the TRUE and FALSE
11873>>>>>    // Values in the extended array.
11873>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
11875>>>>>        Integer iBase
11875>>>>>        Move (iField * FA_COUNT) to iBase
11876>>>>>        Set Value (iBase + FA_CHECKBOX_TRUE) to sTrue
11877>>>>>        Set Value (iBase + FA_CHECKBOX_FALSE) to sFalse
11878>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECKBOX
11879>>>>>    End_Procedure
11880>>>>>    
11880>>>>>    // Return the Value associated with the field and its select-state.
11880>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
11882>>>>>        Integer iBase
11882>>>>>        Integer iType
11882>>>>>        String sValue
11882>>>>>        Move (iField * FA_COUNT) to iBase
11883>>>>>        Get Field_Validation_Type iField to iType
11884>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move iState to sValue
11887>>>>>        Else ;            Get Value (iBase + If(iState,FA_CHECKBOX_TRUE,FA_CHECKBOX_FALSE));            to sValue
11889>>>>>        Function_Return sValue
11890>>>>>    End_Function
11891>>>>>    
11891>>>>>    // Return the select_state based on the passed value and field
11891>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
11893>>>>>        Integer iBase
11893>>>>>        Integer iType
11893>>>>>        String  sTrue
11893>>>>>        Integer iState
11893>>>>>        Integer iFile
11893>>>>>        Integer iField_Type
11893>>>>>        Move (iField * FA_COUNT) to iBase
11894>>>>>        Get Field_Validation_Type iField to iType
11895>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
11896>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move (not(sValue=0 or sValue='')) to iState
11899>>>>>        Else Begin
11900>>>>>            Delegate Get Main_File to iFile
11902>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
11905>>>>>            If (iField_Type = DF_BCD) ;                Move (Number(sValue)=Number(sTrue)) to iState
11908>>>>>            Else ; // DF_ASCII                Move (sValue=sTrue) to iState
11910>>>>>        End
11910>>>>>>
11910>>>>>        Function_Return iState
11911>>>>>    End_Function
11912>>>>>    
11912>>>>>    
11912>>>>>    // Check that the buffer value is one of the two checkbox values.
11912>>>>>    Function Validate_Field_Checkbox Integer iField Returns Integer
11914>>>>>        String  sTrue
11914>>>>>        String  sFalse
11914>>>>>        String  sValue
11914>>>>>        Integer iField_Type
11914>>>>>        Integer iResult
11914>>>>>        Integer iFile
11914>>>>>        Integer iBase
11914>>>>>        Move (iField * FA_COUNT) to iBase
11915>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
11916>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
11917>>>>>        Delegate Get Field_Current_Value iField to sValue
11919>>>>>        Delegate Get Main_File to iFile
11921>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
11924>>>>>        Move 0 to iResult
11925>>>>>        If (iField_Type = DF_BCD) ;            Move (Number(sValue)=Number(sTrue) or ;            Number(sValue)=Number(sFalse)) to iResult
11928>>>>>        Else ; // DF_ASCII            Move (sValue=sTrue or sValue=sFalse) to iResult
11930>>>>>        If not iResult Begin
11932>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECKBOX sTrue sFalse
11934>>>>>            Function_Return 1
11935>>>>>        End
11935>>>>>>
11935>>>>>    End_Function
11936>>>>>    
11936>>>>>    // Callback to provide all valid value for this validation.
11936>>>>>    // Just call back with the two true and false values
11936>>>>>    Procedure Field_Fill_List_Field_Checkbox Integer iField Integer iObj Integer iMsg
11938>>>>>        String  sTrue
11938>>>>>        String  sFalse
11938>>>>>        Integer iBase
11938>>>>>        Move (iField * FA_COUNT) to iBase
11939>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
11940>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
11941>>>>>        Send iMsg to iObj 0 sTrue '' 0 (NullrowId())
11942>>>>>        Send iMsg to iObj 1 sFalse '' 0 (NullrowId())
11943>>>>>    End_Procedure
11944>>>>>    
11944>>>>>    // The object keeps track of a validation table object. This table object
11944>>>>>    // can be any type of object must at a minimum understand a small message
11944>>>>>    // protocol (see xvaltbl.pkg for info)
11944>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
11946>>>>>        Integer iBase
11946>>>>>        Move (iField * FA_COUNT) to iBase
11947>>>>>        Set Value (iBase + FA_TABLE_OBJECT) to iObj
11948>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_TABLE
11949>>>>>    End_Procedure
11950>>>>>    
11950>>>>>    // This valdates against a validation table if appropriate (if a table
11950>>>>>    // exists and the table's validate_State is T). It validates by passing
11950>>>>>    // the message validate_value to the validation table object
11950>>>>>    Function Validate_Field_Table Integer iField Returns Integer
11952>>>>>        Integer iBase
11952>>>>>        Integer iTableObj
11952>>>>>        String  sValue
11952>>>>>        Integer iResult
11952>>>>>        Move (iField * FA_COUNT) to iBase
11953>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
11954>>>>>        If (iTableObj and Validate_State(iTableObj) ) Begin
11956>>>>>            Delegate Get Field_Current_Value iField to sValue
11958>>>>>            Get Validate_Value of iTableOBj sValue to iResult
11959>>>>>            If iResult ;                Delegate Send Field_Error iField DD_INVALID_VALUE_TABLE
11963>>>>>        End
11963>>>>>>
11963>>>>>        Function_Return iResult
11964>>>>>    End_Function
11965>>>>>    
11965>>>>>    // Callback to provide all valid value for this validation.
11965>>>>>    // Pass the request on to the validation table. This is the most common
11965>>>>>    // use of this.
11965>>>>>    Procedure Field_Fill_List_Field_Table Integer iField Integer iObj Integer iMsg
11967>>>>>        Integer iBase
11967>>>>>        Integer iTableObj
11967>>>>>        Move (iField * FA_COUNT) to iBase
11968>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
11969>>>>>        If iTableObj ;            Send Request_Fill_From_List to iTableObj iObj iMsg
11972>>>>>    End_Procedure
11973>>>>>    
11973>>>>>    // Often extended valditation types can provide automatic prompt
11973>>>>>    // objects. If the extended type supports a prompt object and there is
11973>>>>>    // a global validation_list object, we will use it
11973>>>>>    Function Prompt_Object Integer iField Returns Integer
11975>>>>>        Integer iType
11975>>>>>        Integer iObj
11975>>>>>        Get Field_Validation_Type iField to iType
11976>>>>>        If not (iType=FA_VALIDATION_TYPE_NONE or iType=FA_VALIDATION_TYPE_RANGE) ;            Move DD_Global_Validation_Prompt_Object to iObj
11979>>>>>        Function_Return iObj
11980>>>>>    End_Function
11981>>>>>    
11981>>>>>    
11981>>>>>End_Class
11982>>>>>
11982>>>>>
11982>>>>>
11982>>>>>// use to keep track of file field pairs such as system file file/field
11982>>>>>Struct tDDFileField
11982>>>>>    Integer iFile
11982>>>>>    Integer iField
11982>>>>>End_Struct
11982>>>>>
11982>>>>>Class Field_Mask_Array is an Array
11983>>>>>    
11983>>>>>    Function Array_Name Integer iField Integer iType Returns String
11985>>>>>        String sName
11985>>>>>        Move (iField*FMA_COUNT+iType) to iField
11986>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to sName
11989>>>>>        // sometimes an array value that is undefined returns a 0, we must change this to ''
11989>>>>>        If (sName = '0') ;            Move '' to sName
11992>>>>>        Function_Return sName
11993>>>>>    End_Function
11994>>>>>    
11994>>>>>    
11994>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
11996>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_TYPE) to iType
11997>>>>>    End_Procedure
11998>>>>>    
11998>>>>>    Function Field_Mask_Type Integer iField Returns Integer
12000>>>>>        Integer iType
12000>>>>>        Move (iField*FMA_COUNT+FMA_MASK_TYPE) to iField
12001>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iType
12004>>>>>        Function_Return iType
12005>>>>>    End_Function
12006>>>>>    
12006>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
12008>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iState
12009>>>>>    End_Procedure
12010>>>>>    
12010>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
12012>>>>>        Integer iState
12012>>>>>        Move (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iField
12013>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iState
12016>>>>>        Function_Return iState
12017>>>>>    End_Function
12018>>>>>    
12018>>>>>    Procedure Set Field_Mask Integer iField String sMask
12020>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK) to sMask
12021>>>>>    End_Procedure
12022>>>>>    
12022>>>>>    Function Field_Mask Integer iField Returns String
12024>>>>>        Function_Return (Array_Name(Self,iField,FMA_MASK))
12025>>>>>    End_Function
12026>>>>>    
12026>>>>>    Procedure Set Field_Label_Short Integer iField String sName
12028>>>>>        Set Value (iField*FMA_COUNT+FMA_SHORT_NAME) to sName
12029>>>>>    End_Procedure
12030>>>>>    
12030>>>>>    Function Field_Label_Short Integer iField Returns String
12032>>>>>        Function_Return (Array_Name(Self,iField,FMA_SHORT_NAME))
12033>>>>>    End_Function
12034>>>>>    
12034>>>>>    Procedure Set Field_Label_Long Integer iField String sName
12036>>>>>        Set Value (iField*FMA_COUNT+FMA_LONG_NAME) to sName
12037>>>>>    End_Procedure
12038>>>>>    
12038>>>>>    Function Field_Label_Long Integer iField Returns String
12040>>>>>        Function_Return (Array_Name(Self,iField,FMA_LONG_NAME))
12041>>>>>    End_Function
12042>>>>>    
12042>>>>>    Procedure Set Field_Class_Name Integer iField String sName
12044>>>>>        Set Value (iField*FMA_COUNT+FMA_CLASS_NAME) to sName
12045>>>>>    End_Procedure
12046>>>>>    
12046>>>>>    Function Field_Class_Name Integer iField Returns String
12048>>>>>        Function_Return (Array_Name(Self,iField,FMA_CLASS_NAME))
12049>>>>>    End_Function
12050>>>>>    
12050>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoPrompt
12052>>>>>        Set Value (iField*FMA_COUNT+FMA_WEBPROMPTOBJECT) to hoPrompt
12053>>>>>    End_Procedure
12054>>>>>    
12054>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
12056>>>>>        Function_Return (Array_Name(Self,iField,FMA_WEBPROMPTOBJECT))
12057>>>>>    End_Function
12058>>>>>    
12058>>>>>End_Class
12059>>>>>
12059>>>>>Class DataDictionary is a DataSet
12060>>>>>    
12060>>>>>    Procedure Construct_Object
12062>>>>>        Forward Send Construct_Object
12064>>>>>        
12064>>>>>        Property String  Existing_Key_Value                           ""
12065>>>>>        Property Integer Protect_Key_State                            True
12066>>>>>        
12066>>>>>        Property String  Key_Fields                                   ""
12067>>>>>        
12067>>>>>        // These are added to support the checking of DSO connections
12067>>>>>        // during deletes and saves. Only the first two properties are Public
12067>>>>>        Property Integer Validate_Save_Structure_Mode   DD_Validate_Structure_Once
12068>>>>>        Property Integer Validate_Delete_Structure_Mode DD_Validate_Structure_Once
12069>>>>>        Property Integer Save_Structure_Validated_State              False
12070>>>>>        Property Integer Cascade_Delete_Structure_Validated_State    False
12071>>>>>        Property Integer No_Cascade_Delete_Structure_Validated_State False
12072>>>>>        
12072>>>>>        Property Integer Last_Mark_Sequence_Id                       0
12073>>>>>        
12073>>>>>        // These are added for optimized traversal of
12073>>>>>        // entry-update and validation and maybe more
12073>>>>>        Property String  Visited_Fields          ""
12074>>>>>        Property Integer Visited_State           False
12075>>>>>        // means will be part of a downward delete (cascade deletable). This only has meaning
12075>>>>>        // when cascade_delete_state is True
12075>>>>>        Property Boolean DownDelete_State        False
12076>>>>>        
12076>>>>>        // these are set by the define_auto_increment, which is obsolete and has been replaced
12076>>>>>        // the Set Field_auto_increment method.
12076>>>>>        Property Integer Auto_Increment_Source_File  0
12077>>>>>        Property Integer Auto_Increment_Source_Field 0
12078>>>>>        Property Integer Auto_Increment_Dest_Field   0
12079>>>>>        
12079>>>>>        // used by the set Field_auto_increment method
12079>>>>>        // these are split into two arrays to make searching for the field easier
12079>>>>>        // the arrays should always be synched.
12079>>>>>        Property Integer[] pAutoIncrementFields
12080>>>>>        Property tDDFileField[] pAutoIncrementSysFileFields
12081>>>>>        
12081>>>>>        // Error Reporting Related
12081>>>>>        // If DD_Error_No_Report errors would be supressed (only ERR gets set)
12081>>>>>        Property Integer Error_Report_Mode           DD_Error_Report
12082>>>>>        
12082>>>>>        // During validation, this is the field being validated.
12082>>>>>        Property Integer Current_Validate_Field      0
12083>>>>>        
12083>>>>>        // when errors are redirected locally this maintains the original handler.
12083>>>>>        Property Integer Old_Error_Object_Id         0
12084>>>>>        
12084>>>>>        // Must be provided if local error handler is to be created
12084>>>>>        Property Integer Error_Processing_State      0
12085>>>>>        
12085>>>>>        // These should be changed most carefully and possible only and the
12085>>>>>        // DSO level. These allow you to defeat full field validation which
12085>>>>>        // makes it easier to corrupt data! Validate_DEO_Only_State limits
12085>>>>>        // save validation to DEOs (which is what data-sets have always done).
12085>>>>>        // Validate_foreign_File_State will skip validation under the following
12085>>>>>        // conditions: 1) DSO if for a parent (it did not originate the save).
12085>>>>>        //
12085>>>>>        Property Integer Validate_DEOs_Only_State    False
12086>>>>>        Property Integer Validate_Foreign_File_State True
12087>>>>>        // if set true, a field validation requested started with this
12087>>>>>        // DD will check all fields, even in an error is encountered
12087>>>>>        Property Integer Validate_All_Fields_State   False
12088>>>>>        
12088>>>>>        // If true, all entry updates will occur through the DD. Else
12088>>>>>        // saves occur through the DD and find occur through the DEOs
12088>>>>>        Property Integer EntryUpdateLocalState True // changed from false to true in 17.0
12089>>>>>        
12089>>>>>        // can be used by Refind_records method (remote refind of recs). Obsolete. Use prFindRowId
12089>>>>>        Property Integer Find_Record_Id 0
12090>>>>>        
12090>>>>>        // can be used by Refind_records method (remote refind of recs)
12090>>>>>        Property RowID prFindRowId (NullRowId())
12091>>>>>        // can be used by Refind_records method (remote refind of recs)
12091>>>>>        Property tDDChangedInfo pDDChangedInfo
12092>>>>>        
12092>>>>>        // Private: Id of field_objects container. This is not created until needed
12092>>>>>        Property Integer Field_Objects 0
12093>>>>>        
12093>>>>>        // Public: If set the DDO will never be foreign, allowing
12093>>>>>        // you to create new parents when a child is saved. This would
12093>>>>>        // normally only be set within the DDO and not the class. This would be
12093>>>>>        // used where a child table wants to save the parent (header) when the
12093>>>>>        // first child is saved. It would disable the foreign key and index
12093>>>>>        // find_Req and required settings (as well as any displayonly).
12093>>>>>        Property Integer Allow_Foreign_New_Save_State False
12094>>>>>        
12094>>>>>        Set pbDDAttach to True // set false to get (very) old attach_main_file_behavior
12095>>>>>        Set pbSmartRelate to True // Only relate if parent is attached via a DDO
12096>>>>>        
12096>>>>>        // If this is an alias file, this is the master file it is based on
12096>>>>>        Property Handle piMasterTable 0
12097>>>>>        
12097>>>>>        Property tDDServerInformation[] pServerInformation
12098>>>>>        
12098>>>>>        Property tDDRemembered[] pDDDefaults
12099>>>>>        
12099>>>>>        Property Boolean pbInSuperFind False
12100>>>>>        
12100>>>>>        // Create the local buffer.
12100>>>>>        Object Record_Buffer is a cRecordBuffer
12102>>>>>        End_Object
12103>>>>>        
12103>>>>>        // Create the extended field attributes array.
12103>>>>>        Object Field_Attributes is a Field_Attributes
12105>>>>>        End_Object
12106>>>>>        
12106>>>>>        // Create an array to maintain Status help values for each field
12106>>>>>        Object Statushelp_Array is an array
12108>>>>>        End_Object
12109>>>>>        
12109>>>>>        Object FieldMask_Array is an Field_Mask_array
12111>>>>>        End_Object
12112>>>>>        
12112>>>>>        
12112>>>>>        // keep track of all system/unknown files that must be set to
12112>>>>>        // default for smart file mode to work right.
12112>>>>>        Object System_File_obj is an Array
12114>>>>>        End_Object
12115>>>>>        
12115>>>>>        // used during Request_Validate
12115>>>>>        Property Handle[] pDDsWithFindReqErrors
12116>>>>>        
12116>>>>>        // Apply SQL filters in constrained finds
12116>>>>>        Property Boolean pbUseDDSQLFilters False
12117>>>>>        // If pbUseDDSQLFilters is true, this determines if the table global filter should be applied as well
12117>>>>>        Property Boolean pbApplyGlobalSQLFilters False
12118>>>>>        // Filter which will get applied before each DDO constrained find. If "", no filter is applied
12118>>>>>        Property String psSQLFilter ""
12119>>>>>        
12119>>>>>        // Old values for SQL Filters which are pushed and popped by StoreSQLDefaultFilters and RestoreSQLDefaultFilters
12119>>>>>        Property String psOldFilter ""
12120>>>>>        Property Boolean pbOldFilterActive
12121>>>>>        Property Boolean pbOldFilterEq
12122>>>>>        
12122>>>>>        // used to point to the composite child object that provides the SQL
12122>>>>>        // interfaces for a driver. This can be used with DAW drivers. Other drivers may require
12122>>>>>        // that you sub-class your DD and create a different object based on a custom class
12122>>>>>        Property Handle phoSQLHelper (Create(Self,RefClass(cDAWSQLDriverHelper)))
12123>>>>>        
12123>>>>>        
12123>>>>>        Property Handle pbInResync False
12124>>>>>        
12124>>>>>        Property Integer piPrimaryIndex -1      // Indicates the unique index used by the webapp view state system (-1 defaults to the primary key or recnum for embedded).
12125>>>>>        
12125>>>>>        Set Smart_FileMode_State to True  // extended DSOs should default to true
12126>>>>>        
12126>>>>>        Send Define_Fields // Developer Hook - define all field rules
12127>>>>>    End_Procedure
12128>>>>>    
12128>>>>>    // Returns 1 to indicate that this is a DD class.
12128>>>>>    Function Extended_DSO_State Returns Integer
12130>>>>>        Function_Return 1
12131>>>>>    End_Function
12132>>>>>    
12132>>>>>    
12132>>>>>    // Used to set up all XDS functions and rules. Called by construct_object
12132>>>>>    // and considered a bit more user friendly.
12132>>>>>    Procedure Define_Fields
12134>>>>>    End_Procedure
12135>>>>>    
12135>>>>>    
12135>>>>>    
12135>>>>>    // This message has been augmented to create a local recordbuffer for a
12135>>>>>    // file. We cannot do this earlier because we need the file to count the
12135>>>>>    // number of necessary fields.
12135>>>>>    Procedure Set Main_File Integer iFile
12137>>>>>        Integer iCurrent_File iMaster
12137>>>>>        Get piMasterTable to iMaster
12138>>>>>        If iMaster Begin
12140>>>>>            // is an alias condition
12140>>>>>            Forward Set Main_File to iFile
12142>>>>>            Send ReDefineAliasItems to (Record_Buffer(Self)) iFile
12143>>>>>        End
12143>>>>>>
12143>>>>>        Else If iFile Begin
12146>>>>>            Get Main_File to iCurrent_File
12147>>>>>            If (iCurrent_File and iCurrent_File <> iFile) Begin
12149>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_CANNOT_CHANGE_MAIN_FILE
12150>>>>>                Procedure_Return
12151>>>>>            End
12151>>>>>>
12151>>>>>            Forward Set Main_File to iFile
12153>>>>>            Send Create_Items to (Record_Buffer(Self)) iFile
12154>>>>>            Send Create_Items to (Field_Attributes(Self))
12155>>>>>        End
12155>>>>>>
12155>>>>>    End_Procedure
12156>>>>>    
12156>>>>>    // This procedure will update the Key_Fields property to include or
12156>>>>>    // excluded the fieldnumber passed in the list of fieldnumbers which make
12156>>>>>    // up an keyvalue.
12156>>>>>    Procedure Set Key_Field_State Integer iField Integer iState
12158>>>>>        String  sKeys
12158>>>>>        Set Key_Field_State of Record_Buffer iField to iState
12159>>>>>        Get Key_Fields to sKeys
12160>>>>>        Set Key_Fields to (Overstrike(If(iState, "X", " "), sKeys, iField))
12161>>>>>    End_Procedure
12162>>>>>    
12162>>>>>    // Will return TRUE if the field passed has been defined as a key.
12162>>>>>    Function Key_Field_State Integer iField Returns Integer
12164>>>>>        Integer iState
12164>>>>>        Get Key_Field_State of Record_Buffer iField to iState
12165>>>>>        Function_Return iState
12166>>>>>    End_Function
12167>>>>>    
12167>>>>>    // Returns complete key value.
12167>>>>>    Function Key_Value Returns String
12169>>>>>        String  sKeys
12169>>>>>        String  sKey_Value
12169>>>>>        String  sValue
12169>>>>>        Integer iField
12169>>>>>        Get Key_Fields to sKeys
12170>>>>>        Move "" to sKey_Value
12171>>>>>        Repeat
12171>>>>>>
12171>>>>>            Move (Pos( "X",sKeys)) to iField
12172>>>>>            If iField Begin
12174>>>>>                Get Field_Current_Value iField to sValue
12175>>>>>                Append sKey_Value sValue
12176>>>>>                Move (Overstrike(" ", sKeys, iField)) to sKeys
12177>>>>>            End
12177>>>>>>
12177>>>>>        Until not iField
12179>>>>>        Function_Return sKey_Value
12180>>>>>    End_Function
12181>>>>>    
12181>>>>>    // This procedure will be called whenever the Data_Set changes its
12181>>>>>    // Current_Record property, or after a Save, Delete or Clear operation.
12181>>>>>    // We send this message to the Record_Buffer object to update its values.
12181>>>>>    Procedure New_Current_Record Integer iOld Integer iNew
12183>>>>>        // does nothing, but exists if developer is using this for some purpose. Is called after
12183>>>>>        // OnNewCurrentRecord (if recnum based table)
12183>>>>>    End_Procedure
12184>>>>>    
12184>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
12186>>>>>        Integer iObj
12186>>>>>        Integer iOldst
12186>>>>>        Integer iFoc
12186>>>>>        Integer iIsExt
12186>>>>>        Forward Send OnNewCurrentRecord riOld riNew
12188>>>>>        Move (Record_Buffer(Self)) to iObj
12189>>>>>        If iObj Begin
12191>>>>>            Send OnNewCurrentRecord of iObj riOld riNew
12192>>>>>            // must also refresh all defined extended fields
12192>>>>>            Send ExtendedFieldsRefresh (IsNullRowId(riNew)) // pass bCleared (true if a clear)
12193>>>>>            Get Focus of Desktop to iFoc
12194>>>>>            Get Extended_DEO_State of iFoc to iIsExt     // if focus is deo item
12195>>>>>            If iIsExt Begin                               // disable the state so
12197>>>>>                Get Entry_Refresh_State of iFoc to iOldSt // value will come
12198>>>>>                Set Entry_Refresh_State of iFoc to True   // from Local buffer.
12199>>>>>            End
12199>>>>>>
12199>>>>>            Set Existing_Key_Value to (Key_Value(Self))
12200>>>>>            If iIsExt ;                Set Entry_Refresh_State of iFoc to iOldSt
12203>>>>>            // Only set defaults when the record is new
12203>>>>>            If (IsNullRowId(riNew)) ;                Send Prepare_Default_Values
12206>>>>>        End
12206>>>>>>
12206>>>>>    End_Procedure
12207>>>>>    
12207>>>>>    // Shuts off change mode and sends initialize_default_values which is
12207>>>>>    // a user hook routine.
12207>>>>>    Procedure Prepare_Default_Values
12209>>>>>        Integer iOldState
12209>>>>>        Get Change_disabled_State to iOldState
12210>>>>>        Set Change_disabled_State to True
12211>>>>>        Send Private_Field_Defaults
12212>>>>>        // set defaults if this is the main DDO or the DDO is
12212>>>>>        // flagged as supporting saving new records when foreign (a parent)
12212>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self)) ;            Send Field_Defaults
12215>>>>>        Send AssignDynamicDefaults
12216>>>>>        Set Change_disabled_State to iOldState
12217>>>>>    End_Procedure
12218>>>>>    
12218>>>>>    // Set all checkbox fields to default to False data value.
12218>>>>>    Procedure Private_Field_Defaults
12220>>>>>        Integer iField
12220>>>>>        Repeat
12220>>>>>>
12220>>>>>            Get Next_Validation_Type of (Field_Attributes(Self)) ;                FA_VALIDATION_TYPE_CHECKBOX iField to iField
12221>>>>>            If (iField = 0) ;                Procedure_Return
12224>>>>>            Set Field_Select_State  iField to False
12225>>>>>            Set Field_Changed_State iField to True
12226>>>>>        Loop
12227>>>>>>
12227>>>>>    End_Procedure
12228>>>>>    
12228>>>>>    // Will be called after a clear operation to let the application
12228>>>>>    // programmer set the default values for the record. This should be done
12228>>>>>    // by sending SET Field_Current_Value.
12228>>>>>    Procedure Field_Defaults
12230>>>>>    End_Procedure
12231>>>>>    
12231>>>>>    // Pass type and string value and see if this is valid data for this
12231>>>>>    // type. Currently we check for numbers and dates. Return non-zero
12231>>>>>    // if invalid.
12231>>>>>    Function IsDataInvalid Integer iType String sValue Returns Integer
12233>>>>>        Date    dVal
12233>>>>>        DateTime dtVal
12233>>>>>        Number  nVal
12233>>>>>        Integer bOK
12233>>>>>        Boolean bInvalid
12233>>>>>        
12233>>>>>        Move False to bInvalid
12234>>>>>        If (iType=DF_BCD or iType=DF_DATE or iType=DF_DATETIME) Begin
12236>>>>>            If (iType=DF_DATE) Begin
12238>>>>>                MoveTrapErr sValue to dVal
12239>>>>>                Move (Err) to bInvalid
12240>>>>>            End
12240>>>>>>
12240>>>>>            Else If (iType=DF_DATETIME) Begin
12243>>>>>                MoveTrapErr sValue to dtVal
12244>>>>>                Move (Err) to bInvalid
12245>>>>>//          Move (not(IsDateValid(dtVal))) to bInvalid //jjt-uncomment when working
12245>>>>>            End
12245>>>>>>
12245>>>>>            Else Begin
12246>>>>>                MoveTrapErr sValue to nVal // this may gen an error.
12247>>>>>                Move (Err) to bInvalid
12248>>>>>            End
12248>>>>>>
12248>>>>>            Move False to Err
12249>>>>>        End
12249>>>>>>
12249>>>>>        Function_Return bInvalid
12250>>>>>    End_Function
12251>>>>>    
12251>>>>>    // Return 1 if the passed DEO is part of the DDs list of connected DEOs
12251>>>>>    // First check if server of DEO is this DD. If so, we are owned. If not
12251>>>>>    // we must check the DD's UI DEO list.
12251>>>>>    // The passed object MUST be a valid DEO or an error will occur.
12251>>>>>    Function IsDEOOwned Integer iDEO Returns Integer
12253>>>>>        Integer iMax iCount
12253>>>>>        // if DEOs server is same as current DD it is owned. This is the
12253>>>>>        // fast check
12253>>>>>        If (Server(iDEO)=Self) ;            Function_Return 1
12256>>>>>        // else see if the DEO is in the DD's DEO list
12256>>>>>        Get Data_Set_User_Interface_Count to iMax
12257>>>>>        Decrement iMax
12258>>>>>        For iCount from 0 to iMax
12264>>>>>>
12264>>>>>            If (Data_Set_User_Interface(Self,iCount)=iDEO) ;                Function_Return 1
12267>>>>>        Loop
12268>>>>>>
12268>>>>>        Function_Return 0
12269>>>>>    End_Function
12270>>>>>    
12270>>>>>    // This procedure changes the field value of the given field in the
12270>>>>>    // record-buffer object.
12270>>>>>    // It also sends Field_Value_Changed to notify every the attached DEOs.
12270>>>>>    // This has been optimized so this message is only sent when data is
12270>>>>>    // actually changed.
12270>>>>>    Procedure Set Field_Current_Value Integer iField String sValue
12272>>>>>        Integer iObj
12272>>>>>        String sOldVal
12272>>>>>        Integer iChanged
12272>>>>>        Integer iType
12272>>>>>        Integer iFile
12272>>>>>        Integer iFocObj
12272>>>>>        Integer iCrnt
12272>>>>>        Integer bInvalid
12272>>>>>        Integer iIdentity
12272>>>>>        Address pData
12272>>>>>        Integer iLen
12272>>>>>        
12272>>>>>        Get Main_File to iFile
12273>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12276>>>>>        
12276>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12276>>>>>        // that you will use the underlying fields instead
12276>>>>>        If (iType = DF_OVERLAP) Begin
12278>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12279>>>>>            Procedure_Return
12280>>>>>        End
12280>>>>>>
12280>>>>>        
12280>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
12282>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
12283>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
12284>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
12285>>>>>            // will gen error if ext. field does not exist
12285>>>>>            Set Field_Current_Pointer_Value iField iLen to pData
12286>>>>>            Procedure_Return
12287>>>>>        End
12287>>>>>>
12287>>>>>        
12287>>>>>        
12287>>>>>        // If date or number, force conversion so any error is detected before
12287>>>>>        // the buffer is updated. We don't want the record buffer to contain
12287>>>>>        // invalid data
12287>>>>>        Get IsDataInvalid iType sValue to bInvalid
12288>>>>>        If bInvalid ;         // If an error occurred we have            Procedure_Return  // a bad number or a bad date. Do no more!
12291>>>>>        
12291>>>>>        Move (Record_Buffer(Self)) to iObj
12292>>>>>        Get Value of iObj iField to sOldVal
12293>>>>>        
12293>>>>>        Set Value of iObj iField to sValue
12294>>>>>        
12294>>>>>        // Augmented to handle non DF databases JJT
12294>>>>>        // Some tables may use some field other then recnum for their record identity.
12294>>>>>        // This will be dfrecnum or some other numeric field. When this happens the DD have
12294>>>>>        // to field buffers for the same value. When an update occurs from the DD to the DB buffer
12294>>>>>        // an update can occur twice. If the values are the same, this does not matter. Else the highest
12294>>>>>        // field value will get the update (not recnum). So if someone changes recnum but not its real field
12294>>>>>        // finding may not work right. The DD is updated when a record is found and the API keeps the two values
12294>>>>>        // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
12294>>>>>        // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
12294>>>>>        // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
12294>>>>>        //
12294>>>>>        // if field is recnum and record identity is not 0, we must also update the other field.
12294>>>>>        If (iField=0) Begin
12296>>>>>            Get_Attribute DF_FILE_RECORD_IDENTITY of iFile to iIdentity
12299>>>>>            If (iIdentity>0) ;                Set Value of iObj iIdentity to sValue
12302>>>>>        End
12302>>>>>>
12302>>>>>        
12302>>>>>        // When data-sets are working they should not update the
12302>>>>>        // DEOs.
12302>>>>>        
12302>>>>>        // prior to vdf7, we stopped all operation modes of non-zero. We now allow
12302>>>>>        // validates to pass through and we have a new operation mode for this. This
12302>>>>>        // should be ok, since we already allowed navigation validation through - we just
12302>>>>>        // stopped request_validate validations.
12302>>>>>        If (Operation_Mode=0 or Operation_Mode=MODE_VALIDATING) Begin
12304>>>>>            If (iType=DF_BCD) ;                Move (Number(sValue)<>Number(sOldVal)) to iChanged
12307>>>>>            Else If (iType=DF_DATE) ;                Move (Date(sValue)<>Date(sOldVal)) to iChanged
12311>>>>>            Else If (iType=DF_DATETIME) ;                Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to iChanged
12315>>>>>            Else ;                Move (sValue<>sOldVal) to iChanged
12317>>>>>            // if changed, notify all DEOs of this change
12317>>>>>            If iChanged ;                Send Field_Value_Changed iField sValue
12320>>>>>            Else Begin
12321>>>>>                // If here the set value did not change the contents of the DD.
12321>>>>>                // However, it is possible that the current focus DEO may contain
12321>>>>>                // a different value than the one we are setting. In such a case
12321>>>>>                // we must re-synchronize the DEO. Only the one DEO can be affected
12321>>>>>                // because it is the current focus deo/item that can contain a value
12321>>>>>                // that is not yet updated in the DD. This fixes a bug where the
12321>>>>>                // iexit was setting a value which was different from what was in
12321>>>>>                // the DEO but was the same as the old DD value (iExit is called
12321>>>>>                // before the DD is re-synched with the DEO). This could happen
12321>>>>>                // also by sending this message directly with a different value in
12321>>>>>                // the DEO focus item.
12321>>>>>                Get Focus of Desktop to iFocObj
12322>>>>>                // similar logic to Get Field_Current_Value. We check that the DEO
12322>>>>>                // is extended, that entry_refresh is not disabled and that the
12322>>>>>                // DEO's server is this DD.
12322>>>>>                If ( Extended_DEO_State(iFocObj) and ;                    (Entry_Refresh_State(iFocObj)=0)) Begin
12324>>>>>                    Get Current_item of iFocObj to iCrnt
12325>>>>>                    // If Focus DEO has same file and field and it is not checkbox
12325>>>>>                    // we must set its value. Set local value directly sets the value
12325>>>>>                    // in the DEO item. If we used value we'd get recursion!
12325>>>>>                    If ( Data_File(iFocObj,iCrnt)=iFile and ;                        Data_Field(iFocObj,iCrnt)=iField and ;                        IsDEOOwned(Self,iFocObj) and ;                        Checkbox_item_State(iFocObj,iCrnt)=0 ) ;                        Send File_Field_Value_Changed to iFocObj iFile iField sValue True
12328>>>>>                    //Set Local_Value of iFocObj iCrnt to sValue
12328>>>>>                End
12328>>>>>>
12328>>>>>            End
12328>>>>>>
12328>>>>>        End
12328>>>>>>
12328>>>>>    End_Procedure
12329>>>>>    
12329>>>>>    // Sets Field_Current_Value and Sets Field_Changed_State for passed field.
12329>>>>>    Procedure Set Field_Changed_Value Integer iField String sValue
12331>>>>>        Set Field_Changed_State iField to True
12332>>>>>        Set Field_Current_Value iField to sValue
12333>>>>>    End_Procedure
12334>>>>>    
12334>>>>>    
12334>>>>>    // This should only be set by a DEO that is changing a NoPut value. This should only happen when NoEnter=F
12334>>>>>    // for indexed findable noput deos. With foreign-field noputs we may store the value and update them
12334>>>>>    // for finds but we don't want them for saves. The cDDBuffer class handles this but it needs to
12334>>>>>    // know if this was a DEO NoPut update. DDOs have always allowed you to directly update foreign NoPut
12334>>>>>    // fields when the change did not come from a DEO.
12334>>>>>    Procedure Set Field_NoPutValueChangedByDeo Integer iField Boolean bChange
12336>>>>>        Set Item_ChangedByDeo of Record_Buffer iField to bChange
12337>>>>>    End_Procedure
12338>>>>>    
12338>>>>>    Procedure Set File_Field_NoPutValueChangedByDeo Integer iFile Integer iField Boolean bChange
12340>>>>>        Integer iDSO
12340>>>>>        Get Data_set iFile to iDSO
12341>>>>>        If iDSO Begin
12343>>>>>            Set Field_NoPutValueChangedByDeo of iDSO iField to bChange
12344>>>>>        End
12344>>>>>>
12344>>>>>    End_Procedure
12345>>>>>    
12345>>>>>    // Returns the value from the record buffer for the field of which the
12345>>>>>    // fieldnumber has been passed.
12345>>>>>    // If the file/field requested is the focus file/field the use the DEO's
12345>>>>>    // value.
12345>>>>>    Function Field_Current_Value Integer iField Returns String
12347>>>>>        Integer iType
12347>>>>>        Integer iFile
12347>>>>>        String  sValue
12347>>>>>        Integer iFoc
12347>>>>>        Integer iCrnt
12347>>>>>        Integer iFldSize iVoid
12347>>>>>        UChar[] UCData
12348>>>>>        
12348>>>>>        Get Focus of desktop to iFoc
12349>>>>>        Get Main_File to iFile
12350>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12353>>>>>        
12353>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12353>>>>>        // that you will use the underlying fields instead
12353>>>>>        If (iType=DF_OVERLAP) Begin
12355>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12356>>>>>            Function_Return ''
12357>>>>>        End
12357>>>>>>
12357>>>>>        
12357>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if overlap, text or binary direct to pointer
12359>>>>>            Get Field_Current_UCAValue iField to UCData
12360>>>>>            
12360>>>>>            // we assume a string is passed here. If we return to a string the
12360>>>>>            // pointer message will convert this to a string. Check that max string
12360>>>>>            // length is not larger than Max_Argument_Size has been removed.
12360>>>>>            Move (SizeOfArray(UCData)) to iFldSize
12361>>>>>            Move (UCharArrayToString(UCData)) to sValue
12362>>>>>            // This function has always returned the value as a 0 delimited string.
12362>>>>>            // Therefore trim at first zero. This means that you should not use this method
12362>>>>>            // with Binary types as embedded zeros will cause a truncation.
12362>>>>>            Move (CString(sValue)) to sValue
12363>>>>>            Function_Return sValue
12364>>>>>        End
12364>>>>>>
12364>>>>>        
12364>>>>>        // This was extended to also make sure that the focus's server
12364>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12364>>>>>        // file/field being the right file/field but for a different view.
12364>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12364>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12364>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12364>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12364>>>>>        // DEO field, so the buffer is always correct.
12364>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12366>>>>>            Get Current_item of iFoc to iCrnt
12367>>>>>            If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;                IsDEOOwned(Self,iFoc) and ;                (Checkbox_item_State(iFoc,iCrnt)=0) ) Begin
12369>>>>>                Get Data_Value of iFoc iCrnt to sValue
12370>>>>>            End
12370>>>>>>
12370>>>>>            Else Begin
12371>>>>>                Get Value of (Record_Buffer(Self)) iField to sValue
12372>>>>>            End
12372>>>>>>
12372>>>>>        End
12372>>>>>>
12372>>>>>        Else Begin
12373>>>>>            Get Value of (Record_Buffer(Self)) iField to sValue
12374>>>>>        End
12374>>>>>>
12374>>>>>        
12374>>>>>        // cast value to the proper datatype
12374>>>>>        If (iType=DF_BCD) Begin
12376>>>>>            Function_Return (Number(sValue))
12377>>>>>        End
12377>>>>>>
12377>>>>>        Else If (iType=DF_DATE) Begin
12380>>>>>            Function_Return (Date(sValue))
12381>>>>>        End
12381>>>>>>
12381>>>>>        Else If (iType=DF_DATETIME) Begin
12384>>>>>            Function_Return (Cast(sValue,DateTime))
12385>>>>>        End
12385>>>>>>
12385>>>>>        // else return as string
12385>>>>>        Function_Return sValue
12386>>>>>    End_Function
12387>>>>>    
12387>>>>>    // This sets a default value without setting the DSO's changed_State
12387>>>>>    Procedure Set Field_Default_Value Integer iField String sValue
12389>>>>>        Integer iOldState
12389>>>>>        Get Change_disabled_State to iOldState
12390>>>>>        Set Change_disabled_State to True
12391>>>>>        Set Field_Changed_Value iField to sValue
12392>>>>>        Set Change_disabled_State to iOldState
12393>>>>>    End_Procedure
12394>>>>>    
12394>>>>>    Procedure Set File_Field_default_Value Integer iFile Integer iField String sValue
12396>>>>>        Integer iDSO
12396>>>>>        Get Data_set iFile to iDSO
12397>>>>>        If iDSO ;            Set Field_default_Value of iDSO iField to sValue
12400>>>>>    End_Procedure
12401>>>>>    
12401>>>>>    // Methods to set and get the value of a field. When set all DSOs and
12401>>>>>    // DEOs are notified.
12401>>>>>    Procedure Set File_Field_Current_Value Integer iFile Integer iField String sValue
12403>>>>>        Integer iDSO
12403>>>>>        Get Data_set iFile to iDSO
12404>>>>>        If iDSO ;            Set Field_Current_Value of iDSO iField to sValue
12407>>>>>    End_Procedure
12408>>>>>    
12408>>>>>    Procedure Set File_Field_Changed_Value Integer iFile Integer iField String sValue
12410>>>>>        Integer iDSO
12410>>>>>        Get Data_set iFile to iDSO
12411>>>>>        If iDSO ;            Set Field_Changed_Value of iDSO iField to sValue
12414>>>>>    End_Procedure
12415>>>>>    
12415>>>>>    Function File_Field_Current_Value Integer iFile Integer iField Returns String
12417>>>>>        Integer iDSO
12417>>>>>        String sValue
12417>>>>>        Get Data_set iFile to iDSO
12418>>>>>        If iDSO ;            Get Field_Current_Value of iDSO iField to sValue
12421>>>>>        Function_Return sValue
12422>>>>>    End_Function
12423>>>>>    
12423>>>>>    // This procedure will notify every attached DEO that the value of a
12423>>>>>    // field has been changed. Every DEO needs to update its value to reflect
12423>>>>>    // the new value.
12423>>>>>    Procedure Field_Value_Changed Integer iField String sValue
12425>>>>>        Integer iMax
12425>>>>>        Integer iCount
12425>>>>>        Integer iDEO
12425>>>>>        Integer iMain_File
12425>>>>>        Integer iNoChange
12425>>>>>        Get Change_Disabled_State to iNoChange
12426>>>>>        Get Main_File to iMain_File
12427>>>>>        Get Data_Set_User_Interface_Count to iMax
12428>>>>>        Decrement iMax
12429>>>>>        For iCount from 0 to iMax
12435>>>>>>
12435>>>>>            Get Data_Set_User_Interface iCount to iDEO
12436>>>>>            If (Extended_DEO_State(iDEO) ) Begin
12438>>>>>                Send File_Field_Value_Changed to iDEO iMain_File iField sValue iNoChange
12439>>>>>            End
12439>>>>>>
12439>>>>>        Loop
12440>>>>>>
12440>>>>>    End_Procedure
12441>>>>>    
12441>>>>>    // Gets/Sets Field_Changed_State of the passed field. Will Set Changed_
12441>>>>>    // state if appropriate (if change_disabled_state is false)
12441>>>>>    Function Field_Changed_State Integer iField Returns Integer
12443>>>>>        Function_Return ;            (Item_Changed_State(Record_Buffer(Self), iField))
12444>>>>>    End_Function
12445>>>>>    
12445>>>>>    
12445>>>>>    // Handle NoPut here. If the field is noput set the field_changed_State but do not set the
12445>>>>>    // DD's changed_state. As of 17.0, we changed the rule so that noput DEOs always update the DD.
12445>>>>>    // They set the field_Current_value and they set the field_changed_state. If noput they will
12445>>>>>    // not set changed_state. This now makes windows and web consistent.
12445>>>>>    Procedure Set Field_Changed_State Integer iField Integer iState
12447>>>>>        Boolean bNoPut bOldSt bIsCommitted
12447>>>>>        
12447>>>>>        Get Field_Option iField DD_NOPUT to bNoPut
12448>>>>>        If not bNoPut Begin // if not noput, see if this is a committed and therefore noput
12450>>>>>            Get IsCommitted iField to bIsCommitted
12451>>>>>            If bIsCommitted Begin
12453>>>>>                Get IsFieldCommitted iField to bNoPut
12454>>>>>            End
12454>>>>>>
12454>>>>>        End
12454>>>>>>
12454>>>>>        
12454>>>>>        If bNoPut Begin
12456>>>>>            Get Change_disabled_State to bOldSt
12457>>>>>            Set Change_disabled_State to True
12458>>>>>        End
12458>>>>>>
12458>>>>>        
12458>>>>>        Set Item_Changed_State of (Record_Buffer(Self)) iField to iState
12459>>>>>        // the cDDBuffer class item_changed_state does not attempt to set
12459>>>>>        // changed_state, so we do it here. This will allow for future
12459>>>>>        // greater flexibilities.
12459>>>>>        If (iState) Begin
12461>>>>>            Set Changed_State of (Record_Buffer(Self)) to True
12462>>>>>        End
12462>>>>>>
12462>>>>>        If bNoPut Begin
12464>>>>>            Set Change_disabled_State to bOldSt
12465>>>>>        End
12465>>>>>>
12465>>>>>        
12465>>>>>    End_Procedure
12466>>>>>    
12466>>>>>    // As above, but passes both file and field
12466>>>>>    Function File_Field_Changed_State Integer iFile Integer iField Returns Integer
12468>>>>>        Integer iDSO
12468>>>>>        Get Data_Set iFile to iDSO
12469>>>>>        If iDSO ;            Function_Return (Field_Changed_State(iDSO, iField))
12472>>>>>    End_Function
12473>>>>>    
12473>>>>>    Procedure Set File_Field_Changed_State Integer iFile Integer iField Integer iState
12475>>>>>        Integer iDSO
12475>>>>>        Get Data_Set iFile to iDSO
12476>>>>>        If iDSO ;            Set Field_Changed_State of iDSO iField to iState
12479>>>>>    End_Procedure
12480>>>>>    
12480>>>>>    // This simulates entering a value into a field from a keyboard. Pass the
12480>>>>>    // Field and DD Options and the value. It is up to you to pass the proper
12480>>>>>    // DD options. This is normally sent by File_Field_Entry and you are
12480>>>>>    // advised to use that message and not this one.
12480>>>>>    Procedure Set Field_Entry Integer iField Integer iOpts Integer bShowErr String sValue
12482>>>>>        Integer iFile
12482>>>>>        Integer iType
12482>>>>>        Integer bChanged
12482>>>>>        Integer bInvalid
12482>>>>>        Integer hObj
12482>>>>>        String sOldVal
12482>>>>>        Address pData
12482>>>>>        Integer iLen
12482>>>>>        
12482>>>>>        Get Main_File to iFile
12483>>>>>        
12483>>>>>        // if No-enter or Displayonly, this shouldn't be changed. We will
12483>>>>>        // let NoPut through, since a user might need it for finding.
12483>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
12486>>>>>        
12486>>>>>        // Force a caplsock if required
12486>>>>>        If (iOpts iand DD_CAPSLOCK) ;            Move (Uppercase(sValue)) to sValue
12489>>>>>        
12489>>>>>        // If date or number, force conversion so any error is detected before
12489>>>>>        // the buffer is updated. We don't want the record buffer to contain
12489>>>>>        // invalid data
12489>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12492>>>>>        
12492>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12492>>>>>        // that you will use the underlying fields instead
12492>>>>>        If (iType = DF_OVERLAP) Begin
12494>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12495>>>>>            Procedure_Return
12496>>>>>        End
12496>>>>>>
12496>>>>>        
12496>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
12498>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
12499>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
12500>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
12501>>>>>            // will gen error if ext. field does not exist
12501>>>>>            Set Field_Pointer_Entry iField iOpts iLen bShowErr to pData
12502>>>>>            Procedure_Return
12503>>>>>        End
12503>>>>>>
12503>>>>>        
12503>>>>>        Get IsDataInvalid iType sValue to bInvalid
12504>>>>>        If bInvalid Begin     // If an error occurred we have
12506>>>>>            If bShowErr ;                Send Data_set_error iField (If(iType=DF_DATE or iType=DF_DATETIME, DFERR_ENTER_VALID_DATE, DFERR_BAD_ENTRY)) ;                (" ("-sValue-")")
12509>>>>>            Procedure_Return  // a bad number or a bad date. Do no more!
12510>>>>>        End
12510>>>>>>
12510>>>>>        // update the value only if the value is changed.
12510>>>>>        Move (Record_Buffer(Self)) to hObj
12511>>>>>        Get Value of hObj iField to sOldVal
12512>>>>>        If (iType=DF_BCD) ;            Move (Number(sValue)<>Number(sOldVal)) to bChanged
12515>>>>>        Else If (iType=DF_DATE) ;            Move (Date(sValue)<>Date(sOldVal)) to bChanged
12519>>>>>        Else If (iType=DF_DATETIME) ;            Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to bChanged
12523>>>>>        Else ;            Move (sValue<>sOldVal) to bChanged
12525>>>>>        
12525>>>>>        // if changed or force put, update the value.
12525>>>>>        If ( bChanged or (iOpts iand DD_FORCEPUT) ) ;            Set Field_Current_Value iField to sValue
12528>>>>>        
12528>>>>>        // Set changed state if changed. This is an improvement on DEOs which would set changed-state for
12528>>>>>        // a no-put. Set Field_Changed_State will not set Changed_state if it is noput
12528>>>>>        If ( bChanged) Begin
12530>>>>>            Set Field_Changed_State iField to True
12531>>>>>            // if noput (but not noenter) we must tell the DDO that this should not be
12531>>>>>            // updated during a save.
12531>>>>>            If (iOpts iand DD_NOPUT) Begin
12533>>>>>                Set Field_NoPutValueChangedByDeo iField to True
12534>>>>>            End
12534>>>>>>
12534>>>>>        End
12534>>>>>>
12534>>>>>        
12534>>>>>        // perform autofinds if needed. Note that required checking will occur as
12534>>>>>        // part of validation.
12534>>>>>        // We will only autofind if the field value is changed. This is consistent with
12534>>>>>        // DEOs which do not autofind on unchanged values. This provides optimizations
12534>>>>>        // when a parent record is already loaded.
12534>>>>>        If (bChanged or Field_Changed_state(Self,iField)) Begin
12536>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
12536>>>>>            // testing is important and make sure we test for exact bit match. Must first
12536>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
12536>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Send File_Field_AutoFind iFile iField GE
12539>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) ;                Send File_Field_AutoFind iFile iField EQ
12543>>>>>        End
12543>>>>>>
12543>>>>>        
12543>>>>>    End_Procedure
12544>>>>>    
12544>>>>>    // This returns file-field options for a Field_Entry type of environment.
12544>>>>>    // It will strip autofind from main-file DDs but leave foreign field alone.
12544>>>>>    // This is needed for Field_entry. Otherwise adding a field value to an autofind
12544>>>>>    // for save or find causes an autofind to trigger first which either causes the
12544>>>>>    // wrong rec to save or for a double find.
12544>>>>>    Function File_Field_Entry_Options Integer iFile Integer iField Returns Integer
12546>>>>>        Integer iOpts
12546>>>>>        // this will get the appropriate field and foreign field opts
12546>>>>>        Get File_Field_Options iFile iField to iOpts
12547>>>>>        // If the main file (not foreign) we will strip autofind. Autofind should not
12547>>>>>        // be an automatic part of main file entry while it should with foreign fields.
12547>>>>>        If (iFile=Main_File(Self)) Begin
12549>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
12549>>>>>            // testing is important and make sure we test for exact bit match. Must first
12549>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
12549>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Move (iOpts - DD_AUTOFIND_GE) to iOpts
12552>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND)  ;                Move (iOpts - DD_AUTOFIND)    to iOpts
12556>>>>>        End
12556>>>>>>
12556>>>>>        Function_Return iOpts
12557>>>>>    End_Function
12558>>>>>    
12558>>>>>    // This simulates entering a value into a field from a keyboard. The DD
12558>>>>>    // receiving this message determines if it is Main or Foreign (just like
12558>>>>>    // server). It will do an uppercase, will respect No_Enter and DisplayOnly
12558>>>>>    // and will do a autofind if required. It does not do a field validation.
12558>>>>>    Procedure Set File_Field_Entry Integer iFile Integer iField Integer bShowErr String sValue
12560>>>>>        Integer iOpts
12560>>>>>        Integer hDD
12560>>>>>        Get Data_Set iFile to hDD
12561>>>>>        If hDD Begin
12563>>>>>            // this will get the appropriate field and foreign field opts
12563>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
12564>>>>>            Set Field_Entry of hDD iField iOpts bShowErr to sValue
12565>>>>>        End
12565>>>>>>
12565>>>>>    End_Procedure
12566>>>>>    
12566>>>>>    // return object ID of extended field, 0 if none
12566>>>>>    Function Field_Object Integer iField Returns Integer
12568>>>>>        Integer hoFlds hoField
12568>>>>>        Boolean bAutoAssign
12568>>>>>        Get Field_Objects to hoFlds
12569>>>>>        If hoFlds Begin
12571>>>>>            Get Field_Object of hoFlds iField to hoField
12572>>>>>        End
12572>>>>>>
12572>>>>>        If not hoField Begin
12574>>>>>            Send DefineExtendedField iField // will create field_objects and Field_Object as needed
12575>>>>>            Get Field_Objects to hoFlds
12576>>>>>            Get Field_Object of hoFlds iField to hoField
12577>>>>>        End
12577>>>>>>
12577>>>>>        Function_Return hoField
12578>>>>>    End_Function
12579>>>>>    
12579>>>>>    // This is the same as Field_entry except the value is passed via a
12579>>>>>    // pointer. If data-type is extended (text/binary) it will use and an
12579>>>>>    // extended field object to handle this. If date/number/string we will
12579>>>>>    // convert this to a string and use Field_Entry. It is the caller's
12579>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
12579>>>>>    // If an extended Field object is needed and not defined, an error is
12579>>>>>    // returned. If pointer is null, assume empty string passed (this is a
12579>>>>>    // change as of 8.3 - it used to ignore null pointers)
12579>>>>>    Procedure Set Field_Pointer_Entry Integer iField Integer iOpts Integer iLen Integer bShowErr Address pData
12581>>>>>        Integer hFld
12581>>>>>        String  sValue
12581>>>>>        Integer iFile
12581>>>>>        Integer iType
12581>>>>>        
12581>>>>>        Get Main_file to iFile
12582>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12585>>>>>        
12585>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12585>>>>>        // that you will use the underlying fields instead
12585>>>>>        If (iType = DF_OVERLAP) ;            Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_OVERLAP_ERROR
12588>>>>>        Else If (iType=DF_TEXT or iType=DF_BINARY) Begin
12591>>>>>            Get Field_Object iField to hFld // the object that handles this large text
12592>>>>>            If hFld ;                Set Field_pEntry of hFld iOpts iLen bShowErr to pData
12595>>>>>            Else ;                Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_FIELD_NOT_DEFINED
12597>>>>>        End
12597>>>>>>
12597>>>>>        Else Begin
12598>>>>>            // if number,date or string convert the pointer data to
12598>>>>>            // string data and do a normal entry with it.
12598>>>>>            Move (PointerToString(pData)) to sValue
12599>>>>>            Set Field_Entry iField iOpts bShowErr to sValue
12600>>>>>        End
12600>>>>>>
12600>>>>>    End_Procedure
12601>>>>>    
12601>>>>>    // This is the same as File_Field_entry except the value is passed via a
12601>>>>>    // pointer. See Field_Pointer_Entry for more on this
12601>>>>>    Procedure Set File_Field_Pointer_Entry Integer iFile Integer iField Integer iLen Integer bShowErr Address pData
12603>>>>>        Integer iOpts
12603>>>>>        Integer hDD
12603>>>>>        Get Data_Set iFile to hDD
12604>>>>>        If hDD Begin
12606>>>>>            // this will get the appropriate field and foreign field opts
12606>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
12607>>>>>            Set Field_Pointer_Entry of hDD iField iOpts iLen bShowErr to pData
12608>>>>>        End
12608>>>>>>
12608>>>>>    End_Procedure
12609>>>>>    
12609>>>>>    // This is the same as Field_Current_Value except the value is passed via
12609>>>>>    // a pointer. If data-type is extended (text/binary) it will use and an
12609>>>>>    // extended field object to handle this. If date/number/string we will
12609>>>>>    // convert this to a string and use Field_Entry. It is the caller's
12609>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
12609>>>>>    // If an extended Field object is needed and not defined, an error is
12609>>>>>    // returned. If pointer is null, assume empty string passed (this is a
12609>>>>>    // change as of 8.3 - it used to ignore null pointers)
12609>>>>>    Procedure Set Field_Current_Pointer_Value Integer iField Integer iLen Address pData
12611>>>>>        Integer hFld
12611>>>>>        String  sValue
12611>>>>>        Integer iFile iType iCrnt
12611>>>>>        Handle iFocObj
12611>>>>>        Boolean bChanged
12611>>>>>        
12611>>>>>        Get Main_file to iFile
12612>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12615>>>>>        
12615>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12615>>>>>        // that you will use the underlying fields instead
12615>>>>>        If (iType = DF_OVERLAP) Begin
12617>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12618>>>>>            Procedure_Return
12619>>>>>        End
12619>>>>>>
12619>>>>>        
12619>>>>>        If (iType<>DF_TEXT and iType<>DF_BINARY) Begin
12621>>>>>            // if number,date or string convert the pointer data to
12621>>>>>            // string data and do a normal entry with it.
12621>>>>>            Move (PointerToString(pData)) to sValue  // create string from pointer data
12622>>>>>            Set Field_Current_Value iField to sValue
12623>>>>>            Procedure_Return
12624>>>>>        End
12624>>>>>>
12624>>>>>        
12624>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12625>>>>>        If not hFld Begin
12627>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12628>>>>>            Procedure_Return
12629>>>>>        End
12629>>>>>>
12629>>>>>        
12629>>>>>        Get Is_pValueChanged of hFld iLen pData to bChanged
12630>>>>>        If bChanged Begin
12632>>>>>            Set Field_pValue of hFld iLen to pData
12633>>>>>            Send Field_Pointer_Value_Changed iField pData
12634>>>>>        End
12634>>>>>>
12634>>>>>        Else Begin
12635>>>>>            // If here the set value did not change the contents of the DD.
12635>>>>>            // However, it is possible that the current focus DEO may contain
12635>>>>>            // a different value than the one we are setting. In such a case
12635>>>>>            // we must re-synchronize the DEO. Only the one DEO can be affected
12635>>>>>            // because it is the current focus deo/item that can contain a value
12635>>>>>            // that is not yet updated in the DD. This fixes a bug where the
12635>>>>>            // iexit was setting a value which was different from what was in
12635>>>>>            // the DEO but was the same as the old DD value (iExit is called
12635>>>>>            // before the DD is re-synched with the DEO). This could happen
12635>>>>>            // also by sending this message directly with a different value in
12635>>>>>            // the DEO focus item.
12635>>>>>            Get Focus of Desktop to iFocObj
12636>>>>>            // similar logic to Get Field_Pointer_Current_Value. We check that the DEO
12636>>>>>            // is extended, that entry_refresh is not disabled and that the
12636>>>>>            // DEO's server is this DD.
12636>>>>>            If ( Extended_DEO_State(iFocObj) and (Entry_Refresh_State(iFocObj)=0)) Begin
12638>>>>>                // If Focus DEO has same file and field and it is not checkbox
12638>>>>>                // we must set its value. Set local value directly sets the value
12638>>>>>                // in the DEO item. If we used value we'd get recursion!
12638>>>>>                Get Current_item of iFocObj to iCrnt
12639>>>>>                If ( Data_File(iFocObj,iCrnt)=iFile and ;                    Data_Field(iFocObj,iCrnt)=iField and ;                    IsDEOOwned(Self,iFocObj) ) Begin
12641>>>>>                    Send File_Field_Pointer_Value_Changed to iFocObj iFile iField pData True
12642>>>>>                End
12642>>>>>>
12642>>>>>            End
12642>>>>>>
12642>>>>>        End
12642>>>>>>
12642>>>>>    End_Procedure
12643>>>>>    
12643>>>>>    // This is never called but it needed for the compiler. Required for apps DDs that don't compile in a DEO interface
12643>>>>>    Procedure File_Field_Pointer_Value_Changed Integer iFile Integer iField Address pValue Integer iChangeDisabled
12645>>>>>    End_Procedure
12646>>>>>    
12646>>>>>    Procedure Field_Pointer_Value_Changed Integer iField Address pValue
12648>>>>>        Integer iMax
12648>>>>>        Integer iCount
12648>>>>>        Integer iDEO
12648>>>>>        Integer iMain_File
12648>>>>>        Integer iNoChange
12648>>>>>        Get Change_Disabled_State to iNoChange
12649>>>>>        Get Main_File to iMain_File
12650>>>>>        Get Data_Set_User_Interface_Count to iMax
12651>>>>>        Decrement iMax
12652>>>>>        For iCount from 0 to iMax
12658>>>>>>
12658>>>>>            Get Data_Set_User_Interface iCount to iDEO
12659>>>>>            If (Extended_DEO_State(iDEO) ) Begin
12661>>>>>                Send File_Field_Pointer_Value_Changed to iDEO iMain_File iField pValue iNoChange
12662>>>>>            End
12662>>>>>>
12662>>>>>        Loop
12663>>>>>>
12663>>>>>    End_Procedure
12664>>>>>    
12664>>>>>    // This is the same as File_Field_Current_Value except the value is passed
12664>>>>>    // via a pointer. See Field_current_Pointer_Value for more on this
12664>>>>>    Procedure Set File_Field_Current_Pointer_Value Integer iFile Integer iField Integer iLen Address pData
12666>>>>>        Integer hDD
12666>>>>>        Get Data_Set iFile to hDD
12667>>>>>        If hDD ;            Set Field_Current_Pointer_Value of hDD iField iLen to pData
12670>>>>>    End_Procedure
12671>>>>>    
12671>>>>>    // This returns the data pointer to the extended field. At this point
12671>>>>>    // this is the data. Be careful if you change the data, be even more
12671>>>>>    // careful if you change the pointer (don't do it!!!!)
12671>>>>>    Function Field_Current_Pointer_Value Integer iField Returns Address
12673>>>>>        Integer hFld
12673>>>>>        Handle iFoc
12673>>>>>        
12673>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12674>>>>>        If not hFld Begin
12676>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12677>>>>>            Function_Return 0
12678>>>>>        End
12678>>>>>>
12678>>>>>        
12678>>>>>        
12678>>>>>        // This was extended to also make sure that the focus's server
12678>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12678>>>>>        // file/field being the right file/field but for a different view.
12678>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12678>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12678>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12678>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12678>>>>>        // DEO field, so the buffer is always correct.
12678>>>>>        Get Focus of Desktop to iFoc
12679>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12681>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
12683>>>>>                Send Update_Focus_Field
12684>>>>>            End
12684>>>>>>
12684>>>>>        End
12684>>>>>>
12684>>>>>        
12684>>>>>        Function_Return (FieldPointer(hFld))
12685>>>>>    End_Function
12686>>>>>    
12686>>>>>    
12686>>>>>    Function Field_Current_UCAValue Integer iField Returns UChar[]
12688>>>>>        Integer hFld
12688>>>>>        Handle iFoc
12688>>>>>        UChar[] Data
12689>>>>>        
12689>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12690>>>>>        If not hFld Begin
12692>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12693>>>>>            Function_Return 0
12694>>>>>        End
12694>>>>>>
12694>>>>>        
12694>>>>>        
12694>>>>>        // This was extended to also make sure that the focus's server
12694>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12694>>>>>        // file/field being the right file/field but for a different view.
12694>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12694>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12694>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12694>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12694>>>>>        // DEO field, so the buffer is always correct.
12694>>>>>        Get Focus of Desktop to iFoc
12695>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12697>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
12699>>>>>                Send Update_Focus_Field
12700>>>>>            End
12700>>>>>>
12700>>>>>        End
12700>>>>>>
12700>>>>>        Get FieldArray of hFld to Data
12701>>>>>        Function_Return Data
12702>>>>>    End_Function
12703>>>>>    
12703>>>>>    Function File_Field_Current_Pointer_Value Integer iFile Integer iField Returns Address
12705>>>>>        Address pValue
12705>>>>>        Integer hDD
12705>>>>>        Get Data_Set iFile to hDD
12706>>>>>        If hDD Begin
12708>>>>>            Get Field_Current_Pointer_Value of hDD iField to pValue // return pointer to first byte of
12709>>>>>            Function_Return pValue                                  // data
12710>>>>>        End
12710>>>>>>
12710>>>>>    End_Function
12711>>>>>    
12711>>>>>    Procedure Set Field_Current_UCAValue Integer iField UChar[] Data
12713>>>>>        Set Field_Current_Pointer_Value iField (SizeOfArray(Data)) to (AddressOf(Data))
12714>>>>>    End_Procedure
12715>>>>>    
12715>>>>>    Procedure Set File_Field_Current_UCAValue Integer iFile Integer iField UChar[] Data
12717>>>>>        Integer hDD
12717>>>>>        Get Data_Set iFile to hDD
12718>>>>>        If hDD Begin
12720>>>>>            Set Field_Current_UCAValue of hDD iField to Data
12721>>>>>        End
12721>>>>>>
12721>>>>>    End_Procedure
12722>>>>>    
12722>>>>>    Function File_Field_Current_UCAValue Integer iFile Integer iField Returns UChar[]
12724>>>>>        UChar[] UCValue
12725>>>>>        Handle hDD
12725>>>>>        Get Data_Set iFile to hDD
12726>>>>>        If hDD Begin
12728>>>>>            Get Field_Current_UCAValue of hDD iField to UCValue // return pointer to first byte of
12729>>>>>            Function_Return UCValue                              // data
12730>>>>>        End
12730>>>>>>
12730>>>>>    End_Function
12731>>>>>    
12731>>>>>    // Create an extended field object for the passed field. .
12731>>>>>    // If field already exists, do nothing. This should only be used with
12731>>>>>    // text and binary fields.
12731>>>>>    Procedure DefineExtendedField Integer iField
12733>>>>>        Integer hFlds
12733>>>>>        Get Field_Objects to hFlds // this may not be created yet.
12734>>>>>        If not hFlds Begin         // if not created, create extended-fields wrapper
12736>>>>>            Object ExtendedFieldObjects is a FieldObjects
12738>>>>>                Move Self to hFlds
12739>>>>>            End_Object
12740>>>>>            Set Field_Objects to hFlds
12741>>>>>        End
12741>>>>>>
12741>>>>>        Send DefineFieldObject to hFlds iField
12742>>>>>    End_Procedure
12743>>>>>    
12743>>>>>    // create extended DD fields for all text and binary files
12743>>>>>    Procedure DefineAllExtendedFields
12745>>>>>        Integer iCount iType iField iFile
12745>>>>>        Get Main_file to iFile
12746>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iCount
12749>>>>>        For iField from 1 to iCount
12755>>>>>>
12755>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12758>>>>>            If (iType=DF_TEXT or iType=DF_BINARY) ; // if text or binary                Send DefineExtendedField iField
12761>>>>>        Loop
12762>>>>>>
12762>>>>>    End_Procedure
12763>>>>>    
12763>>>>>    // Update Extended fields to FileBuffer.  DD-Fields ---> FileBuffer
12763>>>>>    // Private
12763>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
12765>>>>>        Integer hFlds
12765>>>>>        Get Field_Objects to hFlds
12766>>>>>        If hFlds ;            Send ExtendedFieldsUpdate to hFlds bSave
12769>>>>>    End_Procedure
12770>>>>>    
12770>>>>>    // Refresh Extended field from FileBuffer.  DD-Fields <--- FileBuffer
12770>>>>>    // Private
12770>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
12772>>>>>        Integer hFlds
12772>>>>>        Get Field_Objects to hFlds
12773>>>>>        If hFlds ;            Send ExtendedFieldsRefresh to hFlds bCleared
12776>>>>>    End_Procedure
12777>>>>>    
12777>>>>>    // This procedure can be used to set the Item_Options of a field. This can
12777>>>>>    // be passed any number of arguments.
12777>>>>>    // Support the following special first parameters:
12777>>>>>    //      DD_CLEAR_FIELD_OPTIONS     - clear all following passed otpions
12777>>>>>    //      DD_CLEAR_ALL_FIELD_OPTIONS - clear all options
12777>>>>>    Procedure Set Field_Options Integer iField Integer iArg1 // plus unknown arguments
12779>>>>>        Integer iObj
12779>>>>>        Integer iOptions
12779>>>>>        Integer iOption
12779>>>>>        Integer iArg
12779>>>>>        Integer iClear
12779>>>>>        Integer iType
12779>>>>>        Move (Record_Buffer(Self)) to iObj
12780>>>>>        Get Item_Options of iObj iField to iOptions
12781>>>>>        //
12781>>>>>        For iArg from 2 to Num_Arguments
12787>>>>>>
12787>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
12788>>>>>            
12788>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
12791>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
12795>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
12799>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
12801>>>>>        Loop
12802>>>>>>
12802>>>>>        //
12802>>>>>        //Get_Attribute DF_FIELD_TYPE of (Main_File(self)) iField to iType
12802>>>>>        //If (iType=DF_TEXT or iType=DF_BINARY) ;            // if text of binary
12802>>>>>        //    Move (iOptions iOR DD_DISPLAYONLY) to iOptions // make sure DO is set
12802>>>>>        
12802>>>>>        Set Item_Options of iObj iField to iOptions
12803>>>>>    End_Procedure
12804>>>>>    
12804>>>>>    // This function returns all the item_options which have been set for
12804>>>>>    // a field. The value from the Record_Buffer object will be binary or'ed
12804>>>>>    // with constand Default_Item_Options and the DD_AUTOCLEAR constants when
12804>>>>>    // the Autoclear_State of the field has been set.
12804>>>>>    // Keep in mind that Autoclear is *not* kept in the Item_Options
12804>>>>>    // property.
12804>>>>>    Function Field_Options Integer iField Returns Integer
12806>>>>>        Function_Return (Item_Options(Record_Buffer(Self), iField))
12807>>>>>    End_Function
12808>>>>>    
12808>>>>>    Function Field_Option Integer iField Integer iOption Returns Integer
12810>>>>>        Integer iOptions
12810>>>>>        Integer iState
12810>>>>>        Get Item_Options of (Record_Buffer(Self)) iField to iOptions
12811>>>>>        // All bits must match for it to be True (e.g., displayonly requires noput & noenter)
12811>>>>>        Move ((iOptions iand iOption)=iOption) to iState
12812>>>>>        Function_Return iState
12813>>>>>    End_Function
12814>>>>>    
12814>>>>>    
12814>>>>>    Procedure Set Foreign_Field_Options Integer iField Integer iArg1 // Integer iOption
12816>>>>>        Integer iObj
12816>>>>>        Integer iOptions
12816>>>>>        Integer iOption
12816>>>>>        Integer iArg
12816>>>>>        Integer iClear
12816>>>>>        
12816>>>>>        
12816>>>>>        Move (Record_Buffer(Self)) to iObj
12817>>>>>        Get Aux_Value of iObj iField to iOptions
12818>>>>>        //
12818>>>>>        For iArg from 2 to Num_Arguments
12824>>>>>>
12824>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
12825>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
12828>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
12832>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
12836>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
12838>>>>>        Loop
12839>>>>>>
12839>>>>>        //
12839>>>>>        Set Aux_Value of iObj iField to iOptions
12840>>>>>    End_Procedure
12841>>>>>    
12841>>>>>    Function Foreign_Field_Options Integer iField Returns Integer
12843>>>>>        Integer iOpts
12843>>>>>        Get ForeignFieldOptions of Record_Buffer iField to iOpts
12844>>>>>        Function_Return iOpts
12845>>>>>    End_Function
12846>>>>>    
12846>>>>>    Procedure Set Foreign_Field_Option Integer iField Integer iOption Integer bSet
12848>>>>>        If bSet Begin
12850>>>>>            Set Foreign_Field_Options iField to iOption
12851>>>>>        End
12851>>>>>>
12851>>>>>        Else Begin
12852>>>>>            Set Foreign_Field_Options iField to DD_CLEAR_FIELD_OPTIONS iOption
12853>>>>>        End
12853>>>>>>
12853>>>>>    End_Procedure
12854>>>>>    
12854>>>>>    Function Foreign_Field_Option Integer iField Integer iOption Returns Integer
12856>>>>>        Integer iOptions
12856>>>>>        Integer iState
12856>>>>>        Get Foreign_Field_Options iField to iOptions
12857>>>>>        Move ((iOptions iand iOption)=iOption) to iState
12858>>>>>        Function_Return iState
12859>>>>>    End_Function
12860>>>>>    
12860>>>>>    // This procedure is being used by DEOs when they need to copy the item-
12860>>>>>    // options from the Data_Set. When the filenumber being passed is not
12860>>>>>    // equal to the Main_File of this Data_Set, then the Foreign_Field_Options
12860>>>>>    // will be applied.
12860>>>>>    Function File_Field_Options Integer iFile Integer iField Returns Integer
12862>>>>>        Integer iDSO
12862>>>>>        Integer iMain_File
12862>>>>>        Integer iOpts
12862>>>>>        Integer iRB
12862>>>>>        Integer iType
12862>>>>>        Get Main_File to iMain_File
12863>>>>>        If (iFile <> iMain_File) ;            Get Data_Set iFile to iDSO
12866>>>>>        Else ;            Move Self to iDSO
12868>>>>>        If iDSO Begin
12870>>>>>            Get Field_Options of iDSO iField to iOpts
12871>>>>>            // we consider the item to be foreign if the DDO main file is different than the one
12871>>>>>            // passed and we do not allow foreign (parent) new records to be saved.
12871>>>>>            If (iFile<>iMain_File and Allow_Foreign_New_Save_State(iDSO)=0) ; // Add Foreign_Field_Options                Move (iOpts ior Foreign_Field_Options(iDSO, iField)) to iOpts
12874>>>>>            Function_Return iOpts
12875>>>>>        End
12875>>>>>>
12875>>>>>    End_Function
12876>>>>>    
12876>>>>>    
12876>>>>>    // Procedure to set the message to be sent on item entry.
12876>>>>>    Procedure Set Field_Entry_msg Integer iField Integer iMsg
12878>>>>>        Set Item_Entry_MSG of (Record_Buffer(Self)) iField to iMsg
12879>>>>>    End_Procedure
12880>>>>>    
12880>>>>>    // Function to return the message to be sent on item entry.
12880>>>>>    Function Field_Entry_msg Integer iField Returns Integer
12882>>>>>        Function_Return (Item_Entry_MSG(Record_Buffer(Self), iField))
12883>>>>>    End_Function
12884>>>>>    
12884>>>>>    
12884>>>>>    // Procedure to send the message to be sent on item exit.
12884>>>>>    Procedure Set Field_Exit_msg Integer iField Integer iMsg
12886>>>>>        Set Item_Exit_MSG of (Record_Buffer(Self)) iField to iMsg
12887>>>>>    End_Procedure
12888>>>>>    
12888>>>>>    // Function to return the message to be set on item exit.
12888>>>>>    Function Field_Exit_msg Integer iField Returns Integer
12890>>>>>        Function_Return (Item_Exit_MSG(Record_Buffer(Self), iField))
12891>>>>>    End_Function
12892>>>>>    
12892>>>>>    // Procedure to set the message to be sent on item validation.
12892>>>>>    Procedure Set Field_Validate_msg Integer iField Integer iMsg
12894>>>>>        Set Item_Validate_MSG of (Record_Buffer(Self)) iField to iMsg
12895>>>>>    End_Procedure
12896>>>>>    
12896>>>>>    // Function to return the message to be set on item validation.
12896>>>>>    Function Field_Validate_msg Integer iField Returns Integer
12898>>>>>        Function_Return (Item_Validate_MSG(Record_Buffer(Self), iField))
12899>>>>>    End_Function
12900>>>>>    
12900>>>>>    
12900>>>>>    // Used to Get/Set the Prompt_Object for a Field.
12900>>>>>    Procedure Set Field_Prompt_Object Integer iField Integer iObj
12902>>>>>        Set Prompt_Object of (Record_Buffer(Self)) iField to iObj
12903>>>>>    End_Procedure
12904>>>>>    
12904>>>>>    Function Field_Prompt_Object Integer iField Returns Integer
12906>>>>>        Integer iObj
12906>>>>>        Get Prompt_Object of (Record_Buffer(Self)) iField to iObj
12907>>>>>        If (iObj = 0) ;            Get Prompt_Object of (Field_Attributes(Self)) iField to iObj
12910>>>>>        Function_Return iObj
12911>>>>>    End_Function
12912>>>>>    
12912>>>>>    Procedure Set Field_Zoom_Object Integer iField Integer iObj
12914>>>>>        Set Zoom_Object of (Record_Buffer(Self)) iField to iObj
12915>>>>>    End_Procedure
12916>>>>>    
12916>>>>>    Function Field_Zoom_Object Integer iField Returns Integer
12918>>>>>        Function_Return (Zoom_Object(Record_Buffer(Self), iField))
12919>>>>>    End_Function
12920>>>>>    
12920>>>>>    
12920>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoObj
12922>>>>>        Set Field_WebPrompt_Object of FieldMask_Array iField to hoObj
12923>>>>>    End_Procedure
12924>>>>>    
12924>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
12926>>>>>        Handle hoPrompt
12926>>>>>        Get Field_WebPrompt_Object of FieldMask_Array iField to hoPrompt
12927>>>>>        Function_Return hoPrompt
12928>>>>>    End_Function
12929>>>>>    
12929>>>>>    
12929>>>>>    // Used to Get/Set the Prompt_Object for a Field.
12929>>>>>    Function File_Field_Prompt_Object Integer iFile Integer iField Returns Integer
12931>>>>>        Integer iObj
12931>>>>>        Get File_Field_Property iFile iField GET_Field_Prompt_Object to iObj
12932>>>>>        Function_Return iObj
12933>>>>>    End_Function
12934>>>>>    
12934>>>>>    Function File_Field_Zoom_Object Integer iFile Integer iField Returns Integer
12936>>>>>        Integer iObj
12936>>>>>        Get File_Field_Property iFile iField GET_Field_Zoom_Object to iObj
12937>>>>>        Function_Return iObj
12938>>>>>    End_Function
12939>>>>>    
12939>>>>>    Function File_Field_WebPrompt_Object Integer iFile Integer iField Returns Handle
12941>>>>>        Handle hoPrompt
12941>>>>>        Get File_Field_Property iFile iField GET_Field_WebPrompt_Object to hoPrompt
12942>>>>>        Function_Return hoPrompt
12943>>>>>    End_Function
12944>>>>>    
12944>>>>>    // Return the extended validation type for this field.
12944>>>>>    Function Field_Validation_Type Integer iField Returns Integer
12946>>>>>        Integer iType
12946>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField ;            to iType
12947>>>>>        Function_Return iType
12948>>>>>    End_Function
12949>>>>>    
12949>>>>>    // Procedure to define a valid value range for a field.
12949>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
12951>>>>>        Set Field_Value_Range of (Field_Attributes(Self)) iField ;            to sMin sMax
12952>>>>>    End_Procedure
12953>>>>>    
12953>>>>>    
12953>>>>>    // Procedure to define a validate table for a field.
12953>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
12955>>>>>        Set Field_Value_Table of (Field_Attributes(Self)) iField ;            to iObj
12956>>>>>    End_Procedure
12957>>>>>    
12957>>>>>    // This provides a callback to the calling object (iObj) by passing this
12957>>>>>    // object the message iMsg for each item in the table. Note this works for
12957>>>>>    // all extended validation types (range, check, etc.)
12957>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
12959>>>>>        Send Field_Fill_list to (Field_Attributes(Self)) ;            iField iObj iMsg
12960>>>>>    End_Procedure
12961>>>>>    
12961>>>>>    Procedure File_Field_Fill_List Integer iFile Integer iField ;            Integer iObj Integer iMsg
12963>>>>>        Integer iDSO
12963>>>>>        Get Data_set iFile to iDSO
12964>>>>>        If iDSO ;            Send Field_Fill_list to iDSO iField iObj iMsg
12967>>>>>    End_Procedure
12968>>>>>    
12968>>>>>    // Returns the ID if any of the validation table for this object.
12968>>>>>    Function Field_Table_Object Integer iField Returns Integer
12970>>>>>        Integer iRval
12970>>>>>        Get Field_Table_Object of (Field_Attributes(Self)) iField to iRVal
12971>>>>>        Function_Return iRVal
12972>>>>>    End_Function
12973>>>>>    
12973>>>>>    Function File_Field_Table_Object Integer iFile Integer iField Returns Integer
12975>>>>>        Integer iDSO
12975>>>>>        Get Data_set iFile to iDSO
12976>>>>>        If iDSO ;            Function_Return (Field_Table_Object(iDSO,iField))
12979>>>>>    End_Function
12980>>>>>    
12980>>>>>    // Returns code description value for the passed string for the
12980>>>>>    // passed validation table object. Normally use field_value_description
12980>>>>>    Function Validation_Table_Description Integer iObj String sVal Returns String
12982>>>>>        String sDesc
12982>>>>>        If iObj ;            Get Find_Code_Description of iObj sVal to sDesc
12985>>>>>        Function_Return sDesc
12986>>>>>    End_Function
12987>>>>>    
12987>>>>>    // Returns the description value for the field's code value. This only
12987>>>>>    // works if you have a validation table - else it returns the field value
12987>>>>>    Function Field_Current_Description Integer iField Returns String
12989>>>>>        String sDesc
12989>>>>>        String sVal
12989>>>>>        Integer iObj
12989>>>>>        Get Field_Current_Value iField to sVal
12990>>>>>        Get Field_Table_Object iField to iObj
12991>>>>>        If iObj Begin
12993>>>>>            Get Validation_Table_Description iObj sVal to sDesc
12994>>>>>            If (sDesc="") ;                Move sVal to sDesc // if desc is blank, use value
12997>>>>>        End
12997>>>>>>
12997>>>>>        Else ;            Move sVal to sDesc
12999>>>>>        Function_Return sDesc
13000>>>>>    End_Function
13001>>>>>    
13001>>>>>    Function File_Field_Current_Description Integer iFile Integer iField Returns String
13003>>>>>        Integer iDSO
13003>>>>>        Get Data_set iFile to iDSO
13004>>>>>        If iDSO ;            Function_Return (Field_Current_Description(iDSO,iField))
13007>>>>>    End_Function
13008>>>>>    
13008>>>>>    // Required Messaging to Support Checkbox items in DEOs
13008>>>>>    //  Defines a field as a two item field and defines True and False values
13008>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
13010>>>>>        Set Field_CheckBox_Values of (Field_Attributes(Self)) iField ;            to sTrue sFalse
13011>>>>>    End_Procedure
13012>>>>>    
13012>>>>>    //    Returns a field's select_State based on the pased value
13012>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
13014>>>>>        Function_Return (Field_Value_Select_State(Field_Attributes(Self),iField,sValue))
13015>>>>>    End_Function
13016>>>>>    
13016>>>>>    //    Returns a field's select_State based on the DD buffer contents
13016>>>>>    Function Field_Select_State Integer iField Returns Integer
13018>>>>>        String sValue
13018>>>>>        Get Field_Current_Value iField to sValue
13019>>>>>        Function_Return (Field_Value_Select_State(Self,iField,sValue))
13020>>>>>    End_Function
13021>>>>>    
13021>>>>>    //   Returns a file/field' select_State based on contents of DD buffer
13021>>>>>    Function File_Field_Select_State Integer iFile Integer iField Returns Integer
13023>>>>>        Integer iDSO
13023>>>>>        Get Data_set iFile to iDSO
13024>>>>>        If iDSO ;            Function_Return (Field_Select_State(iDSO,iField))
13027>>>>>    End_Function
13028>>>>>    
13028>>>>>    //   Returns a file/field' select_State based on passed value
13028>>>>>    Function File_Field_Value_Select_State Integer iFile Integer iField ;            String sValue Returns Integer
13030>>>>>        Integer iDSO
13030>>>>>        Get Data_set iFile to iDSO
13031>>>>>        If iDSO ;            Function_Return (Field_Value_Select_State(iDSO,iField,sValue))
13034>>>>>    End_Function
13035>>>>>    
13035>>>>>    // get the actual database value that corresponds to the boolean value
13035>>>>>    // passed.
13035>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
13037>>>>>        Function_Return (Field_Checkbox_Value(Field_Attributes(Self),iField,iState))
13038>>>>>    End_Function
13039>>>>>    
13039>>>>>    Function File_Field_CheckBox_Value Integer iFile Integer iField Integer iState Returns String
13041>>>>>        Integer iDSO
13041>>>>>        Get Data_set iFile to iDSO
13042>>>>>        If iDSO ;            Function_Return (Field_Checkbox_Value(iDSO,iField,iState))
13045>>>>>    End_Function
13046>>>>>    
13046>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
13046>>>>>    Procedure Set Field_Select_State Integer iField Integer iState
13048>>>>>        String sValue
13048>>>>>        Get Field_Checkbox_Value iField iState to sValue
13049>>>>>        Set Field_Current_Value iField to sValue
13050>>>>>    End_Procedure
13051>>>>>    
13051>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
13051>>>>>    // if needed (set Field_Current_Value does this). First finds proper file
13051>>>>>    // DSO
13051>>>>>    Procedure Set File_Field_Select_State Integer iFile Integer iField Integer iState
13053>>>>>        Integer iDSO
13053>>>>>        Get Data_set iFile to iDSO
13054>>>>>        If iDSO ;            Set Field_Select_State of iDSO iField to iState
13057>>>>>    End_Procedure
13058>>>>>    
13058>>>>>    // Procedure to define a check string for a field.
13058>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
13060>>>>>        Set Field_Value_Check of (Field_Attributes(Self)) iField ;            to sCheck
13061>>>>>    End_Procedure
13062>>>>>    
13062>>>>>    // This function will be called indirectly by DEOs when an item is being
13062>>>>>    // entered, exited or needs validation. The first argument holds the
13062>>>>>    // fieldnumber for the field and the second holds the id of the message
13062>>>>>    // which can be send to retrieve the message which needs to be send for
13062>>>>>    // this Field/Event combination. The value of the second argument can be
13062>>>>>    // GET_Field_Entry_MSG, GET_Field_Exit_MSG or GET_Field_Validate_MSG.
13062>>>>>    Function Exec_Field_Message Integer iField Integer iMsg_ID Returns Integer
13064>>>>>        Integer iMsg
13064>>>>>        Integer iResult
13064>>>>>        String  sValue
13064>>>>>        Get iMsg_ID iField to iMsg
13065>>>>>        If iMsg Begin
13067>>>>>            Get Field_Current_Value iField to sValue
13068>>>>>            Get iMsg iField sValue to iResult
13069>>>>>        End
13069>>>>>>
13069>>>>>        Function_Return iResult
13070>>>>>    End_Function
13071>>>>>    
13071>>>>>    
13071>>>>>    // This function will be called from within DEOs when an item is being
13071>>>>>    // entered, exited or needs validation. The first argument holds the
13071>>>>>    // file number, the second argument holds the field and the third
13071>>>>>    // holds the id of the message  which can be send to retrieve the message
13071>>>>>    // which needs to be send for this File/Field/Event combination.
13071>>>>>    // The value of the second argument can be  GET_Field_Entry_MSG,
13071>>>>>    // GET_Field_Exit_MSG or GET_Field_Validate_MSG.
13071>>>>>    // This will redirect to the proper data-set object.
13071>>>>>    Function Exec_File_Field_Message Integer iFile Integer iField Integer iMsg_ID Returns Integer
13073>>>>>        Integer iDSO
13073>>>>>        Integer iResult
13073>>>>>        Get Data_set iFile to iDSO
13074>>>>>        If iDSO ;            Get Exec_Field_Message of iDSO iField iMsg_ID to iResult
13077>>>>>        Function_Return iResult
13078>>>>>    End_Function
13079>>>>>    
13079>>>>>    // Find the data-set whose main_file is the same as File#. The message
13079>>>>>    // Which_data_set includes updating parent files, we will throw those out.
13079>>>>>    // This has been augmented to search down the DDO tree if we do not find
13079>>>>>    // the DD with our quick C Which_Data_set search
13079>>>>>    Function Data_Set Integer iFile Returns Integer
13081>>>>>        Integer iTmp
13081>>>>>        Integer iDSO
13081>>>>>        Get Main_File to iTmp
13082>>>>>        If (iTmp = iFile) ;            Function_Return Self
13085>>>>>        Get Which_Data_Set iFile to iDSO
13086>>>>>        If iDSO Begin
13088>>>>>            // check that DS's main-file is the File (and not a parent file)
13088>>>>>            Get Main_File of iDSO to iTmp
13089>>>>>            If (iTmp = iFile) ;                Function_Return iDSO
13092>>>>>        End
13092>>>>>>
13092>>>>>        
13092>>>>>        // This really should have succeeded by now. If not we need to do a
13092>>>>>        // downward sweep looking for DD. This will be a slower process since it
13092>>>>>        // involves flex level DDO structure traversal. We should very rarely ever
13092>>>>>        // get to this point. If we do, it takes longer!
13092>>>>>        
13092>>>>>        // Unlike other traversals we will mark and check in a single
13092>>>>>        // step.
13092>>>>>        // This Mark_Id creates a sequence Id for this clear. This way
13092>>>>>        // DSOs only get cleared one time during this process.
13092>>>>>        Send IncrementCurrentMarkId
13093>>>>>        Get Private.Data_set iFile to iDSO // this does the recursive downward search
13094>>>>>        Function_Return iDSO
13095>>>>>    End_Function
13096>>>>>    
13096>>>>>    Function Private.Data_Set Integer iFile Returns Integer
13098>>>>>        Integer iMax
13098>>>>>        Integer iDSO hDD
13098>>>>>        Integer iCount
13098>>>>>        
13098>>>>>        If (iFile=Main_file(Self)) ;            Function_Return Self
13101>>>>>        
13101>>>>>        // We are only looking at sequence ID.
13101>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
13102>>>>>        
13102>>>>>        // recurse Down first, since we already tried upward direction.
13102>>>>>        Get Data_Set_Client_Count to iMax
13103>>>>>        Decrement iMax
13104>>>>>        For iCount from 0 to iMax
13110>>>>>>
13110>>>>>            Get Data_Set_Client iCount to iDSO
13111>>>>>            // If already cleared during this sequence...do nothing
13111>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
13113>>>>>                Get Private.Data_Set of iDSO iFile to hDD
13114>>>>>                If hDD ;                    Function_Return hDD // when found...get out
13117>>>>>            End
13117>>>>>>
13117>>>>>        Loop
13118>>>>>>
13118>>>>>        // recurse up server list next. We do this 2nd because it is
13118>>>>>        // the less likely path for success.
13118>>>>>        Get Data_Set_Server_Count to iMax
13119>>>>>        Decrement iMax
13120>>>>>        For iCount from 0 to iMax
13126>>>>>>
13126>>>>>            Get Data_Set_Server iCount to iDSO
13127>>>>>            // If already cleared during this sequence...do nothing
13127>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
13129>>>>>                Get Private.Data_Set of iDSO iFile to hDD
13130>>>>>                If hDD ;                    Function_Return hDD // when found...get out
13133>>>>>            End
13133>>>>>>
13133>>>>>        Loop
13134>>>>>>
13134>>>>>        Function_Return 0 // if here, our traversal has failed.
13135>>>>>    End_Function
13136>>>>>    
13136>>>>>    // These methods can be used to set/get a field property in a flexible
13136>>>>>    // way. The first two argument are the file- and fieldnumber followed by
13136>>>>>    // the ID of the message that should be send. The last argument should
13136>>>>>    // be the value to set or the variable to store the value in.
13136>>>>>    Procedure Set File_Field_Property Integer iFile Integer iField Integer iMsg String sValue
13138>>>>>        Integer iDSO
13138>>>>>        Get Data_Set iFile to iDSO
13139>>>>>        If iDSO Begin
13141>>>>>            Set iMsg of iDSO iField to sValue
13142>>>>>            Procedure_Return sValue
13143>>>>>        End
13143>>>>>>
13143>>>>>    End_Procedure
13144>>>>>    
13144>>>>>    Function File_Field_Property Integer iFile Integer iField Integer iMsg Returns Integer
13146>>>>>        Integer iDSO
13146>>>>>        String  sValue
13146>>>>>        Get Data_Set iFile to iDSO
13147>>>>>        If iDSO Begin
13149>>>>>            Get iMsg of iDSO iField to sValue
13150>>>>>            Function_Return sValue
13151>>>>>        End
13151>>>>>>
13151>>>>>    End_Function
13152>>>>>    
13152>>>>>    // This procedure will return the number of fields in the object
13152>>>>>    Function Field_Count Returns Integer
13154>>>>>        Function_Return (Item_Count(Record_Buffer(Self)) - 1)
13155>>>>>    End_Function
13156>>>>>    
13156>>>>>    // This procedure will clear all flags in the visited_fields string so
13156>>>>>    // that all field will be validated on the next requests.
13156>>>>>    Procedure Clear_Visited_Fields
13158>>>>>        // this clears field visitation marks
13158>>>>>        Set Visited_Fields to (Repeat(" ", Field_Count(Self)))
13159>>>>>    End_Procedure
13160>>>>>    
13160>>>>>    // Private.Initialize_Visited
13160>>>>>    // This procedure will be called when validations (and perhaps other
13160>>>>>    // events) is requested. It clears the visited marks and then proceeds
13160>>>>>    // to clear the marks up the server tree.
13160>>>>>    // This is passed two parameters: Up_and_down, If true upward and downward
13160>>>>>    // initialize. If Clear_Fields also clear the field string
13160>>>>>    Procedure Private.Initialize_Visited Integer Up_and_Down Integer Clear_Fields
13162>>>>>        Integer iMax
13162>>>>>        Integer iDSO
13162>>>>>        Integer iCount
13162>>>>>        
13162>>>>>        // recurse up server list first. Only recurse up
13162>>>>>        Get Data_Set_Server_Count to iMax
13163>>>>>        Decrement iMax
13164>>>>>        For iCount from 0 to iMax
13170>>>>>>
13170>>>>>            Get Data_Set_Server iCount to iDSO
13171>>>>>            // If already cleared during this sequence...do nothing
13171>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                Send Private.Initialize_Visited to iDSO False Clear_Fields
13174>>>>>        Loop
13175>>>>>>
13175>>>>>        
13175>>>>>        If Clear_Fields ;            Send Clear_Visited_Fields // clear all markers in this object
13178>>>>>        // this clears the visited mark for the entire object
13178>>>>>        Set Visited_State to False
13179>>>>>        Set DownDelete_State to False
13180>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
13181>>>>>        
13181>>>>>        // If Up_and_Down recurse Down server list
13181>>>>>        If Up_and_Down Begin
13183>>>>>            Get Data_Set_Client_Count to iMax
13184>>>>>            Decrement iMax // **EK** This line was missing
13185>>>>>            For iCount from 0 to iMax
13191>>>>>>
13191>>>>>                Get Data_Set_Client iCount to iDSO
13192>>>>>                // If already cleared during this sequence...do nothing
13192>>>>>                If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                    Send Private.Initialize_Visited to iDSO True Clear_Fields
13195>>>>>            Loop
13196>>>>>>
13196>>>>>        End
13196>>>>>>
13196>>>>>    End_Procedure
13197>>>>>    
13197>>>>>    
13197>>>>>    // Clears Visited marks and (maybe) field visited marks in all required
13197>>>>>    // DSOs. If Up_and_Down is TRUE DSOs are marked up and Down (delete style)
13197>>>>>    // propagation. If False, DSOs are marked up (save style). This does not
13197>>>>>    // have a mode to mark ALL DSOs in a structure. (Not needed so far).
13197>>>>>    // If Clear_Fields is T the field string marker is also cleared.
13197>>>>>    // The method of using the global integer DD_Current_Mark_ID is an opt-
13197>>>>>    // imizer. This is private - do not tamper with it!
13197>>>>>    // Note that Intialize_Visited does not always Clear all DDOs in the structure. When
13197>>>>>    // Up_and_Down is true, it is marking all DDOs that will participate in a cascade delete
13197>>>>>    // which may not be all DDOs in the structure. If you want to initialize all DDOs use InitializeAllVisited
13197>>>>>    Procedure Initialize_Visited Integer Up_and_Down Integer Clear_Fields
13199>>>>>        Send IncrementCurrentMarkId
13200>>>>>        Send Private.Initialize_Visited Up_and_Down Clear_Fields
13201>>>>>    End_Procedure
13202>>>>>    
13202>>>>>    Procedure InitializeAllVisited2
13204>>>>>        Integer iMax iCount
13204>>>>>        Handle hoDSO
13204>>>>>        
13204>>>>>        Set Visited_State to False
13205>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id // marks this as visited
13206>>>>>        
13206>>>>>        // recurse up server list.
13206>>>>>        Get Data_Set_Server_Count to iMax
13207>>>>>        For iCount from 0 to (iMax-1)
13213>>>>>>
13213>>>>>            Get Data_Set_Server iCount to hoDSO
13214>>>>>            // If already cleared during this sequence...do nothing
13214>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 of hoDSO
13217>>>>>        Loop
13218>>>>>>
13218>>>>>        
13218>>>>>        // recurse down client list.
13218>>>>>        Get Data_Set_Client_Count to iMax
13219>>>>>        For iCount from 0 to (iMax-1)
13225>>>>>>
13225>>>>>            Get Data_Set_Client iCount to hoDSO
13226>>>>>            // If already cleared during this sequence...do nothing
13226>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 to hoDSO
13229>>>>>        Loop
13230>>>>>>
13230>>>>>    End_Procedure
13231>>>>>    
13231>>>>>    // clears visited flag for *all* ddos in the structure.
13231>>>>>    Procedure InitializeAllVisited
13233>>>>>        Send IncrementCurrentMarkId
13234>>>>>        Send InitializeAllVisited2
13235>>>>>    End_Procedure
13236>>>>>    
13236>>>>>    
13236>>>>>    // Internal recursive message to check file connections. Called from
13236>>>>>    // Valid_connections only. Private message
13236>>>>>    Function Private.Valid_Structure Integer Up_And_Down Returns Integer
13238>>>>>        Integer iRval iCount iMax
13238>>>>>        Handle iDSO iPDSO
13238>>>>>        Integer iPMax iPCount iPMain
13238>>>>>        Boolean bUpDown bNull bCascadeNull bDown
13238>>>>>        
13238>>>>>        // Check Current Connections
13238>>>>>        Get Valid_Servers to iRval           // always check servers
13239>>>>>        If (iRval=0 and Up_and_Down) ;       // check Clients if required            Get Valid_Clients to iRval
13242>>>>>        Set Visited_State to True
13243>>>>>        
13243>>>>>        // Ask Server data-sets to check their server connections
13243>>>>>        If not iRval Begin // check up
13245>>>>>            Get Data_Set_Server_Count to iMax
13246>>>>>            Decrement iMax
13247>>>>>            For iCount from 0 to iMax
13253>>>>>>
13253>>>>>                Get Data_Set_Server iCount to iDSO
13254>>>>>                If not (Visited_state(iDSO)) ;                    Get Private.Valid_Structure of iDSO False to iRVal
13257>>>>>            Until iRval
13259>>>>>        End
13259>>>>>>
13259>>>>>        
13259>>>>>        // If required, Ask Clients to check their server and client connections
13259>>>>>        //
13259>>>>>        If (iRval=0 and Up_and_Down) Begin // check down
13261>>>>>            Get Data_Set_Client_Count to iMax
13262>>>>>            Decrement iMax
13263>>>>>            For iCount from 0 to iMax
13269>>>>>>
13269>>>>>                Get Data_Set_Client iCount to iDSO
13270>>>>>                If not (Visited_state(iDSO)) Begin
13272>>>>>                    Get Data_Set_Server_Count of iDSO to iPMax
13273>>>>>                    // test if all deletable parents for a non parent null allowed/cascade delete null
13273>>>>>                    For iPCount from 0 to (iPMax-1)
13279>>>>>>
13279>>>>>                        Get Data_Set_Server of iDSO iPCount to iPDSO
13280>>>>>                        Get DownDelete_State of iPDSO to bDown
13281>>>>>                        If (bDown) Begin
13283>>>>>                            Get Main_File of iPDSO to iPMain
13284>>>>>                            Get IsNullParentAllowed of iDSO iPMain to bNull
13285>>>>>                            Get IsCascadeDeleteNull of iDSO iPMain to bCascadeNull
13286>>>>>                            Move (not(bNull) or not(bCascadeNull)) to bUpDown
13287>>>>>                        End
13287>>>>>>
13287>>>>>                    Until bUpDown
13289>>>>>                    Get Private.Valid_Structure of iDSO bUpDown to iRVal
13290>>>>>                End
13290>>>>>>
13290>>>>>            Until iRval
13292>>>>>        End
13292>>>>>>
13292>>>>>        
13292>>>>>        Function_Return iRVal
13293>>>>>        
13293>>>>>    End_Function
13294>>>>>    
13294>>>>>    // Validate data-set updating connections against required connections
13294>>>>>    // Pass: Up_and_down=T if we should check Server and Client connections
13294>>>>>    //                  =F is we only check servers
13294>>>>>    // Ret: 0 if ok, Missing File# if not ok.
13294>>>>>    // Up_And_Down should be true when testing for cascade delete structures and
13294>>>>>    // false when testing for save / delete-no-cascade structures
13294>>>>>    Function Valid_Structure Integer Up_And_Down Returns Integer
13296>>>>>        Send Initialize_Visited Up_and_Down False // False=don't clear field marks
13297>>>>>        If (Up_And_Down) Begin
13299>>>>>            Send MarkDDOsForCascadeDelete
13300>>>>>        End
13300>>>>>>
13300>>>>>        Function_Return (Private.Valid_Structure(Self,Up_and_Down))
13301>>>>>    End_Function
13302>>>>>    
13302>>>>>    // mark all DDOs which are part of this deletes cascade delete tree
13302>>>>>    // mark this and all clients as Downward deletable. This includes
13302>>>>>    // cacscade delete and cascade set to null (not for cascade_delete_state=F)
13302>>>>>    Procedure MarkDDOsForCascadeDelete
13304>>>>>        Integer iMax  iCount
13304>>>>>        Boolean bDown
13304>>>>>        Handle hoDDO
13304>>>>>        Set DownDelete_State to True
13305>>>>>        Get Data_Set_Client_Count to iMax
13306>>>>>        For iCount from 0 to (iMax-1)
13312>>>>>>
13312>>>>>            Get Data_Set_Client iCount to hoDDO
13313>>>>>            Get DownDelete_State of hoDDO to bDown
13314>>>>>            If not bDown Begin // circular DDO test - never do this
13316>>>>>                Send MarkDDOsForCascadeDelete of hoDDO
13317>>>>>            End
13317>>>>>>
13317>>>>>        Loop
13318>>>>>>
13318>>>>>    End_Procedure
13319>>>>>    
13319>>>>>    
13319>>>>>    // This function will execute the validation message for each field within
13319>>>>>    // this object. If DoAllFG is true all items are validated. If false
13319>>>>>    // only unvisited items are checked.
13319>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
13319>>>>>    // do something with the possible cascade of errors
13319>>>>>    // if the err returns DFERR_ENTER_VALID_REC_ID we will not continue
13319>>>>>    // the validation (the other fields will be bad). This works best if the
13319>>>>>    // findreq appears as one of the first fields in the file (which is almost
13319>>>>>    // always the case
13319>>>>>    Function Validate_Fields Integer DoAllFg Integer bNoStop Returns Integer
13321>>>>>        Integer iRetval
13321>>>>>        Integer iMax
13321>>>>>        Integer iCount
13321>>>>>        Integer iFile
13321>>>>>        Integer iErr
13321>>>>>        String  sVS
13321>>>>>        Get Visited_Fields to sVS
13322>>>>>        Get Field_Count to iMax
13323>>>>>        Get Main_File to iFile
13324>>>>>        For iCount from 1 to iMax
13330>>>>>>
13330>>>>>            If (DoAllFG or Mid(sVS, 1, iCount)=" ") Begin
13332>>>>>                Get Validate_Field iCount to iErr
13333>>>>>                If iErr Begin
13335>>>>>                    Move iErr to iRetVal
13336>>>>>                    // error occurred. If not no-stop or the error is
13336>>>>>                    // a findreq error - we are done.
13336>>>>>                    If (not(bNoStop) or iRetVal=DFERR_ENTER_VALID_REC_ID) ;                        Function_Return iRetVal
13339>>>>>                End
13339>>>>>>
13339>>>>>            End
13339>>>>>>
13339>>>>>        Loop
13340>>>>>>
13340>>>>>        Function_Return iRetval
13341>>>>>    End_Function
13342>>>>>    
13342>>>>>    // 17.0 - added support for null-parents. If null parents allowed, req lets it through
13342>>>>>    Function Validate_Required Integer iField Returns Integer
13344>>>>>        Boolean bNull bErr
13344>>>>>        
13344>>>>>        Move (trim(Field_Current_Value(Self,iField))='') to bErr
13345>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTRY_REQUIRED ""
13348>>>>>        Function_Return bErr
13349>>>>>    End_Function
13350>>>>>    
13350>>>>>    // return true if we should skip validation for this field. This can happen with Null allowed parents.
13350>>>>>    // if this is foreign, new and has no changes and is null allowed we will skip.
13350>>>>>    Function SkipValidate Integer iField Returns Boolean
13352>>>>>        Boolean bSkip bFieldChanged bEmpty
13352>>>>>        String sValue
13352>>>>>        
13352>>>>>        If (OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(changed_state(Self))) Begin
13354>>>>>            // We must also check field_changed_state and only skip if this is not changed.
13354>>>>>            Get Field_Changed_State iField to bFieldChanged
13355>>>>>            // Retain and remember may set field_changed_state to true even when empty. If this field is changed
13355>>>>>            // but its value is empty we assume it is a candidate for Null checking, so we will set field-changed to false
13355>>>>>            If bFieldChanged Begin
13357>>>>>                Get Field_Current_Value iField to sValue
13358>>>>>                Get IsEmptyField iField sValue to bEmpty
13359>>>>>                If bEmpty Begin
13361>>>>>                    Move False to bFieldChanged
13362>>>>>                End
13362>>>>>>
13362>>>>>            End
13362>>>>>>
13362>>>>>            If (not(bFieldChanged)) Begin
13364>>>>>                // we must find the child that points to this DD, starting with operation_origin. If a child
13364>>>>>                // is found, it will be in array position 1 (0 is self, 1 is child)
13364>>>>>                Get IsNullParentOrAncestor to bSkip
13365>>>>>            End
13365>>>>>>
13365>>>>>        End
13365>>>>>>
13365>>>>>        Function_Return bSkip
13366>>>>>    End_Function
13367>>>>>    
13367>>>>>    
13367>>>>>    // This will tell us if this DD can be treated as either a null parent
13367>>>>>    // or an ancestor of a null parent. This should only be called for a DD
13367>>>>>    // that is a candidate for this meaning that it does not have a change.
13367>>>>>    // We will test if its child allows this parent to be null or if this
13367>>>>>    // is in the path of an allowed null parent. We assume that parents of
13367>>>>>    // null parents will also be null. This is used to test if validations are
13367>>>>>    // needed.
13367>>>>>    Function IsNullParentOrAncestor Returns Boolean
13369>>>>>        Handle[] hoDDs
13370>>>>>        Integer i iSize iMain
13370>>>>>        Boolean bNullAllowed
13370>>>>>        // gets an array where 0 is self, 1 is parent, 2 is grandparent, and the
13370>>>>>        // last item is the operation_origin.
13370>>>>>        Send DDOServerPath of operation_origin Self (&hoDDs)
13371>>>>>        Move (SizeOfArray(hoDDs)) to iSize
13372>>>>>        If (iSize) Begin
13374>>>>>            // see if the immediate child allows this to be null.
13374>>>>>            Get Main_File to iMain
13375>>>>>            Get IsNullParentAllowed of hoDDs[1] iMain to bNullAllowed
13376>>>>>            
13376>>>>>            // if null not allowed, see if this is an ancestor to a null allowed
13376>>>>>            // parent where all DDs in this path are unchanged. For example:
13376>>>>>            // G.DD <- P.DD <- C.DD where we C.DD allows P.DD to be null and we
13376>>>>>            // want to test if G.DD needs validation
13376>>>>>            Move 1 to i
13377>>>>>            While (not(bNullAllowed) and (i+1<iSize) and not(changed_state(hoDDs[i])) )
13381>>>>>                Get Main_File of hoDDs[i] to iMain
13382>>>>>                Get IsNullParentAllowed of hoDDs[i+1] iMain to bNullAllowed
13383>>>>>                Increment i
13384>>>>>            Loop
13385>>>>>>
13385>>>>>            
13385>>>>>        End
13385>>>>>>
13385>>>>>        Function_Return bNullAllowed
13386>>>>>    End_Function
13387>>>>>    
13387>>>>>    
13387>>>>>    Function Validate_FindReq Integer iField Returns Integer
13389>>>>>        Integer bErr iOpts
13389>>>>>        // if no current record, we have not found the required record.
13389>>>>>        Move (not(HasRecord(Self))) to bErr
13390>>>>>        // We also need to check if the field is changed. If the field is changed and this
13390>>>>>        // is an autofind field, this indicates that an autofind was attempted and failed. We
13390>>>>>        // can't jut rely on current_record because a failed autofind restores the old current
13390>>>>>        // record. For this to work, DEOs must set the DD field's changed_state to true on
13390>>>>>        // no-put fields (dd_deomx.pkg was changed to do this).
13390>>>>>        If (not(bErr) and field_changed_state(Self,iField)) Begin
13392>>>>>            Get Field_Options iField to iOpts
13393>>>>>            Move ( ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) or ;                ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ) ;                to bErr
13394>>>>>        End
13394>>>>>>
13394>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTER_VALID_REC_ID ""
13397>>>>>        Function_Return bErr
13398>>>>>    End_Function
13399>>>>>    
13399>>>>>    // This function will be called to validate a field.
13399>>>>>    // mark field currently being validated
13399>>>>>    // Altered to Check DD options (required, findreq)
13399>>>>>    Function Validate_Field Integer iField Returns Integer
13401>>>>>        Integer iResult
13401>>>>>        Integer iMsg
13401>>>>>        Integer iObj
13401>>>>>        String  sValue
13401>>>>>        Integer iFile
13401>>>>>        Integer iOpts iMain
13401>>>>>        Boolean bSkipValidate
13401>>>>>        Handle[] hoDDs
13402>>>>>        
13402>>>>>        Set Current_Validate_Field to iField
13403>>>>>        
13403>>>>>        // test if we should skip validation on this field
13403>>>>>        Get SkipValidate iField to bSkipValidate
13404>>>>>        
13404>>>>>        If (not(bSkipValidate)) Begin
13406>>>>>            
13406>>>>>            Move (Record_Buffer(Self)) to iObj
13407>>>>>            Get Main_File to iFile
13408>>>>>            
13408>>>>>            // Check for DD option failures: required, find_required
13408>>>>>            // "File_field" gets regular and foreign fields as needed
13408>>>>>            //Get File_Field_Options iFile iField to iOpts
13408>>>>>            Get Field_Options iField to iOpts  // get reg options
13409>>>>>            // if this is not the DDO that started the validation, we will assume that
13409>>>>>            // this is foreign. Operation_origin is set in Request_Validate
13409>>>>>            // If foreign (as defined above) and we do not allow new saves when
13409>>>>>            // foreign, we will consider this to be foreign and add foreign options
13409>>>>>            If (Operation_Origin<>Self and ;                Allow_Foreign_New_Save_State(Self)=0)  ;                Move (iOpts ior Foreign_Field_Options(Self, iField)) to iOpts
13412>>>>>            
13412>>>>>            
13412>>>>>            // Check for FindReq first. If it fails, set iResult to DFERR_ENTER_VALID_REC_ID so
13412>>>>>            // the calling function knows that a findreq failed. Always do this validation first
13412>>>>>            If (iOpts iand DD_FINDREQ) ;                Get Validate_FindReq  iField to iResult
13415>>>>>            If iResult Begin
13417>>>>>                Send AddDDHasFindReqError
13418>>>>>                Move DFERR_ENTER_VALID_REC_ID to iResult
13419>>>>>            End
13419>>>>>>
13419>>>>>            Else Begin
13420>>>>>                
13420>>>>>                If (iOpts iand DD_REQUIRED) ;                    Get Validate_Required iField to iResult
13423>>>>>                
13423>>>>>                If (iResult=0) Begin
13425>>>>>                    // First execute the user defined validation message
13425>>>>>                    Get Item_Validate_MSG of iObj iField to iMsg
13426>>>>>                    If iMsg Begin
13428>>>>>                        Get Field_Current_Value iField to sValue
13429>>>>>                        Get iMsg iField sValue to iResult
13430>>>>>                    End
13430>>>>>>
13430>>>>>                End
13430>>>>>>
13430>>>>>                
13430>>>>>                // Check for keys
13430>>>>>                If (iResult=0 and Key_Field_State(Self, iField)) ;                    Get Validate_Key_Field iField to iResult
13433>>>>>                
13433>>>>>                // Do extended validations
13433>>>>>                If (iResult=0) ;                    Get Validate_Field of (Field_Attributes(Self)) iField to iResult
13436>>>>>            End
13436>>>>>>
13436>>>>>        End
13436>>>>>>
13436>>>>>        
13436>>>>>        Set Current_Validate_Field to 0
13437>>>>>        // Mark this field being validated
13437>>>>>        Get Visited_Fields to sValue
13438>>>>>        Set Visited_Fields to (Overstrike("X", sValue, iField))
13439>>>>>        
13439>>>>>        Function_Return iResult
13440>>>>>        
13440>>>>>    End_Function
13441>>>>>    
13441>>>>>    
13441>>>>>    // This function will be called to validate a field.
13441>>>>>    Function File_Field_Validate_Field Integer iFile Integer iField Returns Integer
13443>>>>>        Integer iDSO
13443>>>>>        Integer iResult
13443>>>>>        Integer hOldOrigin
13443>>>>>        Get Data_Set iFile to iDSO
13444>>>>>        If not iDSO ;            Function_Return 0
13447>>>>>        
13447>>>>>        // This function is only called by the DEOs.
13447>>>>>        // It is possible for validate_item when called as part of
13447>>>>>        // request_validate to get called more than once
13447>>>>>        // when a field is foreign (it is attached to both its DDO and the
13447>>>>>        // child-main ddo). This makes sure the validation is only called once.
13447>>>>>        // (vdf7 change: previously we set OpMode to Mode_Saving and checked that, now we have
13447>>>>>        // a mode just for request_validate).
13447>>>>>        If (Operation_Mode=MODE_VALIDATING and ;         // if from request_validate            Mid(Visited_Fields(iDSO), 1, iField)="X" ) ; // and already marked            Function_Return 0                         // skip it
13450>>>>>        
13450>>>>>        Move Operation_origin to hOldOrigin
13451>>>>>        
13451>>>>>        // if from request_validate operation_origin will be set and should not
13451>>>>>        // be reset here.
13451>>>>>        If (OPERATION_ORIGIN=0) Begin
13453>>>>>            Move Self to Operation_Origin
13454>>>>>        End
13454>>>>>>
13454>>>>>        
13454>>>>>        Get Validate_Field of iDSO iField to iResult
13455>>>>>        Move hOldOrigin to Operation_Origin
13456>>>>>        Function_Return iResult
13457>>>>>    End_Function
13458>>>>>    
13458>>>>>    // This function will be called to check if a key has been changed.
13458>>>>>    Function Validate_Key_Field Integer iField Returns Integer
13460>>>>>        String  sOld_Value
13460>>>>>        String  sNew_Value
13460>>>>>        String  sKeys
13460>>>>>        Integer iState
13460>>>>>        Boolean bMultiKeys
13460>>>>>        Get Protect_Key_State to iState
13461>>>>>        If iState Begin
13463>>>>>            Get Key_Value to sNew_Value
13464>>>>>            // Only check existing records.
13464>>>>>            If (HasRecord(Self)) Begin
13466>>>>>                Get Existing_Key_Value to sOld_Value
13467>>>>>                If (sNew_Value <> sOld_Value) Begin
13469>>>>>                    // we have an error. If there is only one key field we know
13469>>>>>                    // where the field is and we can report that field. If we have
13469>>>>>                    // multiple key fields, we don't really know where the offending key change
13469>>>>>                    // is, so we will not report a field.
13469>>>>>                    Get Key_Fields to sKeys
13470>>>>>                    Move (Pos("X",sKeys)<>RightPos("X",sKeys)) to bMultiKeys
13471>>>>>                    Send Data_set_Error (If(bMultiKeys, -1, iField)) 0 DD_TEXT_NO_KEY_CHANGE_ALLOWED
13472>>>>>                    Function_Return 1
13473>>>>>                End
13473>>>>>>
13473>>>>>            End
13473>>>>>>
13473>>>>>        End
13473>>>>>>
13473>>>>>    End_Function
13474>>>>>    
13474>>>>>    
13474>>>>>    // During request_validate process tell us if this DD has had a find_request error. This
13474>>>>>    // is handled by the DD that originated the request_validate. Very private
13474>>>>>    Function DDHasFindReqError Returns Boolean
13476>>>>>        Handle[] DDsWithFindReqErrors
13477>>>>>        Integer iIndex
13477>>>>>        If (OPERATION_ORIGIN) Begin
13479>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13480>>>>>            Move (SearchArray(Self,DDsWithFindReqErrors)) to iIndex
13481>>>>>            Function_Return (iIndex<>-1)
13482>>>>>        End
13482>>>>>>
13482>>>>>    End_Function
13483>>>>>    
13483>>>>>    // During a request_validate a find_request error has occurred. Add this DD
13483>>>>>    // to list of DDs that have this error. This is handled by the DD that
13483>>>>>    // originated the request_validate.  Very private
13483>>>>>    Procedure AddDDHasFindReqError
13485>>>>>        Handle[] DDsWithFindReqErrors
13486>>>>>        If (OPERATION_ORIGIN) Begin
13488>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13489>>>>>            Move Self to DDsWithFindReqErrors[SizeOfArray(DDsWithFindReqErrors)]
13490>>>>>            Set pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13491>>>>>        End
13491>>>>>>
13491>>>>>    End_Procedure
13492>>>>>    
13492>>>>>    // This function will execute the validation message for each field of the
13492>>>>>    // data set and all of its parents in parent first order.
13492>>>>>    // Pass: DoALLFg bNoStop
13492>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
13492>>>>>    // do something with the possible cascade of errors
13492>>>>>    Function Validate_Data_Sets Integer DoAllFg Integer bNoStop Returns Integer
13494>>>>>        Integer iDSO
13494>>>>>        Integer iRetval
13494>>>>>        Integer iCount
13494>>>>>        Integer iMax
13494>>>>>        Integer bErr
13494>>>>>        Boolean bDDHasFindReqError
13494>>>>>        // ShowLn "Validate_Data_Sets in Data_Set in " (Name(self))
13494>>>>>        // Validate if not foreign, or foreign new saves allowed, or
13494>>>>>        // foreign validation is supported (it normally is)
13494>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self) or ;            Validate_Foreign_File_State(Self)) Begin
13496>>>>>            
13496>>>>>            If (bNoStop) Begin
13498>>>>>                // if do all, it is possible that this DD as a find-req error. If so there is no
13498>>>>>                // need to look for more errors in this DD or its parents. This makes the do all checking
13498>>>>>                // a little more intelligent and doesn't return a bunch of errors when it is not needed
13498>>>>>                Get DDHasFindReqError to bDDHasFindReqError
13499>>>>>            End
13499>>>>>>
13499>>>>>            
13499>>>>>            If (not(bDDHasFindReqError)) Begin
13501>>>>>                Get Data_Set_Server_Count to iMax
13502>>>>>                Decrement iMax
13503>>>>>                For iCount from 0 to iMax
13509>>>>>>
13509>>>>>                    Get Data_Set_Server iCount to iDSO
13510>>>>>                    If not (Visited_state(iDSO)) Begin
13512>>>>>                        Get Validate_Data_Sets of iDSO DoAllFg bNoStop to bErr
13513>>>>>                        If bErr Begin
13515>>>>>                            Move bErr to iRetVal
13516>>>>>                            If bNoStop ;                                Move 0 to bErr
13519>>>>>                        End
13519>>>>>>
13519>>>>>                    End
13519>>>>>>
13519>>>>>                Until bErr
13521>>>>>                If not bErr Begin
13523>>>>>                    Get Validate_Fields DoAllFg bNoStop to bErr
13524>>>>>                    If bErr ;                        Move bErr to iRetVal
13527>>>>>                End
13527>>>>>>
13527>>>>>            End
13527>>>>>>
13527>>>>>        End
13527>>>>>>
13527>>>>>        Set Visited_State to True
13528>>>>>        Function_Return iRetval
13529>>>>>    End_Function
13530>>>>>    
13530>>>>>    // This tests the DDO and all "up" DDOs to see if a switched parent / commit test even needs to be
13530>>>>>    // tested. This is called by the top ValidateSwitchedCommittedParents to see if a switch parent test
13530>>>>>    // even needs to be applied before it has to refinds records.
13530>>>>>    // Return true is there is nothing to test (i.e., the shortcut worked).
13530>>>>>    Function IsCommittedRecursiveUpParentChangeAllowed Returns Boolean
13532>>>>>        Boolean bAllowed bCommitted bVisited bHasRecord
13532>>>>>        Integer iServers iSrvr iParent
13532>>>>>        Handle hoSrvr
13532>>>>>        
13532>>>>>        
13532>>>>>        // optimization. We only test committed parents if one parent does not allow changing committed records.
13532>>>>>        // This avoids extra finds and relates when not needed
13532>>>>>        Set Visited_State to True
13533>>>>>        Get Data_Set_Server_Count to iServers
13534>>>>>        Get IsCommitted to bCommitted
13535>>>>>        Move 0 to iSrvr
13536>>>>>        Move True to bAllowed
13537>>>>>        While (iSrvr<iServers and bAllowed)
13541>>>>>            Get Data_Set_Server iSrvr to hoSrvr
13542>>>>>            Get Main_File of hoSrvr to iParent
13543>>>>>            // if committed and parent change not allowed, we are done
13543>>>>>            If (bCommitted) Begin
13545>>>>>                Get IsCommittedParentChangeAllowed iParent to bAllowed
13546>>>>>            End
13546>>>>>>
13546>>>>>            // if still allowed, check all parents
13546>>>>>            If (bAllowed) Begin
13548>>>>>                Get Visited_State of hoSrvr to bVisited
13549>>>>>                If not bVisited Begin
13551>>>>>                    Get IsCommittedRecursiveUpParentChangeAllowed of hoSrvr to bAllowed
13552>>>>>                End
13552>>>>>>
13552>>>>>            End
13552>>>>>>
13552>>>>>            Increment iSrvr
13553>>>>>        Loop
13554>>>>>>
13554>>>>>        Function_Return bAllowed
13555>>>>>    End_Function
13556>>>>>    
13556>>>>>    
13556>>>>>    // special validate-save check for changed committed parent. If the record is committed
13556>>>>>    // and it has a switched parent and this is not allowed, we have an error. This should rarely happen because the
13556>>>>>    // DEOs should guard aginst this. This is a recursive routine that requires special attention the first time through.
13556>>>>>    // When called from the we must refind the original record and all original parents. This way we can compare these parent
13556>>>>>    // rowids to the DD row id (if different, they've changed). At the end we must restore the DD records. Because this takes time
13556>>>>>    // we only even do this if this is committed and there is a chance that there are changed parents
13556>>>>>    
13556>>>>>    Function ValidateSwitchedCommittedParents Boolean bTop Returns Boolean
13558>>>>>        Integer iServers iSrvr iMain iParent iPMain
13558>>>>>        Handle hoSrvr
13558>>>>>        RowID riCrnt riParent riPCrnt
13558>>>>>        Boolean bChanged bCommitted bAllowed bErr bParentChanged bVisited
13558>>>>>        Boolean bHasRecord bPHasRecord bFound
13558>>>>>        
13558>>>>>        
13558>>>>>        // Shortcut optimization. This tests for any committed DDO with a parent that doesn't allow a switch
13558>>>>>        // return true if there is any reason to actually test any DDO up the tree for a parent change
13558>>>>>        If bTop Begin
13560>>>>>            // init visited nodes, these will be tested and set in IsCommittedRecursiveUpParentChangeAllowed
13560>>>>>            Send Initialize_Visited False False //false=up only, true=clear fields
13561>>>>>            Get IsCommittedRecursiveUpParentChangeAllowed to bAllowed
13562>>>>>            If bAllowed Begin
13564>>>>>                Function_Return False // if all are allowed, we have nothing to test - its ok
13565>>>>>            End
13565>>>>>>
13565>>>>>        End
13565>>>>>>
13565>>>>>        
13565>>>>>        Get Main_File to iMain
13566>>>>>        Get CurrentRowId to riCrnt
13567>>>>>        Get Data_Set_Server_Count to iServers
13568>>>>>        Get HasRecord to bHasRecord
13569>>>>>        
13569>>>>>        If (bHasRecord and (bTop or not(IsSameRowID(GetRowID(iMain),riCrnt))) ) Begin
13571>>>>>            // this refinds the main record and, most importantly, relates all original parents on up
13571>>>>>            // We now have the original parents which we can test to see if they are changed.
13571>>>>>            Get ReadByRowIdEx iMain riCrnt to bFound
13572>>>>>            If not bFound Begin
13574>>>>>                Error DFERR_CANT_REFIND_RECORD
13575>>>>>>
13575>>>>>                Function_Return True
13576>>>>>            End
13576>>>>>>
13576>>>>>        End
13576>>>>>>
13576>>>>>        
13576>>>>>        If (bTop) Begin
13578>>>>>            // If at start, init visited nodes, these will be tested and set during recursive calls to this function
13578>>>>>            Send Initialize_Visited False False // false=up only, true=clear fields
13579>>>>>        End
13579>>>>>>
13579>>>>>        
13579>>>>>        Set Visited_State to True
13580>>>>>        Get IsCommitted to bCommitted
13581>>>>>        If bCommitted Begin
13583>>>>>            // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
13583>>>>>            // First see any any of the parents are changed.
13583>>>>>            Get Parent_Changed_State to bChanged
13584>>>>>            If bChanged Begin
13586>>>>>                // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
13586>>>>>                Move 0 to iSrvr
13587>>>>>                While (iSrvr<iServers and not(bErr))
13591>>>>>                    Get Data_Set_Server iSrvr to hoSrvr
13592>>>>>                    Get Main_File of hoSrvr to iParent
13593>>>>>                    Get CurrentRowId of hoSrvr to riParent
13594>>>>>                    Move (not(IsSameRowID(GetRowID(iParent),riParent))) to bParentChanged // is parent changed?
13595>>>>>                    If bParentChanged Begin
13597>>>>>                        Get IsCommittedParentChangeAllowed iParent to bAllowed // is changing committed parent allowed?
13598>>>>>                        If not bAllowed Begin
13600>>>>>                            Move True to bErr
13601>>>>>                            If bErr Begin
13603>>>>>                                Send Data_Set_Error of hoSrvr -1 0 DD_CANNOT_SWITCH_PARENT
13604>>>>>                            End
13604>>>>>>
13604>>>>>                        End
13604>>>>>>
13604>>>>>                    End
13604>>>>>>
13604>>>>>                    Increment iSrvr
13605>>>>>                Loop
13606>>>>>>
13606>>>>>            End
13606>>>>>>
13606>>>>>        End
13606>>>>>>
13606>>>>>        
13606>>>>>        // no error in immediate we must continue this check up the parent tree.
13606>>>>>        Move 0 to iSrvr
13607>>>>>        While (iSrvr<iServers and not(bErr))
13611>>>>>            Get Data_Set_Server iSrvr to hoSrvr
13612>>>>>            Get Visited_State of hoSrvr to bVisited
13613>>>>>            If (not(bVisited)) Begin
13615>>>>>                
13615>>>>>                // if new record, we need to refind parent records from here since you cannot
13615>>>>>                // have done a find/relate on a new record.
13615>>>>>                If (not(bHasRecord)) Begin
13617>>>>>                    Get HasRecord of hoSrvr to bPHasRecord
13618>>>>>                    If (bPHasRecord) Begin
13620>>>>>                        Get Main_File of hoSrvr to iPMain
13621>>>>>                        Get CurrentRowId of hoSrvr to riPCrnt
13622>>>>>                        If (not(IsNullRowID(riPCrnt))) Begin
13624>>>>>                            Get ReadByRowIdEx of hoSrvr iPMain riPCrnt to bFound
13625>>>>>                            If not bFound Begin
13627>>>>>                                Error DFERR_CANT_REFIND_RECORD
13628>>>>>>
13628>>>>>                                Function_Return True
13629>>>>>                            End
13629>>>>>>
13629>>>>>                        End
13629>>>>>>
13629>>>>>                    End
13629>>>>>>
13629>>>>>                End
13629>>>>>>
13629>>>>>                
13629>>>>>                Get ValidateSwitchedCommittedParents of hoSrvr False to bErr // call recursively up the parent tree
13630>>>>>            End
13630>>>>>>
13630>>>>>            Increment iSrvr
13631>>>>>        Loop
13632>>>>>>
13632>>>>>        
13632>>>>>        If bTop Begin // if back to the top, make sure our buffers are correct.
13634>>>>>            Send Refind_Records
13635>>>>>        End
13635>>>>>>
13635>>>>>        
13635>>>>>        Function_Return bErr
13636>>>>>    End_Function
13637>>>>>    
13637>>>>>    Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
13639>>>>>        
13639>>>>>        Handle hoBuff hoDSO
13639>>>>>        Boolean bCommit bIsFind bVisited bIsForeign
13639>>>>>        Integer iMax iCount iItems iOpts iChanges
13639>>>>>        
13639>>>>>        
13639>>>>>        Move record_buffer to hoBuff
13640>>>>>        Move (OPERATION_MODE<>MODE_SAVING) to bIsFind
13641>>>>>        
13641>>>>>        // first recurse to all parent ddos
13641>>>>>        Get Data_Set_Server_Count to iMax
13642>>>>>        Decrement iMax
13643>>>>>        For iCount from 0 to iMax
13649>>>>>>
13649>>>>>            Get Data_Set_Server iCount to hoDSO
13650>>>>>            Get Visited_State of hoDSO to bVisited
13651>>>>>            If not (bVisited) Begin
13653>>>>>                Send Entry_Update_Data_Sets to hoDSO iFile iAll
13654>>>>>            End
13654>>>>>>
13654>>>>>        Loop
13655>>>>>>
13655>>>>>        
13655>>>>>        // if find, we only do this if the main file is the same as the find file
13655>>>>>        If (not(bIsFind) or iFile=Main_File(Self)) Begin
13657>>>>>            If (not(bIsFind)) Begin
13659>>>>>                // if a save, we care if it is committed.
13659>>>>>                Get IsCommitted to bCommit
13660>>>>>            End
13660>>>>>>
13660>>>>>            
13660>>>>>            // pass if Find (True) or save (False). We only care about commit on saves
13660>>>>>            // The setting of bIsForeign is an approximation. Foreign is really a DEO and and not
13660>>>>>            // a DD concept - in fact, at this point we don't really know. For example, a save in a header/dtl
13660>>>>>            // detail DEO (ordrdtl grid)has header DEOs that are not really foreign. This test errs on the side
13660>>>>>            // of assuming it's foreign. This would cause problems with incorrect parent NoPuts except we also
13660>>>>>            // set a flag, Field_NoPutValueChangedByDeo, when a field is changed via a NoPut DEO. The DD will still update
13660>>>>>            // foreign NoPuts unless this field flag is set.
13660>>>>>            Move (OPERATION_ORIGIN<>Self and Allow_Foreign_New_Save_State(Self)=0) to bIsForeign
13661>>>>>            Send Entry_Update of hoBuff bIsFind (If(bCommit,1,0) + If(bIsForeign,2,0))
13662>>>>>            
13662>>>>>            // also move data from extended dd fields to buffer
13662>>>>>            Send ExtendedFieldsUpdate (not(bIsFind))
13663>>>>>        End
13663>>>>>>
13663>>>>>        Set Visited_State to True
13664>>>>>        
13664>>>>>    End_Procedure
13665>>>>>    
13665>>>>>    // is this field NoPut based passed Commit and Foreign flags.
13665>>>>>    Function FieldNoPut Integer iField Boolean bIsCommited Boolean bIsForeign Returns Boolean
13667>>>>>        Boolean bNoPut
13667>>>>>        // this uses runtime logic - the same use for moving DD Buffer to Field Buffer
13667>>>>>        Get IsFieldDDNoPut of Record_Buffer iField (If(bIsCommited,1,0) + If(bIsForeign,2,0)) to bNoPut
13668>>>>>        Function_Return bNoPut
13669>>>>>    End_Function
13670>>>>>    
13670>>>>>    
13670>>>>>    // Check that Server data-sets exist for all required server file numbers
13670>>>>>    Function Valid_Servers Returns Integer
13672>>>>>        Integer iRval
13672>>>>>        Integer iCount
13672>>>>>        Integer iMax
13672>>>>>        Integer iDSO
13672>>>>>        Integer iPos
13672>>>>>        Integer iFile
13672>>>>>        String  sFiles
13672>>>>>        
13672>>>>>        // First assemble a string of all server file#s in ','##',' format
13672>>>>>        Move ',' to sFiles
13673>>>>>        Get Data_Set_Server_Count to iMax
13674>>>>>        Decrement iMax
13675>>>>>        For iCount from 0 to iMax
13681>>>>>>
13681>>>>>            Get Data_Set_Server iCount to iDSO
13682>>>>>            Move ( sFiles + String(Main_file(iDSO)) + ",") to sFiles
13683>>>>>        Loop
13684>>>>>>
13684>>>>>        
13684>>>>>        // Make sure each required File exists
13684>>>>>        Get Server_File_Count to iMax
13685>>>>>        Decrement iMax
13686>>>>>        For iCount from 0 to iMax
13692>>>>>>
13692>>>>>            Get Server_File iCount to iFile
13693>>>>>            Move (Pos ( ','+String(iFile)+',' , sFiles)) to iPos
13694>>>>>            If (iPos = 0) ;                Move iFile to iRVal
13697>>>>>        Until iRval
13699>>>>>        Function_Return iRVal
13700>>>>>    End_Function
13701>>>>>    
13701>>>>>    
13701>>>>>    // Check that Client data-sets exist for all required Client file numbers
13701>>>>>    Function Valid_Clients Returns Integer
13703>>>>>        Integer iRval
13703>>>>>        Integer iCount
13703>>>>>        Integer iMax
13703>>>>>        Integer iDSO
13703>>>>>        Integer iPos
13703>>>>>        Integer iFile
13703>>>>>        String  sFiles
13703>>>>>        
13703>>>>>        // First assemble a string of all Client file#s in ','##',' format
13703>>>>>        Move ',' to sFiles
13704>>>>>        Get Data_Set_Client_Count to iMax
13705>>>>>        Decrement iMax
13706>>>>>        For iCount from 0 to iMax
13712>>>>>>
13712>>>>>            Get Data_Set_Client iCount to iDSO
13713>>>>>            Move ( sFiles + String(Main_file(iDSO))+",") to sFiles
13714>>>>>        Loop
13715>>>>>>
13715>>>>>        
13715>>>>>        // Make sure each required File exists
13715>>>>>        Get Client_File_Count to iMax
13716>>>>>        Decrement iMax
13717>>>>>        For iCount from 0 to iMax
13723>>>>>>
13723>>>>>            Get Client_File iCount to iFile
13724>>>>>            Move (Pos( ','+String(iFile)+',', sFiles)) to iPos
13725>>>>>            If (iPos = 0) ;                Move iFile to iRVal
13728>>>>>        Until iRval
13730>>>>>        Function_Return iRVal
13731>>>>>    End_Function
13732>>>>>    
13732>>>>>    
13732>>>>>    // Validates save updating connections. If error returns file# that is
13732>>>>>    // expected and missing. If no error Set Validated_Save_connectio_State
13732>>>>>    // indicating that the connection validation has occurred and is ok
13732>>>>>    Function Validate_Save_Structure Integer ForceFg Returns Integer
13734>>>>>        Integer iRval
13734>>>>>        Integer iMode
13734>>>>>        If not ForceFg Begin
13736>>>>>            Get Validate_Save_Structure_Mode to iMode
13737>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and ;                Save_Structure_Validated_state(Self)=0 ) ) ;                to ForceFg
13738>>>>>        End
13738>>>>>>
13738>>>>>        If ForceFg Begin
13740>>>>>            Get Valid_Structure False to iRval
13741>>>>>            If (iRVal = 0) ;                Set Save_Structure_Validated_State to True
13744>>>>>        End
13744>>>>>>
13744>>>>>        Function_Return iRVal
13745>>>>>    End_Function
13746>>>>>    
13746>>>>>    // Validates Delete Structure. If cascade_state is true this must check
13746>>>>>    // up and down the tree. If no cascade_state just check up the tree.  If
13746>>>>>    // Ok, set Validated_Delete_no_Cascade_Connection_State and and or
13746>>>>>    // Validated_Delete_Cascade_Connection_State
13746>>>>>    // Pass: ForceFg - if TRUE force the validation.
13746>>>>>    Function Validate_Delete_Structure Integer ForceFg Returns Integer
13748>>>>>        Integer iCascade
13748>>>>>        Integer iMode
13748>>>>>        Integer iSt
13748>>>>>        Integer iRval
13748>>>>>        Get Cascade_delete_State to iCascade
13749>>>>>        If not ForceFg Begin
13751>>>>>            Get Validate_Delete_Structure_Mode to iMode
13752>>>>>            If (iMode=DD_VALIDATE_STRUCTURE_ONCE and iCascade );                Get Cascade_Delete_Structure_Validated_state to iSt
13755>>>>>            Else ;                Get No_Cascade_Delete_Structure_Validated_state to iSt
13757>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and iSt=0) ) to ForceFg
13758>>>>>        End
13758>>>>>>
13758>>>>>        
13758>>>>>        If ForceFg Begin
13760>>>>>            Get Valid_Structure iCascade to iRval
13761>>>>>            If (iRval = 0) Begin
13763>>>>>                Set No_Cascade_Delete_Structure_Validated_State to True
13764>>>>>                If iCascade ;                    Set Cascade_Delete_Structure_Validated_State to True
13767>>>>>            End
13767>>>>>>
13767>>>>>        End
13767>>>>>>
13767>>>>>        Function_Return iRval
13768>>>>>    End_Function
13769>>>>>    
13769>>>>>    
13769>>>>>    // This procedure will be called whenever the Data_Set wants its DEOs to
13769>>>>>    // write their values to the record buffer. The value of OPERATION_MODE
13769>>>>>    // determines if this is for finding an record or before saving a record.
13769>>>>>    // We use this event to tell our Record_Buffer to update the
13769>>>>>    // global record buffer.
13769>>>>>    // Modified to visit all server DSOs
13769>>>>>    // Note that this is only sent to the DSO starting the operation.
13769>>>>>    // We must manually send this to all server data-sets ourselves
13769>>>>>    // Note that during a DSO save this will get passed iFile=0 and iAll=3
13769>>>>>    // Changed to Support EntryUpdateLocalState (private)
13769>>>>>    // as of 17.0, EntryUpdateLocalState is True which means that entry_updates
13769>>>>>    // for finds now through the DD Buffer (saves always did).
13769>>>>>    Procedure Request_Entry_Update Integer iFile Integer iAll
13771>>>>>        If ((Operation_Mode=MODE_SAVING and iAll=3) or (EntryUpdateLocalState(Self)) ) Begin //3=dso save
13773>>>>>            If (OPERATION_MODE=MODE_WAITING) Begin
13775>>>>>                // we will only not be in an operation if we are doing a find with EntryUpdateLocalState
13775>>>>>                // set to true. In such a case make this a finding. I am not this is actually needed
13775>>>>>                Send Update_Focus_Field_For_Operation MODE_FINDING
13776>>>>>            End
13776>>>>>>
13776>>>>>            Else Begin
13777>>>>>                // if here we already have an operation_mode so there is no need to do anything special
13777>>>>>                Send Update_Focus_Field // Make sure buffer has latest focus item changes
13778>>>>>            End
13778>>>>>>
13778>>>>>            Send Initialize_Visited False False // Clear up, do not clear fields
13779>>>>>            Send Entry_Update_Data_Sets iFile iAll
13780>>>>>        End
13780>>>>>>
13780>>>>>        Forward Send Request_Entry_Update iFile iAll
13782>>>>>    End_Procedure
13783>>>>>    
13783>>>>>    
13783>>>>>    
13783>>>>>    // Forces the focus field to get update its value with the data-set.
13783>>>>>    // This insures that the DSO and DEO contain the same values.
13783>>>>>    Procedure Update_Focus_Field
13785>>>>>        Integer iFocObj
13785>>>>>        Get Focus of desktop to iFocObj
13786>>>>>        If (Extended_DEO_State(iFocObj)) ;            Send Update_Focus_Field to iFocObj
13789>>>>>    End_Procedure
13790>>>>>    
13790>>>>>    // very internal. Used to set Operation_mode and Operation_origin before the
13790>>>>>    // update. A developer can use this in the DEO to know what state the update is in.
13790>>>>>    // This was created because a DEO value change will trigger an OnChange event and you
13790>>>>>    // can look at this and know that this is part of a DD operation.
13790>>>>>    // This is *only* called by the DD operations in this class and the change is made for as
13790>>>>>    // small of a period as possible.
13790>>>>>    Procedure Update_Focus_Field_For_Operation Integer iOperationMode
13792>>>>>        Integer iOldMode iOldOrigin
13792>>>>>        
13792>>>>>        Move OPERATION_MODE to iOldMode
13793>>>>>        Move OPERATION_ORIGIN to iOldOrigin
13794>>>>>        Move iOperationMode to OPERATION_MODE
13795>>>>>        Move Self to OPERATION_ORIGIN
13796>>>>>        Send Update_Focus_Field
13797>>>>>        Move iOldMode to OPERATION_MODE
13798>>>>>        Move iOldOrigin to OPERATION_ORIGIN
13799>>>>>    End_Procedure
13800>>>>>    
13800>>>>>    
13800>>>>>    // Augment to validate all field values that do not get
13800>>>>>    // validated as part of the item validation process. The advantage
13800>>>>>    // of item validation (over only field validation) is that an error
13800>>>>>    // returns you to the offending item.
13800>>>>>    Function Request_Validate Returns Integer
13802>>>>>        Integer iRetval iOldOrigin iOldMode iRetVal2
13802>>>>>        Handle[] DDsWithFindReqErrors
13803>>>>>        
13803>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13805>>>>>            Send Update_Focus_Field_For_Operation MODE_VALIDATING // added 12.1/15.1
13806>>>>>        End
13806>>>>>>
13806>>>>>        Move Operation_Origin to iOldOrigin
13807>>>>>        Move Self to Operation_Origin
13808>>>>>        Move Operation_Mode to iOldMode
13809>>>>>        // clear all find req DD markers at the origin of the validate request. When request validates occur
13809>>>>>        // they will get added to this array and can be tested to see of such an error has occurred.
13809>>>>>        Set pDDsWithFindReqErrors to DDsWithFindReqErrors
13810>>>>>        // Prior to VDF7, we set this to Mode_Saving. We now have a special mode just for request_validate.
13810>>>>>        // We do this because:
13810>>>>>        //   1) because it is useful (more detail never hurts) and
13810>>>>>        //   2) we will allow set_field_current_value to update when mode_validation is set
13810>>>>>        Move MODE_VALIDATING to Operation_Mode
13811>>>>>        Send Initialize_Visited False True //false=up only, true=clear fields
13812>>>>>        Forward Get Request_Validate to iRetval // normal deo validate
13814>>>>>        // If DEO validation failed, do not validate other fields unless Validate_All_Fields is set
13814>>>>>        If ( (iRetval=0 or (Validate_All_Fields_State(Self))) and Validate_DEOs_Only_State(Self)=0) Begin
13816>>>>>            Get Validate_Data_Sets False (Validate_All_Fields_State(Self)) to iRetval2
13817>>>>>            Move (iRetval or iRetVal2) to iRetval
13818>>>>>        End
13818>>>>>>
13818>>>>>        
13818>>>>>        If (iRetval=0) Begin
13820>>>>>            Get ValidateSwitchedCommittedParents True to iRetval
13821>>>>>        End
13821>>>>>>
13821>>>>>        
13821>>>>>        Move iOldMode   to Operation_Mode
13822>>>>>        Move iOldOrigin to Operation_Origin
13823>>>>>        Function_Return iRetval
13824>>>>>    End_Function
13825>>>>>    
13825>>>>>    Function Request_Validate_All Returns Integer
13827>>>>>        Integer bOld iRetVal
13827>>>>>        Get Validate_All_Fields_State to bOld
13828>>>>>        Set Validate_All_Fields_State to True
13829>>>>>        Get request_validate to iretVal
13830>>>>>        Set Validate_All_Fields_State to bOld
13831>>>>>        Function_Return iRetval
13832>>>>>    End_Function
13833>>>>>    
13833>>>>>    
13833>>>>>    
13833>>>>>    // Like Item_find except entry-update is forced through the DD, not DEO
13833>>>>>    Procedure File_Field_Find Integer iFindMode Integer iFile Integer iField ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
13835>>>>>        Integer bOld
13835>>>>>        Get EntryUpdateLocalState to bOld
13836>>>>>        Set EntryUpdateLocalState to True
13837>>>>>        Send Item_Find iFindMode iFile iField bEntUpdt bShowErr bDfrd
13838>>>>>        Set EntryUpdateLocalState to bOld
13839>>>>>    End_Procedure
13840>>>>>    
13840>>>>>    // Autofind for requestd file, field and mode.
13840>>>>>    //    If mode not passed, EQ is assummed
13840>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iFindMode
13842>>>>>        Integer eMode
13842>>>>>        If iFile  Begin
13844>>>>>            // if no 3rd argument, default to autofind
13844>>>>>            Move (If(Num_Arguments<3,EQ,iFindMode)) to eMode
13845>>>>>            Send File_Field_Find eMode iFile iField True False False
13846>>>>>        End
13846>>>>>>
13846>>>>>    End_Procedure
13847>>>>>    
13847>>>>>    // Autofind in default mode (does not set changed states). Can be used
13847>>>>>    // within Clear and Clear_all to autofind parents. Parent values can be
13847>>>>>    // maintained using retainAll option
13847>>>>>    Procedure File_Field_Default_AutoFind Integer iFile Integer iField
13849>>>>>        Integer iOldState
13849>>>>>        Handle  hoDD
13849>>>>>        Get Data_set iFile to hoDD
13850>>>>>        If hoDD Begin
13852>>>>>            Get Change_disabled_State of hoDD to iOldState
13853>>>>>            Set Change_disabled_State of hoDD to True
13854>>>>>            Send File_Field_AutoFind  of hoDD iFile iField EQ
13855>>>>>            Set Change_disabled_State of hoDD to iOldState
13856>>>>>            Set changed_state to False
13857>>>>>        End
13857>>>>>>
13857>>>>>    End_Procedure
13858>>>>>    
13858>>>>>    // File_Index_find
13858>>>>>    // Like item_find except you pass the index you want to find with and
13858>>>>>    // ent-update occurs through DDO buffers not deo buffers.
13858>>>>>    // This is currently private and is only used by web-applications
13858>>>>>    Procedure File_Index_Find Integer iFindMode Integer iFile Integer iIndex ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
13860>>>>>        Integer bOld
13860>>>>>        RowID riRec
13860>>>>>        Integer wasChanged hDD iOldStat
13860>>>>>        Boolean bOk
13860>>>>>        
13860>>>>>        Get Data_Set iFile to hDD
13861>>>>>        If (hDD=0) Begin
13863>>>>>            Error DFERR_PROGRAM C_$CannotFindDD
13864>>>>>>
13864>>>>>            Procedure_Return
13865>>>>>        End
13865>>>>>>
13865>>>>>        
13865>>>>>        Get EntryUpdateLocalState to bOld
13866>>>>>        Set EntryUpdateLocalState to True
13867>>>>>        
13867>>>>>        //  'hold' buffer to prepare for entry_update
13867>>>>>        Move (getRowId(iFile)) to riRec
13868>>>>>        Get_Attribute DF_FILE_STATUS of iFile to iOldStat
13871>>>>>        Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
13874>>>>>        
13874>>>>>        If bEntUpdt Begin
13876>>>>>            Send Request_Entry_Update to hDD iFile 1  //entUpdt all DEOs as required
13877>>>>>            
13877>>>>>            //
13877>>>>>            // we really only need to know if any segment of the index changed
13877>>>>>            // but since we don't have field-changed flags, we look at the
13877>>>>>            // whole recbuf - this is consistent with 2.3b and 3.0 non-dataset
13877>>>>>            // behavior.
13877>>>>>            //
13877>>>>>            Move (iOldStat<>DF_FILE_INACTIVE) to wasChanged
13878>>>>>            If not wasChanged ;                Get_Attribute DF_FILE_CHANGED of iFile to wasChanged
13883>>>>>            If not wasChanged ;                Constrained_Clear iFindMode iFile by iIndex
13888>>>>>            
13888>>>>>        End
13888>>>>>>
13888>>>>>        Move False to Err
13889>>>>>        If bDfrd ;            Send Request_Read iFindMode iFile iIndex
13892>>>>>        Else ;            Send Request_Find iFindMode iFile iIndex
13894>>>>>        If (not(Found) and  not(err)) Begin
13896>>>>>            // refind original record (or leave it cleared if not record)
13896>>>>>            Move (FindByRowId(iFile,riRec)) to bOk
13897>>>>>            
13897>>>>>            If bShowErr ;                Error (If(iFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
13900>>>>>            Move False to Err
13901>>>>>        End
13901>>>>>>
13901>>>>>        Set EntryUpdateLocalState to bOld
13902>>>>>    End_Procedure
13903>>>>>    
13903>>>>>    // This does a refind of all records based on the contents of the
13903>>>>>    // refine_record_id property.
13903>>>>>    // This would be used after clearing the DDs and loading the local rencum
13903>>>>>    // buffer with recnums. This can be used by remote DEOs (BPOs).
13903>>>>>    //
13903>>>>>    // Find all existing records. This must be done in bottom-up, breadth
13903>>>>>    // first order. i.e., Start with the passed DD, find it and then find for
13903>>>>>    // parents. Only find if the record is non-zero and it is different than
13903>>>>>    // the current_record.
13903>>>>>    // This order will allow us to support changed parents.
13903>>>>>    // Don't use this if you do not understand what it does.
13903>>>>>    // Private.Find_Records is a helper. We will keep this private because
13903>>>>>    // it is rather specialized and only used by WebApp.
13903>>>>>    Procedure Find_Records
13905>>>>>        Send Initialize_Visited False False // Clear up, do not clear fields
13906>>>>>        Send Private.Find_Records           // refind all records in upward sweep
13907>>>>>    End_Procedure
13908>>>>>    
13908>>>>>    
13908>>>>>    Procedure Private.Find_Records
13910>>>>>        Integer hPrnt
13910>>>>>        Integer iMax
13910>>>>>        Integer iCount
13910>>>>>        RowID riRec
13910>>>>>        Integer iRec iMain
13910>>>>>        // works with both recId and rowId. Only one should ever be set.
13910>>>>>        // find(clear) record, if needed
13910>>>>>        Get Main_File to iMain
13911>>>>>        // assume that either prFindRowId or Find_record_id has a value - never both
13911>>>>>        // also assume Find_record_id only has values when you are using a recnum table
13911>>>>>        Get prFindRowId to riRec
13912>>>>>        If not (IsNullRowId(riRec)) Begin
13914>>>>>            If not (IsSameRowId(riRec, CurrentRowId(Self) ) ) Begin
13916>>>>>                Send FindByRowId iMain riRec // find an Relate all parents
13917>>>>>            End
13917>>>>>>
13917>>>>>            Set prFindRowId to (NullRowId())  // reset refind rec back to zero.
13918>>>>>        End
13918>>>>>>
13918>>>>>        Else Begin
13919>>>>>            // if this has a recnum, it better be a recnum table or an error will occur.
13919>>>>>            // This is not being tested for a recnum table on purpose. If someone is setting Find_record_id
13919>>>>>            // on a non-recnum table, they doing something wrong. An Error will be a good thing.
13919>>>>>            Get Find_Record_Id to iRec
13920>>>>>            If iRec Begin
13922>>>>>                If (iRec<>Current_record(Self)) Begin
13924>>>>>                    Send Find_By_Recnum iMain iRec // find an Relate all parents
13925>>>>>                End
13925>>>>>>
13925>>>>>                Set Find_record_id to 0 // reset refind rec back to zero.
13926>>>>>            End
13926>>>>>>
13926>>>>>        End
13926>>>>>>
13926>>>>>        Set Visited_State to True
13927>>>>>        
13927>>>>>        // recurse and do the same to all parent files
13927>>>>>        // in almost all cases, there will be no new finding here since the relate has
13927>>>>>        // found the records. If the record is different than the relate, we have
13927>>>>>        // a switched parent state (should_save will be set appropriately).
13927>>>>>        Get Data_Set_Server_Count to iMax
13928>>>>>        Decrement iMax
13929>>>>>        For iCount from 0 to iMax
13935>>>>>>
13935>>>>>            Get Data_Set_Server iCount to hPrnt
13936>>>>>            If not (Visited_state(hPrnt)) ;                Send Private.Find_Records to hPrnt
13939>>>>>        Loop
13940>>>>>>
13940>>>>>    End_Procedure
13941>>>>>    
13941>>>>>    // This Mark_Id creates a sequence Id for this clear. This way
13941>>>>>    // DDOs only get cleared one time during this process.
13941>>>>>    Procedure IncrementCurrentMarkId
13943>>>>>        If (DD_Current_Mark_ID>65536) Begin
13945>>>>>            Move 0 to DD_Current_Mark_id
13946>>>>>        End
13946>>>>>>
13946>>>>>        Increment DD_Current_Mark_id
13947>>>>>    End_Procedure
13948>>>>>    
13948>>>>>    
13948>>>>>    // private use by new webapp framework as of 18.2.
13948>>>>>    // pass bStart as True if this is the start of the resynch.
13948>>>>>    Function ReSyncRecords Boolean bStart Returns Handle
13950>>>>>        RowID riRowId riCrnt
13950>>>>>        Boolean bOk bOldReSync bVisited
13950>>>>>        Handle hoOtherDDO hoBadDDO hoBadPrntDDO
13950>>>>>        Integer iMax iCount iMain
13950>>>>>
13950>>>>>        If bStart Begin
13952>>>>>            Send InitializeAllVisited
13953>>>>>        End
13953>>>>>>
13953>>>>>        
13953>>>>>        // we want depth first traversal. Make sure children are handled before parents
13953>>>>>        // Recursively traverse Children, Find by RowId, Recursively traverse Parents
13953>>>>>        // Use visited_state logic to avoid multiple visits caused by diamond DDO strutures
13953>>>>>        
13953>>>>>        //mark first so we don't visit this coming back up.
13953>>>>>        Set Visited_State to True
13954>>>>>        
13954>>>>>        // traverse downward first
13954>>>>>        Get Data_Set_Client_Count to iMax
13955>>>>>        For iCount from 0 to (iMax-1)
13961>>>>>>
13961>>>>>            Get Data_Set_Client iCount to hoOtherDDO
13962>>>>>            Get Visited_State of hoOtherDDO to bVisited
13963>>>>>            If not bVisited Begin
13965>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
13966>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
13968>>>>>                    Move hoBadPrntDDO to hoBadDDO
13969>>>>>                End
13969>>>>>>
13969>>>>>            End
13969>>>>>>
13969>>>>>        Loop
13970>>>>>>
13970>>>>>        
13970>>>>>        // Find record for DD. It might already be correct if child has already
13970>>>>>        // related it in. If not correct after a relate, this has been switched by this
13970>>>>>        // user or switched by another user, in which case it will be swtitched back
13970>>>>>        // (DDOs have always worked this way).
13970>>>>>        Get prFindRowId to riRowId
13971>>>>>        Get Main_File to iMain
13972>>>>>        Get CurrentRowId to riCrnt
13973>>>>>        If ( not(IsSameRowId(riRowID, riCrnt)) ) Begin
13975>>>>>            Get pbInReSync to bOldReSync
13976>>>>>            Set pbInReSync to True
13977>>>>>            
13977>>>>>            If (IsNullRowId(riRowID)) Begin
13979>>>>>                Send Clear
13980>>>>>            End
13980>>>>>>
13980>>>>>            Else Begin
13981>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
13982>>>>>                If not bOk Begin
13984>>>>>                    Move Self to hoBadDDO
13985>>>>>                End
13985>>>>>>
13985>>>>>            End
13985>>>>>>
13985>>>>>            Set pbInReSync to bOldReSync
13986>>>>>        End
13986>>>>>>
13986>>>>>        
13986>>>>>        // finally traverse to parents
13986>>>>>        Get Data_Set_Server_Count to iMax
13987>>>>>        For iCount from 0 to (iMax-1)
13993>>>>>>
13993>>>>>            Get Data_Set_Server iCount to hoOtherDDO
13994>>>>>            Get Visited_State of hoOtherDDO to bVisited
13995>>>>>            If not bVisited Begin
13997>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
13998>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
14000>>>>>                    Move hoBadPrntDDO to hoBadDDO
14001>>>>>                End
14001>>>>>>
14001>>>>>            End
14001>>>>>>
14001>>>>>        Loop
14002>>>>>>
14002>>>>>        
14002>>>>>        If bStart Begin
14004>>>>>            Send InitializeAllVisited
14005>>>>>            Send ResetChangedStates
14006>>>>>        End
14006>>>>>>
14006>>>>>        
14006>>>>>        Function_Return hoBadDDO
14007>>>>>    End_Function
14008>>>>>    
14008>>>>>
14008>>>>>    Procedure ResetChangedStates
14010>>>>>        Boolean bVisited
14010>>>>>        Handle hoOtherDDO
14010>>>>>        Integer iMax iCount
14010>>>>>        tDDChangedInfo DDChangedInfo
14010>>>>>        tDDChangedInfo DDChangedInfo
14010>>>>>                
14010>>>>>        // we want depth first traversal.
14010>>>>>        //mark first so we don't visit this coming back up.
14010>>>>>        Set Visited_State to True
14011>>>>>        
14011>>>>>        // traverse downward first
14011>>>>>        Get Data_Set_Client_Count to iMax
14012>>>>>        For iCount from 0 to (iMax-1)
14018>>>>>>
14018>>>>>            Get Data_Set_Client iCount to hoOtherDDO
14019>>>>>            Get Visited_State of hoOtherDDO to bVisited
14020>>>>>            If not bVisited Begin
14022>>>>>                Send ResetChangedStates of hoOtherDDO
14023>>>>>            End
14023>>>>>>
14023>>>>>        Loop
14024>>>>>>
14024>>>>>        
14024>>>>>        // Set changed states for this DDO
14024>>>>>        Get pDDChangedInfo to DDChangedInfo
14025>>>>>        Set Changed_State to False // clears changed_state and parent_changed_states            
14026>>>>>        Set Changed_State to DDChangedInfo.bChanged            
14027>>>>>        For iCount from 0 to (SizeOfArray(DDChangedInfo.ParentChanged)-1)
14033>>>>>>
14033>>>>>            Send SetParentDDOSwitched DDChangedInfo.ParentChanged[iCount].iTable DDChangedInfo.ParentChanged[iCount].bSwitched
14034>>>>>        Loop
14035>>>>>>
14035>>>>>        
14035>>>>>        // finally traverse to parents
14035>>>>>        Get Data_Set_Server_Count to iMax
14036>>>>>        For iCount from 0 to (iMax-1)
14042>>>>>>
14042>>>>>            Get Data_Set_Server iCount to hoOtherDDO
14043>>>>>            Get Visited_State of hoOtherDDO to bVisited
14044>>>>>            If not bVisited Begin
14046>>>>>                Send ResetChangedStates of hoOtherDDO
14047>>>>>            End
14047>>>>>>
14047>>>>>        Loop
14048>>>>>>
14048>>>>>        
14048>>>>>    End_Procedure
14049>>>>>
14049>>>>>    // private use by new webapp framework (pre 18.2)
14049>>>>>    Function ReSyncRecord Returns Boolean
14051>>>>>        RowID riRowId
14051>>>>>        Boolean bOk bOldReSync
14051>>>>>        Handle hPrnt
14051>>>>>        Integer iMax iCount iMain
14051>>>>>        
14051>>>>>        Get pbInReSync to bOldReSync
14052>>>>>        
14052>>>>>        Get prFindRowId to riRowId
14053>>>>>        Get Main_File to iMain
14054>>>>>        If not (IsSameRowId(riRowID, CurrentRowId(Self) ) ) Begin
14056>>>>>            If (IsNullRowId(riRowID)) Begin
14058>>>>>                Set pbInReSync to True
14059>>>>>                Send Clear
14060>>>>>                Set pbInReSync to bOldReSync
14061>>>>>            End
14061>>>>>>
14061>>>>>            Else Begin
14062>>>>>                Set pbInReSync to True
14063>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
14064>>>>>                Set pbInReSync to bOldReSync
14065>>>>>                If not bOk Begin
14067>>>>>                    Function_Return False
14068>>>>>                End
14068>>>>>>
14068>>>>>            End
14068>>>>>>
14068>>>>>            
14068>>>>>            // check that the relate found all the parent records we expect.
14068>>>>>            // This should be correct unless a parent has been switched. Constrained
14068>>>>>            // parents, by definition, should already be correct. See **Note** below
14068>>>>>            Get Data_Set_Server_Count to iMax
14069>>>>>            For iCount from 0 to (iMax-1)
14075>>>>>>
14075>>>>>                Get Data_Set_Server iCount to hPrnt
14076>>>>>                If (Constrain_File(Self)<>Main_File(hPrnt) and ;                    not (IsSameRowID(prFindRowId(hPrnt),CurrentRowId(hPrnt)))) Begin
14078>>>>>                    // the parent is either wrong or not processed yet. Either way
14078>>>>>                    // make it right.
14078>>>>>                    Get ReSyncRecord of hPrnt to bOk
14079>>>>>                    If not bOk Begin
14081>>>>>                        Function_Return False
14082>>>>>                    End
14082>>>>>>
14082>>>>>                End
14082>>>>>>
14082>>>>>            Loop
14083>>>>>>
14083>>>>>        End
14083>>>>>>
14083>>>>>        
14083>>>>>        Function_Return True
14084>>>>>    End_Function
14085>>>>>    
14085>>>>>    // **Note** - dealing with changed parents and diamonds during a resync.
14085>>>>>    // If there is not a relates-to contraint between DD and child it is possible
14085>>>>>    // that the child find's relate will change the just found parent DD.
14085>>>>>    // Assuming this is not a structure bug, it means the parent is changed parent and that
14085>>>>>    // change must occur after the child record has been found and related. Therefore we add
14085>>>>>    // check after each child find to see if an parent is incorrect. If it is, either it is a
14085>>>>>    // switched parent or we haven't processed it yet. If the record is fine it
14085>>>>>    // just does nothing. For example (where *=relates-to):
14085>>>>>    //     W
14085>>>>>    //   */  \*
14085>>>>>    //   X    Y
14085>>>>>    //    \  /*
14085>>>>>    //     Z
14085>>>>>    // Assume you found a Z and changed its parent X.
14085>>>>>    // The refind order can be: WXZY or WYZX
14085>>>>>    // If WXZY the refound parent will be lost because Z will relate after the X
14085>>>>>    // find and replace it with the original parent. To control this we add this check
14085>>>>>    // after child Z has done its work. We only need to do this when child DDOs exist
14085>>>>>    // that are not constrained. This can change the order that DDOs are resynced but it
14085>>>>>    // should not matter.
14085>>>>>    
14085>>>>>    
14085>>>>>    
14085>>>>>    // Private use by new webapp framework
14085>>>>>    Procedure ReSyncClearAll
14087>>>>>        Boolean bOldReSync
14087>>>>>        Get pbInReSync to bOldReSync
14088>>>>>        // we need this to stop RememberLast and retains. We don't want those during a resyc clear
14088>>>>>        Set pbInReSync to True
14089>>>>>        Send Clear_All
14090>>>>>        Set pbInReSync to bOldReSync
14091>>>>>    End_Procedure
14092>>>>>    
14092>>>>>    // returns table name for error display. By default it returns the logical name
14092>>>>>    // can be augmented to return other information
14092>>>>>    Function ErrorMessageTableName Integer iTable Returns String
14094>>>>>        String sTable
14094>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTable
14097>>>>>        Function_Return sTable
14098>>>>>    End_Function
14099>>>>>    
14099>>>>>    
14099>>>>>    // Augmented to test updating connections.
14099>>>>>    // If error report it.
14099>>>>>    Procedure Request_Save
14101>>>>>        Integer iRval
14101>>>>>        String sTable
14101>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14103>>>>>            Send Update_Focus_Field_For_Operation MODE_SAVING // added in 12.1/15.1
14104>>>>>            Get Validate_Save_Structure False to iRval
14105>>>>>            If iRval Begin
14107>>>>>                Get ErrorMessageTableName iRval to sTable
14108>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
14109>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_INVALID_SAVE_STRUCTURE sTable
14110>>>>>                Procedure_Return
14111>>>>>            End
14111>>>>>>
14111>>>>>        End
14111>>>>>>
14111>>>>>        Forward Send Request_Save
14113>>>>>    End_Procedure
14114>>>>>    
14114>>>>>    // Augmented to test updating connections.
14114>>>>>    // If error report it.
14114>>>>>    Procedure Request_Delete
14116>>>>>        Integer iRval
14116>>>>>        String sTable
14116>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14118>>>>>            Send Update_Focus_Field_For_Operation MODE_DELETING // added to 12.1/15.1
14119>>>>>            Get Validate_Delete_Structure False to iRval
14120>>>>>            If iRval Begin
14122>>>>>                Get ErrorMessageTableName iRval to sTable
14123>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
14124>>>>>                Send data_Set_Error -1 DFERR_PROGRAM DD_INVALID_DELETE_STRUCTURE sTable
14125>>>>>                Procedure_Return
14126>>>>>            End
14126>>>>>>
14126>>>>>        End
14126>>>>>>
14126>>>>>        Forward Send Request_Delete
14128>>>>>    End_Procedure
14129>>>>>    
14129>>>>>    // Set status-line help for the passed field. This could have been named
14129>>>>>    // Set Field_Status_Help but this keeps this message interface consistent
14129>>>>>    // with the rest of DF for windows.
14129>>>>>    Procedure Set Status_Help Integer iField String sVal
14131>>>>>        Set Value of (StatusHelp_Array(Self)) iField to sVal
14132>>>>>    End_Procedure
14133>>>>>    
14133>>>>>    // Get status-line help for the passed field. This could have been named
14133>>>>>    // Get Field_Status_Help but this keeps this message interface consistent
14133>>>>>    // with the rest of DF for windows.
14133>>>>>    Function Status_Help Integer iField Returns String
14135>>>>>        String sHelp
14135>>>>>        Integer iObj
14135>>>>>        Move (StatusHelp_Array(Self)) to iObj
14136>>>>>        If (Item_Count(iObj)>iField) Begin
14138>>>>>            Get value of iObj iField to sHelp
14139>>>>>            If (sHelp = '0') ;                Move '' to shelp
14142>>>>>        End
14142>>>>>>
14142>>>>>        Function_Return shelp
14143>>>>>    End_Function
14144>>>>>    
14144>>>>>    // Get status-line help for the passed file and field. This is called
14144>>>>>    // by DEOs (or any other object) that needs help for a particular file
14144>>>>>    // and field.
14144>>>>>    Function File_Field_Status_Help Integer iFile Integer iField Returns String
14146>>>>>        Integer iDSO
14146>>>>>        String sValue
14146>>>>>        Get Data_set iFile to iDSO
14147>>>>>        If iDSO ;            Get Status_Help of iDSO iField to sValue
14150>>>>>        Function_Return sValue
14151>>>>>    End_Function
14152>>>>>    
14152>>>>>    // Allows user to set a mask type. Legal value is any of the current mask
14152>>>>>    // window types. 0 Means undefined.
14152>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
14154>>>>>        Set Field_Mask_Type of (FieldMask_Array(Self)) iField to iType
14155>>>>>    End_Procedure
14156>>>>>    
14156>>>>>    Function Field_Mask_Type Integer iField Returns Integer
14158>>>>>        Function_Return (Field_Mask_Type(FieldMask_Array(Self),iField))
14159>>>>>    End_Function
14160>>>>>    
14160>>>>>    Function File_Field_Mask_Type Integer iFile Integer iField Returns Integer
14162>>>>>        Integer iDSO
14162>>>>>        Get Data_set iFile to iDSO
14163>>>>>        If iDSO ;            Function_Return (Field_Mask_Type(iDSO,iField))
14166>>>>>    End_Function
14167>>>>>    
14167>>>>>    // If TRUE the value returned by DEO will contain mask characters.
14167>>>>>    // Currently not supported.
14167>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
14169>>>>>        Set Field_Mask_Value_State of (FieldMask_Array(Self)) iField to iState
14170>>>>>    End_Procedure
14171>>>>>    
14171>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
14173>>>>>        Function_Return (Field_Mask_Value_State(FieldMask_Array(Self),iField))
14174>>>>>    End_Function
14175>>>>>    
14175>>>>>    Function File_Field_Mask_Value_State Integer iFile Integer iField Returns Integer
14177>>>>>        Integer iDSO
14177>>>>>        Get Data_set iFile to iDSO
14178>>>>>        If iDSO ;            Function_Return (Field_Mask_Value_State(iDSO,iField))
14181>>>>>    End_Function
14182>>>>>    
14182>>>>>    // Allows user to set a mask strinng. Legal value is any of the current
14182>>>>>    // masks. Note an empty string with a valid mask type implies that the
14182>>>>>    // system should figure it out by itself.
14182>>>>>    Procedure Set Field_Mask Integer iField String sMask
14184>>>>>        Set Field_Mask of (FieldMask_Array(Self)) iField to sMask
14185>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Mask_Changed iField sMask
14188>>>>>    End_Procedure
14189>>>>>    
14189>>>>>    Function Field_Mask Integer iField Returns String
14191>>>>>        Function_Return (Field_Mask(FieldMask_Array(Self),iField))
14192>>>>>    End_Function
14193>>>>>    
14193>>>>>    Function File_Field_Mask Integer iFile Integer iField Returns String
14195>>>>>        Integer iDSO
14195>>>>>        String sValue
14195>>>>>        Get Data_set iFile to iDSO
14196>>>>>        If iDSO ;            Get Field_Mask of iDSO iField to sValue
14199>>>>>        Function_Return sValue
14200>>>>>    End_Function
14201>>>>>    
14201>>>>>    // Short for field. This is normally used by grid headers.
14201>>>>>    Procedure Set Field_Label_Short Integer iField String sName
14203>>>>>        Set Field_Label_Short of (FieldMask_Array(Self)) iField to sName
14204>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 0 sName
14207>>>>>    End_Procedure
14208>>>>>    
14208>>>>>    Function Field_Label_Short Integer iField Returns String
14210>>>>>        Function_Return (Field_Label_Short(FieldMask_Array(Self),iField))
14211>>>>>    End_Function
14212>>>>>    
14212>>>>>    Function File_Field_Label_Short Integer iFile Integer iField Returns String
14214>>>>>        Integer iDSO
14214>>>>>        String sValue
14214>>>>>        Get Data_set iFile to iDSO
14215>>>>>        If iDSO ;            Get Field_Label_Short of iDSO iField to sValue
14218>>>>>        Function_Return sValue
14219>>>>>    End_Function
14220>>>>>    
14220>>>>>    // Full Name for field. This is normally used by form labels
14220>>>>>    Procedure Set Field_Label_Long Integer iField String sName
14222>>>>>        Set Field_Label_Long of (FieldMask_Array(Self)) iField to sName
14223>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 1 sName
14226>>>>>    End_Procedure
14227>>>>>    
14227>>>>>    Function Field_Label_Long Integer iField Returns String
14229>>>>>        Function_Return (Field_Label_Long(FieldMask_Array(Self),iField))
14230>>>>>    End_Function
14231>>>>>    
14231>>>>>    Function File_Field_Label_Long Integer iFile Integer iField Returns String
14233>>>>>        Integer iDSO
14233>>>>>        String sValue
14233>>>>>        Get Data_set iFile to iDSO
14234>>>>>        If iDSO ;            Get Field_Label_Long of iDSO iField to sValue
14237>>>>>        Function_Return sValue
14238>>>>>    End_Function
14239>>>>>    
14239>>>>>    // This is not really a DD attribute (it is in the API) but it is
14239>>>>>    // appropriate to be accessed from the DD
14239>>>>>    Function Field_Label_Tag Integer iField Returns String
14241>>>>>        String sName
14241>>>>>        Integer iFile
14241>>>>>        Get Main_File to iFile
14242>>>>>        If iFile ;            Get_Attribute DF_FIELD_NAME of iFile iField to sName
14247>>>>>        Function_Return sName
14248>>>>>    End_Function
14249>>>>>    
14249>>>>>    Function SmartCase String sName Returns String
14251>>>>>        Integer iPos iNewPos
14251>>>>>        String sRight
14251>>>>>        Move (Replaces("_",lowercase(sName)," ")) to sName
14252>>>>>        Move (Trim (Replaces(".",sName," "))) to sName
14253>>>>>        Move 1 to iPos
14254>>>>>        Repeat
14254>>>>>>
14254>>>>>            Move (mid(sName,255,iPos+1)) to sRight
14255>>>>>            Move (left(sName,iPos-1) + Uppercase(mid(sName,1,iPos)) + sRight) to sName
14256>>>>>            Move (Pos( " ", sRight)) to iNewPos
14257>>>>>            If (iNewPos = 0) ;                Break
14260>>>>>            Add (iNewPos+1) to iPos
14261>>>>>        Loop
14262>>>>>>
14262>>>>>        Function_Return sName
14263>>>>>    End_Function
14264>>>>>    
14264>>>>>    Enumeration_List
14264>>>>>        Define DD_LABEL_SHORT
14264>>>>>        Define DD_LABEL_LONG
14264>>>>>        Define DD_LABEL_TAG
14264>>>>>    End_Enumeration_List
14264>>>>>    
14264>>>>>    // Handy function to get the label for a field. Three "types" are
14264>>>>>    // supported:
14264>>>>>    // DD_LABEL_SHORT  use short, if none use long, if none use smart tag
14264>>>>>    // DD_LABEL_LONG   use long, if none use smart tag
14264>>>>>    // DD_LABEL_TAG    use smart tag
14264>>>>>    // If you want an explicit field name use oneof the other messages.
14264>>>>>    Function Field_Label Integer iField Integer iType Returns String
14266>>>>>        Integer iServer
14266>>>>>        String sValue
14266>>>>>        If (iType = DD_LABEL_SHORT) ;  // 0 = Short            Get Field_Label_Short iField to sValue
14269>>>>>        If (iType = DD_LABEL_LONG or (iType=DD_LABEL_SHORT and sValue='')) ;            Get Field_Label_Long iField to sValue
14272>>>>>        If (iType = DD_LABEL_TAG or sValue="") Begin
14274>>>>>            Get Field_Label_Tag iField to sValue
14275>>>>>            Get SmartCase sValue to sValue
14276>>>>>        End
14276>>>>>>
14276>>>>>        Function_Return sValue
14277>>>>>    End_Function
14278>>>>>    
14278>>>>>    Function File_Field_Label Integer iFile Integer iField Integer iType Returns String
14280>>>>>        Integer iDSO
14280>>>>>        String sValue
14280>>>>>        Get Data_set iFile to iDSO
14281>>>>>        If iDSO ;            Get Field_Label of iDSO iField iType to sValue
14284>>>>>        Function_Return sValue
14285>>>>>    End_Function
14286>>>>>    
14286>>>>>    // Normally this will not be used by a running program. However, it
14286>>>>>    // could be possible to create classes dynamically at runtime, in which
14286>>>>>    // case these messages could be useful. No File_Field is provided. If the
14286>>>>>    // person knows enough to create dynamic classes they can find the DD.
14286>>>>>    Procedure Set Field_Class_Name Integer iField String sName
14288>>>>>        Set Field_Class_Name of (FieldMask_Array(Self)) iField to sName
14289>>>>>    End_Procedure
14290>>>>>    
14290>>>>>    Function Field_Class_Name Integer iField Returns String
14292>>>>>        Function_Return (Field_Class_Name(FieldMask_Array(Self),iField))
14293>>>>>    End_Function
14294>>>>>    
14294>>>>>    // This procedure should be used to set a specific error number and
14294>>>>>    // message for a particular field. This can be used with the Field_error
14294>>>>>    // message to generate this error during a validation.
14294>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
14296>>>>>        Set Field_Error of (Field_Attributes(Self)) iField to iErr sMsg
14297>>>>>    End_Procedure
14298>>>>>    
14298>>>>>    // Used to retreive the error number and message for a particular field
14298>>>>>    Function Field_Error_Number Integer iField Returns Integer
14300>>>>>        Function_Return (Field_Error_Number(Field_Attributes(Self),iField))
14301>>>>>    End_Function
14302>>>>>    
14302>>>>>    Function Field_Error_Message Integer iField Returns String
14304>>>>>        Function_Return (Field_Error_Message(Field_Attributes(Self),iField))
14305>>>>>    End_Function
14306>>>>>    
14306>>>>>    // This procedure is used to declare an error on a standard field
14306>>>>>    // validation violation like Range or Check.
14306>>>>>    // Can pass 1 to 4 params:
14306>>>>>    // iField -                  Standard usage. Generates field as defined
14306>>>>>    //                           for this field. If field=-1, General error
14306>>>>>    // iField SDefault           If no field error mess (or field=-1) use
14306>>>>>    //                           the default message
14306>>>>>    // iField sDefault sParam1 {sParam2} Replace occurances of @PARAM1 and
14306>>>>>    //                           @PARAM2 in text with these values
14306>>>>>    Procedure Field_Error Integer iField String sDefault ;            String sParam1 String sParam2
14308>>>>>        Integer iErr
14308>>>>>        String  sMess
14308>>>>>        If (iField >= 0) Begin
14310>>>>>            Get Field_Error_Number  iField to iErr
14311>>>>>            Get Field_Error_Message iField to sMess
14312>>>>>        End
14312>>>>>>
14312>>>>>        If (sMess="" and Num_Arguments>1) ;            Move sDefault to sMess
14315>>>>>        If (Num_Arguments = 4) ;            Send Data_Set_Error iField iErr sMess sParam1 sParam2
14318>>>>>        Else If (Num_Arguments = 3) ;            Send Data_Set_Error iField iErr sMess sParam1
14322>>>>>        Else ;            Send Data_Set_Error iField iErr sMess
14324>>>>>    End_Procedure
14325>>>>>    
14325>>>>>    // Procedure Data_Set_Error
14325>>>>>    // This procedure is used to declare a data-set error. Pass error number
14325>>>>>    // and optional error message text.
14325>>>>>    // If iErr is 0, use the default error number.
14325>>>>>    // sParam1 and sParam2 are optional. If passed they are used as text
14325>>>>>    // replacements for @PARAM1 and @PARAM2.
14325>>>>>    // We pass iField (even though we don't use it) so that augmentations
14325>>>>>    // could support error logging down to a field level. If a non-field error
14325>>>>>    // is required the developer should pass negative values (e.g., -1)
14325>>>>>    // This will redirect errors locally if not already redirected
14325>>>>>    //
14325>>>>>    // Altered to additionally support %1 %2 replacements as well as
14325>>>>>    // replacements for @PARAM1 and @PARAM2. (vdf8.2)
14325>>>>>    Procedure Data_set_error Integer iField Integer iErr String sMess ;            String sParam1 String sParam2
14327>>>>>        Integer iOldField
14327>>>>>        Get Current_validate_field to iOldField
14328>>>>>        If (iField <> 0) ;            Set Current_Validate_field to iField
14331>>>>>        
14331>>>>>        If (iErr = 0) ; // if no error is passes, used a default error            Move DD_DEFAULT_ERROR_NUMBER to iErr
14334>>>>>        
14334>>>>>        If (sMess > "") Begin
14336>>>>>            
14336>>>>>            // Support message replacements.. Up to two values
14336>>>>>            // altered to support @Param1/2 and %1 %2 messages
14336>>>>>            If (Num_Arguments>3) Begin
14338>>>>>                Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
14339>>>>>                If (Num_Arguments>4) Begin
14341>>>>>                    Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
14342>>>>>                    Move (SFormat(sMess,sParam1,sParam2)) to sMess
14343>>>>>                End
14343>>>>>>
14343>>>>>                Else Begin
14344>>>>>                    Move (SFormat(sMess,sParam1)) to sMess
14345>>>>>                End
14345>>>>>>
14345>>>>>            End
14345>>>>>>
14345>>>>>            Move Self to ghoErrorSource
14346>>>>>            Error iErr sMess
14347>>>>>>
14347>>>>>            Move 0 to ghoErrorSource
14348>>>>>        End
14348>>>>>>
14348>>>>>        Else ;            Send Operation_Not_Allowed iErr
14350>>>>>        Set Current_validate_field to iOldField
14351>>>>>        Move True to Err // make sure Err is still set
14352>>>>>    End_Procedure
14353>>>>>    
14353>>>>>    // Augment to support Error_Report_Mode. Allows errors without error mess
14353>>>>>    // This will redirect errors locally if not already redirected
14353>>>>>    Procedure Operation_Not_Allowed Integer iErr
14355>>>>>        Integer bOK
14355>>>>>        Move Self to ghoErrorSource
14356>>>>>        Forward Send Operation_Not_Allowed iErr
14358>>>>>        Move 0 to ghoErrorSource
14359>>>>>    End_Procedure
14360>>>>>    
14360>>>>>    // Local error handler. When errors are redirected to the DD this proce-
14360>>>>>    // dure handles the errors. If error_report_mode is NO-report it sets
14360>>>>>    // the err indicator and returns. Else it redirects the error to the
14360>>>>>    // main error handler first moving its ID to ghoErrorSource. This way the
14360>>>>>    // handler knows who sent this message and will get additional error info
14360>>>>>    // by calling Get Extended_error_message
14360>>>>>    Procedure Error_Report Integer iError Integer iLine String ErrMsg
14362>>>>>        Integer hoErrId
14362>>>>>        Integer bRedirect
14362>>>>>        If (Error_Processing_State(Self)) ;  // this prevents recursion            Procedure_Return
14365>>>>>        Set Error_Processing_State to True
14366>>>>>        
14366>>>>>        // if no report mode, just set the err indicator to true.
14366>>>>>        If (Error_Report_Mode(Self)=DD_ERROR_NO_REPORT) ;            Move True to Err
14369>>>>>        Else Begin
14370>>>>>            Get Old_error_object_id to hoErrId  // the original error handler
14371>>>>>            If hoErrId Begin
14373>>>>>                Move (ghoErrorSource=0) to bRedirect
14374>>>>>                If bRedirect ;                    Move Self to ghoErrorSource // error handler can use this
14377>>>>>                Move hoErrID to Error_object_id
14378>>>>>                Send Error_Report to hoErrId iError iLine ErrMsg
14379>>>>>                Move Self to Error_object_id
14380>>>>>                If bRedirect ;                    Move 0 to ghoErrorSource
14383>>>>>            End
14383>>>>>>
14383>>>>>            Else ;                Send error_report of desktop iError iLine ErrMsg
14385>>>>>            //else forward send error_report iError iLine ErrMsg
14385>>>>>        End
14385>>>>>>
14385>>>>>        Set Error_Processing_State to False
14386>>>>>    End_Procedure
14387>>>>>    
14387>>>>>    // This is called (by the system error handler) to get additional informa-
14387>>>>>    // tion about the error. Returns a multi line string with each line
14387>>>>>    // separated by a "\n". Return the file number, name, and if possible
14387>>>>>    // the field number and name.
14387>>>>>    Function Extended_Error_Message Returns String
14389>>>>>        String sExtMess
14389>>>>>        String sFile
14389>>>>>        Integer iFile iField
14389>>>>>        Get main_file to iFile
14390>>>>>        Get Current_Validate_Field to iField
14391>>>>>        Get ErrorMessageTableName iFile to sFile
14392>>>>>        Move (DD_FILE_TEXT* String(iFile) * "-" * sFile) to sExtMess
14393>>>>>        If (iField > 0) ;            Append sExtMess "\n" ;            (DD_FIELD_TEXT* String(iField) * "-" * Field_Label(Self,iField,DD_LABEL_LONG))
14397>>>>>        Set Current_Validate_Field to 0
14398>>>>>        Function_Return sExtMess
14399>>>>>    End_Function
14400>>>>>    
14400>>>>>    Function Extended_Error_File Returns Integer
14402>>>>>        Function_Return (Main_File(Self))
14403>>>>>    End_Function
14404>>>>>    
14404>>>>>    Function Extended_Error_Field Returns Integer
14406>>>>>        Function_Return (Current_Validate_Field(Self))
14407>>>>>    End_Function
14408>>>>>    
14408>>>>>    
14408>>>>>    // The following messages are used to control smart file mode exception
14408>>>>>    // handling. The message "Send Add_system_File file# Fg" allows you to
14408>>>>>    // add system files (or any other files not known to the dso structure)
14408>>>>>    // within define_fields. This allows you to not have to augment the msg
14408>>>>>    // reset_filemodes_for_lock. The only truly public messages here are
14408>>>>>    // Add_system_file and Remove_system_File (which s/b rarely used).
14408>>>>>    
14408>>>>>    // Adds a system file for smart_file_mode handling. A second optional
14408>>>>>    // parameter may be passed to determine of the sys file should only be
14408>>>>>    // locked during a new save (and not during a delete or a save of an
14408>>>>>    // existing record). It is expected that this will be the only public
14408>>>>>    // message used to control smart filemode. All of the remaining sys file
14408>>>>>    // messages are considered advanced.
14408>>>>>    Procedure Add_System_File Integer iFile Integer iLock_Mode
14410>>>>>        Integer iobj iCnt iMode
14410>>>>>        If (Num_arguments = 1) ;            Move DD_Lock_on_All to iMode
14413>>>>>        Else ;            Move iLock_Mode     to iMode
14415>>>>>        Move (system_file_obj(Self)) to iObj
14416>>>>>        Get Item_Count  of iObj to iCnt
14417>>>>>        Set Array_Value of iObj iCnt to iFile
14418>>>>>        Increment iCnt
14419>>>>>        Set Array_Value of iObj iCnt to iMode
14420>>>>>    End_Procedure
14421>>>>>    
14421>>>>>    // Return number of system files
14421>>>>>    Function System_File_Count Returns Integer
14423>>>>>        Function_Return (Item_Count(System_File_Obj(Self))/2)
14424>>>>>    End_Function
14425>>>>>    
14425>>>>>    // Returns system file number for passed item.
14425>>>>>    Function System_File_Number Integer iItem Returns Integer
14427>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2))
14428>>>>>    End_Function
14429>>>>>    
14429>>>>>    // Returns system flag to determine if file is only used during a new
14429>>>>>    // save (and not during an exiting save or a delete).
14429>>>>>    Function System_File_Lock_Mode Integer iItem Returns Integer
14431>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2+1))
14432>>>>>    End_Function
14433>>>>>    
14433>>>>>    // Removes a system_file for smart_file_Mode handling. This remvoes the
14433>>>>>    // first occurance of the file (S/b the only occurance). We assume that
14433>>>>>    // this will be rarely used.
14433>>>>>    Procedure Remove_System_File Integer iFile
14435>>>>>        Integer iobj iCnt iItmCnt
14435>>>>>        Get System_file_Count to iItmCnt
14436>>>>>        Decrement iItmCnt
14437>>>>>        For iCnt from 0 to iItmCnt
14443>>>>>>
14443>>>>>            If (System_File_Number(Self,iCnt)=iFile) Begin
14445>>>>>                Move (system_file_obj(Self)) to iObj
14446>>>>>                Move (iCnt*2) to iCnt
14447>>>>>                Send Delete_Item to iObj iCnt
14448>>>>>                Send Delete_Item to iObj iCnt
14449>>>>>                Procedure_Return
14450>>>>>            End
14450>>>>>>
14450>>>>>        Loop
14451>>>>>>
14451>>>>>    End_Procedure
14452>>>>>    
14452>>>>>    // These set messages, add_client_file, add_server_file and add_system_file
14452>>>>>    // were added to more easily support visual DD class modeling. They do the
14452>>>>>    // same thing the Send counterpart messages do
14452>>>>>    
14452>>>>>    Procedure Set Add_Client_File Integer iFile
14454>>>>>        Send Add_Client_File iFile
14455>>>>>    End_Procedure
14456>>>>>    
14456>>>>>    Procedure Set Add_Server_File Integer iFile
14458>>>>>        Send Add_Server_File iFile
14459>>>>>    End_Procedure
14460>>>>>    
14460>>>>>    Procedure Set Add_System_File Integer iFile Integer iLock_Mode
14462>>>>>        // allow no arguments because the old message allowed this
14462>>>>>        If (Num_arguments=1) Begin
14464>>>>>            Send Add_System_File iFile
14465>>>>>        End
14465>>>>>>
14465>>>>>        Else Begin
14466>>>>>            Send Add_System_File iFile iLock_Mode
14467>>>>>        End
14467>>>>>>
14467>>>>>    End_Procedure
14468>>>>>    
14468>>>>>    // The Set Field_Auto_Increment method replaces the need to use the Define_Auto_Incrmement
14468>>>>>    // command. This models more easily and it supports multiple auto-increment fields
14468>>>>>    Procedure Set Field_Auto_Increment Integer iField Integer iSysFile Integer iSysField
14470>>>>>        Integer[] AutoIncFields
14471>>>>>        tDDFileField[] SysFileFields
14471>>>>>        tDDFileField[] SysFileFields
14472>>>>>        Integer iIndex
14472>>>>>        
14472>>>>>        If (iField=0 or (iSysFile<>0 and iSysField=0)) Begin
14474>>>>>            Error DFERR_PROGRAM "Auto-increment source or destination field is 0"
14475>>>>>>
14475>>>>>            Procedure_Return
14476>>>>>        End
14476>>>>>>
14476>>>>>        // setting the sysfile to 0 is valid. It can be used to clear an existing sysfile
14476>>>>>        If (iSysFile=0) Begin
14478>>>>>            Move 0 to iSysField
14479>>>>>        End
14479>>>>>>
14479>>>>>        Get pAutoIncrementFields to AutoIncFields
14480>>>>>        Get pAutoIncrementSysFileFields to SysFileFields
14481>>>>>        // the destination field array is a list of fields that have auto-incr info. There
14481>>>>>        // can only be zero or one entry per field arranged in no defined order.
14481>>>>>        // see if field is already defined. If not add this to the end.
14481>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
14482>>>>>        If (iIndex=-1) Begin
14484>>>>>            Move (SizeOfArray(SysFileFields)) to iIndex
14485>>>>>        End
14485>>>>>>
14485>>>>>        Move iField    to AutoIncFields[iIndex]
14486>>>>>        Move iSysFile  to SysFileFields[iIndex].iFile
14487>>>>>        Move iSysField to SysFileFields[iIndex].iField
14488>>>>>        Set pAutoIncrementFields to AutoIncFields
14489>>>>>        Set pAutoIncrementSysFileFields to SysFileFields
14490>>>>>    End_Procedure
14491>>>>>    
14491>>>>>    // Get auto-increment system file/field value for a field. There really should be no
14491>>>>>    // reason to ever need this. Field is returned byref
14491>>>>>    Function Field_Auto_Increment Integer iField Integer ByRef iSysField Returns Integer
14493>>>>>        Integer iSysFile
14493>>>>>        Integer[] AutoIncFields
14494>>>>>        tDDFileField[] SysFileFields
14494>>>>>        tDDFileField[] SysFileFields
14495>>>>>        Integer iIndex
14495>>>>>        
14495>>>>>        Get pAutoIncrementFields to AutoIncFields
14496>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
14497>>>>>        If (iIndex>-1) Begin
14499>>>>>            Get pAutoIncrementSysFileFields to SysFileFields
14500>>>>>            Move SysFileFields[iIndex].iFile to iSysFile
14501>>>>>            Move SysFileFields[iIndex].iField to iSysField
14502>>>>>        End
14502>>>>>>
14502>>>>>        Else Begin
14503>>>>>            Move 0 to iSysFile
14504>>>>>            Move 0 to iSysField
14505>>>>>        End
14505>>>>>>
14505>>>>>        Function_Return iSysFile
14506>>>>>    End_Function
14507>>>>>    
14507>>>>>    
14507>>>>>    // Augmented to set any system files defined via the Add_System_file
14507>>>>>    // message. This allows us to hide this procedure for the vast majority
14507>>>>>    // of cases.
14507>>>>>    Procedure Reset_Filemodes_For_Lock
14509>>>>>        Boolean bNewRec
14509>>>>>        Integer  iItmCnt iCnt iMode iFile
14509>>>>>        Integer iMain iMaster iOpts
14509>>>>>        Handle hoDD
14509>>>>>        
14509>>>>>        Forward Send Reset_Filemodes_for_lock
14511>>>>>        
14511>>>>>        Get System_File_Count to iItmCnt
14512>>>>>        If iItmCnt Begin
14514>>>>>            Move (not(HasRecord(Self))) to bNewRec
14515>>>>>            Decrement iItmCnt
14516>>>>>            For iCnt from 0 to iItmCnt
14522>>>>>>
14522>>>>>                Get System_File_Number         iCnt to iFile
14523>>>>>                Get System_File_Lock_Mode iCnt to iMode
14524>>>>>                If ( (iMode=DD_Lock_on_All) or ;                    (Operation_Mode=MODE_DELETING and (iMode iand DD_Lock_on_Delete) ) or ;                    (Operation_Mode=MODE_SAVING and ( (iMode iand DD_Lock_on_Save) or ;                    ( (iMode iand DD_Lock_on_New_Save) and bNewRec) ) ) ) Begin
14526>>>>>                    Set_Attribute DF_FILE_MODE of iFile to DF_FILEMODE_DEFAULT
14529>>>>>                End
14529>>>>>>
14529>>>>>            Loop
14530>>>>>>
14530>>>>>        End
14530>>>>>>
14530>>>>>        
14530>>>>>        // augment to support DD magnaged alias tables.
14530>>>>>        // If an alias, set the alias to the proper alias no locks only if
14530>>>>>        // the master file is actually part of this DDO structure. This allows you
14530>>>>>        // to use alias files without the master being present (or even open). This will work without needing
14530>>>>>        // to set the Master|Alias DF_FILE_ALIAS attributes. If the file is master and part of the DDO structure
14530>>>>>        // it will already have its No_locks attribute cleared. If not part of the DD, its not needed.
14530>>>>>        //
14530>>>>>        Get MasterForAlias to iMaster
14531>>>>>        If iMaster Begin
14533>>>>>            Get Main_File to iMain
14534>>>>>            Get Data_Set iMaster to hoDD // is the master in the DD structure
14535>>>>>            If hoDD Begin
14537>>>>>                Get_Attribute DF_FILE_MODE of iMain to iOpts
14540>>>>>                Set_Attribute DF_FILE_MODE of iMain to (iOpts ior DF_FILEMODE_NO_LOCKS)
14543>>>>>                // note this will be reset to what it was when the transaction ends
14543>>>>>            End
14543>>>>>>
14543>>>>>        End
14543>>>>>>
14543>>>>>        
14543>>>>>    End_Procedure
14544>>>>>    
14544>>>>>    // Augmented to handle auto-increment fields if defined. The value from
14544>>>>>    // the auto-incre sys file is incremented, saved and moved to the new
14544>>>>>    // record. As of 17.0 this is no longer in Creating, which is called after
14544>>>>>    // AutoIncrement.
14544>>>>>    Procedure AutoIncrement
14546>>>>>        Integer iSrcFile iSrcField i iAutoFields
14546>>>>>        Integer iDestFile iDestField
14546>>>>>        Number nNum
14546>>>>>        Integer[] AutoIncFields
14547>>>>>        tDDFileField[] AutoIncSysFileFields
14547>>>>>        tDDFileField[] AutoIncSysFileFields
14548>>>>>        Handle hoOwner
14548>>>>>        
14548>>>>>        Forward Send AutoIncrement
14550>>>>>        
14550>>>>>        // this supports the older Define_Auto_Increment logic. Only one is supported
14550>>>>>        // this is exists for backwards compatibility
14550>>>>>        Get Auto_Increment_Source_File to iSrcFile
14551>>>>>        If iSrcFile Begin // do we have auto increment?
14553>>>>>            Get Auto_Increment_Source_Field  to iSrcField
14554>>>>>            Get Auto_Increment_Dest_Field    to iDestField
14555>>>>>            If (iSrcField and iDestField) Begin  // just in case of error
14557>>>>>                Get Main_file to iDestFile
14558>>>>>                Get_Field_Value iSrcFile iSrcField to nNum
14561>>>>>                Move (nNum+1) to nNum
14562>>>>>                Set_Field_Value iSrcFile  iSrcField  to nNum
14565>>>>>                Set_Field_Value iDestFile iDestField to nNum
14568>>>>>                // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
14568>>>>>                // if the DD is not a parent file, it is a sysfile and we must save it
14568>>>>>                Get Which_Data_Set iSrcFile to hoOwner
14569>>>>>                If not hoOwner Begin
14571>>>>>                    SaveRecord iSrcFile
14572>>>>>                End
14572>>>>>>
14572>>>>>            End
14572>>>>>>
14572>>>>>        End
14572>>>>>>
14572>>>>>        // this supports the newer set syntax which support multiple fields. It is expected that you will
14572>>>>>        // use one syntax of the other, not both. If you use the old syntax, you cannot use the new one
14572>>>>>        Else Begin
14573>>>>>            Get pAutoIncrementFields to AutoIncFields
14574>>>>>            Move (SizeOfArray(AutoIncFields)) to iAutoFields
14575>>>>>            If (iAutoFields>0) Begin
14577>>>>>                Get pAutoIncrementSysFileFields to AutoIncSysFileFields
14578>>>>>                Get Main_file to iDestFile
14579>>>>>                For i from 0 to (iAutoFields-1)
14585>>>>>>
14585>>>>>                    // it is legal to set the sysfile to 0, this means it has been cleared and is not used
14585>>>>>                    If (AutoIncSysFileFields[i].iFile>0) Begin
14587>>>>>                        // we assume both the fields are valid and that they've already been tested when added
14587>>>>>                        Get_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
14590>>>>>                        Move (nNum+1) to nNum
14591>>>>>                        Set_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
14594>>>>>                        Set_Field_Value iDestFile AutoIncFields[i] to nNum
14597>>>>>                        // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
14597>>>>>                        // if the DD is not a parent file, it is a sysfile and we must save it
14597>>>>>                        Get Which_Data_Set AutoIncSysFileFields[i].iFile to hoOwner
14598>>>>>                        If not hoOwner Begin
14600>>>>>                            SaveRecord AutoIncSysFileFields[i].iFile
14601>>>>>                        End
14601>>>>>>
14601>>>>>                    End
14601>>>>>>
14601>>>>>                Loop
14602>>>>>>
14602>>>>>            End
14602>>>>>>
14602>>>>>        End
14602>>>>>>
14602>>>>>        
14602>>>>>    End_Procedure
14603>>>>>    
14603>>>>>    // Augmented to fix a bug in the data-set C code. When a record is saved
14603>>>>>    // as part of a delete operation OnNewCurrentRecord is not called. It
14603>>>>>    // should be. We will do this in flex code for now.
14603>>>>>    Procedure Save_Main_File
14605>>>>>        RowID riRec
14605>>>>>        Integer iRec iMain
14605>>>>>        Boolean bRecnumTable bChanged
14605>>>>>        
14605>>>>>        Get Main_File to iMain
14606>>>>>        Get_Attribute DF_FILE_CHANGED of iMain to bChanged
14609>>>>>        If bChanged Begin
14611>>>>>            Send OnSaveRecord // OnSaveRecord sent if there is something to save
14612>>>>>        End
14612>>>>>>
14612>>>>>        
14612>>>>>        Forward Send Save_Main_File
14614>>>>>        
14614>>>>>        If (Operation_Mode = MODE_DELETING) Begin  // during a delete the crnt
14616>>>>>            Get CurrentRowId to riRec             // rec of parents do not change
14617>>>>>            Send OnNewCurrentRecord riRec riRec  // so old and new are the same.
14618>>>>>            // for backwards compatibility reasons, we also send new_current_record if appropriate
14618>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of iMain to bRecnumTable
14621>>>>>            If (bRecnumTable) Begin
14623>>>>>                Get_Field_Value iMain 0 to iRec
14626>>>>>                Send New_Current_Record iRec iRec
14627>>>>>            End
14627>>>>>>
14627>>>>>        End
14627>>>>>>
14627>>>>>    End_Procedure
14628>>>>>    
14628>>>>>    // Augmented to not clear if a system-file. The auto-latching of views
14628>>>>>    // may cause a sys file DD to get cleared. This corrects this. This really
14628>>>>>    // belongs in Data_set (C) but we will not risk this for now.
14628>>>>>    Procedure Clear_Main_File
14630>>>>>        Integer iFile iIsSys
14630>>>>>        Get Main_File to iFile
14631>>>>>        If iFile Begin
14633>>>>>            Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to iIsSys
14636>>>>>            If iIsSys ;                Procedure_Return
14639>>>>>        End
14639>>>>>>
14639>>>>>        Forward Send Clear_main_file
14641>>>>>    End_Procedure
14642>>>>>    
14642>>>>>    // Executes a request_find on the mainfile. This is easier that having to
14642>>>>>    // pass file number all the time. Useful for batch operations.
14642>>>>>    // If Index is 0, use find_by_recnum (it handles a recnum of 0 better)
14642>>>>>    Procedure Find Integer iMode Integer iIndex
14644>>>>>        Integer iFile
14644>>>>>        Integer iRec
14644>>>>>        Get Main_file to iFile
14645>>>>>        If (iIndex<>0 or iMode<>EQ) ;            Send request_find iMode iFile iIndex
14648>>>>>        Else Begin
14649>>>>>            // this would never happen with row ID
14649>>>>>            Get_Field_Value iFile 0 to iRec // get recnum value
14652>>>>>            Send find_by_recnum iFile iRec
14653>>>>>        End
14653>>>>>>
14653>>>>>    End_Procedure
14654>>>>>    
14654>>>>>    // So many people make the mistake of using requeset_clear and request_
14654>>>>>    // clear_all that will support these are alteratives to clear and
14654>>>>>    // clear_all. The preferred messages remain Clear and Clear_all.
14654>>>>>    // This would not work if you nested DEOs within DSOs (no-one does).
14654>>>>>    Procedure Request_Clear
14656>>>>>        Send Clear
14657>>>>>    End_Procedure
14658>>>>>    
14658>>>>>    Procedure Request_Clear_All
14660>>>>>        Send Clear_All
14661>>>>>    End_Procedure
14662>>>>>    
14662>>>>>    // we want changed_state to always go through the
14662>>>>>    // Record_buffer object. From there it is sent to
14662>>>>>    // here. So if state or RB does not match we must
14662>>>>>    // send to the RB object...it will delegate to here
14662>>>>>    
14662>>>>>    Procedure Set Changed_State Integer bState
14664>>>>>        Integer hRB
14664>>>>>        Move (record_buffer(Self)) to hRB
14665>>>>>        If (hRB and changed_state(hRB)<>bState) ;            Set changed_state of hRB to bState
14668>>>>>        Else ;            Forward Set changed_state to bState
14671>>>>>    End_Procedure
14672>>>>>    
14672>>>>>    // this lets us use the new attach logic
14672>>>>>    
14672>>>>>    // This is a smarter attach than the normal attach command. It only attaches data from a parent
14672>>>>>    // if 1) the DDO parent is connected to the structure and 2) if there is a record to attach. It will
14672>>>>>    // not attach empty records into a child. This should make the finding (and saving) more sensible when
14672>>>>>    // partial DD structures are used. For example, often a report does not all of the parent DDOs - however if
14672>>>>>    // they are not provided, finding can get messed up because blank data is being moved into the child before a
14672>>>>>    // find. This has been a problem since 3.0. This should just make it go away.
14672>>>>>    // as of 17.0, we get the related field info through the local DSO if needed
14672>>>>>    
14672>>>>>    // as if 18.1 this is only called when there is an attachable relationship. This gives us a chance to do any
14672>>>>>    // customizations and to cancel the attach. We've left this to the flex level so we can fine tune attaches.
14672>>>>>    Function ShouldFieldAttach Integer iField Handle hoRelDD Returns Boolean
14674>>>>>        Boolean bDoAttach bChanged
14674>>>>>        Integer iFile iStat iRelFile iType
14674>>>>>        String sValue
14674>>>>>        
14674>>>>>        Get Main_File to iFile
14675>>>>>        Get Main_File of hoRelDD to iRelFile
14676>>>>>        
14676>>>>>        // before we attach check if Find mode and relfile is new and unchanged..if so skip.
14676>>>>>        // If operation_mode is 0, this is probably a Find (item_find sends attach_main_file for some reason).
14676>>>>>        Move True to bDoAttach
14677>>>>>        If (Operation_mode=MODE_FINDING or OPERATION_MODE=0) Begin
14679>>>>>            // we can test the file status to see if we have a record or not. If we have a record, we attach
14679>>>>>            Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
14682>>>>>            If (iStat=DF_FILE_INACTIVE) Begin
14684>>>>>                // if no record, we need to look for changes. We can't just look at the file's changed state because the DD
14684>>>>>                // may have set defaults, which have been moved to the buffer. We should be able to check the DD's changed state
14684>>>>>                // because this is not set with default values. When doing a find entry_update this should be ok. If this were
14684>>>>>                // a save, this would cause problems (but this is not a save). Prior to 17.0 this was not an issue with windows
14684>>>>>                // applications because find entry_updates were done at the DEO level (unlike web applications).
14684>>>>>                Get Changed_State of hoRelDD to bChanged
14685>>>>>                Move bChanged to bDoAttach
14686>>>>>                
14686>>>>>                // special Triumph workaround for Item_Find with blank inner segment. They were counting on the item_find attach_main_file
14686>>>>>                // which would slip through the "no-attach on find when parent is empty optimization". This was needed to force a string segment
14686>>>>>                // that was "" to get filled with spaces from the parent field. The child field was set to "" because of a constrained_clear
14686>>>>>                // in Item_find. This workaround is as narrow as possible. If an item_find attach_main_file (operation_mode=0) and this is
14686>>>>>                // an empty parent (bOk was just set to False), and the field is DF_Ascii and the child value is empty (no trailing spaces)
14686>>>>>                // then force an attach. Since the parent should be "", we can just Set_Field_value to "", which fills the field buffer.
14686>>>>>                // There is no real logic as to why this is being done other than to make it work like it used to with the least
14686>>>>>                // amount of side-effects.
14686>>>>>                If (not(bDoAttach) and OPERATION_MODE=0) Begin
14688>>>>>                    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
14691>>>>>                    If (iType=DF_ASCII) Begin
14693>>>>>                        Get_Field_Value iFile iField to sValue
14696>>>>>                        // if no spaces, this probably was cleared via constrained_clear in Item_Find. We should update
14696>>>>>                        If (Ascii(Left(sValue,1))=0) Begin
14698>>>>>                            Set_Field_Value iFile iField to ""
14701>>>>>                        End
14701>>>>>>
14701>>>>>                    End
14701>>>>>>
14701>>>>>                End
14701>>>>>>
14701>>>>>                
14701>>>>>            End
14701>>>>>>
14701>>>>>        End
14701>>>>>>
14701>>>>>        Function_Return bDoAttach
14702>>>>>    End_Function
14703>>>>>    
14703>>>>>    // Notify all DEOs that a mask has changed.
14703>>>>>    //        this message is sent by set Field_Mask
14703>>>>>    Procedure Field_Mask_Changed Integer iField String sMask
14705>>>>>        Integer i iDEOs iDEO
14705>>>>>        Integer iMain_File
14705>>>>>        Get Main_File to iMain_File
14706>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14707>>>>>        Decrement iDEOs
14708>>>>>        For i from 0 to iDEOs
14714>>>>>>
14714>>>>>            Get Data_Set_User_Interface i to iDEO
14715>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Mask_Changed to iDEO ;                iMain_File iField sMask
14718>>>>>        Loop
14719>>>>>>
14719>>>>>    End_Procedure
14720>>>>>    
14720>>>>>    // Notify all DEOs that a label has changed.
14720>>>>>    //   This message is sent by Set Field_Label_long & Field_Label_Short
14720>>>>>    Procedure Field_label_Changed Integer iField Boolean bLong String sLabel
14722>>>>>        Integer i iDEOs iDEO
14722>>>>>        Integer iMain_File
14722>>>>>        Get Main_File to iMain_File
14723>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14724>>>>>        Decrement iDEOs
14725>>>>>        For i from 0 to iDEOs
14731>>>>>>
14731>>>>>            Get Data_Set_User_Interface i to iDEO
14732>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Label_Changed to iDEO ;                iMain_File iField bLong sLabel
14735>>>>>        Loop
14736>>>>>>
14736>>>>>    End_Procedure
14737>>>>>    
14737>>>>>    // Notify all DEOs that a field option has changed.
14737>>>>>    //   This message is sent by Set Field_Option
14737>>>>>    Procedure Field_Option_Changed Integer iField Integer iOptions Boolean bClear
14739>>>>>        Integer i iDEOs iDEO
14739>>>>>        Integer iMain_File
14739>>>>>        Get Main_File to iMain_File
14740>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14741>>>>>        Decrement iDEOs
14742>>>>>        For i from 0 to iDEOs
14748>>>>>>
14748>>>>>            Get Data_Set_User_Interface i to iDEO
14749>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Option_Changed of iDEO ;                iMain_File iField iOptions bClear
14752>>>>>        Loop
14753>>>>>>
14753>>>>>    End_Procedure
14754>>>>>    
14754>>>>>    
14754>>>>>    //   Set, clear or toggle a field option
14754>>>>>    //   Multiple options can be passed as an expression
14754>>>>>    //   (e.g. Set Field_option 2 (dd_Retain IOR dd_NoEnter).
14754>>>>>    //   Unlike set Field_options this notifies DEOs of changes
14754>>>>>    // supports setting and clearing. e.g.:
14754>>>>>    //    Set Field_Option Field Customer.Name DD_NoEnter to True
14754>>>>>    // This new syntax is now the recommended syntax but the older syntax without
14754>>>>>    // the last parameter is supported (where true is the default). The old syntax is
14754>>>>>    // only supported for compatibility. This means that Field_Option_Clear should
14754>>>>>    // also be replaced with Field_Option
14754>>>>>    Procedure Set Field_Option Integer iField Integer iOption Boolean bSet
14756>>>>>        Boolean bSetTrue
14756>>>>>        Move (If(num_arguments>2, bSet, True)) to bSetTrue // support for old deprecated syntax
14757>>>>>        If bSetTrue Begin
14759>>>>>            Set Field_options iField to iOption
14760>>>>>        End
14760>>>>>>
14760>>>>>        Else Begin
14761>>>>>            Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOption
14762>>>>>        End
14762>>>>>>
14762>>>>>        If (Data_Set_User_Interface_Count(Self)) Begin
14764>>>>>            Send Field_Option_Changed iField iOption (not(bSetTrue))
14765>>>>>        End
14765>>>>>>
14765>>>>>    End_Procedure
14766>>>>>    
14766>>>>>    Procedure Set File_Field_Option Integer iFile Integer iField Integer iOption Boolean bSet
14768>>>>>        Handle hoDD
14768>>>>>        Boolean bSetTrue
14768>>>>>        Move (If(num_arguments>3, bSet, True)) to bSetTrue // support for old deprecated syntax
14769>>>>>        Get Data_set iFile to hoDD
14770>>>>>        If hoDD Begin
14772>>>>>            Set Field_Option of hoDD iField iOption to bSetTrue
14773>>>>>        End
14773>>>>>>
14773>>>>>        
14773>>>>>    End_Procedure
14774>>>>>    
14774>>>>>    Procedure Set Field_Option_Clear Integer iField Integer iOptions
14776>>>>>        Set Field_Option iField iOptions to False
14777>>>>>    End_Procedure
14778>>>>>    
14778>>>>>    Procedure Set File_Field_Option_Clear Integer iFile Integer iField Integer iOptions
14780>>>>>        Set File_Field_Option iFile iField iOptions to False
14781>>>>>    End_Procedure
14782>>>>>    
14782>>>>>    Procedure Set Field_Option_Toggle Integer iField Integer iOption
14784>>>>>        Integer iOldOption
14784>>>>>        Get Field_Options iField to iOldOption
14785>>>>>        // if old and new have overlapping bits, we assume clear
14785>>>>>        Set Field_Option iField iOption to ((iOldOption iand iOption)=0)
14786>>>>>    End_Procedure
14787>>>>>    
14787>>>>>    Procedure Set File_Field_Option_Toggle Integer iFile Integer iField Integer iOption
14789>>>>>        Handle hoDD
14789>>>>>        Get Data_set iFile to hoDD
14790>>>>>        If hoDD ;            Set Field_Option_Toggle of hoDD iField to iOption
14793>>>>>    End_Procedure
14794>>>>>    
14794>>>>>    // This returns the main index for a field. This replaces the DSO message Field_Main_index which
14794>>>>>    // should no longer be used by DDOs. The old message has the problem that the DDO or DSO using
14794>>>>>    // this message may not be the owner of the field. So augmenting the owner DDO did not insure that
14794>>>>>    // all requests for this index would go through it. Now you can augment Field_Index and always
14794>>>>>    // be sure that any DDO requesting an index for a file (via file_field_index) will always go to
14794>>>>>    // the owner object.
14794>>>>>    Function Field_Index Integer iField Returns Integer
14796>>>>>        Integer iFile iIndex iOrder
14796>>>>>        // ordering takes precendence
14796>>>>>        Get ordering to iOrder
14797>>>>>        If (iOrder>=0);            Move iOrder to iIndex  //ordering takes precedence over main index
14800>>>>>        Else Begin
14801>>>>>            Get Main_file to iFile
14802>>>>>            Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex // main index field
14805>>>>>            If (iIndex=0 and iField>0) ; // If field is not recnum and there is no index, the                Move -1 to iIndex        // field has no main index
14808>>>>>        End
14808>>>>>>
14808>>>>>        Function_Return iIndex
14809>>>>>    End_Function
14810>>>>>    
14810>>>>>    // In all cases, this message should be sent instead of Field_Main_Index. If
14810>>>>>    // augmentation was used in Field_Main_Index, use Field_Index to insure the owner object
14810>>>>>    // is called.
14810>>>>>    
14810>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
14812>>>>>        Integer iIndex
14812>>>>>        Handle hoDD
14812>>>>>        Get Data_set iFile to hoDD
14813>>>>>        If (hoDD) ;            Get Field_Index of hoDD iField to iIndex
14816>>>>>        Else ;            Move -1 to iIndex
14818>>>>>        Function_Return iIndex
14819>>>>>    End_Function
14820>>>>>    
14820>>>>>    // 12/1 change: Make sure all of the major DD operations update the DD with the value in
14820>>>>>    // the focus field. After the actual find, save, clar or delete, the DD buffer contains information that
14820>>>>>    // is not yet reflected in the DEOs (before refresh is called) we want to make sure that we
14820>>>>>    // don't try to get data from the DEO. Get Field_Current_Value now checks if operation_mode is
14820>>>>>    // non-zero. If it is, it always gets from the DD buffer.
14820>>>>>    
14820>>>>>    Procedure Clear
14822>>>>>        Boolean bOpOk
14822>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14823>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14825>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARING
14826>>>>>        End
14826>>>>>>
14826>>>>>        If (bOpOk) Begin
14828>>>>>            Send OnPreFind DDFindClear
14829>>>>>        End
14829>>>>>>
14829>>>>>        Forward Send Clear
14831>>>>>        If (bOpOk) Begin
14833>>>>>            Send DefaultParentAutofinds
14834>>>>>            Send OnPostFind DDFindClear True
14835>>>>>        End
14835>>>>>>
14835>>>>>    End_Procedure
14836>>>>>    
14836>>>>>    Procedure Clear_All
14838>>>>>        Boolean bOpOk
14838>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14839>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14841>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARINGALL
14842>>>>>        End
14842>>>>>>
14842>>>>>        Forward Send clear_all
14844>>>>>        If (bOpOk) Begin
14846>>>>>            Send DefaultParentAutofinds
14847>>>>>        End
14847>>>>>>
14847>>>>>    End_Procedure
14848>>>>>    
14848>>>>>    Procedure Request_Assign Integer iFile
14850>>>>>        Handle hoDD
14850>>>>>        Boolean bFound
14850>>>>>        Boolean bOpOk
14850>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14851>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14853>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
14854>>>>>        End
14854>>>>>>
14854>>>>>        
14854>>>>>        If (bOpOk) Begin
14856>>>>>            If (num_arguments=0 or iFile=0) Begin
14858>>>>>                Move Self to hoDD
14859>>>>>            End
14859>>>>>>
14859>>>>>            Else Begin
14860>>>>>                Get Data_Set iFile to hoDD
14861>>>>>            End
14861>>>>>>
14861>>>>>            If hoDD Begin
14863>>>>>                Send OnPreFind of hoDD DDFindRequestAssign
14864>>>>>            End
14864>>>>>>
14864>>>>>        End
14864>>>>>>
14864>>>>>        
14864>>>>>        If (num_arguments=0) Begin
14866>>>>>            Forward Send Request_Assign
14868>>>>>        End
14868>>>>>>
14868>>>>>        Else Begin
14869>>>>>            Forward Send Request_Assign iFile
14871>>>>>        End
14871>>>>>>
14871>>>>>        
14871>>>>>        If (bOpOk) Begin
14873>>>>>            If (hoDD) Begin
14875>>>>>                Move (Found) to bFound
14876>>>>>                Send OnPostFind of hoDD DDFindRequestAssign bFound
14877>>>>>                Move bFound to Found
14878>>>>>            End
14878>>>>>>
14878>>>>>        End
14878>>>>>>
14878>>>>>    End_Procedure
14879>>>>>    
14879>>>>>    
14879>>>>>    Procedure Find_By_Recnum Integer iFile Integer iRecord
14881>>>>>        Handle hoDD
14881>>>>>        Boolean bFound
14881>>>>>        Boolean bOpOk
14881>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14882>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
14883>>>>>        
14883>>>>>        If (bOpOk) Begin
14885>>>>>            Get Data_Set iFile to hoDD
14886>>>>>            If hoDD Begin
14888>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
14889>>>>>            End
14889>>>>>>
14889>>>>>        End
14889>>>>>>
14889>>>>>        
14889>>>>>        Forward Send Find_By_Recnum iFile iRecord
14891>>>>>        
14891>>>>>        If (bOpOk) Begin
14893>>>>>            If (hoDD) Begin
14895>>>>>                Move (Found) to bFound
14896>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
14897>>>>>                Move bFound to Found
14898>>>>>            End
14898>>>>>>
14898>>>>>        End
14898>>>>>>
14898>>>>>    End_Procedure
14899>>>>>    
14899>>>>>    Procedure FindByRowId Integer iFile RowID riRowId
14901>>>>>        Handle hoDD
14901>>>>>        Boolean bFound
14901>>>>>        Boolean bOpOk
14901>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14902>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
14903>>>>>        
14903>>>>>        If (bOpOk) Begin
14905>>>>>            Get Data_Set iFile to hoDD
14906>>>>>            If hoDD Begin
14908>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
14909>>>>>            End
14909>>>>>>
14909>>>>>        End
14909>>>>>>
14909>>>>>        
14909>>>>>        Forward Send FindByRowId iFile riRowId
14911>>>>>        
14911>>>>>        If (bOpOk) Begin
14913>>>>>            If (hoDD) Begin
14915>>>>>                Move (Found) to bFound
14916>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
14917>>>>>                Move bFound to Found
14918>>>>>            End
14918>>>>>>
14918>>>>>        End
14918>>>>>>
14918>>>>>    End_Procedure
14919>>>>>    
14919>>>>>    Function FindByRowIdEx Integer iFile RowID riRowId Returns Boolean
14921>>>>>        Handle hoDD
14921>>>>>        Boolean bFound bSuccess
14921>>>>>        Boolean bOpOk
14921>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14922>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
14923>>>>>        
14923>>>>>        If (bOpOk) Begin
14925>>>>>            Get Data_Set iFile to hoDD
14926>>>>>            If hoDD Begin
14928>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
14929>>>>>            End
14929>>>>>>
14929>>>>>        End
14929>>>>>>
14929>>>>>        
14929>>>>>        Forward Get FindByRowIdEx iFile riRowId to bSuccess
14931>>>>>        
14931>>>>>        If (bOpOk) Begin
14933>>>>>            If (hoDD) Begin
14935>>>>>                Move (Found) to bFound
14936>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
14937>>>>>                Move bFound to Found
14938>>>>>            End
14938>>>>>>
14938>>>>>        End
14938>>>>>>
14938>>>>>        Function_Return bSuccess
14939>>>>>    End_Function
14940>>>>>    
14940>>>>>    Function FindByRowIdExNoAutoFill Integer iFile RowID riRowId Returns Boolean
14942>>>>>        Handle hoDD
14942>>>>>        Boolean bFound bSuccess
14942>>>>>        Boolean bOpOk
14942>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14943>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
14944>>>>>        
14944>>>>>        If (bOpOk) Begin
14946>>>>>            Get Data_Set iFile to hoDD
14947>>>>>            If hoDD Begin
14949>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
14950>>>>>            End
14950>>>>>>
14950>>>>>        End
14950>>>>>>
14950>>>>>        
14950>>>>>        Forward Get FindByRowIdExNoAutoFill iFile riRowId to bSuccess
14952>>>>>        
14952>>>>>        If (bOpOk) Begin
14954>>>>>            If (hoDD) Begin
14956>>>>>                Move (Found) to bFound
14957>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
14958>>>>>                Move bFound to Found
14959>>>>>            End
14959>>>>>>
14959>>>>>        End
14959>>>>>>
14959>>>>>        Function_Return bSuccess
14960>>>>>    End_Function
14961>>>>>    
14961>>>>>    
14961>>>>>    Procedure Request_Find Integer eFindMode Integer iFile Integer iIndex
14963>>>>>        Handle hoDD
14963>>>>>        Boolean bFound
14963>>>>>        Boolean bOpOk
14963>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14964>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14966>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
14967>>>>>        End
14967>>>>>>
14967>>>>>        
14967>>>>>        If (bOpOk) Begin
14969>>>>>            Get Data_Set iFile to hoDD
14970>>>>>            If hoDD Begin
14972>>>>>                Send OnPreFind of hoDD DDFindRequestFind
14973>>>>>            End
14973>>>>>>
14973>>>>>        End
14973>>>>>>
14973>>>>>        
14973>>>>>        Forward Send Request_Find eFindMode iFile iIndex
14975>>>>>        
14975>>>>>        If (bOpOk) Begin
14977>>>>>            If (hoDD) Begin
14979>>>>>                Move (Found) to bFound
14980>>>>>                Send OnPostFind of hoDD DDFindRequestFind bFound
14981>>>>>                Move bFound to Found
14982>>>>>            End
14982>>>>>>
14982>>>>>        End
14982>>>>>>
14982>>>>>    End_Procedure
14983>>>>>    
14983>>>>>    Procedure OnPreFind Integer eMessage
14985>>>>>    End_Procedure
14986>>>>>    
14986>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
14988>>>>>    End_Procedure
14989>>>>>    
14989>>>>>    
14989>>>>>    
14989>>>>>    Procedure Request_Superfind Integer eFindMode Integer iFile Integer iField
14991>>>>>        Boolean bInSuperFind
14991>>>>>        // we need to set pbInSuperFind so Entry_update in the DEOs will know that
14991>>>>>        // they should perform an entry_update. Superfind entry_updates have never gone through
14991>>>>>        // the DD's field buffer.
14991>>>>>        Get pbInSuperFind to bInSuperFind
14992>>>>>        Set pbInSuperFind to True
14993>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14995>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
14996>>>>>        End
14996>>>>>>
14996>>>>>        Forward Send Request_Superfind eFindMode iFile iField
14998>>>>>        Set pbInSuperFind to bInSuperFind
14999>>>>>    End_Procedure
15000>>>>>    
15000>>>>>    // Augmented to return true if a non-constrained parent DD has a change. This way
15000>>>>>    // Should_Save_row only filters changes in a consrained parent.
15000>>>>>    
15000>>>>>    Function Should_Save_Row Returns Boolean
15002>>>>>        Boolean bShouldSaveRow bShouldSave bRelatesToConstraint
15002>>>>>        Integer iServers iServer iServerFile
15002>>>>>        Handle hoServerDD
15002>>>>>        Forward Get Should_Save_Row to bShouldSaveRow // will be true if this DD is changed or has a changed parent.
15004>>>>>        Get Should_Save to bShouldSave // will be true if there is a change anywhere up the entire save structure
15005>>>>>        If (not(bShouldSaveRow) and bShouldSave) Begin
15007>>>>>            // If here we have a changed in an server but not the this DD. We need a further refinement. If the server
15007>>>>>            // change is in a constrained server, we don't consider this a change because you can switch rows without losing
15007>>>>>            // data (with RT changes made for 17.0).
15007>>>>>            Get Data_Set_Server_Count to iServers
15008>>>>>            For iServer from 0 to (iServers-1)
15014>>>>>>
15014>>>>>                Get Data_Set_Server iServer to hoServerDD
15015>>>>>                Get Should_Save of hoServerDD to bShouldSave
15016>>>>>                If bShouldSave Begin
15018>>>>>                    Get Main_File of hoServerDD to iServerFile
15019>>>>>                    Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
15020>>>>>                    If not bRelatesToConstraint Begin
15022>>>>>                        Function_Return True
15023>>>>>                    End
15023>>>>>>
15023>>>>>                End
15023>>>>>>
15023>>>>>            Loop
15024>>>>>>
15024>>>>>        End
15024>>>>>>
15024>>>>>        Function_Return bShouldSaveRow
15025>>>>>    End_Function
15026>>>>>    
15026>>>>>    // returns true if any relates-to constraining server needs a save. Normally there will be
15026>>>>>    // one or zero related-to parents. If Should_Save_Row returns false it is possible that there
15026>>>>>    // is a change up the relates-to constrained branch. If so, this will return True. This can be
15026>>>>>    // used to better determine the changed status of your DDO sructure
15026>>>>>    Function ShouldSaveConstrainedToServer Returns Boolean
15028>>>>>        Boolean bShouldSave bRelatesToConstraint
15028>>>>>        Integer iServers iServer iServerFile
15028>>>>>        Handle hoServerDD
15028>>>>>        Get Data_Set_Server_Count to iServers
15029>>>>>        For iServer from 0 to (iServers-1)
15035>>>>>>
15035>>>>>            Get Data_Set_Server iServer to hoServerDD
15036>>>>>            Get Main_File of hoServerDD to iServerFile
15037>>>>>            Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
15038>>>>>            If bRelatesToConstraint Begin
15040>>>>>                Get Should_Save of hoServerDD to bShouldSave
15041>>>>>                If bShouldSave Begin
15043>>>>>                    Function_Return True
15044>>>>>                End
15044>>>>>>
15044>>>>>            End
15044>>>>>>
15044>>>>>        Loop
15045>>>>>>
15045>>>>>        Function_Return False
15046>>>>>    End_Function
15047>>>>>    
15047>>>>>    Function FindServerInformationElement Integer iFile Returns Integer
15049>>>>>        tDDServerInformation[] ServerInformation
15049>>>>>        tDDServerInformation[] ServerInformation
15050>>>>>        tDDServerInformation ServerSearch
15050>>>>>        tDDServerInformation ServerSearch
15050>>>>>        Integer iIndex
15050>>>>>        Move iFile to ServerSearch.iParent
15051>>>>>        Get pServerInformation to ServerInformation
15052>>>>>        Function_Return (SearchArray(ServerSearch,ServerInformation))
15053>>>>>    End_Function
15054>>>>>    
15054>>>>>    Procedure AddServerData Integer iFile Integer eParam Boolean bValue
15056>>>>>        tDDServerInformation[] ServerInformation
15056>>>>>        tDDServerInformation[] ServerInformation
15057>>>>>        Integer iIndex
15057>>>>>        Handle hoDDO
15057>>>>>        
15057>>>>>        Get pServerInformation to ServerInformation
15058>>>>>        Get FindServerInformationElement iFile to iIndex
15059>>>>>        If (iIndex=-1) Begin
15061>>>>>            Move (SizeOfArray(ServerInformation)) to iIndex
15062>>>>>            Move iFile to ServerInformation[iIndex].iParent
15063>>>>>            // defaults must always be false!
15063>>>>>            Move False to ServerInformation[iIndex].bParentNoSwitchIfCommitted
15064>>>>>            Move False to ServerInformation[iIndex].bAllowNullParent
15065>>>>>            Move False to ServerInformation[iIndex].bNoCascadeDelete
15066>>>>>            Move False to ServerInformation[iIndex].bCascadeDeleteNullTheParent
15067>>>>>        End
15067>>>>>>
15067>>>>>        
15067>>>>>        If (eParam=0) Begin
15069>>>>>            If (bValue<>ServerInformation[iIndex].bAllowNullParent) Begin
15071>>>>>                Move bValue to ServerInformation[iIndex].bAllowNullParent
15072>>>>>                Send AdjustDeleteValidateStructure iFile
15073>>>>>            End
15073>>>>>>
15073>>>>>        End
15073>>>>>>
15073>>>>>        Else If (eParam=1) Begin
15076>>>>>            Move bValue to ServerInformation[iIndex].bParentNoSwitchIfCommitted
15077>>>>>        End
15077>>>>>>
15077>>>>>        Else If (eParam=2) Begin
15080>>>>>            Move bValue to ServerInformation[iIndex].bNoCascadeDelete
15081>>>>>        End
15081>>>>>>
15081>>>>>        Else Begin // (3)
15082>>>>>            If (bValue<>ServerInformation[iIndex].bCascadeDeleteNullTheParent) Begin
15084>>>>>                Move bValue to ServerInformation[iIndex].bCascadeDeleteNullTheParent
15085>>>>>                Send AdjustDeleteValidateStructure iFile
15086>>>>>            End
15086>>>>>>
15086>>>>>        End
15086>>>>>>
15086>>>>>        Set pServerInformation to ServerInformation
15087>>>>>    End_Procedure
15088>>>>>    
15088>>>>>    Function GetServerData Integer iFile Integer eParam Returns Boolean
15090>>>>>        Boolean bValue
15090>>>>>        tDDServerInformation[] ServerInformation
15090>>>>>        tDDServerInformation[] ServerInformation
15091>>>>>        Integer iIndex
15091>>>>>        Get pServerInformation to ServerInformation
15092>>>>>        Get FindServerInformationElement iFile to iIndex
15093>>>>>        // when not found in array, we want to make sure that we return false. Therefore
15093>>>>>        // false should always be the default.
15093>>>>>        If (iIndex<>-1) Begin
15095>>>>>            If (eParam=0) Begin
15097>>>>>                Move ServerInformation[iIndex].bAllowNullParent to bValue
15098>>>>>            End
15098>>>>>>
15098>>>>>            Else If (eParam=1) Begin
15101>>>>>                Move ServerInformation[iIndex].bParentNoSwitchIfCommitted to bValue
15102>>>>>            End
15102>>>>>>
15102>>>>>            Else If (eParam=2) Begin
15105>>>>>                Move ServerInformation[iIndex].bNoCascadeDelete to bValue
15106>>>>>            End
15106>>>>>>
15106>>>>>            Else Begin
15107>>>>>                Move ServerInformation[iIndex].bCascadeDeleteNullTheParent to bValue
15108>>>>>            End
15108>>>>>>
15108>>>>>        End
15108>>>>>>
15108>>>>>        Function_Return bValue
15109>>>>>    End_Function
15110>>>>>    
15110>>>>>    Procedure AdjustDeleteValidateStructure2
15112>>>>>        Integer iCount i
15112>>>>>        Handle hoDDO
15112>>>>>        Boolean bVisited
15112>>>>>        Set Visited_State to True
15113>>>>>        Set Cascade_Delete_Structure_Validated_State to False
15114>>>>>        Get Data_Set_Server_Count to iCount
15115>>>>>        For i from 0 to (iCount-1)
15121>>>>>>
15121>>>>>            Get Data_Set_Server i to hoDDO
15122>>>>>            Get Visited_State of hoDDO to bVisited
15123>>>>>            If (not(bVisited)) Begin
15125>>>>>                Send AdjustDeleteValidateStructure2 of hoDDO
15126>>>>>            End
15126>>>>>>
15126>>>>>        Loop
15127>>>>>>
15127>>>>>    End_Procedure
15128>>>>>    
15128>>>>>    // This is called in the unlikely case that NullParent/CascadeNull are set dynamically. It
15128>>>>>    // tells the parent DDO to recheck its validate-delete structure and it tells all ancestors of
15128>>>>>    // this parent to do the same. If called while DDOs are being created (via a class setting) there
15128>>>>>    // will not be a connected parent for iFile, which is fine.
15128>>>>>    Procedure AdjustDeleteValidateStructure Integer iFile
15130>>>>>        Handle hoDDO
15130>>>>>        Get Which_Data_Set iFile to hoDDO
15131>>>>>        If hoDDO Begin
15133>>>>>            Send Initialize_Visited of hoDDO False False
15134>>>>>            Send AdjustDeleteValidateStructure2 of hoDDO
15135>>>>>        End
15135>>>>>>
15135>>>>>    End_Procedure
15136>>>>>    
15136>>>>>    // Used to add a null parent to the list of parents that allow this
15136>>>>>    Procedure Set ParentNullAllowed Integer iParent Boolean bAllowed
15138>>>>>        Send AddServerData iParent 0 bAllowed
15139>>>>>    End_Procedure
15140>>>>>    
15140>>>>>    // returns true if null parent allowed for this parent file
15140>>>>>    Function ParentNullAllowed Integer iParent Returns Boolean
15142>>>>>        Boolean bValue
15142>>>>>        Get GetServerData iParent 0 to bValue
15143>>>>>        Function_Return bValue
15144>>>>>    End_Function
15145>>>>>    
15145>>>>>    // returns true if null parent allowed for this parent file. This is the function
15145>>>>>    // that can be used for augmentation. This is the methid that is called by the runtime
15145>>>>>    // to determine if a null parent is allowed
15145>>>>>    Function IsNullParentAllowed Integer iServer Returns Boolean
15147>>>>>        Boolean bAllowed
15147>>>>>        Get ParentNullAllowed iServer to bAllowed
15148>>>>>        Function_Return bAllowed
15149>>>>>    End_Function
15150>>>>>    
15150>>>>>    Procedure Set ParentNoSwitchIfCommitted Integer iParent Boolean bAllowed
15152>>>>>        Send AddServerData iParent 1 bAllowed
15153>>>>>    End_Procedure
15154>>>>>    
15154>>>>>    Function ParentNoSwitchIfCommitted Integer iParent Returns Boolean
15156>>>>>        Boolean bValue
15156>>>>>        Get GetServerData iParent 1 to bValue
15157>>>>>        Function_Return bValue
15158>>>>>    End_Function
15159>>>>>    
15159>>>>>    
15159>>>>>    Procedure Set CascadeDeleteAllowed Integer iParent Boolean bAllowed
15161>>>>>        Send AddServerData iParent 2 (not(bAllowed))
15162>>>>>    End_Procedure
15163>>>>>    
15163>>>>>    Function CascadeDeleteAllowed Integer iParent Returns Boolean
15165>>>>>        Boolean bValue
15165>>>>>        Get GetServerData iParent 2 to bValue // note that False=allowed
15166>>>>>        Function_Return (not(bValue))
15167>>>>>    End_Function
15168>>>>>    
15168>>>>>    Function IsCascadeDeleteAllowed Integer iServer Returns Boolean
15170>>>>>        Boolean bAllowed
15170>>>>>        Get CascadeDeleteAllowed iServer to bAllowed
15171>>>>>        Function_Return bAllowed
15172>>>>>    End_Function
15173>>>>>    
15173>>>>>    Procedure Set CascadeDeleteNull Integer iParent Boolean bAllowed
15175>>>>>        Send AddServerData iParent 3 bAllowed
15176>>>>>    End_Procedure
15177>>>>>    
15177>>>>>    Function CascadeDeleteNull Integer iParent Returns Boolean
15179>>>>>        Boolean bValue
15179>>>>>        Get GetServerData iParent 3 to bValue
15180>>>>>        Function_Return bValue
15181>>>>>    End_Function
15182>>>>>    
15182>>>>>    Function IsCascadeDeleteNull Integer iServer Returns Boolean
15184>>>>>        Boolean bAllowed
15184>>>>>        Get CascadeDeleteNull iServer to bAllowed
15185>>>>>        Function_Return bAllowed
15186>>>>>    End_Function
15187>>>>>    
15187>>>>>    // return an array with the server path from this DD to passed top. The top will be
15187>>>>>    // in 0 and its child in 1, grand-child in 2, etc. If empty, no path was found. To start
15187>>>>>    // this process the byref hoDDs array MUST be empty
15187>>>>>    Procedure DDOServerPath Handle hoTop Handle[] ByRef hoDDs
15189>>>>>        Handle hoServer
15189>>>>>        Integer iServers iServer
15189>>>>>        If (hoTop=Self) Begin
15191>>>>>            Move Self to hoDDs[SizeOfArray(hoDDs)]
15192>>>>>            Procedure_Return
15193>>>>>        End
15193>>>>>>
15193>>>>>        Get Data_Set_Server_Count to iServers
15194>>>>>        For iServer from 0 to (iServers-1)
15200>>>>>>
15200>>>>>            Get Data_Set_Server iServer to hoServer
15201>>>>>            Send DDOServerPath of hoServer hoTop (&hoDDs)
15202>>>>>            If (SizeOfArray(hoDDs)) Begin
15204>>>>>                Move Self to hoDDs[SizeOfArray(hoDDs)]
15205>>>>>                Procedure_Return
15206>>>>>            End
15206>>>>>>
15206>>>>>        Loop
15207>>>>>>
15207>>>>>    End_Procedure
15208>>>>>    
15208>>>>>    // returns True if the value passed can be considered empty for this field.
15208>>>>>    Function IsEmptyField Integer iField String sValue Returns Boolean
15210>>>>>        Integer iFile iDataType iValidationType
15210>>>>>        Number nNum
15210>>>>>        Boolean bInvalid bChecked
15210>>>>>        Get Main_File to iFile
15211>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iDataType
15214>>>>>        Get IsDataInvalid iDataType sValue to bInvalid
15215>>>>>        If bInvalid Begin
15217>>>>>            Function_Return True
15218>>>>>        End
15218>>>>>>
15218>>>>>        
15218>>>>>        // DDs set checkbox fields to the False value as default. We must test its select_state
15218>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField to iValidationType
15219>>>>>        If (iValidationType=FA_VALIDATION_TYPE_CHECKBOX) Begin
15221>>>>>            Get Field_Select_State iField to bChecked
15222>>>>>            If not bChecked Begin
15224>>>>>                Function_Return True
15225>>>>>            End
15225>>>>>>
15225>>>>>        End
15225>>>>>>
15225>>>>>        
15225>>>>>        If ((iDataType=DF_BCD or iDataType=DF_DATE) and (Number(sValue)=0)) Begin
15227>>>>>            Move "" to sValue
15228>>>>>        End
15228>>>>>>
15228>>>>>        Else If (iDataType=DF_DATETIME and IsNullDateTime(cast(sValue,DateTime))) Begin
15231>>>>>            Move "" to sValue
15232>>>>>        End
15232>>>>>>
15232>>>>>        Function_Return (sValue="")
15233>>>>>    End_Function
15234>>>>>    
15234>>>>>    
15234>>>>>    // is the record committed
15234>>>>>    Function IsCommitted Returns Boolean
15236>>>>>        Boolean bHasRecord
15236>>>>>        Get HasRecord to bHasRecord
15237>>>>>        Function_Return bHasRecord
15238>>>>>    End_Function
15239>>>>>    
15239>>>>>    // is the field committed. It assumes the record is already committed
15239>>>>>    Function IsFieldCommitted Integer iField Returns Boolean
15241>>>>>        Boolean bIsCommitted
15241>>>>>        Get Field_Option iField DD_COMMIT to bIsCommitted
15242>>>>>        Function_Return bIsCommitted
15243>>>>>    End_Function
15244>>>>>    
15244>>>>>    // is a parent change allowed for this parent server.
15244>>>>>    Function IsCommittedParentChangeAllowed Integer iServer Returns Boolean
15246>>>>>        Boolean bNoSwitch
15246>>>>>        Get ParentNoSwitchIfCommitted iServer to bNoSwitch
15247>>>>>        Function_Return (not(bNoSwitch))
15248>>>>>    End_Function
15249>>>>>    
15249>>>>>    // Are we allowed to find with this file when it is used as a parent?
15249>>>>>    // Check all child DDOs and see if any are committed and do not allow switching parents when committed.
15249>>>>>    //  The rules for each child are switching is ok If:
15249>>>>>    // 1. the child is not committed,
15249>>>>>    // 2. it has a relates-to constraint (Find will change child which is ok)
15249>>>>>    // 3. if IsCommittedParentChangeAllowed allowed.
15249>>>>>    //
15249>>>>>    Function AllowParentFind Returns Boolean
15251>>>>>        Integer iClients iClient iMain
15251>>>>>        Handle hoChild
15251>>>>>        Boolean bIsCommitted
15251>>>>>        Get Data_Set_Client_Count to iClients
15252>>>>>        For iClient from 0 to (iClients-1)
15258>>>>>>
15258>>>>>            Get Data_Set_Client iClient to hoChild
15259>>>>>            Get IsCommitted of hoChild to bIsCommitted
15260>>>>>            If bIsCommitted Begin
15262>>>>>                Get Main_File to iMain
15263>>>>>                Get IsRelatesToConstrained of hoChild iMain to bIsCommitted
15264>>>>>                If not bIsCommitted Begin
15266>>>>>                    Get IsCommittedParentChangeAllowed of hoChild iMain to bIsCommitted
15267>>>>>                    If (not(bIsCommitted)) Begin
15269>>>>>                        Function_Return False
15270>>>>>                    End
15270>>>>>>
15270>>>>>                End
15270>>>>>>
15270>>>>>            End
15270>>>>>>
15270>>>>>        Loop
15271>>>>>>
15271>>>>>        Function_Return True
15272>>>>>    End_Function
15273>>>>>    
15273>>>>>    // aumgented to do nothing if there is no index (instead of annoying error message) and
15273>>>>>    // to do nothing if a find is not allowed because it is a no switch parent of a committed child.
15273>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
15275>>>>>        
15275>>>>>        Integer iIndex iMain
15275>>>>>        Handle  hoOwner
15275>>>>>        Boolean bOk
15275>>>>>        
15275>>>>>        Get File_Field_Index iFile iField to iIndex
15276>>>>>        If (iIndex=-1)  Begin
15278>>>>>            Procedure_Return
15279>>>>>        End
15279>>>>>>
15279>>>>>        Get Main_File to iMain
15280>>>>>        If (iMain<>iFile) Begin
15282>>>>>            Get Which_Data_Set iFile to hoOwner
15283>>>>>            If hoOwner Begin
15285>>>>>                Get AllowParentFind of hoOwner to bOk
15286>>>>>                If not bOk Begin
15288>>>>>                    Procedure_Return
15289>>>>>                End
15289>>>>>>
15289>>>>>            End
15289>>>>>>
15289>>>>>        End
15289>>>>>>
15289>>>>>        
15289>>>>>        If not bDeferred Begin
15291>>>>>            Send Refind_Records // make sure the buffers are correct before the find
15292>>>>>        End
15292>>>>>>
15292>>>>>        
15292>>>>>        Forward Send Item_Find eFindMode iFile iField bDoEntryUpdate bShowFindErr bDeferred
15294>>>>>    End_Procedure
15295>>>>>    
15295>>>>>    
15295>>>>>    Function Field_CommitNoEnterOnIndex Integer iField Returns Boolean
15297>>>>>        Function_Return False
15298>>>>>    End_Function
15299>>>>>    
15299>>>>>    // Return the committed options for this field based on the committed status or this record,
15299>>>>>    // the committed status of the field and whether, if committed, it should be noput or noput+noenter
15299>>>>>    Function File_Field_Committed_Options Integer iFile Integer iField Returns Integer
15301>>>>>        Boolean bIsCommitted bNoEnter
15301>>>>>        Integer iNewOpts iIndex
15301>>>>>        Handle hoOwner
15301>>>>>        
15301>>>>>        Get Which_Data_Set iFile to hoOwner
15302>>>>>        If not hoOwner ;            Function_Return 0
15305>>>>>        
15305>>>>>        Get File_Field_Index iFile iField to iIndex
15306>>>>>        Get IsCommitted of hoOwner iField to bIsCommitted
15307>>>>>        If bIsCommitted Begin
15309>>>>>            Get IsFieldCommitted of hoOwner iField to bIsCommitted
15310>>>>>            If bIsCommitted Begin
15312>>>>>                Move True to bNoEnter
15313>>>>>                If (iIndex<>-1) Begin
15315>>>>>                    Get Field_CommitNoEnterOnIndex iField to bNoEnter
15316>>>>>                End
15316>>>>>>
15316>>>>>                // if committed, it is noput and, if non-indexed, also noenter
15316>>>>>                Move (If(bNoEnter,DD_DISPLAYONLY,DD_NOPUT)) to iNewOpts
15317>>>>>            End
15317>>>>>>
15317>>>>>        End
15317>>>>>>
15317>>>>>        // if a finding parent field, we want to know if you are allowed to switch parents as we will assume
15317>>>>>        // that this field is used for finding.
15317>>>>>        If (hoOwner<>Self and iIndex>-1) Begin
15319>>>>>            Get AllowParentFind of hoOwner to bIsCommitted
15320>>>>>            If not bIsCommitted Begin
15322>>>>>                Move DD_DISPLAYONLY to iNewOpts
15323>>>>>            End
15323>>>>>>
15323>>>>>        End
15323>>>>>>
15323>>>>>        
15323>>>>>        Function_Return iNewOpts
15324>>>>>    End_Function
15325>>>>>    
15325>>>>>    // Returns the current field-field options based on regular options, foreign field status
15325>>>>>    // plus committed record status
15325>>>>>    Function File_Field_DynamicEntryOptions Integer iFile Integer iField Returns Integer
15327>>>>>        Integer iCOpts iFOpts
15327>>>>>        If (iFile=0) Begin
15329>>>>>            Function_Return 0
15330>>>>>        End
15330>>>>>>
15330>>>>>        Get File_Field_Options iFile iField to iFOpts            // regular options (handles regular and foreign)
15331>>>>>        Get File_Field_Committed_Options iFile iField to iCOpts  // possible NoPut, NoEnter additions
15332>>>>>        Function_Return (iFOpts ior iCOpts)
15333>>>>>    End_Function
15334>>>>>    
15334>>>>>    Function DDRememberedFieldIndex Integer iField Returns Integer
15336>>>>>        tDDRemembered[] DefaultValues
15336>>>>>        tDDRemembered[] DefaultValues
15337>>>>>        tDDRemembered SearchItem
15337>>>>>        tDDRemembered SearchItem
15337>>>>>        Integer iIndex
15337>>>>>        Get pDDDefaults to DefaultValues
15338>>>>>        Move iField to SearchItem.iField
15339>>>>>        Move (SearchArray(SearchItem,DefaultValues)) to iIndex
15340>>>>>        Function_Return iIndex
15341>>>>>    End_Function
15342>>>>>    
15342>>>>>    // Interface used to set or clear a dynamic default (remembered) value for a DD field. If the
15342>>>>>    // value passed is empty ("" or as empty as defined by the data-type) it is cleared. If the value
15342>>>>>    // is DD_RememberLast, it will use the last value before a clear as the default, else it uses the
15342>>>>>    // passed value as the default
15342>>>>>    Procedure Set Field_RememberedValue Integer iField String sValue
15344>>>>>        tDDRemembered[] DefaultValues
15344>>>>>        tDDRemembered[] DefaultValues
15345>>>>>        Integer iIndex
15345>>>>>        Boolean bNull
15345>>>>>        Get DDRememberedFieldIndex iField to iIndex
15346>>>>>        Get pDDDefaults to DefaultValues
15347>>>>>        If (sValue<>DD_RememberLast) Begin // if it is rememberlast, we know it is not null
15349>>>>>            Get IsEmptyField iField sValue to bNull
15350>>>>>        End
15350>>>>>>
15350>>>>>        If (not(bNull)) Begin
15352>>>>>            If (iIndex=-1) Begin
15354>>>>>                Move (SizeOfArray(DefaultValues)) to iIndex
15355>>>>>                Move iField to DefaultValues[iIndex].iField
15356>>>>>            End
15356>>>>>>
15356>>>>>            Move sValue to DefaultValues[iIndex].sDefault
15357>>>>>            Set pDDDefaults to DefaultValues
15358>>>>>        End
15358>>>>>>
15358>>>>>        Else If  (iIndex<>-1) Begin
15361>>>>>            Set pDDDefaults to (RemoveFromArray(DefaultValues,iIndex))
15362>>>>>        End
15362>>>>>>
15362>>>>>    End_Procedure
15363>>>>>    
15363>>>>>    // get the remembered value as per rules above
15363>>>>>    Function Field_RememberedValue Integer iField Returns String
15365>>>>>        tDDRemembered[] DefaultValues
15365>>>>>        tDDRemembered[] DefaultValues
15366>>>>>        Integer iIndex
15366>>>>>        Get DDRememberedFieldIndex iField to iIndex
15367>>>>>        If (iIndex<>-1) Begin
15369>>>>>            Get pDDDefaults to DefaultValues
15370>>>>>            Function_Return DefaultValues[iIndex].sDefault
15371>>>>>        End
15371>>>>>>
15371>>>>>        Function_Return ''
15372>>>>>    End_Function
15373>>>>>    
15373>>>>>    Procedure AssignDynamicDefaults
15375>>>>>        Integer iField iFields iFile
15375>>>>>        tDDRemembered[] DefaultValues
15375>>>>>        tDDRemembered[] DefaultValues
15376>>>>>        Boolean bMain
15376>>>>>        String sValue
15376>>>>>        
15376>>>>>        Get Main_File to iFile
15377>>>>>        Get pDDDefaults to DefaultValues
15378>>>>>        Move (SizeOfArray(DefaultValues)) to iFields
15379>>>>>        For iField from 0 to (iFields-1)
15385>>>>>>
15385>>>>>            If ( DefaultValues[iField].sDefault<>"") Begin
15387>>>>>                If (DefaultValues[iField].sDefault=DD_RememberLast) Begin
15389>>>>>                    Move DefaultValues[iField].sLastValue to sValue
15390>>>>>                End
15390>>>>>>
15390>>>>>                Else Begin
15391>>>>>                    Move DefaultValues[iField].sDefault to sValue
15392>>>>>                End
15392>>>>>>
15392>>>>>                Set Field_Changed_Value DefaultValues[iField].iField to sValue
15393>>>>>            End
15393>>>>>>
15393>>>>>        Loop
15394>>>>>>
15394>>>>>    End_Procedure
15395>>>>>    
15395>>>>>    // Clears all remembered defaults for this DD.
15395>>>>>    Procedure ClearRememberedDefaults
15397>>>>>        tDDRemembered[] DefaultValues
15397>>>>>        tDDRemembered[] DefaultValues
15398>>>>>        Set pDDDefaults to DefaultValues
15399>>>>>    End_Procedure
15400>>>>>    
15400>>>>>    Procedure PrivateClearAllRememberedDefaults
15402>>>>>        Integer iCount iMax
15402>>>>>        Handle hoDD
15402>>>>>        Boolean bVisisted
15402>>>>>        
15402>>>>>        Set Visited_State to True
15403>>>>>        
15403>>>>>        Get Data_Set_Server_Count to iMax
15404>>>>>        Decrement iMax
15405>>>>>        For iCount from 0 to iMax
15411>>>>>>
15411>>>>>            Get Data_Set_Server iCount to hoDD
15412>>>>>            Get Visited_State of hoDD to bVisisted
15413>>>>>            If not (bVisisted) Begin
15415>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
15416>>>>>            End
15416>>>>>>
15416>>>>>        Loop
15417>>>>>>
15417>>>>>        
15417>>>>>        Send ClearRememberedDefaults
15418>>>>>        
15418>>>>>        Get Data_Set_Client_Count to iMax
15419>>>>>        Decrement iMax
15420>>>>>        For iCount from 0 to iMax
15426>>>>>>
15426>>>>>            Get Data_Set_Client iCount to hoDD
15427>>>>>            Get Visited_State of hoDD to bVisisted
15428>>>>>            If not (bVisisted) Begin
15430>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
15431>>>>>            End
15431>>>>>>
15431>>>>>        Loop
15432>>>>>>
15432>>>>>        
15432>>>>>    End_Procedure
15433>>>>>    
15433>>>>>    // Clears all remembered defaults for all DDs in this structure.
15433>>>>>    Procedure ClearAllRememberedDefaults
15435>>>>>        Send InitializeAllVisited
15436>>>>>        Send PrivateClearAllRememberedDefaults
15437>>>>>    End_Procedure
15438>>>>>    
15438>>>>>    // This is called after a clear or clear all is sent to this DD. It does autofinds as needed
15438>>>>>    // for any parent DDs. It does this if the parent is not a relates to contraining parent, if
15438>>>>>    // a field has an index, it has a changed value and it is autofind or autofind_ge.
15438>>>>>    Procedure DefaultParentAutofinds
15440>>>>>        Integer i iServers iField iFields iFile iIndex iOpts
15440>>>>>        Boolean bDoAutoFind bRelates bIsEmptyField
15440>>>>>        String sValue
15440>>>>>        Handle hoServer
15440>>>>>        Get Data_Set_Server_Count to iServers
15441>>>>>        For i from 0 to (iServers-1)
15447>>>>>>
15447>>>>>            Get Data_Set_Server i to hoServer
15448>>>>>            Get Main_File of hoServer to iFile
15449>>>>>            Get IsRelatesToConstrained iFile to bRelates
15450>>>>>            // never autofind on a relates-to constraining parent
15450>>>>>            If not (bRelates) Begin
15452>>>>>                
15452>>>>>                Get Field_Count of hoServer to iFields
15453>>>>>                Move False to bDoAutoFind
15454>>>>>                Move 1 to iField
15455>>>>>                While (not(bDoAutoFind) and (iField<=iFields))
15459>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
15462>>>>>                    If (iIndex>0) Begin
15464>>>>>                        Get Field_Changed_State of hoServer iField to bDoAutoFind
15465>>>>>                        If bDoAutoFind Begin
15467>>>>>                            Get Field_Current_Value of hoServer iField to sValue
15468>>>>>                            Get IsEmptyField of hoServer iField sValue to bIsEmptyField
15469>>>>>                            Move (not(bIsEmptyField)) to bDoAutoFind
15470>>>>>                            If bDoAutoFind Begin
15472>>>>>                                Get File_Field_Options iFile iField to iOpts
15473>>>>>                                // if this is a retain or retainall we don't do this because we want
15473>>>>>                                // to maintain backwards compatibility
15473>>>>>                                Move ( (iOpts iand DD_AUTOFIND or iOpts iand DD_AUTOFIND_GE) and ;                                    not( iOpts iand DD_RETAIN or iOpts iand DD_RETAINALL) ) to bDoAutoFind
15474>>>>>                                If bDoAutoFind Begin
15476>>>>>                                    Send File_Field_Default_AutoFind iFile iField
15477>>>>>                                    Set Changed_State to False // clears parent changed state
15478>>>>>                                End
15478>>>>>>
15478>>>>>                            End
15478>>>>>>
15478>>>>>                        End
15478>>>>>>
15478>>>>>                    End
15478>>>>>>
15478>>>>>                    Increment iField
15479>>>>>                Loop
15480>>>>>>
15480>>>>>                
15480>>>>>                // Only check for grandparent autofinds if this parent did not do a an autofind
15480>>>>>                // Doing an autofind on an autofind parent's parent is just too confusing
15480>>>>>                If not bDoAutoFind Begin
15482>>>>>                    Send DefaultParentAutofinds of hoServer
15483>>>>>                End
15483>>>>>>
15483>>>>>            End
15483>>>>>>
15483>>>>>        Loop
15484>>>>>>
15484>>>>>    End_Procedure
15485>>>>>    
15485>>>>>    // Set this DD to be an alias, passing the file number of the alias
15485>>>>>    // This can only be called once per instance and the Main_File must already have been set
15485>>>>>    // most likely in a superclass.
15485>>>>>    // This sets Main_File to the alias, stores the original master file (accessed via MasterForAlias).
15485>>>>>    // It also clears all existing relatonships. Normally we expect the alias class to set
15485>>>>>    // sets pbUseDDRelates and pbNoCascadeDeleteStrict to true. We don't do that automatically so that
15485>>>>>    // the Studio's property panel will show the correct values. When an alias is defined using the
15485>>>>>    // studio it will set these two properties.
15485>>>>>    // This means you must set any required relationships yourself
15485>>>>>    Procedure Set Alias_File Integer iTable
15487>>>>>        Integer iMain iMaster iFieldsM iFieldsA
15487>>>>>        Get Main_File to iMain
15488>>>>>        Get MasterForAlias to iMaster
15489>>>>>        
15489>>>>>        If (iTable=0 and iMaster) Begin
15491>>>>>            Error DFERR_PROGRAM "Cannot unset alias table"
15492>>>>>>
15492>>>>>            Procedure_Return
15493>>>>>        End
15493>>>>>>
15493>>>>>        If (iTable=iMain) Begin
15495>>>>>            Error DFERR_PROGRAM "Cannot set alias table to self"
15496>>>>>>
15496>>>>>            Procedure_Return
15497>>>>>        End
15497>>>>>>
15497>>>>>        If (iMaster) Begin
15499>>>>>            Error DFERR_PROGRAM "Cannot redefine alias table"
15500>>>>>>
15500>>>>>            Procedure_Return
15501>>>>>        End
15501>>>>>>
15501>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iMain to iFieldsM
15504>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iFieldsA
15507>>>>>        If (iFieldsA<>iFieldsM) Begin
15509>>>>>            Error DFERR_PROGRAM "Alias and Master file are not based on the same table"
15510>>>>>>
15510>>>>>            Procedure_Return
15511>>>>>        End
15511>>>>>>
15511>>>>>        
15511>>>>>        Set piMasterTable to iMain
15512>>>>>        Set Main_File to iTable
15513>>>>>        Send DefineAsAlias
15514>>>>>    End_Procedure
15515>>>>>    
15515>>>>>    Procedure DefineAsAlias
15517>>>>>        Integer i iFile
15517>>>>>        
15517>>>>>        // We expect he developer to set these properties to True
15517>>>>>        //Set pbUseDDRelates to True
15517>>>>>        //Set pbNoCascadeDeleteStrict to True
15517>>>>>        
15517>>>>>        Send ClearDDRelates
15518>>>>>        Get Client_File_Count to i
15519>>>>>        While i
15523>>>>>            Decrement i
15524>>>>>            Get Client_File i to iFile
15525>>>>>            Send Remove_Client_File iFile
15526>>>>>        Loop
15527>>>>>>
15527>>>>>        Get Server_File_Count to i
15528>>>>>        While i
15532>>>>>            Decrement i
15533>>>>>            Get Server_File i to iFile
15534>>>>>            Send Remove_Server_File iFile
15535>>>>>        Loop
15536>>>>>>
15536>>>>>    End_Procedure
15537>>>>>    
15537>>>>>    Function MasterForAlias Returns Integer
15539>>>>>        Integer iMaster
15539>>>>>        Get piMasterTable to iMaster
15540>>>>>        Function_Return iMaster
15541>>>>>    End_Function
15542>>>>>    
15542>>>>>    Function IsAlias Returns Boolean
15544>>>>>        Integer iMaster
15544>>>>>        Get piMasterTable to iMaster
15545>>>>>        Function_Return (iMaster<>0)
15546>>>>>    End_Function
15547>>>>>    
15547>>>>>    
15547>>>>>    Procedure OnSaveRecord
15549>>>>>    End_Procedure
15550>>>>>    
15550>>>>>    Procedure StoreDefaultSQLFilters
15552>>>>>        Handle hoSQLHelper
15552>>>>>        Get phoSQLHelper to hoSQLHelper
15553>>>>>        Send StoreDefaultSQLFilters of hoSQLHelper
15554>>>>>    End_Procedure
15555>>>>>    
15555>>>>>    Procedure RestoreDefaultSQLFilters
15557>>>>>        Handle hoSQLHelper
15557>>>>>        Get phoSQLHelper to hoSQLHelper
15558>>>>>        Send RestoreDefaultSQLFilters of hoSQLHelper
15559>>>>>    End_Procedure
15560>>>>>    
15560>>>>>    Procedure ApplySQLFilterStr String sFilter
15562>>>>>        Handle hoSQLHelper
15562>>>>>        Get phoSQLHelper to hoSQLHelper
15563>>>>>        Send ApplySQLFilterStr of hoSQLHelper sFilter
15564>>>>>    End_Procedure
15565>>>>>    
15565>>>>>    
15565>>>>>    Procedure ApplySQLFilter
15567>>>>>        String sNewFilter sOldFilter
15567>>>>>        Boolean bApplyGlobalSQLFilters bOldFilterActive
15567>>>>>        Handle hoSQLHelper
15567>>>>>        Get phoSQLHelper to hoSQLHelper
15568>>>>>        Get psSQLFilter to sNewFilter
15569>>>>>        // if we have am active  table filter we can either ignore it or and it to the where clause
15569>>>>>        // pbApplyGlobalSQLFilters determines what to do.
15569>>>>>        Get pbApplyGlobalSQLFilters to bApplyGlobalSQLFilters
15570>>>>>        Get pbOldFilterActive to bOldFilterActive
15571>>>>>        If (bApplyGlobalSQLFilters and bOldFilterActive) Begin
15573>>>>>            Get psOldFilter to sOldFilter
15574>>>>>            Get SQLStrAppend sOldFilter sNewFilter to sNewFilter
15575>>>>>        End
15575>>>>>>
15575>>>>>        Send ApplySQLFilterStr of hoSQLHelper sNewFilter
15576>>>>>    End_Procedure
15577>>>>>    
15577>>>>>    Procedure Data_Set_PreFind
15579>>>>>        Boolean bUseDDSQLFilters
15579>>>>>        String sOldDDFilter
15579>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
15580>>>>>        If bUseDDSQLFilters Begin
15582>>>>>            
15582>>>>>            Send StoreDefaultSQLFilters
15583>>>>>            
15583>>>>>            // this can get called during cascade deletes. In such a case we will
15583>>>>>            // never explicitly not apply an SQL filters because it could violate relational integrity
15583>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
15585>>>>>                Get psSQLFilter to sOldDDFilter
15586>>>>>                Set psSQLFilter to "" // make sure there is no filter applied
15587>>>>>            End
15587>>>>>>
15587>>>>>            
15587>>>>>            Send ApplySQLFilter
15588>>>>>            
15588>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
15590>>>>>                Set psSQLFilter to sOldDDFilter
15591>>>>>            End
15591>>>>>>
15591>>>>>        End
15591>>>>>>
15591>>>>>    End_Procedure
15592>>>>>    
15592>>>>>    Procedure Data_Set_PostFind
15594>>>>>        Boolean bUseDDSQLFilters
15594>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
15595>>>>>        If bUseDDSQLFilters Begin
15597>>>>>            Send RestoreDefaultSQLFilters
15598>>>>>        End
15598>>>>>>
15598>>>>>    End_Procedure
15599>>>>>    
15599>>>>>    
15599>>>>>    // returns active constraints in atConstraintDef array.
15599>>>>>    // Should be called after constraints are built
15599>>>>>    // typically right after Rebuild_Constraints
15599>>>>>    
15599>>>>>    Function DDOConstraints Returns tConstraintDef[]
15601>>>>>        tConstraintDef[] Constraints
15601>>>>>        tConstraintDef[] Constraints
15602>>>>>        Integer i iCount i1
15602>>>>>        Get DATA_SET_CONSTRAINT_COUNT to iCount
15603>>>>>        For i from 0 to (iCount-1)
15609>>>>>>
15609>>>>>            Get DATA_SET_CONSTRAINT_INFO i 0 to i1 // type / mode
15610>>>>>            Move (Hi(i1)) to  Constraints[i].eType
15611>>>>>            Move (Low(i1)) to  Constraints[i].eMode
15612>>>>>            Get DATA_SET_CONSTRAINT_INFO i 1 to i1 // file / field
15613>>>>>            Move (Hi(i1)) to  Constraints[i].iFile
15614>>>>>            Move (Low(i1)) to  Constraints[i].iField
15615>>>>>            Get DATA_SET_CONSTRAINT_INFO i 2 to i1 // other file /field
15616>>>>>            Move (Hi(i1)) to  Constraints[i].iOtherFile
15617>>>>>            Move (Low(i1)) to  Constraints[i].iOtherField
15618>>>>>            Get DATA_SET_CONSTRAINT_INFO_Value i  to Constraints[i].sValue
15619>>>>>        Loop
15620>>>>>>
15620>>>>>        Function_Return Constraints
15621>>>>>    End_Function
15622>>>>>    
15622>>>>>    // returns constraint finding information about the current find. This tells us what kinds
15622>>>>>    // of constraint find "expressions" are used. This will actually do a cosntrained find
15622>>>>>    // initialization much like Establish_Find_Direction, which means it can change the values in
15622>>>>>    // the file buffer to assist with a jump-in.
15622>>>>>    Function DDOConstraintFindMeta Integer eMode Integer iOrder Returns tDDOConstraintFindMeta
15624>>>>>        tDDOConstraintFindMeta FindMeta
15624>>>>>        tDDOConstraintFindMeta FindMeta
15624>>>>>        Integer i
15624>>>>>        Get Data_Set_Constraint_Exps eMode iOrder to i
15625>>>>>        Move (Hi(i)) to FindMeta.iJumpInSegments
15626>>>>>        Move (i iand CONST_EXP_JUMPOUT) to FindMeta.bJumpOut
15627>>>>>        Move (i iand CONST_EXP_PRE_RELATE) to FindMeta.bPreRelate
15628>>>>>        Move (i iand CONST_EXP_POST_RELATE) to FindMeta.bPostRelate
15629>>>>>        Function_Return FindMeta
15630>>>>>    End_Function
15631>>>>>    
15631>>>>>    // this tells you if the current find or read requires a relate to evaluate the DF constraint.
15631>>>>>    // If false you could use this to set no_relate_state to false for the find/read process and then
15631>>>>>    // restore it when complete. Be careful using this.
15631>>>>>    Function DDOConstraintNeedsRelate Integer iOrder Returns Boolean
15633>>>>>        tDDOConstraintFindMeta FindMeta
15633>>>>>        tDDOConstraintFindMeta FindMeta
15633>>>>>        Get DDOConstraintFindMeta (GE) iOrder to FindMeta
15634>>>>>        Function_Return FindMeta.bPostRelate
15635>>>>>    End_Function
15636>>>>>    
15636>>>>>    // returns true if this table supports SQL filter interface
15636>>>>>    Function SupportsSQLFilters Returns Boolean
15638>>>>>        Boolean bSupports
15638>>>>>        Handle hoSQLHelper
15638>>>>>        Get phoSQLHelper to hoSQLHelper
15639>>>>>        Get SupportsSQLFilters of hoSQLHelper to bSupports
15640>>>>>        Function_Return bSupports
15641>>>>>    End_Function
15642>>>>>    
15642>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
15642>>>>>    
15642>>>>>    // Creates an SQL Like Filter for this field and search target
15642>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
15644>>>>>        String sFilter
15644>>>>>        Handle hoSQLHelper
15644>>>>>        Get phoSQLHelper to hoSQLHelper
15645>>>>>        Get SQLStrLike of hoSQLHelper iField sSearch to sFilter
15646>>>>>        Function_Return sFilter
15647>>>>>    End_Function
15648>>>>>    
15648>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15648>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
15650>>>>>        Handle hoSQLHelper
15650>>>>>        Get phoSQLHelper to hoSQLHelper
15651>>>>>        Get SQLStrAppend of hoSQLHelper sOrigFilter sFilter to sFilter
15652>>>>>        Function_Return sFilter
15653>>>>>    End_Function
15654>>>>>    
15654>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15654>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
15656>>>>>        Handle hoSQLHelper
15656>>>>>        Get phoSQLHelper to hoSQLHelper
15657>>>>>        Get SQLStrAppendOr of hoSQLHelper sOrigFilter sFilter to sFilter
15658>>>>>        Function_Return sFilter
15659>>>>>    End_Function
15660>>>>>
15660>>>>>    // returns the name of the File and Field suitable for an SQL where statement
15660>>>>>    Function SQLStrFileFieldName Integer iField Returns String
15662>>>>>        String sName
15662>>>>>        Handle hoSQLHelper
15662>>>>>        Get phoSQLHelper to hoSQLHelper
15663>>>>>        Get SQLStrFileFieldName of hoSQLHelper iField to sName
15664>>>>>        Function_Return sName
15665>>>>>    End_Function
15666>>>>>
15666>>>>>    // returns the name of the Field suitable for an SQL where statement
15666>>>>>    Function SQLStrFieldName Integer iField Returns String
15668>>>>>        String sName
15668>>>>>        Handle hoSQLHelper
15668>>>>>        Get phoSQLHelper to hoSQLHelper
15669>>>>>        Get SQLStrFieldName of hoSQLHelper iField to sName
15670>>>>>        Function_Return sName
15671>>>>>    End_Function
15672>>>>>
15672>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement
15672>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
15674>>>>>        String sName
15674>>>>>        Handle hoSQLHelper
15674>>>>>        Get phoSQLHelper to hoSQLHelper
15675>>>>>        Get SQLStrSchemaFileFieldName of hoSQLHelper iField to sName
15676>>>>>        Function_Return sName
15677>>>>>    End_Function
15678>>>>>    
15678>>>>>    //  returns the name of a file suitable for a SQL statement
15678>>>>>    Function SQLStrFileName Integer iField Returns String
15680>>>>>        String sName
15680>>>>>        Handle hoSQLHelper
15680>>>>>        Get phoSQLHelper to hoSQLHelper
15681>>>>>        Get SQLStrFileName of hoSQLHelper iField to sName
15682>>>>>        Function_Return sName
15683>>>>>    End_Function
15684>>>>>    
15684>>>>>    // creates escaped SQL string by replacing single quote with two single quotes
15684>>>>>    Function SQLEscapedStr String sSQL Returns String
15686>>>>>        Handle hoSQLHelper
15686>>>>>        Get phoSQLHelper to hoSQLHelper
15687>>>>>        Get SQLEscapedStr of hoSQLHelper sSQL to sSQL
15688>>>>>        Function_Return sSQL
15689>>>>>    End_Function
15690>>>>>    
15690>>>>>    // Returns:
15690>>>>>    //       The record id string based on piPrimaryIndex.
15690>>>>>    Function PrimaryRecordId Returns String
15692>>>>>        Integer iIndex iFile iSegments iSegment iField
15692>>>>>        String sVal sId
15692>>>>>        
15692>>>>>        Get Main_File to iFile
15693>>>>>        Get piPrimaryIndex to iIndex
15694>>>>>        
15694>>>>>        If (iIndex < 0) Begin
15696>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
15699>>>>>        End
15699>>>>>>
15699>>>>>        
15699>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
15702>>>>>        For iSegment from 1 to iSegments
15708>>>>>>
15708>>>>>            Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
15711>>>>>            
15711>>>>>            Get_Field_Value iFile iField to sVal
15714>>>>>            Move (Trim(sVal)) to sVal
15715>>>>>            
15715>>>>>            //  Encode join sign for multi segment indexes
15715>>>>>            If (iSegments > 1) Begin
15717>>>>>                Move (Replaces("_", sVal, "~5F~")) to sVal
15718>>>>>            End
15718>>>>>>
15718>>>>>            
15718>>>>>            If (iSegment = 1) Begin
15720>>>>>                Move sVal to sId
15721>>>>>            End
15721>>>>>>
15721>>>>>            Else Begin
15722>>>>>                Move (sId + "_" + sVal) to sId
15723>>>>>            End
15723>>>>>>
15723>>>>>            
15723>>>>>        Loop
15724>>>>>>
15724>>>>>        
15724>>>>>        Function_Return sId
15725>>>>>    End_Function
15726>>>>>    
15726>>>>>    
15726>>>>>    // Finds a record on the global buffer based on the record id.
15726>>>>>    //
15726>>>>>    // Params:
15726>>>>>    //       sRecordId   Record id generated by PrimaryRecordId.
15726>>>>>    Function FindByPrimaryRecordId String sRecordId Returns Boolean
15728>>>>>        Integer iIndex iFile iSegments iSegment iField
15728>>>>>        String[] aValues
15729>>>>>        String sVal
15729>>>>>        Boolean bTrapped
15729>>>>>        
15729>>>>>        Get Main_File to iFile
15730>>>>>        Get piPrimaryIndex to iIndex
15731>>>>>        
15731>>>>>        If (iIndex < 0) Begin
15733>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
15736>>>>>        End
15736>>>>>>
15736>>>>>        
15736>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
15739>>>>>        
15739>>>>>        If (iSegments > 1) Begin
15741>>>>>            Move (StrSplitToArray(sRecordId, "_")) to aValues
15742>>>>>        End
15742>>>>>>
15742>>>>>        Else Begin
15743>>>>>            Move sRecordId to aValues[0]
15744>>>>>        End
15744>>>>>>
15744>>>>>        
15744>>>>>        If (iSegments = SizeOfArray(aValues)) Begin
15746>>>>>            Clear iFile
15747>>>>>            
15747>>>>>            Send Ignore_Error of Error_Object_Id 56
15748>>>>>            Send Ignore_Error of Error_Object_Id 11
15749>>>>>            
15749>>>>>            For iSegment from 1 to iSegments
15755>>>>>>
15755>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
15758>>>>>                
15758>>>>>                Move aValues[iSegment - 1] to sVal
15759>>>>>                If (iSegments > 1) Begin
15761>>>>>                    Move (Replaces("~5F~", sVal, "_")) to sVal
15762>>>>>                End
15762>>>>>>
15762>>>>>                
15762>>>>>                Set_Field_Value iFile iField to sVal
15765>>>>>            Loop
15766>>>>>>
15766>>>>>            Send Trap_Error of Error_Object_Id 56
15767>>>>>            Send Trap_Error of Error_Object_Id 11
15768>>>>>            
15768>>>>>            Vfind iFile iIndex EQ
15770>>>>>            
15770>>>>>            Function_Return (Found)
15771>>>>>        End
15771>>>>>>
15771>>>>>        
15771>>>>>        Function_Return False
15772>>>>>    End_Function
15773>>>>>    
15773>>>>>    // Converts a RecordId to a RowId by finding it on the global buffer.
15773>>>>>    //
15773>>>>>    // Params:
15773>>>>>    //       sRecordId   Record id based on piPrimaryIndex.
15773>>>>>    //       rRowId      (ByRef) Will be filled with the rowid.
15773>>>>>    // Returns:
15773>>>>>    //       True if the record id was valid.
15773>>>>>    Function RecordIdToRowId String sRecordId RowID ByRef rRowId Returns Boolean
15775>>>>>        Boolean bFound
15775>>>>>        
15775>>>>>        Get FindByPrimaryRecordId sRecordId to bFound
15776>>>>>        If (bFound) Begin
15778>>>>>            Move (GetRowID(Main_File(Self))) to rRowId
15779>>>>>        End
15779>>>>>>
15779>>>>>        Else Begin
15780>>>>>            Move (NullRowID()) to rRowId
15781>>>>>        End
15781>>>>>>
15781>>>>>        
15781>>>>>        Function_Return bFound
15782>>>>>    End_Function
15783>>>>>    
15783>>>>>    // Converts a RowId into a record ID. Note that it performs a find on the global buffer.
15783>>>>>    //
15783>>>>>    // Params:
15783>>>>>    //       riRowId     RowID.
15783>>>>>    // Returns:
15783>>>>>    //       Record id based on piPrimaryIndex.
15783>>>>>    Function RowIdToRecordId RowID riRowId Returns String
15785>>>>>        Boolean bFound
15785>>>>>        String sRecId
15785>>>>>        
15785>>>>>        If (not(IsNullRowID(riRowId))) Begin
15787>>>>>            Move (FindByRowID(Main_File(Self), riRowId)) to bFound
15788>>>>>            
15788>>>>>            If (bFound) Begin
15790>>>>>                Get PrimaryRecordId to sRecId
15791>>>>>            End
15791>>>>>>
15791>>>>>        End
15791>>>>>>
15791>>>>>        
15791>>>>>        Function_Return sRecId
15792>>>>>    End_Function
15793>>>>>End_Class
15794>>>>>
15794>>>>>// This message will be send as a notification message from an
15794>>>>>// Extended_Data_Set whenever a fieldvalue has been changed.
15794>>>>>// It has been defined FOR cUIObject or Desktop  here so that attached
15794>>>>>// DEO which do not know anything about Extended_Data_Sets don't get
15794>>>>>// frustrated.
15794>>>>>// All focusable objects and DEOs must understand this. This should be
15794>>>>>// changed at some point in the future.
15794>>>>>Function Extended_DEO_State for cUIObject Returns Integer
15796>>>>>End_Function
15797>>>>>
15797>>>>>
15797>>>>>// this command is now obsolete. use Set Field_auto_increment
15797>>>>>
15797>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DUFLanguageConstants.inc)
15797>>>>>// *** The Database Update Framework Include file for Languages ***
15797>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
15797>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
15797>>>>>//
15797>>>>>Use LanguageText.Pkg
15797>>>>>
15797>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
15797>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
15797>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
15797>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
15797>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
15797>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
15797>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
15797>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
15797>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
15797>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
15797>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
15797>>>>>    Define CS_DUF_CopyingData               for "Copying data"
15797>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
15797>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
15797>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
15797>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
15797>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
15797>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
15797>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
15797>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
15797>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
15797>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
15797>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
15797>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
15797>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
15797>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
15797>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
15797>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
15797>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
15797>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
15797>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
15797>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
15797>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
15797>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
15797>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
15797>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
15797>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>>>
15797>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DUFStatusPanel.pkg)
15797>>>>>// StatPnl.pkg - creates the standard status_panel object.
15797>>>>>//
15797>>>>>//
15797>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
15797>>>>>// invoke the standard status panel. The standard has always been that the package name
15797>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
15797>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
15797>>>>>// prior revisions has been replace with status panel that is part of the application.
15797>>>>>// This should work much better and faster than the old sentinel based solution.
15797>>>>>// While the way this operates has changed, the interface has not and therefore this should work
15797>>>>>// with most applications.
15797>>>>>//
15797>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
15797>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
15797>>>>>// a cleaner more robust interface.
15797>>>>>//
15797>>>>>//
15797>>>>>// Compatibility Note:
15797>>>>>//
15797>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
15797>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
15797>>>>>//
15797>>>>>// If for some reason you application will not work using this as a replacement for the old status
15797>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
15797>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
15797>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
15797>>>>>//
15797>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
15797>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
15797>>>>>//
15797>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
15797>>>>>// can still access the new object via the ghoStatusPanel handle.
15797>>>>>//
15797>>>>>//
15797>>>>>// Creating your own Status Panel objects
15797>>>>>//
15797>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
15797>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
15797>>>>>// with a different file and object name and direct your status panel request to the new object.
15797>>>>>//
15797>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
15797>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
15797>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
15797>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
15797>>>>>// e.g.
15797>>>>>//       Procedure UpdateStatusBar
15797>>>>>//           Send DoAdvance of oProgressBar
15797>>>>>//           Send ProcessEvents
15797>>>>>//       End_Procedure
15797>>>>>//
15797>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
15797>>>>>// messages this will be done for you.
15797>>>>>//
15797>>>>>// the standard Interface for status panels are:
15797>>>>>//
15797>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
15797>>>>>// Send Start_StatusPanel      - start the status panel
15797>>>>>// Send Stop_StatusPanel       - stop the status panel
15797>>>>>// Send Update_StatusPanel     - update the status panel's action area
15797>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
15797>>>>>//
15797>>>>>// Get/Set Caption_Text - updates the caption bar
15797>>>>>// Get/Set Title_Text   - updates the title area
15797>>>>>// Get/Set Message_Text - updates the Message area
15797>>>>>// Get/Set Action_Text  - updates the action area
15797>>>>>// Get/Set Button_Text  - updates the button area
15797>>>>>//
15797>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
15797>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
15797>>>>>//
15797>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
15797>>>>>Use cProcessStatusPanel.pkg
Including file: cProcessStatusPanel.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cProcessStatusPanel.pkg)
15797>>>>>>>// cProcessStatusPanel.pkg
15797>>>>>>>//
15797>>>>>>>// Class used to create StatusPanels.
15797>>>>>>>//
15797>>>>>>>// This class does not provide any of the inner objects that make up a status panel. Instead an
15797>>>>>>>// interface is provided that is used to update the various areas of status panel. At this level,
15797>>>>>>>// those areas (title area, message area, action area, button area) are logical. You create the
15797>>>>>>>// physical objects at the object level and then bind these objects to the interface.
15797>>>>>>>// Take a look at StatPnl.pkg to see how this is used.
15797>>>>>>>//
15797>>>>>>>// the standard Interface for status panels are:
15797>>>>>>>//
15797>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
15797>>>>>>>// Send Start_StatusPanel      - start the status panel
15797>>>>>>>// Send Stop_StatusPanel       - stop the status panel
15797>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
15797>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
15797>>>>>>>//
15797>>>>>>>// Get/Set Caption_Text - updates the caption bar
15797>>>>>>>// Get/Set Title_Text   - updates the title area
15797>>>>>>>// Get/Set Message_Text - updates the Message area
15797>>>>>>>// Get/Set Action_Text  - updates the action area
15797>>>>>>>// Get/Set Button_Text  - updates the button area
15797>>>>>>>//
15797>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
15797>>>>>>>// Send EnableCancelButton - code must be provided in the cancel button object to enable/disable cancel button
15797>>>>>>>//
15797>>>>>>>
15797>>>>>>>Use cStatusPanel.pkg
Including file: cStatusPanel.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cStatusPanel.pkg)
15797>>>>>>>>>// This is an abstract class that can be used to create status panels. The interface at this level
15797>>>>>>>>>// is very simple. You can start, stop, request a cancel and allow the object to paint.
15797>>>>>>>>>//
15797>>>>>>>>>// Look at cProcessStatusPanel.pkg to see how this is used.
15797>>>>>>>>>
15797>>>>>>>>>Use Windows.pkg
15797>>>>>>>>>
15797>>>>>>>>>
15797>>>>>>>>>
15797>>>>>>>>>
15797>>>>>>>>>Class cStatusPanel is a FloatingPanel
15798>>>>>>>>>    
15798>>>>>>>>>    Procedure Construct_Object
15800>>>>>>>>>        Forward Send Construct_object
15802>>>>>>>>>        
15802>>>>>>>>>        Property Boolean pbCancel False
15803>>>>>>>>>        
15803>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True // kills sysmenu as long as there is no icon
15804>>>>>>>>>        Set Icon to '' // this must be cleared so there will be no icon
15805>>>>>>>>>        Set locate_mode to CENTER_ON_PANEL
15806>>>>>>>>>        Set Border_Style  to Border_Dialog
15807>>>>>>>>>        // should be scoped so it will not try to change the focus if there is no focusable button inside
15807>>>>>>>>>        Set Scope_State to True
15808>>>>>>>>>        
15808>>>>>>>>>        On_Key KEXIT_APPLICATION Send Close_Panel
15809>>>>>>>>>    End_Procedure
15810>>>>>>>>>    
15810>>>>>>>>>    // this is private and required. Never send this.
15810>>>>>>>>>    Procedure Deactivate_Group
15812>>>>>>>>>        If (Active_State(Self)) Begin
15814>>>>>>>>>            Send SuspendGUI of Desktop False
15815>>>>>>>>>        End
15815>>>>>>>>>>
15815>>>>>>>>>        Forward Send Deactivate_Group
15817>>>>>>>>>    End_Procedure
15818>>>>>>>>>    
15818>>>>>>>>>    // Send this message to stop the panel
15818>>>>>>>>>    Procedure Deactivate
15820>>>>>>>>>        If (Active_State(Self)) Begin
15822>>>>>>>>>            Send SuspendGUI of Desktop False
15823>>>>>>>>>        End
15823>>>>>>>>>>
15823>>>>>>>>>        Forward Send Deactivate
15825>>>>>>>>>    End_Procedure
15826>>>>>>>>>    
15826>>>>>>>>>    // Send this message to start the panel
15826>>>>>>>>>    Procedure Activate
15828>>>>>>>>>        If not (Active_State(Self)) Begin
15830>>>>>>>>>            Set pbCancel to False
15831>>>>>>>>>            Send SuspendGUI of Desktop True
15832>>>>>>>>>        End
15832>>>>>>>>>>
15832>>>>>>>>>        Forward Send Activate
15834>>>>>>>>>    End_Procedure
15835>>>>>>>>>    
15835>>>>>>>>>    // This allows the panel to paint when used in a tight loop, which is what status panels are
15835>>>>>>>>>    // used for. Any time you update the panel or wish to check for a cancel, you should call this.
15835>>>>>>>>>    Procedure ProcessEvents
15837>>>>>>>>>        If (Active_State(Self)) Begin
15839>>>>>>>>>            Send PumpMsgQueue of Desktop
15840>>>>>>>>>        End
15840>>>>>>>>>>
15840>>>>>>>>>    End_Procedure
15841>>>>>>>>>    
15841>>>>>>>>>    // note close panel does not actually close the panel. It just sets pbCancel to True, informing the
15841>>>>>>>>>    // process using this that it wants to close. It is then up the process close the panel.
15841>>>>>>>>>    Procedure Close_Panel
15843>>>>>>>>>        Set pbCancel to True
15844>>>>>>>>>    End_Procedure
15845>>>>>>>>>    
15845>>>>>>>>>End_Class
15846>>>>>>>
15846>>>>>>>
15846>>>>>>>
15846>>>>>>>Class cProcessStatusPanel is a cStatusPanel
15847>>>>>>>    
15847>>>>>>>    Procedure Construct_Object
15849>>>>>>>        Forward Send Construct_object
15851>>>>>>>        // determines if panel can be canceled
15851>>>>>>>        Property Boolean Allow_Cancel_State True
15852>>>>>>>    End_Procedure
15853>>>>>>>    
15853>>>>>>>    // Any of the properties that change the text of a status panel must also send
15853>>>>>>>    // ProcessEvents which allows the panel to process painting messages. The ProcessEvents
15853>>>>>>>    // is essential when using status panels within a tight loop
15853>>>>>>>    
15853>>>>>>>    Procedure Set Caption_text String sText
15855>>>>>>>        Set Label to sText
15856>>>>>>>        Send ProcessEvents
15857>>>>>>>    End_Procedure
15858>>>>>>>    
15858>>>>>>>    Function Caption_Text Returns String
15860>>>>>>>        Function_Return (Label(Self))
15861>>>>>>>    End_Function
15862>>>>>>>    
15862>>>>>>>    Procedure Set Message_Text String sText
15864>>>>>>>        Send ProcessEvents
15865>>>>>>>    End_Procedure
15866>>>>>>>    
15866>>>>>>>    Function Message_Text Returns String
15868>>>>>>>    End_Function
15869>>>>>>>    
15869>>>>>>>    Procedure Set Action_Text String sText
15871>>>>>>>        Send ProcessEvents
15872>>>>>>>    End_Procedure
15873>>>>>>>    
15873>>>>>>>    Function Action_Text Returns String
15875>>>>>>>    End_Function
15876>>>>>>>    
15876>>>>>>>    Procedure Set Button_Text String sText
15878>>>>>>>        Send ProcessEvents
15879>>>>>>>    End_Procedure
15880>>>>>>>    
15880>>>>>>>    Function Button_Text Returns String
15882>>>>>>>    End_Function
15883>>>>>>>    
15883>>>>>>>    Procedure Set Title_Text String sText
15885>>>>>>>        Send ProcessEvents
15886>>>>>>>    End_Procedure
15887>>>>>>>    
15887>>>>>>>    Function Title_Text Returns String
15889>>>>>>>    End_Function
15890>>>>>>>    
15890>>>>>>>    // initializes values for caption, title & message
15890>>>>>>>    Procedure Initialize_StatusPanel String sCaption String sTitle String sMessage
15892>>>>>>>        Set Caption_text to sCaption
15893>>>>>>>        Set Title_Text   to sTitle
15894>>>>>>>        Set Message_Text to sMessage
15895>>>>>>>    End_Procedure
15896>>>>>>>    
15896>>>>>>>    // update the status panel's action area
15896>>>>>>>    Procedure Update_StatusPanel String sAction
15898>>>>>>>        Set Action_Text to sAction
15899>>>>>>>    End_Procedure
15900>>>>>>>    
15900>>>>>>>    // stop the status panel
15900>>>>>>>    Procedure Close_Panel
15902>>>>>>>        If (Allow_cancel_state(Self)) Begin
15904>>>>>>>            Forward Send Close_Panel
15906>>>>>>>        End
15906>>>>>>>>
15906>>>>>>>    End_Procedure
15907>>>>>>>    
15907>>>>>>>    // Code must be provided in the cancel button object to enable/disable cancel button
15907>>>>>>>    Procedure EnableCancelButton Boolean bEnable
15909>>>>>>>    End_Procedure
15910>>>>>>>    
15910>>>>>>>    // check for cancel (if cancel or pbCancel is set, close the panel)
15910>>>>>>>    Function Check_StatusPanel Returns Integer
15912>>>>>>>        Boolean bCancel
15912>>>>>>>        If (Active_state(Self)) Begin
15914>>>>>>>            Send ProcessEvents
15915>>>>>>>            Get pbCancel to bCancel
15916>>>>>>>            If bCancel Begin
15918>>>>>>>                Send Stop_StatusPanel // the old status panel removed this when canceled.
15919>>>>>>>            End
15919>>>>>>>>
15919>>>>>>>        End
15919>>>>>>>>
15919>>>>>>>        Function_Return (If(bCancel, MSG_CANCEL, 0)) // the old check status panel returns msg_cancel
15920>>>>>>>    End_Function
15921>>>>>>>    
15921>>>>>>>    // start the status panel
15921>>>>>>>    Procedure Start_StatusPanel
15923>>>>>>>        If not (Active_state(Self)) Begin
15925>>>>>>>            Send EnableCancelButton (Allow_cancel_state(Self))
15926>>>>>>>            Send Activate
15927>>>>>>>        End
15927>>>>>>>>
15927>>>>>>>    End_Procedure
15928>>>>>>>    
15928>>>>>>>    // stop the status panel
15928>>>>>>>    Procedure Stop_StatusPanel
15930>>>>>>>        If (Active_state(Self)) Begin
15932>>>>>>>            Send Deactivate
15933>>>>>>>        End
15933>>>>>>>>
15933>>>>>>>    End_Procedure
15934>>>>>>>    
15934>>>>>>>End_Class
15935>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJSkinFramework.pkg)
15935>>>>>>>Use windows.pkg
15935>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJComSkinFramework.pkg)
15935>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v20.0.0.ocx
15935>>>>>>>>>Use FlexCom20.pkg
Including file: FlexCOM20.pkg    (C:\Program Files\DataFlex 20.1\Pkg\FlexCOM20.pkg)
15935>>>>>>>>>>>// Full Flexcom support for automation (cComAutomationObject),
15935>>>>>>>>>>>// activeX (cComActiveXControl and document objects (cComDocumentObject)
15935>>>>>>>>>>>Use FlexCOM20_Base.pkg // defines basic flexcom symbols and class cComAutomationObject
Including file: FlexCOM20_Base.pkg    (C:\Program Files\DataFlex 20.1\Pkg\FlexCOM20_Base.pkg)
15935>>>>>>>>>>>>>// Flexcom support for automation (cComAutomationObject).
15935>>>>>>>>>>>>>// If you want activeX and document objects use FlexCom20.pkg
15935>>>>>>>>>>>>>Use VdfBase.pkg
15935>>>>>>>>>>>>>Use ComTypes.pkg
Including file: ComTypes.pkg    (C:\Program Files\DataFlex 20.1\Pkg\ComTypes.pkg)
15935>>>>>>>>>>>>>>>Use Variant.pkg
15935>>>>>>>>>>>>>>>
15935>>>>>>>>>>>>>>>
15935>>>>>>>>>>>>>
15935>>>>>>>>>>>>>
15935>>>>>>>>>>>>>
15935>>>>>>>>>>>>>//Enumerations for the peAutoCreate property
15935>>>>>>>>>>>>>//acNoAutoCreate - Do not automatically instantiate the COM object upon VDF object creation.
15935>>>>>>>>>>>>>//You must manually instantiate the COM object using CreateComObject. This is the default
15935>>>>>>>>>>>>>//for cComAutomation.
15935>>>>>>>>>>>>>Define acNoAutoCreate for 0
15935>>>>>>>>>>>>>//acAutoCreate - Automatically instantiate the COM object upon VDF object creation.
15935>>>>>>>>>>>>>//You won't need to manually instantiate the COM object. This is the default
15935>>>>>>>>>>>>>//for cComActiveXControl
15935>>>>>>>>>>>>>Define acAutoCreate for 1
15935>>>>>>>>>>>>>//acDeferredAutoCreate - Automatically instantiate the COM object during Page_Object,
15935>>>>>>>>>>>>>//and automatically destroy the COM object during Page_Delete. Use this setting only
15935>>>>>>>>>>>>>//if acAutoCreate causes problems.
15935>>>>>>>>>>>>>Define acDeferredAutoCreate for 2
15935>>>>>>>>>>>>>
15935>>>>>>>>>>>>>Class cComAutomationObject is a DFComAutomationObject
15936>>>>>>>>>>>>>    Procedure Construct_Object
15938>>>>>>>>>>>>>        Forward Send Construct_Object
15940>>>>>>>>>>>>>        Send RegisterComEvents
15941>>>>>>>>>>>>>    End_Procedure
15942>>>>>>>>>>>>>    
15942>>>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
15942>>>>>>>>>>>>>    Procedure RegisterComEvents
15944>>>>>>>>>>>>>    End_Procedure
15945>>>>>>>>>>>>>    
15945>>>>>>>>>>>>>    // Attach the DF object to com automation object via progId.
15945>>>>>>>>>>>>>    // returns: Boolean bSuccess if Ok, If not ok, pcComObject is set to null
15945>>>>>>>>>>>>>    Function AttachActiveObject Returns Boolean
15947>>>>>>>>>>>>>        String sProgId
15947>>>>>>>>>>>>>        Variant vComObject
15947>>>>>>>>>>>>>        Boolean bSuccess
15947>>>>>>>>>>>>>        Get psProgID to sProgId
15948>>>>>>>>>>>>>        Get ComActiveObject sProgId to vComObject
15949>>>>>>>>>>>>>        Set pvComObject to vComObject
15950>>>>>>>>>>>>>        Move (not(IsNullComObject(vComObject))) to bSuccess // success of variant is not null
15951>>>>>>>>>>>>>        Function_Return bSuccess
15952>>>>>>>>>>>>>    End_Function
15953>>>>>>>>>>>>>    
15953>>>>>>>>>>>>>    // returns true if the control is created.
15953>>>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
15955>>>>>>>>>>>>>        Variant vComObject
15955>>>>>>>>>>>>>        Get pvComObject to vComObject
15956>>>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
15957>>>>>>>>>>>>>    End_Function
15958>>>>>>>>>>>>>    
15958>>>>>>>>>>>>>End_Class
15959>>>>>>>>>>>>>
15959>>>>>>>>>>>>>
15959>>>>>>>>>>>
15959>>>>>>>>>>>Use Windows.pkg
15959>>>>>>>>>>>
15959>>>>>>>>>>>Class cComDocumentObject is a DFComDocumentObject
15960>>>>>>>>>>>
15960>>>>>>>>>>>
15960>>>>>>>>>>>    Procedure Construct_Object
15962>>>>>>>>>>>        Forward Send Construct_Object
15964>>>>>>>>>>>        Send RegisterComEvents
15965>>>>>>>>>>>        Send Define_Standard_Object_Mixin
15966>>>>>>>>>>>        Send Define_Shadow_Mixin
15967>>>>>>>>>>>    End_Procedure
15968>>>>>>>>>>>
15968>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
15969>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
15970>>>>>>>>>>>
15970>>>>>>>>>>>    
15970>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
15970>>>>>>>>>>>    Procedure RegisterComEvents
15972>>>>>>>>>>>    End_Procedure
15973>>>>>>>>>>>    
15973>>>>>>>>>>>    // returns true if the control is created.
15973>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
15975>>>>>>>>>>>        Variant vComObject
15975>>>>>>>>>>>        Get pvComObject to vComObject
15976>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
15977>>>>>>>>>>>    End_Function
15978>>>>>>>>>>>
15978>>>>>>>>>>>
15978>>>>>>>>>>>End_Class
15979>>>>>>>>>>>
15979>>>>>>>>>>>Class cComActiveXControl is a DFComActiveXControl
15980>>>>>>>>>>>
15980>>>>>>>>>>>    Procedure Construct_Object
15982>>>>>>>>>>>        Forward Send Construct_Object
15984>>>>>>>>>>>        Send RegisterComEvents
15985>>>>>>>>>>>
15985>>>>>>>>>>>
15985>>>>>>>>>>>        Send Define_Standard_Object_Mixin
15986>>>>>>>>>>>        Send Define_Single_Item_Navigate_Mixin
15987>>>>>>>>>>>        Send Define_Dflabel_Mixin
15988>>>>>>>>>>>
15988>>>>>>>>>>>        // internal: set true object is notified that the OCX value has changed.
15988>>>>>>>>>>>        Property Boolean pbPrivateControlChanging False
15989>>>>>>>>>>>        // Class sets this true when making a local (externally triggered) change. This is
15989>>>>>>>>>>>        // set when a Set Value change is made to prevent recursion
15989>>>>>>>>>>>        Property Boolean pbPrivateControlRefresh False
15990>>>>>>>>>>>        
15990>>>>>>>>>>>        // added to eumlate a single item form support
15990>>>>>>>>>>>        Property Boolean pbPrivateItem_Changed_State False
15991>>>>>>>>>>>        
15991>>>>>>>>>>>        // This keeps track of value, even when control is not created
15991>>>>>>>>>>>        Property String psPrivateValue ''
15992>>>>>>>>>>>        
15992>>>>>>>>>>>        // If set true, then the control will attempt to bind the value property in the object to the
15992>>>>>>>>>>>        // comValue in the control. It will try to keep these values in synch at all times. This allows a
15992>>>>>>>>>>>        // control to be used as a Form style value control. the default is true. Even when true if the
15992>>>>>>>>>>>        // get/set ComValue methods are not set up to do anything, this will do nothing.
15992>>>>>>>>>>>        Property Boolean pbBindValue True
15993>>>>>>>>>>>        
15993>>>>>>>>>>>    End_Procedure
15994>>>>>>>>>>>    
15994>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
15994>>>>>>>>>>>    Procedure RegisterComEvents
15996>>>>>>>>>>>    End_Procedure
15997>>>>>>>>>>>
15997>>>>>>>>>>>    
15997>>>>>>>>>>>    // returns true if the control is created.
15997>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
15999>>>>>>>>>>>        Variant vComObject
15999>>>>>>>>>>>        Get pvComObject to vComObject
16000>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16001>>>>>>>>>>>    End_Function
16002>>>>>>>>>>>    
16002>>>>>>>>>>>
16002>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
16003>>>>>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
16004>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
16005>>>>>>>>>>>
16005>>>>>>>>>>>    // added to eumlate a single item form support
16005>>>>>>>>>>>    Function Item_Count Returns Integer
16007>>>>>>>>>>>        Function_Return 1
16008>>>>>>>>>>>    End_Function
16009>>>>>>>>>>>    
16009>>>>>>>>>>>    // added to eumlate a single item form support
16009>>>>>>>>>>>    Procedure Set Item_Changed_State Integer iItem Integer iState
16011>>>>>>>>>>>        Set pbPrivateItem_changed_state to iState
16012>>>>>>>>>>>        If (iState and changed_state(Self)=False) ;            Set changed_state to True
16015>>>>>>>>>>>    End_Procedure
16016>>>>>>>>>>>    
16016>>>>>>>>>>>    Function Item_Changed_State Integer iItem Returns Integer
16018>>>>>>>>>>>        Function_Return (pbPrivateItem_changed_state(Self))
16019>>>>>>>>>>>    End_Function
16020>>>>>>>>>>>    
16020>>>>>>>>>>>    
16020>>>>>>>>>>>    // augment to set the label's appearance
16020>>>>>>>>>>>    Procedure Shadow_Display
16022>>>>>>>>>>>        Forward Send Shadow_display
16024>>>>>>>>>>>        Send Label_Shadow_Display
16025>>>>>>>>>>>    End_Procedure
16026>>>>>>>>>>>    
16026>>>>>>>>>>>    // Created to simulate get/Set value.
16026>>>>>>>>>>>    Procedure Set Value Integer iItem String sVal
16028>>>>>>>>>>>        If not (pbPrivateControlChanging(Self)) ;            Send OnRefreshControl sVal
16031>>>>>>>>>>>        Set psPrivateValue to sVal
16032>>>>>>>>>>>        Send OnChange
16033>>>>>>>>>>>        //Set changed_state to True
16033>>>>>>>>>>>        Set item_changed_state 0 to True
16034>>>>>>>>>>>    End_Procedure
16035>>>>>>>>>>>    
16035>>>>>>>>>>>    Function Value Integer iItem Returns String
16037>>>>>>>>>>>        Function_Return (psPrivateValue(Self))
16038>>>>>>>>>>>        //function_return (Controlvalue(self))
16038>>>>>>>>>>>    End_Function
16039>>>>>>>>>>>    
16039>>>>>>>>>>>    Procedure OnChange
16041>>>>>>>>>>>    End_Procedure
16042>>>>>>>>>>>    
16042>>>>>>>>>>>    
16042>>>>>>>>>>>    // It is expected that the sub-class will provide functionality
16042>>>>>>>>>>>    // for these messages. This gets and sets the value of the actual
16042>>>>>>>>>>>    // window control. These should only be used to synchronize the window
16042>>>>>>>>>>>    // control and the DF side. Do not use for any other purpose.
16042>>>>>>>>>>>    Procedure Set ControlValue String sVal
16044>>>>>>>>>>>    End_Procedure
16045>>>>>>>>>>>    
16045>>>>>>>>>>>    Function ControlValue Returns String
16047>>>>>>>>>>>    End_Function
16048>>>>>>>>>>>    
16048>>>>>>>>>>>    Procedure OnCreate
16050>>>>>>>>>>>        // if we are binding value to comValue, do so upon creation
16050>>>>>>>>>>>        If (pbBindValue(Self)) ;            Set ControlValue to (Value(Self))
16053>>>>>>>>>>>        Forward Send OnCreate
16055>>>>>>>>>>>    End_Procedure
16056>>>>>>>>>>>    
16056>>>>>>>>>>>    // Notification that the control is about to be activated in place. The COM component is
16056>>>>>>>>>>>    // created but OnCreate is not yet fired (this happens after the InPlaceActivate).
16056>>>>>>>>>>>    Procedure OnBeforeInPlaceActivate
16058>>>>>>>>>>>        Forward Send OnBeforeInPlaceActivate
16060>>>>>>>>>>>    End_Procedure
16061>>>>>>>>>>>    
16061>>>>>>>>>>>    // Notification that the control's value has been changed
16061>>>>>>>>>>>    // externally by the program (via set value). Use to synchronize
16061>>>>>>>>>>>    // OCX control value.
16061>>>>>>>>>>>    Procedure OnRefreshControl String sVal
16063>>>>>>>>>>>        Boolean bOld
16063>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlChanging(Self)=0 and IsComObjectCreated(Self)) Begin
16065>>>>>>>>>>>            Get pbPrivateControlRefresh to bOld
16066>>>>>>>>>>>            Set pbPrivateControlRefresh to True
16067>>>>>>>>>>>            Set ControlValue to sval
16068>>>>>>>>>>>            Set pbPrivateControlRefresh to bOld
16069>>>>>>>>>>>        End
16069>>>>>>>>>>>>
16069>>>>>>>>>>>    End_Procedure
16070>>>>>>>>>>>    
16070>>>>>>>>>>>    // notification that the control has changed its value. Used to
16070>>>>>>>>>>>    // synchronize the object with the change.
16070>>>>>>>>>>>    Procedure OnControlValueChanged
16072>>>>>>>>>>>        String sVal
16072>>>>>>>>>>>        Boolean bOld
16072>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlRefresh(Self)=0) Begin
16074>>>>>>>>>>>            Get pbPrivateControlChanging to bOld
16075>>>>>>>>>>>            Set pbPrivateControlChanging to True
16076>>>>>>>>>>>            Get ControlValue to sVal
16077>>>>>>>>>>>            Set Value to sVal
16078>>>>>>>>>>>            Set Item_Changed_State 0 to True
16079>>>>>>>>>>>            Set pbPrivateControlChanging to bOld
16080>>>>>>>>>>>        End
16080>>>>>>>>>>>>
16080>>>>>>>>>>>    End_Procedure
16081>>>>>>>>>>>    
16081>>>>>>>>>>>    Procedure Delete_Data
16083>>>>>>>>>>>        Forward Send Delete_Data
16085>>>>>>>>>>>        Set Value to ''
16086>>>>>>>>>>>        Set Changed_state to False
16087>>>>>>>>>>>        Set Item_changed_state 0 to False
16088>>>>>>>>>>>    End_Procedure
16089>>>>>>>>>>>
16089>>>>>>>>>>>
16089>>>>>>>>>>>End_Class
16090>>>>>>>>>>>
16090>>>>>>>>>>>
16090>>>>>>>>>
16090>>>>>>>>>// Changes to Imported package
16090>>>>>>>>>//     OLEXTPxx to XTPxx
16090>>>>>>>>>//     OLExtpxx to xtpxx
16090>>>>>>>>>//     OLESkinFramework to SkinFramework
16090>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
16090>>>>>>>>>//     cCom classes to cCJ
16090>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
16090>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
16090>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
16090>>>>>>>>>//     Use statements as noted below (classes moved to these files)
16090>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
16090>>>>>>>>>
16090>>>>>>>>>// These have been extracted from this class and moved into seperate packages
16090>>>>>>>>>// because other Codejock classes use these.
16090>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
Including file: cCJColorManager.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJColorManager.pkg)
16090>>>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.CommandBars.Unicode.x64.v20.0.0.ocx
16090>>>>>>>>>>>Use FlexCom20.pkg
16090>>>>>>>>>>>
16090>>>>>>>>>>>Define XTPColorManagerColor for Integer
16090>>>>>>>>>>>    Define STDCOLOR_BACKGROUND for 1
16090>>>>>>>>>>>    Define STDCOLOR_ACTIVECAPTION for 2
16090>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTION for 3
16090>>>>>>>>>>>    Define STDCOLOR_MENU for 4
16090>>>>>>>>>>>    Define STDCOLOR_WINDOW for 5
16090>>>>>>>>>>>    Define STDCOLOR_WINDOWFRAME for 6
16090>>>>>>>>>>>    Define STDCOLOR_MENUTEXT for 7
16090>>>>>>>>>>>    Define STDCOLOR_WINDOWTEXT for 8
16090>>>>>>>>>>>    Define STDCOLOR_CAPTIONTEXT for 9
16090>>>>>>>>>>>    Define STDCOLOR_ACTIVEBORDER for 10
16090>>>>>>>>>>>    Define STDCOLOR_INACTIVEBORDER for 11
16090>>>>>>>>>>>    Define STDCOLOR_APPWORKSPACE for 12
16090>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHT for 13
16090>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHTTEXT for 14
16090>>>>>>>>>>>    Define STDCOLOR_BTNFACE for 15
16090>>>>>>>>>>>    Define STDCOLOR_BTNSHADOW for 16
16090>>>>>>>>>>>    Define STDCOLOR_GRAYTEXT for 17
16090>>>>>>>>>>>    Define STDCOLOR_BTNTEXT for 18
16090>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTIONTEXT for 19
16090>>>>>>>>>>>    Define STDCOLOR_BTNHIGHLIGHT for 20
16090>>>>>>>>>>>    Define STDCOLOR_3DDKSHADOW for 21
16090>>>>>>>>>>>    Define STDCOLOR_3DLIGHT for 22
16090>>>>>>>>>>>    Define STDCOLOR_INFOTEXT for 23
16090>>>>>>>>>>>    Define STDCOLOR_INFOBK for 24
16090>>>>>>>>>>>    Define STDCOLOR_HOTLIGHT for 26
16090>>>>>>>>>>>    Define STDCOLOR_GRADIENTACTIVECAPTION for 27
16090>>>>>>>>>>>    Define STDCOLOR_GRADIENTINACTIVECAPTION for 28
16090>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_FACE for 30
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT for 31
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_BORDER for 32
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED for 33
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED for 36
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED_BORDER for 37
16090>>>>>>>>>>>    Define XPCOLOR_ICONSHADDOW for 34
16090>>>>>>>>>>>    Define XPCOLOR_GRAYTEXT for 35
16090>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_GRIPPER for 38
16090>>>>>>>>>>>    Define XPCOLOR_SEPARATOR for 39
16090>>>>>>>>>>>    Define XPCOLOR_DISABLED for 40
16090>>>>>>>>>>>    Define XPCOLOR_MENUBAR_FACE for 41
16090>>>>>>>>>>>    Define XPCOLOR_MENUBAR_EXPANDED for 42
16090>>>>>>>>>>>    Define XPCOLOR_MENUBAR_BORDER for 43
16090>>>>>>>>>>>    Define XPCOLOR_MENUBAR_TEXT for 44
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_TEXT for 45
16090>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_TEXT for 46
16090>>>>>>>>>>>    Define XPCOLOR_PUSHED_TEXT for 47
16090>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_BACK for 48
16090>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_TEXT for 49
16090>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED_BORDER for 50
16090>>>>>>>>>>>    Define XPCOLOR_3DFACE for 51
16090>>>>>>>>>>>    Define XPCOLOR_3DSHADOW for 52
16090>>>>>>>>>>>    Define XPCOLOR_FRAME for 54
16090>>>>>>>>>>>    Define XPCOLOR_SPLITTER_FACE for 55
16090>>>>>>>>>>>    Define XPCOLOR_LABEL for 56
16090>>>>>>>>>>>    Define XPCOLOR_STATICFRAME for 57
16090>>>>>>>>>>>
16090>>>>>>>>>>>Define XTPCurrentSystemTheme for Integer
16090>>>>>>>>>>>    // No known theme in use
16090>>>>>>>>>>>    Define xtpSystemThemeUnknown for 0
16090>>>>>>>>>>>    // Blue theme in use
16090>>>>>>>>>>>    Define xtpSystemThemeBlue for 1
16090>>>>>>>>>>>    // Olive theme in use
16090>>>>>>>>>>>    Define xtpSystemThemeOlive for 2
16090>>>>>>>>>>>    // Silver theme in use
16090>>>>>>>>>>>    Define xtpSystemThemeSilver for 3
16090>>>>>>>>>>>    // Silver theme in use
16090>>>>>>>>>>>    Define xtpSystemThemeRoyale for 4
16090>>>>>>>>>>>    // Silver theme in use
16090>>>>>>>>>>>    Define xtpSystemThemeAero for 5
16090>>>>>>>>>>>    // Use OS theme.
16090>>>>>>>>>>>    Define xtpSystemThemeAuto for 6
16090>>>>>>>>>>>
16090>>>>>>>>>>>
16090>>>>>>>>>>>// CLSID: {C0DE2000-DE43-4B56-BCEB-E14B825CF245}
16090>>>>>>>>>>>Class cCJIColorManager is a Mixin
16091>>>>>>>>>>>
16091>>>>>>>>>>>    Function ComSystemTheme Returns XTPCurrentSystemTheme
16093>>>>>>>>>>>        XTPCurrentSystemTheme retVal
16093>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to retVal
16094>>>>>>>>>>>        Function_Return retVal
16095>>>>>>>>>>>    End_Function
16096>>>>>>>>>>>
16096>>>>>>>>>>>    Procedure Set ComSystemTheme XTPCurrentSystemTheme value
16098>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to value
16099>>>>>>>>>>>    End_Procedure
16100>>>>>>>>>>>
16100>>>>>>>>>>>    Function ComEnableLunaBlueForRoyaleTheme Returns Boolean
16102>>>>>>>>>>>        Boolean retVal
16102>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to retVal
16103>>>>>>>>>>>        Function_Return retVal
16104>>>>>>>>>>>    End_Function
16105>>>>>>>>>>>
16105>>>>>>>>>>>    Procedure Set ComEnableLunaBlueForRoyaleTheme Boolean value
16107>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to value
16108>>>>>>>>>>>    End_Procedure
16109>>>>>>>>>>>
16109>>>>>>>>>>>    Function ComColor XTPColorManagerColor llIndex Returns OLE_COLOR
16111>>>>>>>>>>>        Handle hDispatchDriver
16111>>>>>>>>>>>        OLE_COLOR retVal
16111>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16112>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16113>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16114>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_I4 to retVal
16115>>>>>>>>>>>        Function_Return retVal
16116>>>>>>>>>>>    End_Function
16117>>>>>>>>>>>
16117>>>>>>>>>>>    Procedure ComSetColor XTPColorManagerColor llIndex OLE_COLOR llColor
16119>>>>>>>>>>>        Handle hDispatchDriver
16119>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16120>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16121>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16122>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llColor
16123>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
16124>>>>>>>>>>>    End_Procedure
16125>>>>>>>>>>>
16125>>>>>>>>>>>    Function ComGetCurrentSystemTheme Returns XTPCurrentSystemTheme
16127>>>>>>>>>>>        Handle hDispatchDriver
16127>>>>>>>>>>>        XTPCurrentSystemTheme retVal
16127>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16128>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
16129>>>>>>>>>>>        Function_Return retVal
16130>>>>>>>>>>>    End_Function
16131>>>>>>>>>>>End_Class
16132>>>>>>>>>>>
16132>>>>>>>>>>>// CoClass
16132>>>>>>>>>>>// CLSID: {C0DE2000-F3FE-46E7-BB64-DB033F439F8B}
16132>>>>>>>>>>>Class cCJColorManager is a cComAutomationObject
16133>>>>>>>>>>>    Import_Class_Protocol cCJIColorManager
16134>>>>>>>>>>>
16134>>>>>>>>>>>    Procedure Construct_Object
16136>>>>>>>>>>>        Forward Send Construct_Object
16138>>>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
16139>>>>>>>>>>>    End_Procedure
16140>>>>>>>>>>>End_Class
16141>>>>>>>>>>>
16141>>>>>>>>>
16141>>>>>>>>>
16141>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
16141>>>>>>>>>    Define xtpSkinApplyMetrics for 1
16141>>>>>>>>>    Define xtpSkinApplyFrame for 2
16141>>>>>>>>>    Define xtpSkinApplyColors for 4
16141>>>>>>>>>    Define xtpSkinApplyMenus for 8
16141>>>>>>>>>
16141>>>>>>>>>// CLSID: {C0DE2000-28D7-4F2C-87A7-7266367B4655}
16141>>>>>>>>>// Dispatch interface for SkinFramework Control
16141>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
16142>>>>>>>>>
16142>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
16144>>>>>>>>>        SkinFrameworkApplyOptions retVal
16144>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
16145>>>>>>>>>        Function_Return retVal
16146>>>>>>>>>    End_Function
16147>>>>>>>>>
16147>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
16149>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
16150>>>>>>>>>    End_Procedure
16151>>>>>>>>>
16151>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
16153>>>>>>>>>        Boolean retVal
16153>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
16154>>>>>>>>>        Function_Return retVal
16155>>>>>>>>>    End_Function
16156>>>>>>>>>
16156>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
16158>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
16159>>>>>>>>>    End_Procedure
16160>>>>>>>>>
16160>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
16162>>>>>>>>>        Boolean retVal
16162>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
16163>>>>>>>>>        Function_Return retVal
16164>>>>>>>>>    End_Function
16165>>>>>>>>>
16165>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
16167>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
16168>>>>>>>>>    End_Procedure
16169>>>>>>>>>
16169>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
16171>>>>>>>>>        Handle hDispatchDriver
16171>>>>>>>>>        Boolean retVal
16171>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16172>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16173>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
16174>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
16175>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
16176>>>>>>>>>        Function_Return retVal
16177>>>>>>>>>    End_Function
16178>>>>>>>>>
16178>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
16180>>>>>>>>>        Handle hDispatchDriver
16180>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16181>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16182>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16183>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
16184>>>>>>>>>    End_Procedure
16185>>>>>>>>>
16185>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
16187>>>>>>>>>        Handle hDispatchDriver
16187>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16188>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16189>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16190>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
16191>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
16192>>>>>>>>>    End_Procedure
16193>>>>>>>>>
16193>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
16195>>>>>>>>>        Handle hDispatchDriver
16195>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16196>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16197>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16198>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
16199>>>>>>>>>    End_Procedure
16200>>>>>>>>>
16200>>>>>>>>>    Procedure ComRemoveAllWindows
16202>>>>>>>>>        Handle hDispatchDriver
16202>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16203>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
16204>>>>>>>>>    End_Procedure
16205>>>>>>>>>
16205>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
16207>>>>>>>>>        Handle hDispatchDriver
16207>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16208>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16209>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
16210>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
16211>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
16212>>>>>>>>>    End_Procedure
16213>>>>>>>>>
16213>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
16215>>>>>>>>>        Handle hDispatchDriver
16215>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16216>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16217>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
16218>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
16219>>>>>>>>>    End_Procedure
16220>>>>>>>>>
16220>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
16222>>>>>>>>>        Handle hDispatchDriver
16222>>>>>>>>>        Variant retVal
16222>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16223>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16224>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
16225>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
16226>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
16227>>>>>>>>>        Function_Return retVal
16228>>>>>>>>>    End_Function
16229>>>>>>>>>
16229>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
16231>>>>>>>>>        Handle hDispatchDriver
16231>>>>>>>>>        Variant retVal
16231>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16232>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16233>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
16234>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
16235>>>>>>>>>        Function_Return retVal
16236>>>>>>>>>    End_Function
16237>>>>>>>>>
16237>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
16239>>>>>>>>>        Handle hDispatchDriver
16239>>>>>>>>>        OLE_COLOR retVal
16239>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16240>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16241>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16242>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
16243>>>>>>>>>        Function_Return retVal
16244>>>>>>>>>    End_Function
16245>>>>>>>>>
16245>>>>>>>>>    Procedure ComExcludeModule String llModuleName
16247>>>>>>>>>        Handle hDispatchDriver
16247>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16248>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16249>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
16250>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
16251>>>>>>>>>    End_Procedure
16252>>>>>>>>>
16252>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
16254>>>>>>>>>        Handle hDispatchDriver
16254>>>>>>>>>        Variant retVal
16254>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16255>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16256>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
16257>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
16258>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
16259>>>>>>>>>        Function_Return retVal
16260>>>>>>>>>    End_Function
16261>>>>>>>>>
16261>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
16263>>>>>>>>>        Handle hDispatchDriver
16263>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16264>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16265>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16266>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
16267>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
16268>>>>>>>>>    End_Procedure
16269>>>>>>>>>
16269>>>>>>>>>    Procedure ComAboutBox
16271>>>>>>>>>        Handle hDispatchDriver
16271>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16272>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
16273>>>>>>>>>    End_Procedure
16274>>>>>>>>>End_Class
16275>>>>>>>>>
16275>>>>>>>>>// CLSID: {C0DE2000-4463-4030-B324-AC6A8075FEC8}
16275>>>>>>>>>// Event interface for SkinFramework Control
16275>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
16276>>>>>>>>>
16276>>>>>>>>>    Procedure RegisterComEvents
16278>>>>>>>>>    End_Procedure
16279>>>>>>>>>End_Class
16280>>>>>>>>>
16280>>>>>>>>>// CoClass
16280>>>>>>>>>// ProgID: Codejock.SkinFramework.20.0.0
16280>>>>>>>>>// CLSID: {C0DE2000-2217-42EE-B1B0-82C890431F17}
16280>>>>>>>>>// SkinFramework Control
16280>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
16281>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
16282>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
16283>>>>>>>>>
16283>>>>>>>>>    Procedure Construct_Object
16285>>>>>>>>>        Forward Send Construct_Object
16287>>>>>>>>>        Set psProgID to "{C0DE2000-2217-42EE-B1B0-82C890431F17}"
16288>>>>>>>>>        Set psEventId to "{C0DE2000-4463-4030-B324-AC6A8075FEC8}"
16289>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2021 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v20.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
16290>>>>>>>>>        Set peAutoCreate to acAutoCreate
16291>>>>>>>>>    End_Procedure
16292>>>>>>>>>End_Class
16293>>>>>>>>>
16293>>>>>>>>>// CLSID: {C0DE2000-CA9A-4AA9-8601-0AB7F551AA3D}
16293>>>>>>>>>// SkinFramework Global Settings
16293>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
16294>>>>>>>>>
16294>>>>>>>>>    Function ComLicense Returns String
16296>>>>>>>>>        String retVal
16296>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
16297>>>>>>>>>        Function_Return retVal
16298>>>>>>>>>    End_Function
16299>>>>>>>>>
16299>>>>>>>>>    Procedure Set ComLicense String value
16301>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
16302>>>>>>>>>    End_Procedure
16303>>>>>>>>>
16303>>>>>>>>>    Function ComTitle Returns String
16305>>>>>>>>>        String retVal
16305>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
16306>>>>>>>>>        Function_Return retVal
16307>>>>>>>>>    End_Function
16308>>>>>>>>>
16308>>>>>>>>>    Procedure Set ComTitle String value
16310>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
16311>>>>>>>>>    End_Procedure
16312>>>>>>>>>
16312>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
16312>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
16314>>>>>>>>>        Boolean retVal
16314>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
16315>>>>>>>>>        Function_Return retVal
16316>>>>>>>>>    End_Function
16317>>>>>>>>>
16317>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
16317>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
16319>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
16320>>>>>>>>>    End_Procedure
16321>>>>>>>>>
16321>>>>>>>>>    Function ComVersion Returns String
16323>>>>>>>>>        Handle hDispatchDriver
16323>>>>>>>>>        String retVal
16323>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16324>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
16325>>>>>>>>>        Function_Return retVal
16326>>>>>>>>>    End_Function
16327>>>>>>>>>
16327>>>>>>>>>    Function ComUnicode Returns Boolean
16329>>>>>>>>>        Handle hDispatchDriver
16329>>>>>>>>>        Boolean retVal
16329>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16330>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
16331>>>>>>>>>        Function_Return retVal
16332>>>>>>>>>    End_Function
16333>>>>>>>>>
16333>>>>>>>>>    Function ComOcxPath Returns String
16335>>>>>>>>>        Handle hDispatchDriver
16335>>>>>>>>>        String retVal
16335>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16336>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
16337>>>>>>>>>        Function_Return retVal
16338>>>>>>>>>    End_Function
16339>>>>>>>>>End_Class
16340>>>>>>>>>
16340>>>>>>>>>// CoClass
16340>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.20.0.0
16340>>>>>>>>>// CLSID: {C0DE2000-F744-4373-B38D-29CE83EF0EE5}
16340>>>>>>>>>// SkinFramework Global Settings
16340>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
16341>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
16342>>>>>>>>>
16342>>>>>>>>>    Procedure Construct_Object
16344>>>>>>>>>        Forward Send Construct_Object
16346>>>>>>>>>        Set psProgID to "{C0DE2000-F744-4373-B38D-29CE83EF0EE5}"
16347>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
16348>>>>>>>>>    End_Procedure
16349>>>>>>>>>End_Class
16350>>>>>>>>>
16350>>>>>>>>>// CLSID: {C0DE2000-1038-498E-A936-361F08B4C4AA}
16350>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
16351>>>>>>>>>
16351>>>>>>>>>    Function ComColorScheme Returns String
16353>>>>>>>>>        String retVal
16353>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
16354>>>>>>>>>        Function_Return retVal
16355>>>>>>>>>    End_Function
16356>>>>>>>>>
16356>>>>>>>>>    Procedure Set ComColorScheme String value
16358>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
16359>>>>>>>>>    End_Procedure
16360>>>>>>>>>
16360>>>>>>>>>    Function ComFontSize Returns String
16362>>>>>>>>>        String retVal
16362>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
16363>>>>>>>>>        Function_Return retVal
16364>>>>>>>>>    End_Function
16365>>>>>>>>>
16365>>>>>>>>>    Procedure Set ComFontSize String value
16367>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
16368>>>>>>>>>    End_Procedure
16369>>>>>>>>>
16369>>>>>>>>>    Function ComIniFileName Returns String
16371>>>>>>>>>        String retVal
16371>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
16372>>>>>>>>>        Function_Return retVal
16373>>>>>>>>>    End_Function
16374>>>>>>>>>
16374>>>>>>>>>    Procedure Set ComIniFileName String value
16376>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
16377>>>>>>>>>    End_Procedure
16378>>>>>>>>>End_Class
16379>>>>>>>>>
16379>>>>>>>>>// CLSID: {C0DE2000-4834-499E-95B4-30E0C3F43A10}
16379>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
16380>>>>>>>>>
16380>>>>>>>>>    Function ComName Returns String
16382>>>>>>>>>        String retVal
16382>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
16383>>>>>>>>>        Function_Return retVal
16384>>>>>>>>>    End_Function
16385>>>>>>>>>
16385>>>>>>>>>    Procedure Set ComName String value
16387>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
16388>>>>>>>>>    End_Procedure
16389>>>>>>>>>
16389>>>>>>>>>    Function ComPath Returns String
16391>>>>>>>>>        String retVal
16391>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
16392>>>>>>>>>        Function_Return retVal
16393>>>>>>>>>    End_Function
16394>>>>>>>>>
16394>>>>>>>>>    Procedure Set ComPath String value
16396>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
16397>>>>>>>>>    End_Procedure
16398>>>>>>>>>
16398>>>>>>>>>    Function ComCount Returns Integer
16400>>>>>>>>>        Handle hDispatchDriver
16400>>>>>>>>>        Integer retVal
16400>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16401>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
16402>>>>>>>>>        Function_Return retVal
16403>>>>>>>>>    End_Function
16404>>>>>>>>>
16404>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
16406>>>>>>>>>        Handle hDispatchDriver
16406>>>>>>>>>        Variant retVal
16406>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16407>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16408>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16409>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
16410>>>>>>>>>        Function_Return retVal
16411>>>>>>>>>    End_Function
16412>>>>>>>>>
16412>>>>>>>>>    Function Com_NewEnum Returns Variant
16414>>>>>>>>>        Handle hDispatchDriver
16414>>>>>>>>>        Variant retVal
16414>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16415>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
16416>>>>>>>>>        Function_Return retVal
16417>>>>>>>>>    End_Function
16418>>>>>>>>>End_Class
16419>>>>>>>>>
16419>>>>>>>>>// CLSID: {C0DE2000-FB37-4B08-A2B9-F6F8B253D697}
16419>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
16420>>>>>>>>>
16420>>>>>>>>>    Function ComCount Returns Integer
16422>>>>>>>>>        Handle hDispatchDriver
16422>>>>>>>>>        Integer retVal
16422>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16423>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
16424>>>>>>>>>        Function_Return retVal
16425>>>>>>>>>    End_Function
16426>>>>>>>>>
16426>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
16428>>>>>>>>>        Handle hDispatchDriver
16428>>>>>>>>>        Variant retVal
16428>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16429>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16430>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16431>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
16432>>>>>>>>>        Function_Return retVal
16433>>>>>>>>>    End_Function
16434>>>>>>>>>
16434>>>>>>>>>    Function Com_NewEnum Returns Variant
16436>>>>>>>>>        Handle hDispatchDriver
16436>>>>>>>>>        Variant retVal
16436>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16437>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
16438>>>>>>>>>        Function_Return retVal
16439>>>>>>>>>    End_Function
16440>>>>>>>>>End_Class
16441>>>>>>>>>
16441>>>>>>>>>// CLSID: {C0DE2000-C56F-43C0-BCF1-8193B35FE4C4}
16441>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
16442>>>>>>>>>
16442>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
16444>>>>>>>>>        Handle hDispatchDriver
16444>>>>>>>>>        OLE_COLOR retVal
16444>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16445>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16446>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16447>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
16448>>>>>>>>>        Function_Return retVal
16449>>>>>>>>>    End_Function
16450>>>>>>>>>End_Class
16451>>>>>>>Use cApplication.pkg
16451>>>>>>>
16451>>>>>>>Struct tSkinInformation
16451>>>>>>>    String sName     // description of the skin
16451>>>>>>>    String sSkinfile // file path. Can be relative or full
16451>>>>>>>    String sSkinIni  // section name
16451>>>>>>>End_Struct
16451>>>>>>>
16451>>>>>>>
16451>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
16452>>>>>>>    
16452>>>>>>>    Procedure Construct_Object
16454>>>>>>>        Forward Send Construct_Object
16456>>>>>>>        
16456>>>>>>>        Property String psSkinFile ""
16457>>>>>>>        Property String psSkinIni ""
16458>>>>>>>        Property Boolean pbLoadPreference False
16459>>>>>>>        
16459>>>>>>>        Set peAutoCreate to acAutoCreate
16460>>>>>>>        
16460>>>>>>>        Move Self to ghoSkinFramework
16461>>>>>>>    End_Procedure
16462>>>>>>>    
16462>>>>>>>    // return the default skin path, which is the programs directory.
16462>>>>>>>    // This requires an application object.
16462>>>>>>>    // If you want to different skin path, override this.
16462>>>>>>>    Function SkinPath Returns String
16464>>>>>>>        String sPath sPaths
16464>>>>>>>        Handle hoWorkspace
16464>>>>>>>        If ghoApplication Begin
16466>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
16467>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
16468>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
16469>>>>>>>        End
16469>>>>>>>>
16469>>>>>>>        Else Begin
16470>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16471>>>>>>>>
16471>>>>>>>        End
16471>>>>>>>>
16471>>>>>>>        Function_Return sPath
16472>>>>>>>    End_Function
16473>>>>>>>    
16473>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
16473>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
16473>>>>>>>    Function SkinQFile Returns String
16475>>>>>>>        String sFile sPath sSep
16475>>>>>>>        Boolean bQualified
16475>>>>>>>        Get psSkinFile to sFile
16476>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
16478>>>>>>>            Get SkinPath to sPath
16479>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
16480>>>>>>>            Move (sPath - sSep - sFile) to sFile
16481>>>>>>>        End
16481>>>>>>>>
16481>>>>>>>        Function_Return sFile
16482>>>>>>>    End_Function
16483>>>>>>>    
16483>>>>>>>    // defines the default VDF window class mapping.
16483>>>>>>>    Procedure OnAddVDFWindowClasses
16485>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
16486>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
16487>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
16488>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
16489>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
16490>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
16491>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
16492>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
16493>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
16494>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
16495>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
16496>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
16497>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
16498>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
16499>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
16500>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
16501>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
16502>>>>>>>        // External class
16502>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
16503>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
16504>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
16505>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
16506>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
16507>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
16508>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
16509>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
16510>>>>>>>    End_Procedure
16511>>>>>>>    
16511>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
16511>>>>>>>    Procedure OnAddCustomWindowClasses
16513>>>>>>>    End_Procedure
16514>>>>>>>    
16514>>>>>>>    // called when object is created during end_construct_object.
16514>>>>>>>    Procedure OnCreate
16516>>>>>>>        Integer iOpts
16516>>>>>>>        Boolean bUseWindowsFont
16516>>>>>>>        Forward Send OnCreate
16518>>>>>>>        
16518>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
16518>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
16518>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
16519>>>>>>>        If bUseWindowsFont Begin
16521>>>>>>>            Get ComApplyOptions to iOpts
16522>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
16523>>>>>>>        End
16523>>>>>>>>
16523>>>>>>>        
16523>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
16523>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
16523>>>>>>>        // and this was the suggested workaround.
16523>>>>>>>        Set ComAutoApplyNewThreads to False
16524>>>>>>>        
16524>>>>>>>        Send OnAddVDFWindowClasses
16525>>>>>>>        Send OnAddCustomWindowClasses
16526>>>>>>>        
16526>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
16526>>>>>>>        If (pbLoadPreference(Self)) Begin
16528>>>>>>>            Send LoadSkinPreference
16529>>>>>>>        End
16529>>>>>>>>
16529>>>>>>>        // if a skin file name exists, we apply the skin.
16529>>>>>>>        If (psSkinFile(Self)<>"") Begin
16531>>>>>>>            Send ApplySkin
16532>>>>>>>        End
16532>>>>>>>>
16532>>>>>>>    End_Procedure
16533>>>>>>>    
16533>>>>>>>    // called by framework as part of application exit.
16533>>>>>>>    Procedure Broadcast_Notify_Exit_Application
16535>>>>>>>        Send Notify_Exit_Application
16536>>>>>>>    End_Procedure
16537>>>>>>>    
16537>>>>>>>    Procedure Notify_Exit_Application
16539>>>>>>>        If (pbLoadPreference(Self)) Begin
16541>>>>>>>            Send SaveSkinPreference
16542>>>>>>>        End
16542>>>>>>>>
16542>>>>>>>    End_Procedure
16543>>>>>>>    
16543>>>>>>>    Procedure NotifyPreApplySkin
16545>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
16547>>>>>>>    End_Procedure
16548>>>>>>>    
16548>>>>>>>    Procedure NotifyPostApplySkin
16550>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
16552>>>>>>>    End_Procedure
16553>>>>>>>    
16553>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
16553>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
16553>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
16555>>>>>>>        tSkinInformation[] Skins
16555>>>>>>>        tSkinInformation[] Skins
16556>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
16556>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
16556>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
16556>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
16556>>>>>>>        Integer iPos iDfltLen
16556>>>>>>>        Boolean bUseRelativePath
16556>>>>>>>        
16556>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
16557>>>>>>>        
16557>>>>>>>        Get SkinPath to sDefaultPath
16558>>>>>>>        If (sPath="") Begin
16560>>>>>>>            Move sDefaultPath to sPath
16561>>>>>>>        End
16561>>>>>>>>
16561>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
16562>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
16563>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
16564>>>>>>>        
16564>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
16565>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
16567>>>>>>>            
16567>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
16568>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
16569>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
16570>>>>>>>            
16570>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
16571>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
16572>>>>>>>            
16572>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
16578>>>>>>>>
16578>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
16579>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
16580>>>>>>>                
16580>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
16581>>>>>>>                
16581>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
16587>>>>>>>>
16587>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
16588>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
16589>>>>>>>                    
16589>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
16590>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
16591>>>>>>>                    If bUseRelativePath Begin
16593>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
16594>>>>>>>                        If iPos Begin
16596>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
16597>>>>>>>                            While (Left(sSkinFile,1)=sSep)
16601>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
16602>>>>>>>                            Loop
16603>>>>>>>>
16603>>>>>>>                        End
16603>>>>>>>>
16603>>>>>>>                    End
16603>>>>>>>>
16603>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
16604>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
16605>>>>>>>                    
16605>>>>>>>                    Increment iArrayItem
16606>>>>>>>                Loop
16607>>>>>>>>
16607>>>>>>>            Loop
16608>>>>>>>>
16608>>>>>>>            
16608>>>>>>>            Send Destroy of hSkinDescriptions
16609>>>>>>>            Send Destroy of hSkinDescription
16610>>>>>>>            Send Destroy of hSkinIniFile
16611>>>>>>>            
16611>>>>>>>        End
16611>>>>>>>>
16611>>>>>>>        Function_Return Skins
16612>>>>>>>    End_Function
16613>>>>>>>    
16613>>>>>>>    // Save the skin preference. This requires an application object.
16613>>>>>>>    // Only do this if the application object allows it.
16613>>>>>>>    // This is called during startup if pbLoadPreference is True
16613>>>>>>>    // Suitable for override
16613>>>>>>>    Procedure SaveSkinPreference
16615>>>>>>>        String sSkin sIni
16615>>>>>>>        If ghoApplication Begin
16617>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
16619>>>>>>>                Get psSkinFile to sSkin
16620>>>>>>>                Get psSkinIni to sIni
16621>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
16622>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
16623>>>>>>>            End
16623>>>>>>>>
16623>>>>>>>        End
16623>>>>>>>>
16623>>>>>>>        Else Begin
16624>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16625>>>>>>>>
16625>>>>>>>        End
16625>>>>>>>>
16625>>>>>>>    End_Procedure
16626>>>>>>>    
16626>>>>>>>    // Load the skin preference. This requires an application object.
16626>>>>>>>    // Only do this if the application object allows it.
16626>>>>>>>    // This is called during startup if pbLoadPreference is True
16626>>>>>>>    // Suitable for override
16626>>>>>>>    Procedure LoadSkinPreference
16628>>>>>>>        String sSkin sIni
16628>>>>>>>        Boolean bExists
16628>>>>>>>        If ghoApplication Begin
16630>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
16632>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
16633>>>>>>>                If bExists Begin
16635>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
16636>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
16637>>>>>>>                    Set psSkinFile to sSkin
16638>>>>>>>                    Set psSkinIni to sIni
16639>>>>>>>                End
16639>>>>>>>>
16639>>>>>>>            End
16639>>>>>>>>
16639>>>>>>>        End
16639>>>>>>>>
16639>>>>>>>        Else Begin
16640>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16641>>>>>>>>
16641>>>>>>>        End
16641>>>>>>>>
16641>>>>>>>    End_Procedure
16642>>>>>>>    
16642>>>>>>>    // Can be called to apply the current skin.
16642>>>>>>>    Procedure ApplySkin
16644>>>>>>>        Boolean bOk
16644>>>>>>>        String sSkin sIni
16644>>>>>>>        If (IsComObjectCreated(Self)) Begin
16646>>>>>>>            Get SkinQFile to sSkin
16647>>>>>>>            Get psSkinIni to sIni
16648>>>>>>>            
16648>>>>>>>            Send NotifyPreApplySkin
16649>>>>>>>            // when skins are used we don't want to use built in Visual Styles
16649>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
16650>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
16651>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
16653>>>>>>>                // if not ok, no skin was appied. Enable visual styles
16653>>>>>>>                Send EnableVisualStyles of Desktop True
16654>>>>>>>            End
16654>>>>>>>>
16654>>>>>>>            Send NotifyPostApplySkin
16655>>>>>>>        End
16655>>>>>>>>
16655>>>>>>>    End_Procedure
16656>>>>>>>    
16656>>>>>>>    
16656>>>>>>>End_Class
16657>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cProgressBar.pkg)
16657>>>>>>>Use Windows.pkg
16657>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cWinControl.pkg)
16657>>>>>>>>>Use Windows.pkg
16657>>>>>>>>>
16657>>>>>>>>>// Key State Masks for Mouse Messages
16657>>>>>>>>>
16657>>>>>>>>>Define MK_LBUTTON  for |CI$0001
16657>>>>>>>>>Define MK_RBUTTON  for |CI$0002
16657>>>>>>>>>Define MK_SHIFT    for |CI$0004
16657>>>>>>>>>Define MK_CONTROL  for |CI$0008
16657>>>>>>>>>Define MK_MBUTTON  for |CI$0010
16657>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
16657>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
16657>>>>>>>>>
16657>>>>>>>>>Enum_List // Mouse Key Flags
16657>>>>>>>>>    Define mkLeft    for MK_LBUTTON
16657>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
16657>>>>>>>>>    Define mkRight   for MK_RBUTTON
16657>>>>>>>>>    Define mkX1      for MK_XBUTTON1
16657>>>>>>>>>    Define mkX2      for MK_XBUTTON2
16657>>>>>>>>>    Define mkShift   for MK_SHIFT
16657>>>>>>>>>    Define mkControl for MK_CONTROL
16657>>>>>>>>>End_Enum_List
16657>>>>>>>>>
16657>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
16657>>>>>>>>>    Define mbLeft
16657>>>>>>>>>    Define mbMiddle
16657>>>>>>>>>    Define mbRight
16657>>>>>>>>>    Define mbX1
16657>>>>>>>>>    Define mbX2
16657>>>>>>>>>End_Enum_List
16657>>>>>>>>>
16657>>>>>>>>>Class cWinControl is a DfBaseControl
16658>>>>>>>>>    Procedure Construct_Object
16660>>>>>>>>>        Forward Send Construct_Object
16662>>>>>>>>>        Property Integer private_pbEnabled True
16663>>>>>>>>>        Property Integer private_pbVisible True
16664>>>>>>>>>    End_Procedure
16665>>>>>>>>>    
16665>>>>>>>>>    Procedure End_Construct_Object
16667>>>>>>>>>        Forward Send End_Construct_Object
16669>>>>>>>>>        
16669>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
16670>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
16671>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
16672>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
16673>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
16674>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
16675>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
16676>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
16677>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
16678>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
16679>>>>>>>>>    End_Procedure
16680>>>>>>>>>    
16680>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
16682>>>>>>>>>        //Intentionally cancelled
16682>>>>>>>>>    End_Procedure
16683>>>>>>>>>    
16683>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
16685>>>>>>>>>        //Intentionally cancelled
16685>>>>>>>>>    End_Procedure
16686>>>>>>>>>    
16686>>>>>>>>>    Procedure DoRecreateWindow
16688>>>>>>>>>        // Recreates the window
16688>>>>>>>>>        If (Window_Handle(Self)) Begin
16690>>>>>>>>>            // attempt to do this without disturbing the focus tree.
16690>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
16691>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
16692>>>>>>>>>        End
16692>>>>>>>>>>
16692>>>>>>>>>    End_Procedure
16693>>>>>>>>>    
16693>>>>>>>>>    Procedure DoUpdateWindow
16695>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
16695>>>>>>>>>        Handle hWnd
16695>>>>>>>>>        
16695>>>>>>>>>        Get Window_Handle to hWnd
16696>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
16699>>>>>>>>>    End_Procedure
16700>>>>>>>>>    
16700>>>>>>>>>    Procedure Page Integer iState
16702>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
16703>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
16704>>>>>>>>>        Forward Send Page iState
16706>>>>>>>>>    End_Procedure
16707>>>>>>>>>    
16707>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
16709>>>>>>>>>        Integer x y eButton
16709>>>>>>>>>        
16709>>>>>>>>>        Move (Hi(lParam))  to y
16710>>>>>>>>>        Move (Low(lParam)) to x
16711>>>>>>>>>        
16711>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
16712>>>>>>>>>    End_Procedure
16713>>>>>>>>>    
16713>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
16715>>>>>>>>>        Integer x y eButton
16715>>>>>>>>>        
16715>>>>>>>>>        Move (Hi(lParam))  to y
16716>>>>>>>>>        Move (Low(lParam)) to x
16717>>>>>>>>>        
16717>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
16718>>>>>>>>>    End_Procedure
16719>>>>>>>>>    
16719>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
16721>>>>>>>>>        Integer x y eButton
16721>>>>>>>>>        
16721>>>>>>>>>        Move (Hi(lParam))  to y
16722>>>>>>>>>        Move (Low(lParam)) to x
16723>>>>>>>>>        
16723>>>>>>>>>        Send OnMouseUp mbRight x y wParam
16724>>>>>>>>>    End_Procedure
16725>>>>>>>>>    
16725>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
16727>>>>>>>>>        Integer x y eButton fKeys
16727>>>>>>>>>        
16727>>>>>>>>>        Move (Hi(lParam))  to y
16728>>>>>>>>>        Move (Low(lParam)) to x
16729>>>>>>>>>        
16729>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
16730>>>>>>>>>    End_Procedure
16731>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
16733>>>>>>>>>        Integer x y eButton
16733>>>>>>>>>        
16733>>>>>>>>>        Move (Hi(lParam))  to y
16734>>>>>>>>>        Move (Low(lParam)) to x
16735>>>>>>>>>        
16735>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
16736>>>>>>>>>    End_Procedure
16737>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
16739>>>>>>>>>        Integer x y eButton
16739>>>>>>>>>        
16739>>>>>>>>>        Move (Hi(lParam))  to y
16740>>>>>>>>>        Move (Low(lParam)) to x
16741>>>>>>>>>        
16741>>>>>>>>>        Send OnMouseDown mbRight x y wParam
16742>>>>>>>>>    End_Procedure
16743>>>>>>>>>    
16743>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
16745>>>>>>>>>        Integer x y eButton
16745>>>>>>>>>        
16745>>>>>>>>>        Move (Hi(lParam))  to y
16746>>>>>>>>>        Move (Low(lParam)) to x
16747>>>>>>>>>        
16747>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
16748>>>>>>>>>    End_Procedure
16749>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
16751>>>>>>>>>        Integer x y eButton
16751>>>>>>>>>        
16751>>>>>>>>>        Move (Hi(lParam))  to y
16752>>>>>>>>>        Move (Low(lParam)) to x
16753>>>>>>>>>        
16753>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
16754>>>>>>>>>    End_Procedure
16755>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
16757>>>>>>>>>        Integer x y eButton
16757>>>>>>>>>        
16757>>>>>>>>>        Move (Hi(lParam))  to y
16758>>>>>>>>>        Move (Low(lParam)) to x
16759>>>>>>>>>        
16759>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
16760>>>>>>>>>    End_Procedure
16761>>>>>>>>>    
16761>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
16763>>>>>>>>>        Integer x y eButton
16763>>>>>>>>>        
16763>>>>>>>>>        Move (Hi(lParam))  to y
16764>>>>>>>>>        Move (Low(lParam)) to x
16765>>>>>>>>>        
16765>>>>>>>>>        Send OnMouseMove x y wParam
16766>>>>>>>>>    End_Procedure
16767>>>>>>>>>    
16767>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
16769>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16769>>>>>>>>>        //String sButton
16769>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16769>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16769>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16769>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16769>>>>>>>>>        
16769>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16769>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16769>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16769>>>>>>>>>    End_Procedure
16770>>>>>>>>>    
16770>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
16772>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16772>>>>>>>>>        //String sButton
16772>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16772>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16772>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16772>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16772>>>>>>>>>        
16772>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16772>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16772>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16772>>>>>>>>>    End_Procedure
16773>>>>>>>>>    
16773>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
16775>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16775>>>>>>>>>        //String sButton
16775>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16775>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16775>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16775>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16775>>>>>>>>>        
16775>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16775>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16775>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16775>>>>>>>>>    End_Procedure
16776>>>>>>>>>    
16776>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
16778>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16778>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16778>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16778>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16778>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16778>>>>>>>>>        
16778>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16778>>>>>>>>>    End_Procedure
16779>>>>>>>>>    
16779>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
16781>>>>>>>>>        Handle hWnd
16781>>>>>>>>>        
16781>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
16783>>>>>>>>>            Set private_pbEnabled to bEnabled
16784>>>>>>>>>            Get Window_Handle to hWnd
16785>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
16788>>>>>>>>>        End
16788>>>>>>>>>>
16788>>>>>>>>>    End_Procedure
16789>>>>>>>>>    Function pbEnabled Returns Boolean
16791>>>>>>>>>        Function_Return (private_pbEnabled(Self))
16792>>>>>>>>>    End_Function
16793>>>>>>>>>    
16793>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
16795>>>>>>>>>        Handle  hWnd
16795>>>>>>>>>        Integer iVoid
16795>>>>>>>>>        
16795>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
16797>>>>>>>>>            Set private_pbVisible to bVisible
16798>>>>>>>>>            Get Window_Handle to hWnd
16799>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
16802>>>>>>>>>        End
16802>>>>>>>>>>
16802>>>>>>>>>    End_Procedure
16803>>>>>>>>>    Function pbVisible Returns Boolean
16805>>>>>>>>>        Function_Return (private_pbVisible(Self))
16806>>>>>>>>>    End_Function
16807>>>>>>>>>    
16807>>>>>>>>>End_Class
16808>>>>>>>Use CommCtrl.pkg
16808>>>>>>>
16808>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
16808>>>>>>>Class cProgressBar is a cWinControl
16809>>>>>>>    
16809>>>>>>>    Procedure Construct_Object
16811>>>>>>>        Forward Send Construct_Object
16813>>>>>>>        Property Integer private_piMinimum
16814>>>>>>>        Property Integer private_piMaximum   100
16815>>>>>>>        Property Integer private_piAdvanceBy 10
16816>>>>>>>        Property Integer private_piPosition
16817>>>>>>>        Property Integer private_pbVertical  False
16818>>>>>>>        Property Integer private_pbSmooth    False
16819>>>>>>>        Property Integer private_piBackColor clDefault
16820>>>>>>>        Property Integer private_piBarColor  clDefault
16821>>>>>>>        
16821>>>>>>>        Send Define_ToolTip_Support_Mixin
16822>>>>>>>        
16822>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
16823>>>>>>>        Set Focus_Mode to NonFocusable
16824>>>>>>>        Set Skip_State to True
16825>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
16826>>>>>>>    End_Procedure
16827>>>>>>>    
16827>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
16828>>>>>>>    
16828>>>>>>>    Procedure Set piMinimum Integer iMin
16830>>>>>>>        Integer iMax
16830>>>>>>>        
16830>>>>>>>        Set private_piMinimum to iMin
16831>>>>>>>        Get private_piMaximum to iMax
16832>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
16833>>>>>>>    End_Procedure
16834>>>>>>>    Function piMinimum Returns Integer
16836>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
16839>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
16841>>>>>>>    End_Function
16842>>>>>>>    
16842>>>>>>>    Procedure Set piMaximum Integer iMax
16844>>>>>>>        Integer iMin
16844>>>>>>>        
16844>>>>>>>        Set private_piMaximum to iMax
16845>>>>>>>        Get private_piMinimum to iMin
16846>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
16847>>>>>>>    End_Procedure
16848>>>>>>>    Function piMaximum Returns Integer
16850>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
16853>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
16855>>>>>>>    End_Function
16856>>>>>>>    
16856>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
16858>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
16859>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
16860>>>>>>>    End_Procedure
16861>>>>>>>    Function piAdvanceBy Returns Integer
16863>>>>>>>        Function_Return (private_piAdvanceBy(Self))
16864>>>>>>>    End_Function
16865>>>>>>>    
16865>>>>>>>    Procedure Set piPosition Integer iPos
16867>>>>>>>        Set private_piPosition to iPos
16868>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
16869>>>>>>>    End_Procedure
16870>>>>>>>    
16870>>>>>>>    Function piPosition Returns Integer
16872>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
16875>>>>>>>        Else;            Function_Return (private_piPosition(Self))
16877>>>>>>>    End_Function
16878>>>>>>>    
16878>>>>>>>    Procedure Set pbVertical Boolean bVertical
16880>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
16882>>>>>>>            Set private_pbVertical to bVertical
16883>>>>>>>            Send DoRecreateWindow
16884>>>>>>>        End
16884>>>>>>>>
16884>>>>>>>    End_Procedure
16885>>>>>>>    
16885>>>>>>>    Function pbVertical Returns Boolean
16887>>>>>>>        Function_Return (private_pbVertical(Self))
16888>>>>>>>    End_Function
16889>>>>>>>    
16889>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
16891>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
16893>>>>>>>            Set private_pbSmooth to bSmooth
16894>>>>>>>            Send DoRecreateWindow
16895>>>>>>>        End
16895>>>>>>>>
16895>>>>>>>    End_Procedure
16896>>>>>>>    Function pbSmooth Returns Boolean
16898>>>>>>>        Function_Return (private_pbSmooth(Self))
16899>>>>>>>    End_Function
16900>>>>>>>    
16900>>>>>>>    Procedure Set piBackColor Integer rgbColor
16902>>>>>>>        Set private_piBackColor to rgbColor
16903>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
16904>>>>>>>    End_Procedure
16905>>>>>>>    Function piBackColor Returns Integer
16907>>>>>>>        Function_Return (private_piBackColor(Self))
16908>>>>>>>    End_Function
16909>>>>>>>    
16909>>>>>>>    Procedure Set piBarColor Integer rgbColor
16911>>>>>>>        Set private_piBarColor to rgbColor
16912>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
16913>>>>>>>    End_Procedure
16914>>>>>>>    Function piBarColor Returns Integer
16916>>>>>>>        Function_Return (private_piBarColor(Self))
16917>>>>>>>    End_Function
16918>>>>>>>    
16918>>>>>>>    Procedure DoAdvance
16920>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
16921>>>>>>>    End_Procedure
16922>>>>>>>    
16922>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
16924>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
16925>>>>>>>    End_Procedure
16926>>>>>>>    
16926>>>>>>>    Procedure private_DoInitWindow
16928>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
16929>>>>>>>        Set piBackColor to (private_piBackColor(Self))
16930>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
16931>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
16932>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
16933>>>>>>>        Set piPosition  to (private_piPosition(Self))
16934>>>>>>>    End_Procedure
16935>>>>>>>    
16935>>>>>>>    Procedure Page_Object Integer iState
16937>>>>>>>        Handle hWnd
16937>>>>>>>        
16937>>>>>>>        Get Window_Handle to hWnd
16938>>>>>>>        If (hWnd=0 and iState) Begin
16940>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
16941>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
16942>>>>>>>            Forward Send Page_Object True
16944>>>>>>>        End
16944>>>>>>>>
16944>>>>>>>        Else ;            Forward Send Page_Object iState
16947>>>>>>>        
16947>>>>>>>        // Handle tooltip support....
16947>>>>>>>        If (iState = 0) Begin
16949>>>>>>>            Send RequestDeleteToolTip
16950>>>>>>>        End
16950>>>>>>>>
16950>>>>>>>        Else Begin
16951>>>>>>>            Send RequestAddToolTip
16952>>>>>>>        End
16952>>>>>>>>
16952>>>>>>>    End_Procedure
16953>>>>>>>    
16953>>>>>>>    Procedure Page Integer iState
16955>>>>>>>        Forward Send Page iState
16957>>>>>>>        If (iState =1);            Send private_DoInitWindow
16960>>>>>>>    End_Procedure
16961>>>>>>>    
16961>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
16961>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
16961>>>>>>>    // is implemented in a mixin class.
16961>>>>>>>    Procedure RequestAddToolTip
16963>>>>>>>        Send AddToolTip
16964>>>>>>>    End_Procedure
16965>>>>>>>    
16965>>>>>>>    
16965>>>>>>>    // Called by Page_Object. Handles tooltip removal.
16965>>>>>>>    Procedure RequestDeleteToolTip
16967>>>>>>>        Send DeleteToolTip
16968>>>>>>>    End_Procedure
16969>>>>>>>End_Class
16970>>>>>Use Windows.pkg
16970>>>>>Use DUFLanguageConstants.inc
16970>>>>>
16970>>>>>    Global_Variable Handle ghoStatusPanel // will contain the ID of the global StatusPanel object
16970>>>>>
16970>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
16970>>>>>
16970>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
16970>>>>>
16970>>>>>Object Status_Panel is a cProcessStatusPanel
16972>>>>>    Set Size to 152 222
16973>>>>>    Set Border_Style to Border_Dialog
16974>>>>>    Set Icon to "Default.ico"
16975>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
16976>>>>>
16976>>>>>    Property Boolean Cancel_Button_Visible_State True
16978>>>>>
16978>>>>>    Procedure Activate
16981>>>>>        Integer iSizeBefore
16981>>>>>        Get GuiSize to iSizeBefore
16982>>>>>        Forward Send Activate
16984>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
16985>>>>>    End_Procedure
16986>>>>>
16986>>>>>    Procedure End_Construct_Object
16989>>>>>        Forward Send End_Construct_Object
16991>>>>>        Set Label of oTitleTxt      to ""
16992>>>>>        Set Label of oTableNameTxt  to ""
16993>>>>>        Set Label of oMessageTxt    to ""
16994>>>>>        Set Label of oActionTxt     to ""
16995>>>>>    End_Procedure
16996>>>>>
16996>>>>>    Object oTitleTxt is a TextBox
16998>>>>>        Set Location to 5 21
16999>>>>>        Set Size to 8 179
17000>>>>>        Set Auto_Size_State to False
17001>>>>>        Set Justification_Mode  to jMode_Center
17002>>>>>        Set Label to "This is the Title Text"
17003>>>>>    End_Object
17004>>>>>
17004>>>>>    Object oTableNameTxt is a TextBox
17006>>>>>        Set Size to 19 204
17007>>>>>        Set Location to 18 9
17008>>>>>        Set Auto_Size_State to False
17009>>>>>        Set Justification_Mode to JMode_Left
17010>>>>>        Set Label to "This is the TableName Text"
17011>>>>>    End_Object
17012>>>>>
17012>>>>>    Object oMessageTxt is a TextBox
17014>>>>>        Set Location to 39 9
17015>>>>>        Set Size to 19 204
17016>>>>>        Set Auto_Size_State to False
17017>>>>>        Set Justification_Mode to JMode_Left
17018>>>>>        Set Label to "This is the Message text"
17019>>>>>    End_Object
17020>>>>>
17020>>>>>    Object oActionTxt is a TextBox
17022>>>>>        Set Size to 16 204
17023>>>>>        Set Location to 60 9
17024>>>>>        Set Auto_Size_State to False
17025>>>>>        Set Justification_Mode to JMode_Left
17026>>>>>        Set Label to "This is the Action Text"
17027>>>>>    End_Object
17028>>>>>
17028>>>>>    Object oStopButton is a Button
17030>>>>>        Set Location to 123 82
17031>>>>>        Set Label to C_$Cancel
17032>>>>>
17032>>>>>        Procedure OnClick 
17035>>>>>            Integer iRetval
17035>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
17036>>>>>            If (iRetval = MBR_Yes) Begin
17038>>>>>                Send Exit_Application
17039>>>>>            End
17039>>>>>>
17039>>>>>        End_Procedure
17040>>>>>
17040>>>>>    End_Object
17041>>>>>
17041>>>>>    Object oPercentage_tb is a TextBox
17043>>>>>        Set Location to 74 196
17044>>>>>        Set Size to 10 25
17045>>>>>//        Set Label to "% Done"
17045>>>>>    End_Object
17046>>>>>
17046>>>>>    Object oCopyRight is a TextBox
17048>>>>>        Set Location to 140 21
17049>>>>>        Set Size to 9 197
17050>>>>>        Set FontPointHeight to 8
17051>>>>>        Set Auto_Size_State to False
17052>>>>>        Set Justification_Mode  to jMode_Center
17053>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
17054>>>>>    End_Object
17055>>>>>
17055>>>>>    Object oProgressBar is a cProgressBar
17057>>>>>        Set Size to 10 179
17058>>>>>        Set Location to 83 22
17059>>>>>        Set pbVisible to True // default
17060>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
17061>>>>>    End_Object
17062>>>>>
17062>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
17065>>>>>        Set pbVisible of ghoProgressBar to bVisible
17066>>>>>    End_Procedure
17067>>>>>
17067>>>>>    Function Progress_Bar_Visible_State Returns Boolean
17070>>>>>        Boolean bVisible
17070>>>>>        Get pbVisible of ghoProgressBar to bVisible
17071>>>>>        Function_Return (bVisible)
17072>>>>>    End_Function
17073>>>>>
17073>>>>>    Object oProgressBarOverall is a cProgressBar
17075>>>>>        Set Size to 10 179
17076>>>>>        Set Location to 107 22
17077>>>>>        Set pbVisible to True // default
17078>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
17079>>>>>    End_Object
17080>>>>>
17080>>>>>    Object oOverallProgress_tb is a TextBox
17082>>>>>        Set Size to 10 65
17083>>>>>        Set Location to 95 24
17084>>>>>        Set Label to "Overall Progress"
17085>>>>>    End_Object
17086>>>>>
17086>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
17089>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
17090>>>>>    End_Procedure
17091>>>>>
17091>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
17094>>>>>        Boolean bVisible
17094>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
17095>>>>>        Function_Return (bVisible)
17096>>>>>    End_Function
17097>>>>>
17097>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
17097>>>>>    // objects defined within this instance of the status panel.
17097>>>>>
17097>>>>>    // note: all of the messages that change text should be forwarded
17097>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
17097>>>>>
17097>>>>>    Procedure Set Message_Text String sText
17100>>>>>        Set Label of oMessageTxt to sText
17101>>>>>        Forward Set Message_Text to sText
17103>>>>>    End_Procedure
17104>>>>>
17104>>>>>    Function Message_Text Returns String
17107>>>>>        Function_Return (Label(oMessageTxt))
17108>>>>>    End_Function
17109>>>>>
17109>>>>>    Procedure Set Action_Text String sText
17112>>>>>        Set Label of oActionTxt to sText
17113>>>>>        Forward Set Action_Text to sText
17115>>>>>    End_Procedure
17116>>>>>
17116>>>>>    Function Action_Text Returns String
17119>>>>>        Function_Return (Label(oActionTxt))
17120>>>>>    End_Function
17121>>>>>
17121>>>>>    Procedure Set Button_Text String sText
17124>>>>>        Set Label of oStopButton to sText
17125>>>>>        Forward Set Button_Text to sText
17127>>>>>    End_Procedure
17128>>>>>
17128>>>>>    Function Button_Text Returns String
17131>>>>>        Function_Return (Label(oStopButton))
17132>>>>>    End_Function
17133>>>>>
17133>>>>>    Procedure Set Title_Text String sText
17136>>>>>        Set Label of oTitleTxt to sText
17137>>>>>        Forward Set Title_Text to sText
17139>>>>>    End_Procedure
17140>>>>>
17140>>>>>    Function Title_Text Returns String
17143>>>>>        Function_Return (Label(oTitleTxt))
17144>>>>>    End_Function
17145>>>>>
17145>>>>>    Procedure Set TableName_Text String sText
17148>>>>>        Set Label of oTableNameTxt to sText
17149>>>>>    End_Procedure
17150>>>>>
17150>>>>>    Function TableName_Text Returns String
17153>>>>>        Function_Return (Label(oTableNameTxt))
17154>>>>>    End_Function
17155>>>>>
17155>>>>>    Procedure Set License_Text String sText
17158>>>>>//        Set Label of oLicense_txt to sText
17158>>>>>    End_Procedure
17159>>>>>
17159>>>>>    // gets called when status panel is activated passing whether a button
17159>>>>>    // should appear
17159>>>>>    Procedure EnableCancelButton Boolean bEnable
17162>>>>>        Boolean bVisible
17162>>>>>        Get Cancel_Button_Visible_State to bVisible
17163>>>>>        If (bEnable = False) Begin
17165>>>>>            Set Visible_State of oStopButton to bVisible
17166>>>>>        End
17166>>>>>>
17166>>>>>        Set Enabled_State of oStopButton to bEnable
17167>>>>>    End_Procedure
17168>>>>>
17168>>>>>    Procedure Reset_StatusPanel
17171>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
17172>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
17173>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
17174>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
17175>>>>>    End_Procedure
17176>>>>>
17176>>>>>//    Object oProgressBar is a cProgressBar
17176>>>>>//        Move Self to ghoProgressBar
17176>>>>>//        Set Location to 1 25
17176>>>>>//        Set Size to 9 173
17176>>>>>//        Set piMinimum        to 0
17176>>>>>//        Set piMaximum        to 2000
17176>>>>>//        Set piAdvanceBy      to 100
17176>>>>>//        Set pbSmooth to True
17176>>>>>//
17176>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
17176>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
17176>>>>>//        // color will show correctly.
17176>>>>>//        Procedure Page Integer iPageObject
17176>>>>>//            Handle hWin
17176>>>>>//            Forward Send Page iPageObject
17176>>>>>//            If (ghoSkinFramework <> 0) Begin
17176>>>>>//                Get Window_Handle to hWin
17176>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
17176>>>>>//            End
17176>>>>>//        End_Procedure
17176>>>>>//    End_Object
17176>>>>>
17176>>>>>End_Object
17177>>>>>
17177>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateHandler.inc)
17177>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
17177>>>>>//
17177>>>>>Use VdfBase.pkg
17177>>>>>Use cApplication.pkg
17177>>>>>Use seq_chnl.pkg
17177>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\vwin32fh\vWin32fh.pkg)
17177>>>>>>>// This code is part of VDF GUIdance
17177>>>>>>>// Visit us @ http://www.vdf-guidance.com
17177>>>>>>>// e-Mail us @ info@vdf-guidance.com
17177>>>>>>>// VDF GUIdance is a mutual project of
17177>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
17177>>>>>>>// Wil van Antwerpen  - Antwise Solutions
17177>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
17177>>>>>>>//
17177>>>>>>>//
17177>>>>>>>// *** Windows 32bit file handling wrapper class ***
17177>>>>>>>//
17177>>>>>>>
17177>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
17177>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
17177>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
17177>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
17177>>>>>>>//
17177>>>>>>>// The used naming-convention is:
17177>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
17177>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
17177>>>>>>>//
17177>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
17177>>>>>>>// of DataAccess in the future.
17177>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
17177>>>>>>>//
17177>>>>>>>// mm-dd-yyyy Author Description
17177>>>>>>>//
17177>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
17177>>>>>>>//                   vGetWindowsDirectory
17177>>>>>>>//
17177>>>>>>>//                   vGetTempFileName
17177>>>>>>>//                   vGetTempPath
17177>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
17177>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
17177>>>>>>>//                   error in your application anyways. Changed this for:
17177>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
17177>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
17177>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
17177>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
17177>>>>>>>//                   It is renamed too avoid this.
17177>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
17177>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
17177>>>>>>>//                   Removed the local keyword in the variable declarations
17177>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
17177>>>>>>>//                   created file-open dialog
17177>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
17177>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
17177>>>>>>>//                   This has now been taken care of.
17177>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
17177>>>>>>>//                   These declarations are now included from the vWin32fh header file.
17177>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
17177>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
17177>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
17177>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
17177>>>>>>>//                   One can however restore to the old way of handling by simply calling the
17177>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
17177>>>>>>>//                   filehandling operations
17177>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
17177>>>>>>>//                   as well as the StringFromRightOfChar function.
17177>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
17177>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
17177>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
17177>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
17177>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
17177>>>>>>>//                   extended characters are treated ok too.
17177>>>>>>>//                   Reported by Flemming from
17177>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
17177>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
17177>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
17177>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
17177>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
17177>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
17177>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
17177>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
17177>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
17177>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
17177>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
17177>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
17177>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
17177>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
17177>>>>>>>
17177>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
Including file: File_dlg.pkg    (C:\Program Files\DataFlex 20.1\Pkg\File_dlg.pkg)
17177>>>>>>>>>Use Windows.pkg
17177>>>>>>>>>Use GlobalFunctionsProcedures.pkg
17177>>>>>>>>>
17177>>>>>>>>>
17177>>>>>>>>>// Unicode support, wide version of GetOpenFileName - Gets called directly from Show_Dialog.
17177>>>>>>>>>External_Function GetOpenFileNameW "GetOpenFileNameW" Comdlg32.DLL Pointer OpenStruct Returns Integer
17178>>>>>>>>>
17178>>>>>>>>>// Unicode support, wide version of GetSaveFileName
17178>>>>>>>>>External_Function GetSaveFileNameW "GetSaveFileNameW" Comdlg32.DLL Pointer OpenStruct Returns Integer
17179>>>>>>>>>
17179>>>>>>>>>Struct TOpenFileName
17179>>>>>>>>>    DWord    lStructSize          // length, in bytes, of the structure.
17179>>>>>>>>>    Integer  iMissingAlignment1
17179>>>>>>>>>    Handle   hwndOwner            // Handle to the window that owns the dialog box.
17179>>>>>>>>>    Handle   hInstance            // handle to a memory object containing a dialog box template.
17179>>>>>>>>>    Pointer  lpstrFilter          // pointer to a buffer containing pairs of null-terminated filter strings.
17179>>>>>>>>>    Pointer  lpstrCustomFilter    // Pointer to a static buffer that contains a pair of null-terminated filter strings for preserving the filter pattern chosen by the user.
17179>>>>>>>>>    DWord    nMaxCustFilter       // size, in chars, of the buffer identified by lpstrCustomFilter.
17179>>>>>>>>>    DWord    nFilterIndex         // index of the currently selected filter
17179>>>>>>>>>    Pointer  lpstrFile            // Pointer to a buffer that contains the file name(s)
17179>>>>>>>>>    DWord    nMaxFile             // Size, in CHARs, of the buffer pointed to by lpstrFile.
17179>>>>>>>>>    Integer  iMissingAlignment2
17179>>>>>>>>>    Pointer  lpstrFileTitle       // Pointer to a buffer that receives the file name and extension
17179>>>>>>>>>    DWord    nMaxFileTitle        // size, in CHARs, of the buffer pointed to by lpstrFileTitle
17179>>>>>>>>>    Integer  iMissingAlignment3
17179>>>>>>>>>    Pointer  lpstrInitialDir      // Pointer to a NULL terminated string that can specify the initial directory.
17179>>>>>>>>>    Pointer  lpstrTitle           // Pointer to a string to be placed in the title bar of the dialog box.
17179>>>>>>>>>    DWord    ofnFlags             // set of bit flags you can use to initialize the dialog box.
17179>>>>>>>>>    Short    nFileOffset          // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name in the string pointed to by lpstrFile.
17179>>>>>>>>>    Short    nFileExtension       // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name extension in the string pointed to by lpstrFile.
17179>>>>>>>>>    Pointer  lpstrDefExt          // Pointer to a buffer that contains the default extension.
17179>>>>>>>>>    Longptr  lCustData            // Specifies application-defined data that the system passes to the hook procedure identified by the lpfnHook member.
17179>>>>>>>>>    Pointer  lpfnHook             // Pointer to a hook procedure.
17179>>>>>>>>>    Pointer  lpTemplateName       // Pointer to a null-terminated string that names a dialog template resource in the module identified by the hInstance member.
17179>>>>>>>>>    Pointer  lpvReserved          // Reserved
17179>>>>>>>>>    DWord    dwReserved           // Reserved
17179>>>>>>>>>    DWord    FlagsEx              // A set of bit flags you can use to initialize the dialog box.
17179>>>>>>>>>End_Struct
17179>>>>>>>>>
17179>>>>>>>>>Define OFN_READONLY               for |CI$000001
17179>>>>>>>>>Define OFN_OVERWRITEPROMPT        for |CI$000002
17179>>>>>>>>>Define OFN_HIDEREADONLY           for |CI$000004
17179>>>>>>>>>Define OFN_NOCHANGEDIR            for |CI$000008
17179>>>>>>>>>Define OFN_NOVALIDATE             for |CI$000100
17179>>>>>>>>>Define OFN_ALLOWMULTISELECT       for |CI$000200
17179>>>>>>>>>Define OFN_EXTENSIONDIFFERENT     for |CI$000400
17179>>>>>>>>>Define OFN_PATHMUSTEXIST          for |CI$000800
17179>>>>>>>>>Define OFN_FILEMUSTEXIST          for |CI$001000
17179>>>>>>>>>Define OFN_CREATEPROMPT           for |CI$002000
17179>>>>>>>>>Define OFN_SHAREAWARE             for |CI$004000
17179>>>>>>>>>Define OFN_NOREADONLYRETURN       for |CI$008000
17179>>>>>>>>>Define OFN_NOTESTFILECREATE       for |CI$010000
17179>>>>>>>>>Define OFN_EXPLORER               for |CI$080000     // new look commdlg
17179>>>>>>>>>
17179>>>>>>>>>Class AbstractFileDialog is a cObject
17180>>>>>>>>>    
17180>>>>>>>>>    Procedure Construct_Object
17182>>>>>>>>>        Forward Send Construct_Object
17184>>>>>>>>>        
17184>>>>>>>>>        Property String  Filter_String
17185>>>>>>>>>        Property String  Initial_Folder
17186>>>>>>>>>        Property String  File_Name
17187>>>>>>>>>        Property String  File_Title
17188>>>>>>>>>        Property String  Dialog_Caption
17189>>>>>>>>>        Property Integer Filter_Index          1
17190>>>>>>>>>        Property Integer HideReadOnly_State    False
17191>>>>>>>>>        Property Integer TickReadOnly_State    False
17192>>>>>>>>>        Property Integer AllowReadOnly_State   True
17193>>>>>>>>>        Property Integer FileMustExist_State   True
17194>>>>>>>>>        Property Integer PathMustExist_State   True
17195>>>>>>>>>        Property Integer CreatePrompt_State    True
17196>>>>>>>>>        Property Integer ShowFileTitle_State   False
17197>>>>>>>>>        Property Integer OverwritePrompt_State False
17198>>>>>>>>>        Property Integer NoChangeDir_State     False
17199>>>>>>>>>        
17199>>>>>>>>>        Property Boolean Private_MultiSelect_State False
17200>>>>>>>>>        
17200>>>>>>>>>        Property String[] Private_Selected_Files
17201>>>>>>>>>        
17201>>>>>>>>>        Property Integer PrivateExternal_msg
17202>>>>>>>>>        
17202>>>>>>>>>        //Set Focus_Mode To No_Activate
17202>>>>>>>>>    End_Procedure
17203>>>>>>>>>    
17203>>>>>>>>>    Function OwnerHandle Returns Handle
17205>>>>>>>>>        Handle hWnd
17205>>>>>>>>>        Handle hoObj
17205>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
17206>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
17207>>>>>>>>>        Function_Return hWnd
17208>>>>>>>>>    End_Function
17209>>>>>>>>>    
17209>>>>>>>>>    
17209>>>>>>>>>    Function Show_Dialog Returns Integer // bool
17211>>>>>>>>>        Handle hWnd
17211>>>>>>>>>        Integer bOK iFilter iFlags bHideRO bTickRO bFileExist bPathExist iMsg
17211>>>>>>>>>        Integer icInitDir bCreatePrompt bOverwritePrompt bAllowReadOnly
17211>>>>>>>>>        Integer iPos iCount
17211>>>>>>>>>        Integer bNoChangeDir
17211>>>>>>>>>        Pointer lpsFileTitle lpsFileName lpsFilter lpsInitDir
17211>>>>>>>>>        Pointer lpsTitle lpsDefExt
17211>>>>>>>>>        WString sFileName sFileTitle sFilter sInitDir sTitle sDefExt
17211>>>>>>>>>        Pointer lpOpenFileData
17211>>>>>>>>>        Boolean bMultiSelect
17211>>>>>>>>>        String[] sFiles
17212>>>>>>>>>        TOpenFileName OpenFileData
17212>>>>>>>>>        TOpenFileName OpenFileData
17212>>>>>>>>>        
17212>>>>>>>>>        //Delegate Get Container_Handle To hWnd
17212>>>>>>>>>        Get OwnerHandle to hWnd
17213>>>>>>>>>        
17213>>>>>>>>>        If (ShowFileTitle_State(Self)) Begin
17215>>>>>>>>>            Get File_Title to sFileName
17216>>>>>>>>>        End
17216>>>>>>>>>>
17216>>>>>>>>>        
17216>>>>>>>>>        Get private_MultiSelect_State to bMultiSelect
17217>>>>>>>>>        
17217>>>>>>>>>        Get Initial_Folder        to sInitDir
17218>>>>>>>>>        Get Dialog_Caption        to sTitle
17219>>>>>>>>>        Get Filter_String         to sFilter
17220>>>>>>>>>        Get HideReadOnly_State    to bHideRO
17221>>>>>>>>>        Get TickReadOnly_State    to bTickRO
17222>>>>>>>>>        Get FileMustExist_State   to bFileExist
17223>>>>>>>>>        Get PathMustExist_State   to bPathExist
17224>>>>>>>>>        Get CreatePrompt_State    to bCreatePrompt
17225>>>>>>>>>        Get OverwritePrompt_State to bOverwritePrompt
17226>>>>>>>>>        Get AllowReadOnly_State   to bAllowReadOnly
17227>>>>>>>>>        Get NoChangeDir_State     to bNoChangeDir
17228>>>>>>>>>        Get Filter_Index          to iFilter
17229>>>>>>>>>        
17229>>>>>>>>>        Move (sFilter + Character(0) + Character(0)) to sFilter
17230>>>>>>>>>        Move (Replaces('|', sFilter, Character(0))) to sFilter
17231>>>>>>>>>        
17231>>>>>>>>>        Append sInitDir   (character(0))
17232>>>>>>>>>        Append sFileTitle (Repeat(character(0),32000))
17233>>>>>>>>>        Append sFileName  (Repeat(character(0),32000))
17234>>>>>>>>>        Append sTitle     (Repeat(character(0),255))
17235>>>>>>>>>        Append sDefExt    (character(0))
17236>>>>>>>>>        
17236>>>>>>>>>        Move (AddressOf(sInitDir))   to lpsInitDir
17237>>>>>>>>>        Move (AddressOf(sFileName))  to lpsFileName
17238>>>>>>>>>        Move (AddressOf(sFileTitle)) to lpsFileTitle
17239>>>>>>>>>        Move (AddressOf(sTitle))     to lpsTitle
17240>>>>>>>>>        Move (AddressOf(sDefExt))    to lpsDefExt
17241>>>>>>>>>        Move (AddressOf(sFilter))    to lpsFilter
17242>>>>>>>>>        
17242>>>>>>>>>        
17242>>>>>>>>>        If (bMultiSelect) Begin
17244>>>>>>>>>            Move (OFN_EXPLORER + OFN_ALLOWMULTISELECT) to iFlags  // Multi-select!
17245>>>>>>>>>        End
17245>>>>>>>>>>
17245>>>>>>>>>        
17245>>>>>>>>>        If bFileExist ;            Move (iFlags + OFN_FILEMUSTEXIST)    to iFlags
17248>>>>>>>>>        If bPathExist ;            Move (iFlags + OFN_PATHMUSTEXIST)    to iFlags
17251>>>>>>>>>        If bHideRO ;            Move (iFlags + OFN_HIDEREADONLY)     to iFlags
17254>>>>>>>>>        If bTickRO ;            Move (iFlags + OFN_READONLY)         to iFlags
17257>>>>>>>>>        If bCreatePrompt ;            Move (iFlags + OFN_CREATEPROMPT)     to iFlags
17260>>>>>>>>>        If bOverwritePrompt ;            Move (iFlags + OFN_OVERWRITEPROMPT)  to iFlags
17263>>>>>>>>>        If not bAllowReadOnly ;            Move (iFlags + OFN_NOREADONLYRETURN) to iFlags
17266>>>>>>>>>        If bNoChangeDir ;            Move (iFlags + OFN_NOCHANGEDIR)      to iFlags
17269>>>>>>>>>        
17269>>>>>>>>>        Move (SizeOfType(TOpenFileName)) to OpenFileData.lStructSize
17270>>>>>>>>>        Move hWnd         to OpenFileData.hWndOwner
17271>>>>>>>>>        Move iFilter      to OpenFileData.nFilterIndex
17272>>>>>>>>>        Move lpsFileName  to OpenFileData.lpstrFile
17273>>>>>>>>>        
17273>>>>>>>>>        If (sInitDir <> '') Begin
17275>>>>>>>>>            Move lpsInitDir    to OpenFileData.lpstrInitialDir
17276>>>>>>>>>        End
17276>>>>>>>>>>
17276>>>>>>>>>        
17276>>>>>>>>>        If (sTitle <> '') Begin
17278>>>>>>>>>            Move lpsTitle      to OpenFileData.lpstrTitle
17279>>>>>>>>>        End
17279>>>>>>>>>>
17279>>>>>>>>>        
17279>>>>>>>>>        Move 32000             to OpenFileData.nMaxFileTitle
17280>>>>>>>>>        Move 32000             to OpenFileData.nMaxFile
17281>>>>>>>>>        Move lpsFileTitle      to OpenFileData.lpstrFileTitle
17282>>>>>>>>>        Move iFlags            to OpenFileData.ofnFlags
17283>>>>>>>>>        Move lpsFilter         to OpenFileData.lpstrFilter
17284>>>>>>>>>        Move lpsDefExt         to OpenFileData.lpstrDefExt
17285>>>>>>>>>        
17285>>>>>>>>>        Move (AddressOf(OpenFileData)) to lpOpenFileData
17286>>>>>>>>>        
17286>>>>>>>>>        Get PrivateExternal_msg to iMsg
17287>>>>>>>>>        If (iMsg = Get_GetOpenFileNameW) ;            Move (GetOpenFileNameW (lpOpenFileData)) to bOK
17290>>>>>>>>>        If (iMsg = Get_GetSaveFileNameW) ;            Move (GetSaveFileNameW (lpOpenFileData)) to bOK
17293>>>>>>>>>        
17293>>>>>>>>>        If bOK Begin
17295>>>>>>>>>            Move OpenFileData.ofnFlags     to iFlags
17296>>>>>>>>>            Move OpenFileData.nFilterIndex to iFilter
17297>>>>>>>>>            Move OpenFileData.nFileOffset  to icInitDir
17298>>>>>>>>>            
17298>>>>>>>>>            Move (CString(Left(sFileName, icInitDir))) to sInitDir    // Trim trailing null
17299>>>>>>>>>            Set Initial_Folder     to sInitDir
17300>>>>>>>>>            
17300>>>>>>>>>            Set TickReadOnly_State to (iFlags iand OFN_READONLY)
17301>>>>>>>>>            Set Filter_Index       to iFilter
17302>>>>>>>>>
17302>>>>>>>>>            Set File_Name          to (CString( sFileName ))
17303>>>>>>>>>            Set File_Title         to (CString( sFileTitle ))
17304>>>>>>>>>            
17304>>>>>>>>>            If (bMultiSelect) Begin
17306>>>>>>>>>                // If this is a multi-files dialog then parse out the array of selected files....
17306>>>>>>>>>                If (Right(sInitDir, 1) = "\") ;                    Move (Left(sInitDir, Length(sInitDir)-1)) to sInitDir     // Trim trailing :\". This is only there if 1 file was selected!
17309>>>>>>>>>                
17309>>>>>>>>>                // Get the null delimited string of file names into the sFiles array....
17309>>>>>>>>>                Move 0 to iCount
17310>>>>>>>>>                Move (Right(sFileName, Length(sFileName) - icInitDir)) to sFileName    // Strip the path info (we already have it)
17311>>>>>>>>>                
17311>>>>>>>>>                Repeat
17311>>>>>>>>>>
17311>>>>>>>>>                    // Get the next filename....
17311>>>>>>>>>                    Move (Pos(Character(0), sFileName)) to iPos   // Filenames are null delimeted
17312>>>>>>>>>                    
17312>>>>>>>>>                    If (iPos > 1) Begin
17314>>>>>>>>>                        Move (sInitDir + "\" + CString(Left(sFileName, iPos))) to sFiles[iCount]
17315>>>>>>>>>                        Move (Right(sFileName, Length(sFileName) - iPos)) to sFileName
17316>>>>>>>>>                        Increment iCount
17317>>>>>>>>>                    End
17317>>>>>>>>>>
17317>>>>>>>>>                Until (iPos <= 1)
17319>>>>>>>>>            End
17319>>>>>>>>>>
17319>>>>>>>>>            Else Begin
17320>>>>>>>>>                Move (CString(sFileName)) to sFiles[0]
17321>>>>>>>>>            End
17321>>>>>>>>>>
17321>>>>>>>>>            
17321>>>>>>>>>            Set private_Selected_Files to sFiles
17322>>>>>>>>>        End
17322>>>>>>>>>>
17322>>>>>>>>>        Function_Return (bOK)
17323>>>>>>>>>    End_Function
17324>>>>>>>>>End_Class
17325>>>>>>>>>
17325>>>>>>>>>Class OpenDialog is an AbstractFileDialog
17326>>>>>>>>>    Procedure Construct_Object
17328>>>>>>>>>        Forward Send Construct_Object
17330>>>>>>>>>        Set PrivateExternal_msg to get_GetOpenFileNameW
17331>>>>>>>>>    End_Procedure
17332>>>>>>>>>    
17332>>>>>>>>>    Procedure Set MultiSelect_State Boolean bState
17334>>>>>>>>>        Set private_MultiSelect_State to bState
17335>>>>>>>>>    End_Procedure
17336>>>>>>>>>    
17336>>>>>>>>>    Function MultiSelect_State Returns Boolean
17338>>>>>>>>>        Boolean bState
17338>>>>>>>>>        Get private_MultiSelect_State to bState
17339>>>>>>>>>        Function_Return bState
17340>>>>>>>>>    End_Function
17341>>>>>>>>>    
17341>>>>>>>>>    Function Selected_Files Returns String[]
17343>>>>>>>>>        String[] sFiles
17344>>>>>>>>>        Get private_Selected_Files to sFiles
17345>>>>>>>>>        Function_Return sFiles
17346>>>>>>>>>    End_Function
17347>>>>>>>>>End_Class
17348>>>>>>>>>
17348>>>>>>>>>Class SaveAsDialog is an AbstractFileDialog
17349>>>>>>>>>    Procedure Construct_Object
17351>>>>>>>>>        Forward Send Construct_Object
17353>>>>>>>>>        Set FileMustExist_State   to False
17354>>>>>>>>>        Set CreatePrompt_State    to False
17355>>>>>>>>>        Set ShowFileTitle_State   to True
17356>>>>>>>>>        Set OverwritePrompt_State to True
17357>>>>>>>>>        Set HideReadOnly_State    to True
17358>>>>>>>>>        Set PrivateExternal_msg to get_GetSaveFileNameW
17359>>>>>>>>>    End_Procedure
17360>>>>>>>>>End_Class
17361>>>>>>>>>
17361>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\vwin32fh\cvFileDialogs.pkg)
17361>>>>>>>>>//***************************************************************************
17361>>>>>>>>>//*
17361>>>>>>>>>//* Class:        cvSaveAsDialog
17361>>>>>>>>>//* Package Name: cvFileDialogs.pkg
17361>>>>>>>>>//*
17361>>>>>>>>>//***************************************************************************
17361>>>>>>>>>
17361>>>>>>>>>Use File_dlg.pkg
17361>>>>>>>>>
17361>>>>>>>>>// *WvA: 13-01-1999 Created
17361>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
17361>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
17361>>>>>>>>>// file_name.
17361>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
17362>>>>>>>>>
17362>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
17364>>>>>>>>>        Forward Send Construct_Object iImage_Id
17366>>>>>>>>>        Set HideReadOnly_State to True
17367>>>>>>>>>    End_Procedure
17368>>>>>>>>>
17368>>>>>>>>>    Function SelectedFileName Returns String
17370>>>>>>>>>        String sFileName
17370>>>>>>>>>        Move "" to sFileName
17371>>>>>>>>>        If (Show_Dialog(Self)) Begin
17373>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
17374>>>>>>>>>        End
17374>>>>>>>>>>
17374>>>>>>>>>        Function_Return sFileName
17375>>>>>>>>>    End_Function
17376>>>>>>>>>End_Class
17377>>>>>>>>>
17377>>>>>>>>>// *WvA: 13-01-1999 Created
17377>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
17377>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
17377>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
17377>>>>>>>>>//                   file-open dialog
17377>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
17379>>>>>>>>>    String sSelectedFile
17379>>>>>>>>>    Integer hoOpenFileDialog
17379>>>>>>>>>
17379>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
17381>>>>>>>>>
17381>>>>>>>>>        Set Dialog_Caption    to sCaptionText
17382>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
17383>>>>>>>>>        Set Initial_Folder    to sInitialFolder
17384>>>>>>>>>
17384>>>>>>>>>        Move Self       to hoOpenFileDialog
17385>>>>>>>>>    End_Object
17386>>>>>>>>>
17386>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
17387>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
17388>>>>>>>>>    Function_Return sSelectedFile
17389>>>>>>>>>End_Function
17390>>>>>>>>>
17390>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
17391>>>>>>>>>
17391>>>>>>>>>    Procedure Construct_Object
17393>>>>>>>>>        Forward Send Construct_Object
17395>>>>>>>>>        Set HideReadOnly_State to True
17396>>>>>>>>>    End_Procedure
17397>>>>>>>>>
17397>>>>>>>>>    Function SelectedFileName Returns String
17399>>>>>>>>>        String sFileName
17399>>>>>>>>>        Move "" to sFileName
17400>>>>>>>>>        If (Show_Dialog(Self)) Begin
17402>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
17403>>>>>>>>>        End
17403>>>>>>>>>>
17403>>>>>>>>>        Function_Return sFileName
17404>>>>>>>>>    End_Function
17405>>>>>>>>>
17405>>>>>>>>>End_Class
17406>>>>>>>>>
17406>>>>>>>>>// Added optional default filename as suggested by Nils
17406>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
17408>>>>>>>>>    String sSelectedFile
17408>>>>>>>>>    Integer hoDialog
17408>>>>>>>>>
17408>>>>>>>>>    Move "" to sSelectedFile
17409>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
17410>>>>>>>>>    If (hoDialog) Begin
17412>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
17412>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
17413>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
17414>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
17415>>>>>>>>>        If (Num_Arguments = 4) Begin
17417>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
17418>>>>>>>>>        End
17418>>>>>>>>>>
17418>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
17419>>>>>>>>>        Send Destroy of hoDialog
17420>>>>>>>>>    End
17420>>>>>>>>>>
17420>>>>>>>>>    Function_Return sSelectedFile
17421>>>>>>>>>End_Function
17422>>>>>>>Use Seq_chnl.pkg
17422>>>>>>>
17422>>>>>>>Use windows.pkg
17422>>>>>>>Use Dll.pkg
17422>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\vwin32fh\vwin32fh.h)
17422>>>>>>>>>//TH-Header
17422>>>>>>>>>//*****************************************************************************************
17422>>>>>>>>>// Copyright (c)  2004 KURANT Project
17422>>>>>>>>>// All rights reserved.
17422>>>>>>>>>//
17422>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
17422>>>>>>>>>// $ProjectName : Windows 32 bits file handling
17422>>>>>>>>>// $Authors     : Wil van Antwerpen
17422>>>>>>>>>// $Created     : 19.02.2004  19:25
17422>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
17422>>>>>>>>>//
17422>>>>>>>>>// Contents:
17422>>>>>>>>>//  This file contains the Windows API external function call definitions and
17422>>>>>>>>>//  constants as they are used in the vWin32fh package.
17422>>>>>>>>>//*****************************************************************************************
17422>>>>>>>>>//TH-RevisionStart
17422>>>>>>>>>//TH-RevisionEnd
17422>>>>>>>>>
17422>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
17422>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
17422>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
17422>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
17422>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
17422>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
17422>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
17422>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
17422>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
17422>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
17422>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
17422>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
17422>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
17422>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
17422>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
17422>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
17422>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
17422>>>>>>>>>
17422>>>>>>>>>
17422>>>>>>>>>Define vMax_Path     For |CI260
17422>>>>>>>>>Define vMinChar      For |CI$80
17422>>>>>>>>>Define vMaxChar      For |CI$7F
17422>>>>>>>>>Define vMinShort     For |CI$8000
17422>>>>>>>>>Define vMaxShort     For |CI$7FFF
17422>>>>>>>>>Define vMinLong      For |CI$80000000
17422>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
17422>>>>>>>>>Define vMaxByte      For |CI$FF
17422>>>>>>>>>Define vMaxWord      For |CI$FFFF
17422>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
17422>>>>>>>>>
17422>>>>>>>>>
17422>>>>>>>>>
17422>>>>>>>>>// For FindFirstFile
17422>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
17422>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
17422>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
17422>>>>>>>>>
17422>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
17422>>>>>>>>>// the API-call ShellExecute is used.
17422>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
17422>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
17422>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
17422>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
17422>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
17422>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
17422>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
17422>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
17422>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
17422>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
17422>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
17422>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
17422>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
17422>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
17422>>>>>>>>>
17422>>>>>>>>>
17422>>>>>>>>>// C-Structure
17422>>>>>>>>>//typedef struct _browseinfo {
17422>>>>>>>>>//    HWND hwndOwner;
17422>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
17422>>>>>>>>>//    LPSTR pszDisplayName;
17422>>>>>>>>>//    LPCSTR lpszTitle;
17422>>>>>>>>>//    UINT ulFlags;
17422>>>>>>>>>//    BFFCALLBACK lpfn;
17422>>>>>>>>>//    LPARAM lParam;
17422>>>>>>>>>//    int iImage;
17422>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
17422>>>>>>>>>
17422>>>>>>>>>//declare C structure struct_browseinfo
17422>>>>>>>>>//as documented in MSDN under Windows Shell API
17422>>>>>>>>>Struct tvBrowseInfo
17422>>>>>>>>>  Handle    hWndOwner
17422>>>>>>>>>  Pointer   pIDLRoot
17422>>>>>>>>>  Pointer   pszDisplayName
17422>>>>>>>>>  Pointer   lpszTitle
17422>>>>>>>>>  dWord     ulFlags
17422>>>>>>>>>  Pointer   lpfnCallback
17422>>>>>>>>>  dWord     lParam
17422>>>>>>>>>  DWord     iImage
17422>>>>>>>>>End_Struct // tvBrowseInfo
17422>>>>>>>>>
17422>>>>>>>>>// Browsing for directory.
17422>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
17422>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
17422>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
17422>>>>>>>>>                                            // The callback function can set the status text by
17422>>>>>>>>>                                            // sending messages to the dialog box.
17422>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
17422>>>>>>>>>
17422>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
17422>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
17422>>>>>>>>>
17422>>>>>>>>>// message from browser
17422>>>>>>>>>//Define BFFM_INITIALIZED        1
17422>>>>>>>>>//Define BFFM_SELCHANGED         2
17422>>>>>>>>>
17422>>>>>>>>>// messages to browser
17422>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
17422>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
17422>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
17422>>>>>>>>>
17422>>>>>>>>>
17422>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
17423>>>>>>>>>
17423>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
17424>>>>>>>>>
17424>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
17425>>>>>>>>>
17425>>>>>>>>>
17425>>>>>>>>>
17425>>>>>>>>>
17425>>>>>>>>>Struct tvSecurity_attributes
17425>>>>>>>>>  DWord   nLength
17425>>>>>>>>>  Pointer lpDescriptor
17425>>>>>>>>>  Integer bInheritHandle
17425>>>>>>>>>End_Struct // tvSecurity_attributes
17425>>>>>>>>>
17425>>>>>>>>>//nLength:
17425>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
17425>>>>>>>>>// SECURITY_ATTRIBUTES structure.
17425>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
17425>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
17425>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
17425>>>>>>>>>//
17425>>>>>>>>>//lpSecurityDescriptor:
17425>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
17425>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
17425>>>>>>>>>// descriptor of the calling process.
17425>>>>>>>>>//
17425>>>>>>>>>//bInheritHandle:
17425>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
17425>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
17425>>>>>>>>>
17425>>>>>>>>>
17425>>>>>>>>>// BOOL CreateDirectory(
17425>>>>>>>>>//    LPCTSTR lpPathName,
17425>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
17425>>>>>>>>>//   );
17425>>>>>>>>>//
17425>>>>>>>>>// lpPathName
17425>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
17425>>>>>>>>>//  to be created.
17425>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
17425>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
17425>>>>>>>>>// lpSecurityAttributes
17425>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
17425>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
17425>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
17425>>>>>>>>>// Returns:
17425>>>>>>>>>//  If the function succeeds, the return value is nonzero.
17425>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
17425>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
17426>>>>>>>>>
17426>>>>>>>>>
17426>>>>>>>>>// lpPathName
17426>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
17426>>>>>>>>>//  to be removed.
17426>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
17426>>>>>>>>>// Returns:
17426>>>>>>>>>//  If the function succeeds, the return value is nonzero.
17426>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
17426>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
17427>>>>>>>>>
17427>>>>>>>>>
17427>>>>>>>>>
17427>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
17427>>>>>>>>>// executable file or a document file.
17427>>>>>>>>>//
17427>>>>>>>>>// Operation can be one of the following:
17427>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
17427>>>>>>>>>//            The file can be an executable file or a document file.
17427>>>>>>>>>//            The file can be a folder to open.
17427>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
17427>>>>>>>>>//            The file should be a document file. If the file is an executable file,
17427>>>>>>>>>//            the function opens the file, as if "open" had been specified.
17427>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
17427>>>>>>>>>//
17427>>>>>>>>>// Return Values:
17427>>>>>>>>>//
17427>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
17427>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
17427>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
17427>>>>>>>>>//
17427>>>>>>>>>// The following table lists these error values:
17427>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
17427>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
17427>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
17427>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
17427>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
17427>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
17427>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
17427>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
17427>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
17427>>>>>>>>>// Public Const SE_ERR_FNF = 2
17427>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
17427>>>>>>>>>// Public Const SE_ERR_OOM = 8
17427>>>>>>>>>// Public Const SE_ERR_PNF = 3
17427>>>>>>>>>// Public Const SE_ERR_SHARE = 26
17427>>>>>>>>>
17427>>>>>>>>>
17427>>>>>>>>>
17427>>>>>>>>>// Code to open the program that is associated with the selected file.
17427>>>>>>>>>//
17427>>>>>>>>>// External function call used in Procedure DoStartDocument
17427>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
17428>>>>>>>>>
17428>>>>>>>>>
17428>>>>>>>>>
17428>>>>>>>>>
17428>>>>>>>>>Define vFO_MOVE                For |CI$0001
17428>>>>>>>>>Define vFO_COPY                For |CI$0002
17428>>>>>>>>>Define vFO_DELETE              For |CI$0003
17428>>>>>>>>>Define vFO_RENAME              For |CI$0004
17428>>>>>>>>>
17428>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
17428>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
17428>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
17428>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
17428>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
17428>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
17428>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
17428>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
17428>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
17428>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
17428>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
17428>>>>>>>>>
17428>>>>>>>>>Struct tvShFileOpStruct
17428>>>>>>>>>  Handle  hWnd
17428>>>>>>>>>  Integer wFunc
17428>>>>>>>>>  Pointer pFrom
17428>>>>>>>>>  Pointer pTo
17428>>>>>>>>>  Short   fFlags
17428>>>>>>>>>  Short   fAnyOperationsAborted
17428>>>>>>>>>  Pointer hNameMappings
17428>>>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
17428>>>>>>>>>End_Struct // tvShFileOpStruct
17428>>>>>>>>>
17428>>>>>>>>>// hwnd
17428>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
17428>>>>>>>>>
17428>>>>>>>>>// wFunc
17428>>>>>>>>>//   Operation to perform. This member can be one of the following values:
17428>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
17428>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
17428>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
17428>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
17428>>>>>>>>>
17428>>>>>>>>>// pFrom
17428>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
17428>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
17428>>>>>>>>>
17428>>>>>>>>>// pTo
17428>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
17428>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
17428>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
17428>>>>>>>>>//   double null-terminated.
17428>>>>>>>>>
17428>>>>>>>>>// fAnyOperationsAborted
17428>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
17428>>>>>>>>>//   were completed or FALSE otherwise.
17428>>>>>>>>>
17428>>>>>>>>>
17428>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
17428>>>>>>>>>// This can be a file or a folder.
17428>>>>>>>>>// With thanks to Andrew S Kaplan
17428>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
17429>>>>>>>>>
17429>>>>>>>>>
17429>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
17429>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
17430>>>>>>>>>
17430>>>>>>>>>
17430>>>>>>>>>
17430>>>>>>>>>// Courtesy Of Vincent Oorsprong
17430>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
17430>>>>>>>>>//   Pointer lpPathName ;
17430>>>>>>>>>//   Pointer lpPrefixString ;
17430>>>>>>>>>//   Integer uUnique ;
17430>>>>>>>>>//   Pointer lpTempFileName ;
17430>>>>>>>>>//   Returns Integer
17430>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
17430>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
17431>>>>>>>>>
17431>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
17432>>>>>>>>>
17432>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
17433>>>>>>>>>
17433>>>>>>>>>// from:
17433>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
17433>>>>>>>>>//
17433>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
17433>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
17433>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
17433>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
17433>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
17433>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
17433>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
17433>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
17433>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
17433>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
17433>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
17433>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
17433>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
17433>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
17433>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
17433>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
17433>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
17433>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
17433>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
17433>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
17433>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
17433>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
17433>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
17433>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
17433>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
17433>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
17433>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
17433>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
17433>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
17433>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
17433>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
17433>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
17433>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
17433>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
17433>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
17433>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
17433>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
17433>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
17433>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
17433>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
17433>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
17433>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
17433>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
17433>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
17433>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
17433>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
17433>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
17433>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
17433>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
17433>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
17433>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
17433>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
17433>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
17433>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
17433>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
17433>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
17433>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
17433>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
17433>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
17433>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
17433>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
17433>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
17433>>>>>>>>>
17433>>>>>>>>>
17433>>>>>>>>>//HRESULT SHGetFolderPath(
17433>>>>>>>>>//    HWND hwndOwner,
17433>>>>>>>>>//    int nFolder,
17433>>>>>>>>>//    HANDLE hToken,
17433>>>>>>>>>//    DWORD dwFlags,
17433>>>>>>>>>//    LPTSTR pszPath
17433>>>>>>>>>//);
17433>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
17433>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
17433>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
17433>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
17433>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
17433>>>>>>>>>//
17433>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
17434>>>>>>>>>
17434>>>>>>>>>
17434>>>>>>>>>
17434>>>>>>>>>Struct tvWin32FindData
17434>>>>>>>>> Dword            dwFileAttributes
17434>>>>>>>>> Dword            ftCreationLowDateTime
17434>>>>>>>>> Dword            ftCreationHighDateTime
17434>>>>>>>>> dword            ftLastAccessLowDateTime
17434>>>>>>>>> Dword            ftLastAccessHighDateTime
17434>>>>>>>>> Dword            ftLastWriteLowDateTime
17434>>>>>>>>> Dword            ftLastWriteHighDateTime
17434>>>>>>>>> Dword            nFileSizeHigh
17434>>>>>>>>> Dword            nFileSizeLow
17434>>>>>>>>> Dword            dwReserved0
17434>>>>>>>>> Dword            dwReserved1
17434>>>>>>>>> UChar[vMax_Path] cFileName
17434>>>>>>>>> UChar[14]        cAlternateFileName
17434>>>>>>>>>End_Struct
17434>>>>>>>>>
17434>>>>>>>>>// Courtesy Of Vincent Oorsprong
17434>>>>>>>>>// lpFileName      : address of name of file to search for
17434>>>>>>>>>// lpFindFileData  : address of returned information
17434>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
17435>>>>>>>>>
17435>>>>>>>>>// Courtesy Of Vincent Oorsprong
17435>>>>>>>>>// hFindFile       : handle of search
17435>>>>>>>>>// lpFindFileData  : address of structure for data on found file
17435>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
17436>>>>>>>>>
17436>>>>>>>>>//
17436>>>>>>>>>// Unicode equivalents
17436>>>>>>>>>//
17436>>>>>>>>>// lpFileName      : address of name of file to search for
17436>>>>>>>>>// lpFindFileData  : address of returned information
17436>>>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
17437>>>>>>>>>
17437>>>>>>>>>// hFindFile       : handle of search
17437>>>>>>>>>// lpFindFileData  : address of structure for data on found file
17437>>>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
17438>>>>>>>>>
17438>>>>>>>>>
17438>>>>>>>>>// Courtesy Of Vincent Oorsprong
17438>>>>>>>>>//  hFindFile      : file search handle
17438>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
17439>>>>>>>>>
17439>>>>>>>>>
17439>>>>>>>>>
17439>>>>>>>>>Struct tvFileTime
17439>>>>>>>>>  DWord dwLowDateTime
17439>>>>>>>>>  DWord dwHighDateTime
17439>>>>>>>>>End_Struct
17439>>>>>>>>>
17439>>>>>>>>>
17439>>>>>>>>>Struct tvSystemTime
17439>>>>>>>>>  UShort wYear
17439>>>>>>>>>  UShort wMonth
17439>>>>>>>>>  UShort wDayOfWeek
17439>>>>>>>>>  UShort wDay
17439>>>>>>>>>  UShort wHour
17439>>>>>>>>>  UShort wMinute
17439>>>>>>>>>  UShort wSecond
17439>>>>>>>>>  UShort wMilliSeconds
17439>>>>>>>>>End_Struct
17439>>>>>>>>>
17439>>>>>>>>>
17439>>>>>>>>>// Courtesy Of Vincent Oorsprong
17439>>>>>>>>>//  lpFileTime     : pointer to file time to convert
17439>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
17439>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
17440>>>>>>>>>
17440>>>>>>>>>// Courtesy Of Vincent Oorsprong
17440>>>>>>>>>// This function formats the time in a picture-string passed
17440>>>>>>>>>//
17440>>>>>>>>>// Picture      Meaning
17440>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
17440>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
17440>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
17440>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
17440>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
17440>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
17440>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
17440>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
17440>>>>>>>>>//    t         One character time marker string, such as A or P
17440>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
17440>>>>>>>>>//
17440>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
17440>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
17440>>>>>>>>>
17440>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
17441>>>>>>>>>
17441>>>>>>>>>
17441>>>>>>>>>// Courtesy Of Vincent Oorsprong
17441>>>>>>>>>// This function formats the date in a picture-string passed
17441>>>>>>>>>//
17441>>>>>>>>>// Picture      Meaning
17441>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
17441>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
17441>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
17441>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
17441>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
17441>>>>>>>>>//              value associated with the specified locale.
17441>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
17441>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
17441>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
17441>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
17441>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
17441>>>>>>>>>//              associated with the specified locale.
17441>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
17441>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
17441>>>>>>>>>//    yyyy      Year represented hy full four digits.
17441>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
17441>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
17441>>>>>>>>>//              does not have an associated era or period string.
17441>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
17441>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
17441>>>>>>>>>
17441>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
17442>>>>>>>>>
17442>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
17442>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
17442>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
17442>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
17442>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
17442>>>>>>>>>
17442>>>>>>>>>//  Date Flags for GetDateFormatW.
17442>>>>>>>>>//
17442>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
17442>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
17442>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
17442>>>>>>>>>
17442>>>>>>>>>
17442>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
17443>>>>>>>>>
17443>>>>>>>>>
17443>>>>>>>>>// **WvA: 20-02-2004
17443>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
17443>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
17443>>>>>>>>>// incorrectly into an unsigned integer.
17443>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
17443>>>>>>>>>// It does smell a bit fishy though
17443>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
17443>>>>>>>>>
17443>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
17443>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
17443>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
17443>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
17443>>>>>>>>>
17443>>>>>>>>>// Possible errors that can be returned by the shellformat function
17443>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
17443>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
17443>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
17443>>>>>>>>>
17443>>>>>>>>>
17443>>>>>>>>> // Courtesy Of Steve Walter,
17443>>>>>>>>> // USA Software, Inc
17443>>>>>>>>> // Format a disk
17443>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
17443>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
17444>>>>>>>>>
17444>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
17444>>>>>>>>>
17444>>>>>>>>>// SHCreateDirectoryEx
17444>>>>>>>>>
17444>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
17444>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
17444>>>>>>>>>//
17444>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
17444>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
17444>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
17444>>>>>>>>>//
17444>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
17444>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
17444>>>>>>>>>//        ERROR_CANCELLED.
17444>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
17444>>>>>>>>>
17444>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
17444>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
17444>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
17444>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
17444>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
17444>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
17444>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
17444>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
17444>>>>>>>>>
17444>>>>>>>>>//        int SHCreateDirectoryEx(
17444>>>>>>>>>//            HWND hwnd,
17444>>>>>>>>>//            LPCTSTR pszPath,
17444>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
17444>>>>>>>>>//        );
17444>>>>>>>>>
17444>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
17445>>>>>>>>>
17445>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
17446>>>>>>>
17446>>>>>>>
17446>>>>>>>//
17446>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
17446>>>>>>>// If sStopChar has no occurences in the string an empty string is
17446>>>>>>>// returned.
17446>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
17448>>>>>>>    String  sRetVal
17448>>>>>>>    String  sChar
17448>>>>>>>    Integer iLength
17448>>>>>>>    Integer iPos
17448>>>>>>>    Boolean bStopChar
17448>>>>>>>    Move "" to sRetval
17449>>>>>>>    Move (Length(sFrom)) to iLength
17450>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
17452>>>>>>>        Move iLength   to iPos
17453>>>>>>>        Move (False)   to bStopChar
17454>>>>>>>        While Not bStopChar
17458>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
17459>>>>>>>            Decrement iPos
17460>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
17462>>>>>>>                Move (True) to bStopChar
17463>>>>>>>            End
17463>>>>>>>>
17463>>>>>>>            Else Begin
17464>>>>>>>                Move (sChar+sRetVal) to sRetVal
17465>>>>>>>            End
17465>>>>>>>>
17465>>>>>>>        Loop
17466>>>>>>>>
17466>>>>>>>    End
17466>>>>>>>>
17466>>>>>>>    Function_Return sRetVal
17467>>>>>>>End_Function
17468>>>>>>>
17468>>>>>>>// Pre:  sFileName contains the complete path of the file.
17468>>>>>>>// Post: returns the complete path of the file.
17468>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
17468>>>>>>>Function ParseFolderName Global String sFileName Returns String
17470>>>>>>>    String sFile
17470>>>>>>>    String sFolderName
17470>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
17470>>>>>>>
17470>>>>>>>    Move "" to sFolderName
17471>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
17472>>>>>>>    If sDirSep In sFileName Begin
17474>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
17475>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
17476>>>>>>>    End
17476>>>>>>>>
17476>>>>>>>    Else If ":" In sFileName Begin
17479>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
17480>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
17481>>>>>>>    End
17481>>>>>>>>
17481>>>>>>>    Function_Return sFolderName
17482>>>>>>>End_Function
17483>>>>>>>
17483>>>>>>>// Pre:  sFileName contains the complete path of the file.
17483>>>>>>>// post: The returned filename has it's path removed, but will have a extension
17483>>>>>>>Function ParseFileName Global String sFileName Returns String
17485>>>>>>>    String sFolderName
17485>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
17485>>>>>>>
17485>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
17486>>>>>>>    Get ParseFolderName sFileName to sFolderName
17487>>>>>>>    If (sFolderName <> "") Begin
17489>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
17490>>>>>>>    End
17490>>>>>>>>
17490>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
17491>>>>>>>    Function_Return sFilename
17492>>>>>>>End_Function
17493>>>>>>>
17493>>>>>>>// Pre:  sFileName may contain the complete path of the file.
17493>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
17493>>>>>>>//       return "bak" as the extension and not "gif"
17493>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
17493>>>>>>>//       such as "html" or "java"
17493>>>>>>>Function ParseFileExtension Global String sFileName Returns String
17495>>>>>>>    String  sFileExtension
17495>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
17496>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
17497>>>>>>>    Function_Return sFileExtension
17498>>>>>>>End_Function
17499>>>>>>>
17499>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
17499>>>>>>>
17499>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
17501>>>>>>>    String sMessage
17501>>>>>>>    Case Begin
17501>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
17503>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
17504>>>>>>>            Case Break
17505>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
17508>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
17509>>>>>>>            Case Break
17510>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
17513>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
17514>>>>>>>            Case Break
17515>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
17518>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
17519>>>>>>>            Case Break
17520>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
17523>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
17524>>>>>>>            Case Break
17525>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
17528>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
17529>>>>>>>            Case Break
17530>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
17533>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
17534>>>>>>>            Case Break
17535>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
17538>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
17539>>>>>>>            Case Break
17540>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
17543>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
17544>>>>>>>            Case Break
17545>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
17548>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
17549>>>>>>>            Case Break
17550>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
17553>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
17554>>>>>>>            Case Break
17555>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
17558>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
17559>>>>>>>            Case Break
17560>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
17563>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
17564>>>>>>>            Case Break
17565>>>>>>>        Case Else
17565>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
17566>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
17567>>>>>>>            Case Break
17568>>>>>>>    Case End
17568>>>>>>>    Function_Return sMessage
17569>>>>>>>End_Function
17570>>>>>>>
17570>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
17572>>>>>>>    String sMessage
17572>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
17573>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
17574>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
17575>>>>>>>End_Procedure
17576>>>>>>>
17576>>>>>>>// Does the directory exist? - No = false, Yes = True
17576>>>>>>>// This also works with UNC path encoding and wildcards
17576>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
17578>>>>>>>    Boolean bFolderExists
17578>>>>>>>    Boolean bStop
17578>>>>>>>    String  sFolder sTmp
17578>>>>>>>    Integer iCh
17578>>>>>>>
17578>>>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
17578>>>>>>>    Move (Utf8ToAnsi(Trim(sFolderName))) to sFolderName
17579>>>>>>>    If (sFolderName = "") Begin
17581>>>>>>>        Function_Return False
17582>>>>>>>    End
17582>>>>>>>>
17582>>>>>>>
17582>>>>>>>    Move True  to bFolderExists
17583>>>>>>>    Move False to bStop
17584>>>>>>>    Move "dir:" to sFolder
17585>>>>>>>    Append sFolder sFolderName
17586>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
17587>>>>>>>    Direct_Input channel iCh sFolder
17589>>>>>>>    Repeat
17589>>>>>>>>
17589>>>>>>>        Readln channel iCh sTmp
17591>>>>>>>        Move (SeqEof) to bStop
17592>>>>>>>        If (Trim(sTmp)="") Begin
17594>>>>>>>            Move False to bFolderExists
17595>>>>>>>        End
17595>>>>>>>>
17595>>>>>>>        Else Begin
17596>>>>>>>            Move True to bFolderExists
17597>>>>>>>            Move True to bStop
17598>>>>>>>        End
17598>>>>>>>>
17598>>>>>>>    Until (bStop)
17600>>>>>>>    Close_Input channel iCh
17602>>>>>>>    Send Seq_Release_Channel iCh
17603>>>>>>>    Function_Return bFolderExists
17604>>>>>>>End_Function
17605>>>>>>>
17605>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
17605>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
17607>>>>>>>    String sFolder sTitle sPath
17607>>>>>>>    Pointer lpItemIdList
17607>>>>>>>    Integer iFolderSelected iRetval
17607>>>>>>>    tvBrowseInfo BrowseInfo
17607>>>>>>>    tvBrowseInfo BrowseInfo
17607>>>>>>>
17607>>>>>>>    Move "" to sPath
17608>>>>>>>    If (sDialogTitle<>"") Begin
17610>>>>>>>        Move sDialogTitle to sTitle
17611>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
17611>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
17611>>>>>>>        // These chars are correctly shown if no toansi is used.
17611>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
17611>>>>>>>        // selected it will always be valid.
17611>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
17612>>>>>>>    End
17612>>>>>>>>
17612>>>>>>>
17612>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
17613>>>>>>>
17613>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
17613>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
17613>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
17614>>>>>>>
17614>>>>>>>    // null 128 chars into var (make space)
17614>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17615>>>>>>>
17615>>>>>>>    // select folder
17615>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
17616>>>>>>>    // get selected folder name
17616>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
17617>>>>>>>
17617>>>>>>>    // release memory resources that are used by the ItemIdList
17617>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
17618>>>>>>>
17618>>>>>>>    If (iFolderSelected<>0) Begin
17620>>>>>>>        Move (CString(sFolder)) to sPath
17621>>>>>>>    End
17621>>>>>>>>
17621>>>>>>>    Function_Return  sPath
17622>>>>>>>End_Function
17623>>>>>>>
17623>>>>>>>// returns 0 if the folder is created.
17623>>>>>>>//         1 if the API-call returned an error.
17623>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
17625>>>>>>>    String  sFolder
17625>>>>>>>    Integer iRetval bFolderCreated
17625>>>>>>>    tvSecurity_attributes SA
17625>>>>>>>    tvSecurity_attributes SA
17625>>>>>>>
17625>>>>>>>    Move False to bFolderCreated
17626>>>>>>>
17626>>>>>>>    // null MAX_PATH chars into var (make space)
17626>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17627>>>>>>>
17627>>>>>>>    If (sNewFolder <> "") Begin
17629>>>>>>>
17629>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
17630>>>>>>>        Move  0  to SA.lpDescriptor
17631>>>>>>>        Move  1  to SA.bInheritHandle
17632>>>>>>>
17632>>>>>>>        //
17632>>>>>>>        Move (sNewFolder+"") to sFolder
17633>>>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
17634>>>>>>>    End
17634>>>>>>>>
17634>>>>>>>
17634>>>>>>>    If (bFolderCreated=false) Begin
17636>>>>>>>        Move 1 to iRetVal
17637>>>>>>>    End
17637>>>>>>>>
17637>>>>>>>    Function_Return iRetVal
17638>>>>>>>End_Function
17639>>>>>>>
17639>>>>>>>// **WvA: 03-02-2002 Function created.
17639>>>>>>>// With this function one can remove a directory.
17639>>>>>>>// returns 0 if the folder is removed.
17639>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
17639>>>>>>>//         2 if the folder did not exist
17639>>>>>>>//         3 if the sFolder parameter passed is equal to ""
17639>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
17641>>>>>>>    Boolean bRemoved
17641>>>>>>>    String  sPath
17641>>>>>>>    Integer iRetval
17641>>>>>>>
17641>>>>>>>    Move 0     to iRetVal
17642>>>>>>>    Move False to bRemoved
17643>>>>>>>    Move (Trim(sFolder)) to sFolder
17644>>>>>>>    If (sFolder="") Begin
17646>>>>>>>        Move 3 to iRetVal
17647>>>>>>>    End
17647>>>>>>>>
17647>>>>>>>    If (vFolderExists(sFolder)=False) Begin
17649>>>>>>>        Move 2 to iRetVal
17650>>>>>>>    End
17650>>>>>>>>
17650>>>>>>>    If (iRetVal=0) Begin
17652>>>>>>>    // null MAX_PATH chars into var (make space)
17652>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
17653>>>>>>>        //
17653>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
17654>>>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
17655>>>>>>>    End
17655>>>>>>>>
17655>>>>>>>
17655>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
17657>>>>>>>        Move 1 to iRetVal
17658>>>>>>>    End
17658>>>>>>>>
17658>>>>>>>    Function_Return iRetVal
17659>>>>>>>End_Function
17660>>>>>>>
17660>>>>>>>// This function informs the user that he entered a yet unknown folder and
17660>>>>>>>// asks if he/she wants to create the folder (Yes/No)
17660>>>>>>>// Choice: "Yes" - this creates the folder
17660>>>>>>>//                 if successful, the function returns false
17660>>>>>>>//                 else it will be true.
17660>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
17660>>>>>>>//                 For example: to stop a save
17660>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
17660>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
17660>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
17662>>>>>>>    Integer bIsNotValid
17662>>>>>>>    Integer iUsers_Choice
17662>>>>>>>    String  sMessage
17662>>>>>>>
17662>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
17664>>>>>>>        Move "The folder '" to sMessage
17665>>>>>>>        Append sMessage sFolderName
17666>>>>>>>        Append sMessage "' does not yet exist,\n"
17667>>>>>>>        Append sMessage "Do you want to create it now?"
17668>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
17669>>>>>>>        Case Begin
17669>>>>>>>            Case (iUsers_Choice = MBR_Yes)
17671>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
17672>>>>>>>                If bIsNotValid Begin
17674>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
17675>>>>>>>                    Append sMessage sFolderName "'.\n\n"
17677>>>>>>>                    Send Info_Box sMessage "Info"
17678>>>>>>>                End
17678>>>>>>>>
17678>>>>>>>                Case Break
17679>>>>>>>            Case (iUsers_Choice = MBR_No)
17682>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
17683>>>>>>>                Case Break
17684>>>>>>>        Case End
17684>>>>>>>    End
17684>>>>>>>>
17684>>>>>>>    Function_Return bIsNotValid
17685>>>>>>>End_Function
17686>>>>>>>
17686>>>>>>>// This will perform an operation on a file (e.g. open) with the application
17686>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
17686>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
17686>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
17688>>>>>>>    Handle  hInstance hWnd
17688>>>>>>>    // remove any leading/trailing spaces in the string
17688>>>>>>>    Move (Trim(sDocument)) to sDocument
17689>>>>>>>    Move (Trim(sPath))     to sPath
17690>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
17690>>>>>>>    Append sOperation   (Character(0))
17691>>>>>>>    Append sDocument    (Character(0))
17692>>>>>>>    Append sParameters  (Character(0))
17693>>>>>>>    Append sPath        (Character(0))
17694>>>>>>>
17694>>>>>>>    Get Window_Handle to hWnd
17695>>>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
17696>>>>>>>    If (hInstance <= 32) Begin
17698>>>>>>>        Send vDDE_Error_Handler hInstance
17699>>>>>>>    End
17699>>>>>>>>
17699>>>>>>>End_Procedure
17700>>>>>>>
17700>>>>>>>Class cShellFileOperations is a Array
17701>>>>>>>
17701>>>>>>>    Procedure Construct_Object
17703>>>>>>>        Forward Send Construct_Object
17705>>>>>>>        Property Integer piDeleteFlags        0
17706>>>>>>>        Property Integer piCopyFlags          0
17707>>>>>>>        Property Integer piMoveFlags          0
17708>>>>>>>        Property Integer piRenameFlags        0
17709>>>>>>>
17709>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
17710>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
17711>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
17712>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
17713>>>>>>>    End_Procedure
17714>>>>>>>
17714>>>>>>>    // This function uses the shell API to perform a file operation on the
17714>>>>>>>    // files supplied.
17714>>>>>>>    //
17714>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
17716>>>>>>>        Integer  iRetVal
17716>>>>>>>        Integer  iUserAbort
17716>>>>>>>        tvShFileOpStruct FOS
17716>>>>>>>        tvShFileOpStruct FOS
17716>>>>>>>
17716>>>>>>>        Move (Utf8ToAnsi(sSource)+Character(0)+Character(0))      to sSource
17717>>>>>>>        Move (Utf8ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
17718>>>>>>>        If (eOperation <> vFO_DELETE) Begin
17720>>>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
17721>>>>>>>        End
17721>>>>>>>>
17721>>>>>>>
17721>>>>>>>        Move eOperation           to FOS.wFunc
17722>>>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
17723>>>>>>>        Move iFlags               to FOS.fFlags
17724>>>>>>>
17724>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
17725>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
17726>>>>>>>        If (iUserAbort <> 0) Begin
17728>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
17729>>>>>>>        End
17729>>>>>>>>
17729>>>>>>>        Function_Return (iRetVal)
17730>>>>>>>    End_Function
17731>>>>>>>
17731>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
17733>>>>>>>        Integer  iRetVal
17733>>>>>>>        Integer  iFlags
17733>>>>>>>
17733>>>>>>>        Get piDeleteFlags to iFlags
17734>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
17735>>>>>>>        Function_Return iRetVal
17736>>>>>>>    End_Function
17737>>>>>>>
17737>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
17739>>>>>>>        Integer  iRetVal
17739>>>>>>>        Integer  iFlags
17739>>>>>>>
17739>>>>>>>        Get piCopyFlags to iFlags
17740>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
17741>>>>>>>        Function_Return iRetVal
17742>>>>>>>    End_Function
17743>>>>>>>
17743>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
17745>>>>>>>        Integer  iRetVal
17745>>>>>>>        Integer  iFlags
17745>>>>>>>
17745>>>>>>>        Get piMoveFlags to iFlags
17746>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
17747>>>>>>>        Function_Return iRetVal
17748>>>>>>>    End_Function
17749>>>>>>>
17749>>>>>>>    // Rename a file or folder
17749>>>>>>>    // Returns a nonzero value if the operation failed.
17749>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
17751>>>>>>>        Integer  iRetVal
17751>>>>>>>        Integer  iFlags
17751>>>>>>>
17751>>>>>>>        Get piRenameFlags to iFlags
17752>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
17753>>>>>>>        Function_Return iRetVal
17754>>>>>>>    End_Function
17755>>>>>>>
17755>>>>>>>    // Courtesy Of Steve Walter
17755>>>>>>>    // Requires Windows 2000 and up according to msdn but it was
17755>>>>>>>    //  in fact available before that as an unpublished API call
17755>>>>>>>    //  a little google search shows that this was already available
17755>>>>>>>    //  in windows 95 and NT
17755>>>>>>>    //
17755>>>>>>>    // The format is controlled by the dialog interface.
17755>>>>>>>    // That is, the user must click the OK button To actually Begin the format
17755>>>>>>>    // the format cannot be started programmatically.
17755>>>>>>>    // An alternative to this functionality would be to use a controlpanel
17755>>>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
17755>>>>>>>    //
17755>>>>>>>    // hWnd = The windows handle of the object from which the format Function
17755>>>>>>>    //        is called.
17755>>>>>>>    // To Get this,
17755>>>>>>>    //          use:  Get Window_Handle Of <object>
17755>>>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
17755>>>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
17755>>>>>>>    //
17755>>>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
17755>>>>>>>    //
17755>>>>>>>    // iOptions = Format options.
17755>>>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
17755>>>>>>>    //  SHFMT_OPT_FULL    = Full Format
17755>>>>>>>    //  SHFMT_OPT_SYSONLY = System only
17755>>>>>>>    //  3                 = Full format with system. (unsupported)
17755>>>>>>>    //
17755>>>>>>>    // Return Values:
17755>>>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
17755>>>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
17755>>>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
17755>>>>>>>    //
17755>>>>>>>    //
17755>>>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
17755>>>>>>>    //                seem to work, i must have made a silly mistake
17755>>>>>>>    //                somewhere.
17755>>>>>>>    //
17755>>>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
17757>>>>>>>        Handle   hWnd
17757>>>>>>>        Integer  iObj
17757>>>>>>>        DWord    dwReturnVal
17757>>>>>>>        Integer iDrive
17757>>>>>>>
17757>>>>>>>        Function_Return 1 // STOP HERE
17758>>>>>>>
17758>>>>>>>        Move (Trim(sDrive)) to sDrive
17759>>>>>>>        If ( sDrive <> '' ) Begin
17761>>>>>>>            If ( sDrive Contains ':' ) Begin
17763>>>>>>>                Move (Replace(':',sDrive,'')) to sDrive
17764>>>>>>>            End
17764>>>>>>>>
17764>>>>>>>            If (Not( 'AB' Contains sDrive )) Begin
17766>>>>>>>                Function_Return (SHFMT_NOFORMAT)
17767>>>>>>>            End
17767>>>>>>>>
17767>>>>>>>            If ( sDrive = 'A' ) Begin
17769>>>>>>>                Move 0 to iDrive
17770>>>>>>>            End
17770>>>>>>>>
17770>>>>>>>            Else If ( sDrive = 'B' ) Begin
17773>>>>>>>                Move 1 to iDrive
17774>>>>>>>            End
17774>>>>>>>>
17774>>>>>>>            // Window_Handle Of Desktop equals to 0
17774>>>>>>>
17774>>>>>>>            Get focus of desktop to iObj
17775>>>>>>>            If (iObj>desktop) Begin
17777>>>>>>>                Get Container_Handle of iObj to hWnd
17778>>>>>>>            End
17778>>>>>>>>
17778>>>>>>>            While (hWnd=0 And iObj<>Desktop)
17782>>>>>>>                Get Parent of iObj to iObj
17783>>>>>>>                Get Container_Handle of iObj to hWnd
17784>>>>>>>            Loop
17785>>>>>>>>
17785>>>>>>>
17785>>>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
17785>>>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
17786>>>>>>>        End
17786>>>>>>>>
17786>>>>>>>        Else Begin
17787>>>>>>>            Move (SHFMT_ERROR) to dwReturnVal
17788>>>>>>>        End
17788>>>>>>>>
17788>>>>>>>        Function_Return dwReturnVal
17789>>>>>>>    End_Function
17790>>>>>>>
17790>>>>>>>    //Example:
17790>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
17790>>>>>>>    //                                          mode.
17790>>>>>>>
17790>>>>>>>End_Class
17791>>>>>>>
17791>>>>>>>Object oShellFileOperations is a cShellFileOperations
17793>>>>>>>End_Object
17794>>>>>>>
17794>>>>>>>// Restore to the old way of working with the shell file operations.
17794>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
17794>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
17794>>>>>>>Procedure vWin32fhCompatibilityMode
17796>>>>>>>    Integer hoSFO
17796>>>>>>>    Integer iFlags
17796>>>>>>>
17796>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
17797>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
17798>>>>>>>
17798>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
17799>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
17800>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
17801>>>>>>>    Set piRenameFlags of hoSFO to iFlags
17802>>>>>>>End_Procedure
17803>>>>>>>
17803>>>>>>>// Delete a file or folder
17803>>>>>>>// Returns a nonzero value if the operation failed.
17803>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
17805>>>>>>>    Integer  iRetVal
17805>>>>>>>
17805>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
17806>>>>>>>    Function_Return iRetVal
17807>>>>>>>End_Function
17808>>>>>>>
17808>>>>>>>// Copy a file or folder
17808>>>>>>>// Returns a nonzero value if the operation failed.
17808>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
17810>>>>>>>    Integer  iRetVal
17810>>>>>>>
17810>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17811>>>>>>>    Function_Return iRetVal
17812>>>>>>>End_Function
17813>>>>>>>
17813>>>>>>>// Move a file or folder
17813>>>>>>>// Returns a nonzero value if the operation failed.
17813>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
17815>>>>>>>    Integer  iRetVal
17815>>>>>>>
17815>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17816>>>>>>>    Function_Return iRetVal
17817>>>>>>>End_Function
17818>>>>>>>
17818>>>>>>>// Rename a file or folder
17818>>>>>>>// Returns a nonzero value if the operation failed.
17818>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
17820>>>>>>>    Integer  iRetVal
17820>>>>>>>
17820>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17821>>>>>>>    Function_Return iRetVal
17822>>>>>>>End_Function
17823>>>>>>>
17823>>>>>>>Function vGetWindowsDirectory Returns String
17825>>>>>>>    String  sDirectory
17825>>>>>>>    Integer iVoid
17825>>>>>>>
17825>>>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
17826>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
17827>>>>>>>    Function_Return (CString(sDirectory))
17828>>>>>>>End_Function
17829>>>>>>>
17829>>>>>>>Function vGetTempPath Returns String
17831>>>>>>>    Integer iRetval
17831>>>>>>>    String  sTempPath
17831>>>>>>>
17831>>>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
17832>>>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
17833>>>>>>>    Function_Return (Cstring(sTempPath))
17834>>>>>>>End_Function
17835>>>>>>>
17835>>>>>>>// Courtesy of Marco Kuipers
17835>>>>>>>Function vMakeTempFile Returns String
17837>>>>>>>    Integer iRetval
17837>>>>>>>    String  sTempPath
17837>>>>>>>    String  sTempFileName
17837>>>>>>>    String  sPrefixString
17837>>>>>>>
17837>>>>>>>    Get vGetTempPath to sTempPath
17838>>>>>>>    If (sTempPath = "") Begin
17840>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
17841>>>>>>>        If (sTempPath<>"") Begin
17843>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
17844>>>>>>>        End
17844>>>>>>>>
17844>>>>>>>    End
17844>>>>>>>>
17844>>>>>>>
17844>>>>>>>    If (sTempPath = "") Begin
17846>>>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
17846>>>>>>>    // makes little sense. Leaving this in as it was old behavior.
17846>>>>>>>        Get_Current_Directory to sTempPath
17847>>>>>>>    End
17847>>>>>>>>
17847>>>>>>>
17847>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
17848>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
17850>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
17851>>>>>>>>
17851>>>>>>>    End
17851>>>>>>>>
17851>>>>>>>
17851>>>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
17852>>>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
17853>>>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
17854>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
17856>>>>>>>    //Get ShowLastError to iRetval
17856>>>>>>>        Move "" to sTempFileName
17857>>>>>>>    End
17857>>>>>>>>
17857>>>>>>>
17857>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
17858>>>>>>>End_Function
17859>>>>>>>
17859>>>>>>>// This function creates a uniquely named temporary file in folder sPath
17859>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
17859>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
17859>>>>>>>// does not take care of that.
17859>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
17861>>>>>>>    Integer iRetVal
17861>>>>>>>    String sTempFileName
17861>>>>>>>
17861>>>>>>>    Move (Utf8ToAnsi(sPath)+Character(0))   to sPath
17862>>>>>>>    Move (Utf8ToAnsi(sPrefix)+Character(0)) to sPrefix
17863>>>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
17864>>>>>>>
17864>>>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
17865>>>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
17866>>>>>>>    Function_Return sTempFileName
17867>>>>>>>End_Function
17868>>>>>>>
17868>>>>>>>//
17868>>>>>>>// Get a specific shell folder for example to get the desktop folder
17868>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
17868>>>>>>>//
17868>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
17870>>>>>>>    String  sFolder
17870>>>>>>>    Integer iVoid
17870>>>>>>>    Handle  hWnd
17870>>>>>>>
17870>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
17871>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17872>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
17873>>>>>>>    Function_Return (CString(sFolder))
17874>>>>>>>End_Function
17875>>>>>>>
17875>>>>>>>// Courtesy Of Vincent Oorsprong
17875>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
17877>>>>>>>    String  sFormattedTime sFormattedDate
17877>>>>>>>    String  sFileDateTime
17877>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
17877>>>>>>>    tvFileTime   FileTime
17877>>>>>>>    tvFileTime   FileTime
17877>>>>>>>    tvSystemTime SystemTime
17877>>>>>>>    tvSystemTime SystemTime
17877>>>>>>>
17877>>>>>>>    Move "" to sFileDateTime
17878>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
17879>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
17880>>>>>>>
17880>>>>>>>    Move 0 to SystemTime.wYear
17881>>>>>>>
17881>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
17882>>>>>>>    If (iSuccess = 1) Begin
17884>>>>>>>        Move (ZeroString(255))        to sFormattedTime
17885>>>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
17886>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
17887>>>>>>>        Move (ZeroString(255))        to sFormattedDate
17888>>>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
17889>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
17890>>>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
17891>>>>>>>    End
17891>>>>>>>>
17891>>>>>>>    Function_Return sFileDateTime
17892>>>>>>>End_Function
17893>>>>>>>
17893>>>>>>>// **WvA:
17893>>>>>>>// A windows replacement for the standard function FileExists.
17893>>>>>>>// This version will also return (true) for a file when it is open by an application.
17893>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
17893>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
17893>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
17893>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
17895>>>>>>>    String  sDirSep
17895>>>>>>>    Handle  hFindFile
17895>>>>>>>    Integer iVoid
17895>>>>>>>    tvWin32FindData FindData
17895>>>>>>>    tvWin32FindData FindData
17895>>>>>>>
17895>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
17896>>>>>>>    Move (Utf8ToANSI(Trim(sFilePathMask))) to sFilePathMask
17897>>>>>>>    If (Length(sFilePathMask)>0) Begin
17899>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
17899>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
17900>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
17904>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
17905>>>>>>>        Loop
17906>>>>>>>>
17906>>>>>>>
17906>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17907>>>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
17908>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
17909>>>>>>>    End
17909>>>>>>>>
17909>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
17910>>>>>>>End_Function
17911>>>>>>>
17911>>>>>>>//
17911>>>>>>>// WideChar version of the function, do not use, it's an experiment
17911>>>>>>>//
17911>>>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
17913>>>>>>>    Handle  hFindFile
17913>>>>>>>    Integer iVoid
17913>>>>>>>    tvWin32FindData FindData
17913>>>>>>>    tvWin32FindData FindData
17913>>>>>>>
17913>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
17914>>>>>>>
17914>>>>>>>    If (Length(sFilePathMask)>0) Begin
17916>>>>>>>
17916>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17917>>>>>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
17918>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
17919>>>>>>>    End
17919>>>>>>>>
17919>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
17920>>>>>>>End_Function
17921>>>>>>>
17921>>>>>>>// **WvA
17921>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
17921>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
17921>>>>>>>// The folder may contain a drive letter or UNC encoding.
17921>>>>>>>Function vFolderFormat Global String sFolderName Returns String
17923>>>>>>>    String sDirSep
17923>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
17924>>>>>>>    Move (Trim(sFolderName)) to sFolderName
17925>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
17927>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
17928>>>>>>>    End
17928>>>>>>>>
17928>>>>>>>    Function_Return sFolderName
17929>>>>>>>End_Function
17930>>>>>>>
17930>>>>>>>//
17930>>>>>>>// Returns the amount of files in the folder (if it exists)
17930>>>>>>>// Returns -1 if folder doesn't exist.
17930>>>>>>>// The files "." and ".." are not counted.
17930>>>>>>>//
17930>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
17932>>>>>>>    Boolean bFound
17932>>>>>>>    Handle  hFindFile
17932>>>>>>>    Integer iCount  iVoid
17932>>>>>>>    Integer iSuccess
17932>>>>>>>    String  sFileName
17932>>>>>>>    tvWin32FindData FindData
17932>>>>>>>    tvWin32FindData FindData
17932>>>>>>>
17932>>>>>>>    Move -1 to iCount
17933>>>>>>>    Get vFolderFormat sFolderName to sFolderName
17934>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
17935>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17936>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
17937>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
17938>>>>>>>    If (bFound) Begin
17940>>>>>>>        Move 0 to iCount
17941>>>>>>>    End
17941>>>>>>>>
17941>>>>>>>    While (bFound)
17945>>>>>>>        Increment iCount
17946>>>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
17947>>>>>>>        If (sFileName="." or sFileName="..") Begin
17949>>>>>>>            Decrement iCount
17950>>>>>>>        End
17950>>>>>>>>
17950>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
17951>>>>>>>        Move (iSuccess<>0) to bFound
17952>>>>>>>    Loop
17953>>>>>>>>
17953>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
17954>>>>>>>    Function_Return iCount
17955>>>>>>>End_Function
17956>>>>>>>
17956>>>>>>>//
17956>>>>>>>// Gets the parent path of the currently supplied path
17956>>>>>>>// Returns "" when we are at the root folder.
17956>>>>>>>//
17956>>>>>>>Function vParentPath Global String sPath Returns String
17958>>>>>>>    String sStrip sDirSep
17958>>>>>>>
17958>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
17959>>>>>>>    Move (Trim(sPath)) to sPath
17960>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
17962>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
17963>>>>>>>    End
17963>>>>>>>>
17963>>>>>>>    If (Pos(sDirSep, sPath)) Begin
17965>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
17966>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
17967>>>>>>>    End
17967>>>>>>>>
17967>>>>>>>    Else Begin
17968>>>>>>>        Move "" to sPath
17969>>>>>>>    End
17969>>>>>>>>
17969>>>>>>>    Function_Return sPath
17970>>>>>>>End_Function
17971>>>>>>>
17971>>>>>>>// Create the folder, including intermediate directories.
17971>>>>>>>// Don't panic if the folder already exists.
17971>>>>>>>// Michael Mullan June 2009.
17971>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
17973>>>>>>>    String  sFolder
17973>>>>>>>    Integer iRetval iFolderCreated
17973>>>>>>>    tvSecurity_attributes SA
17973>>>>>>>    tvSecurity_attributes SA
17973>>>>>>>
17973>>>>>>>    Move 0 to iFolderCreated
17974>>>>>>>
17974>>>>>>>    // null MAX_PATH chars into var (make space)
17974>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17975>>>>>>>    If (sNewFolder <> "") Begin
17977>>>>>>>
17977>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
17978>>>>>>>        Move  0  to SA.lpDescriptor
17979>>>>>>>        Move  1  to SA.bInheritHandle
17980>>>>>>>
17980>>>>>>>        //
17980>>>>>>>        Move (sNewFolder+"") to sFolder
17981>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
17982>>>>>>>    End
17982>>>>>>>>
17982>>>>>>>
17982>>>>>>>    If (iFolderCreated <> 0) Begin
17984>>>>>>>        Move 1 to iRetVal
17985>>>>>>>        Case Begin
17985>>>>>>>            Case (iFolderCreated = 161)
17987>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
17988>>>>>>>>
17988>>>>>>>                Case Break
17989>>>>>>>            Case (iFolderCreated = 206)
17992>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
17993>>>>>>>>
17993>>>>>>>                Case Break
17994>>>>>>>            Case (iFolderCreated = 3)
17997>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
17998>>>>>>>>
17998>>>>>>>                Case Break
17999>>>>>>>            Case (iFolderCreated = 80)
18002>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
18003>>>>>>>                Case Break
18004>>>>>>>            Case (iFolderCreated = 183)
18007>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
18008>>>>>>>                Case Break
18009>>>>>>>            Case (iFolderCreated = 1223)
18012>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
18013>>>>>>>>
18013>>>>>>>                Case Break
18014>>>>>>>            Case Else
18014>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
18015>>>>>>>>
18015>>>>>>>        Case End
18015>>>>>>>    End
18015>>>>>>>>
18015>>>>>>>    Function_Return iRetVal
18016>>>>>>>End_Function
18017>>>>>>>
18017>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
18019>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
18019>>>>>>>    Integer iFileSize iVoid
18019>>>>>>>    Handle  hFindFile
18019>>>>>>>    tvWin32FindData FindData
18019>>>>>>>    tvWin32FindData FindData
18019>>>>>>>
18019>>>>>>>    Move (sFileName+"") to sFileName
18020>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
18021>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
18022>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
18024>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
18025>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
18026>>>>>>>    End
18026>>>>>>>>
18026>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
18027>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
18028>>>>>>>
18028>>>>>>>    Function_Return iFileSize
18029>>>>>>>End_Function
18030>>>>>>>
18030>>>>>>>//
18030>>>>>>>// Based on code in Peter Crook's Browse folder workspace
18030>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
18030>>>>>>>//
18030>>>>>>>//=============================================================================
18030>>>>>>>// Verifies that a path is a valid directory.
18030>>>>>>>//
18030>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
18030>>>>>>>//
18030>>>>>>>// Parameters:
18030>>>>>>>//      sPath - Address of the path to verify.
18030>>>>>>>//=============================================================================
18030>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
18032>>>>>>>    Integer iResult
18032>>>>>>>    Boolean bRetVal
18032>>>>>>>
18032>>>>>>>    Move false to bRetVal
18033>>>>>>>    Move (Utf8ToAnsi(sPath) - Character (0)) to sPath
18034>>>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
18035>>>>>>>    If (iResult<>0) Begin
18037>>>>>>>        Move True to bRetVal
18038>>>>>>>    End
18038>>>>>>>>
18038>>>>>>>
18038>>>>>>>    Function_Return bRetVal
18039>>>>>>>End_Function
18040>>>>>>>
18040>>>>>Use DUFLanguageConstants.inc
18040>>>>>
18040>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
18040>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
18040>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
18040>>>>>
18040>>>>>Struct tDUFIntFile
18040>>>>>    Integer iID
18040>>>>>    String sIntFileName
18040>>>>>    String sIntLineText
18040>>>>>End_Struct
18040>>>>>
18040>>>>>Struct tDbVersionInfo
18040>>>>>    Number nVersionNumber
18040>>>>>    Handle hObject
18040>>>>>End_Struct
18040>>>>>
18040>>>>>Struct tDbUpdateError
18040>>>>>    Number nUpdateVersion
18040>>>>>    Integer iError
18040>>>>>    String  sOrgErrorText
18040>>>>>    String  sErrorText
18040>>>>>    Integer iErrorLine
18040>>>>>    Boolean bError  
18040>>>>>    Handle  hTable 
18040>>>>>    String  sTableRootName
18040>>>>>    Integer iField
18040>>>>>    Boolean bShortFormat
18040>>>>>End_Struct
18040>>>>>
18040>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
18040>>>>>//  DF_FILE_IS_MASTER if master
18040>>>>>//  DF_FILE_IS_ALIAS if alias
18040>>>>>Struct tDbUpdateHandlerMasterAlias
18040>>>>>    Handle hTable
18040>>>>>    Integer iMode
18040>>>>>End_Struct
18040>>>>>
18040>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
18040>>>>>Enumeration_List
18040>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
18040>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
18040>>>>>End_Enumeration_List
18040>>>>>
18040>>>>>    Define DATAFLEX_ID for "DATAFLEX"
18040>>>>>
18040>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
18040>>>>>// communicate with the object from anywhere in a program.
18040>>>>>    Global_Variable Handle ghoDbUpdateHandler
18040>>>>>    Move 0 to ghoDbUpdateHandler
18041>>>>>
18041>>>>>// NOTE: If the DbVersion table should _not_ be used and you
18041>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
18041>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
18041>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
18041>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
18041>>>>>//    Declare_Datafile DbVersion
18041>>>>>//#ENDIF
18041>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateLogFile.pkg)
18041>>>>>//****************************************************************************
18041>>>>>// $Module type: Class
18041>>>>>// $Module name: cDbUpdateLogFile
18041>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18041>>>>>// Web-site    : http://www.rdctools.com
18041>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
18041>>>>>//
18041>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
18041>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
18041>>>>>//               that this class is to change; each developer can decide if the errors instead
18041>>>>>//               should be saved to a database table, or something entirely different.
18041>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
18041>>>>>//
18041>>>>>// $Rev History:
18041>>>>>//    2016-10-05  Module header created
18041>>>>>//****************************************************************************
18041>>>>>Use UI
18041>>>>>Use vWin32fh.pkg
18041>>>>>
18041>>>>>
18041>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
18041>>>>>
18041>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
18041>>>>>
18041>>>>>Class cDbUpdateLogFile is a cObject
18042>>>>>
18042>>>>>    Procedure Construct_Object
18044>>>>>        Forward Send Construct_Object
18046>>>>>
18046>>>>>        // Error handling:
18046>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
18047>>>>>        Property Integer piChannel -1
18048>>>>>
18048>>>>>        // This property is set by the cDbUpdateHandler object,
18048>>>>>        // when the update process starts.
18048>>>>>        Property DateTime pdtUpdateStart
18049>>>>>
18049>>>>>        // Gets set to False if the log contains data
18049>>>>>        Property Boolean pbEmptyLogFile True
18050>>>>>
18050>>>>>        // Gets set to True after the error log header text
18050>>>>>        // has been written.
18050>>>>>        Property Boolean pbHeaderWritten False
18051>>>>>
18051>>>>>        // If all activities should be logged- not just errors.
18051>>>>>        Property Boolean pbVerboseState False
18052>>>>>
18052>>>>>        // File name for the error log where all errors
18052>>>>>        // after a run is written to (appended).
18052>>>>>        // It is saved in the Data folder.
18052>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
18053>>>>>        // If this property is set to "" in object code, the
18053>>>>>        // "shell" command parameter will be used to let Windows decide
18053>>>>>        // with which program to open the logfile.
18053>>>>>        Property String psEditorProgram ""
18054>>>>>
18054>>>>>        Property Boolean pbUseDataTableLog False
18055>>>>>
18055>>>>>        // If true an error will be written to file immediately when
18055>>>>>        // it occurs. This can be handy if a large update generates a lots
18055>>>>>        // of errors and the application crasches before finished, thus
18055>>>>>        // the errors will not be written.
18055>>>>>        Property Boolean pbQuickWrite True
18056>>>>>    End_Procedure
18057>>>>>
18057>>>>>    Procedure End_Construct_Object
18059>>>>>        Forward Send End_Construct_Object
18061>>>>>
18061>>>>>    End_Procedure
18062>>>>>
18062>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
18064>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
18064>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
18066>>>>>        Boolean bShortFormat
18066>>>>>        Integer iSize
18066>>>>>        Handle hCurrentTable
18066>>>>>        Integer iCurrentField           
18066>>>>>        String sOrgErrorText sTableRootName
18066>>>>>        
18066>>>>>        Move False to bShortFormat
18067>>>>>        If (num_arguments > 5) Begin
18069>>>>>            Move bShortFormatIn to bShortFormat
18070>>>>>        End
18070>>>>>>
18070>>>>>        // Only do once.
18070>>>>>        If (pbHeaderWritten(Self) = False) Begin
18072>>>>>            Send WriteHeaderData
18073>>>>>            Set pbHeaderWritten to True
18074>>>>>        End
18074>>>>>>
18074>>>>>
18074>>>>>        Get Private.phCurrentTable to hCurrentTable  
18075>>>>>        Get Private.piCurrentField to iCurrentField  
18076>>>>>        If (iError > 0) Begin
18078>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
18081>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
18082>>>>>        End
18082>>>>>>
18082>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
18083>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
18084>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
18085>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
18086>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
18087>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
18088>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
18089>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
18090>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
18091>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
18092>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
18093>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
18094>>>>>
18094>>>>>        If (bError = False) Begin
18096>>>>>            Move False to DbUpdateErrorArray[iSize].bError
18097>>>>>        End
18097>>>>>>
18097>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
18098>>>>>
18098>>>>>        If (pbUseDataTableLog(Self) = True) Begin
18100>>>>>            If (pbQuickWrite(Self) = True) Begin
18102>>>>>                Send OnWriteRow_DataTable
18103>>>>>                // If we are writing error for error flush the
18103>>>>>                // error array when latest error has been written.
18103>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
18104>>>>>            End
18104>>>>>>
18104>>>>>            Procedure_Return
18105>>>>>        End
18105>>>>>>
18105>>>>>        Else Begin
18106>>>>>            If (pbQuickWrite(Self) = True) Begin
18108>>>>>                Send WriteErrorLog
18109>>>>>                // Flush the error log array
18109>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
18110>>>>>            End
18110>>>>>>
18110>>>>>        End
18110>>>>>>
18110>>>>>    End_Procedure   
18111>>>>>    
18111>>>>>    Function FetchErrorDescription Integer iError Returns String
18113>>>>>        String sErrorText         
18113>>>>>        Move "" to sErrorText
18114>>>>>        If (iError > 0) Begin
18116>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
18117>>>>>        End
18117>>>>>>
18117>>>>>        Function_Return sErrorText
18118>>>>>    End_Function
18119>>>>>
18119>>>>>    // Hook procedure for writing header text prior starting the update work to
18119>>>>>    // a database table. This does nothing by default.
18119>>>>>    // Don't forget to Open your "error log table" first (!) as all
18119>>>>>    // tables have been closed at this stage. Put anything
18119>>>>>    // you want to indicate that the update process is just started.
18119>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
18121>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
18123>>>>>    End_Procedure
18124>>>>>
18124>>>>>    Procedure OnWriteRow_DataTable
18126>>>>>        tDbUpdateError[] DbUpdateErrorArray
18126>>>>>        tDbUpdateError[] DbUpdateErrorArray
18127>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
18128>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
18130>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
18132>>>>>        End
18132>>>>>>
18132>>>>>    End_Procedure
18133>>>>>
18133>>>>>    Function psLogTextFileWithPath Returns String
18135>>>>>        String sPath sFileName sFullFileName
18135>>>>>        
18135>>>>>        Get psDataPathFirstPart to sPath
18136>>>>>        Get psLogTextFile to sFileName
18137>>>>>        Move (sPath + sFileName) to sFullFileName
18138>>>>>        Function_Return sFullFileName
18139>>>>>    End_Function                     
18140>>>>>    
18140>>>>>    Procedure WriteHeaderData
18142>>>>>        String sFileName
18142>>>>>        Integer iCh iSize
18142>>>>>        Boolean bQuickWrite
18142>>>>>        DateTime dtUpdateStart
18142>>>>>
18142>>>>>        Move (CurrentDateTime()) to dtUpdateStart
18143>>>>>        If (pbUseDataTableLog(Self) = True) Begin
18145>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
18146>>>>>            Procedure_Return
18147>>>>>        End
18147>>>>>>
18147>>>>>
18147>>>>>        Get piChannel to iCh
18148>>>>>        If (iCh < 0) Begin
18150>>>>>            Get Seq_New_Channel to iCh
18151>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
18153>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
18154>>>>>>
18154>>>>>                Procedure_Return
18155>>>>>            End
18155>>>>>>
18155>>>>>            Set piChannel to iCh
18156>>>>>        End
18156>>>>>>
18156>>>>>
18156>>>>>        Get psLogTextFileWithPath to sFileName
18157>>>>>        Get vWin32_APIFileSize sFileName to iSize
18158>>>>>        Get pbQuickWrite to bQuickWrite
18159>>>>>        
18159>>>>>        If (bQuickWrite = True) Begin
18161>>>>>            Append_Output channel iCh sFileName
18163>>>>>                If (bQuickWrite = True) Begin
18165>>>>>                    If (iSize = 0) Begin
18167>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
18170>>>>>                        Set pbEmptyLogFile to False
18171>>>>>                    End
18171>>>>>>
18171>>>>>                    Writeln channel iCh
18173>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
18176>>>>>                End
18176>>>>>>
18176>>>>>            Close_Output channel iCh
18178>>>>>        End
18178>>>>>>
18178>>>>>    End_Procedure
18179>>>>>
18179>>>>>    // Returns the first datapath found in the psDataPath property.
18179>>>>>    // The returned path always ends with a "\"
18179>>>>>    Function psDataPathFirstPart Returns String
18181>>>>>        String sDataPath
18181>>>>>        Integer iCount
18181>>>>>
18181>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
18182>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
18183>>>>>        If (iCount > 1) Begin
18185>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
18186>>>>>        End
18186>>>>>>
18186>>>>>        If (sDataPath <> "") Begin
18188>>>>>            Get vFolderFormat sDataPath to sDataPath
18189>>>>>        End
18189>>>>>>
18189>>>>>
18189>>>>>        Function_Return sDataPath
18190>>>>>    End_Function
18191>>>>>
18191>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
18191>>>>>    Procedure WriteErrorLog
18193>>>>>        tDbUpdateError[] aDbUpdateErrorArray
18193>>>>>        tDbUpdateError[] aDbUpdateErrorArray
18194>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
18194>>>>>        Integer iCount iSize iCh iError iErrorLine iField
18194>>>>>        Boolean bUseDataTable bQuickWrite
18194>>>>>        DateTime dtUpdateStart dtUpdateEnd
18194>>>>>        TimeSpan tsElapsed
18194>>>>>        Number nVersion                                  
18194>>>>>        Handle hTable
18194>>>>>
18194>>>>>        If (pbHeaderWritten(Self) = False) Begin
18196>>>>>            Send WriteHeaderData
18197>>>>>            Set pbHeaderWritten to True
18198>>>>>        End
18198>>>>>>
18198>>>>>
18198>>>>>        Get pbUseDataTableLog to bUseDataTable
18199>>>>>        If (bUseDataTable = True) Begin
18201>>>>>            Send OnWriteRow_DataTable
18202>>>>>            Procedure_Return
18203>>>>>        End
18203>>>>>>
18203>>>>>
18203>>>>>        Get piChannel to iCh
18204>>>>>        If (iCh < 0) Begin
18206>>>>>            Get Seq_New_Channel to iCh
18207>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
18209>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
18210>>>>>>
18210>>>>>                Procedure_Return
18211>>>>>            End
18211>>>>>>
18211>>>>>            Set piChannel to iCh
18212>>>>>        End
18212>>>>>>
18212>>>>>
18212>>>>>        Get psLogTextFileWithPath to sFileName
18213>>>>>
18213>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
18214>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
18215>>>>>        Decrement iSize
18216>>>>>
18216>>>>>        Get pdtUpdateStart to dtUpdateStart
18217>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
18219>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
18220>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
18221>>>>>        End
18221>>>>>>
18221>>>>>        Get pbQuickWrite to bQuickWrite
18222>>>>>
18222>>>>>        Append_Output channel iCh sFileName
18224>>>>>        If (bQuickWrite = True and iSize < 0) Begin
18226>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
18229>>>>>        End
18229>>>>>>
18229>>>>>        Else If (bQuickWrite = False) Begin
18232>>>>>            Writeln channel iCh
18234>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
18237>>>>>        End   
18237>>>>>>
18237>>>>>        If (iSize >= 0) Begin
18239>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
18241>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
18244>>>>>            End
18244>>>>>>
18244>>>>>        End
18244>>>>>>
18244>>>>>
18244>>>>>        For iCount from 0 to iSize  
18250>>>>>>
18250>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
18251>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
18252>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
18253>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
18254>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
18255>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
18256>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
18257>>>>>            
18257>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
18258>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
18260>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
18261>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
18262>>>>>            End
18262>>>>>>
18262>>>>>            Else Begin
18263>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
18264>>>>>                Move (sVersion + "   " + sErrorText) to sText
18265>>>>>            End
18265>>>>>>
18265>>>>>            Writeln channel iCh sText
18268>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
18270>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
18271>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
18272>>>>>                Writeln channel iCh sOrgErrorText
18275>>>>>            End
18275>>>>>>
18275>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
18277>>>>>                Writeln channel iCh
18279>>>>>            End
18279>>>>>>
18279>>>>>        Loop
18280>>>>>>
18280>>>>>        Close_Output channel iCh
18282>>>>>
18282>>>>>        Send Seq_Release_Channel iCh
18283>>>>>        Set piChannel to -1
18284>>>>>
18284>>>>>    End_Procedure
18285>>>>>
18285>>>>>    // The character to pad is optional. If nothing, spaces are used.
18285>>>>>    // Example:
18285>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
18285>>>>>    //  or:
18285>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
18285>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
18285>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
18287>>>>>        String sChar
18287>>>>>
18287>>>>>        If (Num_Arguments >= 3) Begin
18289>>>>>            Move sOptChar to sChar
18290>>>>>        End
18290>>>>>>
18290>>>>>        Else Begin
18291>>>>>            Move " " to sChar
18292>>>>>        End
18292>>>>>>
18292>>>>>
18292>>>>>        While (Length(sString) < iLength)
18296>>>>>            Move (sChar + sString) to sString
18297>>>>>        Loop
18298>>>>>>
18298>>>>>
18298>>>>>        Function_Return sString
18299>>>>>    End_Function
18300>>>>>
18300>>>>>    Procedure ShowErrorLog
18302>>>>>        String sPath sFileName sEditorProgram
18302>>>>>        Boolean bExists
18302>>>>>
18302>>>>>        Get psLogTextFileWithPath to sFileName
18303>>>>>        Get vFilePathExists sFileName to bExists
18304>>>>>        If (bExists = True) Begin
18306>>>>>            Get psEditorProgram to sEditorProgram
18307>>>>>            If (sEditorProgram <> "") Begin
18309>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
18310>>>>>            End
18310>>>>>>
18310>>>>>            Else Begin
18311>>>>>                Runprogram Shell Background sFileName
18312>>>>>            End
18312>>>>>>
18312>>>>>        End
18312>>>>>>
18312>>>>>        Else Begin
18313>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
18314>>>>>        End
18314>>>>>>
18314>>>>>    End_Procedure
18315>>>>>
18315>>>>>End_Class
18316>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateVersion.pkg)
18316>>>>>//****************************************************************************
18316>>>>>// $Module type: Class
18316>>>>>// $Module name: cDbUpdateVersion
18316>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18316>>>>>// Web-site    : http://www.rdctools.com
18316>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
18316>>>>>//
18316>>>>>// Description : Child class to cDbUpdateHandler.
18316>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
18316>>>>>//               Set the pnVersionNumber to a version number.
18316>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
18316>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
18316>>>>>//               Place your code in the "OnUpdate" event that alters the database.
18316>>>>>//
18316>>>>>// $Rev History:
18316>>>>>//    2016-09-27  Module header created
18316>>>>>//****************************************************************************
18316>>>>>Use UI
18316>>>>>Use DUFLanguageConstants.inc
18316>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary.pkg)
18316>>>>>>>//****************************************************************************
18316>>>>>>>// $Module type: Class
18316>>>>>>>// $Module name: cDbUpdateFunctionLibrary
18316>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18316>>>>>>>// Web-site    : http://www.rdctools.com
18316>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
18316>>>>>>>//
18316>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
18316>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
18316>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
18316>>>>>>>//               with the help of Sql-scripts.
18316>>>>>>>//
18316>>>>>>>// $Rev History:
18316>>>>>>>//    2014-09-05  Module header created
18316>>>>>>>//
18316>>>>>>>//****************************************************************************
18316>>>>>>>Use cApplication.pkg
18316>>>>>>>Use seq_chnl.pkg
18316>>>>>>>Use GlobalFunctionsProcedures.pkg
18316>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
18316>>>>>>>Use Dfcursor.pkg
Including file: Dfcursor.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfcursor.pkg)
18316>>>>>>>>>//  create a desktop object named Cursor_control that understands
18316>>>>>>>>>//   Send Cursor_Wait to (cursor_Control(self))
18316>>>>>>>>>//            creates hourclass cursor
18316>>>>>>>>>//   Send Cursor_ready to (cursor_Control(self))
18316>>>>>>>>>//            restores regular cursor
18316>>>>>>>>>//
18316>>>>>>>>>Use Cursor.pkg
Including file: Cursor.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Cursor.pkg)
18316>>>>>>>>>>>Use Windows.pkg
18316>>>>>>>>>>>Use WinUser.pkg
18316>>>>>>>>>>>
18316>>>>>>>>>>>// Standard Cursor IDs
18316>>>>>>>>>>>
18316>>>>>>>>>>>
18316>>>>>>>>>>>
18316>>>>>>>>>>>
18316>>>>>>>>>>>
18316>>>>>>>>>>>Class CursorShape is a DFBaseToolPanel //BasicPanel
18317>>>>>>>>>>>    
18317>>>>>>>>>>>    Procedure Construct_Object
18319>>>>>>>>>>>        Forward Send Construct_Object
18321>>>>>>>>>>>        
18321>>>>>>>>>>>        Property Handle ClassCursorHandle 0
18322>>>>>>>>>>>        Set Visible_State to False
18323>>>>>>>>>>>        Set Size to 1 1
18324>>>>>>>>>>>    End_Procedure
18325>>>>>>>>>>>    
18325>>>>>>>>>>>    Procedure Set Cursor Integer CursorType
18327>>>>>>>>>>>        Handle CursorID hWnd
18327>>>>>>>>>>>        Longptr retval lpCursorType
18327>>>>>>>>>>>        Get Window_Handle to hWnd
18328>>>>>>>>>>>        If (CursorType = 0) Begin
18330>>>>>>>>>>>            Send Release_Mouse_Capture
18331>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, ClassCursorHandle(Self))) to retval
18332>>>>>>>>>>>            Set ClassCursorHandle to 0
18333>>>>>>>>>>>            Send Page_Object False
18334>>>>>>>>>>>        End
18334>>>>>>>>>>>>
18334>>>>>>>>>>>        Else Begin
18335>>>>>>>>>>>            Send Page_Object True
18336>>>>>>>>>>>            Get Window_Handle to hWnd
18337>>>>>>>>>>>            If (ClassCursorHandle(Self) = 0) ;                Set ClassCursorHandle to (GetClassLongPtr(hWnd, GCL_HCURSOR))
18340>>>>>>>>>>>            
18340>>>>>>>>>>>            Move CursorType to lpCursorType    // Move to Longptr type to avoid conversion from integer to pointer in the next line
18341>>>>>>>>>>>            Move (LoadCursorW(0,lpCursorType)) to CursorID
18342>>>>>>>>>>>            
18342>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, CursorID )) to retval
18343>>>>>>>>>>>            Move (SetCursor(CursorID)) to retval
18344>>>>>>>>>>>            Send Set_Mouse_Capture
18345>>>>>>>>>>>        End
18345>>>>>>>>>>>>
18345>>>>>>>>>>>    End_Procedure
18346>>>>>>>>>>>    
18346>>>>>>>>>>>    Procedure Mouse_Up
18348>>>>>>>>>>>        Handle retval
18348>>>>>>>>>>>        Send Set_Mouse_Capture
18349>>>>>>>>>>>        Move (SetCursor(GetClassLongPtr(Window_Handle(Self), GCL_HCURSOR))) to retval
18350>>>>>>>>>>>    End_Procedure
18351>>>>>>>>>>>    
18351>>>>>>>>>>>    Procedure Cursor_Wait
18353>>>>>>>>>>>        Set cursor to IDC_WAIT
18354>>>>>>>>>>>    End_Procedure
18355>>>>>>>>>>>    
18355>>>>>>>>>>>    Procedure Cursor_Ready
18357>>>>>>>>>>>        Set cursor to 0
18358>>>>>>>>>>>    End_Procedure
18359>>>>>>>>>>>    
18359>>>>>>>>>>>    
18359>>>>>>>>>>>End_Class
18360>>>>>>>>>
18360>>>>>>>>>Object Cursor_Control is a CursorShape
18362>>>>>>>>>End_Object
18363>>>>>>>>>
18363>>>>>>>Use DUFStatusPanel.pkg
18363>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
18363>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
18363>>>>>>>>>//
18363>>>>>>>>>// We need to create a mixin class for the library.
18363>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
18363>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
18363>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
18363>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
18363>>>>>>>>>//
18363>>>>>>>>>Use VdfBase.pkg
18363>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 20.1\Pkg\WinUuid.pkg)
18363>>>>>>>>>>>Use Unicode.Pkg
18363>>>>>>>>>>>
18363>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
18364>>>>>>>>>>>
18364>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
18365>>>>>>>>>>>
18365>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
18366>>>>>>>>>>>
18366>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
18367>>>>>>>>>>>
18367>>>>>>>>>>>
18367>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
18367>>>>>>>>>>>Function RandomHexUUID Global Returns String
18369>>>>>>>>>>>    Pointer pUUID pUUIDStr
18369>>>>>>>>>>>    Integer iRetval iOffset iChar
18369>>>>>>>>>>>    String sUUID
18369>>>>>>>>>>>    
18369>>>>>>>>>>>    Move (Alloc(16)) to pUUID
18370>>>>>>>>>>>    
18370>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
18371>>>>>>>>>>>    
18371>>>>>>>>>>>    If (iRetval = 0) Begin
18373>>>>>>>>>>>        Move 0 to pUUIDStr
18374>>>>>>>>>>>        
18374>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
18375>>>>>>>>>>>        If (iRetval = 0) Begin
18377>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
18378>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
18379>>>>>>>>>>>            
18379>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
18380>>>>>>>>>>>        End
18380>>>>>>>>>>>>
18380>>>>>>>>>>>    End
18380>>>>>>>>>>>>
18380>>>>>>>>>>>    
18380>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
18381>>>>>>>>>>>    
18381>>>>>>>>>>>    Function_Return sUUID
18382>>>>>>>>>>>End_Function
18383>>>>>>>>>>>
18383>>>>>>>>>>>
18383>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
18383>>>>>>>>>>>Function SeqHexUUID Global Returns String
18385>>>>>>>>>>>    Pointer pUUID pUUIDStr
18385>>>>>>>>>>>    Integer iRetval iOffset iChar
18385>>>>>>>>>>>    String sUUID
18385>>>>>>>>>>>    
18385>>>>>>>>>>>    Move (Alloc(16)) to pUUID
18386>>>>>>>>>>>    
18386>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
18387>>>>>>>>>>>    
18387>>>>>>>>>>>    If (iRetval = 0) Begin
18389>>>>>>>>>>>        Move 0 to pUUIDStr
18390>>>>>>>>>>>        
18390>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
18391>>>>>>>>>>>        If (iRetval = 0) Begin
18393>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
18394>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
18395>>>>>>>>>>>            
18395>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
18396>>>>>>>>>>>        End
18396>>>>>>>>>>>>
18396>>>>>>>>>>>    End
18396>>>>>>>>>>>>
18396>>>>>>>>>>>    
18396>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
18397>>>>>>>>>>>    
18397>>>>>>>>>>>    Function_Return sUUID
18398>>>>>>>>>>>End_Function
18399>>>>>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cli.pkg)
18399>>>>>>>>>>>//                                                              
18399>>>>>>>>>>>//   CLI specific functionality. There are several connectivity kits     
18399>>>>>>>>>>>//   based on  SQL/92 CLI. Those are:                                    
18399>>>>>>>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
18399>>>>>>>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
18399>>>>>>>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
18399>>>>>>>>>>>//                                                                       
18399>>>>>>>>>>>//   This package defines the common functionality for all CLI based     
18399>>>>>>>>>>>//   drivers.                                                            
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
18399>>>>>>>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
18399>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
18399>>>>>>>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
18399>>>>>>>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
18399>>>>>>>>>>>Define DF_FILE_TABLE_NAME               for 609
18399>>>>>>>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
18399>>>>>>>>>>>Define DF_FILE_SQL_FILTER               for 611
18399>>>>>>>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
18399>>>>>>>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
18399>>>>>>>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
18399>>>>>>>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
18399>>>>>>>>>>>Define DF_FILE_DATABASE_ID              for 622
18399>>>>>>>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
18399>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
18399>>>>>>>>>>>Define DF_FILE_BLOCK_SIZE               for 628
18399>>>>>>>>>>>Define DF_FILE_JIT_BINDING              for 630
18399>>>>>>>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
18399>>>>>>>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
18399>>>>>>>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
18399>>>>>>>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
18399>>>>>>>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_FIELD_STORE_TIME              for 702
18399>>>>>>>>>>>Define DF_FIELD_TIME                    for 703
18399>>>>>>>>>>>Define DF_FIELD_IS_NULL                 for 704
18399>>>>>>>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
18399>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
18399>>>>>>>>>>>Define DF_FIELD_FETCH_STATE             for 708
18399>>>>>>>>>>>Define DF_FIELD_READ_ONLY               for 710
18399>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
18399>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
18399>>>>>>>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
18399>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN           for 716
18399>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
18399>>>>>>>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
18399>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
18399>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
18399>>>>>>>>>>>Define DF_FIELD_IS_IDENTITY             for 722
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_INDEX_NAME                    for 801
18399>>>>>>>>>>>Define DF_INDEX_UNIQUE                  for 802
18399>>>>>>>>>>>Define DF_INDEX_ON_BACKEND              for 804
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_INDEX_CLUSTERED               for 806
18399>>>>>>>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
18399>>>>>>>>>>>Define DF_INDEX_SQL_TYPE                for 810
18399>>>>>>>>>>>Define DF_INDEX_NUMBER                  for 812
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
18399>>>>>>>>>>>Define DF_DATABASE_ID                            for 1002
18399>>>>>>>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
18399>>>>>>>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
18399>>>>>>>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
18399>>>>>>>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
18399>>>>>>>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
18399>>>>>>>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
18399>>>>>>>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
18399>>>>>>>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
18399>>>>>>>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
18399>>>>>>>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
18399>>>>>>>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
18399>>>>>>>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
18399>>>>>>>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
18399>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
18399>>>>>>>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
18399>>>>>>>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
18399>>>>>>>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
18399>>>>>>>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
18399>>>>>>>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
18399>>>>>>>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
18399>>>>>>>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
18399>>>>>>>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
18399>>>>>>>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
18399>>>>>>>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
18399>>>>>>>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
18399>>>>>>>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
18399>>>>>>>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
18399>>>>>>>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
18399>>>>>>>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
18399>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
18399>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
18399>>>>>>>>>>>Define DF_DATABASE_TRIM_VARCHAR_VALUES           for 1084
18399>>>>>>>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE              for 1085
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
18399>>>>>>>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
18399>>>>>>>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
18399>>>>>>>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
18399>>>>>>>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
18399>>>>>>>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
18399>>>>>>>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
18399>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
18399>>>>>>>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
18399>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
18399>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
18399>>>>>>>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
18399>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
18399>>>>>>>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
18399>>>>>>>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
18399>>>>>>>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
18399>>>>>>>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
18399>>>>>>>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
18399>>>>>>>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
18399>>>>>>>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
18399>>>>>>>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
18399>>>>>>>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
18399>>>>>>>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
18399>>>>>>>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
18399>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
18399>>>>>>>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
18399>>>>>>>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
18399>>>>>>>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
18399>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
18399>>>>>>>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
18399>>>>>>>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
18399>>>>>>>>>>>Define DF_DRIVER_TRIM_VARCHAR_VALUES             for 1184
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
18399>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Replacement for logical column number that indicates all columns
18399>>>>>>>>>>>Define DF_ALL_COLUMNS for -1
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
18399>>>>>>>>>>>Define RIM_NONE            for 0
18399>>>>>>>>>>>Define RIM_IDENTITY_COLUMN for 1
18399>>>>>>>>>>>Define RIM_DISPENSER_TABLE for 2
18399>>>>>>>>>>>Define RIM_EXTERNAL        for 3
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible DF_FIELD_READ_ONLY values
18399>>>>>>>>>>>Define RO_NO            for 0
18399>>>>>>>>>>>Define RO_IGNORECHANGE  for 1
18399>>>>>>>>>>>Define RO_ACCEPTCHANGE  for 2
18399>>>>>>>>>>>Define RO_ERRORONCHANGE for 3
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
18399>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNICODE     for 11
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible SQL Column type values
18399>>>>>>>>>>>//      SQL Server specific types defined in mssqldrv.pkg
18399>>>>>>>>>>>//      DB2 specific typesm defined in db2_drv.pkg
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define SQL_UNKNOWN_TYPE   for    0
18399>>>>>>>>>>>Define SQL_CHAR           for    1
18399>>>>>>>>>>>Define SQL_NUMERIC        for    2
18399>>>>>>>>>>>Define SQL_DECIMAL        for    3
18399>>>>>>>>>>>Define SQL_INTEGER        for    4
18399>>>>>>>>>>>Define SQL_SMALLINT       for    5
18399>>>>>>>>>>>Define SQL_FLOAT          for    6
18399>>>>>>>>>>>Define SQL_REAL           for    7
18399>>>>>>>>>>>Define SQL_DOUBLE         for    8
18399>>>>>>>>>>>Define SQL_DATETIME       for    9
18399>>>>>>>>>>>Define SQL_VARCHAR        for   12
18399>>>>>>>>>>>Define SQL_TYPE_DATE      for   91
18399>>>>>>>>>>>Define SQL_TYPE_TIME      for   92
18399>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
18399>>>>>>>>>>>
18399>>>>>>>>>>>Define SQL_DATE           for    9
18399>>>>>>>>>>>Define SQL_INTERVAL       for   10
18399>>>>>>>>>>>Define SQL_TIME           for   10
18399>>>>>>>>>>>Define SQL_TIMESTAMP      for   11
18399>>>>>>>>>>>Define SQL_LONGVARCHAR    for  (-1)
18399>>>>>>>>>>>Define SQL_BINARY         for  (-2)
18399>>>>>>>>>>>Define SQL_VARBINARY      for  (-3)
18399>>>>>>>>>>>Define SQL_LONGVARBINARY  for  (-4)
18399>>>>>>>>>>>Define SQL_BIGINT         for  (-5)
18399>>>>>>>>>>>Define SQL_TINYINT        for  (-6)
18399>>>>>>>>>>>Define SQL_BIT            for  (-7)
18399>>>>>>>>>>>Define SQL_WCHAR          for  (-8)
18399>>>>>>>>>>>Define SQL_WVARCHAR       for  (-9)
18399>>>>>>>>>>>Define SQL_WLONGVARCHAR   for (-10)
18399>>>>>>>>>>>Define SQL_GUID           for (-11)
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible DF_INDEX_SQL_TYPE values
18399>>>>>>>>>>>Define DF_INDEX_CLIENT      for  1
18399>>>>>>>>>>>Define DF_INDEX_SERVER      for  2
18399>>>>>>>>>>>Define DF_INDEX_SERVER_ONLY for  3
18399>>>>>>>>>>>Define DF_INDEX_TEMPORARY   for  4
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
18399>>>>>>>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
18399>>>>>>>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
18399>>>>>>>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Driver level attributes
18399>>>>>>>>>>>Define DRVR_TOKEN_BASE                       for 1000
18399>>>>>>>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
18399>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
18399>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
18399>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
18399>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
18399>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
18399>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
18399>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
18399>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
18399>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
18399>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
18399>>>>>>>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
18399>>>>>>>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
18399>>>>>>>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
18399>>>>>>>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
18399>>>>>>>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
18399>>>>>>>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
18399>>>>>>>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
18399>>>>>>>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
18399>>>>>>>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
18399>>>>>>>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
18399>>>>>>>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
18399>>>>>>>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
18399>>>>>>>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
18399>>>>>>>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
18399>>>>>>>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
18399>>>>>>>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
18399>>>>>>>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
18399>>>>>>>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
18399>>>>>>>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Error Number constants
18399>>>>>>>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
18399>>>>>>>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
18399>>>>>>>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
18399>>>>>>>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
18399>>>>>>>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
18399>>>>>>>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
18399>>>>>>>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
18399>>>>>>>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
18399>>>>>>>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
18399>>>>>>>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
18399>>>>>>>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
18399>>>>>>>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
18399>>>>>>>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
18399>>>>>>>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
18399>>>>>>>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
18399>>>>>>>>>>>Define CLIERR_SQL_ERROR                           for 12304
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
18399>>>>>>>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
18399>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
18399>>>>>>>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
18399>>>>>>>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
18399>>>>>>>>>>>Define CLIERR_FIELDREADONLY                       for 12315
18399>>>>>>>>>>>Define CLIERR_DBPROPERROR                         for 12316
18399>>>>>>>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
18399>>>>>>>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
18399>>>>>>>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
18399>>>>>>>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
18399>>>>>>>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
18399>>>>>>>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
18399>>>>>>>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
18399>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
18399>>>>>>>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
18399>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
18399>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
18399>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
18399>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
18399>>>>>>>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
18399>>>>>>>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
18399>>>>>>>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
18399>>>>>>>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
18399>>>>>>>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
18399>>>>>>>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
18399>>>>>>>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
18399>>>>>>>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
18399>>>>>>>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
18399>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
18399>>>>>>>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
18399>>>>>>>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
18399>>>>>>>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
18399>>>>>>>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
18399>>>>>>>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
18399>>>>>>>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Call driver Function identifiers
18399>>>>>>>>>>>Define CLI_CONSTRAINT             for 10000
18399>>>>>>>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
18399>>>>>>>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
18399>>>>>>>>>>>Define CLI_BROWSECONNECT          for 10003
18399>>>>>>>>>>>Define CLI_DATASOURCES            for 10004
18399>>>>>>>>>>>Define CLI_CKREVISION             for 10005
18399>>>>>>>>>>>Define CLI_INITDATASOURCES        for 10006
18399>>>>>>>>>>>Define CLI_ENUMERATE_TABLES       for 10007
18399>>>>>>>>>>>Define CLI_TABLENAME              for 10008
18399>>>>>>>>>>>Define CLI_TABLESCHEMA            for 10009
18399>>>>>>>>>>>Define CLI_TABLETYPE              for 10010
18399>>>>>>>>>>>Define CLI_TABLECOMMENT           for 10011
18399>>>>>>>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
18399>>>>>>>>>>>Define CLI_COLUMNNAME             for 10013
18399>>>>>>>>>>>Define CLI_DUMPSTATUS             for 10014
18399>>>>>>>>>>>Define CLI_READCONFIGURATION      for 10015
18399>>>>>>>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
18399>>>>>>>>>>>Define CLI_GETDBATTRIBUTE         for 10017
18399>>>>>>>>>>>Define CLI_GETREGNAME             for 10018
18399>>>>>>>>>>>Define CLI_GETSERIALNUM           for 10019
18399>>>>>>>>>>>Define CLI_GETMAXUSERS            for 10020
18399>>>>>>>>>>>Define CLI_BCP                    for 10021
18399>>>>>>>>>>>Define CLI_DROPINDICES            for 10022
18399>>>>>>>>>>>Define CLI_CREATEINDICES          for 10023
18399>>>>>>>>>>>Define CLI_REDIRECTCONNECTION     for 10024
18399>>>>>>>>>>>Define CLI_CREATECONNECTIONID     for 10025
18399>>>>>>>>>>>Define CLI_DELETECONNECTIONID     for 10026
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Init data source types
18399>>>>>>>>>>>Define SQL_FETCH_ALL     for  2
18399>>>>>>>>>>>Define SQL_FETCH_USER    for 31
18399>>>>>>>>>>>Define SQL_FETCH_SYSTEM  for 32
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Dummy strings used in the commands
18399>>>>>>>>>>>String  CLI$StrDummy 255
18399>>>>>>>>>>>Integer CLI$IntDummy
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>//   Setup a constraint for a file.                                    
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// Set or get an attribute at driver level. These attributes, when set,
18399>>>>>>>>>>>// will be set for the remainder of the session or until set again. To 
18399>>>>>>>>>>>// permanently set driver level attributes change the driver           
18399>>>>>>>>>>>// configuration file.                                                 
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>
18399>>>>>>>>>>>// An instance of this class can be used as a broker object to
18399>>>>>>>>>>>// call several CLI releated methods.                         
18399>>>>>>>>>>>
18399>>>>>>>>>>>//Class cCLIHandler is a cObject
18399>>>>>>>>>>>Class cCLIHandler is an Array
18400>>>>>>>>>>>    
18400>>>>>>>>>>>    Procedure Construct_Object 
18402>>>>>>>>>>>        Forward Send Construct_object 
18404>>>>>>>>>>>        
18404>>>>>>>>>>>        Property String  psDriverID        ""
18405>>>>>>>>>>>    End_Procedure
18406>>>>>>>>>>>    
18406>>>>>>>>>>>    
18406>>>>>>>>>>>    
18406>>>>>>>>>>>    // The revsion of a CLI Connectivity Kit
18406>>>>>>>>>>>    Function CKRevision Returns String
18408>>>>>>>>>>>        String  sDriverID
18408>>>>>>>>>>>        String  sRevision
18408>>>>>>>>>>>        String  sVoid
18408>>>>>>>>>>>        Integer iRetval
18408>>>>>>>>>>>        
18408>>>>>>>>>>>        Get psDriverID to sDriverID
18409>>>>>>>>>>>        If (sDRiverID <> "") Begin
18411>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRevision
18412>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
18417>>>>>>>>>>>        End
18417>>>>>>>>>>>>
18417>>>>>>>>>>>        
18417>>>>>>>>>>>        Function_Return sRevision
18418>>>>>>>>>>>    End_Function
18419>>>>>>>>>>>    
18419>>>>>>>>>>>    
18419>>>>>>>>>>>    
18419>>>>>>>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
18419>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
18419>>>>>>>>>>>    //
18419>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
18421>>>>>>>>>>>        Integer iPartRev
18421>>>>>>>>>>>        Integer iCurrentPart
18421>>>>>>>>>>>        Integer iSeparatorPos
18421>>>>>>>>>>>        
18421>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
18424>>>>>>>>>>>        
18424>>>>>>>>>>>        Move 0 to iCurrentPart
18425>>>>>>>>>>>        Repeat
18425>>>>>>>>>>>>
18425>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
18426>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
18428>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
18429>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
18430>>>>>>>>>>>                Increment iCurrentPart
18431>>>>>>>>>>>            End
18431>>>>>>>>>>>>
18431>>>>>>>>>>>            Else If (sRevision <> "") Begin
18434>>>>>>>>>>>                Move sRevision to iPartRev
18435>>>>>>>>>>>                Move "" to sRevision
18436>>>>>>>>>>>                Increment iCurrentPart
18437>>>>>>>>>>>            End
18437>>>>>>>>>>>>
18437>>>>>>>>>>>            Else ;                Move -1 to iPartRev
18439>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
18441>>>>>>>>>>>        
18441>>>>>>>>>>>        Function_Return iPartRev
18442>>>>>>>>>>>    End_Function
18443>>>>>>>>>>>    
18443>>>>>>>>>>>    
18443>>>>>>>>>>>    
18443>>>>>>>>>>>    // Returns the major revision of the CK
18443>>>>>>>>>>>    //
18443>>>>>>>>>>>    Function CKMajorRevision Returns Integer
18445>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
18446>>>>>>>>>>>    End_Function
18447>>>>>>>>>>>    
18447>>>>>>>>>>>    
18447>>>>>>>>>>>    
18447>>>>>>>>>>>    // Returns the minor revision of the CK
18447>>>>>>>>>>>    //
18447>>>>>>>>>>>    Function CKMinorRevision Returns Integer
18449>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
18450>>>>>>>>>>>    End_Function
18451>>>>>>>>>>>    
18451>>>>>>>>>>>    
18451>>>>>>>>>>>    
18451>>>>>>>>>>>    // Returns the release revision of the CK
18451>>>>>>>>>>>    //
18451>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
18453>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
18454>>>>>>>>>>>    End_Function
18455>>>>>>>>>>>    
18455>>>>>>>>>>>    
18455>>>>>>>>>>>    
18455>>>>>>>>>>>    // Returns the major revision of the CK
18455>>>>>>>>>>>    //
18455>>>>>>>>>>>    Function CKBuildRevision Returns Integer
18457>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
18458>>>>>>>>>>>    End_Function
18459>>>>>>>>>>>    
18459>>>>>>>>>>>    
18459>>>>>>>>>>>    
18459>>>>>>>>>>>    // Determines if the CK conforms to a passed minimal revsion.
18459>>>>>>>>>>>    //
18459>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
18461>>>>>>>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
18464>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
18467>>>>>>>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
18470>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
18473>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
18476>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
18480>>>>>>>>>>>            End
18480>>>>>>>>>>>>
18480>>>>>>>>>>>        End
18480>>>>>>>>>>>>
18480>>>>>>>>>>>        
18480>>>>>>>>>>>        Function_Return (False)
18481>>>>>>>>>>>    End_Function
18482>>>>>>>>>>>    
18482>>>>>>>>>>>    
18482>>>>>>>>>>>    
18482>>>>>>>>>>>    // Returns the Connectiivty Kit registration name.
18482>>>>>>>>>>>    //
18482>>>>>>>>>>>    Function RegistrationName Returns String
18484>>>>>>>>>>>        String  sRegistration
18484>>>>>>>>>>>        String  sDRiverId
18484>>>>>>>>>>>        String  sVoid
18484>>>>>>>>>>>        Integer iRetval
18484>>>>>>>>>>>        
18484>>>>>>>>>>>        Get psDriverID to sDriverID
18485>>>>>>>>>>>        If (sDRiverID <> "") Begin
18487>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRegistration
18488>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
18493>>>>>>>>>>>        End
18493>>>>>>>>>>>>
18493>>>>>>>>>>>        
18493>>>>>>>>>>>        Function_Return sRegistration
18494>>>>>>>>>>>    End_Function
18495>>>>>>>>>>>    
18495>>>>>>>>>>>    // Returns the Connectiivty Kit serial number.
18495>>>>>>>>>>>    //
18495>>>>>>>>>>>    Function SerialNumber Returns Integer
18497>>>>>>>>>>>        String  sDRiverId
18497>>>>>>>>>>>        String  sVoid
18497>>>>>>>>>>>        Integer iRetval
18497>>>>>>>>>>>        
18497>>>>>>>>>>>        Get psDriverID to sDriverID
18498>>>>>>>>>>>        If (sDRiverID <> "") Begin
18500>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
18505>>>>>>>>>>>        End
18505>>>>>>>>>>>>
18505>>>>>>>>>>>        
18505>>>>>>>>>>>        Function_Return iRetval
18506>>>>>>>>>>>    End_Function
18507>>>>>>>>>>>    
18507>>>>>>>>>>>    
18507>>>>>>>>>>>    // Returns the Connectiivty Kit maximum number of users.
18507>>>>>>>>>>>    //
18507>>>>>>>>>>>    Function MaxUsers Returns Integer
18509>>>>>>>>>>>        String  sDRiverId
18509>>>>>>>>>>>        String  sVoid
18509>>>>>>>>>>>        Integer iRetval
18509>>>>>>>>>>>        
18509>>>>>>>>>>>        Get psDriverID to sDriverID
18510>>>>>>>>>>>        If (sDRiverID <> "") Begin
18512>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
18517>>>>>>>>>>>        End
18517>>>>>>>>>>>>
18517>>>>>>>>>>>        
18517>>>>>>>>>>>        Function_Return iRetval
18518>>>>>>>>>>>    End_Function
18519>>>>>>>>>>>    
18519>>>>>>>>>>>    
18519>>>>>>>>>>>    
18519>>>>>>>>>>>    // Dump the current status of the drver in the passed disk file.
18519>>>>>>>>>>>    //
18519>>>>>>>>>>>    Procedure DumpStatus String sFileName
18521>>>>>>>>>>>        String  sVoid
18521>>>>>>>>>>>        String  sDriverID
18521>>>>>>>>>>>        Integer iVoid
18521>>>>>>>>>>>        
18521>>>>>>>>>>>        Get psDriverID to sDriverID
18522>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
18529>>>>>>>>>>>    End_Procedure
18530>>>>>>>>>>>    
18530>>>>>>>>>>>    
18530>>>>>>>>>>>    
18530>>>>>>>>>>>    // Reset all driver level configurable attributes to the
18530>>>>>>>>>>>    // default value and then reread the configuration.
18530>>>>>>>>>>>    //
18530>>>>>>>>>>>    Procedure ReadConfiguration
18532>>>>>>>>>>>        String  sVoid
18532>>>>>>>>>>>        String  sDriverID
18532>>>>>>>>>>>        Integer iVoid
18532>>>>>>>>>>>        
18532>>>>>>>>>>>        Get psDriverID to sDriverID
18533>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
18540>>>>>>>>>>>    End_Procedure
18541>>>>>>>>>>>    
18541>>>>>>>>>>>    
18541>>>>>>>>>>>    
18541>>>>>>>>>>>    // Convert a text to the corresponding
18541>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
18541>>>>>>>>>>>    //
18541>>>>>>>>>>>    Function TextToRIMValue String sText Returns Integer
18543>>>>>>>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
18546>>>>>>>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
18550>>>>>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
18554>>>>>>>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
18558>>>>>>>>>>>    End_Function
18559>>>>>>>>>>>    
18559>>>>>>>>>>>    
18559>>>>>>>>>>>    
18559>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
18559>>>>>>>>>>>    // corresponding text.
18559>>>>>>>>>>>    //
18559>>>>>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
18561>>>>>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
18564>>>>>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
18568>>>>>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
18572>>>>>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
18576>>>>>>>>>>>    End_Function
18577>>>>>>>>>>>    
18577>>>>>>>>>>>    
18577>>>>>>>>>>>    
18577>>>>>>>>>>>    // Convert a text to the corresponding
18577>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
18577>>>>>>>>>>>    //
18577>>>>>>>>>>>    Function TextToROValue String sText Returns Integer
18579>>>>>>>>>>>        If (sText = "No") ;            Function_Return RO_NO
18582>>>>>>>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
18586>>>>>>>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
18590>>>>>>>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
18594>>>>>>>>>>>    End_Function
18595>>>>>>>>>>>    
18595>>>>>>>>>>>    
18595>>>>>>>>>>>    
18595>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
18595>>>>>>>>>>>    // corresponding text.
18595>>>>>>>>>>>    //
18595>>>>>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
18597>>>>>>>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
18600>>>>>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
18604>>>>>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
18608>>>>>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
18612>>>>>>>>>>>    End_Function
18613>>>>>>>>>>>    
18613>>>>>>>>>>>    
18613>>>>>>>>>>>    
18613>>>>>>>>>>>    // Return the text f the last error geneated by the driver.
18613>>>>>>>>>>>    //
18613>>>>>>>>>>>    Function LastDriverError Returns String
18615>>>>>>>>>>>        String  sDriverID
18615>>>>>>>>>>>        String  sLastError
18615>>>>>>>>>>>        String  sLastErrorLength
18615>>>>>>>>>>>        Integer iLastErrorLength
18615>>>>>>>>>>>        Integer iVoid
18615>>>>>>>>>>>        
18615>>>>>>>>>>>        // Initialize
18615>>>>>>>>>>>        Move "" to sLastError
18616>>>>>>>>>>>        
18616>>>>>>>>>>>        Get psDriverID to sDriverID
18617>>>>>>>>>>>        If (sDriverID <> "") Begin
18619>>>>>>>>>>>            // Get the text of the last error
18619>>>>>>>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
18620>>>>>>>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
18625>>>>>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
18626>>>>>>>>>>>            
18626>>>>>>>>>>>            If (iLastErrorLength > 0) Begin
18628>>>>>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
18629>>>>>>>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
18634>>>>>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
18635>>>>>>>>>>>            End
18635>>>>>>>>>>>>
18635>>>>>>>>>>>        End
18635>>>>>>>>>>>>
18635>>>>>>>>>>>        
18635>>>>>>>>>>>        Function_Return sLastError
18636>>>>>>>>>>>    End_Function
18637>>>>>>>>>>>    
18637>>>>>>>>>>>    
18637>>>>>>>>>>>    
18637>>>>>>>>>>>    // Enumerate the tables in a database
18637>>>>>>>>>>>    //
18637>>>>>>>>>>>    Function EnumerateTables String sLogin Returns Integer
18639>>>>>>>>>>>        String  sDriver
18639>>>>>>>>>>>        String  sVoid
18639>>>>>>>>>>>        Integer iNumTables
18639>>>>>>>>>>>        Integer iVoid
18639>>>>>>>>>>>        
18639>>>>>>>>>>>        Get psDriverID to sDriver
18640>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
18647>>>>>>>>>>>        
18647>>>>>>>>>>>        Function_Return iNumTables
18648>>>>>>>>>>>    End_Function
18649>>>>>>>>>>>    
18649>>>>>>>>>>>    
18649>>>>>>>>>>>    
18649>>>>>>>>>>>    // Returns the name of the table enumerated at the given position
18649>>>>>>>>>>>    //
18649>>>>>>>>>>>    Function TableName Integer iIndex Returns String
18651>>>>>>>>>>>        String  sDriver
18651>>>>>>>>>>>        String  sTableName
18651>>>>>>>>>>>        String  sVoid
18651>>>>>>>>>>>        Integer iVoid
18651>>>>>>>>>>>        
18651>>>>>>>>>>>        Get psDriverID to sDriver
18652>>>>>>>>>>>        If (sDriver <> "") Begin
18654>>>>>>>>>>>            Move (Repeat(" ", 255)) to sTableName
18655>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
18660>>>>>>>>>>>        End
18660>>>>>>>>>>>>
18660>>>>>>>>>>>        
18660>>>>>>>>>>>        Function_Return sTableName
18661>>>>>>>>>>>    End_Function
18662>>>>>>>>>>>    
18662>>>>>>>>>>>    
18662>>>>>>>>>>>    
18662>>>>>>>>>>>    // Returns the name of the schema of the table enumerated at the given position
18662>>>>>>>>>>>    //
18662>>>>>>>>>>>    Function SchemaName Integer iIndex Returns String
18664>>>>>>>>>>>        String  sDriver
18664>>>>>>>>>>>        String  sSchemaName
18664>>>>>>>>>>>        String  sVoid
18664>>>>>>>>>>>        Integer iVoid
18664>>>>>>>>>>>        
18664>>>>>>>>>>>        Get psDriverID to sDriver
18665>>>>>>>>>>>        If (sDriver <> "") Begin
18667>>>>>>>>>>>            Move (Repeat(" ", 255)) to sSchemaName
18668>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
18673>>>>>>>>>>>        End
18673>>>>>>>>>>>>
18673>>>>>>>>>>>        
18673>>>>>>>>>>>        Function_Return sSchemaName
18674>>>>>>>>>>>    End_Function
18675>>>>>>>>>>>    
18675>>>>>>>>>>>    // Returns the type of the table enumerated at the given position.
18675>>>>>>>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
18675>>>>>>>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
18675>>>>>>>>>>>    Function TableType Integer iIndex Returns String
18677>>>>>>>>>>>        String  sDriver
18677>>>>>>>>>>>        String  sTableType
18677>>>>>>>>>>>        String  sVoid
18677>>>>>>>>>>>        Integer iVoid
18677>>>>>>>>>>>        
18677>>>>>>>>>>>        Get psDriverID to sDriver
18678>>>>>>>>>>>        If (sDriver <> "") Begin
18680>>>>>>>>>>>            Move (Repeat(" ", 25)) to sTableType
18681>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
18686>>>>>>>>>>>        End
18686>>>>>>>>>>>>
18686>>>>>>>>>>>        
18686>>>>>>>>>>>        Function_Return sTableType
18687>>>>>>>>>>>    End_Function
18688>>>>>>>>>>>    
18688>>>>>>>>>>>    
18688>>>>>>>>>>>    // Returns the comment of the table enumerated at the given position
18688>>>>>>>>>>>    //
18688>>>>>>>>>>>    Function TableComment Integer iIndex Returns String
18690>>>>>>>>>>>        String  sDriver
18690>>>>>>>>>>>        String  sTableComment
18690>>>>>>>>>>>        String  sVoid
18690>>>>>>>>>>>        Integer iVoid
18690>>>>>>>>>>>        
18690>>>>>>>>>>>        Get psDriverID to sDriver
18691>>>>>>>>>>>        If (sDriver <> "") Begin
18693>>>>>>>>>>>            Move (Repeat(" ", 1024)) to sTableComment
18694>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
18699>>>>>>>>>>>        End
18699>>>>>>>>>>>>
18699>>>>>>>>>>>        
18699>>>>>>>>>>>        Function_Return sTableComment
18700>>>>>>>>>>>    End_Function
18701>>>>>>>>>>>    
18701>>>>>>>>>>>    // Enumerate the columns in a table
18701>>>>>>>>>>>    //
18701>>>>>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
18703>>>>>>>>>>>        String  sDriver
18703>>>>>>>>>>>        Integer iNumColumns
18703>>>>>>>>>>>        Integer iVoid
18703>>>>>>>>>>>        
18703>>>>>>>>>>>        Get psDriverID to sDriver
18704>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
18711>>>>>>>>>>>        
18711>>>>>>>>>>>        Function_Return iNumColumns
18712>>>>>>>>>>>    End_Function
18713>>>>>>>>>>>    
18713>>>>>>>>>>>    
18713>>>>>>>>>>>    
18713>>>>>>>>>>>    // Returns the name of the column enumerated at the given position
18713>>>>>>>>>>>    //
18713>>>>>>>>>>>    Function ColumnName Integer iIndex Returns String
18715>>>>>>>>>>>        String  sDriver
18715>>>>>>>>>>>        String  sColumnName
18715>>>>>>>>>>>        String  sVoid
18715>>>>>>>>>>>        Integer iVoid
18715>>>>>>>>>>>        
18715>>>>>>>>>>>        Get psDriverID to sDriver
18716>>>>>>>>>>>        If (sDriver <> "") Begin
18718>>>>>>>>>>>            Move (Repeat(" ", 255)) to sColumnName
18719>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
18724>>>>>>>>>>>        End
18724>>>>>>>>>>>>
18724>>>>>>>>>>>        
18724>>>>>>>>>>>        Function_Return sColumnName
18725>>>>>>>>>>>    End_Function
18726>>>>>>>>>>>    
18726>>>>>>>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
18726>>>>>>>>>>>    //
18726>>>>>>>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
18728>>>>>>>>>>>        
18728>>>>>>>>>>>        Integer iDriverIndex
18728>>>>>>>>>>>        
18728>>>>>>>>>>>        String sSQLDate
18728>>>>>>>>>>>        Integer iOrgDateFmt
18728>>>>>>>>>>>        Integer iOrgDateSep
18728>>>>>>>>>>>        
18728>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18728>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18731>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18734>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18737>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18740>>>>>>>>>>>        
18740>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
18742>>>>>>>>>>>            // Return the dummy zero date
18742>>>>>>>>>>>            Get DriverIndex sDriver to iDriverIndex
18743>>>>>>>>>>>            If (iDriverIndex <> 0) Begin
18745>>>>>>>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
18748>>>>>>>>>>>            End
18748>>>>>>>>>>>>
18748>>>>>>>>>>>            Else Begin
18749>>>>>>>>>>>                Move '0001-01-01' to sSQLDate
18750>>>>>>>>>>>            End
18750>>>>>>>>>>>>
18750>>>>>>>>>>>        End
18750>>>>>>>>>>>>
18750>>>>>>>>>>>        Else Begin
18751>>>>>>>>>>>            Move dDFDate to sSQLDate
18752>>>>>>>>>>>        End
18752>>>>>>>>>>>>
18752>>>>>>>>>>>        
18752>>>>>>>>>>>        // Change date format back to original
18752>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18755>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18758>>>>>>>>>>>        
18758>>>>>>>>>>>        Function_Return sSQLDate
18759>>>>>>>>>>>    End_Function
18760>>>>>>>>>>>    
18760>>>>>>>>>>>    
18760>>>>>>>>>>>    
18760>>>>>>>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
18760>>>>>>>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
18762>>>>>>>>>>>        
18762>>>>>>>>>>>        Integer iDriverIndex
18762>>>>>>>>>>>        
18762>>>>>>>>>>>        Date dDFDate
18762>>>>>>>>>>>        String sDummyDateValue
18762>>>>>>>>>>>        Integer iOrgDateFmt
18762>>>>>>>>>>>        Integer iOrgDateSep
18762>>>>>>>>>>>        
18762>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18762>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18765>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18768>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18771>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18774>>>>>>>>>>>        
18774>>>>>>>>>>>        // We only need to convert if the date is the dummy zero date value
18774>>>>>>>>>>>        Get DriverIndex sDriver to iDriverIndex
18775>>>>>>>>>>>        If (iDriverIndex <> 0) Begin
18777>>>>>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
18780>>>>>>>>>>>        End
18780>>>>>>>>>>>>
18780>>>>>>>>>>>        Else Begin
18781>>>>>>>>>>>            Move '0001-01-01' to sDummyDateValue
18782>>>>>>>>>>>        End
18782>>>>>>>>>>>>
18782>>>>>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
18785>>>>>>>>>>>        Else ;            Move sSQLDate to dDFDate
18787>>>>>>>>>>>        
18787>>>>>>>>>>>        // Change date format back to original
18787>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18790>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18793>>>>>>>>>>>        
18793>>>>>>>>>>>        Function_Return dDFDate
18794>>>>>>>>>>>    End_Function
18795>>>>>>>>>>>    
18795>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
18797>>>>>>>>>>>        
18797>>>>>>>>>>>        String  sCurrentDriver
18797>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
18797>>>>>>>>>>>        
18797>>>>>>>>>>>        Move 0 to iDriver
18798>>>>>>>>>>>        
18798>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
18801>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
18807>>>>>>>>>>>>
18807>>>>>>>>>>>            
18807>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
18810>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
18812>>>>>>>>>>>                Move iCount to iDriver
18813>>>>>>>>>>>            End
18813>>>>>>>>>>>>
18813>>>>>>>>>>>        Loop
18814>>>>>>>>>>>>
18814>>>>>>>>>>>        
18814>>>>>>>>>>>        Function_Return iDriver
18815>>>>>>>>>>>        
18815>>>>>>>>>>>    End_Function
18816>>>>>>>>>>>    
18816>>>>>>>>>>>    
18816>>>>>>>>>>>    // Redirect an exisitng connection. The existing connection
18816>>>>>>>>>>>    // will point to another database but all tables will stay
18816>>>>>>>>>>>    // open!
18816>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
18818>>>>>>>>>>>        String  sDriver
18818>>>>>>>>>>>        String  sVoid
18818>>>>>>>>>>>        Integer iResult
18818>>>>>>>>>>>        Integer iVoid
18818>>>>>>>>>>>        
18818>>>>>>>>>>>        Get psDriverID to sDriver
18819>>>>>>>>>>>        If (sDriver <> "") Begin
18821>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
18826>>>>>>>>>>>        End
18826>>>>>>>>>>>>
18826>>>>>>>>>>>        Function_Return iResult
18827>>>>>>>>>>>    End_Function
18828>>>>>>>>>>>    
18828>>>>>>>>>>>    // Redirect a connection of a connection ID
18828>>>>>>>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
18828>>>>>>>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
18828>>>>>>>>>>>    //
18828>>>>>>>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
18828>>>>>>>>>>>    // to the new connection (Server/Database specified in sConnectString)
18828>>>>>>>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
18828>>>>>>>>>>>    //
18828>>>>>>>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
18828>>>>>>>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
18828>>>>>>>>>>>    //
18828>>>>>>>>>>>    // Returns:
18828>>>>>>>>>>>    //     0 when the redirection was successful.
18828>>>>>>>>>>>    //     1 if the connection ID does not exist or can not be found.
18828>>>>>>>>>>>    //     2 login into the new connection failed.
18828>>>>>>>>>>>    //
18828>>>>>>>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
18830>>>>>>>>>>>        String  sDriver
18830>>>>>>>>>>>        String  sVoid
18830>>>>>>>>>>>        Integer iResult
18830>>>>>>>>>>>        
18830>>>>>>>>>>>        Integer iOption
18830>>>>>>>>>>>        
18830>>>>>>>>>>>        // iOption
18830>>>>>>>>>>>        // 0 = RedirectConnection
18830>>>>>>>>>>>        // 1 = RedirectIdConnectString
18830>>>>>>>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
18830>>>>>>>>>>>        If (bKeepLoggedIn) Begin
18832>>>>>>>>>>>            Move 2 to iOption
18833>>>>>>>>>>>        End
18833>>>>>>>>>>>>
18833>>>>>>>>>>>        Else Begin
18834>>>>>>>>>>>            Move 1 to iOption
18835>>>>>>>>>>>        End
18835>>>>>>>>>>>>
18835>>>>>>>>>>>        
18835>>>>>>>>>>>        Get psDriverID to sDriver
18836>>>>>>>>>>>        If (sDriver <> "") Begin
18838>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
18843>>>>>>>>>>>        End
18843>>>>>>>>>>>>
18843>>>>>>>>>>>        Function_Return iResult
18844>>>>>>>>>>>    End_Function
18845>>>>>>>>>>>    
18845>>>>>>>>>>>    
18845>>>>>>>>>>>    // Create a DataFlex side connection id that can be used later on.
18845>>>>>>>>>>>    //
18845>>>>>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
18847>>>>>>>>>>>        String  sDriver
18847>>>>>>>>>>>        Integer iResult
18847>>>>>>>>>>>        Integer iOptions
18847>>>>>>>>>>>        
18847>>>>>>>>>>>        Get psDriverID to sDriver
18848>>>>>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
18851>>>>>>>>>>>        Else ;            Move iOpt to iOptions
18853>>>>>>>>>>>        If (sDriver <> "") Begin
18855>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
18860>>>>>>>>>>>        End
18860>>>>>>>>>>>>
18860>>>>>>>>>>>        Function_Return iResult
18861>>>>>>>>>>>    End_Function
18862>>>>>>>>>>>    
18862>>>>>>>>>>>    
18862>>>>>>>>>>>    
18862>>>>>>>>>>>    // Delete a DataFlex side connection id.
18862>>>>>>>>>>>    //
18862>>>>>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
18864>>>>>>>>>>>        String  sDriver
18864>>>>>>>>>>>        Integer iResult
18864>>>>>>>>>>>        String sVoid
18864>>>>>>>>>>>        
18864>>>>>>>>>>>        Get psDriverID to sDriver
18865>>>>>>>>>>>        If (sDriver <> "") Begin
18867>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
18872>>>>>>>>>>>        End
18872>>>>>>>>>>>>
18872>>>>>>>>>>>        Function_Return iResult
18873>>>>>>>>>>>    End_Function
18874>>>>>>>>>>>    
18874>>>>>>>>>>>End_Class
18875>>>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files\DataFlex 20.1\Pkg\sql.pkg)
18875>>>>>>>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
18875>>>>>>>>>>>// Connectivty Kits.                                              
18875>>>>>>>>>>>Use CLI.pkg
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Global storage for results
18875>>>>>>>>>>>Integer SQLResult
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Embedded SQL function constants
18875>>>>>>>>>>>Define FUNC_SQLCONNECT             for 1000000
18875>>>>>>>>>>>Define FUNC_SQLFILECONNECT         for 1000001
18875>>>>>>>>>>>Define FUNC_SQLDISCONNECT          for 1000002
18875>>>>>>>>>>>Define FUNC_SQLOPEN                for 1000003
18875>>>>>>>>>>>Define FUNC_SQLCLOSE               for 1000004
18875>>>>>>>>>>>Define FUNC_SQLPREPARE             for 1000005
18875>>>>>>>>>>>Define FUNC_SQLEXECUTE             for 1000006
18875>>>>>>>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
18875>>>>>>>>>>>Define FUNC_SQLFETCH               for 1000008
18875>>>>>>>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
18875>>>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
18875>>>>>>>>>>>Define FUNC_SQLBINDFILE            for 1000011
18875>>>>>>>>>>>Define FUNC_SQLGETDATA             for 1000012
18875>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
18875>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
18875>>>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
18875>>>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
18875>>>>>>>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
18875>>>>>>>>>>>Define FUNC_SQLSETPROCARG          for 1000018
18875>>>>>>>>>>>Define FUNC_SQLCALL                for 1000019
18875>>>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
18875>>>>>>>>>>>Define FUNC_SQLGETPROCARG          for 1000021
18875>>>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
18875>>>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
18875>>>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
18875>>>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
18875>>>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
18875>>>>>>>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
18875>>>>>>>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Embedded SQL statement attribute constants
18875>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
18875>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
18875>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
18875>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
18875>>>>>>>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
18875>>>>>>>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
18875>>>>>>>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
18875>>>>>>>>>>>Define SQL_CURSOR_DYNAMIC           for 2
18875>>>>>>>>>>>Define SQL_CURSOR_STATIC            for 3
18875>>>>>>>>>>>
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Embedded SQL column attribute constants
18875>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
18875>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
18875>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
18875>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
18875>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
18875>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
18875>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
18875>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
18875>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
18875>>>>>>>>>>>
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Types used for conversion with ConvertToXml
18875>>>>>>>>>>>Define esqlTime      for 8
18875>>>>>>>>>>>Define esqlDatetime  for 9
18875>>>>>>>>>>>
18875>>>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
18875>>>>>>>>>>>Integer giLastSQLhdbc
18875>>>>>>>>>>>Integer giLastSQLhstmt
18875>>>>>>>>>>>
18875>>>>>>>>>>>Move -1 to giLastSQLhdbc
18876>>>>>>>>>>>Move -1 to giLastSQLhstmt
18877>>>>>>>>>>>
18877>>>>>>>>>>>Struct tSQLColumn
18877>>>>>>>>>>>    Integer iSQLType
18877>>>>>>>>>>>    Integer iSQLSize
18877>>>>>>>>>>>    Integer iSQLPrecision
18877>>>>>>>>>>>    Integer iVariableDataType
18877>>>>>>>>>>>End_Struct
18877>>>>>>>>>>>
18877>>>>>>>>>>>// Statement object for embedded sql                           
18877>>>>>>>>>>>//   An object is created for each statement. These will be children    
18877>>>>>>>>>>>//   of cSQLConnection objects which manage the create and destruction  
18877>>>>>>>>>>>//   of these.                                                          
18877>>>>>>>>>>>
18877>>>>>>>>>>>Class cSQLStatement is a cObject
18878>>>>>>>>>>>    
18878>>>>>>>>>>>    Procedure Construct_object
18880>>>>>>>>>>>        Forward Send Construct_object
18882>>>>>>>>>>>        
18882>>>>>>>>>>>        Property Handle  phCLIStatementHandle   0
18883>>>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
18884>>>>>>>>>>>        Property String  psDriverID             ""
18885>>>>>>>>>>>        
18885>>>>>>>>>>>        Property Integer piLastColumn      0
18886>>>>>>>>>>>        Property Integer piLastArgument    0
18887>>>>>>>>>>>        Property Integer piBindFile        0
18888>>>>>>>>>>>        
18888>>>>>>>>>>>        Property Integer piColumnCount     0
18889>>>>>>>>>>>        
18889>>>>>>>>>>>        // True if there is at least 1 column with a variable length data type
18889>>>>>>>>>>>        Property Integer piHasVariableDataType  0
18890>>>>>>>>>>>        
18890>>>>>>>>>>>        // Max size of buffer for variable length data. Default 16000
18890>>>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000
18891>>>>>>>>>>>        
18891>>>>>>>>>>>        // Allocated buffer for SQLGetData.
18891>>>>>>>>>>>        Property WString psVariableBuffer  ""
18892>>>>>>>>>>>        
18892>>>>>>>>>>>        // Allocated size of psVariableBuffer
18892>>>>>>>>>>>        Property Integer piVariableBufferLength 0
18893>>>>>>>>>>>        
18893>>>>>>>>>>>        // Stores column properties of a result set.
18893>>>>>>>>>>>        Property tSQLColumn[] paSQLColumns
18894>>>>>>>>>>>        
18894>>>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
18894>>>>>>>>>>>        //   0    = Fetch returned no data.
18894>>>>>>>>>>>        //   <> 0 = Row fetched
18894>>>>>>>>>>>        Property Integer piFetchResult     0
18895>>>>>>>>>>>        
18895>>>>>>>>>>>        
18895>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
18896>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
18897>>>>>>>>>>>        
18897>>>>>>>>>>>    End_Procedure
18898>>>>>>>>>>>    
18898>>>>>>>>>>>    // Store basic information about the statement.
18898>>>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
18900>>>>>>>>>>>        
18900>>>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
18901>>>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
18902>>>>>>>>>>>        Set psDriverID             to sDrvrId
18903>>>>>>>>>>>        
18903>>>>>>>>>>>    End_Procedure
18904>>>>>>>>>>>    
18904>>>>>>>>>>>    
18904>>>>>>>>>>>    // Destroy the cSQLStatement object
18904>>>>>>>>>>>    Procedure DestroySQLStatement
18906>>>>>>>>>>>        Send Destroy
18907>>>>>>>>>>>    End_Procedure
18908>>>>>>>>>>>    
18908>>>>>>>>>>>    // Handle an error that has occurred while checking properties.
18908>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
18910>>>>>>>>>>>        Integer iErrHandle
18910>>>>>>>>>>>        Integer iErrNum
18910>>>>>>>>>>>        String  sLocationInfo
18910>>>>>>>>>>>        
18910>>>>>>>>>>>        // Get the DataFlex statement identifier
18910>>>>>>>>>>>        Move Self to iErrHandle
18911>>>>>>>>>>>        
18911>>>>>>>>>>>        // Determine error number
18911>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
18914>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
18918>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
18922>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
18924>>>>>>>>>>>        
18924>>>>>>>>>>>        // Create location ifnormation
18924>>>>>>>>>>>        Move "[" to sLocationInfo
18925>>>>>>>>>>>        If (sOriginMsg <> "") Begin
18927>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
18928>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
18929>>>>>>>>>>>        End
18929>>>>>>>>>>>>
18929>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
18930>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
18931>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
18932>>>>>>>>>>>        
18932>>>>>>>>>>>        // Generate the error
18932>>>>>>>>>>>        Error iErrNum sLocationInfo
18933>>>>>>>>>>>>
18933>>>>>>>>>>>    End_Procedure
18934>>>>>>>>>>>    
18934>>>>>>>>>>>    // Handle general error not related to the properties
18934>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
18936>>>>>>>>>>>        Integer iErrHandle
18936>>>>>>>>>>>        String  sLocationInfo
18936>>>>>>>>>>>        
18936>>>>>>>>>>>        // Get the DataFlex statement identifier
18936>>>>>>>>>>>        Move Self to iErrHandle
18937>>>>>>>>>>>        
18937>>>>>>>>>>>        // Create location information
18937>>>>>>>>>>>        Move "[" to sLocationInfo
18938>>>>>>>>>>>        If (sOriginMsg <> "") Begin
18940>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
18941>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
18942>>>>>>>>>>>        End
18942>>>>>>>>>>>>
18942>>>>>>>>>>>        If (sErrtext <> "") Begin
18944>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
18945>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
18946>>>>>>>>>>>        End
18946>>>>>>>>>>>>
18946>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
18947>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
18948>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
18949>>>>>>>>>>>        
18949>>>>>>>>>>>        // Generate the error
18949>>>>>>>>>>>        Error iErrNum sLocationInfo
18950>>>>>>>>>>>>
18950>>>>>>>>>>>    End_Procedure
18951>>>>>>>>>>>    
18951>>>>>>>>>>>    // Handle an illegal attribute error
18951>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
18953>>>>>>>>>>>        Integer bReport
18953>>>>>>>>>>>        
18953>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
18956>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
18959>>>>>>>>>>>    End_Procedure
18960>>>>>>>>>>>    
18960>>>>>>>>>>>    // Check if a column number is legal
18960>>>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
18962>>>>>>>>>>>        Integer bLegal
18962>>>>>>>>>>>        Integer iNumColumns
18962>>>>>>>>>>>        
18962>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
18963>>>>>>>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
18966>>>>>>>>>>>        Else ;            Move DFFALSE to bLegal
18968>>>>>>>>>>>        
18968>>>>>>>>>>>        Function_Return bLegal
18969>>>>>>>>>>>    End_Function
18970>>>>>>>>>>>    
18970>>>>>>>>>>>    
18970>>>>>>>>>>>    
18970>>>>>>>>>>>    // Close a statement and free all alllocated resources
18970>>>>>>>>>>>    Procedure SQLClose
18972>>>>>>>>>>>        Integer ihdbc
18972>>>>>>>>>>>        Integer ihstmt
18972>>>>>>>>>>>        Integer iVoid
18972>>>>>>>>>>>        String  sDrvrId
18972>>>>>>>>>>>        String  sEmpty
18972>>>>>>>>>>>        
18972>>>>>>>>>>>        // Initialize
18972>>>>>>>>>>>        Move "" to sEmpty
18973>>>>>>>>>>>        
18973>>>>>>>>>>>        // Get the cli handles
18973>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18974>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18975>>>>>>>>>>>        Get psDriverId            to sDrvrId
18976>>>>>>>>>>>        
18976>>>>>>>>>>>        // Free the CLI handle
18976>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18978>>>>>>>>>>>            // Call the driver function to close
18978>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
18983>>>>>>>>>>>            
18983>>>>>>>>>>>            Move -1 to giLastSQLhstmt
18984>>>>>>>>>>>            // Free the DataFlex handle
18984>>>>>>>>>>>            Send DestroySQLStatement
18985>>>>>>>>>>>        End
18985>>>>>>>>>>>>
18985>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
18987>>>>>>>>>>>    End_Procedure
18988>>>>>>>>>>>    
18988>>>>>>>>>>>    // Prepare a statement for execution
18988>>>>>>>>>>>    Procedure SQLPrepare String sStatement
18990>>>>>>>>>>>        Integer ihdbc
18990>>>>>>>>>>>        Integer ihstmt
18990>>>>>>>>>>>        Integer iVoid
18990>>>>>>>>>>>        String  sDrvrId
18990>>>>>>>>>>>        
18990>>>>>>>>>>>        // Get the cli handles
18990>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18991>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18992>>>>>>>>>>>        Get psDriverId            to sDrvrId
18993>>>>>>>>>>>        
18993>>>>>>>>>>>        // Prepare
18993>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18995>>>>>>>>>>>            // Call the driver function to prepare
18995>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
19000>>>>>>>>>>>            Set piLastArgument to 0
19001>>>>>>>>>>>
19001>>>>>>>>>>>        End
19001>>>>>>>>>>>>
19001>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
19003>>>>>>>>>>>    End_Procedure
19004>>>>>>>>>>>    
19004>>>>>>>>>>>    Procedure SQLGetStatementAttributes
19006>>>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
19006>>>>>>>>>>>        String sMaxValue
19006>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19006>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19007>>>>>>>>>>>        
19007>>>>>>>>>>>        Integer iSqlType
19007>>>>>>>>>>>        Integer iSQLSize
19007>>>>>>>>>>>        Integer iSQLprecision
19007>>>>>>>>>>>        Integer iVariableDataType
19007>>>>>>>>>>>        
19007>>>>>>>>>>>        String  sDrvrId
19007>>>>>>>>>>>        
19007>>>>>>>>>>>        Integer iHasVariableDataType
19007>>>>>>>>>>>        
19007>>>>>>>>>>>        Move 0 to iHasVariableDataType
19008>>>>>>>>>>>        
19008>>>>>>>>>>>        
19008>>>>>>>>>>>        // Get the cli handles
19008>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19009>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19010>>>>>>>>>>>        Get psDriverId            to sDrvrId
19011>>>>>>>>>>>        
19011>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19012>>>>>>>>>>>        
19012>>>>>>>>>>>        Set piColumnCount to iNumColumns
19013>>>>>>>>>>>        
19013>>>>>>>>>>>        // Fill columns array
19013>>>>>>>>>>>        For iCol from 1 to iNumColumns
19019>>>>>>>>>>>>
19019>>>>>>>>>>>            Move 0 to iVariableDataType
19020>>>>>>>>>>>            
19020>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
19021>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
19022>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
19023>>>>>>>>>>>            
19023>>>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
19025>>>>>>>>>>>                // text type
19025>>>>>>>>>>>                Move 1 to iVariableDataType
19026>>>>>>>>>>>            End
19026>>>>>>>>>>>>
19026>>>>>>>>>>>            Else Begin
19027>>>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
19029>>>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
19029>>>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
19031>>>>>>>>>>>                        
19031>>>>>>>>>>>                        Move 1 to iVariableDataType
19032>>>>>>>>>>>                    End
19032>>>>>>>>>>>>
19032>>>>>>>>>>>                End
19032>>>>>>>>>>>>
19032>>>>>>>>>>>            End
19032>>>>>>>>>>>>
19032>>>>>>>>>>>            
19032>>>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
19033>>>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
19034>>>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
19035>>>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
19036>>>>>>>>>>>            
19036>>>>>>>>>>>            If (not(iVariableDataType)) Begin
19038>>>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
19040>>>>>>>>>>>                    Move iSQLSize to iMaxSize
19041>>>>>>>>>>>                End
19041>>>>>>>>>>>>
19041>>>>>>>>>>>            End
19041>>>>>>>>>>>>
19041>>>>>>>>>>>            Else Begin
19042>>>>>>>>>>>                Move 1 to iHasVariableDataType
19043>>>>>>>>>>>            End
19043>>>>>>>>>>>>
19043>>>>>>>>>>>            
19043>>>>>>>>>>>        Loop
19044>>>>>>>>>>>>
19044>>>>>>>>>>>        
19044>>>>>>>>>>>        Set paSQLColumns   to aSQLColumns
19045>>>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
19046>>>>>>>>>>>        
19046>>>>>>>>>>>    End_Procedure
19047>>>>>>>>>>>    
19047>>>>>>>>>>>    // Execute a prepared statement
19047>>>>>>>>>>>    Procedure SQLExecute
19049>>>>>>>>>>>        Integer ihdbc
19049>>>>>>>>>>>        Integer ihstmt
19049>>>>>>>>>>>        Integer iVoid
19049>>>>>>>>>>>        String  sDrvrId
19049>>>>>>>>>>>        String  sEmpty
19049>>>>>>>>>>>        
19049>>>>>>>>>>>        // Initialize
19049>>>>>>>>>>>        Move "" to sEmpty
19050>>>>>>>>>>>        
19050>>>>>>>>>>>        // Get the cli handles
19050>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19051>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19052>>>>>>>>>>>        Get psDriverId            to sDrvrId
19053>>>>>>>>>>>        
19053>>>>>>>>>>>        // Execute
19053>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19055>>>>>>>>>>>            // Call the driver function to execute
19055>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
19060>>>>>>>>>>>            Send SQLGetStatementAttributes
19061>>>>>>>>>>>            Set piLastArgument to 0
19062>>>>>>>>>>>        End
19062>>>>>>>>>>>>
19062>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
19064>>>>>>>>>>>    End_Procedure
19065>>>>>>>>>>>    
19065>>>>>>>>>>>    
19065>>>>>>>>>>>    
19065>>>>>>>>>>>    // Prepare and execute a statement
19065>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
19067>>>>>>>>>>>        Integer ihdbc
19067>>>>>>>>>>>        Integer ihstmt
19067>>>>>>>>>>>        Integer iVoid
19067>>>>>>>>>>>        String  sDrvrId
19067>>>>>>>>>>>        
19067>>>>>>>>>>>        // Get the cli handles
19067>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19068>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19069>>>>>>>>>>>        Get psDriverId            to sDrvrId
19070>>>>>>>>>>>        
19070>>>>>>>>>>>        // ExecDirect
19070>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19072>>>>>>>>>>>            // Call the driver function to execdirect
19072>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
19077>>>>>>>>>>>            Send SQLGetStatementAttributes
19078>>>>>>>>>>>        End
19078>>>>>>>>>>>>
19078>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
19080>>>>>>>>>>>    End_Procedure
19081>>>>>>>>>>>    
19081>>>>>>>>>>>    // Fetch the next row
19081>>>>>>>>>>>    // Returns  : 0   = No more data
19081>>>>>>>>>>>    //<>0 = Success
19081>>>>>>>>>>>    Function SQLFetch Returns Integer
19083>>>>>>>>>>>        Integer ihdbc
19083>>>>>>>>>>>        Integer ihstmt
19083>>>>>>>>>>>        Integer iResult
19083>>>>>>>>>>>        String  sDrvrId
19083>>>>>>>>>>>        String  sEmpty
19083>>>>>>>>>>>        
19083>>>>>>>>>>>        // Initialize
19083>>>>>>>>>>>        Move "" to sEmpty
19084>>>>>>>>>>>        Move 0  to iResult
19085>>>>>>>>>>>        
19085>>>>>>>>>>>        // Get the cli handles
19085>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19086>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19087>>>>>>>>>>>        Get psDriverId            to sDrvrId
19088>>>>>>>>>>>        
19088>>>>>>>>>>>        // Fetch
19088>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19090>>>>>>>>>>>            Move False to Err
19091>>>>>>>>>>>            
19091>>>>>>>>>>>            // Call the driver function to fetch
19091>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19096>>>>>>>>>>>            
19096>>>>>>>>>>>            // If something went wrong, adjust the result
19096>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
19099>>>>>>>>>>>            
19099>>>>>>>>>>>            Set piLastcolumn to 0
19100>>>>>>>>>>>        End
19100>>>>>>>>>>>>
19100>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
19102>>>>>>>>>>>        
19102>>>>>>>>>>>        Function_Return iResult
19103>>>>>>>>>>>    End_Function
19104>>>>>>>>>>>    
19104>>>>>>>>>>>    // Fetch the next row and return an array with all column values
19104>>>>>>>>>>>    // Returns  : Array of strings with all column values
19104>>>>>>>>>>>    // Sets piFetchResult property
19104>>>>>>>>>>>    //   0    = No more data
19104>>>>>>>>>>>    //   <> 0 = Success
19104>>>>>>>>>>>    Function SQLFetchRowValues Returns String[]
19106>>>>>>>>>>>        
19106>>>>>>>>>>>        String[] asValues
19107>>>>>>>>>>>        
19107>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19107>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19108>>>>>>>>>>>        
19108>>>>>>>>>>>        Integer ihdbc
19108>>>>>>>>>>>        Integer ihstmt
19108>>>>>>>>>>>        Integer iResult iVoid
19108>>>>>>>>>>>        Integer iColCount iCol
19108>>>>>>>>>>>        String  sDrvrId
19108>>>>>>>>>>>        String  sEmpty
19108>>>>>>>>>>>        Longptr pResultWStr
19108>>>>>>>>>>>        WString wVariableResult
19108>>>>>>>>>>>        Integer iHasVariableDataType
19108>>>>>>>>>>>        Integer iLen
19108>>>>>>>>>>>        Integer iVariableBufferLength
19108>>>>>>>>>>>        
19108>>>>>>>>>>>        // Initialize
19108>>>>>>>>>>>        Move "" to sEmpty
19109>>>>>>>>>>>        Move 0  to iResult
19110>>>>>>>>>>>        
19110>>>>>>>>>>>        // Get the cli handles
19110>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19111>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19112>>>>>>>>>>>        Get psDriverId            to sDrvrId
19113>>>>>>>>>>>        
19113>>>>>>>>>>>        Get paSQLColumns to aSQLColumns
19114>>>>>>>>>>>        Get piColumnCount to iColCount
19115>>>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
19116>>>>>>>>>>>        
19116>>>>>>>>>>>        If (iHasVariableDataType) Begin
19118>>>>>>>>>>>            
19118>>>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
19119>>>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
19120>>>>>>>>>>>            
19120>>>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
19122>>>>>>>>>>>                // Allocate
19122>>>>>>>>>>>                Move (Repeat(' ', iLen)) to wVariableResult
19123>>>>>>>>>>>                
19123>>>>>>>>>>>                Set piVariableBufferLength to iLen
19124>>>>>>>>>>>                Set psVariableBuffer       to wVariableResult
19125>>>>>>>>>>>                
19125>>>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength
19126>>>>>>>>>>>            End
19126>>>>>>>>>>>>
19126>>>>>>>>>>>        End
19126>>>>>>>>>>>>
19126>>>>>>>>>>>        
19126>>>>>>>>>>>        // Fetch
19126>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19128>>>>>>>>>>>            Move (False) to Err
19129>>>>>>>>>>>            
19129>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19129>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
19129>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
19129>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19131>>>>>>>>>>>                // Setup function arguments
19131>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
19136>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
19137>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
19138>>>>>>>>>>>            End
19138>>>>>>>>>>>>
19138>>>>>>>>>>>            
19138>>>>>>>>>>>            // Call the driver function to fetch
19138>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
19143>>>>>>>>>>>            
19143>>>>>>>>>>>            // If something went wrong, adjust the result
19143>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
19146>>>>>>>>>>>            
19146>>>>>>>>>>>            If (iResult) Begin
19148>>>>>>>>>>>                For iCol from 1 to iColCount
19154>>>>>>>>>>>>
19154>>>>>>>>>>>                    
19154>>>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
19156>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sEmpty sEmpty iCol ;                            Result pResultWStr
19161>>>>>>>>>>>                            
19161>>>>>>>>>>>                        If (pResultWStr) Begin
19163>>>>>>>>>>>                            Move (CString(PointerToWString(pResultWStr))) to asValues[iCol - 1]
19164>>>>>>>>>>>                        End
19164>>>>>>>>>>>>
19164>>>>>>>>>>>                        Else Begin
19165>>>>>>>>>>>                            Move "" to asValues[iCol - 1]
19166>>>>>>>>>>>                        End
19166>>>>>>>>>>>>
19166>>>>>>>>>>>                        
19166>>>>>>>>>>>                    End
19166>>>>>>>>>>>>
19166>>>>>>>>>>>                    Else Begin
19167>>>>>>>>>>>                        Get psVariableBuffer       to wVariableResult
19168>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing iCol iVariableBufferLength (AddressOf(wVariableResult));                            Result iVoid
19173>>>>>>>>>>>                        
19173>>>>>>>>>>>                        Move (CString(wVariableResult)) to asValues[iCol - 1]
19174>>>>>>>>>>>                    End
19174>>>>>>>>>>>>
19174>>>>>>>>>>>                    
19174>>>>>>>>>>>                Loop
19175>>>>>>>>>>>>
19175>>>>>>>>>>>            End
19175>>>>>>>>>>>>
19175>>>>>>>>>>>        End
19175>>>>>>>>>>>>
19175>>>>>>>>>>>        Else Begin
19176>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
19177>>>>>>>>>>>        End
19177>>>>>>>>>>>>
19177>>>>>>>>>>>        
19177>>>>>>>>>>>        Set piFetchResult to iResult
19178>>>>>>>>>>>        
19178>>>>>>>>>>>        Function_Return asValues
19179>>>>>>>>>>>        
19179>>>>>>>>>>>    End_Function
19180>>>>>>>>>>>    
19180>>>>>>>>>>>    // Fetch a complete result set.
19180>>>>>>>>>>>    // Returns  : 2-dimensional array of strings with result set
19180>>>>>>>>>>>    // Sets piFetchResult property
19180>>>>>>>>>>>    //   0    = No more data
19180>>>>>>>>>>>    //   <> 0 = Success
19180>>>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][]
19182>>>>>>>>>>>        
19182>>>>>>>>>>>        String[][] asValues
19183>>>>>>>>>>>        
19183>>>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
19183>>>>>>>>>>>        String sDrvrId sEmpty sMax
19183>>>>>>>>>>>        Longptr pResultWStr
19183>>>>>>>>>>>        WString wResult
19183>>>>>>>>>>>        
19183>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19183>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19184>>>>>>>>>>>        WString  wVariableResult
19184>>>>>>>>>>>        Integer iHasVariableDataType
19184>>>>>>>>>>>        Integer iLen
19184>>>>>>>>>>>        Integer iVariableBufferLength
19184>>>>>>>>>>>        
19184>>>>>>>>>>>        // Initialize
19184>>>>>>>>>>>        Move "" to sEmpty
19185>>>>>>>>>>>        Move 0  to iResult
19186>>>>>>>>>>>        
19186>>>>>>>>>>>        // Get the cli handles
19186>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19187>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19188>>>>>>>>>>>        Get psDriverId            to sDrvrId
19189>>>>>>>>>>>        
19189>>>>>>>>>>>        // Fetch
19189>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19191>>>>>>>>>>>            Move False to Err
19192>>>>>>>>>>>            
19192>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19192>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
19192>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
19192>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19194>>>>>>>>>>>                // Setup function arguments
19194>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
19199>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
19200>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
19201>>>>>>>>>>>            End
19201>>>>>>>>>>>>
19201>>>>>>>>>>>            
19201>>>>>>>>>>>            Get piColumnCount to iColCount
19202>>>>>>>>>>>            If (iColCount) Begin
19204>>>>>>>>>>>                Get paSQLColumns to aSQLColumns
19205>>>>>>>>>>>                Get piHasVariableDataType to iHasVariableDataType
19206>>>>>>>>>>>                If (iHasVariableDataType) Begin
19208>>>>>>>>>>>                    Get piVariableBufferLength      to iVariableBufferLength
19209>>>>>>>>>>>                    Get piMaxVariableBufferLength   to iLen
19210>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
19212>>>>>>>>>>>                        // Allocate
19212>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to wVariableResult
19213>>>>>>>>>>>                        
19213>>>>>>>>>>>                        Set piVariableBufferLength to iLen
19214>>>>>>>>>>>                        Set psVariableBuffer       to wVariableResult
19215>>>>>>>>>>>                        
19215>>>>>>>>>>>                        Get piVariableBufferLength to iVariableBufferLength
19216>>>>>>>>>>>                    End
19216>>>>>>>>>>>>
19216>>>>>>>>>>>                    Else Begin
19217>>>>>>>>>>>                        Set psVariableBuffer       to wVariableResult
19218>>>>>>>>>>>                    End
19218>>>>>>>>>>>>
19218>>>>>>>>>>>                End
19218>>>>>>>>>>>>
19218>>>>>>>>>>>                
19218>>>>>>>>>>>                // Call the driver function to fetch
19218>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19223>>>>>>>>>>>                If (Err) ;                    Move 0 to iResult
19226>>>>>>>>>>>                
19226>>>>>>>>>>>                While (iResult <> 0)
19230>>>>>>>>>>>                    
19230>>>>>>>>>>>                    For iCol from 1 to (iColCount)
19236>>>>>>>>>>>>
19236>>>>>>>>>>>                        
19236>>>>>>>>>>>                        If (not(aSQLColumns[iCol].iVariableDataType)) Begin
19238>>>>>>>>>>>                            
19238>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback 0 ;                                Passing sEmpty sEmpty iCol ;                                Result pResultWStr
19243>>>>>>>>>>>                            
19243>>>>>>>>>>>                            If (pResultWStr) Begin
19245>>>>>>>>>>>                                Move (CString(PointerToWString(pResultWStr))) to asValues[iRow][iCol - 1]
19246>>>>>>>>>>>                            End
19246>>>>>>>>>>>>
19246>>>>>>>>>>>                            Else Begin
19247>>>>>>>>>>>                                Move "" to asValues[iRow][iCol - 1]
19248>>>>>>>>>>>                            End
19248>>>>>>>>>>>>
19248>>>>>>>>>>>                        End
19248>>>>>>>>>>>>
19248>>>>>>>>>>>                        Else Begin
19249>>>>>>>>>>>                            //Variable data
19249>>>>>>>>>>>                            Move wVariableResult to wResult
19250>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback 0 ;                                Passing iCol iVariableBufferLength (AddressOf(wResult)) ;                                Result iVoid
19255>>>>>>>>>>>                            
19255>>>>>>>>>>>                            Move (CString(wResult)) to asValues[iRow][iCol - 1]
19256>>>>>>>>>>>                        End
19256>>>>>>>>>>>>
19256>>>>>>>>>>>                    Loop
19257>>>>>>>>>>>>
19257>>>>>>>>>>>                    
19257>>>>>>>>>>>                    Increment iRow
19258>>>>>>>>>>>                    
19258>>>>>>>>>>>                    // Call the driver function to fetch
19258>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19263>>>>>>>>>>>                    If (Err) ;                        Move 0 to iResult
19266>>>>>>>>>>>                    
19266>>>>>>>>>>>                Loop
19267>>>>>>>>>>>>
19267>>>>>>>>>>>            End
19267>>>>>>>>>>>>
19267>>>>>>>>>>>        End
19267>>>>>>>>>>>>
19267>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
19269>>>>>>>>>>>        
19269>>>>>>>>>>>        Set piFetchResult to iResult
19270>>>>>>>>>>>        
19270>>>>>>>>>>>        Function_Return asValues
19271>>>>>>>>>>>    End_Function
19272>>>>>>>>>>>    
19272>>>>>>>>>>>    // Get the next column
19272>>>>>>>>>>>    Function SQLNextColumn Returns String
19274>>>>>>>>>>>        Integer iCol
19274>>>>>>>>>>>        String  sResult
19274>>>>>>>>>>>        
19274>>>>>>>>>>>        Get piLastColumn to iCol
19275>>>>>>>>>>>        Increment iCol
19276>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
19277>>>>>>>>>>>        Set piLastColumn to iCol
19278>>>>>>>>>>>        
19278>>>>>>>>>>>        Function_Return sResult
19279>>>>>>>>>>>    End_Function
19280>>>>>>>>>>>    
19280>>>>>>>>>>>    
19280>>>>>>>>>>>    // Returns the native type of a column
19280>>>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
19282>>>>>>>>>>>        Integer ihdbc
19282>>>>>>>>>>>        Integer ihstmt
19282>>>>>>>>>>>        String  sDrvrId
19282>>>>>>>>>>>        Integer iSQLType
19282>>>>>>>>>>>        Integer iColumns
19282>>>>>>>>>>>        
19282>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19282>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19283>>>>>>>>>>>        
19283>>>>>>>>>>>        // Get the cli handles
19283>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19284>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19285>>>>>>>>>>>        Get psDriverId            to sDrvrId
19286>>>>>>>>>>>        
19286>>>>>>>>>>>        // Get the value
19286>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19288>>>>>>>>>>>            
19288>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19289>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19290>>>>>>>>>>>            
19290>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19292>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
19293>>>>>>>>>>>            End
19293>>>>>>>>>>>>
19293>>>>>>>>>>>            Else Begin
19294>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
19295>>>>>>>>>>>            End
19295>>>>>>>>>>>>
19295>>>>>>>>>>>        End
19295>>>>>>>>>>>>
19295>>>>>>>>>>>        Else Begin
19296>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
19297>>>>>>>>>>>        End
19297>>>>>>>>>>>>
19297>>>>>>>>>>>        
19297>>>>>>>>>>>        Function_Return iSQLType
19298>>>>>>>>>>>    End_Function
19299>>>>>>>>>>>    
19299>>>>>>>>>>>    // Returns the size (max length) of a column
19299>>>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
19301>>>>>>>>>>>        Integer ihdbc
19301>>>>>>>>>>>        Integer ihstmt
19301>>>>>>>>>>>        String  sDrvrId
19301>>>>>>>>>>>        Integer iSQLSize
19301>>>>>>>>>>>        Integer iColumns
19301>>>>>>>>>>>        
19301>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19301>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19302>>>>>>>>>>>        
19302>>>>>>>>>>>        // Get the cli handles
19302>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19303>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19304>>>>>>>>>>>        Get psDriverId            to sDrvrId
19305>>>>>>>>>>>        
19305>>>>>>>>>>>        // Get the value
19305>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19307>>>>>>>>>>>            
19307>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19308>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19309>>>>>>>>>>>            
19309>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19311>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
19312>>>>>>>>>>>            End
19312>>>>>>>>>>>>
19312>>>>>>>>>>>            Else Begin
19313>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
19314>>>>>>>>>>>            End
19314>>>>>>>>>>>>
19314>>>>>>>>>>>        End
19314>>>>>>>>>>>>
19314>>>>>>>>>>>        Else Begin
19315>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
19316>>>>>>>>>>>        End
19316>>>>>>>>>>>>
19316>>>>>>>>>>>        
19316>>>>>>>>>>>        Function_Return iSQLSize
19317>>>>>>>>>>>    End_Function
19318>>>>>>>>>>>    
19318>>>>>>>>>>>    //  Returns 1 for variable length datatypes.
19318>>>>>>>>>>>    //  For example SQL Server varchar(max) or text type
19318>>>>>>>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
19318>>>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
19320>>>>>>>>>>>        Integer ihdbc
19320>>>>>>>>>>>        Integer ihstmt
19320>>>>>>>>>>>        String  sDrvrId
19320>>>>>>>>>>>        Integer iVariableDataType
19320>>>>>>>>>>>        Integer iColumns
19320>>>>>>>>>>>        
19320>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19320>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19321>>>>>>>>>>>        
19321>>>>>>>>>>>        // Get the cli handles
19321>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19322>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19323>>>>>>>>>>>        Get psDriverId            to sDrvrId
19324>>>>>>>>>>>        
19324>>>>>>>>>>>        // Get the value
19324>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19326>>>>>>>>>>>            
19326>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19327>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19328>>>>>>>>>>>            
19328>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19330>>>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
19331>>>>>>>>>>>            End
19331>>>>>>>>>>>>
19331>>>>>>>>>>>            Else Begin
19332>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
19333>>>>>>>>>>>            End
19333>>>>>>>>>>>>
19333>>>>>>>>>>>        End
19333>>>>>>>>>>>>
19333>>>>>>>>>>>        Else Begin
19334>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
19335>>>>>>>>>>>        End
19335>>>>>>>>>>>>
19335>>>>>>>>>>>        
19335>>>>>>>>>>>        Function_Return iVariableDataType
19336>>>>>>>>>>>    End_Function
19337>>>>>>>>>>>    
19337>>>>>>>>>>>    
19337>>>>>>>>>>>    // Return the value of a column in a fetched row of a given
19337>>>>>>>>>>>    // statement.
19337>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
19339>>>>>>>>>>>        Integer ihdbc
19339>>>>>>>>>>>        Integer ihstmt
19339>>>>>>>>>>>        String  sDrvrId sResult
19339>>>>>>>>>>>        Longptr pResultWStr
19339>>>>>>>>>>>        
19339>>>>>>>>>>>        Integer iVoid
19339>>>>>>>>>>>        Integer iColSize
19339>>>>>>>>>>>        Integer iColPrecision
19339>>>>>>>>>>>        String  sEmpty
19339>>>>>>>>>>>        Integer bLegalColumn
19339>>>>>>>>>>>        
19339>>>>>>>>>>>        // Initialize
19339>>>>>>>>>>>        Move "" to sResult
19340>>>>>>>>>>>        
19340>>>>>>>>>>>        // Get the cli handles
19340>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19341>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19342>>>>>>>>>>>        Get psDriverId            to sDrvrId
19343>>>>>>>>>>>        
19343>>>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19343>>>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
19343>>>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
19343>>>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19345>>>>>>>>>>>            // Setup function arguments
19345>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
19350>>>>>>>>>>>            Move ihstmt to giLastSQLhstmt
19351>>>>>>>>>>>            Move ihdbc to giLastSQLhdbc
19352>>>>>>>>>>>        End
19352>>>>>>>>>>>>
19352>>>>>>>>>>>        
19352>>>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19354>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result pResultWStr
19359>>>>>>>>>>>            
19359>>>>>>>>>>>            If (pResultWStr) Begin
19361>>>>>>>>>>>                Move (PointerToWString(pResultWStr)) to sResult
19362>>>>>>>>>>>            End
19362>>>>>>>>>>>>
19362>>>>>>>>>>>            Else Begin
19363>>>>>>>>>>>                Move "" to sResult
19364>>>>>>>>>>>            End
19364>>>>>>>>>>>>
19364>>>>>>>>>>>        End
19364>>>>>>>>>>>>
19364>>>>>>>>>>>        Else Begin
19365>>>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
19366>>>>>>>>>>>        End
19366>>>>>>>>>>>>
19366>>>>>>>>>>>        
19366>>>>>>>>>>>        Function_Return sResult
19367>>>>>>>>>>>        
19367>>>>>>>>>>>    End_Function
19368>>>>>>>>>>>    
19368>>>>>>>>>>>    // Add a file to the files used to place the statement result in.
19368>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
19370>>>>>>>>>>>        Integer ihdbc
19370>>>>>>>>>>>        Integer ihstmt
19370>>>>>>>>>>>        Integer iVoid
19370>>>>>>>>>>>        String  sDrvrId
19370>>>>>>>>>>>        String  sFileType
19370>>>>>>>>>>>        Integer bIsOpen
19370>>>>>>>>>>>        
19370>>>>>>>>>>>        // Get the cli handles
19370>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19371>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19372>>>>>>>>>>>        Get psDriverId            to sDrvrId
19373>>>>>>>>>>>        
19373>>>>>>>>>>>        // If a file number is not passed see if we can use the statement's
19373>>>>>>>>>>>        // default file number which is usually set with SetFileConnection
19373>>>>>>>>>>>        If (iFileNum = 0) Begin
19375>>>>>>>>>>>            Get piBindFile to iFileNum
19376>>>>>>>>>>>            If (iFileNum = 0) Begin
19378>>>>>>>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
19378>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
19379>>>>>>>>>>>                
19379>>>>>>>>>>>                Move 0 to SQLResult
19380>>>>>>>>>>>                Procedure_Return
19381>>>>>>>>>>>            End
19381>>>>>>>>>>>>
19381>>>>>>>>>>>        End
19381>>>>>>>>>>>>
19381>>>>>>>>>>>        
19381>>>>>>>>>>>        // Bind the file
19381>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19383>>>>>>>>>>>            // Chek if the file is open
19383>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
19386>>>>>>>>>>>            If (bIsOpen) Begin
19388>>>>>>>>>>>                // Check if the file has the correct type
19388>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
19391>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
19393>>>>>>>>>>>                    // Call the driver function to add a file to a statement
19393>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
19398>>>>>>>>>>>                End
19398>>>>>>>>>>>>
19398>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
19400>>>>>>>>>>>            End
19400>>>>>>>>>>>>
19400>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
19402>>>>>>>>>>>        End
19402>>>>>>>>>>>>
19402>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
19404>>>>>>>>>>>    End_Procedure
19405>>>>>>>>>>>    
19405>>>>>>>>>>>    
19405>>>>>>>>>>>    
19405>>>>>>>>>>>    // Get data of a column.                                  
19405>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
19407>>>>>>>>>>>        Integer ihdbc
19407>>>>>>>>>>>        Integer ihstmt
19407>>>>>>>>>>>        Integer iVoid
19407>>>>>>>>>>>        Integer iColSize
19407>>>>>>>>>>>        Integer iResult
19407>>>>>>>>>>>        String  sDrvrId
19407>>>>>>>>>>>        WString wResult
19407>>>>>>>>>>>        String  sEmpty
19407>>>>>>>>>>>        Integer bLegalColumn
19407>>>>>>>>>>>        
19407>>>>>>>>>>>        Integer iVariableBufferLength
19407>>>>>>>>>>>        
19407>>>>>>>>>>>        // Initialize
19407>>>>>>>>>>>        Move "" to sEmpty
19408>>>>>>>>>>>        Move 0 to iResult
19409>>>>>>>>>>>        
19409>>>>>>>>>>>        // Get the cli handles
19409>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19410>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19411>>>>>>>>>>>        Get psDriverId            to sDrvrId
19412>>>>>>>>>>>        
19412>>>>>>>>>>>        // Get the data
19412>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19414>>>>>>>>>>>            // Check if the column exists
19414>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19416>>>>>>>>>>>                If (iLen = 0) Begin
19418>>>>>>>>>>>                    Get SQLColumnValue iCol to wResult
19419>>>>>>>>>>>                End
19419>>>>>>>>>>>>
19419>>>>>>>>>>>                Else Begin
19420>>>>>>>>>>>                    // Add 1 for string terminator
19420>>>>>>>>>>>                    Move (iLen + 1) to iLen
19421>>>>>>>>>>>                    
19421>>>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
19422>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
19424>>>>>>>>>>>                        // Allocate
19424>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to wResult
19425>>>>>>>>>>>                        
19425>>>>>>>>>>>                        Set piVariableBufferLength to iLen
19426>>>>>>>>>>>                        Set psVariableBuffer       to wResult
19427>>>>>>>>>>>                    End
19427>>>>>>>>>>>>
19427>>>>>>>>>>>                    Else Begin
19428>>>>>>>>>>>                        Get psVariableBuffer       to wResult
19429>>>>>>>>>>>                    End
19429>>>>>>>>>>>>
19429>>>>>>>>>>>                    
19429>>>>>>>>>>>                    
19429>>>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19429>>>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
19429>>>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
19429>>>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19431>>>>>>>>>>>                        // Setup function arguments
19431>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
19436>>>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
19437>>>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
19438>>>>>>>>>>>                    End
19438>>>>>>>>>>>>
19438>>>>>>>>>>>                    
19438>>>>>>>>>>>                    Move False to Err
19439>>>>>>>>>>>                    // Call the driver function to get the data
19439>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing iCol iLen (AddressOf(wResult)) ;                        Result iResult
19444>>>>>>>>>>>                    
19444>>>>>>>>>>>                    // If something went wrong, adjust the result
19444>>>>>>>>>>>                    If (Err) Begin
19446>>>>>>>>>>>                        Move 0 to iResult
19447>>>>>>>>>>>                    End
19447>>>>>>>>>>>>
19447>>>>>>>>>>>                    
19447>>>>>>>>>>>                    // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
19447>>>>>>>>>>>                    If (iResult = -4) Begin
19449>>>>>>>>>>>                        Move (SizeOfWString(wResult)) to iResult
19450>>>>>>>>>>>                    End
19450>>>>>>>>>>>>
19450>>>>>>>>>>>                End
19450>>>>>>>>>>>>
19450>>>>>>>>>>>            End
19450>>>>>>>>>>>>
19450>>>>>>>>>>>            Else Begin
19451>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
19452>>>>>>>>>>>            End
19452>>>>>>>>>>>>
19452>>>>>>>>>>>        End
19452>>>>>>>>>>>>
19452>>>>>>>>>>>        Else Begin
19453>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
19454>>>>>>>>>>>        End
19454>>>>>>>>>>>>
19454>>>>>>>>>>>        
19454>>>>>>>>>>>        // Fill global result
19454>>>>>>>>>>>        If (iResult > 0) Begin
19456>>>>>>>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
19457>>>>>>>>>>>        End
19457>>>>>>>>>>>>
19457>>>>>>>>>>>        Else Begin
19458>>>>>>>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
19459>>>>>>>>>>>        End
19459>>>>>>>>>>>>
19459>>>>>>>>>>>        
19459>>>>>>>>>>>        Function_Return (CString(wResult))
19460>>>>>>>>>>>    End_Function
19461>>>>>>>>>>>
19461>>>>>>>>>>>    // SQLGetDataToUChar (SQLGetData returning uchar array)
19461>>>>>>>>>>>    // Use for binary data and for character data containing Unicode non-bmp characters
19461>>>>>>>>>>>    Function SQLGetDataToUChar Integer iCol Integer iLen Returns UChar[]
19463>>>>>>>>>>>        Integer ihdbc
19463>>>>>>>>>>>        Integer ihstmt
19463>>>>>>>>>>>        Integer iVoid
19463>>>>>>>>>>>        Integer iColSize
19463>>>>>>>>>>>        Integer iResult
19463>>>>>>>>>>>        String  sDrvrId
19463>>>>>>>>>>>        UChar[] uaResult
19464>>>>>>>>>>>        
19464>>>>>>>>>>>        Integer iSQLType
19464>>>>>>>>>>>        Integer iBinaryType
19464>>>>>>>>>>>        Integer iLenArray
19464>>>>>>>>>>>        Integer iResizeSize
19464>>>>>>>>>>>        
19464>>>>>>>>>>>        Move 0 to iResult
19465>>>>>>>>>>>        
19465>>>>>>>>>>>        // Get the cli handles
19465>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19466>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19467>>>>>>>>>>>        Get psDriverId            to sDrvrId
19468>>>>>>>>>>>        
19468>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19470>>>>>>>>>>>            // Check if the column exists
19470>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19472>>>>>>>>>>>                            
19472>>>>>>>>>>>                Get SQLColumnType iCol to iSQLType
19473>>>>>>>>>>>                If ( (iSQLType = SQL_BINARY) or (iSQLType = SQL_VARBINARY) or (iSQLType = SQL_LONGVARBINARY) ) Begin
19475>>>>>>>>>>>                    Move 1 to iBinaryType
19476>>>>>>>>>>>                End
19476>>>>>>>>>>>>
19476>>>>>>>>>>>                Else Begin
19477>>>>>>>>>>>                    Move 0 to iBinaryType 
19478>>>>>>>>>>>                End
19478>>>>>>>>>>>>
19478>>>>>>>>>>>    
19478>>>>>>>>>>>                If (iBinaryType) Begin
19480>>>>>>>>>>>                    Move (ResizeArray(uaResult,iLen)) to uaResult
19481>>>>>>>>>>>                End
19481>>>>>>>>>>>>
19481>>>>>>>>>>>                Else Begin
19482>>>>>>>>>>>                    // Character type
19482>>>>>>>>>>>                    // returned as wstring (2 bytes per character)
19482>>>>>>>>>>>                    // Add 1 for string terminator
19482>>>>>>>>>>>                    Move (iLen + 1) to iLen
19483>>>>>>>>>>>                    Move (iLen * 2) to iLenArray // wstring 2 bytes per char
19484>>>>>>>>>>>                    Move (ResizeArray(uaResult,iLenArray)) to uaResult
19485>>>>>>>>>>>                End
19485>>>>>>>>>>>>
19485>>>>>>>>>>>
19485>>>>>>>>>>>                // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19485>>>>>>>>>>>                // in the next FUNC_SQLCOLUMNVALUE call.
19485>>>>>>>>>>>                If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19487>>>>>>>>>>>                    // Setup function arguments
19487>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
19492>>>>>>>>>>>                    Move ihstmt to giLastSQLhstmt
19493>>>>>>>>>>>                    Move ihdbc to giLastSQLhdbc
19494>>>>>>>>>>>                End
19494>>>>>>>>>>>>
19494>>>>>>>>>>>                
19494>>>>>>>>>>>                Move False to Err
19495>>>>>>>>>>>                
19495>>>>>>>>>>>                // Call the driver function to get the data
19495>>>>>>>>>>>                // iResult will be the length of the data in bytes 
19495>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                    Callback Self ;                    Passing iCol iLen (AddressOf(uaResult[0])) ;                    Result iResult
19500>>>>>>>>>>>                
19500>>>>>>>>>>>                // If something went wrong, adjust the result
19500>>>>>>>>>>>                If (Err) Begin
19502>>>>>>>>>>>                    Move 0 to iResult
19503>>>>>>>>>>>                End
19503>>>>>>>>>>>>
19503>>>>>>>>>>>                
19503>>>>>>>>>>>                // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
19503>>>>>>>>>>>                If (iResult = -4) Begin
19505>>>>>>>>>>>                    Move (SizeOfArray(uaResult)) to iResult
19506>>>>>>>>>>>                End
19506>>>>>>>>>>>>
19506>>>>>>>>>>>                
19506>>>>>>>>>>>                If (iBinaryType) Begin
19508>>>>>>>>>>>                    If (iResult < iLen) Begin
19510>>>>>>>>>>>                        Move (ResizeArray(uaResult,iResult)) to uaResult
19511>>>>>>>>>>>                    End
19511>>>>>>>>>>>>
19511>>>>>>>>>>>                End
19511>>>>>>>>>>>>
19511>>>>>>>>>>>                Else Begin
19512>>>>>>>>>>>                    // Character data
19512>>>>>>>>>>>                    //   iResult has length of data in bytes (without zero terminator)
19512>>>>>>>>>>>                    //   uaResult will have data + zero terminator
19512>>>>>>>>>>>                    If (iResult < (iLenArray - 2) ) Begin
19514>>>>>>>>>>>                        // Received less than requested, strip off trailing zeroes.
19514>>>>>>>>>>>                        Move iResult to iResizeSize
19515>>>>>>>>>>>                    End
19515>>>>>>>>>>>>
19515>>>>>>>>>>>                    Else Begin
19516>>>>>>>>>>>                        // Strip off zero terminator
19516>>>>>>>>>>>                        Move (iLenArray - 2) to iResizeSize
19517>>>>>>>>>>>                    End
19517>>>>>>>>>>>>
19517>>>>>>>>>>>                    
19517>>>>>>>>>>>                    Move (ResizeArray(uaResult,iResizeSize)) to uaResult
19518>>>>>>>>>>>                    
19518>>>>>>>>>>>                End
19518>>>>>>>>>>>>
19518>>>>>>>>>>>            End
19518>>>>>>>>>>>>
19518>>>>>>>>>>>            Else Begin
19519>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
19520>>>>>>>>>>>            End
19520>>>>>>>>>>>>
19520>>>>>>>>>>>        End
19520>>>>>>>>>>>>
19520>>>>>>>>>>>        Else Begin
19521>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
19522>>>>>>>>>>>        End
19522>>>>>>>>>>>>
19522>>>>>>>>>>>        
19522>>>>>>>>>>>        // Fill global result
19522>>>>>>>>>>>        If (iResult > 0) Begin
19524>>>>>>>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
19525>>>>>>>>>>>        End
19525>>>>>>>>>>>>
19525>>>>>>>>>>>        Else Begin
19526>>>>>>>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
19527>>>>>>>>>>>        End
19527>>>>>>>>>>>>
19527>>>>>>>>>>>        
19527>>>>>>>>>>>        Function_Return uaResult
19528>>>>>>>>>>>
19528>>>>>>>>>>>    End_Function
19529>>>>>>>>>>>    
19529>>>>>>>>>>>    
19529>>>>>>>>>>>    // Map a column name to a number, if the name id not found no
19529>>>>>>>>>>>    // error is generated the returned number will be 0 (zero) in
19529>>>>>>>>>>>    // that case
19529>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
19531>>>>>>>>>>>        Integer ihdbc
19531>>>>>>>>>>>        Integer ihstmt
19531>>>>>>>>>>>        Integer iNumColumns
19531>>>>>>>>>>>        Integer iColCount
19531>>>>>>>>>>>        Integer iColNum
19531>>>>>>>>>>>        String  sDrvrId
19531>>>>>>>>>>>        String  sCurColName
19531>>>>>>>>>>>        
19531>>>>>>>>>>>        // Get the cli handles
19531>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19532>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19533>>>>>>>>>>>        Get psDriverId            to sDrvrId
19534>>>>>>>>>>>        
19534>>>>>>>>>>>        // Get the number by looping through the column names
19534>>>>>>>>>>>        Move 0 to iColNum
19535>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19536>>>>>>>>>>>        For iColCount from 1 to iNumColumns
19542>>>>>>>>>>>>
19542>>>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
19543>>>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
19546>>>>>>>>>>>            
19546>>>>>>>>>>>            If (iColNum) ;                Break
19549>>>>>>>>>>>        Loop
19550>>>>>>>>>>>>
19550>>>>>>>>>>>        
19550>>>>>>>>>>>        Function_Return iColNum
19551>>>>>>>>>>>    End_Function
19552>>>>>>>>>>>    
19552>>>>>>>>>>>    
19552>>>>>>>>>>>    // SQLStmtAttribute
19552>>>>>>>>>>>    // Moved to SQLGetStatementAttribute. 
19552>>>>>>>>>>>    // This function is still here for backward compatibility.
19552>>>>>>>>>>>
19552>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
19554>>>>>>>>>>>        String  sResult
19554>>>>>>>>>>>
19554>>>>>>>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
19555>>>>>>>>>>>        
19555>>>>>>>>>>>        Function_Return sResult
19556>>>>>>>>>>>    End_Function
19557>>>>>>>>>>>
19557>>>>>>>>>>> 
19557>>>>>>>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
19559>>>>>>>>>>>        Integer ihdbc
19559>>>>>>>>>>>        Integer ihstmt
19559>>>>>>>>>>>        String  sResult
19559>>>>>>>>>>>        String  sDrvrId
19559>>>>>>>>>>>        
19559>>>>>>>>>>>        // Initialize
19559>>>>>>>>>>>        Move "" to sResult
19560>>>>>>>>>>>        
19560>>>>>>>>>>>        // Get the cli handles
19560>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19561>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19562>>>>>>>>>>>        Get psDriverId            to sDrvrId
19563>>>>>>>>>>>        
19563>>>>>>>>>>>        // Get the attribute
19563>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
19566>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
19568>>>>>>>>>>>        
19568>>>>>>>>>>>        Function_Return sResult
19569>>>>>>>>>>>    End_Function
19570>>>>>>>>>>>
19570>>>>>>>>>>>    
19570>>>>>>>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
19572>>>>>>>>>>>
19572>>>>>>>>>>>        Integer ihdbc
19572>>>>>>>>>>>        Integer ihstmt
19572>>>>>>>>>>>        String  sDrvrId
19572>>>>>>>>>>>        
19572>>>>>>>>>>>        Integer iLen
19572>>>>>>>>>>>        Integer bLegalAttrib
19572>>>>>>>>>>>        Integer iVoid
19572>>>>>>>>>>>        Integer iAttribValue
19572>>>>>>>>>>>
19572>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19573>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19574>>>>>>>>>>>        Get psDriverId            to sDrvrId
19575>>>>>>>>>>>        
19575>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19577>>>>>>>>>>>            Case Begin
19577>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
19579>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
19580>>>>>>>>>>>                    Break
19581>>>>>>>>>>>                    
19581>>>>>>>>>>>                Case Else
19581>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
19582>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
19583>>>>>>>>>>>            Case End
19583>>>>>>>>>>>
19583>>>>>>>>>>>            If (bLegalAttrib) Begin
19585>>>>>>>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
19587>>>>>>>>>>>                    
19587>>>>>>>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
19588>>>>>>>>>>>                    Case Begin
19588>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
19590>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
19593>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
19596>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
19599>>>>>>>>>>>                            Break
19600>>>>>>>>>>>                            
19600>>>>>>>>>>>                        Case Else
19600>>>>>>>>>>>                            Move DFFALSE to bLegalAttrib
19601>>>>>>>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
19602>>>>>>>>>>>
19602>>>>>>>>>>>                    Case End
19602>>>>>>>>>>>                End
19602>>>>>>>>>>>>
19602>>>>>>>>>>>            End
19602>>>>>>>>>>>>
19602>>>>>>>>>>>
19602>>>>>>>>>>>            
19602>>>>>>>>>>>            If (bLegalAttrib) Begin
19604>>>>>>>>>>>                
19604>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
19609>>>>>>>>>>>                
19609>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
19614>>>>>>>>>>>            End
19614>>>>>>>>>>>>
19614>>>>>>>>>>>        End
19614>>>>>>>>>>>>
19614>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
19616>>>>>>>>>>>        
19616>>>>>>>>>>>        
19616>>>>>>>>>>>        
19616>>>>>>>>>>>    End_Procedure
19617>>>>>>>>>>>    
19617>>>>>>>>>>>    
19617>>>>>>>>>>>    
19617>>>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
19619>>>>>>>>>>>        String  sResult
19619>>>>>>>>>>>        Integer iLen
19619>>>>>>>>>>>        Integer bLegalAttrib
19619>>>>>>>>>>>        
19619>>>>>>>>>>>        // Initialize
19619>>>>>>>>>>>        Move ""     to sResult
19620>>>>>>>>>>>        
19620>>>>>>>>>>>        // Get the attribute
19620>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19622>>>>>>>>>>>            Case Begin
19622>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
19624>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
19627>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
19630>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
19633>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
19636>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
19637>>>>>>>>>>>                    Break
19638>>>>>>>>>>>                    
19638>>>>>>>>>>>                Case Else
19638>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
19639>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
19640>>>>>>>>>>>            Case End
19640>>>>>>>>>>>            
19640>>>>>>>>>>>            If (bLegalAttrib) Begin
19642>>>>>>>>>>>                // Setup function arguments
19642>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
19647>>>>>>>>>>>            End
19647>>>>>>>>>>>>
19647>>>>>>>>>>>        End
19647>>>>>>>>>>>>
19647>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
19649>>>>>>>>>>>        
19649>>>>>>>>>>>        Function_Return sResult
19650>>>>>>>>>>>    End_Function
19651>>>>>>>>>>>    
19651>>>>>>>>>>>    
19651>>>>>>>>>>>    
19651>>>>>>>>>>>    // Get a column's attribute
19651>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
19653>>>>>>>>>>>        Integer ihdbc
19653>>>>>>>>>>>        Integer ihstmt
19653>>>>>>>>>>>        String  sResult
19653>>>>>>>>>>>        String  sDrvrId
19653>>>>>>>>>>>        
19653>>>>>>>>>>>        // Initialize
19653>>>>>>>>>>>        Move "" to sResult
19654>>>>>>>>>>>        
19654>>>>>>>>>>>        // Get the cli handles
19654>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19655>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19656>>>>>>>>>>>        Get psDriverId            to sDrvrId
19657>>>>>>>>>>>        
19657>>>>>>>>>>>        // Get the attribute
19657>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
19660>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
19662>>>>>>>>>>>        
19662>>>>>>>>>>>        Function_Return sResult
19663>>>>>>>>>>>    End_Function
19664>>>>>>>>>>>    
19664>>>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
19666>>>>>>>>>>>        String  sResult
19666>>>>>>>>>>>        String  sEmpty
19666>>>>>>>>>>>        Integer bIsStringAttribute
19666>>>>>>>>>>>        Integer iLen
19666>>>>>>>>>>>        Integer iVoid
19666>>>>>>>>>>>        Integer bLegalAttrib
19666>>>>>>>>>>>        Integer bLegalColumn
19666>>>>>>>>>>>        
19666>>>>>>>>>>>        // Initialize
19666>>>>>>>>>>>        Move "" to sResult
19667>>>>>>>>>>>        Move "" to sEmpty
19668>>>>>>>>>>>        Move 0  to iLen
19669>>>>>>>>>>>        
19669>>>>>>>>>>>        // Get the attribute
19669>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19671>>>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
19672>>>>>>>>>>>            If (bLegalColumn) Begin
19674>>>>>>>>>>>                // Determine the atributes type
19674>>>>>>>>>>>                Case Begin
19674>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
19676>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
19679>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
19682>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
19685>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
19688>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
19691>>>>>>>>>>>                        Move DFFALSE to bIsStringAttribute
19692>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
19693>>>>>>>>>>>                        Break
19694>>>>>>>>>>>                        
19694>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
19697>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
19700>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
19703>>>>>>>>>>>                        Move DFTRUE to bIsStringAttribute
19704>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
19705>>>>>>>>>>>                        Break
19706>>>>>>>>>>>                        
19706>>>>>>>>>>>                    Case Else
19706>>>>>>>>>>>                        Move DFFALSE to bLegalAttrib
19707>>>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
19708>>>>>>>>>>>                Case End
19708>>>>>>>>>>>                
19708>>>>>>>>>>>                If (bLegalAttrib) Begin
19710>>>>>>>>>>>                    // Setup function arguments
19710>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
19715>>>>>>>>>>>                    
19715>>>>>>>>>>>                    If (bIsStringAttribute) Begin
19717>>>>>>>>>>>                        // Call the driver function to get the data length
19717>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
19722>>>>>>>>>>>                        
19722>>>>>>>>>>>                        If (iLen) Begin
19724>>>>>>>>>>>                            // Allocate
19724>>>>>>>>>>>                            Move (Repeat(' ', iLen)) to sResult
19725>>>>>>>>>>>                            
19725>>>>>>>>>>>                            // Call the driver function to get the name
19725>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
19730>>>>>>>>>>>                        End
19730>>>>>>>>>>>>
19730>>>>>>>>>>>                    End
19730>>>>>>>>>>>>
19730>>>>>>>>>>>                    Else Begin
19731>>>>>>>>>>>                        // get the attribute
19731>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
19736>>>>>>>>>>>                    End
19736>>>>>>>>>>>>
19736>>>>>>>>>>>                End
19736>>>>>>>>>>>>
19736>>>>>>>>>>>            End
19736>>>>>>>>>>>>
19736>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
19738>>>>>>>>>>>        End
19738>>>>>>>>>>>>
19738>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
19740>>>>>>>>>>>        
19740>>>>>>>>>>>        Function_Return sResult
19741>>>>>>>>>>>    End_Function
19742>>>>>>>>>>>    
19742>>>>>>>>>>>    
19742>>>>>>>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
19742>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
19744>>>>>>>>>>>        Integer ihdbc
19744>>>>>>>>>>>        Integer ihstmt
19744>>>>>>>>>>>        String  sDrvrId
19744>>>>>>>>>>>        Integer iVoid
19744>>>>>>>>>>>        String  sSchema
19744>>>>>>>>>>>        String  sEmpty
19744>>>>>>>>>>>        
19744>>>>>>>>>>>        // Initialize
19744>>>>>>>>>>>        Move "" to sEmpty
19745>>>>>>>>>>>        
19745>>>>>>>>>>>        // Get the cli handles
19745>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19746>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19747>>>>>>>>>>>        Get psDriverId            to sDrvrId
19748>>>>>>>>>>>        
19748>>>>>>>>>>>        // Call the procedure
19748>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19750>>>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
19753>>>>>>>>>>>            Else ;                Move "" to sSchema
19755>>>>>>>>>>>            
19755>>>>>>>>>>>            If (sSchema <> "") Begin
19757>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
19762>>>>>>>>>>>            End
19762>>>>>>>>>>>>
19762>>>>>>>>>>>            
19762>>>>>>>>>>>            // Call the procedure
19762>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
19767>>>>>>>>>>>            
19767>>>>>>>>>>>            Set piLastArgument to 0
19768>>>>>>>>>>>        End
19768>>>>>>>>>>>>
19768>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
19770>>>>>>>>>>>    End_Procedure
19771>>>>>>>>>>>    
19771>>>>>>>>>>>    // Pass the next argument
19771>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
19773>>>>>>>>>>>        Integer iArgnum
19773>>>>>>>>>>>        
19773>>>>>>>>>>>        Get piLastArgument to iArgnum
19774>>>>>>>>>>>        Increment iArgnum
19775>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
19776>>>>>>>>>>>        Set piLastArgument to iArgnum
19777>>>>>>>>>>>    End_Procedure
19778>>>>>>>>>>>    
19778>>>>>>>>>>>    
19778>>>>>>>>>>>    
19778>>>>>>>>>>>    // Set the next argument
19778>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
19780>>>>>>>>>>>        Integer ihdbc
19780>>>>>>>>>>>        Integer ihstmt
19780>>>>>>>>>>>        String  sDrvrId
19780>>>>>>>>>>>        Integer iVoid
19780>>>>>>>>>>>        String  sEmpty
19780>>>>>>>>>>>        
19780>>>>>>>>>>>        // Initialize
19780>>>>>>>>>>>        Move "" to sEmpty
19781>>>>>>>>>>>        
19781>>>>>>>>>>>        // Get the cli handles
19781>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19782>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19783>>>>>>>>>>>        Get psDriverId            to sDrvrId
19784>>>>>>>>>>>        
19784>>>>>>>>>>>        // Call the procedure
19784>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19786>>>>>>>>>>>            // Pass the information
19786>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
19791>>>>>>>>>>>            
19791>>>>>>>>>>>            // Pass the argument
19791>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
19796>>>>>>>>>>>        End
19796>>>>>>>>>>>>
19796>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
19798>>>>>>>>>>>    End_Procedure
19799>>>>>>>>>>>    
19799>>>>>>>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
19801>>>>>>>>>>>        Integer iParamNum 
19801>>>>>>>>>>>        Integer iType
19801>>>>>>>>>>>        
19801>>>>>>>>>>>        If (num_arguments < 2) Begin
19803>>>>>>>>>>>            Move typeString to iType
19804>>>>>>>>>>>        End
19804>>>>>>>>>>>>
19804>>>>>>>>>>>        Else Begin
19805>>>>>>>>>>>            Move iParamType to iType
19806>>>>>>>>>>>        End
19806>>>>>>>>>>>>
19806>>>>>>>>>>>        
19806>>>>>>>>>>>        Get piLastArgument to iParamNum
19807>>>>>>>>>>>        Increment iParamNum
19808>>>>>>>>>>>        Send SQLSetParameter iParamNum sParamValue iType
19809>>>>>>>>>>>        Set piLastArgument to iParamNum
19810>>>>>>>>>>>    End_Procedure
19811>>>>>>>>>>>
19811>>>>>>>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
19813>>>>>>>>>>>        
19813>>>>>>>>>>>        Integer ihdbc
19813>>>>>>>>>>>        Integer ihstmt
19813>>>>>>>>>>>        String  sDrvrId
19813>>>>>>>>>>>        Integer iVoid
19813>>>>>>>>>>>        String  sEmpty
19813>>>>>>>>>>>        Integer iType
19813>>>>>>>>>>>        
19813>>>>>>>>>>>        If (num_arguments < 3) Begin
19815>>>>>>>>>>>            Move typeString to iType
19816>>>>>>>>>>>        End
19816>>>>>>>>>>>>
19816>>>>>>>>>>>        Else Begin
19817>>>>>>>>>>>            Move iParamType to iType
19818>>>>>>>>>>>        End
19818>>>>>>>>>>>>
19818>>>>>>>>>>>        
19818>>>>>>>>>>>        Case Begin
19818>>>>>>>>>>>            Case (iType = typeDate )    
19820>>>>>>>>>>>
19820>>>>>>>>>>>                If (sParamValue <> "") Begin
19822>>>>>>>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
19823>>>>>>>>>>>                End
19823>>>>>>>>>>>>
19823>>>>>>>>>>>                
19823>>>>>>>>>>>                Break
19824>>>>>>>>>>>
19824>>>>>>>>>>>            Case (iType = typeDatetime )    
19827>>>>>>>>>>>
19827>>>>>>>>>>>                If (sParamValue <> "") Begin
19829>>>>>>>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
19830>>>>>>>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
19831>>>>>>>>>>>                End
19831>>>>>>>>>>>>
19831>>>>>>>>>>>
19831>>>>>>>>>>>                Break
19832>>>>>>>>>>>
19832>>>>>>>>>>>            Case (iType = typeNumber )    
19835>>>>>>>>>>>
19835>>>>>>>>>>>                If (sParamValue <> "") Begin
19837>>>>>>>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
19838>>>>>>>>>>>                End
19838>>>>>>>>>>>>
19838>>>>>>>>>>>                
19838>>>>>>>>>>>                Break
19839>>>>>>>>>>>            
19839>>>>>>>>>>>            Case (iType = typeTime )    
19842>>>>>>>>>>>
19842>>>>>>>>>>>                If (sParamValue <> "") Begin
19844>>>>>>>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
19845>>>>>>>>>>>                End
19845>>>>>>>>>>>>
19845>>>>>>>>>>>                
19845>>>>>>>>>>>                Break
19846>>>>>>>>>>>                
19846>>>>>>>>>>>            Case Else
19846>>>>>>>>>>>                    // sParamValue is a string type or a type that must be passed as a string
19846>>>>>>>>>>>                    Break
19847>>>>>>>>>>>                
19847>>>>>>>>>>>        Case End
19847>>>>>>>>>>>        
19847>>>>>>>>>>>        
19847>>>>>>>>>>>        // Initialize
19847>>>>>>>>>>>        Move "" to sEmpty
19848>>>>>>>>>>>        
19848>>>>>>>>>>>        // Get the cli handles
19848>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19849>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19850>>>>>>>>>>>        Get psDriverId            to sDrvrId
19851>>>>>>>>>>>        
19851>>>>>>>>>>>        // Call the procedure
19851>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19853>>>>>>>>>>>            // Pass the information
19853>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
19858>>>>>>>>>>>            
19858>>>>>>>>>>>            // Pass the argument
19858>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
19863>>>>>>>>>>>        End
19863>>>>>>>>>>>>
19863>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
19865>>>>>>>>>>>    End_Procedure
19866>>>>>>>>>>>    
19866>>>>>>>>>>>    
19866>>>>>>>>>>>    // Call a stored procedure
19866>>>>>>>>>>>    Procedure SQLCall
19868>>>>>>>>>>>        Integer ihdbc
19868>>>>>>>>>>>        Integer ihstmt
19868>>>>>>>>>>>        String  sDrvrId
19868>>>>>>>>>>>        Integer iVoid
19868>>>>>>>>>>>        String  sEmpty
19868>>>>>>>>>>>        
19868>>>>>>>>>>>        // Initialize
19868>>>>>>>>>>>        Move "" to sEmpty
19869>>>>>>>>>>>        
19869>>>>>>>>>>>        // Get the cli handles
19869>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19870>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19871>>>>>>>>>>>        Get psDriverId            to sDrvrId
19872>>>>>>>>>>>        
19872>>>>>>>>>>>        // Call the procedure
19872>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19874>>>>>>>>>>>            // Call the procedure
19874>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
19879>>>>>>>>>>>            
19879>>>>>>>>>>>            Send SQLGetStatementAttributes
19880>>>>>>>>>>>            Set piLastArgument to 0
19881>>>>>>>>>>>        End
19881>>>>>>>>>>>>
19881>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
19883>>>>>>>>>>>    End_Procedure
19884>>>>>>>>>>>    
19884>>>>>>>>>>>    
19884>>>>>>>>>>>    // Get the next argument
19884>>>>>>>>>>>    Function SQLGetNextArgument Returns String
19886>>>>>>>>>>>        Integer iArgnum
19886>>>>>>>>>>>        String  sResult
19886>>>>>>>>>>>        
19886>>>>>>>>>>>        Get piLastArgument to iArgnum
19887>>>>>>>>>>>        Increment iArgnum
19888>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
19889>>>>>>>>>>>        Set piLastArgument to iArgnum
19890>>>>>>>>>>>        
19890>>>>>>>>>>>        Function_Return sResult
19891>>>>>>>>>>>    End_Function
19892>>>>>>>>>>>    
19892>>>>>>>>>>>    
19892>>>>>>>>>>>    
19892>>>>>>>>>>>    // Get the specified argument from a procedure
19892>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
19894>>>>>>>>>>>        Integer ihdbc
19894>>>>>>>>>>>        Integer ihstmt
19894>>>>>>>>>>>        String  sDrvrId
19894>>>>>>>>>>>        Integer iVoid
19894>>>>>>>>>>>        String  sEmpty
19894>>>>>>>>>>>        String  sArgument
19894>>>>>>>>>>>        Integer iLen
19894>>>>>>>>>>>        
19894>>>>>>>>>>>        // Initialize
19894>>>>>>>>>>>        Move "" to sEmpty
19895>>>>>>>>>>>        Move "" to sArgument
19896>>>>>>>>>>>        
19896>>>>>>>>>>>        // Get the cli handles
19896>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19897>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19898>>>>>>>>>>>        Get psDriverId            to sDrvrId
19899>>>>>>>>>>>        
19899>>>>>>>>>>>        // Call the procedure
19899>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19901>>>>>>>>>>>            // Pass the information
19901>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
19906>>>>>>>>>>>            
19906>>>>>>>>>>>            // Get the length
19906>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
19911>>>>>>>>>>>            
19911>>>>>>>>>>>            If (iLen) Begin
19913>>>>>>>>>>>                // Allocate
19913>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sArgument
19914>>>>>>>>>>>                
19914>>>>>>>>>>>                // Pass the argument
19914>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
19919>>>>>>>>>>>            End
19919>>>>>>>>>>>>
19919>>>>>>>>>>>        End
19919>>>>>>>>>>>>
19919>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
19921>>>>>>>>>>>        
19921>>>>>>>>>>>        Function_Return sArgument
19922>>>>>>>>>>>    End_Function
19923>>>>>>>>>>>    
19923>>>>>>>>>>>    
19923>>>>>>>>>>>    // Get the return value of a stored function
19923>>>>>>>>>>>    Function SQLReturnValue Returns String
19925>>>>>>>>>>>        Integer ihdbc
19925>>>>>>>>>>>        Integer ihstmt
19925>>>>>>>>>>>        String  sDrvrId
19925>>>>>>>>>>>        Integer iVoid
19925>>>>>>>>>>>        String  sEmpty
19925>>>>>>>>>>>        String  sRetval
19925>>>>>>>>>>>        Integer iLen
19925>>>>>>>>>>>        
19925>>>>>>>>>>>        // Initialize
19925>>>>>>>>>>>        Move "" to sEmpty
19926>>>>>>>>>>>        Move "" to sRetval
19927>>>>>>>>>>>        
19927>>>>>>>>>>>        // Get the cli handles
19927>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19928>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19929>>>>>>>>>>>        Get psDriverId            to sDrvrId
19930>>>>>>>>>>>        
19930>>>>>>>>>>>        // Call the procedure
19930>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19932>>>>>>>>>>>            // Get the length
19932>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
19937>>>>>>>>>>>            
19937>>>>>>>>>>>            If (iLen) Begin
19939>>>>>>>>>>>                // Allocate
19939>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sRetval
19940>>>>>>>>>>>                
19940>>>>>>>>>>>                // Pass the argument
19940>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
19945>>>>>>>>>>>            End
19945>>>>>>>>>>>>
19945>>>>>>>>>>>        End
19945>>>>>>>>>>>>
19945>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
19947>>>>>>>>>>>        
19947>>>>>>>>>>>        Function_Return sRetval
19948>>>>>>>>>>>    End_Function
19949>>>>>>>>>>>    
19949>>>>>>>>>>>    
19949>>>>>>>>>>>    // Switch to the next set
19949>>>>>>>>>>>    // Returns : 0   = No more result sets
19949>>>>>>>>>>>    //     <>0 = Switched to next set
19949>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
19951>>>>>>>>>>>        Integer ihdbc
19951>>>>>>>>>>>        Integer ihstmt
19951>>>>>>>>>>>        String  sDrvrId
19951>>>>>>>>>>>        Integer iResult
19951>>>>>>>>>>>        String  sEmpty
19951>>>>>>>>>>>        
19951>>>>>>>>>>>        // Initialize
19951>>>>>>>>>>>        Move "" to sEmpty
19952>>>>>>>>>>>        Move 0  to iResult
19953>>>>>>>>>>>        
19953>>>>>>>>>>>        // Get the cli handles
19953>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19954>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19955>>>>>>>>>>>        Get psDriverId            to sDrvrId
19956>>>>>>>>>>>        
19956>>>>>>>>>>>        // Call the procedure
19956>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19958>>>>>>>>>>>            // Get the length
19958>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
19963>>>>>>>>>>>            
19963>>>>>>>>>>>            Send SQLGetStatementAttributes
19964>>>>>>>>>>>            Set piLastArgument to 0
19965>>>>>>>>>>>        End
19965>>>>>>>>>>>>
19965>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
19967>>>>>>>>>>>        
19967>>>>>>>>>>>        Function_Return iResult
19968>>>>>>>>>>>    End_Function
19969>>>>>>>>>>>    
19969>>>>>>>>>>>    
19969>>>>>>>>>>>    // Setup a file that will be acivated after a succesfull
19969>>>>>>>>>>>    //fetch on the statement
19969>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
19971>>>>>>>>>>>        Integer ihdbc
19971>>>>>>>>>>>        Integer ihstmt
19971>>>>>>>>>>>        String  sDrvrId
19971>>>>>>>>>>>        Integer iResult
19971>>>>>>>>>>>        Integer bIsOpen
19971>>>>>>>>>>>        Integer iVoid
19971>>>>>>>>>>>        String  sFileType
19971>>>>>>>>>>>        
19971>>>>>>>>>>>        // Check if file is open
19971>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
19974>>>>>>>>>>>        If (bIsOpen) Begin
19976>>>>>>>>>>>            // Get the cli handles
19976>>>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
19977>>>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
19978>>>>>>>>>>>            Get psDriverId            to sDrvrId
19979>>>>>>>>>>>            
19979>>>>>>>>>>>            // Call the procedure
19979>>>>>>>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19981>>>>>>>>>>>                // Check if the file has the correct type
19981>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
19984>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
19986>>>>>>>>>>>                    // Setup the buffer
19986>>>>>>>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
19991>>>>>>>>>>>                End
19991>>>>>>>>>>>>
19991>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
19993>>>>>>>>>>>            End
19993>>>>>>>>>>>>
19993>>>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
19995>>>>>>>>>>>        End
19995>>>>>>>>>>>>
19995>>>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
19997>>>>>>>>>>>    End_Procedure
19998>>>>>>>>>>>    
19998>>>>>>>>>>>    
19998>>>>>>>>>>>    
19998>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
20000>>>>>>>>>>>        Integer ihdbc
20000>>>>>>>>>>>        Integer ihstmt
20000>>>>>>>>>>>        String  sDrvrId
20000>>>>>>>>>>>        String  sMessage
20000>>>>>>>>>>>        Integer iVoid
20000>>>>>>>>>>>        
20000>>>>>>>>>>>        // Initialize
20000>>>>>>>>>>>        Move "" to sMessage
20001>>>>>>>>>>>        
20001>>>>>>>>>>>        // Get the cli handles
20001>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20002>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20003>>>>>>>>>>>        Get psDriverId            to sDrvrId
20004>>>>>>>>>>>        
20004>>>>>>>>>>>        // Call the procedure
20004>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20006>>>>>>>>>>>            // Setup function arguments
20006>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
20011>>>>>>>>>>>            
20011>>>>>>>>>>>            Move (Repeat(' ', 1024)) to sMessage
20012>>>>>>>>>>>            // Get the length
20012>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
20017>>>>>>>>>>>        End
20017>>>>>>>>>>>>
20017>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
20019>>>>>>>>>>>        
20019>>>>>>>>>>>        Function_Return sMessage
20020>>>>>>>>>>>    End_Function
20021>>>>>>>>>>>    
20021>>>>>>>>>>>    
20021>>>>>>>>>>>    
20021>>>>>>>>>>>    // Remove the component identifier from a diagnostic message
20021>>>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
20023>>>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
20027>>>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
20028>>>>>>>>>>>        Loop
20029>>>>>>>>>>>>
20029>>>>>>>>>>>        
20029>>>>>>>>>>>        Function_Return sDiagMessage
20030>>>>>>>>>>>    End_Function
20031>>>>>>>>>>>    
20031>>>>>>>>>>>    
20031>>>>>>>>>>>    
20031>>>>>>>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
20031>>>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
20033>>>>>>>>>>>        
20033>>>>>>>>>>>        Integer iType
20033>>>>>>>>>>>        String  sSQLDate
20033>>>>>>>>>>>        Integer iOrgDateFmt
20033>>>>>>>>>>>        Integer iOrgDateSep
20033>>>>>>>>>>>        
20033>>>>>>>>>>>        String sDriverId
20033>>>>>>>>>>>        String sDummyZeroDate
20033>>>>>>>>>>>        String sDummyZeroDateMssqlDatetime
20033>>>>>>>>>>>        
20033>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
20033>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
20036>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20039>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
20042>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
20045>>>>>>>>>>>        
20045>>>>>>>>>>>        // We only need to convert if the date is 0
20045>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
20047>>>>>>>>>>>            
20047>>>>>>>>>>>            If (num_arguments < 2) Begin
20049>>>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
20050>>>>>>>>>>>            End
20050>>>>>>>>>>>>
20050>>>>>>>>>>>            Else Begin
20051>>>>>>>>>>>                Move iSQLType to iType
20052>>>>>>>>>>>            End
20052>>>>>>>>>>>>
20052>>>>>>>>>>>            
20052>>>>>>>>>>>            
20052>>>>>>>>>>>            Get psDriverID to sDriverId
20053>>>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
20054>>>>>>>>>>>            
20054>>>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
20056>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20057>>>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
20058>>>>>>>>>>>            End
20058>>>>>>>>>>>>
20058>>>>>>>>>>>            Else Begin
20059>>>>>>>>>>>                Move sDummyZeroDate to sSQLDate
20060>>>>>>>>>>>            End
20060>>>>>>>>>>>>
20060>>>>>>>>>>>            
20060>>>>>>>>>>>        End
20060>>>>>>>>>>>>
20060>>>>>>>>>>>        Else Begin
20061>>>>>>>>>>>            Move dDFDate to sSQLDate
20062>>>>>>>>>>>        End
20062>>>>>>>>>>>>
20062>>>>>>>>>>>        
20062>>>>>>>>>>>        // Change date format back to original
20062>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
20065>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20068>>>>>>>>>>>        
20068>>>>>>>>>>>        Function_Return sSQLDate
20069>>>>>>>>>>>    End_Function
20070>>>>>>>>>>>    
20070>>>>>>>>>>>    
20070>>>>>>>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
20070>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
20072>>>>>>>>>>>        
20072>>>>>>>>>>>        Integer iType
20072>>>>>>>>>>>        Date    dDFDate
20072>>>>>>>>>>>        Integer iOrgDateFmt
20072>>>>>>>>>>>        Integer iOrgDateSep
20072>>>>>>>>>>>        
20072>>>>>>>>>>>        String  sDriverId
20072>>>>>>>>>>>        String  sDummyZeroDate
20072>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
20072>>>>>>>>>>>        
20072>>>>>>>>>>>        Get psDriverID to sDriverId
20073>>>>>>>>>>>        
20073>>>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
20074>>>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20075>>>>>>>>>>>        
20075>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
20078>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20081>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
20084>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
20087>>>>>>>>>>>        
20087>>>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
20088>>>>>>>>>>>        
20088>>>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
20090>>>>>>>>>>>            Move 0 to dDFDate
20091>>>>>>>>>>>        End
20091>>>>>>>>>>>>
20091>>>>>>>>>>>        Else Begin
20092>>>>>>>>>>>            Move sSQLDate to dDFDate
20093>>>>>>>>>>>        End
20093>>>>>>>>>>>>
20093>>>>>>>>>>>        
20093>>>>>>>>>>>        // Change date format back to original
20093>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
20096>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20099>>>>>>>>>>>        
20099>>>>>>>>>>>        Function_Return dDFDate
20100>>>>>>>>>>>    End_Function
20101>>>>>>>>>>>    
20101>>>>>>>>>>>End_Class
20102>>>>>>>>>>>
20102>>>>>>>>>>>
20102>>>>>>>>>>>// Connection object for embedded SQL                          
20102>>>>>>>>>>>// This provides the ability to create a connection for a driver.     
20102>>>>>>>>>>>// It will contain child statement objects                            
20102>>>>>>>>>>>
20102>>>>>>>>>>>Class cSQLConnection is a cObject
20103>>>>>>>>>>>    
20103>>>>>>>>>>>    Procedure Construct_object
20105>>>>>>>>>>>        Forward Send Construct_object
20107>>>>>>>>>>>        
20107>>>>>>>>>>>        Property Integer phCLIConnectionHandle       0
20108>>>>>>>>>>>        
20108>>>>>>>>>>>        Property String  psDriverID        ""
20109>>>>>>>>>>>        Property Integer piBindFile        0
20110>>>>>>>>>>>        
20110>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
20111>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
20112>>>>>>>>>>>        
20112>>>>>>>>>>>    End_Procedure
20113>>>>>>>>>>>    
20113>>>>>>>>>>>    
20113>>>>>>>>>>>    
20113>>>>>>>>>>>    // Store basic information about the connection
20113>>>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
20115>>>>>>>>>>>        
20115>>>>>>>>>>>        String sDummyZeroDate
20115>>>>>>>>>>>        Integer iDriverIndex
20115>>>>>>>>>>>        
20115>>>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
20116>>>>>>>>>>>        Set psDriverID            to sDrvrId
20117>>>>>>>>>>>        
20117>>>>>>>>>>>        Case Begin
20117>>>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
20119>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
20120>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
20121>>>>>>>>>>>                Break
20122>>>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
20125>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
20126>>>>>>>>>>>                Break
20127>>>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
20130>>>>>>>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
20131>>>>>>>>>>>                If (iDriverIndex <> 0) Begin
20133>>>>>>>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
20136>>>>>>>>>>>                End
20136>>>>>>>>>>>>
20136>>>>>>>>>>>                Else Begin
20137>>>>>>>>>>>                    Move '0001-01-01' to sDummyZeroDate
20138>>>>>>>>>>>                End
20138>>>>>>>>>>>>
20138>>>>>>>>>>>
20138>>>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
20139>>>>>>>>>>>                Break
20140>>>>>>>>>>>                
20140>>>>>>>>>>>        Case End
20140>>>>>>>>>>>        
20140>>>>>>>>>>>    End_Procedure
20141>>>>>>>>>>>    
20141>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
20143>>>>>>>>>>>        
20143>>>>>>>>>>>        String  sCurrentDriver
20143>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
20143>>>>>>>>>>>        
20143>>>>>>>>>>>        Move 0 to iDriver
20144>>>>>>>>>>>        
20144>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
20147>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
20153>>>>>>>>>>>>
20153>>>>>>>>>>>            
20153>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
20156>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
20158>>>>>>>>>>>                Move iCount to iDriver
20159>>>>>>>>>>>            End
20159>>>>>>>>>>>>
20159>>>>>>>>>>>        Loop
20160>>>>>>>>>>>>
20160>>>>>>>>>>>        
20160>>>>>>>>>>>        Function_Return iDriver
20161>>>>>>>>>>>        
20161>>>>>>>>>>>    End_Function
20162>>>>>>>>>>>
20162>>>>>>>>>>>    
20162>>>>>>>>>>>    // Destroy the SQLConnection object
20162>>>>>>>>>>>    Procedure DestroySQLConnection
20164>>>>>>>>>>>        Send Destroy
20165>>>>>>>>>>>    End_Procedure
20166>>>>>>>>>>>    
20166>>>>>>>>>>>    
20166>>>>>>>>>>>    // Connect to a database server
20166>>>>>>>>>>>    // Returns : 1 Succesfully connected
20166>>>>>>>>>>>    //           0 Not connected
20166>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
20168>>>>>>>>>>>        Integer ihdbc
20168>>>>>>>>>>>        String  sEmpty
20168>>>>>>>>>>>        
20168>>>>>>>>>>>        // Initialize
20168>>>>>>>>>>>        Move "" to sEmpty
20169>>>>>>>>>>>        Move 0  to ihdbc
20170>>>>>>>>>>>        
20170>>>>>>>>>>>        Move False to Err
20171>>>>>>>>>>>        
20171>>>>>>>>>>>        // Call the driver function to connect
20171>>>>>>>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
20176>>>>>>>>>>>        
20176>>>>>>>>>>>        // If there was an error, make result invalid
20176>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
20179>>>>>>>>>>>        
20179>>>>>>>>>>>        // Check result and store it
20179>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
20182>>>>>>>>>>>        
20182>>>>>>>>>>>        // Return success status
20182>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20183>>>>>>>>>>>    End_Function
20184>>>>>>>>>>>    
20184>>>>>>>>>>>    
20184>>>>>>>>>>>    // Use a connection of an already open file
20184>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
20186>>>>>>>>>>>        Integer ihdbc
20186>>>>>>>>>>>        Integer bIsOpen
20186>>>>>>>>>>>        String  sDrvrId
20186>>>>>>>>>>>        String  sEmpty
20186>>>>>>>>>>>        
20186>>>>>>>>>>>        // Initialize
20186>>>>>>>>>>>        Move "" to sEmpty
20187>>>>>>>>>>>        Move 0  to ihdbc
20188>>>>>>>>>>>        
20188>>>>>>>>>>>        // Check if file is open
20188>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
20191>>>>>>>>>>>        If (bIsOpen) Begin
20193>>>>>>>>>>>            // Fill the driver id, assume longest is 255 characters
20193>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDrvrId
20194>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
20197>>>>>>>>>>>            
20197>>>>>>>>>>>            Move False to Err
20198>>>>>>>>>>>            
20198>>>>>>>>>>>            // Call the driver function to connect
20198>>>>>>>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
20203>>>>>>>>>>>            
20203>>>>>>>>>>>            // If there was an error, make result invalid
20203>>>>>>>>>>>            If (Err) ;                Move 0 to ihdbc
20206>>>>>>>>>>>            
20206>>>>>>>>>>>            // Check result and store it
20206>>>>>>>>>>>            If (ihdbc <> 0) Begin
20208>>>>>>>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
20208>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
20211>>>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
20212>>>>>>>>>>>                
20212>>>>>>>>>>>                // Set filenum so it can be used for fetching
20212>>>>>>>>>>>                Set piBindFile to iFileNum
20213>>>>>>>>>>>            End
20213>>>>>>>>>>>>
20213>>>>>>>>>>>        End
20213>>>>>>>>>>>>
20213>>>>>>>>>>>        
20213>>>>>>>>>>>        // Return success status
20213>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20214>>>>>>>>>>>    End_Function
20215>>>>>>>>>>>    
20215>>>>>>>>>>>    
20215>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
20215>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
20215>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
20215>>>>>>>>>>>    // The connectstring must be an exact match, but can be case insensitive
20215>>>>>>>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
20215>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
20215>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
20215>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
20217>>>>>>>>>>>        Integer ihdbc
20217>>>>>>>>>>>        String  sEmpty
20217>>>>>>>>>>>        Integer iFileNum
20217>>>>>>>>>>>        
20217>>>>>>>>>>>        // Initialize
20217>>>>>>>>>>>        Move "" to sEmpty
20218>>>>>>>>>>>        Move 0  to ihdbc
20219>>>>>>>>>>>        
20219>>>>>>>>>>>        Move False to Err
20220>>>>>>>>>>>        
20220>>>>>>>>>>>        // Call the driver function
20220>>>>>>>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
20220>>>>>>>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
20220>>>>>>>>>>>        Move 0 to iFileNum
20221>>>>>>>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
20226>>>>>>>>>>>        
20226>>>>>>>>>>>        // If there was an error, make result invalid
20226>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
20229>>>>>>>>>>>        
20229>>>>>>>>>>>        // Check result and store it
20229>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
20232>>>>>>>>>>>        
20232>>>>>>>>>>>        // Return success status
20232>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20233>>>>>>>>>>>    End_Function
20234>>>>>>>>>>>    
20234>>>>>>>>>>>    
20234>>>>>>>>>>>    // Disconnect from an embedded SQL server and free allocated
20234>>>>>>>>>>>    // resources
20234>>>>>>>>>>>    Procedure SQLDisconnect
20236>>>>>>>>>>>        Integer ihdbc
20236>>>>>>>>>>>        Integer iVoid
20236>>>>>>>>>>>        String  sDrvrId
20236>>>>>>>>>>>        String  sEmpty
20236>>>>>>>>>>>        
20236>>>>>>>>>>>        // Initialize
20236>>>>>>>>>>>        Move "" to sEmpty
20237>>>>>>>>>>>        
20237>>>>>>>>>>>        // Get the cli handle
20237>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20238>>>>>>>>>>>        Get psDriverId to sDrvrId
20239>>>>>>>>>>>        
20239>>>>>>>>>>>        // Free the CLI handle
20239>>>>>>>>>>>        If (ihdbc <> 0) Begin
20241>>>>>>>>>>>            // Call the driver function to disconnect
20241>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
20246>>>>>>>>>>>            
20246>>>>>>>>>>>            Move -1 to giLastSQLhdbc
20247>>>>>>>>>>>            
20247>>>>>>>>>>>            // Free the DataFlex handle
20247>>>>>>>>>>>            Send DestroySQLConnection
20248>>>>>>>>>>>        End
20248>>>>>>>>>>>>
20248>>>>>>>>>>>    End_Procedure
20249>>>>>>>>>>>    
20249>>>>>>>>>>>    // Create a cSQLStatement object
20249>>>>>>>>>>>    Function CreateSQLStatement Returns Handle
20251>>>>>>>>>>>        
20251>>>>>>>>>>>        Handle hoSQLStatement
20251>>>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
20252>>>>>>>>>>>        
20252>>>>>>>>>>>        // If the connection has a default Bind File, assign it to the
20252>>>>>>>>>>>        // statement object. The default is set when you open a file with a
20252>>>>>>>>>>>        // SetFileConnection command.
20252>>>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
20253>>>>>>>>>>>        
20253>>>>>>>>>>>        Function_Return hoSQLStatement
20254>>>>>>>>>>>    End_Function
20255>>>>>>>>>>>    
20255>>>>>>>>>>>    
20255>>>>>>>>>>>    // Open a statement for use
20255>>>>>>>>>>>    Function SQLOpen Returns Handle
20257>>>>>>>>>>>        Handle  hoSQLStatement
20257>>>>>>>>>>>        Integer ihdbc
20257>>>>>>>>>>>        Integer ihstmt
20257>>>>>>>>>>>        Integer iVoid
20257>>>>>>>>>>>        String  sDrvrId
20257>>>>>>>>>>>        String  sEmpty
20257>>>>>>>>>>>        String  sDummyZeroDate
20257>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
20257>>>>>>>>>>>        
20257>>>>>>>>>>>        // Initialize
20257>>>>>>>>>>>        Move "" to sEmpty
20258>>>>>>>>>>>        
20258>>>>>>>>>>>        // Get the cli handle to the connection
20258>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20259>>>>>>>>>>>        Get psDriverId  to sDrvrId
20260>>>>>>>>>>>        
20260>>>>>>>>>>>        // Allocate a new handle and populate it
20260>>>>>>>>>>>        If (ihdbc <> 0) Begin
20262>>>>>>>>>>>            // Create a new cSQLStatement object
20262>>>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
20263>>>>>>>>>>>            
20263>>>>>>>>>>>            // Call the driver function to allocate a cli statement handle
20263>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
20268>>>>>>>>>>>            
20268>>>>>>>>>>>            // If unsuccessful destroy hoSQLStatement
20268>>>>>>>>>>>            If (ihstmt = 0) Begin
20270>>>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
20271>>>>>>>>>>>                Move 0 to hoSQLStatement
20272>>>>>>>>>>>            End
20272>>>>>>>>>>>>
20272>>>>>>>>>>>            Else Begin
20273>>>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
20274>>>>>>>>>>>                
20274>>>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
20274>>>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
20275>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20276>>>>>>>>>>>                
20276>>>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
20277>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
20278>>>>>>>>>>>                
20278>>>>>>>>>>>            End
20278>>>>>>>>>>>>
20278>>>>>>>>>>>        End
20278>>>>>>>>>>>>
20278>>>>>>>>>>>        
20278>>>>>>>>>>>        Function_Return hoSQLStatement
20279>>>>>>>>>>>    End_Function
20280>>>>>>>>>>>    
20280>>>>>>>>>>>End_Class
20281>>>>>>>>>>>
20281>>>>>>>>>>>// Manager for embedded SQL handles.                           
20281>>>>>>>>>>>// We want to be able to use multiple drivers and multiple            
20281>>>>>>>>>>>// connections within a driver and multiple statements within a       
20281>>>>>>>>>>>// connection. To allow this we have placed our own handle logic on   
20281>>>>>>>>>>>// top of the driver handle logic. This way we can handle the         
20281>>>>>>>>>>>// situation where two driver handles may be equal.                   
20281>>>>>>>>>>>
20281>>>>>>>>>>>Class cSQLHandleManager is a cObject
20282>>>>>>>>>>>    
20282>>>>>>>>>>>    Procedure Construct_object
20284>>>>>>>>>>>        Forward Send Construct_object
20286>>>>>>>>>>>        
20286>>>>>>>>>>>        Property String  psDefaultDriver      ""
20287>>>>>>>>>>>        Property String  psDefaultConnection  ""
20288>>>>>>>>>>>        
20288>>>>>>>>>>>    End_Procedure
20289>>>>>>>>>>>    
20289>>>>>>>>>>>    // Create a cSQLConnection object
20289>>>>>>>>>>>    Function CreateSQLConnection Returns Handle
20291>>>>>>>>>>>        Handle hoSQLConnection
20291>>>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
20292>>>>>>>>>>>        Function_Return hoSQLConnection
20293>>>>>>>>>>>    End_Function
20294>>>>>>>>>>>    
20294>>>>>>>>>>>    
20294>>>>>>>>>>>    // Store default connection information
20294>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
20296>>>>>>>>>>>        Set psDefaultDriver      to sDriver
20297>>>>>>>>>>>        Set psDefaultConnection  to sConnect
20298>>>>>>>>>>>    End_Procedure
20299>>>>>>>>>>>    
20299>>>>>>>>>>>    
20299>>>>>>>>>>>    // Make a connection to an embedded SQL server
20299>>>>>>>>>>>    // Returns : The DataFlex handle to the connection
20299>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
20301>>>>>>>>>>>        Handle hoSQLConnection
20301>>>>>>>>>>>        Integer bOK
20301>>>>>>>>>>>        
20301>>>>>>>>>>>        // Check arguments
20301>>>>>>>>>>>        If (sDrvrID = "" and sConnect = "") Begin
20303>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
20304>>>>>>>>>>>            Get psDefaultConnection  to sConnect
20305>>>>>>>>>>>        End
20305>>>>>>>>>>>>
20305>>>>>>>>>>>        
20305>>>>>>>>>>>        // Create a cSQLConnection object
20305>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20306>>>>>>>>>>>        // Connect to the database
20306>>>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
20307>>>>>>>>>>>        
20307>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20307>>>>>>>>>>>        If (not(bOK)) Begin
20309>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20310>>>>>>>>>>>            Move 0 to hoSQLConnection
20311>>>>>>>>>>>        End
20311>>>>>>>>>>>>
20311>>>>>>>>>>>        
20311>>>>>>>>>>>        Function_Return hoSQLConnection
20312>>>>>>>>>>>    End_Function
20313>>>>>>>>>>>    
20313>>>>>>>>>>>    
20313>>>>>>>>>>>    
20313>>>>>>>>>>>    // Make an existing connection available for use with Embedded SQL.
20313>>>>>>>>>>>    // The connection is identified by the number of a file
20313>>>>>>>>>>>    // that is open for that connection.
20313>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
20315>>>>>>>>>>>        Handle hoSQLConnection
20315>>>>>>>>>>>        Integer bOK
20315>>>>>>>>>>>        
20315>>>>>>>>>>>        // Create a cSQLConnection object
20315>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20316>>>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
20317>>>>>>>>>>>        
20317>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20317>>>>>>>>>>>        If (not(bOK)) Begin
20319>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20320>>>>>>>>>>>            Move 0 to hoSQLConnection
20321>>>>>>>>>>>        End
20321>>>>>>>>>>>>
20321>>>>>>>>>>>        
20321>>>>>>>>>>>        Function_Return hoSQLConnection
20322>>>>>>>>>>>    End_Function
20323>>>>>>>>>>>    
20323>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
20323>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
20323>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
20323>>>>>>>>>>>    // The connectstrings must be an exact match, but can be case insensitive
20323>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
20323>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
20323>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
20325>>>>>>>>>>>        Handle hoSQLConnection
20325>>>>>>>>>>>        Integer bOK
20325>>>>>>>>>>>        
20325>>>>>>>>>>>        // Check arguments
20325>>>>>>>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
20327>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
20328>>>>>>>>>>>            Get psDefaultConnection  to sConnectString
20329>>>>>>>>>>>        End
20329>>>>>>>>>>>>
20329>>>>>>>>>>>        
20329>>>>>>>>>>>        // Create a cSQLConnection object
20329>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20330>>>>>>>>>>>        // Connect to the database
20330>>>>>>>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
20331>>>>>>>>>>>        
20331>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20331>>>>>>>>>>>        If (not(bOK)) Begin
20333>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20334>>>>>>>>>>>            Move 0 to hoSQLConnection
20335>>>>>>>>>>>        End
20335>>>>>>>>>>>>
20335>>>>>>>>>>>        
20335>>>>>>>>>>>        Function_Return hoSQLConnection
20336>>>>>>>>>>>    End_Function
20337>>>>>>>>>>>    
20337>>>>>>>>>>>    
20337>>>>>>>>>>>End_Class
20338>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\MSSqldrv.pkg)
20338>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
20338>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
20338>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
20338>>>>>>>>>>>
20338>>>>>>>>>>>Use Cli.pkg
20338>>>>>>>>>>>Use SQL.pkg
20338>>>>>>>>>>>
20338>>>>>>>>>>>//   Driver Indentification
20338>>>>>>>>>>>
20338>>>>>>>>>>>//   Error number constants
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>// SQL Server spcific types.
20338>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
20338>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
20338>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
20338>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
20338>>>>>>>>>>>
20338>>>>>>>>>>>// SQL Server spcific types.
20338>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
20338>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
20338>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
20338>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
20338>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
20338>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
20338>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
20338>>>>>>>>>>>//
20338>>>>>>>>>>>//     Setup a constraint for a file.
20338>>>>>>>>>>>
20338>>>>>>>>>>>
20338>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
20339>>>>>>>>>>>    
20339>>>>>>>>>>>    Procedure Construct_Object
20341>>>>>>>>>>>        Forward Send Construct_Object
20343>>>>>>>>>>>        
20343>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
20344>>>>>>>>>>>    End_Procedure
20345>>>>>>>>>>>    
20345>>>>>>>>>>>    
20345>>>>>>>>>>>    
20345>>>>>>>>>>>    //   Extract the list from the out connect string.
20345>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
20347>>>>>>>>>>>        String  sItem
20347>>>>>>>>>>>        Integer iStart
20347>>>>>>>>>>>        Integer iEnd
20347>>>>>>>>>>>        
20347>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
20350>>>>>>>>>>>        
20350>>>>>>>>>>>        Send Delete_Data to hoStore
20351>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
20352>>>>>>>>>>>        While (iStart > 0)
20356>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
20357>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
20360>>>>>>>>>>>            Else Begin
20361>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
20362>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
20363>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
20366>>>>>>>>>>>                
20366>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
20369>>>>>>>>>>>                
20369>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
20372>>>>>>>>>>>            End
20372>>>>>>>>>>>>
20372>>>>>>>>>>>        Loop
20373>>>>>>>>>>>>
20373>>>>>>>>>>>        
20373>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
20374>>>>>>>>>>>    End_Procedure
20375>>>>>>>>>>>    
20375>>>>>>>>>>>    
20375>>>>>>>>>>>    
20375>>>>>>>>>>>    //   Call the driver's browse connect function
20375>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
20377>>>>>>>>>>>        String  sDriver
20377>>>>>>>>>>>        String  sOutConnStr
20377>>>>>>>>>>>        Integer iArg
20377>>>>>>>>>>>        Integer iRetval
20377>>>>>>>>>>>        
20377>>>>>>>>>>>        Get psDriverID to sDriver
20378>>>>>>>>>>>        If (sDriver <> "") Begin
20380>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
20381>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
20386>>>>>>>>>>>        End
20386>>>>>>>>>>>>
20386>>>>>>>>>>>        
20386>>>>>>>>>>>        Function_Return sOutConnStr
20387>>>>>>>>>>>    End_Function// BrowseConnect
20388>>>>>>>>>>>    
20388>>>>>>>>>>>    
20388>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
20390>>>>>>>>>>>        String  sDriver
20390>>>>>>>>>>>        String  sOutConnStr
20390>>>>>>>>>>>        Integer iArg
20390>>>>>>>>>>>        Integer iRetval
20390>>>>>>>>>>>        
20390>>>>>>>>>>>        Move 1 to iArg // Browses only local
20391>>>>>>>>>>>        
20391>>>>>>>>>>>        Get psDriverID to sDriver
20392>>>>>>>>>>>        If (sDriver <> "") Begin
20394>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
20395>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
20400>>>>>>>>>>>        End
20400>>>>>>>>>>>>
20400>>>>>>>>>>>        
20400>>>>>>>>>>>        Function_Return sOutConnStr
20401>>>>>>>>>>>    End_Function// BrowseConnect
20402>>>>>>>>>>>    
20402>>>>>>>>>>>    
20402>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
20404>>>>>>>>>>>        
20404>>>>>>>>>>>        String  sServerList
20404>>>>>>>>>>>        Integer iNumServers
20404>>>>>>>>>>>        Integer iDriver
20404>>>>>>>>>>>        Integer iClientVersion
20404>>>>>>>>>>>        String  sDriver
20404>>>>>>>>>>>        
20404>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
20405>>>>>>>>>>>        
20405>>>>>>>>>>>        If (iDriver) Begin
20407>>>>>>>>>>>            
20407>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
20410>>>>>>>>>>>            
20410>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
20411>>>>>>>>>>>            
20411>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
20412>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
20414>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
20415>>>>>>>>>>>            End
20415>>>>>>>>>>>>
20415>>>>>>>>>>>            Else Begin
20416>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
20417>>>>>>>>>>>            End
20417>>>>>>>>>>>>
20417>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
20418>>>>>>>>>>>        End
20418>>>>>>>>>>>>
20418>>>>>>>>>>>        
20418>>>>>>>>>>>        Function_Return iNumServers
20419>>>>>>>>>>>        
20419>>>>>>>>>>>    End_Function
20420>>>>>>>>>>>    
20420>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
20420>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
20420>>>>>>>>>>>    //   This may take a long time.
20420>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
20420>>>>>>>>>>>    Function EnumerateServers Returns Integer
20422>>>>>>>>>>>        
20422>>>>>>>>>>>        Integer iNumServers
20422>>>>>>>>>>>        Integer iNetworkLocal
20422>>>>>>>>>>>        
20422>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
20423>>>>>>>>>>>        
20423>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
20424>>>>>>>>>>>        
20424>>>>>>>>>>>        Function_Return iNumServers
20425>>>>>>>>>>>        
20425>>>>>>>>>>>    End_Function
20426>>>>>>>>>>>    
20426>>>>>>>>>>>    
20426>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
20426>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
20426>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
20426>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
20428>>>>>>>>>>>        
20428>>>>>>>>>>>        Integer iNumServers
20428>>>>>>>>>>>        Integer iNetworkLocal
20428>>>>>>>>>>>        
20428>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
20429>>>>>>>>>>>        
20429>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
20430>>>>>>>>>>>        
20430>>>>>>>>>>>        Function_Return iNumServers
20431>>>>>>>>>>>        
20431>>>>>>>>>>>    End_Function
20432>>>>>>>>>>>    
20432>>>>>>>>>>>    
20432>>>>>>>>>>>    
20432>>>>>>>>>>>    //   Enumerate database in a given server.
20432>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
20434>>>>>>>>>>>        Integer hoSQL
20434>>>>>>>>>>>        String  sConnect
20434>>>>>>>>>>>        String  sDatabase
20434>>>>>>>>>>>        Integer hdbc
20434>>>>>>>>>>>        Integer hstmt
20434>>>>>>>>>>>        Integer iFetchResult
20434>>>>>>>>>>>        
20434>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
20437>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
20440>>>>>>>>>>>        
20440>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
20443>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
20445>>>>>>>>>>>        
20445>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
20447>>>>>>>>>>>            Move Current_Object to hoSQL
20448>>>>>>>>>>>        End_Object
20449>>>>>>>>>>>        
20449>>>>>>>>>>>        If (hoSQL <> 0) Begin
20451>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
20452>>>>>>>>>>>            If (hdbc <> 0) Begin
20454>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
20455>>>>>>>>>>>                If (hstmt <> 0) Begin
20457>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
20457>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
20457>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
20457>>>>>>>>>>>                    //   stay the same.
20457>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
20458>>>>>>>>>>>                    Send SQLCall to hstmt
20459>>>>>>>>>>>                    Repeat
20459>>>>>>>>>>>>
20459>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
20460>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
20462>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
20463>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
20464>>>>>>>>>>>                        End
20464>>>>>>>>>>>>
20464>>>>>>>>>>>                    Until (iFetchResult = 0)
20466>>>>>>>>>>>                    
20466>>>>>>>>>>>                    Send SQLClose to hstmt
20467>>>>>>>>>>>                End
20467>>>>>>>>>>>>
20467>>>>>>>>>>>                Send SQLDisconnect to hdbc
20468>>>>>>>>>>>            End
20468>>>>>>>>>>>>
20468>>>>>>>>>>>        End
20468>>>>>>>>>>>>
20468>>>>>>>>>>>        Send Destroy_Object to hoSQL
20469>>>>>>>>>>>        
20469>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
20470>>>>>>>>>>>    End_Function
20471>>>>>>>>>>>    
20471>>>>>>>>>>>    
20471>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
20473>>>>>>>>>>>        
20473>>>>>>>>>>>        String  sSqlServerClientVersionName
20473>>>>>>>>>>>        
20473>>>>>>>>>>>        
20473>>>>>>>>>>>        Case Begin
20473>>>>>>>>>>>            
20473>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
20475>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
20476>>>>>>>>>>>                Case Break
20477>>>>>>>>>>>                
20477>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
20480>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
20481>>>>>>>>>>>                Case Break
20482>>>>>>>>>>>            
20482>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
20485>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
20486>>>>>>>>>>>                Case Break
20487>>>>>>>>>>>            
20487>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
20490>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
20491>>>>>>>>>>>                Case Break
20492>>>>>>>>>>>            
20492>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
20495>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
20496>>>>>>>>>>>                Case Break
20497>>>>>>>>>>>            
20497>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
20500>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
20501>>>>>>>>>>>                Case Break
20502>>>>>>>>>>>            
20502>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
20505>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
20506>>>>>>>>>>>                Case Break
20507>>>>>>>>>>>            
20507>>>>>>>>>>>            Case Else
20507>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
20508>>>>>>>>>>>                
20508>>>>>>>>>>>        Case End
20508>>>>>>>>>>>        
20508>>>>>>>>>>>        
20508>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
20509>>>>>>>>>>>        
20509>>>>>>>>>>>    End_Function
20510>>>>>>>>>>>
20510>>>>>>>>>>>
20510>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
20512>>>>>>>>>>>        
20512>>>>>>>>>>>        String  sSqlServerClientDriverName
20512>>>>>>>>>>>        
20512>>>>>>>>>>>        Case Begin
20512>>>>>>>>>>>            
20512>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
20514>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
20515>>>>>>>>>>>                Case Break
20516>>>>>>>>>>>                
20516>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
20519>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
20520>>>>>>>>>>>                Case Break
20521>>>>>>>>>>>            
20521>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
20524>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
20525>>>>>>>>>>>                Case Break
20526>>>>>>>>>>>            
20526>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
20529>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
20530>>>>>>>>>>>                Case Break
20531>>>>>>>>>>>            
20531>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
20534>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
20535>>>>>>>>>>>                Case Break
20536>>>>>>>>>>>            
20536>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
20539>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
20540>>>>>>>>>>>                Case Break
20541>>>>>>>>>>>            
20541>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
20544>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
20545>>>>>>>>>>>                Case Break
20546>>>>>>>>>>>            
20546>>>>>>>>>>>            Case Else
20546>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
20547>>>>>>>>>>>                
20547>>>>>>>>>>>        Case End
20547>>>>>>>>>>>        
20547>>>>>>>>>>>        
20547>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
20548>>>>>>>>>>>        
20548>>>>>>>>>>>    End_Function
20549>>>>>>>>>>>    
20549>>>>>>>>>>>    
20549>>>>>>>>>>>End_Class
20550>>>>>>>>>>>
20550>>>>>>>>>>>
20550>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\db2_drv.pkg)
20550>>>>>>>>>>>// DB2_DRV.PKG                                                          
20550>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
20550>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
20550>>>>>>>>>>>//   specific code to a DataFlex application.                           
20550>>>>>>>>>>>
20550>>>>>>>>>>>Use Cli.pkg
20550>>>>>>>>>>>
20550>>>>>>>>>>>// Driver attributes
20550>>>>>>>>>>>
20550>>>>>>>>>>>
20550>>>>>>>>>>>// Driver Indentification
20550>>>>>>>>>>>
20550>>>>>>>>>>>// Error number constants
20550>>>>>>>>>>>
20550>>>>>>>>>>>// Call driver function identifiers
20550>>>>>>>>>>>
20550>>>>>>>>>>>// DB2 specific data types
20550>>>>>>>>>>>Define SQL_CLOB           for   (-99)
20550>>>>>>>>>>>Define SQL_BLOB           for   (-98)
20550>>>>>>>>>>>Define SQL_XML            for   (-370)
20550>>>>>>>>>>>// DB2 Graphic types are Unicode types
20550>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
20550>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
20550>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
20550>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
20550>>>>>>>>>>>
20550>>>>>>>>>>>
20550>>>>>>>>>>>// Extra DB2 commands
20550>>>>>>>>>>>
20550>>>>>>>>>>>
20550>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
20550>>>>>>>>>>>//   Setup a constraint for a file.                                     
20550>>>>>>>>>>>
20550>>>>>>>>>>>
20550>>>>>>>>>>>
20550>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
20551>>>>>>>>>>>    
20551>>>>>>>>>>>    Procedure Construct_Object
20553>>>>>>>>>>>        Forward Send Construct_Object
20555>>>>>>>>>>>        
20555>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
20556>>>>>>>>>>>    End_Procedure
20557>>>>>>>>>>>    
20557>>>>>>>>>>>    
20557>>>>>>>>>>>    
20557>>>>>>>>>>>    // Reset the datasource list to the beginning
20557>>>>>>>>>>>    Procedure SeedDataSources
20559>>>>>>>>>>>        String  sDriver
20559>>>>>>>>>>>        String  sVoid
20559>>>>>>>>>>>        Integer iRetval
20559>>>>>>>>>>>        
20559>>>>>>>>>>>        Get psDriverID to sDriver
20560>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
20567>>>>>>>>>>>    End_Procedure
20568>>>>>>>>>>>    
20568>>>>>>>>>>>    
20568>>>>>>>>>>>    
20568>>>>>>>>>>>    // Call the driver's data sources function
20568>>>>>>>>>>>    Function DataSources Returns String
20570>>>>>>>>>>>        String  sDriver
20570>>>>>>>>>>>        String  sDataSource
20570>>>>>>>>>>>        String  sDescription
20570>>>>>>>>>>>        Integer iLength
20570>>>>>>>>>>>        Integer iRetval
20570>>>>>>>>>>>        
20570>>>>>>>>>>>        Get psDriverID to sDriver
20571>>>>>>>>>>>        If (sDriver <> "") Begin
20573>>>>>>>>>>>            Move 8192 to iLength
20574>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
20575>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
20576>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
20581>>>>>>>>>>>        End
20581>>>>>>>>>>>>
20581>>>>>>>>>>>        
20581>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
20584>>>>>>>>>>>        Else ;            Function_Return ""
20586>>>>>>>>>>>    End_Function
20587>>>>>>>>>>>    
20587>>>>>>>>>>>End_Class
20588>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\odbc_drv.pkg)
20588>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
20588>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
20588>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
20588>>>>>>>>>>>
20588>>>>>>>>>>>Use Cli.pkg
20588>>>>>>>>>>>
20588>>>>>>>>>>>// Driver Indentification
20588>>>>>>>>>>>
20588>>>>>>>>>>>// Error number constants
20588>>>>>>>>>>>
20588>>>>>>>>>>>// Call driver function identifiers
20588>>>>>>>>>>>
20588>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
20589>>>>>>>>>>>    
20589>>>>>>>>>>>    Procedure Construct_Object
20591>>>>>>>>>>>        Forward Send Construct_Object
20593>>>>>>>>>>>        
20593>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
20594>>>>>>>>>>>    End_Procedure
20595>>>>>>>>>>>    
20595>>>>>>>>>>>    
20595>>>>>>>>>>>    
20595>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
20595>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
20597>>>>>>>>>>>        String  sDriver
20597>>>>>>>>>>>        String  sVoid
20597>>>>>>>>>>>        Integer iRetval
20597>>>>>>>>>>>        
20597>>>>>>>>>>>        Get psDriverID to sDriver
20598>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
20605>>>>>>>>>>>    End_Procedure
20606>>>>>>>>>>>    
20606>>>>>>>>>>>    
20606>>>>>>>>>>>    // Call the driver's data sources function
20606>>>>>>>>>>>    Function DataSources Returns String
20608>>>>>>>>>>>        String  sDriver
20608>>>>>>>>>>>        String  sDataSource
20608>>>>>>>>>>>        String  sDescription
20608>>>>>>>>>>>        Integer iLength
20608>>>>>>>>>>>        Integer iRetval
20608>>>>>>>>>>>        
20608>>>>>>>>>>>        Get psDriverID to sDriver
20609>>>>>>>>>>>        If (sDriver <> "") Begin
20611>>>>>>>>>>>            Move 8192 to iLength
20612>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
20613>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
20614>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
20619>>>>>>>>>>>        End
20619>>>>>>>>>>>>
20619>>>>>>>>>>>        
20619>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
20622>>>>>>>>>>>        Else ;            Function_Return ""
20624>>>>>>>>>>>    End_Function
20625>>>>>>>>>>>    
20625>>>>>>>>>>>End_Class
20626>>>>>>>>>>>
20626>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.1\Pkg\DFBTRDRV.PKG)
20626>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
20626>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
20626>>>>>>>>>>>//               specific functions in the DFBTRDRV.
20626>>>>>>>>>>>Use Ui
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Driver Indentification
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>// Driver attributes
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Call_Driver functions ID's
20626>>>>>>>>>>>//
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// DFBTRFN_SET_OWNER options
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to create all vars which may be needed
20626>>>>>>>>>>>// in other commands.
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to set the owner of a Btrieve file.
20626>>>>>>>>>>>// File must have been opened.
20626>>>>>>>>>>>// Filenumber needs to be passed.
20626>>>>>>>>>>>// To clear set the owner to "".
20626>>>>>>>>>>>// Examples:
20626>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
20626>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
20626>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
20626>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
20626>>>>>>>>>>>// To clear:
20626>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
20626>>>>>>>>>>>// options.
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to parse for Callback
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
20626>>>>>>>>>>>// File must have been opened.
20626>>>>>>>>>>>// Filenumber needs to be passed.
20626>>>>>>>>>>>// Examples:
20626>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
20626>>>>>>>>>>>// which will be tries when opening files.
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
20626>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
20626>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
20626>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to change the transaction type.
20626>>>>>>>>>>>// Valid types are:
20626>>>>>>>>>>>//     DFBTRTT_NONE
20626>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
20626>>>>>>>>>>>//     DFBTRTT_CONCURRENT
20626>>>>>>>>>>>//
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to get the current transaction type.
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to set explicit_locking
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to get explicit locking
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>//
20626>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
20626>>>>>>>>>>>//
20626>>>>>>>>>>>
20626>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
20626>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
20626>>>>>>>>>>>
20626>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
20627>>>>>>>>>>>    
20627>>>>>>>>>>>    Procedure Construct_Object Integer iImage
20629>>>>>>>>>>>        Forward Send Construct_object iImage
20631>>>>>>>>>>>        
20631>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
20632>>>>>>>>>>>    End_Procedure
20633>>>>>>>>>>>    
20633>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
20633>>>>>>>>>>>    //
20633>>>>>>>>>>>    
20633>>>>>>>>>>>    Function CKRevision Returns String
20635>>>>>>>>>>>        String  sDriverID
20635>>>>>>>>>>>        String  sRevision
20635>>>>>>>>>>>        String  sVoid
20635>>>>>>>>>>>        Integer iRetval
20635>>>>>>>>>>>        
20635>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20635>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20635>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20635>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20636>>>>>>>>>>>        Get psDriverID to sDriverID
20637>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
20638>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
20643>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20644>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
20646>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20646>>>>>>>>>>>            Move "0.0.0.0" to sRevision
20647>>>>>>>>>>>        End
20647>>>>>>>>>>>>
20647>>>>>>>>>>>        Function_Return sRevision
20648>>>>>>>>>>>    End_Function
20649>>>>>>>>>>>    
20649>>>>>>>>>>>    Function CkUsesUri Returns Integer
20651>>>>>>>>>>>        String  sDriverID
20651>>>>>>>>>>>        String  sVoid1
20651>>>>>>>>>>>        String  sVoid2
20651>>>>>>>>>>>        Integer iRetval
20651>>>>>>>>>>>        
20651>>>>>>>>>>>        Get psDriverID to sDriverID
20652>>>>>>>>>>>        
20652>>>>>>>>>>>        Move 0 to iRetval
20653>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20653>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20653>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
20653>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20654>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
20659>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20660>>>>>>>>>>>        
20660>>>>>>>>>>>        Function_Return iRetval
20661>>>>>>>>>>>    End_Function
20662>>>>>>>>>>>    
20662>>>>>>>>>>>    
20662>>>>>>>>>>>    
20662>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
20662>>>>>>>>>>>    //
20662>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
20662>>>>>>>>>>>    //
20662>>>>>>>>>>>    
20662>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
20664>>>>>>>>>>>        Integer iPartRev
20664>>>>>>>>>>>        Integer iCurrentPart
20664>>>>>>>>>>>        Integer iSeparatorPos
20664>>>>>>>>>>>        
20664>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
20667>>>>>>>>>>>        
20667>>>>>>>>>>>        Move 0 to iCurrentPart
20668>>>>>>>>>>>        Repeat
20668>>>>>>>>>>>>
20668>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
20669>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
20671>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
20672>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
20673>>>>>>>>>>>                Increment iCurrentPart
20674>>>>>>>>>>>            End
20674>>>>>>>>>>>>
20674>>>>>>>>>>>            Else If (sRevision <> "") Begin
20677>>>>>>>>>>>                Move sRevision to iPartRev
20678>>>>>>>>>>>                Move "" to sRevision
20679>>>>>>>>>>>                Increment iCurrentPart
20680>>>>>>>>>>>            End
20680>>>>>>>>>>>>
20680>>>>>>>>>>>            Else ;                Move -1 to iPartRev
20682>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
20684>>>>>>>>>>>        
20684>>>>>>>>>>>        Function_Return iPartRev
20685>>>>>>>>>>>    End_Function
20686>>>>>>>>>>>    
20686>>>>>>>>>>>    
20686>>>>>>>>>>>    
20686>>>>>>>>>>>    //
20686>>>>>>>>>>>    //  Returns the major revision of the CK
20686>>>>>>>>>>>    //
20686>>>>>>>>>>>    
20686>>>>>>>>>>>    Function CKMajorRevision Returns Integer
20688>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
20689>>>>>>>>>>>    End_Function
20690>>>>>>>>>>>    
20690>>>>>>>>>>>    
20690>>>>>>>>>>>    
20690>>>>>>>>>>>    //  Returns the minor revision of the CK
20690>>>>>>>>>>>    //
20690>>>>>>>>>>>    
20690>>>>>>>>>>>    Function CKMinorRevision Returns Integer
20692>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
20693>>>>>>>>>>>    End_Function
20694>>>>>>>>>>>    
20694>>>>>>>>>>>    
20694>>>>>>>>>>>    //  Returns the release revision of the CK
20694>>>>>>>>>>>    //
20694>>>>>>>>>>>    
20694>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
20696>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
20697>>>>>>>>>>>    End_Function
20698>>>>>>>>>>>    
20698>>>>>>>>>>>    
20698>>>>>>>>>>>    //  Returns the major revision of the CK
20698>>>>>>>>>>>    //
20698>>>>>>>>>>>    
20698>>>>>>>>>>>    Function CKBuildRevision Returns Integer
20700>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
20701>>>>>>>>>>>    End_Function
20702>>>>>>>>>>>    
20702>>>>>>>>>>>    
20702>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
20702>>>>>>>>>>>    //
20702>>>>>>>>>>>    
20702>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
20704>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
20707>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
20710>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
20713>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
20716>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
20719>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
20723>>>>>>>>>>>            End
20723>>>>>>>>>>>>
20723>>>>>>>>>>>        End
20723>>>>>>>>>>>>
20723>>>>>>>>>>>        
20723>>>>>>>>>>>        Function_Return (False)
20724>>>>>>>>>>>    End_Function
20725>>>>>>>>>>>    
20725>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
20725>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
20725>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
20725>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
20725>>>>>>>>>>>    //
20725>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
20725>>>>>>>>>>>    //   in the following format:
20725>>>>>>>>>>>    //       <version>.<revision>.<type>
20725>>>>>>>>>>>    //   possible values for <type>:
20725>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
20725>>>>>>>>>>>    //         server using Workgroup authentication mode
20725>>>>>>>>>>>    //       C for client cache engine
20725>>>>>>>>>>>    //       D for DOS workstation
20725>>>>>>>>>>>    //       N for client Requester
20725>>>>>>>>>>>    //       S for NetWare server
20725>>>>>>>>>>>    //       T for 32-bit Windows server engine
20725>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
20725>>>>>>>>>>>    //
20725>>>>>>>>>>>    //   example:
20725>>>>>>>>>>>    //       8.50.T
20725>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
20725>>>>>>>>>>>    //   32-bits Windows server.
20725>>>>>>>>>>>    //
20725>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
20725>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
20725>>>>>>>>>>>    //
20725>>>>>>>>>>>    //   If the version information is not available or can not be obtained
20725>>>>>>>>>>>    //   the functions will return "0.0.0"
20725>>>>>>>>>>>    
20725>>>>>>>>>>>    //  Returns the version information of the
20725>>>>>>>>>>>    //           Pervasive.SQL Client requester.
20725>>>>>>>>>>>    
20725>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
20727>>>>>>>>>>>        
20727>>>>>>>>>>>        String  sDriverID
20727>>>>>>>>>>>        String  sVersion
20727>>>>>>>>>>>        String  sVoid
20727>>>>>>>>>>>        Integer iRetval
20727>>>>>>>>>>>        
20727>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20727>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20727>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20727>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20728>>>>>>>>>>>        Get psDriverID to sDriverID
20729>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20730>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20735>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20736>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20738>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20738>>>>>>>>>>>            Move "0.0.0" to sVersion
20739>>>>>>>>>>>        End
20739>>>>>>>>>>>>
20739>>>>>>>>>>>        Function_Return sVersion
20740>>>>>>>>>>>    End_Function
20741>>>>>>>>>>>    
20741>>>>>>>>>>>    //           Pervasive.SQL Engine
20741>>>>>>>>>>>    
20741>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
20743>>>>>>>>>>>        
20743>>>>>>>>>>>        String  sDriverID
20743>>>>>>>>>>>        String  sVersion
20743>>>>>>>>>>>        String  sVoid
20743>>>>>>>>>>>        Integer iRetval
20743>>>>>>>>>>>        
20743>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20743>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20743>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20743>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20744>>>>>>>>>>>        Get psDriverID to sDriverID
20745>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20746>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20751>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20752>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20754>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20754>>>>>>>>>>>            Move "0.0.0" to sVersion
20755>>>>>>>>>>>        End
20755>>>>>>>>>>>>
20755>>>>>>>>>>>        Function_Return sVersion
20756>>>>>>>>>>>    End_Function
20757>>>>>>>>>>>    
20757>>>>>>>>>>>    //  Returns the version information of the
20757>>>>>>>>>>>    //           Pervasive.SQL Server Engine
20757>>>>>>>>>>>    
20757>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
20759>>>>>>>>>>>        
20759>>>>>>>>>>>        String  sDriverID
20759>>>>>>>>>>>        String  sVersion
20759>>>>>>>>>>>        String  sVoid
20759>>>>>>>>>>>        Integer iRetval
20759>>>>>>>>>>>        
20759>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20759>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20759>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20759>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20760>>>>>>>>>>>        Get psDriverID to sDriverID
20761>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20762>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20767>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20768>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20770>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20770>>>>>>>>>>>            Move "0.0.0" to sVersion
20771>>>>>>>>>>>        End
20771>>>>>>>>>>>>
20771>>>>>>>>>>>        Function_Return sVersion
20772>>>>>>>>>>>    End_Function
20773>>>>>>>>>>>    
20773>>>>>>>>>>>End_Class
20774>>>>>>>>>>>
20774>>>>>>>>>>>
20774>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cSQLConnectionIniFile.inc)
20774>>>>>>>>>>>//****************************************************************************
20774>>>>>>>>>>>// $Module type: Include file
20774>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
20774>>>>>>>>>>>//
20774>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
20774>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
20774>>>>>>>>>>>// E-mail      : support@rdctools.com
20774>>>>>>>>>>>// Web-site    : http://www.rdctools.com
20774>>>>>>>>>>>//
20774>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
20774>>>>>>>>>>>//
20774>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
20774>>>>>>>>>>>//
20774>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
20774>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
20774>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
20774>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
20774>>>>>>>>>>>// in the help folder for more details.
20774>>>>>>>>>>>//
20774>>>>>>>>>>>Use Winkern.pkg
20774>>>>>>>>>>>Use cIniFile.pkg
20774>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCryptographerEx.pkg)
20774>>>>>>>>>>>>>Use VdfBase.pkg
20774>>>>>>>>>>>>>
20774>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.1\Pkg\CryptographerConstants.pkg)
20774>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
20774>>>>>>>>>>>>>>>// Algorithm classes
20774>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
20774>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
20774>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
20774>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
20774>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
20774>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
20774>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Algorithm types
20774>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
20774>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
20774>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
20774>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
20774>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
20774>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
20774>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Generic sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// RSA sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
20774>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
20774>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
20774>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// DSS sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
20774>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// DES sub_ids
20774>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
20774>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
20774>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
20774>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
20774>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
20774>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
20774>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
20774>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
20774>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
20774>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
20774>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
20774>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
20774>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Fortezza sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
20774>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// RC2 sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Stream cipher sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
20774>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
20774>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
20774>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Hash sub ids
20774>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
20774>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
20774>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
20774>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
20774>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
20774>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
20774>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
20774>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
20774>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
20774>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
20774>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
20774>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
20774>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
20774>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// secure channel sub ids
20774>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
20774>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
20774>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
20774>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
20774>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
20774>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
20774>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// algorithm identifier definitions
20774>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
20774>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
20774>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
20774>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
20774>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
20774>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
20774>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
20774>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
20774>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
20774>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
20774>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
20774>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
20774>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
20774>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
20774>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
20774>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
20774>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
20774>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
20774>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
20774>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
20774>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
20774>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
20774>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
20774>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
20774>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
20774>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
20774>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
20774>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
20774>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
20774>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
20774>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
20774>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
20774>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
20774>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
20774>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
20774>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
20774>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
20774>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
20774>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
20774>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
20774>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
20774>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
20774>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
20774>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Providers
20774>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
20774>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
20774>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
20774>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
20774>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
20774>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
20774>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
20774>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
20774>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
20774>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
20774>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
20774>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
20774>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
20774>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
20774>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
20774>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
20774>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
20774>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
20774>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
20774>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
20774>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
20774>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
20774>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
20774>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
20774>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
20774>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Provider types
20774>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
20774>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
20774>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
20774>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
20774>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
20774>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
20774>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
20774>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
20774>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
20774>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
20774>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
20774>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
20774>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
20774>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
20774>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
20774>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
20774>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
20774>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// KP_MODE
20774>>>>>>>>>>>>>>>// KP_MODE
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
20774>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
20774>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
20774>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
20774>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
20774>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
20774>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
20774>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
20774>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
20774>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
20774>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
20774>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
20774>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
20774>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
20774>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
20774>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
20774>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
20774>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
20774>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
20774>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
20774>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
20774>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
20774>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
20774>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
20774>>>>>>>>>>>>>>>Define KP_RP                            for 23
20774>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
20774>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
20774>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
20774>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
20774>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
20774>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
20774>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
20774>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
20774>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
20774>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
20774>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
20774>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
20774>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
20774>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
20774>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
20774>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
20774>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
20774>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
20774>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
20774>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
20774>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
20774>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
20774>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// key BLOB types
20774>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
20774>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
20774>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
20774>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
20774>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
20774>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
20774>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
20774>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// KP_PADDING
20774>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
20774>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
20774>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>//  Structure cryptimportkey
20774>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
20774>>>>>>>>>>>>>>>    UChar    bType
20774>>>>>>>>>>>>>>>    UChar    bVersion
20774>>>>>>>>>>>>>>>    UShort   reserved
20774>>>>>>>>>>>>>>>    UInteger aiKeyAlg
20774>>>>>>>>>>>>>>>End_Struct
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
20774>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
20774>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
20774>>>>>>>>>>>>>>>    UInteger       dwKeySize
20774>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
20774>>>>>>>>>>>>>>>End_Struct
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
20774>>>>>>>>>>>>>>>Struct HMAC_INFO
20774>>>>>>>>>>>>>>>    UInteger HashAlgid
20774>>>>>>>>>>>>>>>    Pointer pbInnerString
20774>>>>>>>>>>>>>>>    DWord cbInnerString
20774>>>>>>>>>>>>>>>    Pointer pbOuterString
20774>>>>>>>>>>>>>>>    DWord cbOuterString
20774>>>>>>>>>>>>>>>End_Struct
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>Struct BLOBHEADER
20774>>>>>>>>>>>>>>>    UChar   bType
20774>>>>>>>>>>>>>>>    UChar   bVersion
20774>>>>>>>>>>>>>>>    Short   reserved
20774>>>>>>>>>>>>>>>    Integer aiKeyAlg
20774>>>>>>>>>>>>>>>End_Struct
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>Struct CryptoBlob
20774>>>>>>>>>>>>>>>    BLOBHEADER  header
20774>>>>>>>>>>>>>>>    BLOBHEADER  header
20774>>>>>>>>>>>>>>>    Integer     cbKeySize
20774>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
20774>>>>>>>>>>>>>>>End_Struct
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>
20774>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
20774>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
20775>>>>>>>>>>>>>>>
20775>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
20775>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
20777>>>>>>>>>>>>>>>    
20777>>>>>>>>>>>>>>>    Boolean bResult
20777>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
20777>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
20777>>>>>>>>>>>>>>>
20777>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
20778>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
20779>>>>>>>>>>>>>>>    
20779>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
20780>>>>>>>>>>>>>>>
20780>>>>>>>>>>>>>>>    Function_Return bResult
20781>>>>>>>>>>>>>>>End_Function
20782>>>>>>>>>>>>>>>
20782>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
20783>>>>>>>>>>>>>>>
20783>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
20784>>>>>>>>>>>>>>>
20784>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
20785>>>>>>>>>>>>>>>
20785>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
20786>>>>>>>>>>>>>>>
20786>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
20787>>>>>>>>>>>>>>>
20787>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
20788>>>>>>>>>>>>>>>
20788>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
20789>>>>>>>>>>>>>>>
20789>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
20790>>>>>>>>>>>>>>>
20790>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
20791>>>>>>>>>>>>>>>    
20791>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
20792>>>>>>>>>>>>>>>
20792>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
20793>>>>>>>>>>>>>>>
20793>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
20794>>>>>>>>>>>>>>>
20794>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
20795>>>>>>>>>>>>>>>    
20795>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
20796>>>>>>>>>>>>>>>    
20796>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
20797>>>>>>>>>>>>>>>    
20797>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
20798>>>>>>>>>>>>>
20798>>>>>>>>>>>>>Class cCryptographerEx is a cObject
20799>>>>>>>>>>>>>    
20799>>>>>>>>>>>>>    Procedure Construct_Object
20801>>>>>>>>>>>>>        Forward Send Construct_Object
20803>>>>>>>>>>>>>        
20803>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
20804>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
20805>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
20806>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
20807>>>>>>>>>>>>>        
20807>>>>>>>>>>>>>        // Private properties
20807>>>>>>>>>>>>>        Property Handle     Private_phProv
20808>>>>>>>>>>>>>        
20808>>>>>>>>>>>>>        // Block cipher properties
20808>>>>>>>>>>>>>        Property UChar[]    paKey
20809>>>>>>>>>>>>>        Property UChar[]    paIV
20810>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
20811>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
20812>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
20813>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
20814>>>>>>>>>>>>>        Property Integer    piBlockSize     16
20815>>>>>>>>>>>>>    End_Procedure
20816>>>>>>>>>>>>>    
20816>>>>>>>>>>>>>    
20816>>>>>>>>>>>>>    // Acquire key container handle
20816>>>>>>>>>>>>>    Function AcquireContext Returns Handle
20818>>>>>>>>>>>>>        Integer iProvider
20818>>>>>>>>>>>>>        WString wProvider
20818>>>>>>>>>>>>>        Handle hProv
20818>>>>>>>>>>>>>        Boolean bOk
20818>>>>>>>>>>>>>        Pointer pProv
20818>>>>>>>>>>>>>        
20818>>>>>>>>>>>>>        Move 0 to hProv
20819>>>>>>>>>>>>>        Get piProvider to iProvider
20820>>>>>>>>>>>>>        Get psProvider to wProvider
20821>>>>>>>>>>>>>        
20821>>>>>>>>>>>>>        //  Determine address to be passed as provider
20821>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
20823>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
20824>>>>>>>>>>>>>        End
20824>>>>>>>>>>>>>>
20824>>>>>>>>>>>>>        Else Begin
20825>>>>>>>>>>>>>            Move 0 to pProv
20826>>>>>>>>>>>>>        End
20826>>>>>>>>>>>>>>
20826>>>>>>>>>>>>>        
20826>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
20826>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
20827>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
20829>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
20830>>>>>>>>>>>>>        End
20830>>>>>>>>>>>>>>
20830>>>>>>>>>>>>>        
20830>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
20832>>>>>>>>>>>>>            // Fallback to original
20832>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
20833>>>>>>>>>>>>>            
20833>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
20835>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
20836>>>>>>>>>>>>>            End
20836>>>>>>>>>>>>>>
20836>>>>>>>>>>>>>        End
20836>>>>>>>>>>>>>>
20836>>>>>>>>>>>>>        Set Private_phProv to hProv
20837>>>>>>>>>>>>>        
20837>>>>>>>>>>>>>        Function_Return hProv
20838>>>>>>>>>>>>>    End_Function
20839>>>>>>>>>>>>>    
20839>>>>>>>>>>>>>    // Releases key container handle
20839>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
20841>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
20842>>>>>>>>>>>>>    End_Function
20843>>>>>>>>>>>>>    
20843>>>>>>>>>>>>>    // Creates hash object
20843>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
20845>>>>>>>>>>>>>        Integer iAlgorithm
20845>>>>>>>>>>>>>        Handle hHash
20845>>>>>>>>>>>>>        Boolean bOk
20845>>>>>>>>>>>>>        
20845>>>>>>>>>>>>>        Move 0 to hHash
20846>>>>>>>>>>>>>        Get piHash to iAlgorithm
20847>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
20848>>>>>>>>>>>>>        
20848>>>>>>>>>>>>>        Function_Return hHash
20849>>>>>>>>>>>>>    End_Function
20850>>>>>>>>>>>>>    
20850>>>>>>>>>>>>>    // Destroys the hash object
20850>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
20852>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
20853>>>>>>>>>>>>>    End_Function
20854>>>>>>>>>>>>>    
20854>>>>>>>>>>>>>    // Adds data to hash object
20854>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
20856>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
20857>>>>>>>>>>>>>    End_Function
20858>>>>>>>>>>>>>    
20858>>>>>>>>>>>>>    // Generates session key
20858>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
20860>>>>>>>>>>>>>        Integer iAlgorithm
20860>>>>>>>>>>>>>        Handle hKey
20860>>>>>>>>>>>>>        Boolean bOk
20860>>>>>>>>>>>>>        
20860>>>>>>>>>>>>>        Move 0 to hKey
20861>>>>>>>>>>>>>        Get piCipher to iAlgorithm
20862>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
20863>>>>>>>>>>>>>        
20863>>>>>>>>>>>>>        Function_Return hKey
20864>>>>>>>>>>>>>    End_Function
20865>>>>>>>>>>>>>    
20865>>>>>>>>>>>>>    // Imports a plain text key
20865>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
20867>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
20867>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
20867>>>>>>>>>>>>>        Boolean   bSuccess
20867>>>>>>>>>>>>>        Handle    hKey
20867>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
20867>>>>>>>>>>>>>        UChar[]   ucaKeyblob
20868>>>>>>>>>>>>>        Integer iVoid
20868>>>>>>>>>>>>>        
20868>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
20869>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
20870>>>>>>>>>>>>>        
20870>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
20871>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
20872>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
20873>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
20874>>>>>>>>>>>>>        
20874>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
20875>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
20876>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
20877>>>>>>>>>>>>>        
20877>>>>>>>>>>>>>        Move 0 to hKey
20878>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
20879>>>>>>>>>>>>>        If (not(bSuccess)) Begin
20881>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
20882>>>>>>>>>>>>>        End
20882>>>>>>>>>>>>>>
20882>>>>>>>>>>>>>        
20882>>>>>>>>>>>>>        Function_Return hKey
20883>>>>>>>>>>>>>    End_Function
20884>>>>>>>>>>>>>    
20884>>>>>>>>>>>>>    // Destroys the key
20884>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
20886>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
20887>>>>>>>>>>>>>    End_Function
20888>>>>>>>>>>>>>    
20888>>>>>>>>>>>>>    // Retrieves key data
20888>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
20890>>>>>>>>>>>>>        Integer iBuffer iLen
20890>>>>>>>>>>>>>        Boolean bOk
20890>>>>>>>>>>>>>        
20890>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
20891>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
20892>>>>>>>>>>>>>        Function_Return iBuffer
20893>>>>>>>>>>>>>    End_Function
20894>>>>>>>>>>>>>    
20894>>>>>>>>>>>>>    // Retrieves a hash value
20894>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
20896>>>>>>>>>>>>>        UChar[] ucHash
20897>>>>>>>>>>>>>        Integer liResult
20897>>>>>>>>>>>>>        DWord   dwDataLen
20897>>>>>>>>>>>>>        
20897>>>>>>>>>>>>>        Move 0 to dwDataLen
20898>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
20899>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
20902>>>>>>>>>>>>>        
20902>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
20903>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
20904>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
20907>>>>>>>>>>>>>        
20907>>>>>>>>>>>>>        Function_Return ucHash
20908>>>>>>>>>>>>>    End_Function
20909>>>>>>>>>>>>>
20909>>>>>>>>>>>>>    // Encrypts data
20909>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
20911>>>>>>>>>>>>>        Handle hProv hHash hKey
20911>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
20911>>>>>>>>>>>>>        Boolean bOk
20911>>>>>>>>>>>>>        
20911>>>>>>>>>>>>>        Get AcquireContext to hProv
20912>>>>>>>>>>>>>        If (hProv) Begin
20914>>>>>>>>>>>>>            Get CreateHash hProv to hHash
20915>>>>>>>>>>>>>            If (hHash) Begin
20917>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
20918>>>>>>>>>>>>>                If (bOk) Begin
20920>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
20921>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
20922>>>>>>>>>>>>>                End
20922>>>>>>>>>>>>>>
20922>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
20923>>>>>>>>>>>>>            End
20923>>>>>>>>>>>>>>
20923>>>>>>>>>>>>>            
20923>>>>>>>>>>>>>            If (hKey) Begin
20925>>>>>>>>>>>>>                //  First call to determine resulting data size
20925>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
20926>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
20927>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
20928>>>>>>>>>>>>>                
20928>>>>>>>>>>>>>                //  Reserve space in string
20928>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
20930>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
20931>>>>>>>>>>>>>                End
20931>>>>>>>>>>>>>>
20931>>>>>>>>>>>>>                
20931>>>>>>>>>>>>>                //  Call to really decrypt
20931>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
20932>>>>>>>>>>>>>                //If (not(bOk)) Begin
20932>>>>>>>>>>>>>                //Move "" to sData
20932>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
20932>>>>>>>>>>>>>                //End
20932>>>>>>>>>>>>>                
20932>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
20933>>>>>>>>>>>>>            End 
20933>>>>>>>>>>>>>>
20933>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
20934>>>>>>>>>>>>>        End 
20934>>>>>>>>>>>>>>
20934>>>>>>>>>>>>>        Function_Return ucData
20935>>>>>>>>>>>>>    End_Function
20936>>>>>>>>>>>>>    
20936>>>>>>>>>>>>>    // Decrypts data
20936>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
20938>>>>>>>>>>>>>        Handle hProv hHash hKey
20938>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
20938>>>>>>>>>>>>>        Boolean bOk
20938>>>>>>>>>>>>>        
20938>>>>>>>>>>>>>        Get AcquireContext to hProv
20939>>>>>>>>>>>>>        If (hProv) Begin
20941>>>>>>>>>>>>>            Get CreateHash hProv to hHash
20942>>>>>>>>>>>>>            If (hHash) Begin
20944>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
20945>>>>>>>>>>>>>                If (bOk) Begin
20947>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
20948>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
20949>>>>>>>>>>>>>                End
20949>>>>>>>>>>>>>>
20949>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
20950>>>>>>>>>>>>>            End
20950>>>>>>>>>>>>>>
20950>>>>>>>>>>>>>            
20950>>>>>>>>>>>>>            If (hKey) Begin
20952>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
20953>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
20954>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
20954>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
20956>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
20957>>>>>>>>>>>>>                End
20957>>>>>>>>>>>>>>
20957>>>>>>>>>>>>>                
20957>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
20958>>>>>>>>>>>>>            End
20958>>>>>>>>>>>>>>
20958>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
20959>>>>>>>>>>>>>        End
20959>>>>>>>>>>>>>>
20959>>>>>>>>>>>>>        Function_Return ucData
20960>>>>>>>>>>>>>    End_Function
20961>>>>>>>>>>>>>    
20961>>>>>>>>>>>>>    // Creates a key
20961>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
20963>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
20963>>>>>>>>>>>>>        CryptoBlob keyBlob
20963>>>>>>>>>>>>>        CryptoBlob keyBlob
20963>>>>>>>>>>>>>        Boolean bOk
20963>>>>>>>>>>>>>        Handle hKey
20963>>>>>>>>>>>>>        UChar[] aKey
20964>>>>>>>>>>>>>
20964>>>>>>>>>>>>>        Get paKey to aKey
20965>>>>>>>>>>>>>        Get piKeyAlg to iAlg
20966>>>>>>>>>>>>>        Get piKeyType to iType
20967>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
20968>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
20969>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
20970>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
20971>>>>>>>>>>>>>        
20971>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
20972>>>>>>>>>>>>>        For iByte from 0 to iLength
20978>>>>>>>>>>>>>>
20978>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
20979>>>>>>>>>>>>>        Loop
20980>>>>>>>>>>>>>>
20980>>>>>>>>>>>>>        
20980>>>>>>>>>>>>>        Move 0 to hKey
20981>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
20982>>>>>>>>>>>>>        Function_Return hKey
20983>>>>>>>>>>>>>    End_Function
20984>>>>>>>>>>>>>    
20984>>>>>>>>>>>>>    // Sets the key parameters
20984>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
20986>>>>>>>>>>>>>        Integer iPadding iMode
20986>>>>>>>>>>>>>        Boolean bOk
20986>>>>>>>>>>>>>        UChar[] aIV
20987>>>>>>>>>>>>>        
20987>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
20987>>>>>>>>>>>>>        //For iByte from 0 to iLength
20987>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
20987>>>>>>>>>>>>>        //Loop
20987>>>>>>>>>>>>>
20987>>>>>>>>>>>>>        // Set initialization vector
20987>>>>>>>>>>>>>        Get paIV to aIV
20988>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
20989>>>>>>>>>>>>>        If (bOk) Begin
20991>>>>>>>>>>>>>            // Set padding
20991>>>>>>>>>>>>>            Get piKeyPadding to iPadding
20992>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
20993>>>>>>>>>>>>>            If (bOk) Begin
20995>>>>>>>>>>>>>                // Set move
20995>>>>>>>>>>>>>                Get piKeyMode to iMode
20996>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
20997>>>>>>>>>>>>>            End
20997>>>>>>>>>>>>>>
20997>>>>>>>>>>>>>        End
20997>>>>>>>>>>>>>>
20997>>>>>>>>>>>>>        Function_Return bOk        
20998>>>>>>>>>>>>>    End_Function
20999>>>>>>>>>>>>>    
20999>>>>>>>>>>>>>    // Encrypts using block cipher
20999>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
21001>>>>>>>>>>>>>        Handle hProv hKey
21001>>>>>>>>>>>>>        Integer iLen iSize iBlocks
21001>>>>>>>>>>>>>        Boolean bOk
21001>>>>>>>>>>>>>        
21001>>>>>>>>>>>>>        Get AcquireContext to hProv
21002>>>>>>>>>>>>>        If (hProv) Begin
21004>>>>>>>>>>>>>            // Create key
21004>>>>>>>>>>>>>            Get CreateKey hProv to hKey
21005>>>>>>>>>>>>>            If (hKey) Begin
21007>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
21008>>>>>>>>>>>>>                If (bOk) Begin
21010>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
21010>>>>>>>>>>>>>                    Get piBlockSize to iSize
21011>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
21012>>>>>>>>>>>>>                    
21012>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
21013>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
21014>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
21015>>>>>>>>>>>>>                End
21015>>>>>>>>>>>>>>
21015>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21016>>>>>>>>>>>>>            End
21016>>>>>>>>>>>>>>
21016>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21017>>>>>>>>>>>>>        End
21017>>>>>>>>>>>>>>
21017>>>>>>>>>>>>>        Function_Return ucData
21018>>>>>>>>>>>>>    End_Function
21019>>>>>>>>>>>>>    
21019>>>>>>>>>>>>>    // Decrypts using block cipher
21019>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
21021>>>>>>>>>>>>>        Handle hProv hKey
21021>>>>>>>>>>>>>        Integer iLen
21021>>>>>>>>>>>>>        Boolean bOk
21021>>>>>>>>>>>>>        
21021>>>>>>>>>>>>>        Get AcquireContext to hProv
21022>>>>>>>>>>>>>        If (hProv) Begin
21024>>>>>>>>>>>>>            // Create key
21024>>>>>>>>>>>>>            Get CreateKey hProv to hKey
21025>>>>>>>>>>>>>            If (hKey) Begin
21027>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
21028>>>>>>>>>>>>>                If (bOk) Begin
21030>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
21031>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
21032>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
21033>>>>>>>>>>>>>                End
21033>>>>>>>>>>>>>>
21033>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21034>>>>>>>>>>>>>            End
21034>>>>>>>>>>>>>>
21034>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21035>>>>>>>>>>>>>        End
21035>>>>>>>>>>>>>>
21035>>>>>>>>>>>>>        Function_Return ucData
21036>>>>>>>>>>>>>    End_Function
21037>>>>>>>>>>>>>    
21037>>>>>>>>>>>>>    
21037>>>>>>>>>>>>>    //  Generates random data.
21037>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
21039>>>>>>>>>>>>>        Handle hProv
21039>>>>>>>>>>>>>        UChar[] uaResult
21040>>>>>>>>>>>>>        Boolean bRes
21040>>>>>>>>>>>>>        
21040>>>>>>>>>>>>>        Get AcquireContext to hProv
21041>>>>>>>>>>>>>        
21041>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
21042>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
21043>>>>>>>>>>>>>        
21043>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
21044>>>>>>>>>>>>>        
21044>>>>>>>>>>>>>        Function_Return uaResult
21045>>>>>>>>>>>>>    End_Function
21046>>>>>>>>>>>>>    
21046>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
21046>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
21048>>>>>>>>>>>>>        String sResult
21048>>>>>>>>>>>>>        UChar[] ucData
21049>>>>>>>>>>>>>        Pointer pBase64
21049>>>>>>>>>>>>>        Integer iVoid
21049>>>>>>>>>>>>>        
21049>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
21050>>>>>>>>>>>>>        
21050>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
21051>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
21052>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21053>>>>>>>>>>>>>        
21053>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
21054>>>>>>>>>>>>>    End_Function
21055>>>>>>>>>>>>>    
21055>>>>>>>>>>>>>End_Class
21056>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\Base64Functions.pkg)
21056>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
21056>>>>>>>>>>>>>//>
21056>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
21056>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
21056>>>>>>>>>>>>>//>
21056>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
21056>>>>>>>>>>>>>//> strings.
21056>>>>>>>>>>>>>//>
21056>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
21056>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
21056>>>>>>>>>>>>>//>
21056>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
21056>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
21056>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
21056>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
21056>>>>>>>>>>>>>
21056>>>>>>>>>>>>>Use VdfBase.pkg
21056>>>>>>>>>>>>>
21056>>>>>>>>>>>>>// Functions in vdfBase64.dll
21056>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
21057>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
21058>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
21059>>>>>>>>>>>>>
21059>>>>>>>>>>>>>// Structure
21059>>>>>>>>>>>>>Struct txxfBase64Buffer
21059>>>>>>>>>>>>>    Pointer pData
21059>>>>>>>>>>>>>    Integer iLength
21059>>>>>>>>>>>>>End_Struct 
21059>>>>>>>>>>>>>
21059>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
21059>>>>>>>>>>>>>
21059>>>>>>>>>>>>>Object _oBase64Functions is a cObject
21061>>>>>>>>>>>>>    Move Self to oBase64Functions
21062>>>>>>>>>>>>>
21062>>>>>>>>>>>>>
21062>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
21065>>>>>>>>>>>>>        Address pBase64
21065>>>>>>>>>>>>>        String sResult
21065>>>>>>>>>>>>>        Integer iVoid
21065>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
21066>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
21067>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21068>>>>>>>>>>>>>        Function_Return sResult
21069>>>>>>>>>>>>>    End_Function
21070>>>>>>>>>>>>>
21070>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
21073>>>>>>>>>>>>>        Address pBinary
21073>>>>>>>>>>>>>        String sBinary
21073>>>>>>>>>>>>>        Integer iVoid iLen
21073>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
21074>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
21075>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
21076>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
21077>>>>>>>>>>>>>        Function_Return sBinary
21078>>>>>>>>>>>>>    End_Function
21079>>>>>>>>>>>>>
21079>>>>>>>>>>>>>End_Object
21080>>>>>>>>>>>Use MSSqldrv.pkg
21080>>>>>>>>>>>Use db2_drv.pkg
21080>>>>>>>>>>>Use odbc_drv.pkg
21080>>>>>>>>>>>Use DFBtrDrv.pkg
21080>>>>>>>>>>>Use vWin32fh.pkg
21080>>>>>>>>>>>
21080>>>>>>>>>>>Use DUFLanguageConstants.inc
21080>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\MertechDUF.pkg)
21080>>>>>>>>>>>>>//
21080>>>>>>>>>>>>>// Use of Mertech drivers:
21080>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
21080>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
21080>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
21080>>>>>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
21080>>>>>>>>>>>>>// MySQL Data Types
21080>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
21080>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
21080>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
21080>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
21080>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
21080>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
21080>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
21080>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
21080>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
21080>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
21080>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
21080>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
21080>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
21080>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
21080>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
21080>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
21080>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
21080>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
21080>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
21080>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
21080>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
21080>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
21080>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
21080>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
21080>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
21080>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
21080>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
21080>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
21080>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
21080>>>>>>>>>>>>>
21080>>>>>>>>>>>>>// Oracle Data Types
21080>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
21080>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
21080>>>>>>>>>>>>>Define eOracle_INT                                  for   3
21080>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
21080>>>>>>>>>>>>>Define eOracle_STRING                               for   5
21080>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
21080>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
21080>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
21080>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
21080>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
21080>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
21080>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
21080>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
21080>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
21080>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
21080>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
21080>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
21080>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
21080>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
21080>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
21080>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
21080>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
21080>>>>>>>>>>>>>
21080>>>>>>>>>>>>>// PostgreSQL Data Types
21080>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
21080>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
21080>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
21080>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
21080>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
21080>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
21080>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
21080>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
21080>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
21080>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
21080>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
21080>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
21080>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
21080>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
21080>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
21080>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
21080>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
21080>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
21080>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
21080>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
21080>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
21080>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
21080>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
21080>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
21080>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
21080>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
21080>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
21080>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
21080>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
21080>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
21080>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
21080>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
21080>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
21080>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
21080>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
21080>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
21080>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
21080>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
21080>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
21080>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
21080>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
21080>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
21080>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
21080>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
21080>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
21080>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
21080>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
21080>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
21080>>>>>>>>>>>>>
21080>>>>>>>>>>>>>// SQL Server Data Types
21080>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
21080>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
21080>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
21080>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
21080>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
21080>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
21080>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
21080>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
21080>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
21080>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
21080>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
21080>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
21080>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
21080>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
21080>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
21080>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
21080>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
21080>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
21080>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
21080>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
21080>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
21080>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
21080>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
21080>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
21080>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
21080>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
21080>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
21080>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
21080>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
21080>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
21080>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
21080>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
21080>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
21080>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
21080>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
21080>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
21080>>>>>>>>>>>>>
21080>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary.inc)
21080>>>>>>>>>>>>>>>Use DUFLanguageConstants.inc
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
21080>>>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
21080>>>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
21080>>>>>>>>>>>>>>>
21080>>>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
21080>>>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSQLScriptArray
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
21081>>>>>>>>>>>>>>>    Integer iOrgArgumentSize
21081>>>>>>>>>>>>>>>    String[] sSQLScriptArray
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSqlErrorArray
21081>>>>>>>>>>>>>>>    String[]  sSqlErrorArray
21081>>>>>>>>>>>>>>>    String[]  sSqlStatementArray
21081>>>>>>>>>>>>>>>    Integer[] iSqlErrorArray
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSqlColumnNew
21081>>>>>>>>>>>>>>>    String  sBaseColumnName
21081>>>>>>>>>>>>>>>    String  sBaseTableName
21081>>>>>>>>>>>>>>>    String  sLabel
21081>>>>>>>>>>>>>>>    Integer iSqlType
21081>>>>>>>>>>>>>>>    Integer iSize
21081>>>>>>>>>>>>>>>    Integer iPrecision
21081>>>>>>>>>>>>>>>    Integer iDFType
21081>>>>>>>>>>>>>>>    Integer iDFNativeType
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tColumnType
21081>>>>>>>>>>>>>>>    String  sSQLType
21081>>>>>>>>>>>>>>>    Integer iSQLType
21081>>>>>>>>>>>>>>>    Boolean bCanEditSize
21081>>>>>>>>>>>>>>>    Integer iDefaultSize
21081>>>>>>>>>>>>>>>    Integer iMinSize
21081>>>>>>>>>>>>>>>    Number  nMaxSize
21081>>>>>>>>>>>>>>>    String  sDataFlexType
21081>>>>>>>>>>>>>>>    Integer iDataFlexType
21081>>>>>>>>>>>>>>>    Boolean bNativeDataType
21081>>>>>>>>>>>>>>>    String  sPrecision
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
21081>>>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
21081>>>>>>>>>>>>>>>// keywords.
21081>>>>>>>>>>>>>>>Struct tSQLKeyWords
21081>>>>>>>>>>>>>>>    Integer iSQLWord
21081>>>>>>>>>>>>>>>    Integer iSQLDbType
21081>>>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSQLRelation
21081>>>>>>>>>>>>>>>    Integer iFileNumber
21081>>>>>>>>>>>>>>>    Integer iFieldNumber
21081>>>>>>>>>>>>>>>    String  sFileName
21081>>>>>>>>>>>>>>>    String  sFieldName
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSQLLoggedInUser
21081>>>>>>>>>>>>>>>    String sUser
21081>>>>>>>>>>>>>>>    String sProgram
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
21081>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
21081>>>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
21081>>>>>>>>>>>>>>>// They can have slightly different SQL keywords.
21081>>>>>>>>>>>>>>>// Note: If a new type is added to the list,
21081>>>>>>>>>>>>>>>//       the struct array xxx must be adjusted
21081>>>>>>>>>>>>>>>//       so that it is filled with all SQL
21081>>>>>>>>>>>>>>>//       keywords for that new type.
21081>>>>>>>>>>>>>>>Enum_List
21081>>>>>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
21081>>>>>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
21081>>>>>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
21081>>>>>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
21081>>>>>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
21081>>>>>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
21081>>>>>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
21081>>>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
21081>>>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
21081>>>>>>>>>>>>>>>//    Define EN_DbTypeOracle
21081>>>>>>>>>>>>>>>//    Define EN_DbTypeDB2
21081>>>>>>>>>>>>>>>//    Define EN_DbTypePostgre
21081>>>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
21081>>>>>>>>>>>>>>>End_Enum_List
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
21081>>>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
21081>>>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
21081>>>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
21081>>>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
21081>>>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
21081>>>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
21081>>>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
21081>>>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
21081>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
21081>>>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
21081>>>>>>>>>>>>>>>Enum_List
21081>>>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
21081>>>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
21081>>>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
21081>>>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
21081>>>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
21081>>>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
21081>>>>>>>>>>>>>>>End_Enum_List
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
21081>>>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
21081>>>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// These are not defined pre DF 18:
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSQLIntTableInfo
21081>>>>>>>>>>>>>>>    String sDriverName
21081>>>>>>>>>>>>>>>    String sServerName
21081>>>>>>>>>>>>>>>    String sDatabaseName
21081>>>>>>>>>>>>>>>    String sSchemaName
21081>>>>>>>>>>>>>>>    Boolean bRecnumTable
21081>>>>>>>>>>>>>>>    Integer iPrimaryIndex
21081>>>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
21081>>>>>>>>>>>>>>>    String sTableCharacterFormat
21081>>>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
21081>>>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
21081>>>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
21081>>>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
21081>>>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
21081>>>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
21081>>>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
21081>>>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
21081>>>>>>>>>>>>>>>    String sFileIndexTablespace
21081>>>>>>>>>>>>>>>    String sFileLongTablespace
21081>>>>>>>>>>>>>>>    String sTableTablespace
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tSQLIntColumnInfo
21081>>>>>>>>>>>>>>>    Integer iFieldNumber
21081>>>>>>>>>>>>>>>    Integer iFieldIndex
21081>>>>>>>>>>>>>>>    Integer iFieldRelatedFile
21081>>>>>>>>>>>>>>>    Integer iFieldRelatedField
21081>>>>>>>>>>>>>>>    Integer iIndexNumber
21081>>>>>>>>>>>>>>>    Integer iIndexNumberSegments
21081>>>>>>>>>>>>>>>    Integer iIndexSegmentField1
21081>>>>>>>>>>>>>>>    Integer iIndexSegmentField2
21081>>>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
21081>>>>>>>>>>>>>>>    String  sIndexName
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIColumn
21081>>>>>>>>>>>>>>>    Integer iFieldNumber
21081>>>>>>>>>>>>>>>    String  sFieldName
21081>>>>>>>>>>>>>>>    Integer iType
21081>>>>>>>>>>>>>>>    String  sType
21081>>>>>>>>>>>>>>>    Integer iLength
21081>>>>>>>>>>>>>>>    Integer iPrecision
21081>>>>>>>>>>>>>>>    Integer iOptions
21081>>>>>>>>>>>>>>>    Boolean bIsSQLType
21081>>>>>>>>>>>>>>>    Boolean bAllowNULL
21081>>>>>>>>>>>>>>>    String  sDefaultValue
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIColumnCompare
21081>>>>>>>>>>>>>>>    Integer iFieldNumber
21081>>>>>>>>>>>>>>>    // FROM database:
21081>>>>>>>>>>>>>>>    Boolean bExistsFrom
21081>>>>>>>>>>>>>>>    String  sFieldNameFrom
21081>>>>>>>>>>>>>>>    Integer iTypeFrom
21081>>>>>>>>>>>>>>>    String  sTypeFrom
21081>>>>>>>>>>>>>>>    Integer iLengthFrom
21081>>>>>>>>>>>>>>>    Integer iPrecisionFrom
21081>>>>>>>>>>>>>>>    Integer iOptionsFrom
21081>>>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
21081>>>>>>>>>>>>>>>    Boolean bAllowNULLFrom
21081>>>>>>>>>>>>>>>    String  sDefaultValueFrom
21081>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
21081>>>>>>>>>>>>>>>    Boolean bCancelFrom
21081>>>>>>>>>>>>>>>    Boolean bErrorFrom
21081>>>>>>>>>>>>>>>    // TO database:
21081>>>>>>>>>>>>>>>    Boolean bExistsTo
21081>>>>>>>>>>>>>>>    Integer iFieldNumberTo
21081>>>>>>>>>>>>>>>    String  sFieldNameTo
21081>>>>>>>>>>>>>>>    Integer iTypeTo
21081>>>>>>>>>>>>>>>    String  sTypeTo
21081>>>>>>>>>>>>>>>    Integer iLengthTo
21081>>>>>>>>>>>>>>>    Integer iPrecisionTo
21081>>>>>>>>>>>>>>>    Integer iOptionsTo
21081>>>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
21081>>>>>>>>>>>>>>>    Boolean bAllowNULLTo
21081>>>>>>>>>>>>>>>    String  sDefaultValueTo
21081>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
21081>>>>>>>>>>>>>>>    Boolean bCancelTo
21081>>>>>>>>>>>>>>>    Boolean bErrorTo
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIRelation
21081>>>>>>>>>>>>>>>    Handle  hTableFrom
21081>>>>>>>>>>>>>>>    Integer iColumnFrom
21081>>>>>>>>>>>>>>>    Handle  hTableTo
21081>>>>>>>>>>>>>>>    Integer iColumnTo
21081>>>>>>>>>>>>>>>    String  sLogicalNameFrom
21081>>>>>>>>>>>>>>>    String  sLogicalNameTo
21081>>>>>>>>>>>>>>>    String  sFieldNameFrom
21081>>>>>>>>>>>>>>>    String  sFieldNameTo
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIRelationCompare
21081>>>>>>>>>>>>>>>    // Common:
21081>>>>>>>>>>>>>>>    Handle  hTableFrom
21081>>>>>>>>>>>>>>>    Integer iColumnFrom
21081>>>>>>>>>>>>>>>    Handle  hTableTo
21081>>>>>>>>>>>>>>>    Integer iColumnTo
21081>>>>>>>>>>>>>>>    // FROM database:
21081>>>>>>>>>>>>>>>    Boolean bExistsFrom
21081>>>>>>>>>>>>>>>    String  sLogicalNameFrom_From
21081>>>>>>>>>>>>>>>    String  sLogicalNameTo_From
21081>>>>>>>>>>>>>>>    String  sFieldNameFrom_From
21081>>>>>>>>>>>>>>>    String  sFieldNameTo_From
21081>>>>>>>>>>>>>>>    Boolean bShouldChange_From
21081>>>>>>>>>>>>>>>    Boolean bCancel_From
21081>>>>>>>>>>>>>>>    Boolean bError_From
21081>>>>>>>>>>>>>>>    // TO database:
21081>>>>>>>>>>>>>>>    Boolean bExistsTo
21081>>>>>>>>>>>>>>>    String  sLogicalNameFrom_To
21081>>>>>>>>>>>>>>>    String  sLogicalNameTo_To
21081>>>>>>>>>>>>>>>    String  sFieldNameFrom_To
21081>>>>>>>>>>>>>>>    String  sFieldNameTo_To
21081>>>>>>>>>>>>>>>    Boolean bShouldChange_To
21081>>>>>>>>>>>>>>>    Boolean bCancel_To
21081>>>>>>>>>>>>>>>    Boolean bError_To
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIIndexSegment
21081>>>>>>>>>>>>>>>    Integer iFieldNumber
21081>>>>>>>>>>>>>>>    String  sFieldName
21081>>>>>>>>>>>>>>>    Boolean bUppercase
21081>>>>>>>>>>>>>>>    Boolean bAscending
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIIndex
21081>>>>>>>>>>>>>>>    Integer iIndexNumber
21081>>>>>>>>>>>>>>>    Integer iPrimaryIndex
21081>>>>>>>>>>>>>>>    String  sSQLIndexName
21081>>>>>>>>>>>>>>>    Integer iSQLIndexType
21081>>>>>>>>>>>>>>>    Boolean bIsSQLClustered
21081>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
21081>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
21081>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPIIndexCompare
21081>>>>>>>>>>>>>>>    // Common:
21081>>>>>>>>>>>>>>>    Integer iIndexNumber
21081>>>>>>>>>>>>>>>    // FROM database:
21081>>>>>>>>>>>>>>>    Boolean bExistsFrom
21081>>>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
21081>>>>>>>>>>>>>>>    String  sSQLIndexNameFrom
21081>>>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
21081>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
21081>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
21081>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
21081>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
21081>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
21081>>>>>>>>>>>>>>>    Boolean bCancelFrom
21081>>>>>>>>>>>>>>>    Boolean bErrorFrom
21081>>>>>>>>>>>>>>>    // TO database:
21081>>>>>>>>>>>>>>>    Boolean bExistsTo
21081>>>>>>>>>>>>>>>    Integer iPrimaryIndexTo
21081>>>>>>>>>>>>>>>    String  sSQLIndexNameTo
21081>>>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
21081>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
21081>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
21081>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
21081>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
21081>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
21081>>>>>>>>>>>>>>>    Boolean bCancelTo
21081>>>>>>>>>>>>>>>    Boolean bErrorTo
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPITableNameInfo
21081>>>>>>>>>>>>>>>    Integer iTableNumber
21081>>>>>>>>>>>>>>>    String  sRootName
21081>>>>>>>>>>>>>>>    String  sLogicalName
21081>>>>>>>>>>>>>>>    String  sDisplayName
21081>>>>>>>>>>>>>>>    String  sDriverID
21081>>>>>>>>>>>>>>>    Boolean bIsAlias
21081>>>>>>>>>>>>>>>    Boolean bIsSQL
21081>>>>>>>>>>>>>>>    Boolean bIsSystemFile
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
21081>>>>>>>>>>>>>>>    Integer iTableNumber
21081>>>>>>>>>>>>>>>    // FROM
21081>>>>>>>>>>>>>>>    Boolean bExistsFrom
21081>>>>>>>>>>>>>>>    String  sRootNameFrom
21081>>>>>>>>>>>>>>>    String  sLogicalNameFrom
21081>>>>>>>>>>>>>>>    String  sDisplayNameFrom
21081>>>>>>>>>>>>>>>    String  sDriverIDFrom
21081>>>>>>>>>>>>>>>    Boolean bIsAliasFrom
21081>>>>>>>>>>>>>>>    Boolean bIsSQLFrom
21081>>>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
21081>>>>>>>>>>>>>>>    // TO database:
21081>>>>>>>>>>>>>>>    Boolean bExistsTo
21081>>>>>>>>>>>>>>>    String  sRootNameTo
21081>>>>>>>>>>>>>>>    String  sLogicalNameTo
21081>>>>>>>>>>>>>>>    String  sDisplayNameTo
21081>>>>>>>>>>>>>>>    String  sDriverIDTo
21081>>>>>>>>>>>>>>>    Boolean bIsAliasTo
21081>>>>>>>>>>>>>>>    Boolean bIsSQLTo
21081>>>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPITable
21081>>>>>>>>>>>>>>>    Handle hTable
21081>>>>>>>>>>>>>>>    Boolean bFromTable
21081>>>>>>>>>>>>>>>    Boolean bToTable
21081>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
21081>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
21081>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
21081>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
21081>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
21081>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
21081>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
21081>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
21081>>>>>>>>>>>>>>>    Boolean bShouldChange
21081>>>>>>>>>>>>>>>    Boolean bCancel
21081>>>>>>>>>>>>>>>    Boolean bError
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPITableCompare
21081>>>>>>>>>>>>>>>    Handle hTable
21081>>>>>>>>>>>>>>>    // FROM database:
21081>>>>>>>>>>>>>>>    Boolean bExistsFrom
21081>>>>>>>>>>>>>>>    // TO database:
21081>>>>>>>>>>>>>>>    Boolean bExistsTo
21081>>>>>>>>>>>>>>>    // Both:
21081>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
21081>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
21081>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
21081>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
21081>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
21081>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
21081>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
21081>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
21081>>>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
21081>>>>>>>>>>>>>>>    Boolean bCancel         // User cancel
21081>>>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Struct tAPITableBooleans
21081>>>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
21081>>>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
21081>>>>>>>>>>>>>>>    Boolean bCompareIndexAscending
21081>>>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
21081>>>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
21081>>>>>>>>>>>>>>>End_Struct
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
21081>>>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
21081>>>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
21081>>>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
21081>>>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
21081>>>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
21081>>>>>>>>>>>>>>>Enum_List
21081>>>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
21081>>>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
21081>>>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
21081>>>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
21081>>>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
21081>>>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
21081>>>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
21081>>>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
21081>>>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
21081>>>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
21081>>>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
21081>>>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
21081>>>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
21081>>>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
21081>>>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
21081>>>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
21081>>>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
21081>>>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
21081>>>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
21081>>>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
21081>>>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
21081>>>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
21081>>>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
21081>>>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
21081>>>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
21081>>>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
21081>>>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
21081>>>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
21081>>>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
21081>>>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
21081>>>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
21081>>>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
21081>>>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
21081>>>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
21081>>>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
21081>>>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
21081>>>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
21081>>>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
21081>>>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
21081>>>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
21081>>>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
21081>>>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
21081>>>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
21081>>>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
21081>>>>>>>>>>>>>>>End_Enum_List
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>>>>>
21081>>>>>>>>>>>
21081>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
21081>>>>>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
21081>>>>>>>>>>>
21081>>>>>>>>>>>
21081>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
21081>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
21081>>>>>>>>>>>
21081>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
21081>>>>>>>>>>>
21081>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
21081>>>>>>>>>>>
21081>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
21081>>>>>>>>>>>
21081>>>>>>>>>>>    Define MDSDB2    for "MDS_DB2"
21081>>>>>>>>>>>
21081>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
21081>>>>>>>>>>>
21081>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
21081>>>>>>>>>>>// They can have slightly different SQL keywords.
21081>>>>>>>>>>>// Note: If a new type is added to the list,
21081>>>>>>>>>>>//       the struct array xxx must be adjusted
21081>>>>>>>>>>>//       so that it is filled with all SQL
21081>>>>>>>>>>>//       keywords for that new type.
21081>>>>>>>>>>>Enum_List  
21081>>>>>>>>>>>End_Enum_List
21081>>>>>>>>>>>
21081>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
21081>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
21081>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
21081>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
21081>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
21081>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
21081>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
21081>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
21081>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
21081>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
21081>>>>>>>>>>>
21081>>>>>>>>>>>
21081>>>>>>>>>>>// SQLConnection.ini constants:
21081>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
21081>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
21081>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
21081>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
21081>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
21081>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
21081>>>>>>>>>>>
21081>>>>>>>>>>>// DF 19 ini-file settings:
21081>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
21081>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
21081>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
21081>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
21081>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
21081>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
21081>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
21081>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
21081>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
21081>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
21081>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
21081>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
21081>>>>>>>>>>>
21081>>>>>>>>>>>// Database Update Framework extended settings:
21081>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
21081>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
21081>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
21081>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
21081>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
21081>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
21081>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
21081>>>>>>>>>>>
21081>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
21081>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
21081>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
21081>>>>>>>>>>>
21081>>>>>>>>>>>Struct tSQLConnection
21081>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
21081>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
21081>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
21081>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
21081>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
21081>>>>>>>>>>>    String sDatabase                // 6. SQL Database
21081>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
21081>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
21081>>>>>>>>>>>    String sUserID                  // 9. User ID
21081>>>>>>>>>>>    String sPassword                // 10. Password
21081>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
21081>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
21081>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
21081>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
21081>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
21081>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
21081>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
21081>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
21081>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
21081>>>>>>>>>>>End_Struct
21081>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
21081>>>>>>>>>
21081>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
21082>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
21084>>>>>>>>>        Handle hoSQLManagerMT
21084>>>>>>>>>
21084>>>>>>>>>        Property String private.psUseDatabase ""
21085>>>>>>>>>
21085>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
21085>>>>>>>>>        Property Handle  private.phCurrentTable 0
21086>>>>>>>>>        Property Integer private.piCurrentField 0
21087>>>>>>>>>
21087>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
21088>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
21089>>>>>>>>>
21089>>>>>>>>>        Property Handle phoSQLManagerMT
21090>>>>>>>>>
21090>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
21091>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
21092>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
21093>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
21094>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
21095>>>>>>>>>
21095>>>>>>>>>        Property Boolean pbHandleQueryErrors True
21096>>>>>>>>>
21096>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
21097>>>>>>>>>        Property String[] paSQLFetchResults
21098>>>>>>>>>
21098>>>>>>>>>        // Error handling
21098>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
21099>>>>>>>>>        Property Boolean pbSqlError False
21100>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
21101>>>>>>>>>        Property Boolean pbProcessingError False
21102>>>>>>>>>
21102>>>>>>>>>        // Statistics on query
21102>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
21103>>>>>>>>>        Property TimeSpan ptsQueryExec
21104>>>>>>>>>        Property TimeSpan ptsFetchResults
21105>>>>>>>>>        Property Integer piColumns 0
21106>>>>>>>>>        Property Integer piRows 0
21107>>>>>>>>>        Property Integer piRowType 0
21108>>>>>>>>>        Property String[] paQueryMessages
21109>>>>>>>>>        Property String psSQLStatementString
21110>>>>>>>>>
21110>>>>>>>>>        Property Integer[] paTableConvertExceptions
21111>>>>>>>>>
21111>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
21112>>>>>>>>>
21112>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
21112>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
21112>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
21112>>>>>>>>>        Property Integer piChunkMax 500
21113>>>>>>>>>
21113>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
21113>>>>>>>>>        Send SetupSQLKeywordArray
21114>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
21115>>>>>>>>>    End_Procedure
21116>>>>>>>>>
21116>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
21116>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
21118>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
21120>>>>>>>>>            Function_Return (EQ)
21121>>>>>>>>>        End
21121>>>>>>>>>>
21121>>>>>>>>>        Function_Return (GT)
21122>>>>>>>>>    End_Function
21123>>>>>>>>>
21123>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
21123>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
21125>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
21128>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
21131>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
21134>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
21137>>>>>>>>>
21137>>>>>>>>>        Function_Return (EQ)
21138>>>>>>>>>    End_Function
21139>>>>>>>>>
21139>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
21141>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
21141>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
21142>>>>>>>>>        Integer iSize
21142>>>>>>>>>
21142>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
21143>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
21144>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
21145>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
21146>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
21147>>>>>>>>>
21147>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
21148>>>>>>>>>    End_Procedure
21149>>>>>>>>>
21149>>>>>>>>>    // Creates a struct array with all SQL keywords
21149>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
21149>>>>>>>>>    // have slightly different wording.
21149>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
21149>>>>>>>>>    // needs to be done for every keyword group below.
21149>>>>>>>>>    Procedure SetupSQLKeywordArray
21151>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
21151>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
21153>>>>>>>>>
21153>>>>>>>>>        // This should only be called once; but in case it is
21153>>>>>>>>>        // we delete the array first.
21153>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
21154>>>>>>>>>
21154>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
21154>>>>>>>>>        //
21154>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
21155>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
21156>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
21157>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
21158>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
21159>>>>>>>>>
21159>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
21160>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
21161>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
21162>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
21163>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
21164>>>>>>>>>
21164>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
21165>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
21166>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
21167>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
21168>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
21169>>>>>>>>>
21169>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
21170>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
21171>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
21172>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
21173>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
21174>>>>>>>>>
21174>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
21175>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
21176>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
21177>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
21178>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
21179>>>>>>>>>
21179>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
21180>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
21181>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
21182>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
21183>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
21184>>>>>>>>>
21184>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
21185>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
21186>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
21187>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
21188>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
21189>>>>>>>>>
21189>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
21190>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
21191>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
21192>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
21193>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
21194>>>>>>>>>
21194>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
21195>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
21196>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
21197>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
21198>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
21199>>>>>>>>>
21199>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
21200>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
21201>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
21202>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
21203>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
21204>>>>>>>>>
21204>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
21205>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
21206>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
21207>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
21208>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
21209>>>>>>>>>
21209>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
21210>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
21211>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
21212>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
21213>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
21214>>>>>>>>>
21214>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
21215>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
21216>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
21217>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
21218>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
21219>>>>>>>>>
21219>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
21220>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
21221>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
21222>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
21223>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
21224>>>>>>>>>
21224>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
21225>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
21226>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
21227>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
21228>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
21229>>>>>>>>>
21229>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
21230>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
21231>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
21232>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
21233>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
21234>>>>>>>>>
21234>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
21235>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
21236>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
21237>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
21238>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
21239>>>>>>>>>
21239>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
21240>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
21241>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
21242>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
21243>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
21244>>>>>>>>>
21244>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
21245>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
21246>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
21247>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
21248>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
21249>>>>>>>>>
21249>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
21250>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
21251>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
21252>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
21253>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
21254>>>>>>>>>
21254>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
21255>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
21256>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
21257>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
21258>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
21259>>>>>>>>>
21259>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
21260>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
21261>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
21262>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
21263>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
21264>>>>>>>>>
21264>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
21265>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
21266>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
21267>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
21268>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
21269>>>>>>>>>
21269>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
21270>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
21271>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
21272>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
21273>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
21274>>>>>>>>>
21274>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
21275>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
21276>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
21277>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
21278>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
21279>>>>>>>>>
21279>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
21280>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
21281>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
21282>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
21283>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
21284>>>>>>>>>
21284>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
21285>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
21286>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
21287>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
21288>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
21289>>>>>>>>>
21289>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
21290>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
21291>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
21292>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
21293>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
21294>>>>>>>>>
21294>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
21295>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
21296>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
21297>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
21298>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
21299>>>>>>>>>
21299>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
21300>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
21301>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
21302>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
21303>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
21304>>>>>>>>>
21304>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
21305>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
21306>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
21307>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
21308>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
21309>>>>>>>>>
21309>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
21310>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
21311>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
21312>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
21313>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
21314>>>>>>>>>
21314>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
21315>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
21316>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
21317>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
21318>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
21319>>>>>>>>>
21319>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
21320>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
21321>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
21322>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
21323>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
21324>>>>>>>>>
21324>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
21325>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
21326>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
21327>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
21328>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
21329>>>>>>>>>
21329>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
21330>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
21331>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
21332>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
21333>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
21334>>>>>>>>>
21334>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
21335>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
21336>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
21337>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
21338>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
21339>>>>>>>>>
21339>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
21340>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
21341>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
21342>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
21343>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
21344>>>>>>>>>
21344>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
21345>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
21346>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
21347>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
21348>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
21349>>>>>>>>>
21349>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
21350>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
21351>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
21352>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
21353>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
21354>>>>>>>>>
21354>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
21355>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
21356>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
21357>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
21358>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
21359>>>>>>>>>
21359>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
21360>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
21361>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
21362>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
21363>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
21364>>>>>>>>>
21364>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
21365>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
21366>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
21367>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
21368>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
21369>>>>>>>>>
21369>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
21370>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
21371>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
21372>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
21373>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
21374>>>>>>>>>
21374>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
21374>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
21375>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
21376>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
21377>>>>>>>>>
21377>>>>>>>>>    End_Procedure
21378>>>>>>>>>
21378>>>>>>>>>End_Class
21379>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cSQLConnectionHandler.pkg)
21379>>>>>>>>>//****************************************************************************
21379>>>>>>>>>// $Module type: Class
21379>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
21379>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
21379>>>>>>>>>// Web-site    : http://www.rdctools.com
21379>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
21379>>>>>>>>>//
21379>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
21379>>>>>>>>>//
21379>>>>>>>>>// $Rev History:
21379>>>>>>>>>//    2015-08-11  Module header created
21379>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
21379>>>>>>>>>//                Added a new structure for passing connection data back & forth.
21379>>>>>>>>>//                Added better error handling.
21379>>>>>>>>>//                Added a decompose message for the connection string.
21379>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
21379>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
21379>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
21379>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
21379>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
21379>>>>>>>>>//****************************************************************************
21379>>>>>>>>>Use cli.pkg
21379>>>>>>>>>Use MSSqldrv.pkg
21379>>>>>>>>>Use db2_drv.pkg
21379>>>>>>>>>Use odbc_drv.pkg
21379>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cSQLConnectionIniFile.pkg)
21379>>>>>>>>>>>//****************************************************************************
21379>>>>>>>>>>>// $Module type: Class
21379>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
21379>>>>>>>>>>>//
21379>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
21379>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
21379>>>>>>>>>>>// E-mail      : support@rdctools.com
21379>>>>>>>>>>>// Web-site    : http://www.rdctools.com
21379>>>>>>>>>>>//
21379>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
21379>>>>>>>>>>>//
21379>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
21379>>>>>>>>>>>//               properties of that object.
21379>>>>>>>>>>>//
21379>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
21379>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
21379>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
21379>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
21379>>>>>>>>>>>// in the help folder for more details.
21379>>>>>>>>>>>//
21379>>>>>>>>>>>Use cSQLConnectionIniFile.inc
21379>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateDatabaseDriver.pkg)
21379>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
21379>>>>>>>>>>>>>
21379>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
21380>>>>>>>>>>>>>    Procedure Construct_Object
21382>>>>>>>>>>>>>        Forward Send Construct_Object
21384>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
21385>>>>>>>>>>>>>    End_Procedure
21386>>>>>>>>>>>>>
21386>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
21388>>>>>>>>>>>>>        String sRetval
21388>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
21390>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
21391>>>>>>>>>>>>>        End                                        
21391>>>>>>>>>>>>>>
21391>>>>>>>>>>>>>        Else Begin
21392>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
21393>>>>>>>>>>>>>        End
21393>>>>>>>>>>>>>>
21393>>>>>>>>>>>>>            
21393>>>>>>>>>>>>>        Function_Return sRetval
21394>>>>>>>>>>>>>    End_Function
21395>>>>>>>>>>>>>
21395>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21397>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
21397>>>>>>>>>>>>>
21397>>>>>>>>>>>>>        Get psDriverID to sDriverID
21398>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
21399>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
21400>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
21402>>>>>>>>>>>>>            Move "" to sDatabase
21403>>>>>>>>>>>>>        End
21403>>>>>>>>>>>>>>
21403>>>>>>>>>>>>>        
21403>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
21403>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
21403>>>>>>>>>>>>>//            Function_Return sConnect
21403>>>>>>>>>>>>>//        End
21403>>>>>>>>>>>>>
21403>>>>>>>>>>>>>        If (sDatabase <> "") Begin
21405>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
21406>>>>>>>>>>>>>        End
21406>>>>>>>>>>>>>>
21406>>>>>>>>>>>>>        If (bTrusted = True) Begin
21408>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
21409>>>>>>>>>>>>>        End
21409>>>>>>>>>>>>>>
21409>>>>>>>>>>>>>        Else Begin
21410>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
21411>>>>>>>>>>>>>        End
21411>>>>>>>>>>>>>>
21411>>>>>>>>>>>>>        Function_Return sConnect
21412>>>>>>>>>>>>>    End_Function
21413>>>>>>>>>>>>>
21413>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21415>>>>>>>>>>>>>        Boolean bLoginSuccessful
21415>>>>>>>>>>>>>        String sDriverID
21415>>>>>>>>>>>>>
21415>>>>>>>>>>>>>        Get psDriverID to sDriverID
21416>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
21418>>>>>>>>>>>>>            Function_Return True
21419>>>>>>>>>>>>>        End
21419>>>>>>>>>>>>>>
21419>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
21420>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
21422>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
21423>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
21425>>>>>>>>>>>>>        End
21425>>>>>>>>>>>>>>
21425>>>>>>>>>>>>>        Else Begin
21426>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
21428>>>>>>>>>>>>>        End
21428>>>>>>>>>>>>>>
21428>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
21429>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21430>>>>>>>>>>>>>    End_Function
21431>>>>>>>>>>>>>End_Class
21432>>>>>>>>>>>>>
21432>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
21433>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
21435>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
21436>>>>>>>>>>>>>    End_Function
21437>>>>>>>>>>>>>End_Class
21438>>>>>>>>>>>>>
21438>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
21439>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21441>>>>>>>>>>>>>        Boolean bLoginSuccessful
21441>>>>>>>>>>>>>        String sDriverID
21441>>>>>>>>>>>>>
21441>>>>>>>>>>>>>        Get psDriverID to sDriverID
21442>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
21443>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
21445>>>>>>>>>>>>>            Function_Return True
21446>>>>>>>>>>>>>        End
21446>>>>>>>>>>>>>>
21446>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
21447>>>>>>>>>>>>>        If (bTrusted = False) Begin
21449>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
21451>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
21452>>>>>>>>>>>>>            End
21452>>>>>>>>>>>>>>
21452>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21455>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21456>>>>>>>>>>>>>            End
21456>>>>>>>>>>>>>>
21456>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
21458>>>>>>>>>>>>>        End
21458>>>>>>>>>>>>>>
21458>>>>>>>>>>>>>        Else Begin
21459>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
21461>>>>>>>>>>>>>        End
21461>>>>>>>>>>>>>>
21461>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
21462>>>>>>>>>>>>>
21462>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21463>>>>>>>>>>>>>    End_Function
21464>>>>>>>>>>>>>End_Class
21465>>>>>>>>>>>>>
21465>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
21466>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21468>>>>>>>>>>>>>        Boolean bLoginSuccessful
21468>>>>>>>>>>>>>        String sDriverID
21468>>>>>>>>>>>>>
21468>>>>>>>>>>>>>        Move False to Err
21469>>>>>>>>>>>>>        Get psDriverID to sDriverID
21470>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21472>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21473>>>>>>>>>>>>>        End
21473>>>>>>>>>>>>>>
21473>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21475>>>>>>>>>>>>>
21475>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21476>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21477>>>>>>>>>>>>>    End_Function
21478>>>>>>>>>>>>>End_Class
21479>>>>>>>>>>>>>
21479>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
21480>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21482>>>>>>>>>>>>>        Boolean bLoginSuccessful
21482>>>>>>>>>>>>>        String sDriverID
21482>>>>>>>>>>>>>
21482>>>>>>>>>>>>>        Move False to Err
21483>>>>>>>>>>>>>        Get psDriverID to sDriverID
21484>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21484>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21484>>>>>>>>>>>>>//        End
21484>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21486>>>>>>>>>>>>>
21486>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21487>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21488>>>>>>>>>>>>>    End_Function
21489>>>>>>>>>>>>>End_Class
21490>>>>>>>>>>>>>
21490>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
21491>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21493>>>>>>>>>>>>>        Function_Return ""
21494>>>>>>>>>>>>>    End_Function
21495>>>>>>>>>>>>>End_Class
21496>>>>>>>>>>>>>
21496>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
21497>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21499>>>>>>>>>>>>>        Boolean bLoginSuccessful
21499>>>>>>>>>>>>>        String sDriverID
21499>>>>>>>>>>>>>
21499>>>>>>>>>>>>>        Get psDriverID to sDriverID
21500>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
21500>>>>>>>>>>>>>        Move False to Err
21501>>>>>>>>>>>>>        If (bTrusted = False) Begin
21503>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
21505>>>>>>>>>>>>>        End
21505>>>>>>>>>>>>>>
21505>>>>>>>>>>>>>        Else Begin
21506>>>>>>>>>>>>>            Login sServer "" "" sDriverID
21508>>>>>>>>>>>>>        End
21508>>>>>>>>>>>>>>
21508>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21509>>>>>>>>>>>>>
21509>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21510>>>>>>>>>>>>>    End_Function
21511>>>>>>>>>>>>>End_Class
21512>>>>>>>>>>>>>
21512>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
21513>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21515>>>>>>>>>>>>>        Boolean bLoginSuccessful
21515>>>>>>>>>>>>>        String sDriverID
21515>>>>>>>>>>>>>        Integer iPos
21515>>>>>>>>>>>>>
21515>>>>>>>>>>>>>        Get psDriverID to sDriverID
21516>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
21517>>>>>>>>>>>>>        If (iPos = 0) Begin
21519>>>>>>>>>>>>>            If (sDatabase <> "") Begin
21521>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
21522>>>>>>>>>>>>>            End
21522>>>>>>>>>>>>>>
21522>>>>>>>>>>>>>        End
21522>>>>>>>>>>>>>>
21522>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
21522>>>>>>>>>>>>>        Move False to Err
21523>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
21523>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21525>>>>>>>>>>>>>
21525>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21526>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21527>>>>>>>>>>>>>    End_Function
21528>>>>>>>>>>>>>End_Class
21529>>>>>>>>>>>>>
21529>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
21530>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21532>>>>>>>>>>>>>        Boolean bLoginSuccessful
21532>>>>>>>>>>>>>        String sDriverID
21532>>>>>>>>>>>>>
21532>>>>>>>>>>>>>        Get psDriverID to sDriverID
21533>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
21533>>>>>>>>>>>>>        Move False to Err
21534>>>>>>>>>>>>>        If (bTrusted = False) Begin
21536>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
21538>>>>>>>>>>>>>        End
21538>>>>>>>>>>>>>>
21538>>>>>>>>>>>>>        Else Begin
21539>>>>>>>>>>>>>            Login sServer "" "" sDriverID
21541>>>>>>>>>>>>>        End
21541>>>>>>>>>>>>>>
21541>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21542>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21543>>>>>>>>>>>>>    End_Function
21544>>>>>>>>>>>>>End_Class
21545>>>>>>>>>>>>>
21545>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
21546>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21548>>>>>>>>>>>>>        Boolean bLoginSuccessful
21548>>>>>>>>>>>>>        String sDriverID
21548>>>>>>>>>>>>>
21548>>>>>>>>>>>>>        Get psDriverID to sDriverID
21549>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
21549>>>>>>>>>>>>>        Move False to Err
21550>>>>>>>>>>>>>        If (bTrusted = False) Begin
21552>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
21554>>>>>>>>>>>>>        End
21554>>>>>>>>>>>>>>
21554>>>>>>>>>>>>>        Else Begin
21555>>>>>>>>>>>>>            Login sServer "" "" sDriverID
21557>>>>>>>>>>>>>        End
21557>>>>>>>>>>>>>>
21557>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21558>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21559>>>>>>>>>>>>>    End_Function
21560>>>>>>>>>>>>>End_Class
21561>>>>>>>>>>>>>
21561>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
21562>>>>>>>>>>>>>    Procedure Construct_Object
21564>>>>>>>>>>>>>        Forward Send Construct_Object
21566>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
21567>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
21568>>>>>>>>>>>>>    End_Procedure
21569>>>>>>>>>>>>>
21569>>>>>>>>>>>>>    Function CreateDriver Returns Handle
21571>>>>>>>>>>>>>        String sDriverID
21571>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
21571>>>>>>>>>>>>>
21571>>>>>>>>>>>>>        Get psDriverID to sDriverID
21572>>>>>>>>>>>>>        Case Begin
21572>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
21574>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
21575>>>>>>>>>>>>>                Case Break
21576>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
21579>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
21580>>>>>>>>>>>>>                Case Break
21581>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
21584>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
21585>>>>>>>>>>>>>                Case Break               
21586>>>>>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
21586>>>>>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
21586>>>>>>>>>>>>>//                Case Break
21586>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
21589>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
21590>>>>>>>>>>>>>                Case Break
21591>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
21594>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
21595>>>>>>>>>>>>>                Case Break
21596>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
21599>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
21600>>>>>>>>>>>>>                Case Break
21601>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
21604>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
21605>>>>>>>>>>>>>                Case Break
21606>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
21606>>>>>>>>>>>>>            Case Else
21606>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
21607>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
21608>>>>>>>>>>>>>        Case End
21608>>>>>>>>>>>>>
21608>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
21609>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
21610>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
21611>>>>>>>>>>>>>
21611>>>>>>>>>>>>>        Function_Return hoDriver
21612>>>>>>>>>>>>>    End_Function
21613>>>>>>>>>>>>>
21613>>>>>>>>>>>>>    Procedure DestroyDriver
21615>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
21617>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
21618>>>>>>>>>>>>>        End
21618>>>>>>>>>>>>>>
21618>>>>>>>>>>>>>    End_Procedure
21619>>>>>>>>>>>>>
21619>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21621>>>>>>>>>>>>>        String sConnect
21621>>>>>>>>>>>>>        Handle hoDriver
21621>>>>>>>>>>>>>
21621>>>>>>>>>>>>>        Get CreateDriver to hoDriver
21622>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
21623>>>>>>>>>>>>>        Send DestroyDriver
21624>>>>>>>>>>>>>        Function_Return sConnect
21625>>>>>>>>>>>>>    End_Function
21626>>>>>>>>>>>>>
21626>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21628>>>>>>>>>>>>>        Boolean bLoginSuccessful
21628>>>>>>>>>>>>>        Handle hoDriver
21628>>>>>>>>>>>>>
21628>>>>>>>>>>>>>        Get CreateDriver to hoDriver
21629>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
21630>>>>>>>>>>>>>        Send DestroyDriver
21631>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21632>>>>>>>>>>>>>    End_Function
21633>>>>>>>>>>>>>
21633>>>>>>>>>>>>>End_Class
21634>>>>>>>>>>>
21634>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cLoginEncryption.pkg)
21634>>>>>>>>>>>>>Use cCryptographerEx.pkg
21634>>>>>>>>>>>>>
21634>>>>>>>>>>>>>Class cLoginEncryption is a cObject
21635>>>>>>>>>>>>>    
21635>>>>>>>>>>>>>    Procedure Construct_Object
21637>>>>>>>>>>>>>        Forward Send Construct_Object
21639>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
21639>>>>>>>>>>>>>        Property String psEncryptPassword ""
21640>>>>>>>>>>>>>        
21640>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
21642>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
21643>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
21644>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
21645>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
21646>>>>>>>>>>>>>        End_Object
21647>>>>>>>>>>>>>    End_Procedure
21648>>>>>>>>>>>>>    
21648>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
21648>>>>>>>>>>>>>    // hidden mechanism desired.
21648>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
21650>>>>>>>>>>>>>        String sPassword
21650>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
21651>>>>>>>>>>>>>        Function_Return sPassword
21652>>>>>>>>>>>>>    End_Function
21653>>>>>>>>>>>>>    
21653>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
21653>>>>>>>>>>>>>    //
21653>>>>>>>>>>>>>    // Params:
21653>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
21653>>>>>>>>>>>>>    // Returns:
21653>>>>>>>>>>>>>    //   Base64 encoded hash.
21653>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
21655>>>>>>>>>>>>>        String sEncryptPassword sBase64
21655>>>>>>>>>>>>>        UChar[] ucBinary
21656>>>>>>>>>>>>>        Pointer pBase64
21656>>>>>>>>>>>>>        Integer iVoid
21656>>>>>>>>>>>>>        
21656>>>>>>>>>>>>>        //  Encrypt Key
21656>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
21657>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
21659>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
21660>>>>>>>>>>>>>>
21660>>>>>>>>>>>>>        End
21660>>>>>>>>>>>>>>
21660>>>>>>>>>>>>>        
21660>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
21661>>>>>>>>>>>>>        
21661>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
21663>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
21664>>>>>>>>>>>>>>
21664>>>>>>>>>>>>>            Function_Return ""
21665>>>>>>>>>>>>>        End
21665>>>>>>>>>>>>>>
21665>>>>>>>>>>>>>        
21665>>>>>>>>>>>>>        //  Encode binary hash to Base64
21665>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
21666>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
21667>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21668>>>>>>>>>>>>>        
21668>>>>>>>>>>>>>        Function_Return sBase64
21669>>>>>>>>>>>>>    End_Function
21670>>>>>>>>>>>>>    
21670>>>>>>>>>>>>>    
21670>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
21670>>>>>>>>>>>>>    //
21670>>>>>>>>>>>>>    // Params:
21670>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
21670>>>>>>>>>>>>>    // Returns:
21670>>>>>>>>>>>>>    //   Readable plain text password
21670>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
21672>>>>>>>>>>>>>        String sEncryptPassword
21672>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
21674>>>>>>>>>>>>>        Boolean bIsHex
21674>>>>>>>>>>>>>        Integer iLen iVoid
21674>>>>>>>>>>>>>        Pointer pBinary
21674>>>>>>>>>>>>>        
21674>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
21676>>>>>>>>>>>>>            //  Decode from Base64
21676>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
21677>>>>>>>>>>>>>            
21677>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
21678>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
21679>>>>>>>>>>>>>                        
21679>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
21680>>>>>>>>>>>>>            
21680>>>>>>>>>>>>>            //  Encrypted binary hash to string
21680>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
21681>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
21682>>>>>>>>>>>>>        End
21682>>>>>>>>>>>>>>
21682>>>>>>>>>>>>>        
21682>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
21683>>>>>>>>>>>>>    End_Function
21684>>>>>>>>>>>>>End_Class
21685>>>>>>>>>>>
21685>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
21686>>>>>>>>>>>    Procedure Construct_Object
21688>>>>>>>>>>>        Forward Send Construct_Object
21690>>>>>>>>>>>
21690>>>>>>>>>>>        Property String Private_psIniFilePath
21691>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
21692>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
21693>>>>>>>>>>>
21693>>>>>>>>>>>        Property Boolean pbDFConnId False
21694>>>>>>>>>>>
21694>>>>>>>>>>>        // *** You really want to change this value! ***
21694>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
21694>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
21695>>>>>>>>>>>
21695>>>>>>>>>>>    End_Procedure
21696>>>>>>>>>>>
21696>>>>>>>>>>>    Procedure End_Construct_Object
21698>>>>>>>>>>>        Forward Send End_Construct_Object
21700>>>>>>>>>>>    End_Procedure
21701>>>>>>>>>>>
21701>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
21703>>>>>>>>>>>        String sIniFile
21703>>>>>>>>>>>        Get vFolderFormat sPath to sPath
21704>>>>>>>>>>>        Set private_psIniFilePath to sPath
21705>>>>>>>>>>>        Get psIniFileName to sIniFile
21706>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
21707>>>>>>>>>>>    End_Procedure
21708>>>>>>>>>>>
21708>>>>>>>>>>>    Function psIniFilePath Returns String
21710>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
21711>>>>>>>>>>>    End_Function
21712>>>>>>>>>>>
21712>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
21714>>>>>>>>>>>        String sPath
21714>>>>>>>>>>>        Get psIniFilePath to sPath
21715>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
21716>>>>>>>>>>>        Set private_psIniFileName to sFileName
21717>>>>>>>>>>>    End_Procedure
21718>>>>>>>>>>>
21718>>>>>>>>>>>    Function psIniFileName Returns String
21720>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
21721>>>>>>>>>>>    End_Function
21722>>>>>>>>>>>
21722>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
21722>>>>>>>>>>>    // Sets a value in the program's ini file (write)
21722>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
21722>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
21724>>>>>>>>>>>        String sIniFile sPath
21724>>>>>>>>>>>
21724>>>>>>>>>>>        Get psIniFilePath to sPath
21725>>>>>>>>>>>        Get psIniFileName to sIniFile
21726>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
21727>>>>>>>>>>>        Set psFileName to sIniFile
21728>>>>>>>>>>>        Send WriteString sSection sValueName sValue
21729>>>>>>>>>>>    End_Procedure
21730>>>>>>>>>>>
21730>>>>>>>>>>>    // Get a value from program's ini-file (read)
21730>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
21730>>>>>>>>>>>    // Returns the value
21730>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
21732>>>>>>>>>>>        String sValue sIniFile sPath
21732>>>>>>>>>>>
21732>>>>>>>>>>>        Get psIniFilePath to sPath
21733>>>>>>>>>>>        Get psIniFileName to sIniFile
21734>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
21735>>>>>>>>>>>        Set psFileName to sIniFile
21736>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
21737>>>>>>>>>>>
21737>>>>>>>>>>>        Function_Return sValue
21738>>>>>>>>>>>    End_Function
21739>>>>>>>>>>>
21739>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
21739>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
21741>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
21744>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
21747>>>>>>>>>>>
21747>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
21750>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
21753>>>>>>>>>>>
21753>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
21756>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
21759>>>>>>>>>>>
21759>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
21762>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
21765>>>>>>>>>>>
21765>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
21768>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
21771>>>>>>>>>>>
21771>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
21774>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
21777>>>>>>>>>>>
21777>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
21780>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
21783>>>>>>>>>>>
21783>>>>>>>>>>>        Function_Return (EQ)
21784>>>>>>>>>>>    End_Function
21785>>>>>>>>>>>
21785>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
21787>>>>>>>>>>>        Handle hoSections
21787>>>>>>>>>>>        Integer iItems
21787>>>>>>>>>>>
21787>>>>>>>>>>>        Send ReadSections hoSections
21788>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
21789>>>>>>>>>>>        Function_Return iItems
21790>>>>>>>>>>>    End_Function
21791>>>>>>>>>>>
21791>>>>>>>>>>>    // The normal connection string looks something like this;
21791>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
21791>>>>>>>>>>>    // ...but the full connection string looks like this;
21791>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
21791>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
21791>>>>>>>>>>>//        String sSection
21791>>>>>>>>>>>//        Integer iCount
21791>>>>>>>>>>>//
21791>>>>>>>>>>>//        Move False to Err
21791>>>>>>>>>>>//        Get psIniSectionName to sSection
21791>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
21791>>>>>>>>>>>//        Increment iCount
21791>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
21791>>>>>>>>>>>//
21791>>>>>>>>>>>//        Function_Return (Err = False)
21791>>>>>>>>>>>//    End_Function
21791>>>>>>>>>>>
21791>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
21793>>>>>>>>>>>        Integer iCount
21793>>>>>>>>>>>        Boolean bExists
21793>>>>>>>>>>>        String sSection
21793>>>>>>>>>>>
21793>>>>>>>>>>>        Move False to Err
21794>>>>>>>>>>>        Move 1 to iCount
21795>>>>>>>>>>>        Get psIniSectionName to sSection
21796>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
21797>>>>>>>>>>>        While (bExists = True)
21801>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
21802>>>>>>>>>>>            Increment iCount
21803>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
21804>>>>>>>>>>>        Loop
21805>>>>>>>>>>>>
21805>>>>>>>>>>>        Function_Return (Err = False)
21806>>>>>>>>>>>    End_Function
21807>>>>>>>>>>>
21807>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
21809>>>>>>>>>>>        Integer iCount
21809>>>>>>>>>>>        String sSection
21809>>>>>>>>>>>        Boolean bExists
21809>>>>>>>>>>>
21809>>>>>>>>>>>        Move False to Err
21810>>>>>>>>>>>        Move 1 to iCount
21811>>>>>>>>>>>        Get psIniSectionName to sSection
21812>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
21813>>>>>>>>>>>        While (bExists = True)
21817>>>>>>>>>>>            If (iCount = iItem) Begin
21819>>>>>>>>>>>                Send DeleteSection sSection
21820>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
21820>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
21821>>>>>>>>>>>            End
21821>>>>>>>>>>>>
21821>>>>>>>>>>>            Increment iCount
21822>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
21823>>>>>>>>>>>        Loop
21824>>>>>>>>>>>>
21824>>>>>>>>>>>
21824>>>>>>>>>>>        Function_Return (Err = False)
21825>>>>>>>>>>>    End_Function
21826>>>>>>>>>>>
21826>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
21826>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
21826>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
21828>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21828>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21829>>>>>>>>>>>        tSQLConnection   SQLConnection
21829>>>>>>>>>>>        tSQLConnection   SQLConnection
21829>>>>>>>>>>>        Integer iIndex
21829>>>>>>>>>>>
21829>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
21830>>>>>>>>>>>        If (iIndex = -1) Begin
21832>>>>>>>>>>>            Move True to SQLConnection.bError
21833>>>>>>>>>>>            Function_Return SQLConnection
21834>>>>>>>>>>>        End
21834>>>>>>>>>>>>
21834>>>>>>>>>>>
21834>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
21835>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
21836>>>>>>>>>>>
21836>>>>>>>>>>>        Function_Return SQLConnection
21837>>>>>>>>>>>    End_Function
21838>>>>>>>>>>>
21838>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
21838>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
21840>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21840>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21841>>>>>>>>>>>        Integer iRetval iCount iSize
21841>>>>>>>>>>>        String sValue
21841>>>>>>>>>>>        Boolean bExists
21841>>>>>>>>>>>
21841>>>>>>>>>>>        Move -1 to iRetval
21842>>>>>>>>>>>
21842>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
21843>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
21844>>>>>>>>>>>        Decrement iSize
21845>>>>>>>>>>>        For iCount from 0 to iSize
21851>>>>>>>>>>>>
21851>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
21852>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
21853>>>>>>>>>>>            If (bExists) Begin
21855>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
21856>>>>>>>>>>>                Move iSize to iCount         // We're done!
21857>>>>>>>>>>>            End
21857>>>>>>>>>>>>
21857>>>>>>>>>>>        Loop
21858>>>>>>>>>>>>
21858>>>>>>>>>>>
21858>>>>>>>>>>>        Function_Return iRetval
21859>>>>>>>>>>>    End_Function
21860>>>>>>>>>>>
21860>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
21860>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
21860>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
21862>>>>>>>>>>>        Integer iCount iSize iItems
21862>>>>>>>>>>>        String sValue
21862>>>>>>>>>>>        Boolean bExists
21862>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21862>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21863>>>>>>>>>>>
21863>>>>>>>>>>>        Move 0 to iItems
21864>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
21865>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
21866>>>>>>>>>>>        Decrement iSize
21867>>>>>>>>>>>        For iCount from 0 to iSize
21873>>>>>>>>>>>>
21873>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
21874>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
21875>>>>>>>>>>>            If (bExists) Begin
21877>>>>>>>>>>>                Increment iItems
21878>>>>>>>>>>>            End
21878>>>>>>>>>>>>
21878>>>>>>>>>>>        Loop
21879>>>>>>>>>>>>
21879>>>>>>>>>>>
21879>>>>>>>>>>>        Function_Return (iItems > 1)
21880>>>>>>>>>>>    End_Function
21881>>>>>>>>>>>
21881>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
21881>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
21883>>>>>>>>>>>        Boolean bOK
21883>>>>>>>>>>>        Integer iSize iCount
21883>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21883>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21884>>>>>>>>>>>        tSQLConnection SQLConnection
21884>>>>>>>>>>>        tSQLConnection SQLConnection
21884>>>>>>>>>>>        String sConnectionString
21884>>>>>>>>>>>
21884>>>>>>>>>>>        Move False to Err
21885>>>>>>>>>>>        Get psConnectionString to sConnectionString
21886>>>>>>>>>>>
21886>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
21887>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
21888>>>>>>>>>>>        Decrement iSize
21889>>>>>>>>>>>        // Set all current connection to inactive.
21889>>>>>>>>>>>        For iCount from 0 to iSize
21895>>>>>>>>>>>>
21895>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
21896>>>>>>>>>>>        Loop
21897>>>>>>>>>>>>
21897>>>>>>>>>>>
21897>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
21898>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
21899>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
21900>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
21901>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
21902>>>>>>>>>>>
21902>>>>>>>>>>>        Function_Return (bOK = True)
21903>>>>>>>>>>>    End_Function
21904>>>>>>>>>>>
21904>>>>>>>>>>>    // Used for updating an existing connection with new data.
21904>>>>>>>>>>>    // Returns True if successful.
21904>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
21906>>>>>>>>>>>        Boolean bOK
21906>>>>>>>>>>>        Integer iItem iSize iCount
21906>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21906>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21907>>>>>>>>>>>
21907>>>>>>>>>>>        Move False to Err
21908>>>>>>>>>>>        Move -1 to iItem
21909>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
21910>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
21911>>>>>>>>>>>        Decrement iSize
21912>>>>>>>>>>>        // Set all current connection to inactive.
21912>>>>>>>>>>>        For iCount from 0 to iSize
21918>>>>>>>>>>>>
21918>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
21919>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
21921>>>>>>>>>>>                Move iCount to iItem
21922>>>>>>>>>>>            End
21922>>>>>>>>>>>>
21922>>>>>>>>>>>        Loop
21923>>>>>>>>>>>>
21923>>>>>>>>>>>
21923>>>>>>>>>>>        If (iItem <> -1) Begin
21925>>>>>>>>>>>            Move True to SQLConnection.bEnabled
21926>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
21927>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
21928>>>>>>>>>>>        End
21928>>>>>>>>>>>>
21928>>>>>>>>>>>
21928>>>>>>>>>>>        Function_Return (bOK = True)
21929>>>>>>>>>>>    End_Function
21930>>>>>>>>>>>
21930>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
21932>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21932>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
21933>>>>>>>>>>>        String sSection sValue
21933>>>>>>>>>>>        Integer iCount
21933>>>>>>>>>>>        Boolean bExists
21933>>>>>>>>>>>
21933>>>>>>>>>>>        Get psIniSectionName to sSection
21934>>>>>>>>>>>        Get SectionExists sSection to bExists
21935>>>>>>>>>>>        If (bExists = False) Begin
21937>>>>>>>>>>>            Function_Return SQLConnectionsArray
21938>>>>>>>>>>>        End
21938>>>>>>>>>>>>
21938>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
21939>>>>>>>>>>>        If (bExists = True) Begin
21941>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
21942>>>>>>>>>>>>
21942>>>>>>>>>>>        End
21942>>>>>>>>>>>>
21942>>>>>>>>>>>
21942>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
21943>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
21944>>>>>>>>>>>
21944>>>>>>>>>>>        While (bExists = True)                 
21948>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
21948>>>>>>>>>>>            // We always put the enabled/active connection at the top
21948>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
21948>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
21948>>>>>>>>>>>
21948>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
21949>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
21950>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
21951>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
21952>>>>>>>>>>>
21952>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
21952>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
21953>>>>>>>>>>>            If (sValue = "99") Begin
21955>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
21956>>>>>>>>>>>            End
21956>>>>>>>>>>>>
21956>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
21957>>>>>>>>>>>
21957>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
21958>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
21959>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
21961>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
21962>>>>>>>>>>>            End
21962>>>>>>>>>>>>
21962>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
21964>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
21965>>>>>>>>>>>            End
21965>>>>>>>>>>>>
21965>>>>>>>>>>>
21965>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
21966>>>>>>>>>>>
21966>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
21967>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
21968>>>>>>>>>>>
21968>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
21969>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
21970>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
21972>>>>>>>>>>>                Get DecryptPassword sValue to sValue
21973>>>>>>>>>>>            End
21973>>>>>>>>>>>>
21973>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
21974>>>>>>>>>>>
21974>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
21974>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
21975>>>>>>>>>>>
21975>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
21976>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
21977>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
21978>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
21979>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
21980>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
21981>>>>>>>>>>>
21981>>>>>>>>>>>            Increment iCount
21982>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
21983>>>>>>>>>>>        Loop
21984>>>>>>>>>>>>
21984>>>>>>>>>>>
21984>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
21984>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
21986>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
21987>>>>>>>>>>>        End
21987>>>>>>>>>>>>
21987>>>>>>>>>>>
21987>>>>>>>>>>>        Function_Return SQLConnectionsArray
21988>>>>>>>>>>>    End_Function
21989>>>>>>>>>>>
21989>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
21991>>>>>>>>>>>        Integer iCount iSize
21991>>>>>>>>>>>        Boolean bOK
21991>>>>>>>>>>>        String sSection sValue
21991>>>>>>>>>>>
21991>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
21991>>>>>>>>>>>        Move 0 to iCount
21992>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
21993>>>>>>>>>>>        If (bOK = False) Begin
21995>>>>>>>>>>>            Function_Return False
21996>>>>>>>>>>>        End
21996>>>>>>>>>>>>
21996>>>>>>>>>>>
21996>>>>>>>>>>>        Move False to Err
21997>>>>>>>>>>>        Get psIniSectionName to sSection
21998>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
21998>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
21999>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22000>>>>>>>>>>>        Decrement iSize
22001>>>>>>>>>>>
22001>>>>>>>>>>>        For iCount from 0 to iSize
22007>>>>>>>>>>>>
22007>>>>>>>>>>>            // DF 19 compatible settings:
22007>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
22008>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
22009>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
22010>>>>>>>>>>>            
22010>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
22011>>>>>>>>>>>
22011>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
22012>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
22014>>>>>>>>>>>                Get EncryptPassword sValue to sValue
22015>>>>>>>>>>>            End
22015>>>>>>>>>>>>
22015>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
22016>>>>>>>>>>>
22016>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
22018>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
22019>>>>>>>>>>>            End
22019>>>>>>>>>>>>
22019>>>>>>>>>>>
22019>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
22020>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
22021>>>>>>>>>>>
22021>>>>>>>>>>>            // The Database Update Framework extended settings:
22021>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
22022>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
22023>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
22024>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
22025>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
22026>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
22027>>>>>>>>>>>        Loop
22028>>>>>>>>>>>>
22028>>>>>>>>>>>
22028>>>>>>>>>>>        Function_Return (bOK and Err = False)
22029>>>>>>>>>>>    End_Function
22030>>>>>>>>>>>
22030>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
22030>>>>>>>>>>>    //
22030>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
22030>>>>>>>>>>>    // corresponding to the passed iDbType.
22030>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
22032>>>>>>>>>>>        String sRetval
22032>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
22034>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
22035>>>>>>>>>>>        End
22035>>>>>>>>>>>>
22035>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
22037>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
22038>>>>>>>>>>>        End
22038>>>>>>>>>>>>
22038>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
22040>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
22041>>>>>>>>>>>        End
22041>>>>>>>>>>>>
22041>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
22043>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
22044>>>>>>>>>>>        End
22044>>>>>>>>>>>>
22044>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
22046>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
22047>>>>>>>>>>>        End
22047>>>>>>>>>>>>
22047>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
22049>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
22050>>>>>>>>>>>        End
22050>>>>>>>>>>>>
22050>>>>>>>>>>>        Function_Return sRetval
22051>>>>>>>>>>>    End_Function
22052>>>>>>>>>>>
22052>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
22052>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
22052>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
22054>>>>>>>>>>>        Integer iRetval
22054>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
22056>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22057>>>>>>>>>>>        End
22057>>>>>>>>>>>>
22057>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
22059>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
22060>>>>>>>>>>>        End
22060>>>>>>>>>>>>
22060>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
22062>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
22063>>>>>>>>>>>        End
22063>>>>>>>>>>>>
22063>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
22065>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
22066>>>>>>>>>>>        End
22066>>>>>>>>>>>>
22066>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
22068>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
22069>>>>>>>>>>>        End
22069>>>>>>>>>>>>
22069>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
22071>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
22072>>>>>>>>>>>        End
22072>>>>>>>>>>>>
22072>>>>>>>>>>>        Function_Return iRetval
22073>>>>>>>>>>>    End_Function
22074>>>>>>>>>>>
22074>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
22074>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
22074>>>>>>>>>>>    // the SQL Connection program's grid.
22074>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
22076>>>>>>>>>>>        String sRetval
22076>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
22078>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
22079>>>>>>>>>>>        End
22079>>>>>>>>>>>>
22079>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
22081>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
22082>>>>>>>>>>>        End
22082>>>>>>>>>>>>
22082>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
22084>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
22085>>>>>>>>>>>        End
22085>>>>>>>>>>>>
22085>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
22087>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
22088>>>>>>>>>>>        End
22088>>>>>>>>>>>>
22088>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
22090>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
22091>>>>>>>>>>>        End
22091>>>>>>>>>>>>
22091>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
22093>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
22094>>>>>>>>>>>        End
22094>>>>>>>>>>>>
22094>>>>>>>>>>>        Function_Return sRetval
22095>>>>>>>>>>>    End_Function
22096>>>>>>>>>>>
22096>>>>>>>>>>>    // Pass a driver id and the function will return
22096>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
22096>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
22096>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
22098>>>>>>>>>>>        Integer iRetval
22098>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
22100>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22101>>>>>>>>>>>        End
22101>>>>>>>>>>>>
22101>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
22103>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22104>>>>>>>>>>>        End
22104>>>>>>>>>>>>
22104>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
22106>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22107>>>>>>>>>>>        End
22107>>>>>>>>>>>>
22107>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
22109>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
22110>>>>>>>>>>>        End
22110>>>>>>>>>>>>
22110>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
22112>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
22113>>>>>>>>>>>        End
22113>>>>>>>>>>>>
22113>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
22115>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
22116>>>>>>>>>>>        End
22116>>>>>>>>>>>>
22116>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
22118>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
22119>>>>>>>>>>>        End
22119>>>>>>>>>>>>
22119>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
22121>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
22122>>>>>>>>>>>        End
22122>>>>>>>>>>>>
22122>>>>>>>>>>>        Function_Return iRetval
22123>>>>>>>>>>>    End_Function
22124>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
22124>>>>>>>>>>>>
22124>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
22126>>>>>>>>>>>>    Integer iStart iEnd
22126>>>>>>>>>>>>    String sRetval
22126>>>>>>>>>>>>
22126>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
22127>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
22128>>>>>>>>>>>>    If (iStart = 0) Begin
22130>>>>>>>>>>>>        Function_Return ""
22131>>>>>>>>>>>>    End
22131>>>>>>>>>>>>>
22131>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
22132>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
22133>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
22135>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
22136>>>>>>>>>>>>    End
22136>>>>>>>>>>>>>
22136>>>>>>>>>>>>    Else Begin
22137>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
22138>>>>>>>>>>>>    End
22138>>>>>>>>>>>>>
22138>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
22140>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
22141>>>>>>>>>>>>        Decrement iEnd
22142>>>>>>>>>>>>    End
22142>>>>>>>>>>>>>
22142>>>>>>>>>>>>    If (iEnd <> 0) Begin
22144>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
22145>>>>>>>>>>>>    End
22145>>>>>>>>>>>>>
22145>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
22146>>>>>>>>>>>>
22146>>>>>>>>>>>>    Function_Return (Trim(sRetval))
22147>>>>>>>>>>>>End_Function
22148>>>>>>>>>>>>
22148>>>>>>>>>>>>
22148>>>>>>>>>>>
22148>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
22150>>>>>>>>>>>        String sConnect
22150>>>>>>>>>>>        Handle hoDriver
22150>>>>>>>>>>>
22150>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
22151>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
22152>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
22153>>>>>>>>>>>        Send Destroy of hoDriver
22154>>>>>>>>>>>
22154>>>>>>>>>>>        Function_Return sConnect
22155>>>>>>>>>>>    End_Function
22156>>>>>>>>>>>
22156>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
22156>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
22158>>>>>>>>>>>        String sConnect
22158>>>>>>>>>>>
22158>>>>>>>>>>>        Case Begin
22158>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
22160>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
22161>>>>>>>>>>>                If (sDatabase <> "") Begin
22163>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22164>>>>>>>>>>>                End
22164>>>>>>>>>>>>
22164>>>>>>>>>>>                Case Break
22165>>>>>>>>>>>
22165>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
22168>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
22170>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
22171>>>>>>>>>>>                End
22171>>>>>>>>>>>>
22171>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
22174>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22175>>>>>>>>>>>                End
22175>>>>>>>>>>>>
22175>>>>>>>>>>>
22175>>>>>>>>>>>                If (sDatabase <> "") Begin
22177>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22178>>>>>>>>>>>                End
22178>>>>>>>>>>>>
22178>>>>>>>>>>>                Case Break
22179>>>>>>>>>>>
22179>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
22182>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22183>>>>>>>>>>>                If (sDatabase <> "") Begin
22185>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22186>>>>>>>>>>>                End
22186>>>>>>>>>>>>
22186>>>>>>>>>>>                Case Break
22187>>>>>>>>>>>
22187>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
22190>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22191>>>>>>>>>>>                If (sDatabase <> "") Begin
22193>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22194>>>>>>>>>>>                End
22194>>>>>>>>>>>>
22194>>>>>>>>>>>                Case Break
22195>>>>>>>>>>>
22195>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
22198>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22199>>>>>>>>>>>                If (sDatabase <> "") Begin
22201>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22202>>>>>>>>>>>                End
22202>>>>>>>>>>>>
22202>>>>>>>>>>>                Case Break
22203>>>>>>>>>>>
22203>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
22206>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22207>>>>>>>>>>>                If (sDatabase <> "") Begin
22209>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22210>>>>>>>>>>>                End
22210>>>>>>>>>>>>
22210>>>>>>>>>>>                Case Break
22211>>>>>>>>>>>
22211>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
22214>>>>>>>>>>>                Break
22215>>>>>>>>>>>
22215>>>>>>>>>>>            Case Else
22215>>>>>>>>>>>                Move "" to sConnect
22216>>>>>>>>>>>        Case End
22216>>>>>>>>>>>
22216>>>>>>>>>>>        Function_Return sConnect
22217>>>>>>>>>>>    End_Function
22218>>>>>>>>>>>
22218>>>>>>>>>>>    // Use Base64
22218>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
22220>>>>>>>>>>>        String sRetval
22220>>>>>>>>>>>        Handle hoLoginEncryption
22220>>>>>>>>>>>
22220>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
22221>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
22222>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
22223>>>>>>>>>>>        Send Destroy of hoLoginEncryption
22224>>>>>>>>>>>          
22224>>>>>>>>>>>        Function_Return sRetval
22225>>>>>>>>>>>    End_Function
22226>>>>>>>>>>>
22226>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
22228>>>>>>>>>>>        String sRetval
22228>>>>>>>>>>>        Handle hoLoginEncryption
22228>>>>>>>>>>>
22228>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
22229>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
22230>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
22231>>>>>>>>>>>        Send Destroy of hoLoginEncryption
22232>>>>>>>>>>>
22232>>>>>>>>>>>        Function_Return sRetval
22233>>>>>>>>>>>    End_Function
22234>>>>>>>>>>>
22234>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
22234>>>>>>>>>>>    Function ApplicationPath Returns String
22236>>>>>>>>>>>        String sApplicationFileName sPath
22236>>>>>>>>>>>        Integer iNumChars iRetval
22236>>>>>>>>>>>
22236>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
22237>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
22238>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
22239>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
22240>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
22241>>>>>>>>>>>
22241>>>>>>>>>>>        Function_Return sPath
22242>>>>>>>>>>>    End_Function
22243>>>>>>>>>>>
22243>>>>>>>>>>>    // Pass a filename including the extension. The return value
22243>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
22243>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
22243>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
22245>>>>>>>>>>>        Boolean bExists
22245>>>>>>>>>>>        Handle hoPaths hoIniFile
22245>>>>>>>>>>>        String[] asWorkSpaceFiles
22246>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
22246>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
22246>>>>>>>>>>>        
22246>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
22247>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
22248>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
22249>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
22250>>>>>>>>>>>        If (bExists = True) Begin
22252>>>>>>>>>>>            Function_Return sProgramsPath
22253>>>>>>>>>>>        End                      
22253>>>>>>>>>>>>
22253>>>>>>>>>>>    
22253>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
22254>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
22256>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
22257>>>>>>>>>>>        End                                              
22257>>>>>>>>>>>>
22257>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
22258>>>>>>>>>>>        
22258>>>>>>>>>>>        Move False to bExists
22259>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
22260>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
22261>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
22262>>>>>>>>>>>        Decrement iSize       
22263>>>>>>>>>>>        
22263>>>>>>>>>>>        For iCount from 0 to iSize
22269>>>>>>>>>>>>
22269>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
22270>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
22271>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
22272>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
22273>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
22279>>>>>>>>>>>>
22279>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
22280>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
22281>>>>>>>>>>>                // Check if there are more than one path specified;
22281>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
22282>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
22284>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
22285>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
22291>>>>>>>>>>>>
22291>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
22292>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
22293>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
22294>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
22295>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
22296>>>>>>>>>>>                        If (bExists = True) Begin
22298>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
22299>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
22300>>>>>>>>>>>                            Move iSize to iCount
22301>>>>>>>>>>>                        End                                                    
22301>>>>>>>>>>>>
22301>>>>>>>>>>>                    Loop
22302>>>>>>>>>>>>
22302>>>>>>>>>>>                End
22302>>>>>>>>>>>>
22302>>>>>>>>>>>                Else Begin
22303>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
22304>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
22305>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
22306>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
22307>>>>>>>>>>>                    If (bExists = True) Begin
22309>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
22310>>>>>>>>>>>                        Move iSize to iCount
22311>>>>>>>>>>>                    End                                                    
22311>>>>>>>>>>>>
22311>>>>>>>>>>>                End
22311>>>>>>>>>>>>
22311>>>>>>>>>>>            Loop
22312>>>>>>>>>>>>
22312>>>>>>>>>>>            If (bExists = False) Begin
22314>>>>>>>>>>>                Move "" to sPath    
22315>>>>>>>>>>>            End
22315>>>>>>>>>>>>
22315>>>>>>>>>>>            Send Destroy of hoIniFile          
22316>>>>>>>>>>>        Loop        
22317>>>>>>>>>>>>
22317>>>>>>>>>>>        Send Destroy of hoPaths
22318>>>>>>>>>>>        
22318>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
22318>>>>>>>>>>>        If (sPath = "") Begin
22320>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
22321>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
22322>>>>>>>>>>>        End                  
22322>>>>>>>>>>>>
22322>>>>>>>>>>>        
22322>>>>>>>>>>>        Function_Return sPath    
22323>>>>>>>>>>>    End_Function
22324>>>>>>>>>>>    
22324>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
22324>>>>>>>>>>>    // with one or more .ws file names.
22324>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
22324>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
22324>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
22324>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
22326>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
22328>>>>>>>>>>>        String sFile sHomePath sDirSep
22328>>>>>>>>>>>        Integer iCh iSize
22328>>>>>>>>>>>        Boolean bExists      
22328>>>>>>>>>>>        Handle hoIniFile 
22328>>>>>>>>>>>        
22328>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
22329>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
22330>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
22332>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
22333>>>>>>>>>>>        End                                              
22333>>>>>>>>>>>>
22333>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
22334>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
22335>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
22336>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
22337>>>>>>>>>>>        
22337>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
22337>>>>>>>>>>>        // read the name of the .ws file name.
22337>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
22338>>>>>>>>>>>        If (bExists = True) Begin
22340>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
22341>>>>>>>>>>>            If (iCh < 0) Begin
22343>>>>>>>>>>>                Function_Return asSWSFiles
22344>>>>>>>>>>>            End                                 
22344>>>>>>>>>>>>
22344>>>>>>>>>>>            
22344>>>>>>>>>>>            Repeat
22344>>>>>>>>>>>>
22344>>>>>>>>>>>                Readln channel iCh sFile
22346>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
22348>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
22349>>>>>>>>>>>                End
22349>>>>>>>>>>>>
22349>>>>>>>>>>>            Until (SeqEof = True)
22351>>>>>>>>>>>            Send Seq_Close_Channel iCh    
22352>>>>>>>>>>>            
22352>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
22353>>>>>>>>>>>            If (iSize <> 0) Begin
22355>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
22356>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
22356>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
22356>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
22357>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
22358>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
22359>>>>>>>>>>>                If (sFile <> "") Begin
22361>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
22362>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
22363>>>>>>>>>>>                    File_Exist sFile bExists
22364>>>>>>>>>>>                    If (bExists = True) Begin
22366>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
22367>>>>>>>>>>>                    End
22367>>>>>>>>>>>>
22367>>>>>>>>>>>                End
22367>>>>>>>>>>>>
22367>>>>>>>>>>>                Send Destroy of hoIniFile
22368>>>>>>>>>>>            End
22368>>>>>>>>>>>>
22368>>>>>>>>>>>        End
22368>>>>>>>>>>>>
22368>>>>>>>>>>>        
22368>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
22368>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
22370>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
22371>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
22372>>>>>>>>>>>            If (bExists = False) Begin
22374>>>>>>>>>>>                Function_Return asWorkspaceFiles
22375>>>>>>>>>>>            End
22375>>>>>>>>>>>>
22375>>>>>>>>>>>        
22375>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
22376>>>>>>>>>>>            If (iCh < 0) Begin
22378>>>>>>>>>>>                Function_Return asWorkspaceFiles
22379>>>>>>>>>>>            End                                 
22379>>>>>>>>>>>>
22379>>>>>>>>>>>            
22379>>>>>>>>>>>            Repeat
22379>>>>>>>>>>>>
22379>>>>>>>>>>>                Readln channel iCh sFile
22381>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
22383>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
22384>>>>>>>>>>>                End
22384>>>>>>>>>>>>
22384>>>>>>>>>>>            Until (SeqEof = True)
22386>>>>>>>>>>>            Send Seq_Close_Channel iCh
22387>>>>>>>>>>>        End
22387>>>>>>>>>>>>
22387>>>>>>>>>>>        
22387>>>>>>>>>>>        Function_Return asWorkspaceFiles
22388>>>>>>>>>>>    End_Function
22389>>>>>>>>>>>
22389>>>>>>>>>>>End_Class
22390>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
22390>>>>>>>>>Use vWin32fh.pkg
22390>>>>>>>>>
22390>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
22390>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
22390>>>>>>>>>    Use cConnectionDUF.pkg
Including file: cConnectionDUF.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cConnectionDUF.pkg)
22390>>>>>>>>>>>// * Dummy class * that will only be used if DF 18.2 or less.
22390>>>>>>>>>>>//
22390>>>>>>>>>>>// The cConnection class is new to DF 19 and that DF 19 package/class
22390>>>>>>>>>>>// will be used automatically instead of this package
22390>>>>>>>>>>>// if the current DF version is 19 and up _and_ the class
22390>>>>>>>>>>>// has been instantianted in the cApplication object.
22390>>>>>>>>>>>//
22390>>>>>>>>>>>// If an object of the original cConnection class is placed in
22390>>>>>>>>>>>// the cApplication, that connection logic will be used instead
22390>>>>>>>>>>>// of the Database Update Framework's SQLConnections logic. Or more
22390>>>>>>>>>>>// correctly; "Managed Connection" settings will be read and applied
22390>>>>>>>>>>>// instead of those defined in the framework's SQLConnections.ini file.
22390>>>>>>>>>>>//
22390>>>>>>>>>>>Struct tConnection
22390>>>>>>>>>>>    String sId                // connection id
22390>>>>>>>>>>>    String sString            // server-string as added via the ini file
22390>>>>>>>>>>>    String sUID               // User Id
22390>>>>>>>>>>>    String sPWD               // non-encrypted password
22390>>>>>>>>>>>    Boolean bTrustedConnection // Trusted connection
22390>>>>>>>>>>>    Integer iOptions          // connection ID options (don't use)
22390>>>>>>>>>>>    String sDriver            // name of driver
22390>>>>>>>>>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
22390>>>>>>>>>>>    String sConnectionString  // Full connection string assembled from various strings
22390>>>>>>>>>>>    String sSection           // this is usually the section name as it appears
22390>>>>>>>>>>>                              // in the connections ini file (e.g., [Connection1])
22390>>>>>>>>>>>    Boolean bDisabled         // if set, this is not an active Id
22390>>>>>>>>>>>End_Struct
22390>>>>>>>>>>>
22390>>>>>>>>>>>
22390>>>>>>>>>>>Class cConnection is a cObject
22391>>>>>>>>>>>
22391>>>>>>>>>>>    Procedure Construct_Object
22393>>>>>>>>>>>        Forward Send Construct_Object
22395>>>>>>>>>>>
22395>>>>>>>>>>>    End_Procedure
22396>>>>>>>>>>>
22396>>>>>>>>>>>    Function ConnectionIdInfo Returns tConnection
22398>>>>>>>>>>>        tConnection Connection
22398>>>>>>>>>>>        tConnection Connection
22398>>>>>>>>>>>        Function_Return Connection
22399>>>>>>>>>>>    End_Function
22400>>>>>>>>>>>
22400>>>>>>>>>>>    Function IsConnectionIdLoggedIn Returns Boolean
22402>>>>>>>>>>>        Function_Return False
22403>>>>>>>>>>>    End_Function
22404>>>>>>>>>>>
22404>>>>>>>>>>>    Function LoginConnectionId Returns String
22406>>>>>>>>>>>        Function_Return ""
22407>>>>>>>>>>>    End_Function
22408>>>>>>>>>>>
22408>>>>>>>>>>>    // get array of managed connections across all drivers
22408>>>>>>>>>>>    // returns array of connections in tConnection.
22408>>>>>>>>>>>    Function ConnectionIDs Returns tConnection[]
22410>>>>>>>>>>>        tConnection[] Connections
22410>>>>>>>>>>>        tConnection[] Connections
22411>>>>>>>>>>>        Function_Return Connections
22412>>>>>>>>>>>    End_Function
22413>>>>>>>>>>>
22413>>>>>>>>>>>    Function ConnectionIdIndex String sConnectionID Returns Integer
22415>>>>>>>>>>>        Function_Return 0
22416>>>>>>>>>>>    End_Function
22417>>>>>>>>>>>
22417>>>>>>>>>>>    Function RedirectConnectionId String sConnectionID String sServer String sUserId String sPw Boolean bTrusted Boolean bKeepOpen Returns Boolean
22419>>>>>>>>>>>        Function_Return False
22420>>>>>>>>>>>    End_Function
22421>>>>>>>>>>>
22421>>>>>>>>>>>End_Class
22422>>>>>>>>>
22422>>>>>>>>>// We're making references to this object handle so we need it defined
22422>>>>>>>>>// here as well as for the cDbUpdateHandler class
22422>>>>>>>>>
22422>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
22422>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
22423>>>>>>>>>
22423>>>>>>>>>Class cSQLConnectionHandler is a cObject
22424>>>>>>>>>
22424>>>>>>>>>    Procedure Construct_Object
22426>>>>>>>>>        Forward Send Construct_Object
22428>>>>>>>>>        Move Self to ghoSQLConnectionHandler
22429>>>>>>>>>
22429>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
22430>>>>>>>>>
22430>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
22430>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
22430>>>>>>>>>        // methods to this class.
22430>>>>>>>>>        Property Boolean pbUseConnectionID True
22431>>>>>>>>>        Property Boolean pbToANSI          True
22432>>>>>>>>>        Property Boolean pbRecnum          True
22433>>>>>>>>>        Property Boolean pbCopyData        True
22434>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
22435>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
22436>>>>>>>>>        Property Boolean pbCompareIndexAscending False
22437>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
22438>>>>>>>>>
22438>>>>>>>>>        // Driver default value settings:
22438>>>>>>>>>        // Note: When the object is created the corresponding values
22438>>>>>>>>>        // from the driver .int files are read.
22438>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
22438>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
22439>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
22440>>>>>>>>>        Property String psDriverDefaultValueDate     ""
22441>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
22442>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
22443>>>>>>>>>        Property String psDriverDefaultValueText     ""
22444>>>>>>>>>
22444>>>>>>>>>        // Driver "nullability" settings:
22444>>>>>>>>>        // Note: When the object is created the corresponding values
22444>>>>>>>>>        // from the driver .int files are read.
22444>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
22444>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
22445>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
22446>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
22447>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
22448>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
22449>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
22450>>>>>>>>>
22450>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
22450>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
22450>>>>>>>>>        //     driver interfaces.
22450>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
22450>>>>>>>>>        //     of the struct they are all routed throu this struct property.
22450>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
22451>>>>>>>>>
22451>>>>>>>>>    End_Procedure
22452>>>>>>>>>
22452>>>>>>>>>    Procedure End_Construct_Object
22454>>>>>>>>>        tSQLConnection SQLConnection
22454>>>>>>>>>        tSQLConnection SQLConnection
22454>>>>>>>>>
22454>>>>>>>>>        Forward Send End_Construct_Object
22456>>>>>>>>>
22456>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
22456>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
22457>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22458>>>>>>>>>    End_Procedure
22459>>>>>>>>>
22459>>>>>>>>>    // *** Properties ***
22459>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
22459>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
22459>>>>>>>>>    // merely here for conveniance.
22459>>>>>>>>>    //
22459>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
22459>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
22459>>>>>>>>>    // This struct property contains all the connection data.
22459>>>>>>>>>    //
22459>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
22461>>>>>>>>>        Boolean bOK
22461>>>>>>>>>
22461>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22462>>>>>>>>>
22462>>>>>>>>>        // When starting a program we might not have a connection id yet:
22462>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
22464>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
22464>>>>>>>>>            Procedure_Return
22465>>>>>>>>>        End
22465>>>>>>>>>>
22465>>>>>>>>>
22465>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
22465>>>>>>>>>        // be logged in already and don't want to do it again.
22465>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
22467>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
22467>>>>>>>>>            // driver interfaces about the change & make a new login.
22467>>>>>>>>>            Get SQLLogin SQLConnection to bOK
22468>>>>>>>>>            If (bOK = False) Begin
22470>>>>>>>>>                Error DFERR_PROGRAM "Login error."
22471>>>>>>>>>>
22471>>>>>>>>>            End
22471>>>>>>>>>>
22471>>>>>>>>>        End
22471>>>>>>>>>>
22471>>>>>>>>>
22471>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
22471>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
22472>>>>>>>>>
22472>>>>>>>>>    End_Procedure
22473>>>>>>>>>
22473>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
22473>>>>>>>>>    // attempt to load the driver.
22473>>>>>>>>>    // Returns true if the passed driver is SQL based.
22473>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
22475>>>>>>>>>        Boolean bOK
22475>>>>>>>>>
22475>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
22476>>>>>>>>>        If (bOK = False) Begin
22478>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
22479>>>>>>>>>        End
22479>>>>>>>>>>
22479>>>>>>>>>
22479>>>>>>>>>        Function_Return bOK
22480>>>>>>>>>    End_Function
22481>>>>>>>>>
22481>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
22481>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
22483>>>>>>>>>        String sAttributeValue
22483>>>>>>>>>        Integer iDriverID
22483>>>>>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
22483>>>>>>>>>
22483>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
22484>>>>>>>>>        If (bSQLDriver = False) Begin
22486>>>>>>>>>            Procedure_Return
22487>>>>>>>>>        End                                      
22487>>>>>>>>>>
22487>>>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
22488>>>>>>>>>        If (bIsMertechDriver = True) Begin
22490>>>>>>>>>            Procedure_Return
22491>>>>>>>>>        End
22491>>>>>>>>>>
22491>>>>>>>>>        
22491>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
22492>>>>>>>>>
22492>>>>>>>>>        // Driver default values for various data types:
22492>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
22495>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
22496>>>>>>>>>
22496>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
22499>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
22500>>>>>>>>>
22500>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
22503>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
22504>>>>>>>>>
22504>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
22507>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
22508>>>>>>>>>
22508>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
22511>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
22512>>>>>>>>>
22512>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
22515>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
22516>>>>>>>>>
22516>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
22516>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
22519>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
22520>>>>>>>>>
22520>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
22523>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
22524>>>>>>>>>
22524>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
22527>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
22528>>>>>>>>>
22528>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
22531>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
22532>>>>>>>>>
22532>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
22535>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
22536>>>>>>>>>
22536>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
22539>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
22540>>>>>>>>>
22540>>>>>>>>>    End_Procedure
22541>>>>>>>>>
22541>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
22543>>>>>>>>>        Boolean bOK bIsDaw bIsMertech
22543>>>>>>>>>        String sConnectionString
22543>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
22543>>>>>>>>>        Integer iDriverID
22543>>>>>>>>>
22543>>>>>>>>>        Move False to bOK
22544>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
22545>>>>>>>>>        If (bIsDaw = False) Begin
22547>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
22548>>>>>>>>>            If (bIsMertech = False) Begin
22550>>>>>>>>>                Function_Return False
22551>>>>>>>>>            End
22551>>>>>>>>>>
22551>>>>>>>>>        End
22551>>>>>>>>>>
22551>>>>>>>>>
22551>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
22552>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
22553>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
22554>>>>>>>>>        If (iDriverID = 0) Begin
22556>>>>>>>>>            Move hoErrorObj to Error_Object_Id
22557>>>>>>>>>            Function_Return False
22558>>>>>>>>>        End
22558>>>>>>>>>>
22558>>>>>>>>>
22558>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
22558>>>>>>>>>        If (bIsMertech = False) Begin
22560>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
22563>>>>>>>>>        End
22563>>>>>>>>>>
22563>>>>>>>>>
22563>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
22564>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
22565>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
22566>>>>>>>>>        Send Destroy   of hoDriver
22567>>>>>>>>>
22567>>>>>>>>>        Function_Return bOK
22568>>>>>>>>>    End_Function
22569>>>>>>>>>
22569>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
22571>>>>>>>>>        tSQLConnection SQLConnection
22571>>>>>>>>>        tSQLConnection SQLConnection
22571>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22572>>>>>>>>>        Function_Return SQLConnection
22573>>>>>>>>>    End_Function
22574>>>>>>>>>
22574>>>>>>>>>    Procedure Set psConnectionID String sValue
22576>>>>>>>>>        tSQLConnection SQLConnection
22576>>>>>>>>>        tSQLConnection SQLConnection
22576>>>>>>>>>
22576>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22577>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
22579>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
22580>>>>>>>>>        End
22580>>>>>>>>>>
22580>>>>>>>>>
22580>>>>>>>>>        // Else we might want to change the current connection ID
22580>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
22583>>>>>>>>>            Move False to Err
22584>>>>>>>>>            Logout SQLConnection.sDriverID
22585>>>>>>>>>            // This will also make a login to the new server.
22585>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
22586>>>>>>>>>        End
22586>>>>>>>>>>
22586>>>>>>>>>        Set pSQLConnection to SQLConnection
22587>>>>>>>>>    End_Procedure
22588>>>>>>>>>
22588>>>>>>>>>    Function psConnectionID Returns String
22590>>>>>>>>>        tSQLConnection SQLConnection
22590>>>>>>>>>        tSQLConnection SQLConnection
22590>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22591>>>>>>>>>        Function_Return SQLConnection.sConnectionID
22592>>>>>>>>>    End_Function
22593>>>>>>>>>
22593>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
22593>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
22593>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
22593>>>>>>>>>    //       for a connection string has the wrong format for that driver.
22593>>>>>>>>>    Procedure Set psDriverID String sValue
22595>>>>>>>>>        tSQLConnection SQLConnection
22595>>>>>>>>>        tSQLConnection SQLConnection
22595>>>>>>>>>        Get pSQLConnection to SQLConnection
22596>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
22597>>>>>>>>>        Set pSQLConnection to SQLConnection
22598>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
22600>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22601>>>>>>>>>        End
22601>>>>>>>>>>
22601>>>>>>>>>    End_Procedure
22602>>>>>>>>>
22602>>>>>>>>>    Function psDriverID Returns String
22604>>>>>>>>>        tSQLConnection SQLConnection
22604>>>>>>>>>        tSQLConnection SQLConnection
22604>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22605>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
22607>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
22608>>>>>>>>>        End
22608>>>>>>>>>>
22608>>>>>>>>>        Function_Return SQLConnection.sDriverID
22609>>>>>>>>>    End_Function
22610>>>>>>>>>
22610>>>>>>>>>    Procedure Set psConnectionString String sValue
22612>>>>>>>>>        tSQLConnection SQLConnection
22612>>>>>>>>>        tSQLConnection SQLConnection
22612>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22613>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
22614>>>>>>>>>        Set pSQLConnection to SQLConnection
22615>>>>>>>>>    End_Procedure
22616>>>>>>>>>
22616>>>>>>>>>    Function psConnectionString Returns String
22618>>>>>>>>>        tSQLConnection SQLConnection
22618>>>>>>>>>        tSQLConnection SQLConnection
22618>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22619>>>>>>>>>        Function_Return SQLConnection.sConnectionString
22620>>>>>>>>>    End_Function
22621>>>>>>>>>
22621>>>>>>>>>    Procedure Set psServer String sValue
22623>>>>>>>>>        tSQLConnection SQLConnection
22623>>>>>>>>>        tSQLConnection SQLConnection
22623>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22624>>>>>>>>>        Move sValue        to SQLConnection.sServer
22625>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22626>>>>>>>>>        Set pSQLConnection to SQLConnection
22627>>>>>>>>>    End_Procedure
22628>>>>>>>>>
22628>>>>>>>>>    Function psServer Returns String
22630>>>>>>>>>        tSQLConnection SQLConnection
22630>>>>>>>>>        tSQLConnection SQLConnection
22630>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22631>>>>>>>>>        Function_Return SQLConnection.sServer
22632>>>>>>>>>    End_Function
22633>>>>>>>>>
22633>>>>>>>>>    Procedure Set psDatabase String sValue
22635>>>>>>>>>        tSQLConnection SQLConnection
22635>>>>>>>>>        tSQLConnection SQLConnection
22635>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22636>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
22637>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22638>>>>>>>>>        Set pSQLConnection to SQLConnection
22639>>>>>>>>>    End_Procedure
22640>>>>>>>>>
22640>>>>>>>>>    Function psDatabase Returns String
22642>>>>>>>>>        tSQLConnection SQLConnection
22642>>>>>>>>>        tSQLConnection SQLConnection
22642>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22643>>>>>>>>>        Function_Return SQLConnection.sDatabase
22644>>>>>>>>>    End_Function
22645>>>>>>>>>
22645>>>>>>>>>    Procedure Set psUserID String sValue
22647>>>>>>>>>        tSQLConnection SQLConnection
22647>>>>>>>>>        tSQLConnection SQLConnection
22647>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22648>>>>>>>>>        Move sValue        to SQLConnection.sUserID
22649>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22650>>>>>>>>>        Set pSQLConnection to SQLConnection
22651>>>>>>>>>    End_Procedure
22652>>>>>>>>>
22652>>>>>>>>>    Function psUserID Returns String
22654>>>>>>>>>        tSQLConnection SQLConnection
22654>>>>>>>>>        tSQLConnection SQLConnection
22654>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22655>>>>>>>>>        Function_Return SQLConnection.sUserID
22656>>>>>>>>>    End_Function
22657>>>>>>>>>
22657>>>>>>>>>    // This is the uncrypted password
22657>>>>>>>>>    Procedure Set psPassword String sValue
22659>>>>>>>>>        tSQLConnection SQLConnection
22659>>>>>>>>>        tSQLConnection SQLConnection
22659>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22660>>>>>>>>>        Move sValue        to SQLConnection.sPassword
22661>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22662>>>>>>>>>        Set pSQLConnection to SQLConnection
22663>>>>>>>>>    End_Procedure
22664>>>>>>>>>
22664>>>>>>>>>    Function psPassword Returns String
22666>>>>>>>>>        tSQLConnection SQLConnection
22666>>>>>>>>>        tSQLConnection SQLConnection
22666>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22667>>>>>>>>>        Function_Return SQLConnection.sPassword
22668>>>>>>>>>    End_Function
22669>>>>>>>>>
22669>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
22671>>>>>>>>>        tSQLConnection SQLConnection
22671>>>>>>>>>        tSQLConnection SQLConnection
22671>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22672>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
22673>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22674>>>>>>>>>        Set pSQLConnection to SQLConnection
22675>>>>>>>>>    End_Procedure
22676>>>>>>>>>
22676>>>>>>>>>    Function pbTrusted Returns Boolean
22678>>>>>>>>>        tSQLConnection SQLConnection
22678>>>>>>>>>        tSQLConnection SQLConnection
22678>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22679>>>>>>>>>        Function_Return SQLConnection.bTrusted
22680>>>>>>>>>    End_Function
22681>>>>>>>>>
22681>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
22681>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
22681>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
22681>>>>>>>>>    //     the central pSQLConnection "hub".
22681>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
22683>>>>>>>>>        tSQLConnection SQLConnection
22683>>>>>>>>>        tSQLConnection SQLConnection
22683>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22684>>>>>>>>>        Move bValue to SQLConnection.bTrusted
22685>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22686>>>>>>>>>    End_Procedure
22687>>>>>>>>>
22687>>>>>>>>>    Function pbSilentLogin Returns Boolean
22689>>>>>>>>>        tSQLConnection SQLConnection
22689>>>>>>>>>        tSQLConnection SQLConnection
22689>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22690>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
22691>>>>>>>>>    End_Function
22692>>>>>>>>>
22692>>>>>>>>>    Procedure Set piDbType Integer iValue
22694>>>>>>>>>        tSQLConnection SQLConnection
22694>>>>>>>>>        tSQLConnection SQLConnection
22694>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22695>>>>>>>>>        Move iValue to SQLConnection.iDbType
22696>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22697>>>>>>>>>    End_Procedure
22698>>>>>>>>>
22698>>>>>>>>>    Function piDbType Returns Integer
22700>>>>>>>>>        tSQLConnection SQLConnection
22700>>>>>>>>>        tSQLConnection SQLConnection
22700>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22701>>>>>>>>>        Function_Return SQLConnection.iDbType
22702>>>>>>>>>    End_Function
22703>>>>>>>>>
22703>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
22705>>>>>>>>>        tSQLConnection SQLConnection
22705>>>>>>>>>        tSQLConnection SQLConnection
22705>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22706>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
22707>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22708>>>>>>>>>    End_Procedure
22709>>>>>>>>>
22709>>>>>>>>>    Function psBaseTableSpace Returns String
22711>>>>>>>>>        tSQLConnection SQLConnection
22711>>>>>>>>>        tSQLConnection SQLConnection
22711>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22712>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
22713>>>>>>>>>    End_Function
22714>>>>>>>>>
22714>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
22716>>>>>>>>>        tSQLConnection SQLConnection
22716>>>>>>>>>        tSQLConnection SQLConnection
22716>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22717>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
22718>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22719>>>>>>>>>    End_Procedure
22720>>>>>>>>>
22720>>>>>>>>>    Function psIndexTableSpace Returns String
22722>>>>>>>>>        tSQLConnection SQLConnection
22722>>>>>>>>>        tSQLConnection SQLConnection
22722>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22723>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
22724>>>>>>>>>    End_Function
22725>>>>>>>>>
22725>>>>>>>>>    Procedure Set psLongTableSpace String sValue
22727>>>>>>>>>        tSQLConnection SQLConnection
22727>>>>>>>>>        tSQLConnection SQLConnection
22727>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22728>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
22729>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22730>>>>>>>>>    End_Procedure
22731>>>>>>>>>
22731>>>>>>>>>    Function psLongTableSpace Returns String
22733>>>>>>>>>        tSQLConnection SQLConnection
22733>>>>>>>>>        tSQLConnection SQLConnection
22733>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22734>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
22735>>>>>>>>>    End_Function
22736>>>>>>>>>
22736>>>>>>>>>    Procedure Set psSchema String sValue
22738>>>>>>>>>        tSQLConnection SQLConnection
22738>>>>>>>>>        tSQLConnection SQLConnection
22738>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22739>>>>>>>>>        Move sValue to SQLConnection.sSchema
22740>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22741>>>>>>>>>    End_Procedure
22742>>>>>>>>>
22742>>>>>>>>>    Function psSchema Returns String
22744>>>>>>>>>        tSQLConnection SQLConnection
22744>>>>>>>>>        tSQLConnection SQLConnection
22744>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22745>>>>>>>>>        Function_Return SQLConnection.sSchema
22746>>>>>>>>>    End_Function
22747>>>>>>>>>
22747>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
22749>>>>>>>>>        tSQLConnection SQLConnection
22749>>>>>>>>>        tSQLConnection SQLConnection
22749>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22750>>>>>>>>>        Move bValue to SQLConnection.bEnabled
22751>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22752>>>>>>>>>    End_Procedure
22753>>>>>>>>>
22753>>>>>>>>>    Function pbEnabled Returns Boolean
22755>>>>>>>>>        tSQLConnection SQLConnection
22755>>>>>>>>>        tSQLConnection SQLConnection
22755>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22756>>>>>>>>>        Function_Return SQLConnection.bEnabled
22757>>>>>>>>>    End_Function
22758>>>>>>>>>
22758>>>>>>>>>
22758>>>>>>>>>    // ************************************
22758>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
22760>>>>>>>>>        tSQLConnection SQLConnection
22760>>>>>>>>>        tSQLConnection SQLConnection
22760>>>>>>>>>
22760>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
22760>>>>>>>>>        // deferr reading SQL connection values until later.
22760>>>>>>>>>        If (bReadDFConnSettings = True) Begin
22762>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
22762>>>>>>>>>            If (ghoConnection > 0) Begin
22764>>>>>>>>>                Get ReadcConnections to SQLConnection
22765>>>>>>>>>            End
22765>>>>>>>>>>
22765>>>>>>>>>
22765>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
22765>>>>>>>>>            // object is used.
22765>>>>>>>>>            If (bReadSQLConnections = True) Begin
22767>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
22768>>>>>>>>>            End
22768>>>>>>>>>>
22768>>>>>>>>>        End
22768>>>>>>>>>>
22768>>>>>>>>>
22768>>>>>>>>>        Function_Return SQLConnection
22769>>>>>>>>>    End_Function
22770>>>>>>>>>
22770>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
22770>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
22772>>>>>>>>>        tConnection Connection
22772>>>>>>>>>        tConnection Connection
22772>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22772>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22772>>>>>>>>>        Integer iRetval iDbType
22772>>>>>>>>>        Boolean bOK bConnected
22772>>>>>>>>>        String sConnectionID
22772>>>>>>>>>
22772>>>>>>>>>
22772>>>>>>>>>        Function_Return SQLConnection
22773>>>>>>>>>    End_Function
22774>>>>>>>>>
22774>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
22774>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
22774>>>>>>>>>    // connection id for a particular driver.
22774>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
22774>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
22774>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
22774>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
22774>>>>>>>>>    // connections of the DAW cConnect class.
22774>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
22776>>>>>>>>>        tConnection[] ConnIdArray
22776>>>>>>>>>        tConnection[] ConnIdArray
22777>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
22777>>>>>>>>>        Boolean bEnabled bFound
22777>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
22777>>>>>>>>>
22777>>>>>>>>>        Move False to bFound
22778>>>>>>>>>        If (ghoConnection > 0) Begin
22780>>>>>>>>>
22780>>>>>>>>>            // The property of the cDbUpdateHandler container object
22780>>>>>>>>>            Get psDriverID to sDriverID
22781>>>>>>>>>
22781>>>>>>>>>            Move 0 to iConnectionIDCounter
22782>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
22782>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
22783>>>>>>>>>            Decrement iSize
22784>>>>>>>>>            For iCount from 0 to iSize
22790>>>>>>>>>>
22790>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
22791>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
22792>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
22793>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
22793>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
22793>>>>>>>>>                If (sConnectionID = "") Begin
22795>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
22796>>>>>>>>>                End
22796>>>>>>>>>>
22796>>>>>>>>>                Else Begin
22797>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
22799>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
22800>>>>>>>>>                    End
22800>>>>>>>>>>
22800>>>>>>>>>                End
22800>>>>>>>>>>
22800>>>>>>>>>
22800>>>>>>>>>                If (bFound = True) Begin
22802>>>>>>>>>                    Increment iConnectionIDCounter
22803>>>>>>>>>                End
22803>>>>>>>>>>
22803>>>>>>>>>            Loop
22804>>>>>>>>>>
22804>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
22805>>>>>>>>>            If (bFound = True) Begin
22807>>>>>>>>>                Move sConnectionID2 to sConnectionID
22808>>>>>>>>>            End
22808>>>>>>>>>>
22808>>>>>>>>>        End
22808>>>>>>>>>>
22808>>>>>>>>>
22808>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
22808>>>>>>>>>        // but no DFConn.ini record has been created.
22808>>>>>>>>>        If (iSize = -1) Begin
22810>>>>>>>>>            Move True to bFound
22811>>>>>>>>>        End
22811>>>>>>>>>>
22811>>>>>>>>>
22811>>>>>>>>>        Function_Return bFound
22812>>>>>>>>>    End_Function
22813>>>>>>>>>
22813>>>>>>>>>    // Send on object creation to read the default connection string settings, and
22813>>>>>>>>>    // create a connection to the server.
22813>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
22815>>>>>>>>>        String sPath sFileName
22815>>>>>>>>>        Boolean bExists bActive
22815>>>>>>>>>        tSQLConnection[] SQLConnectionArray
22815>>>>>>>>>        tSQLConnection[] SQLConnectionArray
22816>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22816>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22816>>>>>>>>>        Handle hoIniFile
22816>>>>>>>>>        Integer iSize iCount iRetval
22816>>>>>>>>>
22816>>>>>>>>>        Get psIniFilePath to sPath
22817>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
22818>>>>>>>>>        If (sPath = "") Begin
22820>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
22821>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
22822>>>>>>>>>        End
22822>>>>>>>>>>
22822>>>>>>>>>        Get vFolderFormat sPath to sPath
22823>>>>>>>>>        Get psIniFileName to sFileName
22824>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
22825>>>>>>>>>
22825>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
22826>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
22827>>>>>>>>>        If (iSize = 0) Begin
22829>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
22829>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
22829>>>>>>>>>            // in the cApplication object.
22829>>>>>>>>>            Get pSQLConnection to SQLConnection
22830>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
22832>>>>>>>>>                Function_Return SQLConnectionEmpty
22833>>>>>>>>>            End
22833>>>>>>>>>>
22833>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
22834>>>>>>>>>            Move 1 to iSize
22835>>>>>>>>>        End
22835>>>>>>>>>>
22835>>>>>>>>>
22835>>>>>>>>>        Move False to bActive
22836>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
22836>>>>>>>>>        Decrement iSize
22837>>>>>>>>>        For iCount from 0 to iSize
22843>>>>>>>>>>
22843>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
22844>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
22846>>>>>>>>>                Move True to bActive
22847>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
22848>>>>>>>>>            End
22848>>>>>>>>>>
22848>>>>>>>>>        Loop
22849>>>>>>>>>>
22849>>>>>>>>>
22849>>>>>>>>>        // In case all connections have been disabled, we're out of here.
22849>>>>>>>>>        If (bActive = False) Begin
22851>>>>>>>>>            Function_Return SQLConnectionEmpty
22852>>>>>>>>>        End
22852>>>>>>>>>>
22852>>>>>>>>>
22852>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
22853>>>>>>>>>
22853>>>>>>>>>        Set pSQLConnection to SQLConnection
22854>>>>>>>>>        Get AutoSetConnectionID to iRetval
22855>>>>>>>>>
22855>>>>>>>>>        Function_Return SQLConnection
22856>>>>>>>>>    End_Function
22857>>>>>>>>>
22857>>>>>>>>>    Procedure Set psIniFilePath String sPath
22859>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
22860>>>>>>>>>    End_Procedure
22861>>>>>>>>>
22861>>>>>>>>>    Function psIniFilePath Returns String
22863>>>>>>>>>        String sRetval
22863>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
22864>>>>>>>>>        Function_Return sRetval
22865>>>>>>>>>    End_Function
22866>>>>>>>>>
22866>>>>>>>>>    Procedure Set psIniFileName String sFileName
22868>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
22869>>>>>>>>>    End_Procedure
22870>>>>>>>>>
22870>>>>>>>>>    Function psIniFileName Returns String
22872>>>>>>>>>        String sRetval
22872>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
22873>>>>>>>>>        Function_Return sRetval
22874>>>>>>>>>    End_Function
22875>>>>>>>>>
22875>>>>>>>>>    Procedure Set psIniSectionName String sSection
22877>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
22878>>>>>>>>>    End_Procedure
22879>>>>>>>>>
22879>>>>>>>>>    Function psIniSectionName Returns String
22881>>>>>>>>>        String sRetval
22881>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
22882>>>>>>>>>        Function_Return sRetval
22883>>>>>>>>>    End_Function
22884>>>>>>>>>
22884>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
22886>>>>>>>>>        Handle ho
22886>>>>>>>>>        Get phoSQLConnectionIniFile to ho
22887>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
22888>>>>>>>>>    End_Procedure
22889>>>>>>>>>
22889>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
22891>>>>>>>>>        Handle ho
22891>>>>>>>>>        String sRetval
22891>>>>>>>>>        Get phoSQLConnectionIniFile to ho
22892>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
22893>>>>>>>>>        Function_Return sRetval
22894>>>>>>>>>    End_Function
22895>>>>>>>>>
22895>>>>>>>>>    Function SectionExists String sSection Returns Boolean
22897>>>>>>>>>        Handle ho
22897>>>>>>>>>        Boolean bRetval
22897>>>>>>>>>        Get phoSQLConnectionIniFile to ho
22898>>>>>>>>>        Get SectionExists of ho sSection to bRetval
22899>>>>>>>>>        Function_Return bRetval
22900>>>>>>>>>    End_Function
22901>>>>>>>>>
22901>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
22903>>>>>>>>>        Handle ho
22903>>>>>>>>>        Boolean bRetval
22903>>>>>>>>>        Get phoSQLConnectionIniFile to ho
22904>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
22905>>>>>>>>>        Function_Return bRetval
22906>>>>>>>>>    End_Function
22907>>>>>>>>>
22907>>>>>>>>>    Function EncryptPassword String sPassword Returns String
22909>>>>>>>>>        Handle ho
22909>>>>>>>>>        String sRetval
22909>>>>>>>>>        Get phoSQLConnectionIniFile to ho
22910>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
22911>>>>>>>>>        Function_Return sRetval
22912>>>>>>>>>    End_Function
22913>>>>>>>>>
22913>>>>>>>>>    Function DecryptPassword String sPassword Returns String
22915>>>>>>>>>        Handle ho
22915>>>>>>>>>        String sRetval
22915>>>>>>>>>        Get phoSQLConnectionIniFile to ho
22916>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
22917>>>>>>>>>        Function_Return sRetval
22918>>>>>>>>>    End_Function
22919>>>>>>>>>
22919>>>>>>>>>    // *** Main Connection Message ***
22919>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
22921>>>>>>>>>        Handle hoDriver
22921>>>>>>>>>        String sConnectionString sError
22921>>>>>>>>>        Boolean bLoginSuccessful
22921>>>>>>>>>
22921>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
22922>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
22923>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
22924>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
22925>>>>>>>>>        If (bLoginSuccessful = False) Begin
22927>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
22928>>>>>>>>>>
22928>>>>>>>>>            If (bExitProgram = True) Begin
22930>>>>>>>>>                Send Exit_Application
22931>>>>>>>>>            End
22931>>>>>>>>>>
22931>>>>>>>>>        End
22931>>>>>>>>>>
22931>>>>>>>>>        Send Destroy of hoDriver
22932>>>>>>>>>    End_Procedure
22933>>>>>>>>>
22933>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
22935>>>>>>>>>        Integer iRetval
22935>>>>>>>>>        Handle hoCLI
22935>>>>>>>>>        String sDriverID
22935>>>>>>>>>
22935>>>>>>>>>        Get psDriverID to sDriverID
22936>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
22937>>>>>>>>>        If (hoCLI <> 0) Begin
22939>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
22940>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
22941>>>>>>>>>            Send Destroy of hoCLI
22942>>>>>>>>>        End
22942>>>>>>>>>>
22942>>>>>>>>>
22942>>>>>>>>>        Function_Return iRetval
22943>>>>>>>>>    End_Function
22944>>>>>>>>>
22944>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
22946>>>>>>>>>        tSQLConnection SQLConnection
22946>>>>>>>>>        tSQLConnection SQLConnection
22946>>>>>>>>>
22946>>>>>>>>>        Set psDriverID to sDriverID
22947>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
22948>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
22949>>>>>>>>>    End_Procedure
22950>>>>>>>>>
22950>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
22950>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
22950>>>>>>>>>    // or the one in the DataFlex Bin folder.)
22950>>>>>>>>>    // We then need to delete the current one before creating a new one.
22950>>>>>>>>>    // This is because the parameters may differ between the program code and the
22950>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
22950>>>>>>>>>    // when one tries to create a Connection ID that already exists.
22950>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
22952>>>>>>>>>        Integer iResult iDriver iNumConn iConn
22952>>>>>>>>>        Handle hoCLI
22952>>>>>>>>>        String sID
22952>>>>>>>>>
22952>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
22954>>>>>>>>>            Procedure_Return
22955>>>>>>>>>        End
22955>>>>>>>>>>
22955>>>>>>>>>
22955>>>>>>>>>        Move 0 to iResult
22956>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
22957>>>>>>>>>        If (hoCLI <> 0) Begin
22959>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
22960>>>>>>>>>            Get DriverIndex sDriverID to iDriver
22961>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
22964>>>>>>>>>            Decrement iNumConn
22965>>>>>>>>>            For iConn from 0 to iNumConn
22971>>>>>>>>>>
22971>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
22974>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
22976>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
22977>>>>>>>>>                End
22977>>>>>>>>>>
22977>>>>>>>>>            Loop
22978>>>>>>>>>>
22978>>>>>>>>>            Send Destroy of hoCLI
22979>>>>>>>>>        End
22979>>>>>>>>>>
22979>>>>>>>>>
22979>>>>>>>>>    End_Procedure
22980>>>>>>>>>
22980>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
22982>>>>>>>>>        Integer iResult iDriver iNumConn iConn
22982>>>>>>>>>        Handle hoCLI
22982>>>>>>>>>        String sID sConnectionString sVal sDatabase
22982>>>>>>>>>        tSQLConnection SQLConnection
22982>>>>>>>>>        tSQLConnection SQLConnection
22982>>>>>>>>>        Boolean bTrusted
22982>>>>>>>>>
22982>>>>>>>>>        Move 0 to iResult
22983>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
22984>>>>>>>>>        If (hoCLI <> 0) Begin
22986>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
22987>>>>>>>>>            Get DriverIndex sDriverID to iDriver
22988>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
22991>>>>>>>>>            Decrement iNumConn
22992>>>>>>>>>            For iConn from 0 to iNumConn
22998>>>>>>>>>>
22998>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
23001>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
23003>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
23004>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
23007>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
23010>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
23011>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
23014>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
23015>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
23016>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
23017>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
23018>>>>>>>>>
23018>>>>>>>>>                    Case Begin
23018>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
23020>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
23021>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
23022>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
23023>>>>>>>>>                            Case Break
23024>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
23027>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23028>>>>>>>>>                            Case Break
23029>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
23032>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23033>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
23035>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
23036>>>>>>>>>                            End
23036>>>>>>>>>>
23036>>>>>>>>>                            Case Break
23037>>>>>>>>>                        Case (sDriverID = SQLFLEX)
23040>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23041>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
23042>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23044>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23045>>>>>>>>>                            End
23045>>>>>>>>>>
23045>>>>>>>>>                            Else Begin
23046>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23047>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23048>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23049>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23050>>>>>>>>>                            End
23050>>>>>>>>>>
23050>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
23051>>>>>>>>>                            Case Break
23052>>>>>>>>>                        Case (sDriverID = MDSMySQL)
23055>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23056>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
23057>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23059>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23060>>>>>>>>>                            End
23060>>>>>>>>>>
23060>>>>>>>>>                            Else Begin
23061>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23062>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23063>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23064>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23065>>>>>>>>>                            End
23065>>>>>>>>>>
23065>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
23066>>>>>>>>>                            Case Break
23067>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
23070>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23071>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
23072>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23074>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23075>>>>>>>>>                            End
23075>>>>>>>>>>
23075>>>>>>>>>                            Else Begin
23076>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23077>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23078>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23079>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23080>>>>>>>>>                            End
23080>>>>>>>>>>
23080>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
23081>>>>>>>>>                            Case Break
23082>>>>>>>>>
23082>>>>>>>>>                        Case (sDriverID = ORAFLEX)
23085>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
23086>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
23087>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23088>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
23090>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
23091>>>>>>>>>                            End
23091>>>>>>>>>>
23091>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
23093>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
23094>>>>>>>>>                            End
23094>>>>>>>>>>
23094>>>>>>>>>                            Else Begin
23095>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
23096>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
23097>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
23098>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
23099>>>>>>>>>                            End
23099>>>>>>>>>>
23099>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
23100>>>>>>>>>                            Case Break
23101>>>>>>>>>                        Case Else
23101>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
23102>>>>>>>>>>
23102>>>>>>>>>                            Case Break
23103>>>>>>>>>                    Case End
23103>>>>>>>>>                End
23103>>>>>>>>>>
23103>>>>>>>>>            Loop
23104>>>>>>>>>>
23104>>>>>>>>>            Send Destroy of hoCLI
23105>>>>>>>>>        End
23105>>>>>>>>>>
23105>>>>>>>>>
23105>>>>>>>>>        Function_Return SQLConnection
23106>>>>>>>>>    End_Function
23107>>>>>>>>>
23107>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
23109>>>>>>>>>        String  sCurrentDriver
23109>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
23109>>>>>>>>>
23109>>>>>>>>>        Move 0 to iDriver
23110>>>>>>>>>        Move 0 to iCount
23111>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
23114>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
23120>>>>>>>>>>
23120>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
23123>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
23125>>>>>>>>>                Function_Return iCount
23126>>>>>>>>>            End
23126>>>>>>>>>>
23126>>>>>>>>>        Loop
23127>>>>>>>>>>
23127>>>>>>>>>
23127>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
23127>>>>>>>>>        If (iDriver = 0) Begin
23129>>>>>>>>>            Move 0 to LastErr
23130>>>>>>>>>            Load_Driver sDriverID
23131>>>>>>>>>            // If driver could not be loaded.
23131>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
23133>>>>>>>>>                Move -1 to iCount
23134>>>>>>>>>            End
23134>>>>>>>>>>
23134>>>>>>>>>        End
23134>>>>>>>>>>
23134>>>>>>>>>        Function_Return iCount
23135>>>>>>>>>    End_Function
23136>>>>>>>>>
23136>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
23136>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
23138>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
23138>>>>>>>>>        Boolean bTrusted bSilent
23138>>>>>>>>>        Integer iRetval
23138>>>>>>>>>
23138>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
23139>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
23140>>>>>>>>>        Move SQLConnection.sServer       to sServer
23141>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
23142>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
23143>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
23144>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
23145>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
23146>>>>>>>>>
23146>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
23147>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
23147>>>>>>>>>        Get AutoSetConnectionID to iRetval
23148>>>>>>>>>    End_Procedure
23149>>>>>>>>>
23149>>>>>>>>>    // Called when the object is constructed.
23149>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
23149>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
23149>>>>>>>>>    // the database is needed.
23149>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
23151>>>>>>>>>        String sConnectionID sDriverID sConnectionString
23151>>>>>>>>>        Integer iDriver iRetval
23151>>>>>>>>>        Handle hoCLI
23151>>>>>>>>>        Boolean bOK bSilent bMertechDriver
23151>>>>>>>>>
23151>>>>>>>>>        Get pbSilentLogin      to bSilent
23152>>>>>>>>>        Get psConnectionID     to sConnectionID
23153>>>>>>>>>        Get psConnectionString to sConnectionString
23154>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
23154>>>>>>>>>        Get psDriverID to sDriverID
23155>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23156>>>>>>>>>        If (bOK = False) Begin
23158>>>>>>>>>            Function_Return False
23159>>>>>>>>>        End
23159>>>>>>>>>>
23159>>>>>>>>>
23159>>>>>>>>>        // Mertech drivers can't use connection ID's.
23159>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
23160>>>>>>>>>        If (bMertechDriver = True) Begin
23162>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
23162>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
23162>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
23163>>>>>>>>>            Function_Return (hoCLI <> 0)
23164>>>>>>>>>        End
23164>>>>>>>>>>
23164>>>>>>>>>
23164>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
23165>>>>>>>>>        // If driver not loaded; load it.
23165>>>>>>>>>        If (iDriver = 0) Begin
23167>>>>>>>>>            Load_Driver sDriverID
23168>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
23169>>>>>>>>>        End
23169>>>>>>>>>>
23169>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
23169>>>>>>>>>        If (iDriver = 0) Begin
23171>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
23172>>>>>>>>>>
23172>>>>>>>>>            Function_Return False
23173>>>>>>>>>        End           
23173>>>>>>>>>>
23173>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
23176>>>>>>>>>        
23176>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23177>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
23178>>>>>>>>>        // Delete the connection first; in case it exists
23178>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
23179>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
23180>>>>>>>>>        Send Destroy of hoCLI
23181>>>>>>>>>
23181>>>>>>>>>        Function_Return (iRetval = 0)
23182>>>>>>>>>    End_Function
23183>>>>>>>>>
23183>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
23183>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
23183>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
23183>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
23183>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
23183>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
23185>>>>>>>>>        Handle hoSQLHandler
23185>>>>>>>>>        String sDriverID sServer sDatabase
23185>>>>>>>>>
23185>>>>>>>>>        Move 0 to hoSQLHandler
23186>>>>>>>>>        Get psDriverID to sDriverID
23187>>>>>>>>>        Get psServer   to sServer
23188>>>>>>>>>        Get psDatabase to sDatabase
23189>>>>>>>>>
23189>>>>>>>>>        Function_Return hoSQLHandler
23190>>>>>>>>>    End_Function
23191>>>>>>>>>
23191>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
23193>>>>>>>>>        Boolean bOK bMertechDriver
23193>>>>>>>>>
23193>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
23194>>>>>>>>>
23194>>>>>>>>>        If (bOK = False) Begin
23196>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
23197>>>>>>>>>        End
23197>>>>>>>>>>
23197>>>>>>>>>
23197>>>>>>>>>        If (bOK = False) Begin
23199>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
23200>>>>>>>>>            If (bMertechDriver = True) Begin
23202>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
23203>>>>>>>>>>
23203>>>>>>>>>            End
23203>>>>>>>>>>
23203>>>>>>>>>            Else Begin
23204>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
23205>>>>>>>>>>
23205>>>>>>>>>            End
23205>>>>>>>>>>
23205>>>>>>>>>            Function_Return False
23206>>>>>>>>>        End
23206>>>>>>>>>>
23206>>>>>>>>>
23206>>>>>>>>>        Function_Return True
23207>>>>>>>>>    End_Function
23208>>>>>>>>>
23208>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
23210>>>>>>>>>        Boolean bOK
23210>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
23211>>>>>>>>>        Function_Return bOK
23212>>>>>>>>>    End_Function
23213>>>>>>>>>
23213>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
23215>>>>>>>>>        Boolean bOK
23215>>>>>>>>>        Move False to bOK
23216>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
23216>>>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
23217>>>>>>>>>//        #ENDIF
23217>>>>>>>>>        Function_Return bOK
23218>>>>>>>>>    End_Function
23219>>>>>>>>>
23219>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
23221>>>>>>>>>        Handle hoIniFile
23221>>>>>>>>>        String sConnect
23221>>>>>>>>>
23221>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
23222>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
23223>>>>>>>>>
23223>>>>>>>>>        Function_Return sConnect
23224>>>>>>>>>    End_Function
23225>>>>>>>>>
23225>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
23225>>>>>>>>>    // Pass a complete driver connection string
23225>>>>>>>>>    // Returns the following as a struct:
23225>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
23225>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
23225>>>>>>>>>    //
23225>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
23227>>>>>>>>>        tSQLConnection SQLConnection
23227>>>>>>>>>        tSQLConnection SQLConnection
23227>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
23227>>>>>>>>>        Boolean bTrusted bSilent bOK
23227>>>>>>>>>        Integer iPos
23227>>>>>>>>>
23227>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23228>>>>>>>>>        If (bOK = False) Begin
23230>>>>>>>>>            Function_Return SQLConnection
23231>>>>>>>>>        End
23231>>>>>>>>>>
23231>>>>>>>>>
23231>>>>>>>>>        Move False to bTrusted
23232>>>>>>>>>        Move False to bSilent
23233>>>>>>>>>
23233>>>>>>>>>        Case Begin
23233>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
23235>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
23236>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23237>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23238>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23239>>>>>>>>>                If (bTrusted = False) Begin
23241>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23242>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23243>>>>>>>>>                End
23243>>>>>>>>>>
23243>>>>>>>>>                Case Break
23244>>>>>>>>>
23244>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
23247>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
23249>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
23250>>>>>>>>>                End
23250>>>>>>>>>>
23250>>>>>>>>>                Else Begin
23251>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23252>>>>>>>>>                End
23252>>>>>>>>>>
23252>>>>>>>>>
23252>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23253>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23254>>>>>>>>>                If (bTrusted = False) Begin
23256>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23257>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23258>>>>>>>>>                End
23258>>>>>>>>>>
23258>>>>>>>>>                Case Break
23259>>>>>>>>>
23259>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
23262>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23263>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23264>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23265>>>>>>>>>                Case Break
23266>>>>>>>>>
23266>>>>>>>>>            Case (sDriverID = SQLFLEX)
23269>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
23270>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23271>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23272>>>>>>>>>                If (bTrusted = False) Begin
23274>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23275>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23276>>>>>>>>>                End
23276>>>>>>>>>>
23276>>>>>>>>>                Case Break
23277>>>>>>>>>
23277>>>>>>>>>            Case (sDriverID = ORAFLEX)
23280>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23281>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23282>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
23284>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
23285>>>>>>>>>                End
23285>>>>>>>>>>
23285>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23286>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23287>>>>>>>>>                Case Break
23288>>>>>>>>>
23288>>>>>>>>>            Case (sDriverID = MDSPgSQL)
23291>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23292>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23293>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23294>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23295>>>>>>>>>                Case Break
23296>>>>>>>>>
23296>>>>>>>>>            Case (sDriverID = MDSMySQL)
23299>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23300>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23301>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23302>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23303>>>>>>>>>                Case Break
23304>>>>>>>>>
23304>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
23307>>>>>>>>>                Break
23308>>>>>>>>>        Case End
23308>>>>>>>>>
23308>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
23309>>>>>>>>>
23309>>>>>>>>>        // bSilent?
23309>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
23310>>>>>>>>>        If (iPos = 0) Begin
23312>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
23313>>>>>>>>>        End
23313>>>>>>>>>>
23313>>>>>>>>>        If (iPos = 0) Begin
23315>>>>>>>>>            Move "0"                                                            to sValue
23316>>>>>>>>>        End
23316>>>>>>>>>>
23316>>>>>>>>>        Else Begin
23317>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
23318>>>>>>>>>        End
23318>>>>>>>>>>
23318>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
23319>>>>>>>>>
23319>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
23320>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
23321>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
23322>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
23323>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
23324>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
23325>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
23326>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
23327>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
23328>>>>>>>>>
23328>>>>>>>>>        Function_Return SQLConnection
23329>>>>>>>>>    End_Function
23330>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
23330>>>>>>>>>>
23330>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
23332>>>>>>>>>>    Integer iStart iEnd
23332>>>>>>>>>>    String sRetval
23332>>>>>>>>>>
23332>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
23333>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
23334>>>>>>>>>>    If (iStart = 0) Begin
23336>>>>>>>>>>        Function_Return ""
23337>>>>>>>>>>    End
23337>>>>>>>>>>>
23337>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
23338>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
23339>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
23341>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
23342>>>>>>>>>>    End
23342>>>>>>>>>>>
23342>>>>>>>>>>    Else Begin
23343>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
23344>>>>>>>>>>    End
23344>>>>>>>>>>>
23344>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
23346>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
23347>>>>>>>>>>        Decrement iEnd
23348>>>>>>>>>>    End
23348>>>>>>>>>>>
23348>>>>>>>>>>    If (iEnd <> 0) Begin
23350>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
23351>>>>>>>>>>    End
23351>>>>>>>>>>>
23351>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
23352>>>>>>>>>>
23352>>>>>>>>>>    Function_Return (Trim(sRetval))
23353>>>>>>>>>>End_Function
23354>>>>>>>>>>
23354>>>>>>>>>>
23354>>>>>>>>>
23354>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
23354>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
23356>>>>>>>>>        Handle ho
23356>>>>>>>>>        Integer iIndex
23356>>>>>>>>>        Boolean bRetval bOK
23356>>>>>>>>>        tSQLConnection SQLConnection
23356>>>>>>>>>        tSQLConnection SQLConnection
23356>>>>>>>>>
23356>>>>>>>>>        Get pSQLConnection to SQLConnection
23357>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23358>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
23359>>>>>>>>>        If (iIndex = -1) Begin
23361>>>>>>>>>            Function_Return False
23362>>>>>>>>>        End
23362>>>>>>>>>>
23362>>>>>>>>>
23362>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
23363>>>>>>>>>        Send UpdateConnectionString SQLConnection
23364>>>>>>>>>        If (ghoConnection > 0) Begin
23366>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
23367>>>>>>>>>            If (iIndex <> -1) Begin
23369>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
23370>>>>>>>>>            End
23370>>>>>>>>>>
23370>>>>>>>>>        End
23370>>>>>>>>>>
23370>>>>>>>>>
23370>>>>>>>>>        Function_Return bRetval
23371>>>>>>>>>    End_Function
23372>>>>>>>>>
23372>>>>>>>>>End_Class
23373>>>>>>>Use vWin32fh.pkg
23373>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\Libraries\DFAbout\DfAbout.pkg)
23373>>>>>>>>>Use LanguageText.pkg
23373>>>>>>>>>Use Windows.pkg
23373>>>>>>>>>Use Dfclient.pkg
Including file: Dfclient.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfclient.pkg)
23373>>>>>>>>>>>Use Windows.pkg
23373>>>>>>>>>>>Use DfPanel.pkg
Including file: Dfpanel.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfpanel.pkg)
23373>>>>>>>>>>>>>Use Windows.pkg
23373>>>>>>>>>>>>>Use dfcolor.pkg
23373>>>>>>>>>>>>>
23373>>>>>>>>>>>>>//  Used when help object makes a request to the object requesting help.
23373>>>>>>>>>>>>>Use HelpSystemConstants.pkg
23373>>>>>>>>>>>>>
23373>>>>>>>>>>>>>Enumeration_List
23373>>>>>>>>>>>>>    Define amTop
23373>>>>>>>>>>>>>    Define amBottom
23373>>>>>>>>>>>>>    Define amLeft
23373>>>>>>>>>>>>>    Define amRight
23373>>>>>>>>>>>>>End_Enumeration_List
23373>>>>>>>>>>>>>
23373>>>>>>>>>>>>>Use DFAStBar.pkg  // df application status bar
Including file: Dfastbar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfastbar.pkg)
23373>>>>>>>>>>>>>>>Register_Procedure Add_Border_Object
23373>>>>>>>>>>>>>>>Register_Procedure Remove_Border_Object
23373>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>Use DFStatBr.pkg
Including file: Dfstatbr.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfstatbr.pkg)
23373>>>>>>>>>>>>>>>>>Use windows.pkg
23373>>>>>>>>>>>>>>>>>Use CommCtrl.pkg
23373>>>>>>>>>>>>>>>>>Use WinGDI.pkg
23373>>>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>>>
23373>>>>>>>>>>>>>>>>>Class BasicStatusBar is a dfBaseList
23374>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23376>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23378>>>>>>>>>>>>>>>>>        Property Integer Private.Simple_State False
23379>>>>>>>>>>>>>>>>>        
23379>>>>>>>>>>>>>>>>>        Property String  Private.Simple_Value ''
23380>>>>>>>>>>>>>>>>>        
23380>>>>>>>>>>>>>>>>>        Property Integer Tooltips_State False // this does nothing
23381>>>>>>>>>>>>>>>>>        Set Scroll_Bar_Visible_State to False
23382>>>>>>>>>>>>>>>>>        Set Border_Style             to Border_None
23383>>>>>>>>>>>>>>>>>        Set External_class_Name "cObsoleteBasicStatusBar" to "msctls_statusbar32"
23384>>>>>>>>>>>>>>>>>        Set Color to clDefault
23385>>>>>>>>>>>>>>>>>    End_Procedure
23386>>>>>>>>>>>>>>>>>    
23386>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
23388>>>>>>>>>>>>>>>>>        //If (Tooltips_State(self)) Set Window_Style To SBT_TOOLTIPS True
23388>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
23390>>>>>>>>>>>>>>>>>    End_Procedure
23391>>>>>>>>>>>>>>>>>    
23391>>>>>>>>>>>>>>>>>    Procedure Set Simple_State Integer bState
23393>>>>>>>>>>>>>>>>>        Handle hWnd
23393>>>>>>>>>>>>>>>>>        Set Private.Simple_state to bState
23394>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23395>>>>>>>>>>>>>>>>>        If hWnd ;            Send Windows_Message SB_SIMPLE bState 0
23398>>>>>>>>>>>>>>>>>    End_Procedure
23399>>>>>>>>>>>>>>>>>    
23399>>>>>>>>>>>>>>>>>    Function Simple_State Returns Integer
23401>>>>>>>>>>>>>>>>>        Function_Return (Private.Simple_state(Self))
23402>>>>>>>>>>>>>>>>>    End_Function
23403>>>>>>>>>>>>>>>>>    
23403>>>>>>>>>>>>>>>>>    Procedure Set Simple_Value String sValue
23405>>>>>>>>>>>>>>>>>        Integer iVoid
23405>>>>>>>>>>>>>>>>>        Handle hWnd
23405>>>>>>>>>>>>>>>>>        WString wsValue
23405>>>>>>>>>>>>>>>>>        
23405>>>>>>>>>>>>>>>>>        Set Private.Simple_Value to sValue
23406>>>>>>>>>>>>>>>>>        
23406>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23407>>>>>>>>>>>>>>>>>        If hWnd Begin
23409>>>>>>>>>>>>>>>>>            Append sValue ( Character(0) )
23410>>>>>>>>>>>>>>>>>            Move sValue to wsValue
23411>>>>>>>>>>>>>>>>>            
23411>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SETTEXT (255 + sbNORMAL) (AddressOf(wsValue))
23412>>>>>>>>>>>>>>>>>        End
23412>>>>>>>>>>>>>>>>>>
23412>>>>>>>>>>>>>>>>>        Set Simple_State to True
23413>>>>>>>>>>>>>>>>>    End_Procedure
23414>>>>>>>>>>>>>>>>>    
23414>>>>>>>>>>>>>>>>>    Function Simple_Value Returns String
23416>>>>>>>>>>>>>>>>>        Function_Return (private.Simple_value(Self))
23417>>>>>>>>>>>>>>>>>    End_Function
23418>>>>>>>>>>>>>>>>>    
23418>>>>>>>>>>>>>>>>>    Procedure Activate
23420>>>>>>>>>>>>>>>>>    End_Procedure
23421>>>>>>>>>>>>>>>>>    
23421>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer iState
23423>>>>>>>>>>>>>>>>>        Handle hWnd
23423>>>>>>>>>>>>>>>>>        Get Window_handle to hWnd
23424>>>>>>>>>>>>>>>>>        Forward Send Page_Object iState
23426>>>>>>>>>>>>>>>>>        If (iState and hWnd = 0) ;            Send DoRestructure
23429>>>>>>>>>>>>>>>>>    End_Procedure
23430>>>>>>>>>>>>>>>>>    
23430>>>>>>>>>>>>>>>>>    Procedure Page Integer iState
23432>>>>>>>>>>>>>>>>>        Forward Send Page iState
23434>>>>>>>>>>>>>>>>>        If (iState=1) Begin
23436>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SETBKCOLOR 0 (Color(Self))
23437>>>>>>>>>>>>>>>>>        End
23437>>>>>>>>>>>>>>>>>>
23437>>>>>>>>>>>>>>>>>    End_Procedure
23438>>>>>>>>>>>>>>>>>    
23438>>>>>>>>>>>>>>>>>    Procedure DoRestructure
23440>>>>>>>>>>>>>>>>>        Integer iLoop icItems iWidth icWidth iRetVal
23440>>>>>>>>>>>>>>>>>        Handle hWnd
23440>>>>>>>>>>>>>>>>>        Integer[] aItems
23441>>>>>>>>>>>>>>>>>        
23441>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23442>>>>>>>>>>>>>>>>>        If hWnd Begin
23444>>>>>>>>>>>>>>>>>            
23444>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SIMPLE (Simple_State(Self)) 0
23445>>>>>>>>>>>>>>>>>            Set Simple_Value to (Simple_Value(Self))
23446>>>>>>>>>>>>>>>>>            
23446>>>>>>>>>>>>>>>>>            Get Item_Count to icItems
23447>>>>>>>>>>>>>>>>>            
23447>>>>>>>>>>>>>>>>>            For iLoop from 1 to (icItems -1)
23453>>>>>>>>>>>>>>>>>>
23453>>>>>>>>>>>>>>>>>                Get Message (iLoop -1) to iWidth
23454>>>>>>>>>>>>>>>>>                Move (icWidth + iWidth) to icWidth
23455>>>>>>>>>>>>>>>>>                Move (icWidth) to aItems[iLoop - 1]
23456>>>>>>>>>>>>>>>>>                
23456>>>>>>>>>>>>>>>>>                Set Value (iLoop -1) to (Value(Self, iLoop -1))
23457>>>>>>>>>>>>>>>>>            Loop
23458>>>>>>>>>>>>>>>>>>
23458>>>>>>>>>>>>>>>>>            // Now make the last item 'spring' to the end
23458>>>>>>>>>>>>>>>>>            Move -1 to aItems[icItems - 1]
23459>>>>>>>>>>>>>>>>>                        
23459>>>>>>>>>>>>>>>>>            Move (SendMessage(hWnd, SB_SETPARTS, icItems, AddressOf(aItems))) to iRetVal
23460>>>>>>>>>>>>>>>>>            For iLoop from 0 to (icItems -1)
23466>>>>>>>>>>>>>>>>>>
23466>>>>>>>>>>>>>>>>>                Set Value iLoop to (Value(Self, iLoop))
23467>>>>>>>>>>>>>>>>>            Loop
23468>>>>>>>>>>>>>>>>>>
23468>>>>>>>>>>>>>>>>>            
23468>>>>>>>>>>>>>>>>>        End
23468>>>>>>>>>>>>>>>>>>
23468>>>>>>>>>>>>>>>>>    End_Procedure
23469>>>>>>>>>>>>>>>>>    
23469>>>>>>>>>>>>>>>>>    Procedure Add_Item Integer iItemWidth String sValue // this is obsolete
23471>>>>>>>>>>>>>>>>>        Integer iRetVal icItems
23471>>>>>>>>>>>>>>>>>        Handle hWnd
23471>>>>>>>>>>>>>>>>>        
23471>>>>>>>>>>>>>>>>>        Forward Send Add_Item iItemWidth sValue
23473>>>>>>>>>>>>>>>>>        Get Item_Count to icItems
23474>>>>>>>>>>>>>>>>>        Set Value (icItems -1) to sValue
23475>>>>>>>>>>>>>>>>>        If (Window_Handle(Self)) ;            Send DoRestructure
23478>>>>>>>>>>>>>>>>>        Set Current_item to (icItems -1)
23479>>>>>>>>>>>>>>>>>    End_Procedure
23480>>>>>>>>>>>>>>>>>    
23480>>>>>>>>>>>>>>>>>    Procedure AddPane Integer iItemWidth String sValue Integer iStyle
23482>>>>>>>>>>>>>>>>>        Integer iRetVal icItem
23482>>>>>>>>>>>>>>>>>        Handle hWnd
23482>>>>>>>>>>>>>>>>>        
23482>>>>>>>>>>>>>>>>>        Send Add_Item iItemWidth sValue
23483>>>>>>>>>>>>>>>>>        Get Item_Count to icItem
23484>>>>>>>>>>>>>>>>>        Set Value (icItem -1) to sValue
23485>>>>>>>>>>>>>>>>>        Set Aux_Value (icItem -1) to iStyle
23486>>>>>>>>>>>>>>>>>        If (Window_Handle(Self)) ;            Send DoRestructure
23489>>>>>>>>>>>>>>>>>    End_Procedure
23490>>>>>>>>>>>>>>>>>    
23490>>>>>>>>>>>>>>>>>    Procedure AutoSizeLocate
23492>>>>>>>>>>>>>>>>>        Integer iSize iRetVal
23492>>>>>>>>>>>>>>>>>        Handle hWnd
23492>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23493>>>>>>>>>>>>>>>>>        Delegate Get GuiSize to iSize
23495>>>>>>>>>>>>>>>>>        If hWnd ;            Move (SendMessage(hWnd, WM_SIZE, 0, iSize)) to iRetVal
23498>>>>>>>>>>>>>>>>>    End_Procedure
23499>>>>>>>>>>>>>>>>>    
23499>>>>>>>>>>>>>>>>>    Procedure Set Item_Display_Style Integer iItem Integer iStyle  // this is obsolete, Use PaneStyle
23501>>>>>>>>>>>>>>>>>        If (num_arguments = 2) ;            Set Aux_Value iItem to iStyle
23504>>>>>>>>>>>>>>>>>        Else ;            Set Aux_Value (current_item(Self)) to iItem //iStyle passed as arg1
23506>>>>>>>>>>>>>>>>>    End_Procedure
23507>>>>>>>>>>>>>>>>>    
23507>>>>>>>>>>>>>>>>>    Function Item_Display_Style Integer iItem Returns Integer // this is obsolete, use PaneStyle
23509>>>>>>>>>>>>>>>>>        Function_Return (Aux_value(Self, iItem))
23510>>>>>>>>>>>>>>>>>    End_Function
23511>>>>>>>>>>>>>>>>>    
23511>>>>>>>>>>>>>>>>>    Procedure Set Value Integer iItem String sValue
23513>>>>>>>>>>>>>>>>>        Handle hWnd
23513>>>>>>>>>>>>>>>>>        Integer iRetVal iTextStyle iVoid
23513>>>>>>>>>>>>>>>>>        String sNull
23513>>>>>>>>>>>>>>>>>        WString wsValue
23513>>>>>>>>>>>>>>>>>        
23513>>>>>>>>>>>>>>>>>        Forward Set Value iItem to sValue
23515>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23516>>>>>>>>>>>>>>>>>        If hWnd Begin
23518>>>>>>>>>>>>>>>>>            Get Item_Display_Style iItem to iTextStyle
23519>>>>>>>>>>>>>>>>>            Append sValue ( Character(0) )
23520>>>>>>>>>>>>>>>>>            Move sValue to wsValue
23521>>>>>>>>>>>>>>>>>            Move (SendMessage(hWnd, SB_SETTEXT, iItem + iTextStyle, AddressOf(wsValue))) to iRetVal
23522>>>>>>>>>>>>>>>>>        End
23522>>>>>>>>>>>>>>>>>>
23522>>>>>>>>>>>>>>>>>        Set Simple_State to False
23523>>>>>>>>>>>>>>>>>    End_Procedure
23524>>>>>>>>>>>>>>>>>    
23524>>>>>>>>>>>>>>>>>    Function IsSimpleMode Returns Integer
23526>>>>>>>>>>>>>>>>>        Function_Return (WindowsMessage(SB_ISSIMPLE, 0, 0))
23527>>>>>>>>>>>>>>>>>    End_Function
23528>>>>>>>>>>>>>>>>>    
23528>>>>>>>>>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
23530>>>>>>>>>>>>>>>>>        Integer iVoid iCode
23530>>>>>>>>>>>>>>>>>        Longptr iPane
23530>>>>>>>>>>>>>>>>>        tWinNmMouse NmMouse
23530>>>>>>>>>>>>>>>>>        tWinNmMouse NmMouse
23530>>>>>>>>>>>>>>>>>        
23530>>>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(NmMouse), lParam, SizeOfType(tWinNmMouse))) to iVoid
23531>>>>>>>>>>>>>>>>>        
23531>>>>>>>>>>>>>>>>>        Move NmMouse.hdr.code   to iCode
23532>>>>>>>>>>>>>>>>>        Move NmMouse.dwItemSpec to iPane
23533>>>>>>>>>>>>>>>>>        
23533>>>>>>>>>>>>>>>>>        If (iCode = SBN_SIMPLEMODECHANGE) ;            Send OnSimpleModeChange
23536>>>>>>>>>>>>>>>>>        Else If (iCode = NM_CLICK) ;            Send OnClick            iPane
23540>>>>>>>>>>>>>>>>>        Else If (iCode = NM_DBLCLK) ;            Send OnDoubleClick      iPane
23544>>>>>>>>>>>>>>>>>        Else If (iCode = NM_RCLICK) ;            Send OnRightClick       iPane
23548>>>>>>>>>>>>>>>>>        Else If (iCode = NM_RDBLCLK) ;            Send OnDoubleRightClick iPane
23552>>>>>>>>>>>>>>>>>    End_Procedure
23553>>>>>>>>>>>>>>>>>    
23553>>>>>>>>>>>>>>>>>    //  This needs to be chagned to return the real GUISize of the status bar
23553>>>>>>>>>>>>>>>>>    //  by making API calls.
23553>>>>>>>>>>>>>>>>>    //
23553>>>>>>>>>>>>>>>>>    Function GuiSize Returns Integer
23555>>>>>>>>>>>>>>>>>        Handle hWnd
23555>>>>>>>>>>>>>>>>>        Integer cy cx iVoid
23555>>>>>>>>>>>>>>>>>        tWinRect Rect
23555>>>>>>>>>>>>>>>>>        tWinRect Rect
23555>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23556>>>>>>>>>>>>>>>>>        If hWnd Begin
23558>>>>>>>>>>>>>>>>>            Move (GetWindowRect(hWnd, AddressOf(Rect))) to iVoid
23559>>>>>>>>>>>>>>>>>            Move (Rect.right - Rect.left) to cx
23560>>>>>>>>>>>>>>>>>            Move (Rect.bottom - Rect.top) to cy
23561>>>>>>>>>>>>>>>>>        End
23561>>>>>>>>>>>>>>>>>>
23561>>>>>>>>>>>>>>>>>        Else Begin
23562>>>>>>>>>>>>>>>>>            Move 25 to cy
23563>>>>>>>>>>>>>>>>>            Move 19 to cx
23564>>>>>>>>>>>>>>>>>        End
23564>>>>>>>>>>>>>>>>>>
23564>>>>>>>>>>>>>>>>>        Function_Return ( cy*65536 + cx )
23565>>>>>>>>>>>>>>>>>    End_Function
23566>>>>>>>>>>>>>>>>>    
23566>>>>>>>>>>>>>>>>>    Function PaneTextWidth WString sText Returns Integer
23568>>>>>>>>>>>>>>>>>        Handle hWnd hDC
23568>>>>>>>>>>>>>>>>>        Integer bOK
23568>>>>>>>>>>>>>>>>>        tWinPoint Point
23568>>>>>>>>>>>>>>>>>        tWinPoint Point
23568>>>>>>>>>>>>>>>>>        
23568>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23569>>>>>>>>>>>>>>>>>        Move (GetDC(hWnd)) to hDC
23570>>>>>>>>>>>>>>>>>        
23570>>>>>>>>>>>>>>>>>        Move (GetTextExtentW(hDC, AddressOf(sText), length(sText), AddressOf(Point))) to bOk
23571>>>>>>>>>>>>>>>>>        
23571>>>>>>>>>>>>>>>>>        Move (ReleaseDC(hWnd, hDC)) to hDC
23572>>>>>>>>>>>>>>>>>        
23572>>>>>>>>>>>>>>>>>        Function_Return Point.x
23573>>>>>>>>>>>>>>>>>    End_Function
23574>>>>>>>>>>>>>>>>>    
23574>>>>>>>>>>>>>>>>>    Procedure Set PaneWidth Integer iPane Integer cxPane
23576>>>>>>>>>>>>>>>>>        Set Message iPane to cxPane
23577>>>>>>>>>>>>>>>>>    End_Procedure
23578>>>>>>>>>>>>>>>>>    
23578>>>>>>>>>>>>>>>>>    Function PaneWidth Integer iPane Returns Integer
23580>>>>>>>>>>>>>>>>>        Function_Return (Message(Self,iPane))
23581>>>>>>>>>>>>>>>>>    End_Function
23582>>>>>>>>>>>>>>>>>    
23582>>>>>>>>>>>>>>>>>    Procedure Set PaneStyle Integer iPane Integer iStyle
23584>>>>>>>>>>>>>>>>>        Set Aux_Value iPane to iStyle
23585>>>>>>>>>>>>>>>>>    End_Procedure
23586>>>>>>>>>>>>>>>>>    
23586>>>>>>>>>>>>>>>>>    Function PaneStyle Integer iPane Returns Integer
23588>>>>>>>>>>>>>>>>>        Function_Return (Aux_Value(Self,iPane))
23589>>>>>>>>>>>>>>>>>    End_Function
23590>>>>>>>>>>>>>>>>>    
23590>>>>>>>>>>>>>>>>>    Procedure Set PaneText Integer iPane String sText
23592>>>>>>>>>>>>>>>>>        Set Value iPane to sText
23593>>>>>>>>>>>>>>>>>    End_Procedure
23594>>>>>>>>>>>>>>>>>    
23594>>>>>>>>>>>>>>>>>    Function PaneText Integer iPane Returns String
23596>>>>>>>>>>>>>>>>>        Function_Return (Value(Self,iPane))
23597>>>>>>>>>>>>>>>>>    End_Function
23598>>>>>>>>>>>>>>>>>    
23598>>>>>>>>>>>>>>>>>    Function PaneCount Returns Integer
23600>>>>>>>>>>>>>>>>>        Function_Return (Item_Count(Self))
23601>>>>>>>>>>>>>>>>>    End_Function
23602>>>>>>>>>>>>>>>>>    
23602>>>>>>>>>>>>>>>>>    Procedure OnClick Longptr iPane
23604>>>>>>>>>>>>>>>>>    End_Procedure
23605>>>>>>>>>>>>>>>>>    
23605>>>>>>>>>>>>>>>>>    Procedure OnDoubleClick Longptr iPane
23607>>>>>>>>>>>>>>>>>    End_Procedure
23608>>>>>>>>>>>>>>>>>    
23608>>>>>>>>>>>>>>>>>    Procedure OnRightClick Longptr iPane
23610>>>>>>>>>>>>>>>>>    End_Procedure
23611>>>>>>>>>>>>>>>>>    
23611>>>>>>>>>>>>>>>>>    Procedure OnDoubleRightClick Longptr iPane
23613>>>>>>>>>>>>>>>>>    End_Procedure
23614>>>>>>>>>>>>>>>>>    
23614>>>>>>>>>>>>>>>>>    Procedure OnSimpleModeChange
23616>>>>>>>>>>>>>>>>>    End_Procedure
23617>>>>>>>>>>>>>>>>>End_Class
23618>>>>>>>>>>>>>>>>>
23618>>>>>>>>>>>>>>>
23618>>>>>>>>>>>>>>>Class AppStatusBar is a BasicStatusBar
23619>>>>>>>>>>>>>>>    
23619>>>>>>>>>>>>>>>    Procedure Construct_Object
23621>>>>>>>>>>>>>>>        Forward Send Construct_Object
23623>>>>>>>>>>>>>>>        Property Integer Status_Help_Item 0
23624>>>>>>>>>>>>>>>        Property Integer Menu_Simple_State TRUE
23625>>>>>>>>>>>>>>>        
23625>>>>>>>>>>>>>>>        // SET s/b private, Get is public
23625>>>>>>>>>>>>>>>        Property Integer Menu_status_State False // MUST start false
23626>>>>>>>>>>>>>>>        
23626>>>>>>>>>>>>>>>        Property Integer Old_Simple_State  false
23627>>>>>>>>>>>>>>>        
23627>>>>>>>>>>>>>>>        Property String  Old_Status_Value  ''
23628>>>>>>>>>>>>>>>        
23628>>>>>>>>>>>>>>>        Set Popup_State         To TRUE
23629>>>>>>>>>>>>>>>        Set Attach_Parent_State To TRUE
23630>>>>>>>>>>>>>>>        // register status-bar with container
23630>>>>>>>>>>>>>>>        Delegate Set StatusBar_id To self
23632>>>>>>>>>>>>>>>    End_Procedure
23633>>>>>>>>>>>>>>>    
23633>>>>>>>>>>>>>>>    Procedure Set Status_Help_Value String sHelp
23635>>>>>>>>>>>>>>>        Integer iPart
23635>>>>>>>>>>>>>>>        Get Status_Help_Item To iPart
23636>>>>>>>>>>>>>>>        Set Value iPart to sHelp
23637>>>>>>>>>>>>>>>    End_Procedure
23638>>>>>>>>>>>>>>>    
23638>>>>>>>>>>>>>>>    Function Status_Help_Value Returns String
23640>>>>>>>>>>>>>>>        Integer iPart
23640>>>>>>>>>>>>>>>        String sHelp
23640>>>>>>>>>>>>>>>        Get Status_Help_Item To iPart
23641>>>>>>>>>>>>>>>        Get Value iPart To sHelp
23642>>>>>>>>>>>>>>>        Function_Return sHelp
23643>>>>>>>>>>>>>>>    End_Procedure
23644>>>>>>>>>>>>>>>    
23644>>>>>>>>>>>>>>>    Procedure Initialize_Menu
23646>>>>>>>>>>>>>>>        Integer iState OldState
23646>>>>>>>>>>>>>>>        If Not (Menu_Status_state(self)) Begin
23648>>>>>>>>>>>>>>>            Get Simple_State to OldState
23649>>>>>>>>>>>>>>>            Set Old_Simple_State to OldState
23650>>>>>>>>>>>>>>>            If OldState ;                Set Old_Status_Value to (Simple_Value(self))
23653>>>>>>>>>>>>>>>            Else ;                Set Old_Status_Value to (Status_Help_Value(self))
23655>>>>>>>>>>>>>>>            Set Simple_State to (Menu_Simple_State(self))
23656>>>>>>>>>>>>>>>            Set Menu_Status_State to TRUE
23657>>>>>>>>>>>>>>>        End
23657>>>>>>>>>>>>>>>>
23657>>>>>>>>>>>>>>>    End_Procedure
23658>>>>>>>>>>>>>>>    
23658>>>>>>>>>>>>>>>    Procedure Exit_Menu
23660>>>>>>>>>>>>>>>        Integer OldState
23660>>>>>>>>>>>>>>>        String OldVal
23660>>>>>>>>>>>>>>>        If (Menu_Status_state(self)) Begin
23662>>>>>>>>>>>>>>>            Get Old_Simple_State to OldState
23663>>>>>>>>>>>>>>>            Set Simple_State     to OldState
23664>>>>>>>>>>>>>>>            Get old_status_Value to oldVal
23665>>>>>>>>>>>>>>>            If OldState ;                Set Simple_Value to OldVal
23668>>>>>>>>>>>>>>>            Else ;                Set Status_Help_Value to OldVal
23670>>>>>>>>>>>>>>>            Set Menu_Status_State to FALSE
23671>>>>>>>>>>>>>>>        End
23671>>>>>>>>>>>>>>>>
23671>>>>>>>>>>>>>>>    End_Procedure
23672>>>>>>>>>>>>>>>    
23672>>>>>>>>>>>>>>>    Procedure Show_Status_Help String sHelp
23674>>>>>>>>>>>>>>>        Integer iState
23674>>>>>>>>>>>>>>>        Get Simple_State to iState
23675>>>>>>>>>>>>>>>        If not iState ;            Set Status_Help_Value to sHelp
23678>>>>>>>>>>>>>>>        Else ;            Set Simple_Value      to sHelp
23680>>>>>>>>>>>>>>>    End_Procedure
23681>>>>>>>>>>>>>>>    
23681>>>>>>>>>>>>>>>    Function Current_Status_Help Returns String
23683>>>>>>>>>>>>>>>        Integer iState
23683>>>>>>>>>>>>>>>        String sHelp
23683>>>>>>>>>>>>>>>        Get Simple_State to iState
23684>>>>>>>>>>>>>>>        If not iState ;            Get Status_Help_Value to sHelp
23687>>>>>>>>>>>>>>>        Else ;            Get Simple_Value      to sHelp
23689>>>>>>>>>>>>>>>        Function_Return sHelp
23690>>>>>>>>>>>>>>>    End_Function
23691>>>>>>>>>>>>>>>    
23691>>>>>>>>>>>>>>>    Procedure Page_Object Integer bShow
23693>>>>>>>>>>>>>>>        Integer hoClient
23693>>>>>>>>>>>>>>>        Handle hHndl
23693>>>>>>>>>>>>>>>        Get Window_Handle to hHndl
23694>>>>>>>>>>>>>>>        Forward Send Page_Object bShow
23696>>>>>>>>>>>>>>>        If (bShow AND hHndl=0) Begin
23698>>>>>>>>>>>>>>>            Delegate Get Client_Id To hoClient
23700>>>>>>>>>>>>>>>            If hoClient ;                Send Add_Border_Object to hoClient self amBOTTOM
23703>>>>>>>>>>>>>>>        End
23703>>>>>>>>>>>>>>>>
23703>>>>>>>>>>>>>>>    End_Procedure
23704>>>>>>>>>>>>>>>    
23704>>>>>>>>>>>>>>>    Procedure Deactivating
23706>>>>>>>>>>>>>>>        Integer hoClient
23706>>>>>>>>>>>>>>>        Delegate Get Client_Id To hoClient
23708>>>>>>>>>>>>>>>        Forward Send DeActivating
23710>>>>>>>>>>>>>>>        If hoClient ;            Send Remove_Border_Object to hoClient self amBOTTOM
23713>>>>>>>>>>>>>>>    End_Procedure
23714>>>>>>>>>>>>>>>    
23714>>>>>>>>>>>>>>>End_Class
23715>>>>>>>>>>>>>Use DFABtBar.pkg  // df application button bar
Including file: Dfabtbar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfabtbar.pkg)
23715>>>>>>>>>>>>>>>Register_Procedure Add_Border_Object
23715>>>>>>>>>>>>>>>Register_Procedure Remove_Border_Object
23715>>>>>>>>>>>>>>>
23715>>>>>>>>>>>>>>>Use Windows.pkg
23715>>>>>>>>>>>>>>>
23715>>>>>>>>>>>>>>>Class AppToolBar is a BasicToolBar
23716>>>>>>>>>>>>>>>    
23716>>>>>>>>>>>>>>>    Procedure Construct_Object
23718>>>>>>>>>>>>>>>        Forward Send Construct_Object
23720>>>>>>>>>>>>>>>        Set Scope_State         to True
23721>>>>>>>>>>>>>>>        Set Attach_Parent_State to True
23722>>>>>>>>>>>>>>>        Set Popup_State         to True
23723>>>>>>>>>>>>>>>        Set Client_Area_State   to True
23724>>>>>>>>>>>>>>>        Delegate Set ToolBar_Id to Self
23726>>>>>>>>>>>>>>>    End_Procedure
23727>>>>>>>>>>>>>>>    
23727>>>>>>>>>>>>>>>    Procedure Page Integer bState
23729>>>>>>>>>>>>>>>        Integer hoClient
23729>>>>>>>>>>>>>>>        Handle  hWnd
23729>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23730>>>>>>>>>>>>>>>        Forward Send Page bState
23732>>>>>>>>>>>>>>>        If (bState=1 and hWnd=0) Begin
23734>>>>>>>>>>>>>>>            Delegate Get Client_Id to hoClient
23736>>>>>>>>>>>>>>>            If hoClient ;                Send Add_Border_Object to hoClient Self amTOP
23739>>>>>>>>>>>>>>>        End
23739>>>>>>>>>>>>>>>>
23739>>>>>>>>>>>>>>>    End_Procedure
23740>>>>>>>>>>>>>>>    
23740>>>>>>>>>>>>>>>    Procedure Deactivating
23742>>>>>>>>>>>>>>>        Integer hoClient
23742>>>>>>>>>>>>>>>        Forward Send DeActivating
23744>>>>>>>>>>>>>>>        Delegate Get Client_Id to hoClient
23746>>>>>>>>>>>>>>>        If hoClient Begin
23748>>>>>>>>>>>>>>>            Send Remove_Border_Object to hoClient Self amTOP
23749>>>>>>>>>>>>>>>        End
23749>>>>>>>>>>>>>>>>
23749>>>>>>>>>>>>>>>    End_Procedure
23750>>>>>>>>>>>>>>>    
23750>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
23752>>>>>>>>>>>>>>>        Forward Set GuiSize to cy cx
23754>>>>>>>>>>>>>>>    End_Procedure
23755>>>>>>>>>>>>>>>    
23755>>>>>>>>>>>>>>>    // Container_Handle:
23755>>>>>>>>>>>>>>>    // JvH: - This function was put in to allow support for combo-form & other
23755>>>>>>>>>>>>>>>    // controls in the toolbar.
23755>>>>>>>>>>>>>>>    Function Container_Handle Returns Handle
23757>>>>>>>>>>>>>>>        Function_Return (window_handle(Self))
23758>>>>>>>>>>>>>>>    End_Function
23759>>>>>>>>>>>>>>>End_Class
23760>>>>>>>>>>>>>>>
23760>>>>>>>>>>>>>Use DFAClnt.pkg   // df application Client
Including file: Dfaclnt.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfaclnt.pkg)
23760>>>>>>>>>>>>>>>Use Windows.pkg
23760>>>>>>>>>>>>>>>Use Set.pkg
Including file: set.pkg    (C:\Program Files\DataFlex 20.1\Pkg\set.pkg)
23760>>>>>>>>>>>>>>>>>Use VDFBase.pkg
23760>>>>>>>>>>>>>>>>>
23760>>>>>>>>>>>>>>>>>Class Set is an ARRAY
23761>>>>>>>>>>>>>>>>>    
23761>>>>>>>>>>>>>>>>>    Function Find_Element String ElemStr Returns Integer
23763>>>>>>>>>>>>>>>>>        Integer ndx retVal ArrMax
23763>>>>>>>>>>>>>>>>>        String ArrVal
23763>>>>>>>>>>>>>>>>>        Get item_count to ArrMax
23764>>>>>>>>>>>>>>>>>        Move -1 to retVal
23765>>>>>>>>>>>>>>>>>        Move 0 to ndx
23766>>>>>>>>>>>>>>>>>        While (ndx < ArrMax and retVal = -1)
23770>>>>>>>>>>>>>>>>>            Get array_value  ndx to ArrVal
23771>>>>>>>>>>>>>>>>>            If (ArrVal = ElemStr) ;                Move ndx to retVal
23774>>>>>>>>>>>>>>>>>            Move (ndx + 1) to ndx
23775>>>>>>>>>>>>>>>>>        loop
23776>>>>>>>>>>>>>>>>>>
23776>>>>>>>>>>>>>>>>>        Function_Return retVal
23777>>>>>>>>>>>>>>>>>    End_Function
23778>>>>>>>>>>>>>>>>>    
23778>>>>>>>>>>>>>>>>>    Procedure Add_Element String Elem_Str Returns Integer
23780>>>>>>>>>>>>>>>>>        Integer Ret_Val
23780>>>>>>>>>>>>>>>>>        
23780>>>>>>>>>>>>>>>>>        Get Find_Element Elem_Str to Ret_Val
23781>>>>>>>>>>>>>>>>>        
23781>>>>>>>>>>>>>>>>>        If (Ret_Val < 0) ;            Get Item_Count to Ret_Val
23784>>>>>>>>>>>>>>>>>        
23784>>>>>>>>>>>>>>>>>        Set Array_Value  Ret_Val to Elem_Str
23785>>>>>>>>>>>>>>>>>        
23785>>>>>>>>>>>>>>>>>        Procedure_Return Ret_Val
23786>>>>>>>>>>>>>>>>>    End_Procedure
23787>>>>>>>>>>>>>>>>>    
23787>>>>>>>>>>>>>>>>>    Procedure Remove_Element String sElement
23789>>>>>>>>>>>>>>>>>        Integer iIndex
23789>>>>>>>>>>>>>>>>>        Get Find_Element sElement to iIndex
23790>>>>>>>>>>>>>>>>>        If (iIndex > -1) ;            Send delete_item iIndex
23793>>>>>>>>>>>>>>>>>    End_Procedure
23794>>>>>>>>>>>>>>>>>    
23794>>>>>>>>>>>>>>>>>    
23794>>>>>>>>>>>>>>>>>End_Class
23795>>>>>>>>>>>>>>>>>
23795>>>>>>>>>>>>>>>>>//
23795>>>>>>>>>>>>>>>>>// global function to create set instances at random
23795>>>>>>>>>>>>>>>>>//
23795>>>>>>>>>>>>>>>>>Function make_set for cDesktop Returns Integer
23797>>>>>>>>>>>>>>>>>    Integer retval
23797>>>>>>>>>>>>>>>>>    Object SetTemplate is a Set
23799>>>>>>>>>>>>>>>>>        Move Self to retval
23800>>>>>>>>>>>>>>>>>    End_Object
23801>>>>>>>>>>>>>>>>>    Function_Return retval
23802>>>>>>>>>>>>>>>>>End_Function
23803>>>>>>>>>>>>>>>>>
23803>>>>>>>>>>>>>>>>>
23803>>>>>>>>>>>>>>>>>
23803>>>>>>>>>>>>>>>
23803>>>>>>>>>>>>>>>Class AppClientArea is a MdiClientArea
23804>>>>>>>>>>>>>>>    
23804>>>>>>>>>>>>>>>    Procedure Construct_Object
23806>>>>>>>>>>>>>>>        Forward Send Construct_Object
23808>>>>>>>>>>>>>>>        
23808>>>>>>>>>>>>>>>        Property Integer Auto_Arrange_Icons_State True
23809>>>>>>>>>>>>>>>        
23809>>>>>>>>>>>>>>>        Property Integer Private.Client_Scrollbar_State   True
23810>>>>>>>>>>>>>>>        
23810>>>>>>>>>>>>>>>        Delegate Set Client_Id to Self
23812>>>>>>>>>>>>>>>        // keep track of all child dialog objects (views)
23812>>>>>>>>>>>>>>>        
23812>>>>>>>>>>>>>>>        Object Mdi_Dialogs is a Set
23814>>>>>>>>>>>>>>>        End_Object
23815>>>>>>>>>>>>>>>        
23815>>>>>>>>>>>>>>>        Property Integer Private.Last_Dialog_Item -1
23816>>>>>>>>>>>>>>>    End_Procedure
23817>>>>>>>>>>>>>>>    
23817>>>>>>>>>>>>>>>    Procedure Set Client_Scrollbar_State Integer bState
23819>>>>>>>>>>>>>>>        Set Scroll_bar_Visible_State to bState
23820>>>>>>>>>>>>>>>        Set Private.Client_Scrollbar_State to bState
23821>>>>>>>>>>>>>>>    End_Procedure
23822>>>>>>>>>>>>>>>    
23822>>>>>>>>>>>>>>>    Function Client_Scrollbar_State Returns Integer
23824>>>>>>>>>>>>>>>        Function_Return (Private.Client_Scrollbar_State(Self))
23825>>>>>>>>>>>>>>>    End_Function
23826>>>>>>>>>>>>>>>    
23826>>>>>>>>>>>>>>>    Procedure Add_Mdi_Dialog Integer Id#
23828>>>>>>>>>>>>>>>        Send Add_element to (mdi_dialogs(Self)) Id#
23829>>>>>>>>>>>>>>>    End_Procedure
23830>>>>>>>>>>>>>>>    
23830>>>>>>>>>>>>>>>    Procedure Remove_Mdi_Dialog Integer Id#
23832>>>>>>>>>>>>>>>        Integer obj#
23832>>>>>>>>>>>>>>>        Move (mdi_dialogs(Self)) to Obj#
23833>>>>>>>>>>>>>>>        If Obj# ;            Send Remove_element to (mdi_dialogs(Obj#)) Id#
23836>>>>>>>>>>>>>>>    End_Procedure
23837>>>>>>>>>>>>>>>    
23837>>>>>>>>>>>>>>>    Function Next_Mdi_Dialog Integer FindFirst Returns Integer
23839>>>>>>>>>>>>>>>        Integer Id# Item# Obj#
23839>>>>>>>>>>>>>>>        Get Private.Last_dialog_item to Item#
23840>>>>>>>>>>>>>>>        If FindFirst ;            Move -1 to Item#
23843>>>>>>>>>>>>>>>        Increment Item#
23844>>>>>>>>>>>>>>>        Set Private.Last_dialog_item to Item#
23845>>>>>>>>>>>>>>>        Move (Mdi_dialogs(Self)) to Obj#
23846>>>>>>>>>>>>>>>        If (Item_count(Obj#)>Item#) ;            Get Value of Obj# Item# to Id#
23849>>>>>>>>>>>>>>>        Function_Return Id#
23850>>>>>>>>>>>>>>>    End_Function
23851>>>>>>>>>>>>>>>    
23851>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
23853>>>>>>>>>>>>>>>        Forward Set GuiSize to cy cx
23855>>>>>>>>>>>>>>>        If (active_state(Self) and Auto_Arrange_Icons_State(Self)) ;            Send Arrange_icons
23858>>>>>>>>>>>>>>>    End_Procedure
23859>>>>>>>>>>>>>>>    
23859>>>>>>>>>>>>>>>    Procedure Private.Adjust_MDI_Margins Integer cy Integer cx Integer BorderFlag
23861>>>>>>>>>>>>>>>        Integer cMargin
23861>>>>>>>>>>>>>>>        If (BorderFlag = amTOP) Begin
23863>>>>>>>>>>>>>>>            Get mdi_top_margin to cMargin
23864>>>>>>>>>>>>>>>            Set mdi_top_margin to (cMargin + cy)
23865>>>>>>>>>>>>>>>        End
23865>>>>>>>>>>>>>>>>
23865>>>>>>>>>>>>>>>        Else If (BorderFlag = amBOTTOM) Begin
23868>>>>>>>>>>>>>>>            Get mdi_bottom_margin to cMargin
23869>>>>>>>>>>>>>>>            Set mdi_bottom_margin to (cMargin + cy)
23870>>>>>>>>>>>>>>>        End
23870>>>>>>>>>>>>>>>>
23870>>>>>>>>>>>>>>>        Else If (BorderFlag = amLEFT) Begin
23873>>>>>>>>>>>>>>>            Get mdi_left_margin to cMargin
23874>>>>>>>>>>>>>>>            Set mdi_left_margin to (cMargin + cx)
23875>>>>>>>>>>>>>>>        End
23875>>>>>>>>>>>>>>>>
23875>>>>>>>>>>>>>>>        Else If (BorderFlag = amRIGHT) Begin
23878>>>>>>>>>>>>>>>            Get mdi_right_margin to cMargin
23879>>>>>>>>>>>>>>>            Set mdi_right_margin to (cMargin + cx)
23880>>>>>>>>>>>>>>>        End
23880>>>>>>>>>>>>>>>>
23880>>>>>>>>>>>>>>>    End_Procedure
23881>>>>>>>>>>>>>>>    
23881>>>>>>>>>>>>>>>    Procedure Add_Border_Object Integer hoBorder Integer BorderFlag
23883>>>>>>>>>>>>>>>        Integer cy cx
23883>>>>>>>>>>>>>>>        Move (hi(GuiSize(hoBorder)))  to cy
23884>>>>>>>>>>>>>>>        Move (low(GuiSize(hoBorder))) to cx
23885>>>>>>>>>>>>>>>        
23885>>>>>>>>>>>>>>>        Send Private.Adjust_MDI_Margins cy cx BorderFlag
23886>>>>>>>>>>>>>>>    End_Procedure
23887>>>>>>>>>>>>>>>    
23887>>>>>>>>>>>>>>>    Procedure Remove_Border_Object Integer hoBorder Integer BorderFlag
23889>>>>>>>>>>>>>>>        Integer cy cx
23889>>>>>>>>>>>>>>>        Move (-(hi(GuiSize(hoBorder))))  to cy
23890>>>>>>>>>>>>>>>        Move (-(low(GuiSize(hoBorder)))) to cx
23891>>>>>>>>>>>>>>>        
23891>>>>>>>>>>>>>>>        Send Private.Adjust_MDI_Margins cy cx BorderFlag
23892>>>>>>>>>>>>>>>    End_Procedure
23893>>>>>>>>>>>>>>>    
23893>>>>>>>>>>>>>>>    //
23893>>>>>>>>>>>>>>>    // default behavior of mdi client is to passively pass these
23893>>>>>>>>>>>>>>>    // message on to their mdi dialogs (views)
23893>>>>>>>>>>>>>>>    //
23893>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
23895>>>>>>>>>>>>>>>        Integer rVal Id#
23895>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
23896>>>>>>>>>>>>>>>        While (Id# and Rval=0)
23900>>>>>>>>>>>>>>>            Get Verify_Exit_application of Id# to rVal
23901>>>>>>>>>>>>>>>            If not rval ;                Get Next_Mdi_Dialog False to Id#
23904>>>>>>>>>>>>>>>        End
23905>>>>>>>>>>>>>>>>
23905>>>>>>>>>>>>>>>        Function_Return rval
23906>>>>>>>>>>>>>>>    End_Function
23907>>>>>>>>>>>>>>>    
23907>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
23909>>>>>>>>>>>>>>>        Integer Id#
23909>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
23910>>>>>>>>>>>>>>>        While Id#
23914>>>>>>>>>>>>>>>            Send Notify_Exit_Application to Id#
23915>>>>>>>>>>>>>>>            Get Next_Mdi_Dialog False to Id#
23916>>>>>>>>>>>>>>>        End
23917>>>>>>>>>>>>>>>>
23917>>>>>>>>>>>>>>>    End_Procedure
23918>>>>>>>>>>>>>>>    
23918>>>>>>>>>>>>>>>    Procedure Make_all_ViewMode Integer Mode
23920>>>>>>>>>>>>>>>        Integer Id#
23920>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
23921>>>>>>>>>>>>>>>        While Id#
23925>>>>>>>>>>>>>>>            If (active_State(Id#)) ;                Set View_Mode of Id# to Mode
23928>>>>>>>>>>>>>>>            Get Next_Mdi_Dialog False to Id#
23929>>>>>>>>>>>>>>>        End
23930>>>>>>>>>>>>>>>>
23930>>>>>>>>>>>>>>>    End_Procedure
23931>>>>>>>>>>>>>>>    
23931>>>>>>>>>>>>>>>    Procedure Minimize_all_Windows
23933>>>>>>>>>>>>>>>        Send Make_All_ViewMode VIEWMODE_ICONIZE
23934>>>>>>>>>>>>>>>    End_Procedure
23935>>>>>>>>>>>>>>>    
23935>>>>>>>>>>>>>>>    Procedure Restore_all_Windows
23937>>>>>>>>>>>>>>>        Send Make_All_ViewMode VIEWMODE_NORMAL
23938>>>>>>>>>>>>>>>    End_Procedure
23939>>>>>>>>>>>>>>>    
23939>>>>>>>>>>>>>>>    // The framework has used activate_about for years to activate an about
23939>>>>>>>>>>>>>>>    // dialog. As of 12.1, we have a sub-class for this and providing the
23939>>>>>>>>>>>>>>>    // required message makes things work better. It is expected that a
23939>>>>>>>>>>>>>>>    // developer will augment this in their clientarea to call the about
23939>>>>>>>>>>>>>>>    // object that they created.
23939>>>>>>>>>>>>>>>    Procedure Activate_About
23941>>>>>>>>>>>>>>>    End_Procedure
23942>>>>>>>>>>>>>>>    
23942>>>>>>>>>>>>>>>    
23942>>>>>>>>>>>>>>>End_Class
23943>>>>>>>>>>>>>Use DFADlg.pkg    // df application Dialog
Including file: Dfadlg.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfadlg.pkg)
23943>>>>>>>>>>>>>>>Use LanguageText.pkg
23943>>>>>>>>>>>>>>>Use Windows.pkg
23943>>>>>>>>>>>>>>>Use dfConfrm.pkg
Including file: Dfconfrm.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfconfrm.pkg)
23943>>>>>>>>>>>>>>>>>Use LanguageText.pkg
23943>>>>>>>>>>>>>>>>>Use msgbox.pkg
23943>>>>>>>>>>>>>>>>>
23943>>>>>>>>>>>>>>>>>// General purpose confirm function. Added to all classes
23943>>>>>>>>>>>>>>>>>//
23943>>>>>>>>>>>>>>>>>Function Confirm for cUIObject String item_name Returns Integer
23945>>>>>>>>>>>>>>>>>    Integer rval
23945>>>>>>>>>>>>>>>>>    Move (YesNo_Box(item_name, C_$Confirm, MB_DEFBUTTON1 )) to rval
23946>>>>>>>>>>>>>>>>>    Function_Return (rval<>MBR_YES)
23947>>>>>>>>>>>>>>>>>End_function
23948>>>>>>>>>>>>>>>>>
23948>>>>>>>>>>>>>>>>>Function Save_Confirmation for cUIObject Returns integer
23950>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$SaveThisRecord))
23951>>>>>>>>>>>>>>>>>End_function
23952>>>>>>>>>>>>>>>>>
23952>>>>>>>>>>>>>>>>>Function Delete_Confirmation for cUIObject Returns integer
23954>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$DeleteThisRecord))
23955>>>>>>>>>>>>>>>>>End_function
23956>>>>>>>>>>>>>>>>>
23956>>>>>>>>>>>>>>>>>Function Line_Save_Confirmation for cUIObject Returns Integer
23958>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$SaveThisLine))
23959>>>>>>>>>>>>>>>>>End_function
23960>>>>>>>>>>>>>>>>>
23960>>>>>>>>>>>>>>>>>Function Line_Delete_Confirmation for cUIObject Returns Integer
23962>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$DeleteThisLine))
23963>>>>>>>>>>>>>>>>>End_function
23964>>>>>>>>>>>>>>>>>
23964>>>>>>>>>>>>>>>>>Function Data_Loss_Confirmation for cUIObject Returns integer
23966>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$AbandonChanges))
23967>>>>>>>>>>>>>>>>>End_function
23968>>>>>>>>>>>>>>>>>
23968>>>>>>>>>>>>>>>>>Function Exit_Loss_Confirmation for cUIObject Returns integer
23970>>>>>>>>>>>>>>>>>    Integer tmp
23970>>>>>>>>>>>>>>>>>    get Should_save_recursive to tmp
23971>>>>>>>>>>>>>>>>>    If (tmp <> 0) ;        Function_Return (confirm(Self, C_$ChangesExistAbandon))
23974>>>>>>>>>>>>>>>>>End_function
23975>>>>>>>>>>>>>>>>>
23975>>>>>>>>>>>>>>>>>Function No_Confirmation for cUIObject Returns integer
23977>>>>>>>>>>>>>>>>>End_function
23978>>>>>>>>>>>>>>>>>
23978>>>>>>>>>>>>>>>>>Function Should_Save for cUIObject returns integer
23980>>>>>>>>>>>>>>>>>end_function
23981>>>>>>>>>>>>>>>>>
23981>>>>>>>>>>>>>>>>>Function Should_Save_Recursive for cUIObject returns integer
23983>>>>>>>>>>>>>>>>>    Integer rVal
23983>>>>>>>>>>>>>>>>>    Get Should_Save to Rval // changes in this object???
23984>>>>>>>>>>>>>>>>>    If (rVal = 0) ;        Broadcast Get Should_Save_Recursive to Rval // check w/ kids
23988>>>>>>>>>>>>>>>>>    Function_return rVal
23989>>>>>>>>>>>>>>>>>End_Function
23990>>>>>>>>>>>>>>>>>
23990>>>>>>>>>>>>>>>>>
23990>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
23990>>>>>>>>>>>>>>>Use tWinStructs.pkg
23990>>>>>>>>>>>>>>>
23990>>>>>>>>>>>>>>>
23990>>>>>>>>>>>>>>>// as of 15.0, moved some of dbViews features up to this level. Load/Save Environment showing view name
23990>>>>>>>>>>>>>>>Class AppDialog is a MdiDialog
23991>>>>>>>>>>>>>>>    
23991>>>>>>>>>>>>>>>    Procedure Construct_Object
23993>>>>>>>>>>>>>>>        Forward Send Construct_Object
23995>>>>>>>>>>>>>>>        
23995>>>>>>>>>>>>>>>        // This can be used to stop this view from loading and saving its environment.
23995>>>>>>>>>>>>>>>        Property Boolean pbDisableSaveEnvironment False
23996>>>>>>>>>>>>>>>        
23996>>>>>>>>>>>>>>>        // set true to auto-activate the view. This does not work if the object is deferred.
23996>>>>>>>>>>>>>>>        // this is a design time property which is applied during end_construct_object. This should
23996>>>>>>>>>>>>>>>        Property Boolean pbAutoActivate False
23997>>>>>>>>>>>>>>>        
23997>>>>>>>>>>>>>>>        // used to keep track of window placment when deactivated object is reactivated.
23997>>>>>>>>>>>>>>>        Property tWinWindowPlacement pWindowPlacement
23998>>>>>>>>>>>>>>>    End_Procedure
23999>>>>>>>>>>>>>>>    
23999>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24001>>>>>>>>>>>>>>>        Boolean bAutoActivate
24001>>>>>>>>>>>>>>>        Delegate Send Add_Mdi_Dialog Self
24003>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
24005>>>>>>>>>>>>>>>        // if auto-activate, add this to he the panel's array of objects to be acivated.
24005>>>>>>>>>>>>>>>        Get pbAutoActivate to bAutoActivate
24006>>>>>>>>>>>>>>>        If bAutoActivate Begin
24008>>>>>>>>>>>>>>>            Delegate Send AddAutoActivateView Self
24010>>>>>>>>>>>>>>>        End
24010>>>>>>>>>>>>>>>>
24010>>>>>>>>>>>>>>>    End_Procedure
24011>>>>>>>>>>>>>>>    
24011>>>>>>>>>>>>>>>    Procedure Destroy_Object
24013>>>>>>>>>>>>>>>        Integer obj
24013>>>>>>>>>>>>>>>        Move Self to obj
24014>>>>>>>>>>>>>>>        Delegate Send Remove_Mdi_Dialog obj
24016>>>>>>>>>>>>>>>        Forward Send Destroy_Object
24018>>>>>>>>>>>>>>>    End_Procedure
24019>>>>>>>>>>>>>>>    
24019>>>>>>>>>>>>>>>    // Augmented to save view position
24019>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24021>>>>>>>>>>>>>>>        Send Save_Environment
24022>>>>>>>>>>>>>>>    End_Procedure
24023>>>>>>>>>>>>>>>    
24023>>>>>>>>>>>>>>>    Function View_Changed Returns Integer
24025>>>>>>>>>>>>>>>    End_Function
24026>>>>>>>>>>>>>>>    
24026>>>>>>>>>>>>>>>    //
24026>>>>>>>>>>>>>>>    // Augment exit_application_check to see if view is changed. If changed,
24026>>>>>>>>>>>>>>>    // display exit message as required
24026>>>>>>>>>>>>>>>    
24026>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24028>>>>>>>>>>>>>>>        Integer Fail
24028>>>>>>>>>>>>>>>        Get View_Changed to Fail // Ask for changes in Data-sets
24029>>>>>>>>>>>>>>>        If fail ; // ok a change exist...activate changed view.            Get confirm (SFormat(C_$ChangesExistExit, Label(Self)) ) to fail
24032>>>>>>>>>>>>>>>        Function_Return fail
24033>>>>>>>>>>>>>>>    End_Function
24034>>>>>>>>>>>>>>>    
24034>>>>>>>>>>>>>>>    // Activates the view. If view is minimized it restores it first
24034>>>>>>>>>>>>>>>    // works with both popup_state T and F
24034>>>>>>>>>>>>>>>    
24034>>>>>>>>>>>>>>>    Procedure Activate_View Returns Integer
24036>>>>>>>>>>>>>>>        Integer rVal
24036>>>>>>>>>>>>>>>        If ( View_mode(Self)=VIEWMODE_ICONIZE ) ;            Set view_mode to viewmode_normal
24039>>>>>>>>>>>>>>>        If (Popup_state(Self)) ;    // support both popup and            Get Msg_Popup to rVal
24042>>>>>>>>>>>>>>>        Else ;            Get Msg_Activate to rVal
24044>>>>>>>>>>>>>>>        Procedure_Return rVal
24045>>>>>>>>>>>>>>>    End_Procedure
24046>>>>>>>>>>>>>>>    
24046>>>>>>>>>>>>>>>    
24046>>>>>>>>>>>>>>>    // augmented to load last view position
24046>>>>>>>>>>>>>>>    
24046>>>>>>>>>>>>>>>    Procedure Add_Focus Integer hoBase Returns Integer
24048>>>>>>>>>>>>>>>        Integer iRetVal bState
24048>>>>>>>>>>>>>>>        Get Visible_State to bState
24049>>>>>>>>>>>>>>>        Set Visible_State to False
24050>>>>>>>>>>>>>>>        Forward Get Msg_Add_Focus hoBase to iRetVal
24052>>>>>>>>>>>>>>>        If (iRetVal=0) Begin
24054>>>>>>>>>>>>>>>            Send Load_Environment
24055>>>>>>>>>>>>>>>        End
24055>>>>>>>>>>>>>>>>
24055>>>>>>>>>>>>>>>        Set Visible_State to bState
24056>>>>>>>>>>>>>>>        Procedure_Return iRetVal
24057>>>>>>>>>>>>>>>    End_Procedure
24058>>>>>>>>>>>>>>>    
24058>>>>>>>>>>>>>>>    // This is augmented to send save_environment during a view close (was in close_panel)
24058>>>>>>>>>>>>>>>    // we set view_mode to normal if it is zoomed. This is needed to make the MDI stuff work
24058>>>>>>>>>>>>>>>    // properly with the save/load environment. The Saved environment data will make it zoom if needed.
24058>>>>>>>>>>>>>>>    //
24058>>>>>>>>>>>>>>>    Procedure Deactivate Integer eDeactivateScope Returns Integer
24060>>>>>>>>>>>>>>>        Integer eArea iFail
24060>>>>>>>>>>>>>>>        Boolean bPreserveEnvironment
24060>>>>>>>>>>>>>>>        Move (If(num_arguments=0, Area_Type, eDeactivateScope)) to eArea // in case no param is passed
24061>>>>>>>>>>>>>>>        If (eArea<>0) Begin
24063>>>>>>>>>>>>>>>            Forward Get msg_deactivate eArea to iFail
24065>>>>>>>>>>>>>>>        End
24065>>>>>>>>>>>>>>>>
24065>>>>>>>>>>>>>>>        Else Begin
24066>>>>>>>>>>>>>>>            Send Save_Environment
24067>>>>>>>>>>>>>>>            Forward Get msg_deactivate eArea to iFail
24069>>>>>>>>>>>>>>>            
24069>>>>>>>>>>>>>>>            // this works around a problem where maximized MDI views get saved but don't come back
24069>>>>>>>>>>>>>>>            // correctly when loaded again without exiting. It turns out the the MDI client restores
24069>>>>>>>>>>>>>>>            // the view sometimes without telling view_mode. If view_mode is normal, it always works.
24069>>>>>>>>>>>>>>>            // This must happen after the view is deactivated!
24069>>>>>>>>>>>>>>>            
24069>>>>>>>>>>>>>>>            If ghoApplication Begin
24071>>>>>>>>>>>>>>>                Get pbPreserveEnvironment of ghoApplication to bPreserveEnvironment
24072>>>>>>>>>>>>>>>            End
24072>>>>>>>>>>>>>>>>
24072>>>>>>>>>>>>>>>            // do these checks to have as small of an effect as possible.
24072>>>>>>>>>>>>>>>            If (bPreserveEnvironment and iFail=0 and view_mode(Self)=Viewmode_Zoom) Begin
24074>>>>>>>>>>>>>>>                Set View_Mode to Viewmode_Normal
24075>>>>>>>>>>>>>>>            End
24075>>>>>>>>>>>>>>>>
24075>>>>>>>>>>>>>>>        End
24075>>>>>>>>>>>>>>>>
24075>>>>>>>>>>>>>>>        Procedure_Return iFail
24076>>>>>>>>>>>>>>>    End_Procedure
24077>>>>>>>>>>>>>>>    
24077>>>>>>>>>>>>>>>    // Save the window placement information for this to the application object
24077>>>>>>>>>>>>>>>    
24077>>>>>>>>>>>>>>>    Procedure Save_Environment
24079>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24079>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24079>>>>>>>>>>>>>>>        Boolean bSuccess bCancel
24079>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to bCancel
24080>>>>>>>>>>>>>>>        If not bCancel Begin
24082>>>>>>>>>>>>>>>            
24082>>>>>>>>>>>>>>>            // save environment to the object, in case it is reactivated during the same run.
24082>>>>>>>>>>>>>>>            Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
24083>>>>>>>>>>>>>>>            Move (GetWindowPlacement(Window_Handle(Self), addressof(WindowPlacement))) to bSuccess
24084>>>>>>>>>>>>>>>            If bSuccess Begin
24086>>>>>>>>>>>>>>>                // if minimized, assume restored, as we don't want to restart minimized!
24086>>>>>>>>>>>>>>>                If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
24088>>>>>>>>>>>>>>>                    Move SW_SHOWNORMAL to WindowPlacement.showCmd
24089>>>>>>>>>>>>>>>                End
24089>>>>>>>>>>>>>>>>
24089>>>>>>>>>>>>>>>                Set pWindowPlacement to WindowPlacement
24090>>>>>>>>>>>>>>>            End
24090>>>>>>>>>>>>>>>>
24090>>>>>>>>>>>>>>>            // also save environment to the application object, so it can be used when reloaded
24090>>>>>>>>>>>>>>>            If ghoApplication ;                Send DoSaveEnvironment of ghoApplication Self False
24093>>>>>>>>>>>>>>>        End
24093>>>>>>>>>>>>>>>>
24093>>>>>>>>>>>>>>>    End_Procedure
24094>>>>>>>>>>>>>>>    
24094>>>>>>>>>>>>>>>    // Load the window placement information for this from the application object
24094>>>>>>>>>>>>>>>    
24094>>>>>>>>>>>>>>>    Procedure Load_Environment
24096>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24096>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24096>>>>>>>>>>>>>>>        Boolean bSuccess bCancel
24096>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to bCancel
24097>>>>>>>>>>>>>>>        If not bCancel Begin
24099>>>>>>>>>>>>>>>            // if view has alrady been activated and deactivated use the setting from windowplacement saved in the object
24099>>>>>>>>>>>>>>>            Get pWindowPlacement to WindowPlacement
24100>>>>>>>>>>>>>>>            //  if length is zero, assume it has never been used before (never deactivated).
24100>>>>>>>>>>>>>>>            If (WindowPlacement.length>0) Begin
24102>>>>>>>>>>>>>>>                Move (SetWindowPlacement(Window_Handle(Self), AddressOf(WindowPlacement))) to bSuccess
24103>>>>>>>>>>>>>>>            End
24103>>>>>>>>>>>>>>>>
24103>>>>>>>>>>>>>>>            Else Begin
24104>>>>>>>>>>>>>>>                If ghoApplication ;                    Send DoLoadEnvironment of ghoApplication Self False
24107>>>>>>>>>>>>>>>            End
24107>>>>>>>>>>>>>>>>
24107>>>>>>>>>>>>>>>        End
24107>>>>>>>>>>>>>>>>
24107>>>>>>>>>>>>>>>    End_Procedure
24108>>>>>>>>>>>>>>>    
24108>>>>>>>>>>>>>>>    Procedure Entering_Scope Returns Integer
24110>>>>>>>>>>>>>>>        Integer rVal
24110>>>>>>>>>>>>>>>        Forward Get MSG_Entering_Scope to rVal
24112>>>>>>>>>>>>>>>        If not rVal ;            Send Show_View_Name (Label(Self))
24115>>>>>>>>>>>>>>>    End_Procedure
24116>>>>>>>>>>>>>>>    
24116>>>>>>>>>>>>>>>    Procedure Exiting_Scope Integer whereto Returns Integer
24118>>>>>>>>>>>>>>>        Integer rVal
24118>>>>>>>>>>>>>>>        Forward Get MSG_Exiting_Scope whereto to rVal
24120>>>>>>>>>>>>>>>        If not rVal ;            Send Show_View_Name ''
24123>>>>>>>>>>>>>>>    End_Procedure
24124>>>>>>>>>>>>>>>    
24124>>>>>>>>>>>>>>>    Procedure Show_view_Name String sHelp
24126>>>>>>>>>>>>>>>        Integer rVal Id
24126>>>>>>>>>>>>>>>        Get Statusbar_id to id
24127>>>>>>>>>>>>>>>        If Id ;            Send Show_View_Name to Id sHelp
24130>>>>>>>>>>>>>>>    End_Procedure
24131>>>>>>>>>>>>>>>    
24131>>>>>>>>>>>>>>>    // force object to be modal and then pop it up. Upon complettion restore it to a normal view
24131>>>>>>>>>>>>>>>    Procedure Popup_Modal Returns Integer
24133>>>>>>>>>>>>>>>        
24133>>>>>>>>>>>>>>>        Integer OldBMS OldAPS OldPS OldRS OldSS OldMDIState
24133>>>>>>>>>>>>>>>        Integer OldLoc OldAutoLoc OldKeyPath OldDisableSaveEnv OldMin OldMax
24133>>>>>>>>>>>>>>>        Integer rVal
24133>>>>>>>>>>>>>>>        
24133>>>>>>>>>>>>>>>        // If object is active we can't do anything. -1 means already active
24133>>>>>>>>>>>>>>>        If (Active_State(Self)) ;            Procedure_Return -1
24136>>>>>>>>>>>>>>>        
24136>>>>>>>>>>>>>>>        // Remember all important modal property settings.
24136>>>>>>>>>>>>>>>        Get Block_mouse_State to OldBMS
24137>>>>>>>>>>>>>>>        Get Attach_parent_State to OldAPS
24138>>>>>>>>>>>>>>>        Get Popup_State to OldPS
24139>>>>>>>>>>>>>>>        Get Ring_State to OldRS
24140>>>>>>>>>>>>>>>        Get Scope_State to OldSS
24141>>>>>>>>>>>>>>>        Get MDI_State to OldMDIState
24142>>>>>>>>>>>>>>>        Get Key_Path to OldKeyPath
24143>>>>>>>>>>>>>>>        Get Location to OldLoc
24144>>>>>>>>>>>>>>>        Get Maximize_Icon to OldMax
24145>>>>>>>>>>>>>>>        Get Minimize_Icon to OldMin
24146>>>>>>>>>>>>>>>        Get Auto_Locate_State to OldAutoLoc
24147>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to OldDisableSaveEnv
24148>>>>>>>>>>>>>>>        
24148>>>>>>>>>>>>>>>        // set propertie required to make this a modal dialog
24148>>>>>>>>>>>>>>>        Set pbDisableSaveEnvironment to True
24149>>>>>>>>>>>>>>>        Set MDI_State to False
24150>>>>>>>>>>>>>>>        Set Auto_Locate_State to True
24151>>>>>>>>>>>>>>>        Set Key_path to Desktop
24152>>>>>>>>>>>>>>>        Set Block_mouse_state to True
24153>>>>>>>>>>>>>>>        Set Attach_parent_state to False
24154>>>>>>>>>>>>>>>        // we used to set Exit_Application_Local_State to True - as of 19.1 we don't
24154>>>>>>>>>>>>>>>        Set Popup_State to True
24155>>>>>>>>>>>>>>>        Set Ring_State to True
24156>>>>>>>>>>>>>>>        Set Scope_State to True
24157>>>>>>>>>>>>>>>        Set Minimize_Icon to False
24158>>>>>>>>>>>>>>>        Set Maximize_Icon to False
24159>>>>>>>>>>>>>>>        
24159>>>>>>>>>>>>>>>        Get Msg_Popup to rVal
24160>>>>>>>>>>>>>>>        If rval ;            Move -2 to rVal      // did not activate
24163>>>>>>>>>>>>>>>        Else ;            Move StrMark to rVal // StrMark keeps track of UI value
24165>>>>>>>>>>>>>>>        // if 0- a stop_ui, if >0, ret value
24165>>>>>>>>>>>>>>>        // restore all expected properties
24165>>>>>>>>>>>>>>>        Set Auto_Locate_State to OldAutoLoc
24166>>>>>>>>>>>>>>>        Set Location to (hi(OldLoc)) (Low(OldLoc))
24167>>>>>>>>>>>>>>>        Set pbDisableSaveEnvironment to OldDisableSaveEnv
24168>>>>>>>>>>>>>>>        Set MDI_State to OldMDIState
24169>>>>>>>>>>>>>>>        Set Maximize_Icon to OldMax
24170>>>>>>>>>>>>>>>        Set Minimize_Icon to OldMin
24171>>>>>>>>>>>>>>>        Set Block_mouse_State   to OldBMS
24172>>>>>>>>>>>>>>>        Set Attach_parent_State to OldAPS
24173>>>>>>>>>>>>>>>        Set Popup_State         to OldPS
24174>>>>>>>>>>>>>>>        Set Ring_State          to OldRS
24175>>>>>>>>>>>>>>>        Set Scope_State         to OldSS
24176>>>>>>>>>>>>>>>        Procedure_Return rVal
24177>>>>>>>>>>>>>>>        
24177>>>>>>>>>>>>>>>    End_Procedure
24178>>>>>>>>>>>>>>>    
24178>>>>>>>>>>>>>>>End_Class
24179>>>>>>>>>>>>>>>
24179>>>>>>>>>>>>>>>// logically this is required
24179>>>>>>>>>>>>>>>//{ DesignerClass=cDTView }
24179>>>>>>>>>>>>>>>Class View is an AppDialog
24180>>>>>>>>>>>>>>>End_Class
24181>>>>>>>>>>>>>>>
24181>>>>>>>>>>>>>
24181>>>>>>>>>>>>>
24181>>>>>>>>>>>>>Register_Function pbPreserveEnvironment Returns Boolean
24181>>>>>>>>>>>>>Register_Procedure Set phoMainPanel Handle hoMain
24181>>>>>>>>>>>>>Register_Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
24181>>>>>>>>>>>>>Register_Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
24181>>>>>>>>>>>>>Register_Procedure Set pbVisible Boolean bVisible
24181>>>>>>>>>>>>>Register_Function  pbVisible Returns Boolean
24181>>>>>>>>>>>>>
24181>>>>>>>>>>>>>
24181>>>>>>>>>>>>>
24181>>>>>>>>>>>>>Class AppPanel is a BasicPanel
24182>>>>>>>>>>>>>    //
24182>>>>>>>>>>>>>    //  Panel defaults. Use windows MDI color
24182>>>>>>>>>>>>>    //
24182>>>>>>>>>>>>>    //
24182>>>>>>>>>>>>>    Procedure Construct_Object
24184>>>>>>>>>>>>>        Forward Send Construct_Object
24186>>>>>>>>>>>>>        
24186>>>>>>>>>>>>>        Property Integer Auto_Activate_State True
24187>>>>>>>>>>>>>        
24187>>>>>>>>>>>>>        // Support status for toolbar and status bar. For now we support
24187>>>>>>>>>>>>>        // 0=Hide, 1=Show,
24187>>>>>>>>>>>>>        //
24187>>>>>>>>>>>>>        Property Integer Private.ToolBar_State  1
24188>>>>>>>>>>>>>        
24188>>>>>>>>>>>>>        Property Integer Private.StatusBar_State  1
24189>>>>>>>>>>>>>        
24189>>>>>>>>>>>>>        Property Handle[] phoAutoActivateViews
24190>>>>>>>>>>>>>        
24190>>>>>>>>>>>>>        Set Scope_State to True
24191>>>>>>>>>>>>>        Set Mdi_State to True
24192>>>>>>>>>>>>>        
24192>>>>>>>>>>>>>        Set Size to 274 479
24193>>>>>>>>>>>>>        Set pbSizeToClientArea  to False
24194>>>>>>>>>>>>>    End_Procedure
24195>>>>>>>>>>>>>    
24195>>>>>>>>>>>>>    Procedure Set Auto_Arrange_Icons_State Integer bState
24197>>>>>>>>>>>>>        Integer hoClient
24197>>>>>>>>>>>>>        Get Client_id to hoClient
24198>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Set Auto_Arrange_Icons_State of hoClient to bState
24201>>>>>>>>>>>>>    End_Procedure
24202>>>>>>>>>>>>>    
24202>>>>>>>>>>>>>    Function Auto_Arrange_Icons_State Returns Integer
24204>>>>>>>>>>>>>        Integer hoClient bState
24204>>>>>>>>>>>>>        Get Client_id to hoClient
24205>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Get Auto_Arrange_Icons_State of hoClient to bState
24208>>>>>>>>>>>>>        Function_Return bState
24209>>>>>>>>>>>>>    End_Function
24210>>>>>>>>>>>>>    
24210>>>>>>>>>>>>>    Procedure Toggle_Auto_Arrange_Icons
24212>>>>>>>>>>>>>        Set Auto_Arrange_Icons_State ;            to (not(Auto_Arrange_Icons_State(Self)))
24213>>>>>>>>>>>>>    End_Procedure
24214>>>>>>>>>>>>>    
24214>>>>>>>>>>>>>    Procedure Set Client_Scrollbar_State Integer bState
24216>>>>>>>>>>>>>        Integer hoClient
24216>>>>>>>>>>>>>        Get Client_id to hoClient
24217>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Set Client_Scrollbar_State of hoClient to bState
24220>>>>>>>>>>>>>    End_Procedure
24221>>>>>>>>>>>>>    
24221>>>>>>>>>>>>>    Function Client_Scrollbar_State Returns Integer
24223>>>>>>>>>>>>>        Integer hoClient bState
24223>>>>>>>>>>>>>        Get Client_id to hoClient
24224>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Get Client_Scrollbar_State of hoClient to bState
24227>>>>>>>>>>>>>        Function_Return bState
24228>>>>>>>>>>>>>    End_Function
24229>>>>>>>>>>>>>    
24229>>>>>>>>>>>>>    Procedure Toggle_Client_Scrollbar_State
24231>>>>>>>>>>>>>        Set Client_Scrollbar_State ;            to (not(Client_Scrollbar_State(Self)))
24232>>>>>>>>>>>>>    End_Procedure
24233>>>>>>>>>>>>>    
24233>>>>>>>>>>>>>    Function ToolBar_State Returns Integer
24235>>>>>>>>>>>>>        Function_Return (private.Toolbar_State(Self))
24236>>>>>>>>>>>>>    End_Function
24237>>>>>>>>>>>>>    
24237>>>>>>>>>>>>>    Procedure Set Toolbar_State Integer bState
24239>>>>>>>>>>>>>        Integer hoToolBar
24239>>>>>>>>>>>>>        Handle hoCommandBars
24239>>>>>>>>>>>>>        If (bState<>toolbar_State(Self)) Begin
24241>>>>>>>>>>>>>            Set private.toolbar_State to bState
24242>>>>>>>>>>>>>            
24242>>>>>>>>>>>>>            Get phoCommandBars to hoCommandbars
24243>>>>>>>>>>>>>            If hoCommandbars ;                Procedure_Return
24246>>>>>>>>>>>>>            
24246>>>>>>>>>>>>>            If (Window_Handle(Self)) Begin
24248>>>>>>>>>>>>>                Get toolBar_ID to hoToolBar
24249>>>>>>>>>>>>>                If hoToolBar ;                    Send Activate_Component hoToolBar bState (Focus_Mode(hoToolbar))
24252>>>>>>>>>>>>>            End
24252>>>>>>>>>>>>>>
24252>>>>>>>>>>>>>        End
24252>>>>>>>>>>>>>>
24252>>>>>>>>>>>>>    End_Procedure
24253>>>>>>>>>>>>>    
24253>>>>>>>>>>>>>    Procedure Toggle_Toolbar
24255>>>>>>>>>>>>>        Set Toolbar_State to (not(Toolbar_State(Self)))
24256>>>>>>>>>>>>>    End_Procedure
24257>>>>>>>>>>>>>    
24257>>>>>>>>>>>>>    Function StatusBar_State Returns Integer
24259>>>>>>>>>>>>>        Handle hoCommandBars hoStatusBar
24259>>>>>>>>>>>>>        Boolean bState
24259>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24260>>>>>>>>>>>>>        If hoCommandbars Begin
24262>>>>>>>>>>>>>            Get Statusbar_ID to hoStatusBar
24263>>>>>>>>>>>>>            If hoStatusBar Begin
24265>>>>>>>>>>>>>                Get pbVisible of hoStatusBar to bState
24266>>>>>>>>>>>>>            End
24266>>>>>>>>>>>>>>
24266>>>>>>>>>>>>>        End
24266>>>>>>>>>>>>>>
24266>>>>>>>>>>>>>        Else Begin
24267>>>>>>>>>>>>>            Get private.Statusbar_state to bState
24268>>>>>>>>>>>>>        End
24268>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>        Function_Return bState
24269>>>>>>>>>>>>>    End_Function
24270>>>>>>>>>>>>>    
24270>>>>>>>>>>>>>    Procedure Set Statusbar_State Integer bState
24272>>>>>>>>>>>>>        Handle hoStatusBar hoCommandBars
24272>>>>>>>>>>>>>        If (bState<>Statusbar_State(Self)) Begin
24274>>>>>>>>>>>>>            Set private.Statusbar_State to bState
24275>>>>>>>>>>>>>            Get Statusbar_ID to hoStatusBar
24276>>>>>>>>>>>>>            
24276>>>>>>>>>>>>>            Get phoCommandBars to hoCommandbars
24277>>>>>>>>>>>>>            If hoCommandbars Begin
24279>>>>>>>>>>>>>                If hoStatusBar Begin
24281>>>>>>>>>>>>>                    Set pbVisible of hoStatusBar to bState
24282>>>>>>>>>>>>>                End
24282>>>>>>>>>>>>>>
24282>>>>>>>>>>>>>            End
24282>>>>>>>>>>>>>>
24282>>>>>>>>>>>>>            Else Begin
24283>>>>>>>>>>>>>                If (Window_Handle(Self)) Begin
24285>>>>>>>>>>>>>                    If hoStatusBar ;                        Send Activate_Component hoStatusBar bState  nonfocusable
24288>>>>>>>>>>>>>                End
24288>>>>>>>>>>>>>>
24288>>>>>>>>>>>>>            End
24288>>>>>>>>>>>>>>
24288>>>>>>>>>>>>>        End
24288>>>>>>>>>>>>>>
24288>>>>>>>>>>>>>    End_Procedure
24289>>>>>>>>>>>>>    
24289>>>>>>>>>>>>>    Procedure Toggle_Statusbar
24291>>>>>>>>>>>>>        Set Statusbar_State to (not(statusbar_State(Self)))
24292>>>>>>>>>>>>>    End_Procedure
24293>>>>>>>>>>>>>    
24293>>>>>>>>>>>>>    Procedure AutoSizeLocate
24295>>>>>>>>>>>>>    End_Procedure
24296>>>>>>>>>>>>>    
24296>>>>>>>>>>>>>    Procedure Size_Components
24298>>>>>>>>>>>>>        Integer iToolBar iStatBar //iClient
24298>>>>>>>>>>>>>        Integer iSizeToolBar
24298>>>>>>>>>>>>>        Handle hoCommandbars
24298>>>>>>>>>>>>>        
24298>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24299>>>>>>>>>>>>>        If hoCommandbars ;            Procedure_Return
24302>>>>>>>>>>>>>        
24302>>>>>>>>>>>>>        If not (Window_Handle(Self)) ;            Procedure_Return
24305>>>>>>>>>>>>>        
24305>>>>>>>>>>>>>        Get ToolBar_id   to iToolBar
24306>>>>>>>>>>>>>        Get StatusBar_id to iStatBar
24307>>>>>>>>>>>>>        //Get Client_id    To iClient
24307>>>>>>>>>>>>>        
24307>>>>>>>>>>>>>        If (iToolBar and Window_Handle(iToolbar)) Begin
24309>>>>>>>>>>>>>            //Send AutoSizeLocate To iToolBar
24309>>>>>>>>>>>>>            Get GuiSize of iToolbar to iSizeToolbar
24310>>>>>>>>>>>>>            Set GUIsize of iToolbar to (hi(iSizeToolbar)) (low(iSizeToolbar)) // forces auto resize - don't change size
24311>>>>>>>>>>>>>            //set GUIsize of iToolbar to 28 800 // forces auto resize
24311>>>>>>>>>>>>>        End
24311>>>>>>>>>>>>>>
24311>>>>>>>>>>>>>        
24311>>>>>>>>>>>>>        If (iStatBar and Window_Handle(iStatBar)) Begin
24313>>>>>>>>>>>>>            Send AutoSizeLocate to iStatBar
24314>>>>>>>>>>>>>        End
24314>>>>>>>>>>>>>>
24314>>>>>>>>>>>>>    End_Procedure
24315>>>>>>>>>>>>>    
24315>>>>>>>>>>>>>    Procedure Activate_Component Integer Obj Integer st Integer focusmode
24317>>>>>>>>>>>>>        Integer act
24317>>>>>>>>>>>>>        If not Obj ;            Procedure_Return
24320>>>>>>>>>>>>>        Get Active_State of Obj to act
24321>>>>>>>>>>>>>        If (st and act=0) Begin
24323>>>>>>>>>>>>>            Set Focus_Mode of obj to focusable
24324>>>>>>>>>>>>>            Send Add_focus to obj Self
24325>>>>>>>>>>>>>            Set Focus_Mode of obj to focusmode
24326>>>>>>>>>>>>>        End
24326>>>>>>>>>>>>>>
24326>>>>>>>>>>>>>        Else If (st=0 and act) ;            Send deactivate to obj
24330>>>>>>>>>>>>>    End_Procedure
24331>>>>>>>>>>>>>    
24331>>>>>>>>>>>>>    Procedure Add_Components
24333>>>>>>>>>>>>>        Integer hClient
24333>>>>>>>>>>>>>        Handle hoCommandbars
24333>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24334>>>>>>>>>>>>>        If not hoCommandbars Begin
24336>>>>>>>>>>>>>            Get Client_id to hClient
24337>>>>>>>>>>>>>            If (hClient and hClient<>Self ) ; // this forces the client to start at a                Set mdi_top_margin of hClient to (mdi_top_margin(hClient)) // proper size when maximized w/ no components.
24340>>>>>>>>>>>>>            Send Activate_Component (Toolbar_Id(Self)) ;                (Toolbar_State(Self)) nonfocusable
24341>>>>>>>>>>>>>            Send Activate_Component (Statusbar_Id(Self)) ;                (Statusbar_State(Self)) nonfocusable
24342>>>>>>>>>>>>>            Send Size_Components
24343>>>>>>>>>>>>>        End
24343>>>>>>>>>>>>>>
24343>>>>>>>>>>>>>    End_Procedure
24344>>>>>>>>>>>>>    
24344>>>>>>>>>>>>>    Procedure Activate Returns Integer
24346>>>>>>>>>>>>>        Integer bFail
24346>>>>>>>>>>>>>        Forward Get MSG_activate to bFail
24348>>>>>>>>>>>>>        //If NOT bFail Send Add_Components
24348>>>>>>>>>>>>>        Send Add_Components
24349>>>>>>>>>>>>>        Set Main_Window to Self
24350>>>>>>>>>>>>>        Procedure_Return bFail
24351>>>>>>>>>>>>>    End_Procedure
24352>>>>>>>>>>>>>    
24352>>>>>>>>>>>>>    Procedure Client_Message Integer Msg_Id
24354>>>>>>>>>>>>>        Integer hoClient
24354>>>>>>>>>>>>>        Get Client_id to hoClient
24355>>>>>>>>>>>>>        If (hoClient and hoClient <> Self) ;            Send Msg_id to hoClient
24358>>>>>>>>>>>>>    End_Procedure
24359>>>>>>>>>>>>>    
24359>>>>>>>>>>>>>    Procedure Arrange_Icons
24361>>>>>>>>>>>>>        Send Client_Message Current_Message
24362>>>>>>>>>>>>>    End_Procedure
24363>>>>>>>>>>>>>    
24363>>>>>>>>>>>>>    Procedure Cascade_Windows
24365>>>>>>>>>>>>>        Send Client_Message Current_Message
24366>>>>>>>>>>>>>    End_Procedure
24367>>>>>>>>>>>>>    
24367>>>>>>>>>>>>>    Procedure Tile_Windows_Horizontal
24369>>>>>>>>>>>>>        Send Client_Message Current_Message
24370>>>>>>>>>>>>>    End_Procedure
24371>>>>>>>>>>>>>    
24371>>>>>>>>>>>>>    Procedure Tile_Windows_Vertical
24373>>>>>>>>>>>>>        Send Client_Message Current_Message
24374>>>>>>>>>>>>>    End_Procedure
24375>>>>>>>>>>>>>    
24375>>>>>>>>>>>>>    Procedure Set GuiSize Integer sizy Integer sizx
24377>>>>>>>>>>>>>        Forward Set GUISize to sizy sizx
24379>>>>>>>>>>>>>        If BuildingObjectId ;            Procedure_Return
24382>>>>>>>>>>>>>        Send Size_Components
24383>>>>>>>>>>>>>    End_Procedure
24384>>>>>>>>>>>>>    
24384>>>>>>>>>>>>>    //  Returns false to indicate that this is not a DEO. This is used by
24384>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
24384>>>>>>>>>>>>>    //  send a DEO message. DEO view clients set this true
24384>>>>>>>>>>>>>    //
24384>>>>>>>>>>>>>    Function Is_Function Integer MsgId Integer ObjId Integer DelegateFg Returns Integer
24386>>>>>>>>>>>>>        Integer DelMode rVal Id
24386>>>>>>>>>>>>>        Move ( If(DelegateFg,Self,ObjId) ) to Id
24387>>>>>>>>>>>>>        Get Delegation_mode of Id to DelMode
24388>>>>>>>>>>>>>        Set Delegation_mode of Id to No_Delegate_or_Error
24389>>>>>>>>>>>>>        Get MsgId of ObjId to rVal
24390>>>>>>>>>>>>>        Set Delegation_mode of Id to DelMode
24391>>>>>>>>>>>>>        Function_Return rVal
24392>>>>>>>>>>>>>    End_Function
24393>>>>>>>>>>>>>    
24393>>>>>>>>>>>>>    // In this class this should return an id or nothing (no delegation).
24393>>>>>>>>>>>>>    // Note, if no context exists return a 0 or ''.
24393>>>>>>>>>>>>>    //
24393>>>>>>>>>>>>>    Function Help_Context Integer Context_Type Returns String
24395>>>>>>>>>>>>>        Integer ID
24395>>>>>>>>>>>>>        String  rVal
24395>>>>>>>>>>>>>        
24395>>>>>>>>>>>>>        If (Context_Type = HELP_CONTEXT_ID) ;            Get Help_ID to rVal
24398>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_KEYWORD) ;            Get Help_Keyword to rVal
24402>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_ID_OR_KEY) Begin
24405>>>>>>>>>>>>>            Get Help_ID to ID
24406>>>>>>>>>>>>>            If (ID = 0) ;                Get Help_Keyword to rVal
24409>>>>>>>>>>>>>            Move ID to rVal
24410>>>>>>>>>>>>>            If (rval = '') ;                Move 0 to rVal
24413>>>>>>>>>>>>>        End
24413>>>>>>>>>>>>>>
24413>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_DATAFILE) ;            Move '' to rVal
24417>>>>>>>>>>>>>        
24417>>>>>>>>>>>>>        Function_Return rVal
24418>>>>>>>>>>>>>    End_Function
24419>>>>>>>>>>>>>    
24419>>>>>>>>>>>>>    // Get context based on eContext. If no content found, Don't delegate with panels --- end the search (added to 11.1. See help_mx.pkg)
24419>>>>>>>>>>>>>    //
24419>>>>>>>>>>>>>    Function HtmlHelpContext Integer eContext String ByRef sContext Returns Integer
24421>>>>>>>>>>>>>        Integer eContextFound
24421>>>>>>>>>>>>>        Get HtmlHelpObjectContext eContext (&sContext) to eContextFound // context for this one object
24422>>>>>>>>>>>>>        Function_Return eContextFound
24423>>>>>>>>>>>>>    End_Function
24424>>>>>>>>>>>>>    
24424>>>>>>>>>>>>>    
24424>>>>>>>>>>>>>    // When verify_exit_appliction is received by default just
24424>>>>>>>>>>>>>    // send this message to the Mdi-client Id.
24424>>>>>>>>>>>>>    //
24424>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24426>>>>>>>>>>>>>        Integer Id rVal
24426>>>>>>>>>>>>>        Get Client_Id to id
24427>>>>>>>>>>>>>        If (Id and Id<>Self) ;            Get Verify_Exit_application of Id to rVal
24430>>>>>>>>>>>>>        Function_Return Rval
24431>>>>>>>>>>>>>    End_Function
24432>>>>>>>>>>>>>    
24432>>>>>>>>>>>>>    // When exit notifiction is received by default just
24432>>>>>>>>>>>>>    // send this message to the Mdi-client Id.
24432>>>>>>>>>>>>>    //
24432>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24434>>>>>>>>>>>>>        Send Client_Message Current_Message
24435>>>>>>>>>>>>>    End_Procedure
24436>>>>>>>>>>>>>    
24436>>>>>>>>>>>>>    Procedure Minimize_all_Windows
24438>>>>>>>>>>>>>        Send Client_Message Current_Message
24439>>>>>>>>>>>>>    End_Procedure
24440>>>>>>>>>>>>>    
24440>>>>>>>>>>>>>    Procedure Restore_all_Windows
24442>>>>>>>>>>>>>        Send Client_Message Current_Message
24443>>>>>>>>>>>>>    End_Procedure
24444>>>>>>>>>>>>>    
24444>>>>>>>>>>>>>    // augmented to  activate if required
24444>>>>>>>>>>>>>    //
24444>>>>>>>>>>>>>    Procedure End_Construct_Object
24446>>>>>>>>>>>>>        Forward Send End_Construct_object
24448>>>>>>>>>>>>>        If (Auto_activate_state(Self)) ;            Send Activate
24451>>>>>>>>>>>>>    End_Procedure
24452>>>>>>>>>>>>>    
24452>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
24454>>>>>>>>>>>>>        Integer iError i iViews
24454>>>>>>>>>>>>>        Handle[] hoAutoActivateViews
24455>>>>>>>>>>>>>        Forward Get msg_Add_Focus hoParent to iError
24457>>>>>>>>>>>>>        If (iError=0) Begin
24459>>>>>>>>>>>>>            Get phoAutoActivateViews to hoAutoActivateViews
24460>>>>>>>>>>>>>            Move (SizeOfArray(hoAutoActivateViews)) to iViews
24461>>>>>>>>>>>>>            For i from 0 to (iViews-1)
24467>>>>>>>>>>>>>>
24467>>>>>>>>>>>>>                Send Activate_View of hoAutoActivateViews[i]
24468>>>>>>>>>>>>>            Loop
24469>>>>>>>>>>>>>>
24469>>>>>>>>>>>>>        End
24469>>>>>>>>>>>>>>
24469>>>>>>>>>>>>>    End_Procedure
24470>>>>>>>>>>>>>    
24470>>>>>>>>>>>>>    // adds a view to the array of views to be autoactivated
24470>>>>>>>>>>>>>    
24470>>>>>>>>>>>>>    Procedure AddAutoActivateView Handle hoView
24472>>>>>>>>>>>>>        Handle[] hoAutoActivateViews
24473>>>>>>>>>>>>>        Get phoAutoActivateViews to hoAutoActivateViews
24474>>>>>>>>>>>>>        Move hoView to hoAutoActivateViews[SizeOfArray(hoAutoActivateViews)]
24475>>>>>>>>>>>>>        Set phoAutoActivateViews to hoAutoActivateViews
24476>>>>>>>>>>>>>    End_Procedure
24477>>>>>>>>>>>>>    
24477>>>>>>>>>>>>>End_Class
24478>>>>>>>>>>>>>
24478>>>>>>>>>>>>>
24478>>>>>>>>>>>>>Use DFCursor.pkg
24478>>>>>>>>>>>>>
24478>>>>>>>>>>>>>//  Main DEO High level main Panel Class
24478>>>>>>>>>>>>>//
24478>>>>>>>>>>>>>Class Panel is a AppPanel
24479>>>>>>>>>>>>>    
24479>>>>>>>>>>>>>    Procedure Construct_Object
24481>>>>>>>>>>>>>        String St
24481>>>>>>>>>>>>>        Integer iVal
24481>>>>>>>>>>>>>        DWord dwState
24481>>>>>>>>>>>>>        Forward Send Construct_Object
24483>>>>>>>>>>>>>        
24483>>>>>>>>>>>>>        // defaults to hourglass...end_construct will remove
24483>>>>>>>>>>>>>        Send Cursor_wait to (Cursor_Control(Self)) // hourglass
24484>>>>>>>>>>>>>        
24484>>>>>>>>>>>>>    End_Procedure
24485>>>>>>>>>>>>>    
24485>>>>>>>>>>>>>    
24485>>>>>>>>>>>>>    // This sends the message register_active_view to all child objects.
24485>>>>>>>>>>>>>    // It passes the object ID of the object that is requesting this
24485>>>>>>>>>>>>>    // information. The flag BCast_Focus determines if this should
24485>>>>>>>>>>>>>    // broadcast or broadcast_focus
24485>>>>>>>>>>>>>    //
24485>>>>>>>>>>>>>    Procedure Notify_All_Views Integer Msg Integer obj Integer Bcast_Focus
24487>>>>>>>>>>>>>        Integer clobj
24487>>>>>>>>>>>>>        Get Client_ID to clObj
24488>>>>>>>>>>>>>        If (ClObj = 0) ;            Move Self to ClObj
24491>>>>>>>>>>>>>        If BCast_Focus ;            Broadcast_Focus Send Msg to Clobj obj
24495>>>>>>>>>>>>>        Else ;            Broadcast       Send Msg to Clobj obj
24498>>>>>>>>>>>>>    End_Procedure
24499>>>>>>>>>>>>>    
24499>>>>>>>>>>>>>    //
24499>>>>>>>>>>>>>    // Save any information you wish about this panel.
24499>>>>>>>>>>>>>    //
24499>>>>>>>>>>>>>    //  Rules for saving:
24499>>>>>>>>>>>>>    //  1. only save if SaveEnvironment=TRUE, ON or YES
24499>>>>>>>>>>>>>    //  2. Save current size and location to ApplicationSize, ApplicationLocation
24499>>>>>>>>>>>>>    //
24499>>>>>>>>>>>>>    Procedure Save_Environment
24501>>>>>>>>>>>>>        If ghoApplication ;            Send DoSaveEnvironment of ghoApplication Self True
24504>>>>>>>>>>>>>    End_Procedure
24505>>>>>>>>>>>>>    
24505>>>>>>>>>>>>>    // For high level panel support save of environment
24505>>>>>>>>>>>>>    //
24505>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24507>>>>>>>>>>>>>        Send Save_Environment
24508>>>>>>>>>>>>>        Forward Send Notify_Exit_Application
24510>>>>>>>>>>>>>    End_Procedure
24511>>>>>>>>>>>>>    
24511>>>>>>>>>>>>>    // augmented to remove hourglass
24511>>>>>>>>>>>>>    //
24511>>>>>>>>>>>>>    Procedure End_Construct_Object
24513>>>>>>>>>>>>>        // if application object exists, we need to tell that object that we are the main panel
24513>>>>>>>>>>>>>        If ghoApplication ;            Set phoMainPanel of ghoApplication to Self
24516>>>>>>>>>>>>>        Forward Send End_Construct_object
24518>>>>>>>>>>>>>        Send Cursor_ready to (Cursor_Control(Self)) // restore
24519>>>>>>>>>>>>>    End_Procedure
24520>>>>>>>>>>>>>    
24520>>>>>>>>>>>>>    Procedure Page Integer iState
24522>>>>>>>>>>>>>        Forward Send Page iState
24524>>>>>>>>>>>>>        If (iState =1) Begin
24526>>>>>>>>>>>>>            If ghoApplication ;                Send DoLoadEnvironment of ghoApplication Self True
24529>>>>>>>>>>>>>        End
24529>>>>>>>>>>>>>>
24529>>>>>>>>>>>>>    End_Procedure
24530>>>>>>>>>>>>>    
24530>>>>>>>>>>>>>End_Class
24531>>>>>>>>>>>>>
24531>>>>>>>>>>>>>//  Main DEO High level main MDI Client Class
24531>>>>>>>>>>>>>//
24531>>>>>>>>>>>>>//  Currently there is nothing special about this class but it was
24531>>>>>>>>>>>>>//  created because it is logically correct. Extensions may go here in
24531>>>>>>>>>>>>>//  the futire
24531>>>>>>>>>>>>>Class ClientArea is a AppClientArea
24532>>>>>>>>>>>>>End_Class
24533>>>>>>>>>>>>>
24533>>>>>>>>>>>Use EnClient.pkg
Including file: Enclient.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Enclient.pkg)
24533>>>>>>>>>>>>>Use windows.pkg
24533>>>>>>>>>>>>>Use NESTING.pkg       //include DEO nesting standard support module
Including file: nesting.pkg    (C:\Program Files\DataFlex 20.1\Pkg\nesting.pkg)
24533>>>>>>>>>>>>>>>Use VDFBase.pkg
24533>>>>>>>>>>>>>>>
24533>>>>>>>>>>>>>>>Class nesting_mixin is a mixin
24534>>>>>>>>>>>>>>>    
24534>>>>>>>>>>>>>>>    //   Component_State indicates if this object has a parent object which is
24534>>>>>>>>>>>>>>>    //   also a data-entry object.
24534>>>>>>>>>>>>>>>    //
24534>>>>>>>>>>>>>>>    //   Has_Components_State indicates if this object has at least one child-
24534>>>>>>>>>>>>>>>    //   object which is also a data-entry object.
24534>>>>>>>>>>>>>>>    //
24534>>>>>>>>>>>>>>>    //   First_DEO and Last_DEO are used temporarily during the searches for
24534>>>>>>>>>>>>>>>    //   the first and last data-entry object children of this object (see
24534>>>>>>>>>>>>>>>    //   Find_First_DEO, Find_Last_DEO, Inquire_First_DEO and Inquire_Last_DEO).
24534>>>>>>>>>>>>>>>    //
24534>>>>>>>>>>>>>>>    Procedure define_nesting
24536>>>>>>>>>>>>>>>        Property Integer Component_State        0
24537>>>>>>>>>>>>>>>        Property Integer Has_Components_State   0
24538>>>>>>>>>>>>>>>        Property Integer First_DEO              0
24539>>>>>>>>>>>>>>>        Property Integer Last_DEO               0
24540>>>>>>>>>>>>>>>        
24540>>>>>>>>>>>>>>>        // Stop_ui support - Moved from its own mixin package.
24540>>>>>>>>>>>>>>>        Property Integer Stop_UI_State False
24541>>>>>>>>>>>>>>>        
24541>>>>>>>>>>>>>>>    End_Procedure
24542>>>>>>>>>>>>>>>    
24542>>>>>>>>>>>>>>>    
24542>>>>>>>>>>>>>>>    //   This procedure is used to locate the first data-entry object among
24542>>>>>>>>>>>>>>>    //   this object's siblings (its parent's children).
24542>>>>>>>>>>>>>>>    //
24542>>>>>>>>>>>>>>>    //   This procedure is typically invoked via the BROADCAST command from
24542>>>>>>>>>>>>>>>    //   the Find_First_DEO function of this object's parent.
24542>>>>>>>>>>>>>>>    //
24542>>>>>>>>>>>>>>>    Procedure inquire_first_DEO Integer obj# Integer recurseClients
24544>>>>>>>>>>>>>>>        If (focus_mode(Self) = FOCUSABLE) Begin
24546>>>>>>>>>>>>>>>            If (recurseClients and client_area_state(Self)) ;                Broadcast_Focus Send inquire_first_DEO obj# recurseClients
24550>>>>>>>>>>>>>>>            Else Begin
24551>>>>>>>>>>>>>>>                Set first_DEO of obj# to Self
24552>>>>>>>>>>>>>>>                Procedure_Return 1  //to stop broadcast, since this object answered
24553>>>>>>>>>>>>>>>            End
24553>>>>>>>>>>>>>>>>
24553>>>>>>>>>>>>>>>        End
24553>>>>>>>>>>>>>>>>
24553>>>>>>>>>>>>>>>    End_Procedure
24554>>>>>>>>>>>>>>>    
24554>>>>>>>>>>>>>>>    //   If this object is focusable, set Lastt_DEO to this object's id.
24554>>>>>>>>>>>>>>>    //
24554>>>>>>>>>>>>>>>    //   This procedure is used to locate the last data-entry object among
24554>>>>>>>>>>>>>>>    //   this object's siblings (its parent's children).
24554>>>>>>>>>>>>>>>    //
24554>>>>>>>>>>>>>>>    //   This procedure is typically invoked via the BROADCAST command from
24554>>>>>>>>>>>>>>>    //   the Find_Last_DEO function of this object's parent.
24554>>>>>>>>>>>>>>>    //
24554>>>>>>>>>>>>>>>    Procedure inquire_last_DEO Integer obj# Integer recurseClients
24556>>>>>>>>>>>>>>>        If (focus_mode(Self) = FOCUSABLE) Begin
24558>>>>>>>>>>>>>>>            If (recurseClients and client_area_state(Self)) ;                Broadcast_Focus Send inquire_last_DEO obj# recurseClients
24562>>>>>>>>>>>>>>>            Else ;                Set last_DEO of obj# to Self
24564>>>>>>>>>>>>>>>        End
24564>>>>>>>>>>>>>>>>
24564>>>>>>>>>>>>>>>    End_Procedure
24565>>>>>>>>>>>>>>>    
24565>>>>>>>>>>>>>>>    //   This function returns the object id of the first data-entry object
24565>>>>>>>>>>>>>>>    //   which is a child of this object, or 0.
24565>>>>>>>>>>>>>>>    //
24565>>>>>>>>>>>>>>>    //   This function 'searches' by broadcasting Inquire_First_DEO, which
24565>>>>>>>>>>>>>>>    //   returns a 1 to terminate the broadcast after the first data-entry
24565>>>>>>>>>>>>>>>    //   object has been located.
24565>>>>>>>>>>>>>>>    //
24565>>>>>>>>>>>>>>>    Function find_first_DEO Returns Integer
24567>>>>>>>>>>>>>>>        Set First_DEO to 0
24568>>>>>>>>>>>>>>>        Broadcast_Focus Send inquire_first_DEO Self False //sets First_DEO property
24570>>>>>>>>>>>>>>>        Function_Return (first_deo(Self))
24571>>>>>>>>>>>>>>>    End_Function
24572>>>>>>>>>>>>>>>    
24572>>>>>>>>>>>>>>>    
24572>>>>>>>>>>>>>>>    //   This function returns the object id of the last data-entry object
24572>>>>>>>>>>>>>>>    //   which is a child of this object, or 0.
24572>>>>>>>>>>>>>>>    //
24572>>>>>>>>>>>>>>>    //   This function 'searches' by broadcasting Inquire_Last_DEO, which sets
24572>>>>>>>>>>>>>>>    //   the property Last_DEO.  Thus, the last object reached by the broadcast
24572>>>>>>>>>>>>>>>    //   is the last value to be set into Last_DEO.
24572>>>>>>>>>>>>>>>    //
24572>>>>>>>>>>>>>>>    Function find_last_DEO Returns Integer
24574>>>>>>>>>>>>>>>        Set Last_DEO to 0
24575>>>>>>>>>>>>>>>        Broadcast_Focus Send inquire_last_DEO Self False //sets Last_DEO property
24577>>>>>>>>>>>>>>>        Function_Return (Last_DEO(Self))
24578>>>>>>>>>>>>>>>    End_Function
24579>>>>>>>>>>>>>>>    
24579>>>>>>>>>>>>>>>    //   Removes this object from the screen and focus-tree, and also removes
24579>>>>>>>>>>>>>>>    //   this object's children from the screen and focus-tree.
24579>>>>>>>>>>>>>>>    //
24579>>>>>>>>>>>>>>>    //   If no flag argument was passed, AREA_TYPE becomes the flag parameter.
24579>>>>>>>>>>>>>>>    //
24579>>>>>>>>>>>>>>>    //   Client-objects already automatically remove their children from the
24579>>>>>>>>>>>>>>>    //   focus-tree.
24579>>>>>>>>>>>>>>>    //
24579>>>>>>>>>>>>>>>    Procedure Deactivate Integer eDeactivateScope Returns Integer
24581>>>>>>>>>>>>>>>        Integer retval Fg
24581>>>>>>>>>>>>>>>        If (num_arguments > 0) ;            Move eDeactivateScope to Fg
24584>>>>>>>>>>>>>>>        Else ;            Move AREA_TYPE to Fg
24586>>>>>>>>>>>>>>>        Forward Get msg_deactivate fg to retval
24588>>>>>>>>>>>>>>>        
24588>>>>>>>>>>>>>>>        If ( not(retval) and (fg = 0) ) Begin
24590>>>>>>>>>>>>>>>            
24590>>>>>>>>>>>>>>>            // This broadcast no_stop is probably not ever used, but would be if a
24590>>>>>>>>>>>>>>>            // child was in the focus tree, but not as a focus-child. weird, but needs be here.
24590>>>>>>>>>>>>>>>            If ( client_Area_state(Self)=0) ;                Broadcast NO_STOP Send deactivate 0
24595>>>>>>>>>>>>>>>            
24595>>>>>>>>>>>>>>>            If ( Stop_UI_State(Self) ) ;                Send Stop_Ui
24598>>>>>>>>>>>>>>>        End
24598>>>>>>>>>>>>>>>>
24598>>>>>>>>>>>>>>>        Procedure_Return retval
24599>>>>>>>>>>>>>>>    End_Procedure
24600>>>>>>>>>>>>>>>    
24600>>>>>>>>>>>>>>>    //   This procedure marks an object as a child data-entry object, and
24600>>>>>>>>>>>>>>>    //   attempts to use its parent's Server if this object has no Server.
24600>>>>>>>>>>>>>>>    //   Typically sent via broadcast from parent DEO.
24600>>>>>>>>>>>>>>>    //
24600>>>>>>>>>>>>>>>    Procedure Mark_As_Component
24602>>>>>>>>>>>>>>>        Set Component_State to True
24603>>>>>>>>>>>>>>>        Delegate Set Has_Components_State to True
24605>>>>>>>>>>>>>>>    End_Procedure
24606>>>>>>>>>>>>>>>    
24606>>>>>>>>>>>>>>>    
24606>>>>>>>>>>>>>>>    //   This procedure marks child data-entry objects as components.
24606>>>>>>>>>>>>>>>    //
24606>>>>>>>>>>>>>>>    //   The child data-entry objects must understand Mark_As_Component as a
24606>>>>>>>>>>>>>>>    //   method of setting their Component_State to TRUE.
24606>>>>>>>>>>>>>>>    Procedure Mark_Components
24608>>>>>>>>>>>>>>>        Set Component_State to False
24609>>>>>>>>>>>>>>>        Broadcast Send Mark_As_Component
24611>>>>>>>>>>>>>>>    End_Procedure
24612>>>>>>>>>>>>>>>End_Class
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>Use NAVIGATE.pkg      //include DEO navigation standard support module
Including file: navigate.pkg    (C:\Program Files\DataFlex 20.1\Pkg\navigate.pkg)
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>>>Use VDFBase.pkg
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>>>Register_Function verify_data_loss Returns Integer
24613>>>>>>>>>>>>>>>
24613>>>>>>>>>>>>>>>Class navigate_mixin is a mixin
24614>>>>>>>>>>>>>>>    
24614>>>>>>>>>>>>>>>    Procedure define_navigation
24616>>>>>>>>>>>>>>>        On_Key kBegin_of_Panel    Send Beginning_of_Panel PRIVATE
24617>>>>>>>>>>>>>>>        On_Key kCancel            Send Request_Cancel     PRIVATE
24618>>>>>>>>>>>>>>>        On_Key kEnd_of_Panel      Send End_of_Panel       PRIVATE
24619>>>>>>>>>>>>>>>        On_Key kExit_Function     Send Exit_Function      PRIVATE
24620>>>>>>>>>>>>>>>        On_Key kSwitch            Send Switch             PRIVATE
24621>>>>>>>>>>>>>>>        On_Key kSwitch_Back       Send Switch_Back        PRIVATE
24622>>>>>>>>>>>>>>>        Property Integer Auto_Top_Panel_State             True
24623>>>>>>>>>>>>>>>        Property Integer private.Verify_Exit_Msg          0
24624>>>>>>>>>>>>>>>    End_Procedure
24625>>>>>>>>>>>>>>>    
24625>>>>>>>>>>>>>>>    Function Verify_Exit_msg Returns Integer
24627>>>>>>>>>>>>>>>        Integer msg#
24627>>>>>>>>>>>>>>>        Get private.verify_exit_msg to msg#
24628>>>>>>>>>>>>>>>        If (msg# = 0 and Component_State(Self)) ;            Delegate Get verify_exit_msg to msg#
24632>>>>>>>>>>>>>>>        Function_Return msg#
24633>>>>>>>>>>>>>>>    End_Function
24634>>>>>>>>>>>>>>>    
24634>>>>>>>>>>>>>>>    
24634>>>>>>>>>>>>>>>    Procedure Set Verify_Exit_msg Integer msg#
24636>>>>>>>>>>>>>>>        Set private.verify_Exit_Msg to msg#
24637>>>>>>>>>>>>>>>    End_Procedure
24638>>>>>>>>>>>>>>>    
24638>>>>>>>>>>>>>>>    
24638>>>>>>>>>>>>>>>    Function Verify_Exit Returns Integer
24640>>>>>>>>>>>>>>>        Integer msg#
24640>>>>>>>>>>>>>>>        Get verify_Exit_msg to msg#
24641>>>>>>>>>>>>>>>        If (msg# <> 0) ;            Get msg# to msg#
24644>>>>>>>>>>>>>>>        Function_Return msg#
24645>>>>>>>>>>>>>>>    End_Function
24646>>>>>>>>>>>>>>>    
24646>>>>>>>>>>>>>>>    
24646>>>>>>>>>>>>>>>    
24646>>>>>>>>>>>>>>>    
24646>>>>>>>>>>>>>>>    //   The deactivate message-send passes AREA_FLAG, which means that we want
24646>>>>>>>>>>>>>>>    //   to deactivate the object in the focus tree which is either a scope
24646>>>>>>>>>>>>>>>    //   (i.e. Scope_State = TRUE) or a pop-up (i.e. PopUp_State = TRUE), and
24646>>>>>>>>>>>>>>>    //   which is closest to this object in an 'upward' direction (i.e.
24646>>>>>>>>>>>>>>>    //   client/parent, not child or sibling).
24646>>>>>>>>>>>>>>>    //
24646>>>>>>>>>>>>>>>    Procedure Request_Cancel
24648>>>>>>>>>>>>>>>        Integer foc#
24648>>>>>>>>>>>>>>>        If (verify_exit(Self) = 0) Begin
24650>>>>>>>>>>>>>>>            Send deactivate AREA_FLAG
24651>>>>>>>>>>>>>>>            Get focus of desktop to foc#
24652>>>>>>>>>>>>>>>            If (foc# and skip_State(foc#)) ;                Send switch to foc#
24655>>>>>>>>>>>>>>>        End
24655>>>>>>>>>>>>>>>>
24655>>>>>>>>>>>>>>>    End_Procedure
24656>>>>>>>>>>>>>>>    
24656>>>>>>>>>>>>>>>    
24656>>>>>>>>>>>>>>>    
24656>>>>>>>>>>>>>>>    Procedure Exit_Function
24658>>>>>>>>>>>>>>>        Send request_cancel
24659>>>>>>>>>>>>>>>    End_Procedure
24660>>>>>>>>>>>>>>>    
24660>>>>>>>>>>>>>>>End_Class
24661>>>>>>>>>>>>>>>
24661>>>>>>>>>>>>>>>
24661>>>>>>>>>>>>>>>
24661>>>>>>>>>>>>>Use SERVER.pkg        //include Server support module
Including file: Server.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Server.pkg)
24661>>>>>>>>>>>>>>>
24661>>>>>>>>>>>>>>>Use VDFBase.pkg
24661>>>>>>>>>>>>>>>Use brdcster.pkg
Including file: brdcster.pkg    (C:\Program Files\DataFlex 20.1\Pkg\brdcster.pkg)
24661>>>>>>>>>>>>>>>>>Use Set.pkg
24661>>>>>>>>>>>>>>>>>
24661>>>>>>>>>>>>>>>>>//   This class is defined as a subclass of Set with a C language handler
24661>>>>>>>>>>>>>>>>>//   providing additional behavior.
24661>>>>>>>>>>>>>>>>>//
24661>>>>>>>>>>>>>>>>>Class Broadcaster is a Set 0 0 Broadcast_Handler
24662>>>>>>>>>>>>>>>>>End_Class
24663>>>>>>>>>>>>>>>>>
24663>>>>>>>>>>>>>>>>>
24663>>>>>>>>>>>>>>>>>Function make_broadcaster for cDesktop Returns Integer
24665>>>>>>>>>>>>>>>>>    Integer obj#
24665>>>>>>>>>>>>>>>>>    Object broadcasterTemplate is a broadcaster
24667>>>>>>>>>>>>>>>>>        Move Self to obj#
24668>>>>>>>>>>>>>>>>>    End_Object
24669>>>>>>>>>>>>>>>>>    Function_Return obj#
24670>>>>>>>>>>>>>>>>>End_Function
24671>>>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>Register_Procedure Item_Find Integer mode Integer datafile Integer datafield ;    Integer entUpdtFlag Integer errFlag Integer dfrdFlag
24671>>>>>>>>>>>>>>>Register_Procedure Add_User_Interface Integer obj#
24671>>>>>>>>>>>>>>>Register_Procedure Remove_User_Interface Integer obj#
24671>>>>>>>>>>>>>>>Register_Procedure Clear
24671>>>>>>>>>>>>>>>Register_Function  Component_State Returns Integer
24671>>>>>>>>>>>>>>>Register_Function  Can_Delete Returns Integer
24671>>>>>>>>>>>>>>>Register_Object Element
24671>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>// Values for DSO_Detach_Mode
24671>>>>>>>>>>>>>>>//   DETACH_NEVER        = Never
24671>>>>>>>>>>>>>>>//   DETACH_IF_ALLOWED   = do if changed_state=F and DEO Static_Server
24671>>>>>>>>>>>>>>>//   DETACH_IF_NO_CHANGE = do if changed_state=F
24671>>>>>>>>>>>>>>>//   DETACH_ALWAYS       = do it no matter what
24671>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>Enumeration_List
24671>>>>>>>>>>>>>>>    Define Detach_Never
24671>>>>>>>>>>>>>>>    Define Detach_If_No_Change
24671>>>>>>>>>>>>>>>    Define Detach_Always
24671>>>>>>>>>>>>>>>    Define Detach_If_Allowed
24671>>>>>>>>>>>>>>>End_Enumeration_List
24671>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>
24671>>>>>>>>>>>>>>>Class server_mixin is a mixin
24672>>>>>>>>>>>>>>>    
24672>>>>>>>>>>>>>>>    //   Server is the object id of the database agent for this object.
24672>>>>>>>>>>>>>>>    //
24672>>>>>>>>>>>>>>>    //   Watched_Servers is a set of object ids for database agents whose state
24672>>>>>>>>>>>>>>>    //   must also be monitored by this object (but which never receive requests
24672>>>>>>>>>>>>>>>    //   directly from this object, unlike the Server).
24672>>>>>>>>>>>>>>>    //
24672>>>>>>>>>>>>>>>    //   Servers_Scanned determines if the items of this object have been
24672>>>>>>>>>>>>>>>    //   scanned to see if this object should be connected to other database
24672>>>>>>>>>>>>>>>    //   agents as 'just watching' (see Watched_Servers, above).
24672>>>>>>>>>>>>>>>    //
24672>>>>>>>>>>>>>>>    //   Auto_Fill_State determines if this object should always automatically
24672>>>>>>>>>>>>>>>    //   fill itself with data when it is activated.
24672>>>>>>>>>>>>>>>    //
24672>>>>>>>>>>>>>>>    //   Deferred_State determines if this object's browsing in database files
24672>>>>>>>>>>>>>>>    //   should be reflected immediately in this object's database agent (and
24672>>>>>>>>>>>>>>>    //   the agents' agents, etc.), or not.
24672>>>>>>>>>>>>>>>    //
24672>>>>>>>>>>>>>>>    //
24672>>>>>>>>>>>>>>>    Procedure define_server
24674>>>>>>>>>>>>>>>        Integer obj#
24674>>>>>>>>>>>>>>>        Property Integer private.Server           0
24675>>>>>>>>>>>>>>>        Property Integer Watched_Servers          0
24676>>>>>>>>>>>>>>>        // used to send Set Changed_State to "foreign" servers, while Watched_Servers
24676>>>>>>>>>>>>>>>        // is used for sending messages from the DDO to DEOs (there are more of them)
24676>>>>>>>>>>>>>>>        Property Integer ChangedStateWatched_Servers     0
24677>>>>>>>>>>>>>>>        Property Integer private.Servers_Scanned  0
24678>>>>>>>>>>>>>>>        
24678>>>>>>>>>>>>>>>        Property Integer Auto_Fill_State False
24679>>>>>>>>>>>>>>>        Property Integer Deferred_State  False
24680>>>>>>>>>>>>>>>        
24680>>>>>>>>>>>>>>>        // added to support DEO request-delegation. This is set true
24680>>>>>>>>>>>>>>>        // if the server is explicitly set in this DEO (normally via a
24680>>>>>>>>>>>>>>>        // USING parameter).
24680>>>>>>>>>>>>>>>        Property Integer explicit_server_state False
24681>>>>>>>>>>>>>>>        
24681>>>>>>>>>>>>>>>        // Since this package's SET changed_state is using change_
24681>>>>>>>>>>>>>>>        // disabled_state we might as well define it here. This gets changed
24681>>>>>>>>>>>>>>>        // by Clear_mx to support setting of defaults without changing the
24681>>>>>>>>>>>>>>>        // objects changed_state.
24681>>>>>>>>>>>>>>>        
24681>>>>>>>>>>>>>>>        // This stops changed_state from getting changed. It allows item_changed_
24681>>>>>>>>>>>>>>>        // state to chagne without the object's changed_state getting changed.
24681>>>>>>>>>>>>>>>        // This should be considered protected (i.e., likely to change). The new
24681>>>>>>>>>>>>>>>        // messages Entry_Defaults and Set Default_Value are both public and use
24681>>>>>>>>>>>>>>>        // this. Try to use these messages instead of this property.
24681>>>>>>>>>>>>>>>        Property Integer Change_Disabled_State  False
24682>>>>>>>>>>>>>>>        
24682>>>>>>>>>>>>>>>        // If true DEO will not disconnect from server when deactivating.
24682>>>>>>>>>>>>>>>        // If true View should handles attaching and detaching.
24682>>>>>>>>>>>>>>>        Register_Function Default_static_server_state Returns Integer
24682>>>>>>>>>>>>>>>        Property Integer Static_Server_State  (Default_Static_Server_State(Self))
24683>>>>>>>>>>>>>>>        
24683>>>>>>>>>>>>>>>        // Properties to better support tables. If Refresh_dirty_state
24683>>>>>>>>>>>>>>>        // is true then the list object needs refreshing (because it was inactive
24683>>>>>>>>>>>>>>>        // and changes were made that were not updated). After add_focus is
24683>>>>>>>>>>>>>>>        // complete the add_focus_msg is sent (allows tables to initialize the
24683>>>>>>>>>>>>>>>        // list).
24683>>>>>>>>>>>>>>>        Property Integer Refresh_dirty_state  True // when not active/dirty
24684>>>>>>>>>>>>>>>        Property Integer Add_focus_msg        0    // by dflt no message
24685>>>>>>>>>>>>>>>        
24685>>>>>>>>>>>>>>>        // This will call a stub procedure which will be augmented (or replaced)
24685>>>>>>>>>>>>>>>        // by the xdeo mixins
24685>>>>>>>>>>>>>>>        Send Define_Extended_DEO_Mixin
24686>>>>>>>>>>>>>>>        
24686>>>>>>>>>>>>>>>    End_Procedure
24687>>>>>>>>>>>>>>>    
24687>>>>>>>>>>>>>>>    
24687>>>>>>>>>>>>>>>    Procedure remove_deo_from_server
24689>>>>>>>>>>>>>>>        Integer obj# isclient wsrvr
24689>>>>>>>>>>>>>>>        Get Server to obj#
24690>>>>>>>>>>>>>>>        // as of 17.0, containers will be added as a DEO so it receives the Refresh message
24690>>>>>>>>>>>>>>>        If (obj# <> 0) ;            Send remove_user_interface to obj# Self
24693>>>>>>>>>>>>>>>        Get Watched_Servers to wsrvr
24694>>>>>>>>>>>>>>>        If wsrvr ;            Send remove_user_interface to wsrvr Self True // TRUE for watchers
24697>>>>>>>>>>>>>>>        Set Refresh_dirty_state to True
24698>>>>>>>>>>>>>>>    End_Procedure
24699>>>>>>>>>>>>>>>    
24699>>>>>>>>>>>>>>>    
24699>>>>>>>>>>>>>>>    //   This function returns the object id of the database server which
24699>>>>>>>>>>>>>>>    //   encloses this object, if any.  Note that only the Data_Set class
24699>>>>>>>>>>>>>>>    //   defines this function to return anything other than 0.
24699>>>>>>>>>>>>>>>    //
24699>>>>>>>>>>>>>>>    //   This function is used with delegation to locate the Data_Set
24699>>>>>>>>>>>>>>>    //   which is the closest parent of this object.
24699>>>>>>>>>>>>>>>    //
24699>>>>>>>>>>>>>>>    Function Find_Server Returns Integer
24701>>>>>>>>>>>>>>>    End_Function
24702>>>>>>>>>>>>>>>    
24702>>>>>>>>>>>>>>>    Register_Function Server Returns Integer
24702>>>>>>>>>>>>>>>    
24702>>>>>>>>>>>>>>>    
24702>>>>>>>>>>>>>>>    //   This function returns the object id of the database agent of this object,
24702>>>>>>>>>>>>>>>    //   or 0.
24702>>>>>>>>>>>>>>>    Function Locate_Server Returns Integer
24704>>>>>>>>>>>>>>>        Function_Return (Server(Self))
24705>>>>>>>>>>>>>>>    End_Function
24706>>>>>>>>>>>>>>>    
24706>>>>>>>>>>>>>>>    
24706>>>>>>>>>>>>>>>    //   This function returns the object id of the database agent of this
24706>>>>>>>>>>>>>>>    //   object, or 0.
24706>>>>>>>>>>>>>>>    //   If this object's Server is 0, this object's parent's Server is
24706>>>>>>>>>>>>>>>    //   returned, if any.
24706>>>>>>>>>>>>>>>    //
24706>>>>>>>>>>>>>>>    // Notes
24706>>>>>>>>>>>>>>>    //
24706>>>>>>>>>>>>>>>    //   This function is used to allow nested data-entry objects to use the
24706>>>>>>>>>>>>>>>    //   database agent defined by their parent object.
24706>>>>>>>>>>>>>>>    //
24706>>>>>>>>>>>>>>>    Function Server Returns Integer
24708>>>>>>>>>>>>>>>        Integer obj#
24708>>>>>>>>>>>>>>>        Get private.Server to obj#
24709>>>>>>>>>>>>>>>        If (obj# = 0 and Component_State(Self)) ;            Function_Return (Locate_Server(parent(Self)))
24712>>>>>>>>>>>>>>>        Function_Return obj#
24713>>>>>>>>>>>>>>>    End_Function
24714>>>>>>>>>>>>>>>    
24714>>>>>>>>>>>>>>>    
24714>>>>>>>>>>>>>>>    //   This procedure sets the value of the Server property of this object,
24714>>>>>>>>>>>>>>>    //   notifying child-objects of the change, and destroying and creating
24714>>>>>>>>>>>>>>>    //   connections with database agents, as required.
24714>>>>>>>>>>>>>>>    //
24714>>>>>>>>>>>>>>>    //   If the Server of this object is changed while this object is inactive,
24714>>>>>>>>>>>>>>>    //   no notification of child-objects is required or performed.
24714>>>>>>>>>>>>>>>    Procedure Set Server Integer newVal
24716>>>>>>>>>>>>>>>        Integer oldVal
24716>>>>>>>>>>>>>>>        Set explicit_server_state to (newVal <> 0)
24717>>>>>>>>>>>>>>>        Get Server to oldVal
24718>>>>>>>>>>>>>>>        If (newVal <> 0) ;            Set private.Server to (object_id(newVal))
24721>>>>>>>>>>>>>>>        Else ;            Set private.Server to newVal
24723>>>>>>>>>>>>>>>        If (active_state(Self)) Begin
24725>>>>>>>>>>>>>>>            Broadcast Send server_changed oldVal newVal
24727>>>>>>>>>>>>>>>            If (oldVal <> 0) ;                Send remove_deo_from_server  //detach from current server
24730>>>>>>>>>>>>>>>            If (newval <> 0) ;                Send attach_deo_to_server    //attach to new server
24733>>>>>>>>>>>>>>>        End
24733>>>>>>>>>>>>>>>>
24733>>>>>>>>>>>>>>>    End_Procedure
24734>>>>>>>>>>>>>>>    
24734>>>>>>>>>>>>>>>    //   This procedure servers as notification of a change in the connection
24734>>>>>>>>>>>>>>>    //   of this object's parent to its database agent.  If this object uses
24734>>>>>>>>>>>>>>>    //   its parent's database agent by default (see the Server and Find_Server
24734>>>>>>>>>>>>>>>    //   functions, above), it must disconnect from the old agent and connect
24734>>>>>>>>>>>>>>>    //   with the new agent.
24734>>>>>>>>>>>>>>>    Procedure server_changed Integer oldVal Integer newVal
24736>>>>>>>>>>>>>>>        Integer oldSrvr
24736>>>>>>>>>>>>>>>        // as of 17.0, containers will be added as a DEO so it receives the Refresh message
24736>>>>>>>>>>>>>>>        Get private.Server to oldSrvr
24737>>>>>>>>>>>>>>>        If (oldSrvr = 0) Begin  //assumes Server(self) = oldVal by deleg
24739>>>>>>>>>>>>>>>            If (oldVal <> 0) ;                Send remove_user_interface to oldVal Self
24742>>>>>>>>>>>>>>>            If (newVal <> 0) ;                Send add_user_interface to newVal Self
24745>>>>>>>>>>>>>>>        End
24745>>>>>>>>>>>>>>>>
24745>>>>>>>>>>>>>>>    End_Procedure
24746>>>>>>>>>>>>>>>    
24746>>>>>>>>>>>>>>>    
24746>>>>>>>>>>>>>>>    //   This procedure empties the Watched_Servers broadcaster, after
24746>>>>>>>>>>>>>>>    //   detaching this object from all of the broadcaster's elements.
24746>>>>>>>>>>>>>>>    //   This procedure is invoked by Find_Servers_to_Watch, in preparation
24746>>>>>>>>>>>>>>>    //   for a scan. Deletes both sets of watched servers
24746>>>>>>>>>>>>>>>    //
24746>>>>>>>>>>>>>>>    Procedure delete_watched_servers
24748>>>>>>>>>>>>>>>        Integer vis#
24748>>>>>>>>>>>>>>>        
24748>>>>>>>>>>>>>>>        Get watched_servers to vis#
24749>>>>>>>>>>>>>>>        If vis# Begin
24751>>>>>>>>>>>>>>>            Send Remove_User_Interface to vis# Self True //detach from all, TRUE for watchers
24752>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24753>>>>>>>>>>>>>>>            Send delete_Data to vis#                    //empty it
24754>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24755>>>>>>>>>>>>>>>        End
24755>>>>>>>>>>>>>>>>
24755>>>>>>>>>>>>>>>        
24755>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to vis#
24756>>>>>>>>>>>>>>>        If vis# Begin
24758>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24759>>>>>>>>>>>>>>>            Send delete_Data to vis#                    //empty it
24760>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24761>>>>>>>>>>>>>>>        End
24761>>>>>>>>>>>>>>>>
24761>>>>>>>>>>>>>>>    End_Procedure
24762>>>>>>>>>>>>>>>    
24762>>>>>>>>>>>>>>>    //   This procedure adds the specified object id (obj#) to this object's
24762>>>>>>>>>>>>>>>    //   set of database agents who are merely 'watched', and establishes a
24762>>>>>>>>>>>>>>>    //   connection between the database agent and this object.
24762>>>>>>>>>>>>>>>    Procedure add_watched_server Integer obj#
24764>>>>>>>>>>>>>>>        Integer vis# ndx
24764>>>>>>>>>>>>>>>        Get watched_servers to vis#
24765>>>>>>>>>>>>>>>        // if w server does not exist, first create it
24765>>>>>>>>>>>>>>>        If (Vis# = 0) Begin
24767>>>>>>>>>>>>>>>            Get Create of Desktop U_Broadcaster to Vis#
24768>>>>>>>>>>>>>>>            Set Watched_Servers to Vis#
24769>>>>>>>>>>>>>>>        End
24769>>>>>>>>>>>>>>>>
24769>>>>>>>>>>>>>>>        //
24769>>>>>>>>>>>>>>>        Set broadcast_state of vis# to False
24770>>>>>>>>>>>>>>>        Get find_element of vis# obj# to ndx
24771>>>>>>>>>>>>>>>        If (ndx < 0) ;            Send add_element to vis# obj#
24774>>>>>>>>>>>>>>>        Set broadcast_state of vis# to True
24775>>>>>>>>>>>>>>>        If (ndx lt 0 and active_State(Self)) ;            Send add_user_interface to obj# Self True // TRUE for watchers
24778>>>>>>>>>>>>>>>    End_Procedure
24779>>>>>>>>>>>>>>>    
24779>>>>>>>>>>>>>>>    Procedure add_ChangedStateWatched_Servers Integer obj#
24781>>>>>>>>>>>>>>>        Integer vis# ndx
24781>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to vis#
24782>>>>>>>>>>>>>>>        If (Vis# = 0) Begin
24784>>>>>>>>>>>>>>>            Get Create of Desktop U_Broadcaster to Vis#
24785>>>>>>>>>>>>>>>            Set ChangedStateWatched_Servers to Vis#
24786>>>>>>>>>>>>>>>        End
24786>>>>>>>>>>>>>>>>
24786>>>>>>>>>>>>>>>        //
24786>>>>>>>>>>>>>>>        Set broadcast_state of vis# to False
24787>>>>>>>>>>>>>>>        Get find_element of vis# obj# to ndx
24788>>>>>>>>>>>>>>>        If (ndx < 0) ;            Send add_element to vis# obj#
24791>>>>>>>>>>>>>>>        Set broadcast_state of vis# to True
24792>>>>>>>>>>>>>>>    End_Procedure
24793>>>>>>>>>>>>>>>    
24793>>>>>>>>>>>>>>>    
24793>>>>>>>>>>>>>>>    //   This procedure removes the specified object id (obj#) from this object's
24793>>>>>>>>>>>>>>>    //   set of database agents who are merely 'watched', and destroys the
24793>>>>>>>>>>>>>>>    //   connection between the database agent and this object.
24793>>>>>>>>>>>>>>>    Procedure remove_watched_server Integer obj#
24795>>>>>>>>>>>>>>>        Integer vis# ndx
24795>>>>>>>>>>>>>>>        Get watched_servers to vis#
24796>>>>>>>>>>>>>>>        // Only if w server exists
24796>>>>>>>>>>>>>>>        If vis# Begin
24798>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24799>>>>>>>>>>>>>>>            Get find_element of vis# obj# to ndx
24800>>>>>>>>>>>>>>>            If (ndx >= 0) ;                Send remove_element to vis# obj#
24803>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24804>>>>>>>>>>>>>>>            If (ndx >= 0 and active_State(Self)) ;                Send remove_user_interface to obj# Self True // TRUE for watchers
24807>>>>>>>>>>>>>>>        End
24807>>>>>>>>>>>>>>>>
24807>>>>>>>>>>>>>>>    End_Procedure
24808>>>>>>>>>>>>>>>    
24808>>>>>>>>>>>>>>>    //   This procedure causes the scanning of this object's items' fields,
24808>>>>>>>>>>>>>>>    //   and the production of a set of database agents who should be 'watched'.
24808>>>>>>>>>>>>>>>    //   This procedure depends completely upon Find_Servers_To_Watch, below.
24808>>>>>>>>>>>>>>>    //
24808>>>>>>>>>>>>>>>    Procedure Scan_Servers
24810>>>>>>>>>>>>>>>        Send find_servers_to_watch False
24811>>>>>>>>>>>>>>>    End_Procedure
24812>>>>>>>>>>>>>>>    
24812>>>>>>>>>>>>>>>    //   This procedure scans the fields of this object's items to determine
24812>>>>>>>>>>>>>>>    //   what other database agents (data_sets) other than this object's Server
24812>>>>>>>>>>>>>>>    //   should be 'watched' (for data changes).
24812>>>>>>>>>>>>>>>    //   This procedure is invoked once per object, the first time the object
24812>>>>>>>>>>>>>>>    //   is activated.  If the data_file, data_field, and/or main_file of this
24812>>>>>>>>>>>>>>>    //   object are changed (don't change them while this object is active!),
24812>>>>>>>>>>>>>>>    //   set Private.Servers_Scanned to FALSE to force this object to scan
24812>>>>>>>>>>>>>>>    //   again (when it is next activated).
24812>>>>>>>>>>>>>>>    //
24812>>>>>>>>>>>>>>>    
24812>>>>>>>>>>>>>>>    // 17.0: The logic has been retooled to add more watched servers to the DDOs. This is done so
24812>>>>>>>>>>>>>>>    // DD operations will send Refresh to these additional watched-servers. There are two changes:
24812>>>>>>>>>>>>>>>    // 1. Containers are now made watched servers for the Server and all parent servers
24812>>>>>>>>>>>>>>>    // 2. Non-file.field DEOs (e.g., expressions) are made watched servers for the server (which it
24812>>>>>>>>>>>>>>>    //    already did and for all parent servers. Without this, parent entry_item expressions were not
24812>>>>>>>>>>>>>>>    //    getting updated
24812>>>>>>>>>>>>>>>    // Here is how watched-servers works.
24812>>>>>>>>>>>>>>>    // Each DEO attaches and detaches from its Server by sending Add_User_interface and Remove_User_interface
24812>>>>>>>>>>>>>>>    // to the server DD. Once attached, the DD knows about this DEO and sends messages to it as needed (Refresh,
24812>>>>>>>>>>>>>>>    // Entry_Update, etc.). In addition, a DEO may need to attach a parent DDO so that changes in that parent DD
24812>>>>>>>>>>>>>>>    // results in those messages being sent. This is needed if the binding table in entry_item refers to a parent
24812>>>>>>>>>>>>>>>    // table. So we need to send Add_User_interface and Remove_User_interface to that parent server as well. If a DEO
24812>>>>>>>>>>>>>>>    // has multiple, there could be multiple parent servers. As of 17.0, we are also attaching to parent servers if
24812>>>>>>>>>>>>>>>    // we are unsure about how the DEO is being used. If an expression is used, it might need to be updated when
24812>>>>>>>>>>>>>>>    // a parent (or any ancestor) changes. Each DEO keeps track of servers that it attaches to and this is referred
24812>>>>>>>>>>>>>>>    // to as the watched_server list. This list is maintained so the DEO knows which DDOs to attach and detach to.
24812>>>>>>>>>>>>>>>    
24812>>>>>>>>>>>>>>>    
24812>>>>>>>>>>>>>>>    Procedure find_servers_to_watch Integer tableFlag
24814>>>>>>>>>>>>>>>        Integer i file# obj# maxitems count p srvr# self# srvrfile
24814>>>>>>>>>>>>>>>        String fileStr fStr
24814>>>>>>>>>>>>>>>        Boolean bContainer bDoAll
24814>>>>>>>>>>>>>>>        
24814>>>>>>>>>>>>>>>        Get Client_Area_State to bContainer
24815>>>>>>>>>>>>>>>        Set private.Servers_Scanned to True
24816>>>>>>>>>>>>>>>        
24816>>>>>>>>>>>>>>>        Get Server to srvr#
24817>>>>>>>>>>>>>>>        
24817>>>>>>>>>>>>>>>        If (srvr#=0) Begin
24819>>>>>>>>>>>>>>>            Procedure_Return
24820>>>>>>>>>>>>>>>        End
24820>>>>>>>>>>>>>>>>
24820>>>>>>>>>>>>>>>        
24820>>>>>>>>>>>>>>>        Send delete_watched_servers  //empty Watched_Servers broadcaster first
24821>>>>>>>>>>>>>>>        
24821>>>>>>>>>>>>>>>        Get main_file of srvr# to srvrfile  // data-set's main-file
24822>>>>>>>>>>>>>>>        
24822>>>>>>>>>>>>>>>        If bContainer Begin
24824>>>>>>>>>>>>>>>            // containers should get added to all parent DDOs
24824>>>>>>>>>>>>>>>            Send WatchAllParentServers srvr#
24825>>>>>>>>>>>>>>>            Procedure_Return
24826>>>>>>>>>>>>>>>        End
24826>>>>>>>>>>>>>>>>
24826>>>>>>>>>>>>>>>        
24826>>>>>>>>>>>>>>>        If (tableFlag <> 0) ;            Get Prototype_Object to self# // tables
24829>>>>>>>>>>>>>>>        Else ;            Move Self to self# // forms and text windows
24831>>>>>>>>>>>>>>>        
24831>>>>>>>>>>>>>>>        Get item_count of self# to maxitems
24832>>>>>>>>>>>>>>>        Decrement maxitems
24833>>>>>>>>>>>>>>>        
24833>>>>>>>>>>>>>>>        // if no items do nothing
24833>>>>>>>>>>>>>>>        // if one item do quick check
24833>>>>>>>>>>>>>>>        // if multiple items do it the hard way
24833>>>>>>>>>>>>>>>        
24833>>>>>>>>>>>>>>>        If (maxitems<0) Begin
24835>>>>>>>>>>>>>>>            // if no items, which is unusual, we don't know what this DEO is so we will treat it like a container
24835>>>>>>>>>>>>>>>            // and add it as a watched server for all DDOs
24835>>>>>>>>>>>>>>>            Send WatchAllParentServers srvr#
24836>>>>>>>>>>>>>>>            Procedure_Return  // no items
24837>>>>>>>>>>>>>>>        End
24837>>>>>>>>>>>>>>>>
24837>>>>>>>>>>>>>>>        
24837>>>>>>>>>>>>>>>        If (maxitems=0) Begin // only 1 item - skip most of the nonsense
24839>>>>>>>>>>>>>>>            Get data_file of self# 0 to file#
24840>>>>>>>>>>>>>>>            // we need watched server if file exists, it is not the main file
24840>>>>>>>>>>>>>>>            // and is not an updating file (as opposed to updating data-set).
24840>>>>>>>>>>>>>>>            If (file#>0 and file#<>srvrfile) Begin
24842>>>>>>>>>>>>>>>                Get which_data_set of srvr# file# to obj#
24843>>>>>>>>>>>>>>>                If (obj# <> 0 and obj# <> srvr#) Begin
24845>>>>>>>>>>>>>>>                    Send add_Watched_server obj#
24846>>>>>>>>>>>>>>>                    Send add_ChangedStateWatched_Servers obj#
24847>>>>>>>>>>>>>>>                End
24847>>>>>>>>>>>>>>>>
24847>>>>>>>>>>>>>>>            End
24847>>>>>>>>>>>>>>>>
24847>>>>>>>>>>>>>>>            Else If (file#=0) Begin
24850>>>>>>>>>>>>>>>                // if no file (e.g., expression) we don't know when it changes so we tell all servers
24850>>>>>>>>>>>>>>>                // that this is a watcher
24850>>>>>>>>>>>>>>>                Send WatchAllParentServers srvr#
24851>>>>>>>>>>>>>>>            End
24851>>>>>>>>>>>>>>>>
24851>>>>>>>>>>>>>>>            If File# ;                Send Copy_Item_Options Srvr# file# (Data_Field(Self#,0)) Self# 0
24854>>>>>>>>>>>>>>>        End
24854>>>>>>>>>>>>>>>>
24854>>>>>>>>>>>>>>>        Else Begin  // multiple items - do what you must
24855>>>>>>>>>>>>>>>            Move -1 to count
24856>>>>>>>>>>>>>>>            Move "," to fileStr
24857>>>>>>>>>>>>>>>            If tableFlag Begin
24859>>>>>>>>>>>>>>>                Get main_file to file#
24860>>>>>>>>>>>>>>>                If (file# <> srvrfile) Begin    // only do this if mainfile is not the srvr file
24862>>>>>>>>>>>>>>>                    Append fileStr file# ","   //insert mainfile to be sure it's watched
24864>>>>>>>>>>>>>>>                    Increment count
24865>>>>>>>>>>>>>>>                End
24865>>>>>>>>>>>>>>>>
24865>>>>>>>>>>>>>>>            End
24865>>>>>>>>>>>>>>>>
24865>>>>>>>>>>>>>>>            For i from 0 to maxitems
24871>>>>>>>>>>>>>>>>
24871>>>>>>>>>>>>>>>                Get data_file of self# i to file#
24872>>>>>>>>>>>>>>>                If (file#=0) Begin
24874>>>>>>>>>>>>>>>                    // as soon as we don't know what the item is used for we will have
24874>>>>>>>>>>>>>>>                    // to attach to all parent DDOs.
24874>>>>>>>>>>>>>>>                    Move True to bDoAll
24875>>>>>>>>>>>>>>>                End
24875>>>>>>>>>>>>>>>>
24875>>>>>>>>>>>>>>>                If (file# > 0 and file#<>srvrfile and ;                    not(fileStr contains (","+String(file#)+",")) ) Begin
24877>>>>>>>>>>>>>>>                    Move (fileStr+String(file#) + ",") to fileStr
24878>>>>>>>>>>>>>>>                    Increment count
24879>>>>>>>>>>>>>>>                End
24879>>>>>>>>>>>>>>>>
24879>>>>>>>>>>>>>>>                If File# ;                    Send Copy_Item_Options Srvr# file# (Data_Field(Self#,i)) Self# i
24882>>>>>>>>>>>>>>>            Loop
24883>>>>>>>>>>>>>>>>
24883>>>>>>>>>>>>>>>            
24883>>>>>>>>>>>>>>>            // if an item's binding table is unknown, we watch all parent DDOs.
24883>>>>>>>>>>>>>>>            If bDoAll Begin
24885>>>>>>>>>>>>>>>                Send WatchAllParentServers srvr#
24886>>>>>>>>>>>>>>>            End
24886>>>>>>>>>>>>>>>>
24886>>>>>>>>>>>>>>>            Else Begin
24887>>>>>>>>>>>>>>>                If (count >= 0) Begin // any watched items?
24889>>>>>>>>>>>>>>>                    Move (Right(fileStr, length(fileStr) - 1))  to fileStr  //remove leading comma
24890>>>>>>>>>>>>>>>                    For i from 0 to count
24896>>>>>>>>>>>>>>>>
24896>>>>>>>>>>>>>>>                        Move (Pos( "," ,fileStr)) to p
24897>>>>>>>>>>>>>>>                        If (p > 1) Begin
24899>>>>>>>>>>>>>>>                            Move (Left( fileStr , p-1)) to fStr
24900>>>>>>>>>>>>>>>                            Move (Right( fileStr, length(fileStr) - p)) to fileStr
24901>>>>>>>>>>>>>>>                            Move fStr to file#
24902>>>>>>>>>>>>>>>                            Get which_data_set of srvr# file# to obj#
24903>>>>>>>>>>>>>>>                            If (obj# <> 0 and obj# <> srvr#) Begin
24905>>>>>>>>>>>>>>>                                Send add_Watched_server obj#
24906>>>>>>>>>>>>>>>                                Send add_ChangedStateWatched_Servers obj#
24907>>>>>>>>>>>>>>>                            End
24907>>>>>>>>>>>>>>>>
24907>>>>>>>>>>>>>>>                        End
24907>>>>>>>>>>>>>>>>
24907>>>>>>>>>>>>>>>                    Loop
24908>>>>>>>>>>>>>>>>
24908>>>>>>>>>>>>>>>                End
24908>>>>>>>>>>>>>>>>
24908>>>>>>>>>>>>>>>            End
24908>>>>>>>>>>>>>>>>
24908>>>>>>>>>>>>>>>        End
24908>>>>>>>>>>>>>>>>
24908>>>>>>>>>>>>>>>    End_Procedure
24909>>>>>>>>>>>>>>>    
24909>>>>>>>>>>>>>>>    // This does nothing. Other sub-classes (or later mixins) should add
24909>>>>>>>>>>>>>>>    // logic to this.
24909>>>>>>>>>>>>>>>    Procedure Copy_Item_Options Integer iDSO Integer iFile Integer iField ;            Integer iDEO Integer iItem
24911>>>>>>>>>>>>>>>    End_Procedure
24912>>>>>>>>>>>>>>>    
24912>>>>>>>>>>>>>>>    // This does little. Other sub-classes (or later mixins) should add
24912>>>>>>>>>>>>>>>    // logic to this.
24912>>>>>>>>>>>>>>>    Procedure Define_Extended_DEO_Mixin
24914>>>>>>>>>>>>>>>    End_Procedure
24915>>>>>>>>>>>>>>>    
24915>>>>>>>>>>>>>>>    
24915>>>>>>>>>>>>>>>    // created for Nesting support
24915>>>>>>>>>>>>>>>    Procedure Mark_As_Component
24917>>>>>>>>>>>>>>>        Integer ser#
24917>>>>>>>>>>>>>>>        Set Component_State to True
24918>>>>>>>>>>>>>>>        Delegate Set Has_Components_State to True
24920>>>>>>>>>>>>>>>        Get private.Server to ser#
24921>>>>>>>>>>>>>>>        If (ser# = 0) Begin
24923>>>>>>>>>>>>>>>            Delegate Get Locate_Server to ser#
24925>>>>>>>>>>>>>>>            If (ser# <> 0) ;                Set private.Server to ser#
24928>>>>>>>>>>>>>>>        End
24928>>>>>>>>>>>>>>>>
24928>>>>>>>>>>>>>>>    End_Procedure
24929>>>>>>>>>>>>>>>    
24929>>>>>>>>>>>>>>>    // This only gets called when the developer is killing this object. During application
24929>>>>>>>>>>>>>>>    // shut-down, only destroy_object is called. This augmentation destroys the watched broadcaster
24929>>>>>>>>>>>>>>>    // (which is sitting on the desktop). During program shut down we don't care if this is called
24929>>>>>>>>>>>>>>>    // because it is getting destroyed anyway. We are making the assumption that a developer controlled
24929>>>>>>>>>>>>>>>    // destroy will always be called with the watcher still existing.
24929>>>>>>>>>>>>>>>    
24929>>>>>>>>>>>>>>>    Procedure Destroy
24931>>>>>>>>>>>>>>>        Handle hoWatched
24931>>>>>>>>>>>>>>>        Set Changed_State to False //   is this really needed anymore???
24932>>>>>>>>>>>>>>>        // if non 0, The watched server, must still exist.
24932>>>>>>>>>>>>>>>        Get Watched_Servers to hoWatched
24933>>>>>>>>>>>>>>>        If hoWatched Begin
24935>>>>>>>>>>>>>>>            Set Broadcast_State of hoWatched to False
24936>>>>>>>>>>>>>>>            Send Destroy of hoWatched     // destroy the bcaster
24937>>>>>>>>>>>>>>>        End
24937>>>>>>>>>>>>>>>>
24937>>>>>>>>>>>>>>>        // if non 0, The bound watched server, must still exist.
24937>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to hoWatched
24938>>>>>>>>>>>>>>>        If hoWatched Begin
24940>>>>>>>>>>>>>>>            Set Broadcast_State of hoWatched to False
24941>>>>>>>>>>>>>>>            Send Destroy of hoWatched     // destroy the bcaster
24942>>>>>>>>>>>>>>>        End
24942>>>>>>>>>>>>>>>>
24942>>>>>>>>>>>>>>>        Forward Send Destroy
24944>>>>>>>>>>>>>>>    End_Procedure
24945>>>>>>>>>>>>>>>    
24945>>>>>>>>>>>>>>>    
24945>>>>>>>>>>>>>>>    Function Should_Save Returns Integer
24947>>>>>>>>>>>>>>>        Integer Obj# Chngd
24947>>>>>>>>>>>>>>>        Get Server to Obj#
24948>>>>>>>>>>>>>>>        Get Changed_state to Chngd
24949>>>>>>>>>>>>>>>        Function_Return ( Chngd or (obj# <> 0 and Should_Save(obj#)) )
24950>>>>>>>>>>>>>>>    End_Function
24951>>>>>>>>>>>>>>>    
24951>>>>>>>>>>>>>>>    // Added server scan logic here instead of add_focus.
24951>>>>>>>>>>>>>>>    Procedure Attach_Deo_To_Server
24953>>>>>>>>>>>>>>>        Integer obj# isclient srvscn wsrvr
24953>>>>>>>>>>>>>>>        Get Server to obj#
24954>>>>>>>>>>>>>>>        Get client_area_state to isclient
24955>>>>>>>>>>>>>>>        If (obj# <> 0) ;            Send add_user_interface to obj# Self
24958>>>>>>>>>>>>>>>        Get private.Servers_Scanned to srvscn
24959>>>>>>>>>>>>>>>        If (srvscn = 0) ;            Send scan_servers
24962>>>>>>>>>>>>>>>        Get Watched_Servers to wsrvr
24963>>>>>>>>>>>>>>>        If wsrvr Send add_user_interface ;            to wsrvr Self True // TRUE for watchers
24966>>>>>>>>>>>>>>>        If (obj# <> 0 and isclient = 0) ;            Send update_dependent_items
24969>>>>>>>>>>>>>>>    End_Procedure
24970>>>>>>>>>>>>>>>    
24970>>>>>>>>>>>>>>>    // Removed server scan logic and moved it to attach-deo_to_server
24970>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
24972>>>>>>>>>>>>>>>        Integer srvscn retval msg
24972>>>>>>>>>>>>>>>        //
24972>>>>>>>>>>>>>>>        // standard DEO behavior
24972>>>>>>>>>>>>>>>        //
24972>>>>>>>>>>>>>>>        Forward Get msg_Add_Focus hoParent to retval
24974>>>>>>>>>>>>>>>        If retval ;            Procedure_Return retval
24977>>>>>>>>>>>>>>>        
24977>>>>>>>>>>>>>>>        If (client_area_State(Self) = 0) ; //clients already broadcast            Broadcast NO_STOP Send add_focus Self
24982>>>>>>>>>>>>>>>        //
24982>>>>>>>>>>>>>>>        // server augmentation
24982>>>>>>>>>>>>>>>        //
24982>>>>>>>>>>>>>>>        If (focus_mode(Self) <> NO_ACTIVATE and Active_State(Self)) ;            Send attach_DEO_to_server
24985>>>>>>>>>>>>>>>        
24985>>>>>>>>>>>>>>>        // last thing to do is send custom message. With list deos
24985>>>>>>>>>>>>>>>        // msg is probably initialize_list. With non-list deos it
24985>>>>>>>>>>>>>>>        // is probably nothing
24985>>>>>>>>>>>>>>>        Get add_focus_msg to msg
24986>>>>>>>>>>>>>>>        If msg ;            Send msg
24989>>>>>>>>>>>>>>>    End_Procedure
24990>>>>>>>>>>>>>>>    
24990>>>>>>>>>>>>>>>    // Connect DEO to Server if Demanded (DoAllfg=t) or ;
24990>>>>>>>>>>>>>>>    // allowed  (static_server_State=t). Broadcast if children exist
24990>>>>>>>>>>>>>>>    Procedure Connect_DEOs_to_Servers Integer DoAllFg
24992>>>>>>>>>>>>>>>        If (DoAllfg or Static_Server_State(Self)) ;            Send Attach_Deo_to_Server
24995>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Connect_DEOs_to_Servers DoAllfg
24999>>>>>>>>>>>>>>>    End_Procedure
25000>>>>>>>>>>>>>>>    
25000>>>>>>>>>>>>>>>    // Disconnect DEOs from Servers according to rules. Broadcast
25000>>>>>>>>>>>>>>>    // to child components.
25000>>>>>>>>>>>>>>>    //
25000>>>>>>>>>>>>>>>    // Pass: DoAllMode
25000>>>>>>>>>>>>>>>    //    DETACH_NEVER        Never
25000>>>>>>>>>>>>>>>    //    DETACH_IF_NO_CHANGE Do if changed_state=F
25000>>>>>>>>>>>>>>>    //    DETACH_ALWAYS       Do it no matter what
25000>>>>>>>>>>>>>>>    //    DETACH_IF_ALLOWED   Do if changed_state=F and auto_attach
25000>>>>>>>>>>>>>>>    //                        (I don't think this will be needed!)
25000>>>>>>>>>>>>>>>    //
25000>>>>>>>>>>>>>>>    Procedure Disconnect_DEOs_from_Servers Integer DoAllMode
25002>>>>>>>>>>>>>>>        If (DoAllMode <> DETACH_NEVER) Begin
25004>>>>>>>>>>>>>>>            If ( DoAllMode=DETACH_ALWAYS or ; // do all no matter what                ( (Changed_state(Self)=0) and ;                ( (DoAllMode=DETACH_IF_NO_CHANGE) or  ;                (Static_Server_State(Self)) ) ) ) ;                Send Remove_deo_from_server
25007>>>>>>>>>>>>>>>            If (Has_Components_State(Self)) ;                Broadcast Send Disconnect_DEOs_from_Servers DoAllMode
25011>>>>>>>>>>>>>>>        End
25011>>>>>>>>>>>>>>>>
25011>>>>>>>>>>>>>>>    End_Procedure
25012>>>>>>>>>>>>>>>    
25012>>>>>>>>>>>>>>>    // Changed to not remove from server if static.
25012>>>>>>>>>>>>>>>    Procedure Remove_Object
25014>>>>>>>>>>>>>>>        Forward Send remove_object
25016>>>>>>>>>>>>>>>        // remove if not static and no changes
25016>>>>>>>>>>>>>>>        If ( Static_Server_State(Self)=0 and ;            Changed_State(Self)=0 ) ;  // only detach if unchanged!            Send remove_DEO_from_server
25019>>>>>>>>>>>>>>>    End_Procedure
25020>>>>>>>>>>>>>>>    
25020>>>>>>>>>>>>>>>    
25020>>>>>>>>>>>>>>>    // (JJT) Changed so that this respects Change_disabled_state. I don't
25020>>>>>>>>>>>>>>>    //       like this here but its the best I can think of. Therefore, all
25020>>>>>>>>>>>>>>>    //       objects using server.pkg must understand Change_disabled_state.
25020>>>>>>>>>>>>>>>    //
25020>>>>>>>>>>>>>>>    // (JJT) Checks deferred_state and if set do not change the
25020>>>>>>>>>>>>>>>    // changed state of the server object. This had been in datalist and is
25020>>>>>>>>>>>>>>>    // required to make deferred_state work right. Deferred_state was created
25020>>>>>>>>>>>>>>>    // to make selection-lists work correctly and as far as I am concerned it
25020>>>>>>>>>>>>>>>    // should be the only supported use of this. Therefore, I would not *ever*
25020>>>>>>>>>>>>>>>    // expect deferred_state to be set true in tables, entry_forms, or text_
25020>>>>>>>>>>>>>>>    // windows. Since deferred-state is known to this mixin the change
25020>>>>>>>>>>>>>>>    // belongs here - but I expect it to only ever change behaviors in
25020>>>>>>>>>>>>>>>    // selection-lists.
25020>>>>>>>>>>>>>>>    
25020>>>>>>>>>>>>>>>    
25020>>>>>>>>>>>>>>>    // Changed to not remove from server if static.
25020>>>>>>>>>>>>>>>    Procedure Set Changed_State Integer newVal
25022>>>>>>>>>>>>>>>        Integer srvr# wsrvr
25022>>>>>>>>>>>>>>>        If not (Change_Disabled_State(Self)) Begin
25024>>>>>>>>>>>>>>>            Forward Set Changed_State to newVal
25026>>>>>>>>>>>>>>>            Get server to srvr#
25027>>>>>>>>>>>>>>>            
25027>>>>>>>>>>>>>>>            // if deferred keep the server out of it.
25027>>>>>>>>>>>>>>>            If not (deferred_State(Self)) Begin
25029>>>>>>>>>>>>>>>                If (newVal and srvr#) Begin
25031>>>>>>>>>>>>>>>                    Set Changed_State of srvr# to True
25032>>>>>>>>>>>>>>>                    // We also set changed_state of all "foreign" servers. These
25032>>>>>>>>>>>>>>>                    // are the ones whose Data_File is a parent File
25032>>>>>>>>>>>>>>>                    Get ChangedStateWatched_Servers to wsrvr
25033>>>>>>>>>>>>>>>                    If wsrvr ;                        Set Changed_State of wSrvr to True
25036>>>>>>>>>>>>>>>                End
25036>>>>>>>>>>>>>>>>
25036>>>>>>>>>>>>>>>                
25036>>>>>>>>>>>>>>>                // Remove is changed-state=false, not active and not static
25036>>>>>>>>>>>>>>>                If ( not(newVal) and not(Active_State(Self)) and ;                    not(Static_Server_State(Self)) ) ;                    Send remove_DEO_from_Server
25039>>>>>>>>>>>>>>>            End
25039>>>>>>>>>>>>>>>>
25039>>>>>>>>>>>>>>>        End
25039>>>>>>>>>>>>>>>>
25039>>>>>>>>>>>>>>>    End_Procedure
25040>>>>>>>>>>>>>>>    
25040>>>>>>>>>>>>>>>    // When an object is created this sets the default value for
25040>>>>>>>>>>>>>>>    // Static_Server_state. If a parent DEO exists it will use its
25040>>>>>>>>>>>>>>>    // static_server_state property. An Entry_view_Client0 object sets
25040>>>>>>>>>>>>>>>    // this - this way view based daf programs will use the new behavior
25040>>>>>>>>>>>>>>>    // (although it can be disabled)  but non-daf programs will work like
25040>>>>>>>>>>>>>>>    // they always did.
25040>>>>>>>>>>>>>>>    Function Default_Static_Server_State Returns Integer
25042>>>>>>>>>>>>>>>        Integer rVal
25042>>>>>>>>>>>>>>>        // We delegate to get the actual (not default) static state
25042>>>>>>>>>>>>>>>        // Note: Can't check with component_state - it not defined yet
25042>>>>>>>>>>>>>>>        Delegate Get Static_Server_State to rVal
25044>>>>>>>>>>>>>>>        Function_Return rVal
25045>>>>>>>>>>>>>>>    End_Function
25046>>>>>>>>>>>>>>>    
25046>>>>>>>>>>>>>>>    // This adds every parent DDO for the passed DDO to the DEO's list of DDOs to watch.
25046>>>>>>>>>>>>>>>    // It adds the parents and then does this recursively up the DDO tree.
25046>>>>>>>>>>>>>>>    // This means that this DEO will respond to any DD change for any server. This does not
25046>>>>>>>>>>>>>>>    Procedure WatchAllParentServers Handle hoDDO
25048>>>>>>>>>>>>>>>        Handle hoSrvr
25048>>>>>>>>>>>>>>>        Integer iServer iServers
25048>>>>>>>>>>>>>>>        Get Data_Set_Server_Count of hoDDO to iServers
25049>>>>>>>>>>>>>>>        For iServer from 0 to (iServers-1)
25055>>>>>>>>>>>>>>>>
25055>>>>>>>>>>>>>>>            Get Data_Set_Server of hoDDO iServer to hoSrvr
25056>>>>>>>>>>>>>>>            Send Add_Watched_Server hoSrvr
25057>>>>>>>>>>>>>>>            Send WatchAllParentServers hoSrvr
25058>>>>>>>>>>>>>>>        Loop
25059>>>>>>>>>>>>>>>>
25059>>>>>>>>>>>>>>>    End_Procedure
25060>>>>>>>>>>>>>>>    
25060>>>>>>>>>>>>>>>    
25060>>>>>>>>>>>>>>>End_Class
25061>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>>>//
25061>>>>>>>>>>>>>>>// The use of using on an object name is no longer supported. We will check for it's usage in case
25061>>>>>>>>>>>>>>>// developer's use this in old code.
25061>>>>>>>>>>>>>>>// Insetad of using, one should use "Set Server"
25061>>>>>>>>>>>>>>>//
25061>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>Use VERIFY.pkg        //include Verification support module
Including file: verify.pkg    (C:\Program Files\DataFlex 20.1\Pkg\verify.pkg)
25061>>>>>>>>>>>>>>>Use VDFBase.pkg
25061>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>>>Register_Function Component_State Returns Integer
25061>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>>>
25061>>>>>>>>>>>>>>>Class verify_mixin is a mixin
25062>>>>>>>>>>>>>>>    Procedure define_verify
25064>>>>>>>>>>>>>>>        Property Integer private.Verify_Save_Msg      0
25065>>>>>>>>>>>>>>>        Property Integer private.Verify_Delete_Msg    0
25066>>>>>>>>>>>>>>>        Property Integer private.Verify_Data_Loss_Msg 0
25067>>>>>>>>>>>>>>>    End_Procedure
25068>>>>>>>>>>>>>>>    
25068>>>>>>>>>>>>>>>    
25068>>>>>>>>>>>>>>>    Procedure Set Verify_Save_msg Integer val
25070>>>>>>>>>>>>>>>        Set private.Verify_Save_Msg to val
25071>>>>>>>>>>>>>>>    End_Procedure
25072>>>>>>>>>>>>>>>    
25072>>>>>>>>>>>>>>>    Procedure Set Verify_Delete_msg Integer val
25074>>>>>>>>>>>>>>>        Set private.Verify_Delete_Msg to val
25075>>>>>>>>>>>>>>>    End_Procedure
25076>>>>>>>>>>>>>>>    
25076>>>>>>>>>>>>>>>    Procedure Set Verify_Data_Loss_msg Integer val
25078>>>>>>>>>>>>>>>        Set private.Verify_Data_Loss_Msg to val
25079>>>>>>>>>>>>>>>    End_Procedure
25080>>>>>>>>>>>>>>>    
25080>>>>>>>>>>>>>>>    Function Verify_Save_msg Returns Integer
25082>>>>>>>>>>>>>>>        Integer retval
25082>>>>>>>>>>>>>>>        Get private.Verify_Save_Msg to retval
25083>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Save_Msg to retval
25087>>>>>>>>>>>>>>>        Function_Return retval
25088>>>>>>>>>>>>>>>    End_Function
25089>>>>>>>>>>>>>>>    
25089>>>>>>>>>>>>>>>    Function Verify_Delete_msg Returns Integer
25091>>>>>>>>>>>>>>>        Integer retval
25091>>>>>>>>>>>>>>>        Get private.Verify_Delete_Msg to retval
25092>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Delete_Msg to retval
25096>>>>>>>>>>>>>>>        Function_Return retval
25097>>>>>>>>>>>>>>>    End_Function
25098>>>>>>>>>>>>>>>    
25098>>>>>>>>>>>>>>>    
25098>>>>>>>>>>>>>>>    Function Verify_Data_Loss_msg Returns Integer
25100>>>>>>>>>>>>>>>        Integer retval
25100>>>>>>>>>>>>>>>        Get private.Verify_Data_Loss_Msg to retval
25101>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Data_Loss_Msg to retval
25105>>>>>>>>>>>>>>>        Function_Return retval
25106>>>>>>>>>>>>>>>    End_Function
25107>>>>>>>>>>>>>>>    
25107>>>>>>>>>>>>>>>    Function Verify_Save Returns Integer
25109>>>>>>>>>>>>>>>        Integer msg# retval
25109>>>>>>>>>>>>>>>        Get Verify_Save_Msg to msg#
25110>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25112>>>>>>>>>>>>>>>            Get msg# to retval
25113>>>>>>>>>>>>>>>            Function_Return retval
25114>>>>>>>>>>>>>>>        End
25114>>>>>>>>>>>>>>>>
25114>>>>>>>>>>>>>>>    End_Function
25115>>>>>>>>>>>>>>>    
25115>>>>>>>>>>>>>>>    Function Verify_Delete Returns Integer
25117>>>>>>>>>>>>>>>        Integer msg# retval
25117>>>>>>>>>>>>>>>        Get Verify_Delete_Msg to msg#
25118>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25120>>>>>>>>>>>>>>>            Get msg# to retval
25121>>>>>>>>>>>>>>>            Function_Return retval
25122>>>>>>>>>>>>>>>        End
25122>>>>>>>>>>>>>>>>
25122>>>>>>>>>>>>>>>    End_Function
25123>>>>>>>>>>>>>>>    
25123>>>>>>>>>>>>>>>    Function Verify_Data_Loss Returns Integer
25125>>>>>>>>>>>>>>>        Integer msg# retval
25125>>>>>>>>>>>>>>>        Get Verify_Data_Loss_Msg to msg#
25126>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25128>>>>>>>>>>>>>>>            Get msg# to retval
25129>>>>>>>>>>>>>>>            Function_Return retval
25130>>>>>>>>>>>>>>>        End
25130>>>>>>>>>>>>>>>>
25130>>>>>>>>>>>>>>>    End_Function
25131>>>>>>>>>>>>>>>    
25131>>>>>>>>>>>>>>>End_Class
25132>>>>>>>>>>>>>Use ACTIONBR.pkg      //include action-bar support module
Including file: Actionbr.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Actionbr.pkg)
25132>>>>>>>>>>>>>>>Use VDFBase.pkg
25132>>>>>>>>>>>>>>>
25132>>>>>>>>>>>>>>>Class Action_Bar_Mixin is a mixin
25133>>>>>>>>>>>>>>>    Procedure Define_Action_bar
25135>>>>>>>>>>>>>>>    End_Procedure
25136>>>>>>>>>>>>>>>    
25136>>>>>>>>>>>>>>>    Procedure Define_Access_Keys
25138>>>>>>>>>>>>>>>    End_Procedure
25139>>>>>>>>>>>>>>>    
25139>>>>>>>>>>>>>>>    Procedure Add_Action_bar
25141>>>>>>>>>>>>>>>    End_Procedure
25142>>>>>>>>>>>>>>>End_Class
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>Use AutoLcMx.pkg   // Auto locate of popup mixin
25143>>>>>>>>>>>>>Use DEODlgMx.pkg   // DEO delegation support
Including file: deodlgmx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\deodlgmx.pkg)
25143>>>>>>>>>>>>>>>Use VDFBase.pkg
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>>>Enum_List
25143>>>>>>>>>>>>>>>    Define DELEGATE_NEVER
25143>>>>>>>>>>>>>>>    Define DELEGATE_SERVER
25143>>>>>>>>>>>>>>>    Define DELEGATE_ALWAYS
25143>>>>>>>>>>>>>>>End_Enum_List
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>>>Register_Function component_state Returns Integer
25143>>>>>>>>>>>>>>>
25143>>>>>>>>>>>>>>>Class deo_delegate_mixin is a mixin
25144>>>>>>>>>>>>>>>    Procedure define_deo_delegate
25146>>>>>>>>>>>>>>>        
25146>>>>>>>>>>>>>>>        Property Integer DEO_Delegate_Mode     Delegate_Server
25147>>>>>>>>>>>>>>>        
25147>>>>>>>>>>>>>>>        Property Integer delegate_clear_state  True
25148>>>>>>>>>>>>>>>        
25148>>>>>>>>>>>>>>>        Property Integer delegate_delete_state True
25149>>>>>>>>>>>>>>>        
25149>>>>>>>>>>>>>>>        Property Integer delegate_find_state   False
25150>>>>>>>>>>>>>>>        
25150>>>>>>>>>>>>>>>        Property Integer delegate_save_state   True
25151>>>>>>>>>>>>>>>    End_Procedure
25152>>>>>>>>>>>>>>>    
25152>>>>>>>>>>>>>>>    Function should_delegate Returns Integer
25154>>>>>>>>>>>>>>>        Integer Mode Dlg_Obj
25154>>>>>>>>>>>>>>>        
25154>>>>>>>>>>>>>>>        Delegate Get Object_Id to Dlg_Obj
25156>>>>>>>>>>>>>>>        Get Deo_Delegate_Mode to Mode
25157>>>>>>>>>>>>>>>        Function_Return ( (((Mode = DELEGATE_SERVER) and ;            not(Explicit_Server_State(Self)) and ;            (Locate_Server(Self) <> Dlg_Obj)) or ; // don't delegate if the object to delegate to is a server.            (Mode = DELEGATE_ALWAYS)) and Component_State(Self))
25158>>>>>>>>>>>>>>>    End_Function
25159>>>>>>>>>>>>>>>    
25159>>>>>>>>>>>>>>>    Function Should_delegate_Clear Returns Integer
25161>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_clear_state(Self))
25162>>>>>>>>>>>>>>>    End_Function
25163>>>>>>>>>>>>>>>    
25163>>>>>>>>>>>>>>>    Function Should_delegate_Save Returns Integer
25165>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_Save_state(Self))
25166>>>>>>>>>>>>>>>    End_Function
25167>>>>>>>>>>>>>>>    
25167>>>>>>>>>>>>>>>    Function Should_delegate_Delete Returns Integer
25169>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_delete_state(Self))
25170>>>>>>>>>>>>>>>    End_Function
25171>>>>>>>>>>>>>>>    
25171>>>>>>>>>>>>>>>    Function Should_delegate_Find Returns Integer
25173>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_Find_state(Self))
25174>>>>>>>>>>>>>>>    End_Function
25175>>>>>>>>>>>>>>>    
25175>>>>>>>>>>>>>>>End_Class
25176>>>>>>>>>>>>>>>
25176>>>>>>>>>>>>>>>//  During a clear (or a save/delete which sends clear) object-validation is
25176>>>>>>>>>>>>>>>//  properly shut off. However, the false assumption had been made that the
25176>>>>>>>>>>>>>>>//  DEO request_clear/clear_all messages originated with the object that had
25176>>>>>>>>>>>>>>>//  the focus. This was never true and is now even less likely to be true
25176>>>>>>>>>>>>>>>//  with the request_??? delegation method. The proper solution is to shut
25176>>>>>>>>>>>>>>>//  off object-validation in the focus object. The problem here is that
25176>>>>>>>>>>>>>>>//  the focus object may not understand this message (text_windows, buttons,
25176>>>>>>>>>>>>>>>//  etc). The work-around for now is to make sure that all objects understand
25176>>>>>>>>>>>>>>>//  these message. We can not directly add an Object_Validation message to the
25176>>>>>>>>>>>>>>>//  desktop (Object class). Because this message is internal this didn't work.
25176>>>>>>>>>>>>>>>//  By default this does nothing. Objects using val_mx actually pass this on
25176>>>>>>>>>>>>>>>//  object_validation.
25176>>>>>>>>>>>>>>>
25176>>>>>>>>>>>>>>>Procedure Set Object_Item_validation for cUIObject Integer fg
25178>>>>>>>>>>>>>>>End_Procedure
25179>>>>>>>>>>>>>>>
25179>>>>>>>>>>>>>>>Function Object_Item_Validation for cUIObject Returns Integer
25181>>>>>>>>>>>>>>>End_Function
25182>>>>>>>>>>>>>
25182>>>>>>>>>>>>>Class Entry_Client_mixin is a mixin
25183>>>>>>>>>>>>>
25183>>>>>>>>>>>>>    Procedure Construct_Object Integer myImg
25185>>>>>>>>>>>>>        Forward Send construct_object myImg
25187>>>>>>>>>>>>>        Set Ring_State to False
25188>>>>>>>>>>>>>        Property Integer private.Changed_State 0
25189>>>>>>>>>>>>>        
25189>>>>>>>>>>>>>        // We need this property to fully emulate a DEO
25189>>>>>>>>>>>>>        // (Actually, entry_clients should realy support ALL the DEO messages!)
25189>>>>>>>>>>>>>        Property Integer Auto_Clear_DEO_State True
25190>>>>>>>>>>>>>        
25190>>>>>>>>>>>>>        Send define_nesting      //invoke DEO nesting standard support constructor
25191>>>>>>>>>>>>>        Send define_navigation   //invoke DEO navigation standard support constructor
25192>>>>>>>>>>>>>        Send define_server       //invoke Server support constructor
25193>>>>>>>>>>>>>        Send define_action_bar   //invoke action-bar support constructor
25194>>>>>>>>>>>>>        Send define_verify       //invoke Verification support constructor
25195>>>>>>>>>>>>>        Send define_DEO_Delegate
25196>>>>>>>>>>>>>        Send Define_Auto_Locate
25197>>>>>>>>>>>>>        
25197>>>>>>>>>>>>>    End_Procedure
25198>>>>>>>>>>>>>    
25198>>>>>>>>>>>>>    Import_Class_Protocol NESTING_Mixin
25199>>>>>>>>>>>>>    Import_Class_Protocol NAVIGATE_Mixin
25200>>>>>>>>>>>>>    Import_Class_Protocol SERVER_Mixin
25201>>>>>>>>>>>>>    Import_Class_Protocol VERIFY_Mixin
25202>>>>>>>>>>>>>    Import_Class_Protocol ACTION_BAR_Mixin
25203>>>>>>>>>>>>>    Import_Class_Protocol Auto_Locate_Mixin
25204>>>>>>>>>>>>>    Import_Class_Protocol Deo_Delegate_Mixin
25205>>>>>>>>>>>>>    
25205>>>>>>>>>>>>>    
25205>>>>>>>>>>>>>    //
25205>>>>>>>>>>>>>    // created for Server support
25205>>>>>>>>>>>>>    //
25205>>>>>>>>>>>>>    Procedure Display
25207>>>>>>>>>>>>>        Broadcast Send display
25209>>>>>>>>>>>>>    End_Procedure
25210>>>>>>>>>>>>>    
25210>>>>>>>>>>>>>    //
25210>>>>>>>>>>>>>    // created for Server support
25210>>>>>>>>>>>>>    //
25210>>>>>>>>>>>>>    Procedure Clear
25212>>>>>>>>>>>>>        Broadcast Send Clear
25214>>>>>>>>>>>>>    End_Procedure
25215>>>>>>>>>>>>>    
25215>>>>>>>>>>>>>    //
25215>>>>>>>>>>>>>    // created for Server support
25215>>>>>>>>>>>>>    //
25215>>>>>>>>>>>>>    Procedure Clear_Set
25217>>>>>>>>>>>>>        Broadcast Send clear_set
25219>>>>>>>>>>>>>    End_Procedure
25220>>>>>>>>>>>>>    
25220>>>>>>>>>>>>>    //
25220>>>>>>>>>>>>>    // created for property support
25220>>>>>>>>>>>>>    //
25220>>>>>>>>>>>>>    Function Changed_State Returns Integer
25222>>>>>>>>>>>>>        Integer retval
25222>>>>>>>>>>>>>        Get Private.Changed_State to retval
25223>>>>>>>>>>>>>        Function_Return retval
25224>>>>>>>>>>>>>    End_Function
25225>>>>>>>>>>>>>    
25225>>>>>>>>>>>>>    //
25225>>>>>>>>>>>>>    // cancelled from Server mixin
25225>>>>>>>>>>>>>    //
25225>>>>>>>>>>>>>    Procedure Set Changed_State Integer newVal
25227>>>>>>>>>>>>>    End_Procedure
25228>>>>>>>>>>>>>    
25228>>>>>>>>>>>>>    //
25228>>>>>>>>>>>>>    // created for EntItem convenience
25228>>>>>>>>>>>>>    //
25228>>>>>>>>>>>>>    Procedure Entry_Clear Integer file#
25230>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Clear file#
25234>>>>>>>>>>>>>    End_Procedure
25235>>>>>>>>>>>>>    
25235>>>>>>>>>>>>>    //
25235>>>>>>>>>>>>>    // created for EntItem convenience
25235>>>>>>>>>>>>>    //
25235>>>>>>>>>>>>>    Procedure Entry_Clear_All Integer file#
25237>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Clear_All file#
25241>>>>>>>>>>>>>    End_Procedure
25242>>>>>>>>>>>>>    
25242>>>>>>>>>>>>>    //
25242>>>>>>>>>>>>>    // created for EntItem convenience
25242>>>>>>>>>>>>>    //
25242>>>>>>>>>>>>>    Procedure Entry_Display Integer file# Integer flag
25244>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Display file# flag
25248>>>>>>>>>>>>>    End_Procedure
25249>>>>>>>>>>>>>    
25249>>>>>>>>>>>>>    Procedure End_Construct_Object
25251>>>>>>>>>>>>>        Send Mark_Components      // nesting
25252>>>>>>>>>>>>>        Send Define_Access_Keys 0 // action_bar_keys
25253>>>>>>>>>>>>>        Forward Send End_Construct_Object
25255>>>>>>>>>>>>>    End_Procedure
25256>>>>>>>>>>>>>    
25256>>>>>>>>>>>>>    // Added for deo delegate support
25256>>>>>>>>>>>>>    Procedure Request_Clear
25258>>>>>>>>>>>>>        Integer obj# retval foc
25258>>>>>>>>>>>>>        If (should_delegate_clear(Self)) ;            Delegate Send request_clear
25262>>>>>>>>>>>>>        Else Begin
25263>>>>>>>>>>>>>            Get Locate_Server to obj# // locate needed in case this is a DSO
25264>>>>>>>>>>>>>            If (should_save(Self) and ;                (Verify_Data_Loss(Self) <> 0)) ;                Procedure_Return
25267>>>>>>>>>>>>>            
25267>>>>>>>>>>>>>            Get Focus of desktop to Foc
25268>>>>>>>>>>>>>            Get Object_Item_Validation of Foc to retval
25269>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to False
25270>>>>>>>>>>>>>            
25270>>>>>>>>>>>>>            If (obj# <> 0) ;                Send Clear to obj#
25273>>>>>>>>>>>>>            Else ;                Send entry_clear 0
25275>>>>>>>>>>>>>            If (Auto_Top_Panel_State(Self)) ;                Send beginning_of_panel
25278>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to retval
25279>>>>>>>>>>>>>        End
25279>>>>>>>>>>>>>>
25279>>>>>>>>>>>>>    End_Procedure
25280>>>>>>>>>>>>>    
25280>>>>>>>>>>>>>    Procedure Request_Clear_All
25282>>>>>>>>>>>>>        Integer obj# retval foc
25282>>>>>>>>>>>>>        If (should_delegate_clear(Self)) ;            Delegate Send request_clear_all
25286>>>>>>>>>>>>>        Else Begin
25287>>>>>>>>>>>>>            Get Locate_Server to obj#
25288>>>>>>>>>>>>>            If (Should_Save(Self) and ;                (Verify_Data_Loss(Self) <> 0)) ;                Procedure_Return
25291>>>>>>>>>>>>>            
25291>>>>>>>>>>>>>            Get Focus of desktop to Foc
25292>>>>>>>>>>>>>            Get Object_Item_Validation of Foc to retval
25293>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to False
25294>>>>>>>>>>>>>            
25294>>>>>>>>>>>>>            If (obj# <> 0) ;                Send clear_all to obj#
25297>>>>>>>>>>>>>            Else ;                Send entry_clear_all 0
25299>>>>>>>>>>>>>            If (Auto_Top_Panel_State(Self)) ;                Send beginning_of_panel
25302>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to retval
25303>>>>>>>>>>>>>        End
25303>>>>>>>>>>>>>>
25303>>>>>>>>>>>>>    End_Procedure
25304>>>>>>>>>>>>>    
25304>>>>>>>>>>>>>    Procedure Request_Delete
25306>>>>>>>>>>>>>        Integer obj#
25306>>>>>>>>>>>>>        
25306>>>>>>>>>>>>>        If (should_delegate_delete(Self)) ;            Delegate Send request_delete
25310>>>>>>>>>>>>>        Else Begin
25311>>>>>>>>>>>>>            Move False to Err
25312>>>>>>>>>>>>>            Get Locate_Server to obj#
25313>>>>>>>>>>>>>            If (obj# <> 0 and can_delete(obj#) <> 0) Begin
25315>>>>>>>>>>>>>                If (Verify_Delete(Self) <> 0) ;                    Procedure_Return
25318>>>>>>>>>>>>>                Set changed_State to False
25319>>>>>>>>>>>>>                If (Deferred_State(Self)) ;                    Send Request_Assign to obj# 0  //0 means main_file of Server
25322>>>>>>>>>>>>>                Send Request_Delete to obj#
25323>>>>>>>>>>>>>                // ignore auto_clear_deo_state in deletes. Always clear deleted record
25323>>>>>>>>>>>>>                If (not(err)) ;                    Send Request_Clear
25326>>>>>>>>>>>>>            End
25326>>>>>>>>>>>>>>
25326>>>>>>>>>>>>>        End
25326>>>>>>>>>>>>>>
25326>>>>>>>>>>>>>    End_Procedure
25327>>>>>>>>>>>>>    
25327>>>>>>>>>>>>>    Procedure Request_Find Integer mode Integer entUpdtFlag
25329>>>>>>>>>>>>>        If (should_delegate_find(Self)) ;            Delegate Send request_find mode entUpdtFlag
25333>>>>>>>>>>>>>        Else Begin // for now don't support any default find behavior
25334>>>>>>>>>>>>>            // in clients
25334>>>>>>>>>>>>>            Procedure_Return
25335>>>>>>>>>>>>>        End
25335>>>>>>>>>>>>>>
25335>>>>>>>>>>>>>    End_Procedure
25336>>>>>>>>>>>>>    
25336>>>>>>>>>>>>>    Procedure Request_Save
25338>>>>>>>>>>>>>        Integer obj# retval
25338>>>>>>>>>>>>>        
25338>>>>>>>>>>>>>        If (should_delegate_save(Self)) ;            Delegate Send request_save
25342>>>>>>>>>>>>>        Else Begin
25343>>>>>>>>>>>>>            Get Locate_Server to obj#
25344>>>>>>>>>>>>>            
25344>>>>>>>>>>>>>            If (obj# <> 0 and not(Read_Only_State(obj#))) Begin
25346>>>>>>>>>>>>>                Move False to Err
25347>>>>>>>>>>>>>                
25347>>>>>>>>>>>>>                If (Should_Save(Self)) Begin
25349>>>>>>>>>>>>>                    Get Request_Validate of obj# to retval
25350>>>>>>>>>>>>>                    If (retval <> 0) ;                        Procedure_Return
25353>>>>>>>>>>>>>                    //
25353>>>>>>>>>>>>>                    // modification for Verify support
25353>>>>>>>>>>>>>                    //
25353>>>>>>>>>>>>>                    If (Verify_Save(Self) <> 0) ;                        Procedure_Return
25356>>>>>>>>>>>>>                    //
25356>>>>>>>>>>>>>                    // modification for Save support
25356>>>>>>>>>>>>>                    //
25356>>>>>>>>>>>>>                    If (Deferred_State(Self)) ;                        Send Request_Assign to obj# 0  //0 means main_file of server
25359>>>>>>>>>>>>>                    
25359>>>>>>>>>>>>>                    Send Request_Save to obj#
25360>>>>>>>>>>>>>                End
25360>>>>>>>>>>>>>>
25360>>>>>>>>>>>>>                //
25360>>>>>>>>>>>>>                If (not(err) and Auto_Clear_DEO_State(Self)) ;                    Send Request_Clear
25363>>>>>>>>>>>>>            End
25363>>>>>>>>>>>>>>
25363>>>>>>>>>>>>>        End
25363>>>>>>>>>>>>>>
25363>>>>>>>>>>>>>    End_Procedure
25364>>>>>>>>>>>>>    
25364>>>>>>>>>>>>>    // this allows us to save a record without it clearing regardless of
25364>>>>>>>>>>>>>    // the Auto_Clear_DEO_State value
25364>>>>>>>>>>>>>    //
25364>>>>>>>>>>>>>    Procedure Request_Save_No_Clear
25366>>>>>>>>>>>>>        Integer oldclr
25366>>>>>>>>>>>>>        If (should_delegate_save(Self)) ;            Delegate Send request_save_no_clear
25370>>>>>>>>>>>>>        Else Begin
25371>>>>>>>>>>>>>            Get Auto_Clear_DEO_State to OldClr  // whatever it was
25372>>>>>>>>>>>>>            Set Auto_Clear_DEO_State to False   // it is no NO!
25373>>>>>>>>>>>>>            Send request_save                   // do your magic
25374>>>>>>>>>>>>>            Set Auto_Clear_DEO_State to OldClr  // back to whatever it was
25375>>>>>>>>>>>>>        End
25375>>>>>>>>>>>>>>
25375>>>>>>>>>>>>>    End_Procedure
25376>>>>>>>>>>>>>    
25376>>>>>>>>>>>>>    Procedure Request_Superfind Integer mode
25378>>>>>>>>>>>>>        Integer ser# datafile
25378>>>>>>>>>>>>>        
25378>>>>>>>>>>>>>        If (should_delegate_find(Self)) ;            Delegate Send request_superfind mode
25382>>>>>>>>>>>>>        Else Begin
25383>>>>>>>>>>>>>            Procedure_Return
25384>>>>>>>>>>>>>        End
25384>>>>>>>>>>>>>>
25384>>>>>>>>>>>>>    End_Procedure
25385>>>>>>>>>>>>>    
25385>>>>>>>>>>>>>    //  Augment to Support AutoLocate.
25385>>>>>>>>>>>>>    //  This replaces (not augments) the procedure in actionbr. We need
25385>>>>>>>>>>>>>    //  to look into this (activating is very risky to augment activating
25385>>>>>>>>>>>>>    //  in mixins).
25385>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25385>>>>>>>>>>>>>    Procedure Activating // Returns Integer
25387>>>>>>>>>>>>>        Integer InvokingId RVal
25387>>>>>>>>>>>>>        Get Focus of desktop to InvokingId
25388>>>>>>>>>>>>>        //
25388>>>>>>>>>>>>>        Forward Get MSG_activating to rVal   //  This is the standard
25390>>>>>>>>>>>>>        If rVal ;            Procedure_Return rVal        //  actionbr activating
25393>>>>>>>>>>>>>        Send Add_action_bar                  //  logic
25394>>>>>>>>>>>>>        If (Auto_Locate_State(Self) ) ;            Send Auto_Locate InvokingId
25397>>>>>>>>>>>>>    End_Procedure
25398>>>>>>>>>>>>>    
25398>>>>>>>>>>>>>    // add this so that all db clients delegate this message.
25398>>>>>>>>>>>>>    // this is used to catch sub-views (tabview). Tab views (sub
25398>>>>>>>>>>>>>    // views) will augment this to do something useful
25398>>>>>>>>>>>>>    Function SubView_Changed Returns Integer
25400>>>>>>>>>>>>>        Integer hObj
25400>>>>>>>>>>>>>        Broadcast Get SubView_Changed to hObj
25402>>>>>>>>>>>>>        Function_Return hObj
25403>>>>>>>>>>>>>    End_Function
25404>>>>>>>>>>>>>    
25404>>>>>>>>>>>>>    // these are needed to pass these on to possible tabview.
25404>>>>>>>>>>>>>    Function Opening_view_Recursive Returns Integer
25406>>>>>>>>>>>>>        Integer bFail
25406>>>>>>>>>>>>>        Broadcast Get Opening_View_Recursive to bFail
25408>>>>>>>>>>>>>        Function_Return bFail
25409>>>>>>>>>>>>>    End_Function
25410>>>>>>>>>>>>>    
25410>>>>>>>>>>>>>    // these are needed to pass these on to possible tabview.
25410>>>>>>>>>>>>>    Procedure Seed_Data_Sets_Recursive
25412>>>>>>>>>>>>>        Broadcast Send Seed_Data_Sets_Recursive
25414>>>>>>>>>>>>>    End_Procedure
25415>>>>>>>>>>>>>    
25415>>>>>>>>>>>>>    // as of 17.0, clients are added to a DDOs DEO list, which means they receive the messages
25415>>>>>>>>>>>>>    // Refresh, Validate_Items and Entry_Update. These are stubs. The Refresh message is the one
25415>>>>>>>>>>>>>    // that will be useful. A developer can use this to process DD changes within a view or other
25415>>>>>>>>>>>>>    // container
25415>>>>>>>>>>>>>    
25415>>>>>>>>>>>>>    Procedure Refresh Integer eMode
25417>>>>>>>>>>>>>    End_Procedure
25418>>>>>>>>>>>>>    
25418>>>>>>>>>>>>>    Function Validate_Items Returns Integer
25420>>>>>>>>>>>>>    End_Function
25421>>>>>>>>>>>>>    
25421>>>>>>>>>>>>>    Procedure Entry_Update Integer file# Integer flag
25423>>>>>>>>>>>>>    End_Procedure
25424>>>>>>>>>>>>>    
25424>>>>>>>>>>>>>    Function Data_File Integer iItem Returns Integer
25426>>>>>>>>>>>>>        Function_Return 0
25427>>>>>>>>>>>>>    End_Function
25428>>>>>>>>>>>>>    
25428>>>>>>>>>>>>>    Function Data_Field Integer iItem Returns Integer
25430>>>>>>>>>>>>>        Function_Return 0
25431>>>>>>>>>>>>>    End_Function
25432>>>>>>>>>>>>>    
25432>>>>>>>>>>>>>    
25432>>>>>>>>>>>>>End_Class
25433>>>>>>>>>>>>>
25433>>>>>>>>>>>>>
25433>>>>>>>>>>>>>Define DEFAULT_VIEW_LATCH_STATE         for 1
25433>>>>>>>>>>>>>Define DEFAULT_VIEW_STATIC_SERVER_STATE for 1
25433>>>>>>>>>>>>>Define DEFAULT_DSO_DETACH_MODE          for DETACH_IF_NO_CHANGE
25433>>>>>>>>>>>>>
25433>>>>>>>>>>>>>Class Entry_View_Client_mixin is a mixin
25434>>>>>>>>>>>>>    Procedure Construct_Object Integer img#
25436>>>>>>>>>>>>>        Forward Send construct_object img#
25438>>>>>>>>>>>>>        Property String View_Name ''  // default name...could be useful
25439>>>>>>>>>>>>>        Set scope_State to True         // defaults to a Scope
25440>>>>>>>>>>>>>        Set Attach_Parent_State to True // default...controls parentage better
25441>>>>>>>>>>>>>        Set Ring_State to True          // default to Ring...makes sense
25442>>>>>>>>>>>>>        
25442>>>>>>>>>>>>>        Property Integer DSO_Detach_Mode          Default_DSO_Detach_Mode
25443>>>>>>>>>>>>>        Property Integer DEO_Attach_All_State     False
25444>>>>>>>>>>>>>        
25444>>>>>>>>>>>>>        Property Integer View_Latch_State         True  // Default_View_Latch_State
25445>>>>>>>>>>>>>        Property Integer Main_DD                  0
25446>>>>>>>>>>>>>        // keeps track of main-file record when new view is entered!
25446>>>>>>>>>>>>>        
25446>>>>>>>>>>>>>        Property RowID priInitialRowId
25447>>>>>>>>>>>>>        
25447>>>>>>>>>>>>>        // when false activate will attempt to activate the scope_focus
25447>>>>>>>>>>>>>        // when true, activate activates first object.
25447>>>>>>>>>>>>>        Property Integer Auto_Top_View_State      False
25448>>>>>>>>>>>>>
25448>>>>>>>>>>>>>        // When activate is performed (as opposed to set current_scope) the
25448>>>>>>>>>>>>>        // first focusable object is activated. Should the first item of the
25448>>>>>>>>>>>>>        // first object become the current_item?
25448>>>>>>>>>>>>>        // If Top_View is true and Top_Item is false you get the old dac
25448>>>>>>>>>>>>>        // behaviors.
25448>>>>>>>>>>>>>        Property Integer Auto_Top_Item_State      True
25449>>>>>>>>>>>>>        
25449>>>>>>>>>>>>>        // When changing views this will keep track of the object that had
25449>>>>>>>>>>>>>        // the focus when this view (scope) was exited. This manages nested
25449>>>>>>>>>>>>>        // scopes within a view.
25449>>>>>>>>>>>>>        Property Integer private.Last_View_Focus  0
25450>>>>>>>>>>>>>        Property Integer wasNotinUse_State        False // internal use
25451>>>>>>>>>>>>>    End_Procedure
25452>>>>>>>>>>>>>    
25452>>>>>>>>>>>>>    // Augment exit_application_check. If a change
25452>>>>>>>>>>>>>    // is detected activate the changed view. This way the user sees what
25452>>>>>>>>>>>>>    // has been changed.
25452>>>>>>>>>>>>>    //
25452>>>>>>>>>>>>>    Function Exit_Application_Check Returns Integer
25454>>>>>>>>>>>>>        Integer rVal Obj
25454>>>>>>>>>>>>>        
25454>>>>>>>>>>>>>        Get Should_Save to Rval // changes in this object???
25455>>>>>>>>>>>>>        If (rVal = 0) ;            Broadcast Get Exit_Application_Check to Rval // check w/ kids
25459>>>>>>>>>>>>>        
25459>>>>>>>>>>>>>        If (rVal <> 0) Begin  // ok a change exist...activate changed view.
25461>>>>>>>>>>>>>            //
25461>>>>>>>>>>>>>            // before activating the changed view make sure that we are not
25461>>>>>>>>>>>>>            // trying to activate this on top of a modal object. Check the current
25461>>>>>>>>>>>>>            // focus and all of its parent record up to (but not including) the
25461>>>>>>>>>>>>>            // desktop. If any of these object are modal (have block_mouse_state
25461>>>>>>>>>>>>>            // set to true) then do not display the changed view.
25461>>>>>>>>>>>>>            //
25461>>>>>>>>>>>>>            Get Focus of desktop to Obj
25462>>>>>>>>>>>>>            While Obj Gt DESKTOP
25466>>>>>>>>>>>>>                If (Block_Mouse_State(Obj)) ;                    Function_Return rVal // if modal..exit
25469>>>>>>>>>>>>>                Get Parent of Obj to Obj
25470>>>>>>>>>>>>>            Loop
25471>>>>>>>>>>>>>>
25471>>>>>>>>>>>>>            Send Activate
25472>>>>>>>>>>>>>        End
25472>>>>>>>>>>>>>>
25472>>>>>>>>>>>>>        Function_Return rVal
25473>>>>>>>>>>>>>    End_Function
25474>>>>>>>>>>>>>    
25474>>>>>>>>>>>>>    Function Opening_view_Recursive Returns Integer
25476>>>>>>>>>>>>>        Integer main bFail
25476>>>>>>>>>>>>>        Set delegation_mode to delegate_to_parent
25477>>>>>>>>>>>>>        Get Main_DD to Main
25478>>>>>>>>>>>>>        Set WasNotInUse_State to ( Main and In_use_State(Main)=0 )
25479>>>>>>>>>>>>>        Get Opening_View to bFail
25480>>>>>>>>>>>>>        If not bFail ;            Broadcast Get Opening_View_Recursive to bFail
25484>>>>>>>>>>>>>        Function_Return bFail
25485>>>>>>>>>>>>>    End_Function
25486>>>>>>>>>>>>>    
25486>>>>>>>>>>>>>    Procedure Seed_Data_Sets_Recursive
25488>>>>>>>>>>>>>        Integer NotInUse
25488>>>>>>>>>>>>>        Set delegation_mode to delegate_to_parent
25489>>>>>>>>>>>>>        Get WasNotInUse_State to NotInUse
25490>>>>>>>>>>>>>        If NotInUse ;            Send Seed_Data_Sets  // if ok, we've got blank in-use DSO.
25493>>>>>>>>>>>>>        Set WasNotInUse_State to False
25494>>>>>>>>>>>>>        Broadcast Send Seed_Data_Sets_Recursive
25496>>>>>>>>>>>>>    End_Procedure
25497>>>>>>>>>>>>>    
25497>>>>>>>>>>>>>    
25497>>>>>>>>>>>>>    //  Augmented to send Opening_view. If add_focus fails it sends
25497>>>>>>>>>>>>>    //  closing_view to reverse effects of Opening_view
25497>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
25499>>>>>>>>>>>>>        Integer rVal Main NotInUse
25499>>>>>>>>>>>>>        Get Opening_View_Recursive to rval
25500>>>>>>>>>>>>>        //
25500>>>>>>>>>>>>>        If (rVal = 0) Begin
25502>>>>>>>>>>>>>            // Connect DEOs and DSOs as required.
25502>>>>>>>>>>>>>            Send Connect_DEOs_to_Servers (DEO_Attach_All_State(Self))
25503>>>>>>>>>>>>>            Forward Get MSG_add_focus hoParent to rVal
25505>>>>>>>>>>>>>            Send Seed_Data_Sets_Recursive
25506>>>>>>>>>>>>>        End
25506>>>>>>>>>>>>>>
25506>>>>>>>>>>>>>        Procedure_Return rVal
25507>>>>>>>>>>>>>    End_Procedure
25508>>>>>>>>>>>>>    
25508>>>>>>>>>>>>>    // Augmented to Send Closing view
25508>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25508>>>>>>>>>>>>>    Procedure Deactivating //Returns Integer
25510>>>>>>>>>>>>>        Integer rVal
25510>>>>>>>>>>>>>        Forward Get MSG_Deactivating to rVal
25512>>>>>>>>>>>>>        If (rVal = 0) ;            Send closing_View
25515>>>>>>>>>>>>>    End_Procedure
25516>>>>>>>>>>>>>    
25516>>>>>>>>>>>>>    //  Disconnect servers from deos according to rules.
25516>>>>>>>>>>>>>    //
25516>>>>>>>>>>>>>    Procedure Closing_View
25518>>>>>>>>>>>>>        Integer Mode
25518>>>>>>>>>>>>>        Get DSO_Detach_Mode to Mode
25519>>>>>>>>>>>>>        // If we had a View with no DEOs the DSOs would remain in use. We
25519>>>>>>>>>>>>>        // will take the extra step to set all DSOs in-use-states to false.
25519>>>>>>>>>>>>>        Send Disconnect_DEOs_from_Servers Mode
25520>>>>>>>>>>>>>        // we assume that only DSOs understand Set In_Use_State and that
25520>>>>>>>>>>>>>        // no delegation occurs as part of setting this to false.
25520>>>>>>>>>>>>>        If (Mode = DETACH_ALWAYS) ;            Broadcast Recursive Set In_use_State to False
25524>>>>>>>>>>>>>    End_Procedure
25525>>>>>>>>>>>>>    
25525>>>>>>>>>>>>>    // use to preload anything into DSOs. By default, if a Main_DD is
25525>>>>>>>>>>>>>    // defined, we will attempt to latch on
25525>>>>>>>>>>>>>    // the record that was in the buffer when the view was entered!
25525>>>>>>>>>>>>>    Procedure Seed_Data_Sets
25527>>>>>>>>>>>>>        Integer srvr# File#
25527>>>>>>>>>>>>>        Integer bFill
25527>>>>>>>>>>>>>        RowID   riInitalRowId
25527>>>>>>>>>>>>>        Boolean bFound
25527>>>>>>>>>>>>>        Get Main_DD to srvr#
25528>>>>>>>>>>>>>        // If no Main-dd we don't do anything automatically, you are on your
25528>>>>>>>>>>>>>        // own to seed the data-sets any way you want.
25528>>>>>>>>>>>>>        If Srvr# Begin
25530>>>>>>>>>>>>>            Get auto_fill_State of srvr# to bFill
25531>>>>>>>>>>>>>            // if not auto-fill and we've got a record, someone went to a lot of
25531>>>>>>>>>>>>>            // trouble to set up a record. Don't change it. Normally this would
25531>>>>>>>>>>>>>            // occur w/ selection lists (which are not auto-fill) that seed the
25531>>>>>>>>>>>>>            // list in advance.
25531>>>>>>>>>>>>>            If ( bFill=0 and HasRecord(srvr#) ) ;                Procedure_Return
25534>>>>>>>>>>>>>            Get priInitialRowId to riInitalRowId
25535>>>>>>>>>>>>>            If ( not(IsNullRowId(riInitalRowId)) and View_Latch_State(Self) ) Begin
25537>>>>>>>>>>>>>                // if initial record and we latch, refind it via DSO
25537>>>>>>>>>>>>>                // Find & relate record manually and then perform
25537>>>>>>>>>>>>>                // a request_assign. This will not work if the finding file is
25537>>>>>>>>>>>>>                // a constrained child file
25537>>>>>>>>>>>>>                Get Main_file of Srvr# to File#
25538>>>>>>>>>>>>>                // we can now do this in a single step
25538>>>>>>>>>>>>>                Get FindByRowIdEx of srvr# File# riInitalRowId to bFound
25539>>>>>>>>>>>>>            End
25539>>>>>>>>>>>>>>
25539>>>>>>>>>>>>>            Else ;                 // if no initial record, do a formal                If not bFill ;                Send Clear to Srvr# // clear
25543>>>>>>>>>>>>>            // If the srvr is auto-fill and there was no initial record we
25543>>>>>>>>>>>>>            // will chose to do nothing under the assumption that the server
25543>>>>>>>>>>>>>            // has already done an auto-fill and its guess is as good as
25543>>>>>>>>>>>>>            // anything we could come up with.
25543>>>>>>>>>>>>>        End
25543>>>>>>>>>>>>>>
25543>>>>>>>>>>>>>    End_Procedure
25544>>>>>>>>>>>>>    
25544>>>>>>>>>>>>>    //  Needed by view. Find the record number of the requested file.
25544>>>>>>>>>>>>>    //  If file = 0 use the main_file of Main_DD (if it exists).
25544>>>>>>>>>>>>>    Function FileRowId Integer iFile Returns RowID
25546>>>>>>>>>>>>>        Handle hoMain
25546>>>>>>>>>>>>>        RowID  riID
25546>>>>>>>>>>>>>        // if file not passed use main-file of main data set
25546>>>>>>>>>>>>>        If (iFile=0) Begin
25548>>>>>>>>>>>>>            Get Main_DD to hoMain
25549>>>>>>>>>>>>>            If hoMain Begin
25551>>>>>>>>>>>>>                Get main_file of hoMain to iFile
25552>>>>>>>>>>>>>            End
25552>>>>>>>>>>>>>>
25552>>>>>>>>>>>>>        End
25552>>>>>>>>>>>>>>
25552>>>>>>>>>>>>>        If iFile Begin
25554>>>>>>>>>>>>>            Move (GetRowId(iFile)) to riId
25555>>>>>>>>>>>>>        End
25555>>>>>>>>>>>>>>
25555>>>>>>>>>>>>>        Function_Return riId
25556>>>>>>>>>>>>>    End_Function
25557>>>>>>>>>>>>>    
25557>>>>>>>>>>>>>    // We maintain Last_View_Focus to control for nested scopes. A normal
25557>>>>>>>>>>>>>    // will have its scope_state true and no scoped children. However, a
25557>>>>>>>>>>>>>    // zoom might be scoped. We control this by keeping track of the scope when
25557>>>>>>>>>>>>>    // a scope is exited.
25557>>>>>>>>>>>>>    
25557>>>>>>>>>>>>>    Procedure Set Last_View_Focus Integer Foc
25559>>>>>>>>>>>>>        Set private.Last_View_Focus to Foc
25560>>>>>>>>>>>>>    End_Procedure
25561>>>>>>>>>>>>>    
25561>>>>>>>>>>>>>    // Returns The last scope in the view to have the focus. Before returning
25561>>>>>>>>>>>>>    // the value make sure that the scope object is active, else return 0
25561>>>>>>>>>>>>>    Function Last_View_Focus Returns Integer
25563>>>>>>>>>>>>>        Integer foc
25563>>>>>>>>>>>>>        Get private.Last_View_Focus to Foc
25564>>>>>>>>>>>>>        // if not a valid object or this object is not active make it 0
25564>>>>>>>>>>>>>        If (Foc<=DESKTOP or Active_state(Self)=0 or Active_State(Foc)=0) ;            Move 0 to Foc
25567>>>>>>>>>>>>>        Function_Return Foc
25568>>>>>>>>>>>>>    End_Function
25569>>>>>>>>>>>>>    
25569>>>>>>>>>>>>>    // Take care of any buffer initialization
25569>>>>>>>>>>>>>    Function Opening_View Returns Integer
25571>>>>>>>>>>>>>        Integer main
25571>>>>>>>>>>>>>        RowID riId
25571>>>>>>>>>>>>>        
25571>>>>>>>>>>>>>        // if a main DSO exists and it is not in use we must perform
25571>>>>>>>>>>>>>        // any required pre-seeding logic.
25571>>>>>>>>>>>>>        //Get Main_DD to Main
25571>>>>>>>>>>>>>        //If ( Main AND In_use_State(Main)=0 ) Begin
25571>>>>>>>>>>>>>        If ( wasNotinUse_State(Self))  Begin
25573>>>>>>>>>>>>>            // Always clear all file buffers and keep track of the record number
25573>>>>>>>>>>>>>            // that was in the main-dso's file-buffer.
25573>>>>>>>>>>>>>            // This is used by seed_data_sets to seed as required.
25573>>>>>>>>>>>>>            Get FileRowId 0 to riId
25574>>>>>>>>>>>>>            Set priInitialRowId to riId
25575>>>>>>>>>>>>>            //Set Initial_Main_record to Rec#
25575>>>>>>>>>>>>>            Send Prepare_Data_Sets         // allow custom setting
25576>>>>>>>>>>>>>            Broadcast Send clear_main_file // Send refind_records to main
25578>>>>>>>>>>>>>        End
25578>>>>>>>>>>>>>>
25578>>>>>>>>>>>>>    End_Function
25579>>>>>>>>>>>>>    
25579>>>>>>>>>>>>>    // only called if Main_DD exists and it is not yet in-use
25579>>>>>>>>>>>>>    Procedure Prepare_Data_Sets
25581>>>>>>>>>>>>>    End_Procedure
25582>>>>>>>>>>>>>    
25582>>>>>>>>>>>>>    // added to make the file buffers more reliable
25582>>>>>>>>>>>>>    Procedure Entering_Scope Returns Integer
25584>>>>>>>>>>>>>        Integer rVal
25584>>>>>>>>>>>>>        Forward Get MSG_entering_scope to rVal
25586>>>>>>>>>>>>>        // The refind is probably a feature that should always happen.
25586>>>>>>>>>>>>>        // The main-data-set was a way to make this backwards compatable.
25586>>>>>>>>>>>>>        // Maybe that made no sense.
25586>>>>>>>>>>>>>        If (rVal = 0) ;            Broadcast Send refind_DD_records // only refinds in-use DDs.
25590>>>>>>>>>>>>>        Procedure_Return rVal
25591>>>>>>>>>>>>>    End_Procedure
25592>>>>>>>>>>>>>    
25592>>>>>>>>>>>>>    // Augment to keep track of the scope that had the focus when this
25592>>>>>>>>>>>>>    // view was exited. Exiting_Scope seems to get called at the right
25592>>>>>>>>>>>>>    // times - only when focus is moved to an object outside of view's focus.
25592>>>>>>>>>>>>>    Procedure Exiting_Scope Handle hoNewScope
25594>>>>>>>>>>>>>        Integer rVal
25594>>>>>>>>>>>>>        Forward Get MSG_Exiting_Scope hoNewScope to rVal
25596>>>>>>>>>>>>>        If (rVal = 0) ;            Set Last_View_Focus to (Current_Scope(Self))
25599>>>>>>>>>>>>>    End_Procedure
25600>>>>>>>>>>>>>    
25600>>>>>>>>>>>>>    //  Augmented to allow views to take the focus without changing the
25600>>>>>>>>>>>>>    //  focus within the object. The property Auto_top_View_State controls
25600>>>>>>>>>>>>>    //  this. If true, always return to first object, first item. If false
25600>>>>>>>>>>>>>    //  return to current-item of scope focus (when possible).
25600>>>>>>>>>>>>>    //
25600>>>>>>>>>>>>>    Procedure Activate Returns Integer
25602>>>>>>>>>>>>>        Integer rVal Foc
25602>>>>>>>>>>>>>        If ( Auto_Top_View_State(Self)=0 and ; // Do we want behavior?            scope_state(Self) and ;           // s/b true.            Active_state(Self) ) Begin        // Only if active.
25604>>>>>>>>>>>>>            // Last_View_Focus is the last scope to have the focus.
25604>>>>>>>>>>>>>            // It should be active (if not the prop is 0).
25604>>>>>>>>>>>>>            // If for some reason the focus is 0, do a vanilla activate.
25604>>>>>>>>>>>>>            Get Last_View_Focus to Foc
25605>>>>>>>>>>>>>            If Foc ;                Set Current_Scope to Foc
25608>>>>>>>>>>>>>            Else ;                Forward Get Msg_Activate to rVal
25611>>>>>>>>>>>>>        End
25611>>>>>>>>>>>>>>
25611>>>>>>>>>>>>>        Else Begin
25612>>>>>>>>>>>>>            Forward Get Msg_Activate to rVal
25614>>>>>>>>>>>>>            // first Item of first object.
25614>>>>>>>>>>>>>            If ( Rval=0 and Auto_Top_Item_State(Self) ) ;                Send Beginning_of_Panel
25617>>>>>>>>>>>>>        End
25617>>>>>>>>>>>>>>
25617>>>>>>>>>>>>>        Procedure_Return rVal
25618>>>>>>>>>>>>>    End_Procedure
25619>>>>>>>>>>>>>    
25619>>>>>>>>>>>>>    // Views don't delegate to get this property. It uses system default
25619>>>>>>>>>>>>>    Function Default_Static_Server_State Returns Integer
25621>>>>>>>>>>>>>        Function_Return DEFAULT_VIEW_STATIC_SERVER_STATE
25622>>>>>>>>>>>>>    End_Function
25623>>>>>>>>>>>>>    
25623>>>>>>>>>>>>>End_Class
25624>>>>>>>>>>>>>
25624>>>>>>>>>>>>>//
25624>>>>>>>>>>>>>//  Client for Selection Lists.
25624>>>>>>>>>>>>>//
25624>>>>>>>>>>>>>//  Selection_lists and Pick_lists need to know if they should
25624>>>>>>>>>>>>>//  move their values out. With simple sel/pick lists it figures this
25624>>>>>>>>>>>>>//  out if the list is a popup object. (POPUP sets the property
25624>>>>>>>>>>>>>//  move_value_out_state to TRUE. If the sel\pick list needs to be
25624>>>>>>>>>>>>>//  encapulsated by a client the actual list object is no longer a
25624>>>>>>>>>>>>>//  popup (the client is). We need this special client to set the
25624>>>>>>>>>>>>>//  move_value_out_state of the list. It does this by broadcasting
25624>>>>>>>>>>>>>//  this to all objects. This only works if the sel/pick list object is
25624>>>>>>>>>>>>>//  a direct child of the client (which it always will be).
25624>>>>>>>>>>>>>//
25624>>>>>>>>>>>>>//  Also note that this class supports movable objects
25624>>>>>>>>>>>>>
25624>>>>>>>>>>>>>Register_Procedure Set Move_Value_Out_State Integer State
25624>>>>>>>>>>>>>
25624>>>>>>>>>>>>>// used to catch old obsolete syntax
25624>>>>>>>>>>>Use DFNav_mx.pkg // Navigation changes for DF DEOs
Including file: Dfnav_mx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfnav_mx.pkg)
25624>>>>>>>>>>>>>Use VDFBase.pkg
25624>>>>>>>>>>>>>
25624>>>>>>>>>>>>>Class DFnavigate_mixin is a Mixin
25625>>>>>>>>>>>>>    
25625>>>>>>>>>>>>>    Procedure define_DFNavigation
25627>>>>>>>>>>>>>        
25627>>>>>>>>>>>>>        On_Key kSwitch            Send Switch_Next_Area   PRIVATE
25628>>>>>>>>>>>>>        On_Key kSwitch_Back       Send Switch_Prior_Area  PRIVATE
25629>>>>>>>>>>>>>        
25629>>>>>>>>>>>>>        //  Change Panel switching to view switching.
25629>>>>>>>>>>>>>        //  The messages Switch_next_view and Switch_Prior_View
25629>>>>>>>>>>>>>        //  need to be resolved (via delegation) in the view object.
25629>>>>>>>>>>>>>        //  This means that all dfentry object must be placed inside
25629>>>>>>>>>>>>>        //  of a view object. This might cause problems ... we will see.
25629>>>>>>>>>>>>>        
25629>>>>>>>>>>>>>    End_Procedure
25630>>>>>>>>>>>>>    
25630>>>>>>>>>>>>>    Procedure Close_Panel
25632>>>>>>>>>>>>>        Send Exit_Function
25633>>>>>>>>>>>>>    End_Procedure
25634>>>>>>>>>>>>>    
25634>>>>>>>>>>>>>End_Class
25635>>>>>>>>>>>Use dfConfrm.pkg
25635>>>>>>>>>>>Use Dfdbmdpn.pkg // adds obsolete pointerButton for dbModalPanel
Including file: Dfdbmdpn.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfdbmdpn.pkg)
25635>>>>>>>>>>>>>Use Windows.pkg
25635>>>>>>>>>>>>>
25635>>>>>>>>>>>>>Class PointerButton is a Button
25636>>>>>>>>>>>>>    
25636>>>>>>>>>>>>>    Procedure Construct_Object
25638>>>>>>>>>>>>>        Forward Send Construct_Object
25640>>>>>>>>>>>>>        Set focus_mode to pointer_Only
25641>>>>>>>>>>>>>    End_Procedure
25642>>>>>>>>>>>>>    
25642>>>>>>>>>>>>>    Procedure Command Integer i1 Integer i2
25644>>>>>>>>>>>>>        Send Redirect_Message
25645>>>>>>>>>>>>>    End_Procedure
25646>>>>>>>>>>>>>    
25646>>>>>>>>>>>>>    Procedure Redirect_Message Returns Integer
25648>>>>>>>>>>>>>        Integer msg obj rval
25648>>>>>>>>>>>>>        Get message 0 to Msg
25649>>>>>>>>>>>>>        Get Aux_Value 0 to obj
25650>>>>>>>>>>>>>        If Msg ;            Get Msg of ( If(obj, obj, Focus(desktop)) ) to rval
25653>>>>>>>>>>>>>        Procedure_Return rval
25654>>>>>>>>>>>>>    End_Procedure
25655>>>>>>>>>>>>>    
25655>>>>>>>>>>>>>End_Class
25656>>>>>>>>>>>Use Dfdafmac.pkg
Including file: Dfdafmac.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfdafmac.pkg)
25656>>>>>>>>>>>>>Use Windows.pkg
25656>>>>>>>>>>>>>Use dfcursor.pkg
25656>>>>>>>>>>>>>
25656>>>>>>>>>>>>>
25656>>>>>>>>>>>>>//  This expects to create a view INSIDE of another object
25656>>>>>>>>>>>>>//  (Like a panel)
25656>>>>>>>>>>>>>//
25656>>>>>>>>>>>>>
25656>>>>>>>>>>>>>
25656>>>>>>>>>>>>>Define DEFERRED_OBJECT for Deferred_View
25656>>>>>>>>>>>>>
25656>>>>>>>>>>>>>Class CD_Client is a Container
25657>>>>>>>>>>>>>    
25657>>>>>>>>>>>>>    Procedure Construct_Object
25659>>>>>>>>>>>>>        Forward Send Construct_Object
25661>>>>>>>>>>>>>        
25661>>>>>>>>>>>>>        Property Integer Created_object_id 0
25662>>>>>>>>>>>>>        
25662>>>>>>>>>>>>>        Set focus_mode to nonfocusable
25663>>>>>>>>>>>>>    End_Procedure
25664>>>>>>>>>>>>>    
25664>>>>>>>>>>>>>    Procedure Popup
25666>>>>>>>>>>>>>        Send Popup_Modal
25667>>>>>>>>>>>>>    End_Procedure
25668>>>>>>>>>>>>>    
25668>>>>>>>>>>>>>    Register_Function Destroy_Object_State Returns Integer
25668>>>>>>>>>>>>>    
25668>>>>>>>>>>>>>    // is augmented by object instance. Should never
25668>>>>>>>>>>>>>    // be called.
25668>>>>>>>>>>>>>    Function Popup_Handle Returns Handle
25670>>>>>>>>>>>>>        Error DFERR_PROGRAM "Improper use of CD_Popup_Object command"
25671>>>>>>>>>>>>>>
25671>>>>>>>>>>>>>    End_Function
25672>>>>>>>>>>>>>    
25672>>>>>>>>>>>>>    Procedure Popup_Modal Returns Integer
25674>>>>>>>>>>>>>        Integer iRet
25674>>>>>>>>>>>>>        Handle hoId
25674>>>>>>>>>>>>>        Boolean bDestroy
25674>>>>>>>>>>>>>        Get Popup_Handle to hoId
25675>>>>>>>>>>>>>        If hoId Begin
25677>>>>>>>>>>>>>            Get msg_Popup_Modal of hoId to iRet
25678>>>>>>>>>>>>>            Get Destroy_Object_State of hoId to bDestroy
25679>>>>>>>>>>>>>            If bDestroy Begin
25681>>>>>>>>>>>>>                Send Destroy of hoId
25682>>>>>>>>>>>>>                Set Created_Object_Id to 0
25683>>>>>>>>>>>>>            End
25683>>>>>>>>>>>>>>
25683>>>>>>>>>>>>>            Procedure_Return iRet
25684>>>>>>>>>>>>>        End
25684>>>>>>>>>>>>>>
25684>>>>>>>>>>>>>    End_Procedure
25685>>>>>>>>>>>>>    
25685>>>>>>>>>>>>>End_Class
25686>>>>>>>>>>>>>
25686>>>>>>>>>>>>>
25686>>>>>>>>>>>>>
25686>>>>>>>>>>>
25686>>>>>>>>>>>Register_Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
25686>>>>>>>>>>>Register_Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
25686>>>>>>>>>>>
25686>>>>>>>>>>>//
25686>>>>>>>>>>>//  Grouping classes: Used within views to group objects
25686>>>>>>>>>>>//
25686>>>>>>>>>>>//  dbContainer3d_
25686>>>>>>>>>>>//     dbContainer3d
25686>>>>>>>>>>>//
25686>>>>>>>>>>>Class dbContainer3d_ is a Container3d STARTMAC ECstart
25687>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25687>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin // mixin in CM DEO behaviors
25688>>>>>>>>>>>    
25688>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25688>>>>>>>>>>>    //
25688>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25688>>>>>>>>>>>    Procedure Activating //Returns Integer
25690>>>>>>>>>>>        Integer RVal
25690>>>>>>>>>>>        Forward Get MSG_activating to rVal
25692>>>>>>>>>>>        Procedure_Return rVal
25693>>>>>>>>>>>    End_Procedure
25694>>>>>>>>>>>End_Class
25695>>>>>>>>>>>
25695>>>>>>>>>>>Class dbContainer3d is a dbContainer3d_
25696>>>>>>>>>>>    Procedure Construct_Object
25698>>>>>>>>>>>        Forward Send Construct_Object No_Image
25700>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25701>>>>>>>>>>>    End_Procedure
25702>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25703>>>>>>>>>>>End_Class
25704>>>>>>>>>>>
25704>>>>>>>>>>>//
25704>>>>>>>>>>>// Group Based containers
25704>>>>>>>>>>>//
25704>>>>>>>>>>>//  dbGroup_
25704>>>>>>>>>>>//     dbGroup
25704>>>>>>>>>>>//
25704>>>>>>>>>>>Class dbGroup_ is a Group STARTMAC ECstart
25705>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25705>>>>>>>>>>>    
25705>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25706>>>>>>>>>>>    
25706>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25706>>>>>>>>>>>    //
25706>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25706>>>>>>>>>>>    Procedure Activating //Returns Integer
25708>>>>>>>>>>>        Integer RVal
25708>>>>>>>>>>>        Forward Get MSG_activating to rVal
25710>>>>>>>>>>>        Procedure_Return rVal
25711>>>>>>>>>>>    End_Procedure
25712>>>>>>>>>>>End_Class
25713>>>>>>>>>>>
25713>>>>>>>>>>>Class dbGroup is a dbGroup_
25714>>>>>>>>>>>    Procedure Construct_Object
25716>>>>>>>>>>>        Forward Send Construct_Object No_Image
25718>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25719>>>>>>>>>>>    End_Procedure
25720>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25721>>>>>>>>>>>End_Class
25722>>>>>>>>>>>
25722>>>>>>>>>>>
25722>>>>>>>>>>>//
25722>>>>>>>>>>>// Invisible Grouping object
25722>>>>>>>>>>>//
25722>>>>>>>>>>>//   dbContainer - invisible container
25722>>>>>>>>>>>//
25722>>>>>>>>>>>Class dbContainer is an dbContainer3d
25723>>>>>>>>>>>    Import_Class_Protocol NonVisual_Container_Mixin
25724>>>>>>>>>>>End_Class
25725>>>>>>>>>>>
25725>>>>>>>>>>>//
25725>>>>>>>>>>>// View Support (views are mdi dialogs)
25725>>>>>>>>>>>//
25725>>>>>>>>>>>//   dbAppClient_
25725>>>>>>>>>>>//     dbAppView_
25725>>>>>>>>>>>//       dbView
25725>>>>>>>>>>>//
25725>>>>>>>>>>>Class dbAppClient_ is a View  STARTMAC ECstart
25726>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25726>>>>>>>>>>>    
25726>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25727>>>>>>>>>>>    
25727>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25727>>>>>>>>>>>    //
25727>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25727>>>>>>>>>>>    Procedure Activating //Returns Integer
25729>>>>>>>>>>>        Integer RVal
25729>>>>>>>>>>>        Forward Get MSG_activating to rVal
25731>>>>>>>>>>>        Procedure_Return rVal
25732>>>>>>>>>>>    End_Procedure
25733>>>>>>>>>>>End_Class
25734>>>>>>>>>>>
25734>>>>>>>>>>>Class dbAppView_ is a dbAppClient_
25735>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
25736>>>>>>>>>>>End_Class
25737>>>>>>>>>>>
25737>>>>>>>>>>>Class dbView is a dbAppView_
25738>>>>>>>>>>>    
25738>>>>>>>>>>>    Procedure Construct_Object
25740>>>>>>>>>>>        Forward Send Construct_Object No_Image
25742>>>>>>>>>>>        
25742>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25743>>>>>>>>>>>        // dialog views get activated as popup objects.
25743>>>>>>>>>>>        Set Dso_Detach_Mode to Detach_Always
25744>>>>>>>>>>>        
25744>>>>>>>>>>>        // set default verify messages. These are good defaults. The
25744>>>>>>>>>>>        // developer may wish to change these in their object or sub-class.
25744>>>>>>>>>>>        // Note: these messsages are defined in dfconfrm.pkg
25744>>>>>>>>>>>        Set Verify_Data_Loss_Msg   to (RefFunc(Data_Loss_Confirmation))
25745>>>>>>>>>>>        Set Verify_Delete_Msg      to (RefFunc(Delete_Confirmation))
25746>>>>>>>>>>>        Set Verify_Save_Msg        to (RefFunc(Save_Confirmation))
25747>>>>>>>>>>>        Set Verify_Exit_Msg        to (RefFunc(Exit_Loss_Confirmation))
25748>>>>>>>>>>>        //
25748>>>>>>>>>>>    End_Procedure
25749>>>>>>>>>>>    
25749>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25750>>>>>>>>>>>    
25750>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
25750>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
25750>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
25750>>>>>>>>>>>    //
25750>>>>>>>>>>>    Function DEO_Object Returns Integer
25752>>>>>>>>>>>        Function_Return 1
25753>>>>>>>>>>>    End_Function
25754>>>>>>>>>>>    
25754>>>>>>>>>>>    //
25754>>>>>>>>>>>    //  Activate message for views that:
25754>>>>>>>>>>>    //  1. restores the view if it is minimized
25754>>>>>>>>>>>    //  2. Maintains the current scope's focus.
25754>>>>>>>>>>>    //
25754>>>>>>>>>>>    Procedure Activate_current_scope
25756>>>>>>>>>>>        If ( View_mode(Self)=VIEWMODE_ICONIZE ) ;            Set view_mode to viewmode_normal
25759>>>>>>>>>>>        Set Current_Scope to Self
25760>>>>>>>>>>>    End_Procedure
25761>>>>>>>>>>>    
25761>>>>>>>>>>>    // ------------deprecated....Use Object_label.
25761>>>>>>>>>>>    //  Pass full object name - return the relative name
25761>>>>>>>>>>>    //  e.g.,  Main.View.Obj1 --> Obj1
25761>>>>>>>>>>>    Function Local_Object_name String nm Returns String
25763>>>>>>>>>>>        Integer ps
25763>>>>>>>>>>>        Repeat
25763>>>>>>>>>>>>
25763>>>>>>>>>>>            Move (Pos( ".", nm)) to ps
25764>>>>>>>>>>>            If (ps = 0) ;                Function_Return nm
25767>>>>>>>>>>>            Increment ps
25768>>>>>>>>>>>            Move (Mid( Nm, 255, ps)) to Nm
25769>>>>>>>>>>>        Loop
25770>>>>>>>>>>>>
25770>>>>>>>>>>>    End_Function
25771>>>>>>>>>>>    
25771>>>>>>>>>>>    Function View_Changed Returns Integer
25773>>>>>>>>>>>        Integer Changed
25773>>>>>>>>>>>        // first see if any DDOs at this level are changed.
25773>>>>>>>>>>>        Broadcast Get Data_Set_Should_Save to Changed // Ask for changes in Data-sets
25775>>>>>>>>>>>        // if no changes, see if we have any sub-views that are changed
25775>>>>>>>>>>>        // This is used to catch tab-view pages.
25775>>>>>>>>>>>        If not Changed ;            Broadcast Get SubView_Changed to Changed
25779>>>>>>>>>>>        Function_Return Changed
25780>>>>>>>>>>>    End_Function
25781>>>>>>>>>>>    
25781>>>>>>>>>>>    Procedure Close_Client
25783>>>>>>>>>>>        Send Exit_Function
25784>>>>>>>>>>>    End_Procedure
25785>>>>>>>>>>>    
25785>>>>>>>>>>>End_Class
25786>>>>>>>>>>>
25786>>>>>>>>>>>
25786>>>>>>>>>>>
25786>>>>>>>>>>>//
25786>>>>>>>>>>>// ToolPanel Based Classes
25786>>>>>>>>>>>//
25786>>>>>>>>>>>//  dbFloatingPanel_
25786>>>>>>>>>>>//     dbFloatingPanel
25786>>>>>>>>>>>//        dbViewFloatingPanel
25786>>>>>>>>>>>//           dbViewToolPanel
25786>>>>>>>>>>>//           dbModalPanel <---this will get used
25786>>>>>>>>>>>//
25786>>>>>>>>>>>Class dbFloatingPanel_ is a FloatingPanel STARTMAC ECstart
25787>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25787>>>>>>>>>>>    
25787>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25788>>>>>>>>>>>    
25788>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25788>>>>>>>>>>>    //
25788>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25788>>>>>>>>>>>    Procedure Activating //Returns Integer
25790>>>>>>>>>>>        Integer RVal
25790>>>>>>>>>>>        Forward Get MSG_activating to rVal
25792>>>>>>>>>>>        Procedure_Return rVal
25793>>>>>>>>>>>    End_Procedure
25794>>>>>>>>>>>End_Class
25795>>>>>>>>>>>
25795>>>>>>>>>>>Class dbFloatingPanel is a dbFloatingPanel_
25796>>>>>>>>>>>    Procedure Construct_Object
25798>>>>>>>>>>>        Forward Send Construct_Object No_Image
25800>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25801>>>>>>>>>>>        Set Minimize_Icon to False
25802>>>>>>>>>>>        Set Maximize_Icon to False
25803>>>>>>>>>>>    End_Procedure
25804>>>>>>>>>>>    
25804>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25805>>>>>>>>>>>    
25805>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
25805>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
25805>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
25805>>>>>>>>>>>    //
25805>>>>>>>>>>>    Function DEO_Object Returns Integer
25807>>>>>>>>>>>        Function_Return 1
25808>>>>>>>>>>>    End_Function
25809>>>>>>>>>>>    
25809>>>>>>>>>>>    // we Modify this not delegate and look for a parent verify exit msg if this msg is 0.
25809>>>>>>>>>>>    // We assume that toolpanels and dbModalPanels are self contained in terms of opening and closing
25809>>>>>>>>>>>    // and therefore should only use themselves to figure out if there is a verify exit msg. This is needed
25809>>>>>>>>>>>    // in case a db modal panel physically placed inside of another DEO.
25809>>>>>>>>>>>    Function Verify_Exit_msg Returns Integer
25811>>>>>>>>>>>        Integer msg#
25811>>>>>>>>>>>        Get private.verify_exit_msg to msg#
25812>>>>>>>>>>>        // don't look at parent DEOs like we do elsewhere.
25812>>>>>>>>>>>        //if (msg# = 0 AND Component_State(self)) ;
25812>>>>>>>>>>>        //    delegate get verify_exit_msg to msg#
25812>>>>>>>>>>>        Function_Return msg#
25813>>>>>>>>>>>    End_Function
25814>>>>>>>>>>>    
25814>>>>>>>>>>>End_Class
25815>>>>>>>>>>>
25815>>>>>>>>>>>Class dbViewFloatingPanel is a dbFloatingPanel
25816>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
25817>>>>>>>>>>>End_Class
25818>>>>>>>>>>>
25818>>>>>>>>>>>Class dbViewToolPanel is a dbViewFloatingPanel
25819>>>>>>>>>>>    
25819>>>>>>>>>>>    Procedure Construct_Object
25821>>>>>>>>>>>        Forward Send Construct_Object No_Image
25823>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_TOOLWINDOW True
25824>>>>>>>>>>>    End_Procedure
25825>>>>>>>>>>>    
25825>>>>>>>>>>>End_Class
25826>>>>>>>>>>>
25826>>>>>>>>>>>//  EntryModalPanel
25826>>>>>>>>>>>
25826>>>>>>>>>>>Class dbModalPanel is a dbViewFloatingPanel
25827>>>>>>>>>>>    Procedure Construct_Object
25829>>>>>>>>>>>        Forward Send Construct_Object No_Image
25831>>>>>>>>>>>        
25831>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True
25832>>>>>>>>>>>        Set Modal_State to True
25833>>>>>>>>>>>        
25833>>>>>>>>>>>        Property Integer List_Object  0
25834>>>>>>>>>>>        
25834>>>>>>>>>>>        Property Integer Button_Height     14
25835>>>>>>>>>>>        Property Integer Button_Width      50
25836>>>>>>>>>>>        
25836>>>>>>>>>>>        Property Integer Max_Text_Extent   0
25837>>>>>>>>>>>        
25837>>>>>>>>>>>        Object Button_Ids is an array
25839>>>>>>>>>>>        End_Object
25840>>>>>>>>>>>    End_Procedure
25841>>>>>>>>>>>    
25841>>>>>>>>>>>    Function Button_Count Returns Integer
25843>>>>>>>>>>>        Function_Return (Item_count(Button_Ids))
25844>>>>>>>>>>>    End_Function
25845>>>>>>>>>>>    
25845>>>>>>>>>>>    Procedure Add_Button String sLabel Integer hMsg Integer hoTo
25847>>>>>>>>>>>        Integer hoBtn tx
25847>>>>>>>>>>>        // 8.2 - use newer syntax for creating dynamic objects
25847>>>>>>>>>>>        Get Create U_PointerButton to hoBtn
25848>>>>>>>>>>>        Set peAnchors of hoBtn to anBottomRight
25849>>>>>>>>>>>        Set Value of hoBtn 0 to sLabel
25850>>>>>>>>>>>        Set Message of hoBtn 0 to hMsg
25851>>>>>>>>>>>        If (Num_Arguments>2) ;            Set aux_value of hoBtn 0 to hoTo
25854>>>>>>>>>>>        Get Text_Extent of hoBtn sLabel to tx
25855>>>>>>>>>>>        Move (low(tx)) to tx
25856>>>>>>>>>>>        Set Array_Value of Button_Ids (Button_Count(Self)) to hoBtn
25857>>>>>>>>>>>        If (tx > Max_Text_Extent(Self));            Set Max_Text_Extent to tx
25860>>>>>>>>>>>    End_Procedure
25861>>>>>>>>>>>    
25861>>>>>>>>>>>    Procedure Size_Buttons
25863>>>>>>>>>>>        Integer bheight bwidth nb obj Bobj bt mt gsiz gwd
25863>>>>>>>>>>>        
25863>>>>>>>>>>>        Get button_height to bheight
25864>>>>>>>>>>>        Get button_width  to bwidth
25865>>>>>>>>>>>        Get Button_count to nb
25866>>>>>>>>>>>        Decrement nb
25867>>>>>>>>>>>        
25867>>>>>>>>>>>        Move Button_ids to obj
25868>>>>>>>>>>>        
25868>>>>>>>>>>>        For bt from 0 to nb
25874>>>>>>>>>>>>
25874>>>>>>>>>>>            Get integer_value of obj bt to bobj // button id
25875>>>>>>>>>>>            Set Size of bobj to bheight bwidth       // set dflt size
25876>>>>>>>>>>>            If (bt = 0) Begin
25878>>>>>>>>>>>                Get Max_Text_Extent to mt
25879>>>>>>>>>>>                Add 8 to mt
25880>>>>>>>>>>>                Get guisize of bobj to gsiz
25881>>>>>>>>>>>                Move (low(gsiz)) to gwd
25882>>>>>>>>>>>                If (gwd < mt) Begin
25884>>>>>>>>>>>                    Set guisize of bobj to (hi(gsiz)) mt
25885>>>>>>>>>>>                    Send adjust_logicals to bobj
25886>>>>>>>>>>>                    Move (low(size(bobj))) to bwidth
25887>>>>>>>>>>>                    Set Button_width to bwidth
25888>>>>>>>>>>>                End
25888>>>>>>>>>>>>
25888>>>>>>>>>>>            End
25888>>>>>>>>>>>>
25888>>>>>>>>>>>        Loop
25889>>>>>>>>>>>>
25889>>>>>>>>>>>    End_Procedure
25890>>>>>>>>>>>    
25890>>>>>>>>>>>    Procedure Position_Child_Objects
25892>>>>>>>>>>>        Integer lsz psz wd pwd ht llc nb mt bobj obj cht col bt list_obj
25892>>>>>>>>>>>        Integer rmrgn swd
25892>>>>>>>>>>>        
25892>>>>>>>>>>>        If (not(pbSizeToClientArea(Self))) Begin
25894>>>>>>>>>>>            // if using old sizing, we have not changed anything for 14.0
25894>>>>>>>>>>>            If (caption_bar(Self)) ;                Move (Hi(Physical_fontsize(Self))+4+6) to cht
25897>>>>>>>>>>>            Else ;                Move 0 to cht
25899>>>>>>>>>>>            
25899>>>>>>>>>>>            Get GUISize to psz               // size of panel
25900>>>>>>>>>>>            Get List_Object to List_obj      // id of the list object
25901>>>>>>>>>>>            If list_obj Begin
25903>>>>>>>>>>>                Get GUISize of list_obj to lSz
25904>>>>>>>>>>>                Get GUIlocation of list_obj to llc
25905>>>>>>>>>>>                Move (low(llc)+low(lsz)+2) to rmrgn
25906>>>>>>>>>>>            End
25906>>>>>>>>>>>>
25906>>>>>>>>>>>            Else ;                Move (low(psz)-8) to rmrgn
25908>>>>>>>>>>>            
25908>>>>>>>>>>>            Get Button_count to nb        // number of buttons
25909>>>>>>>>>>>            
25909>>>>>>>>>>>            If (nb = 0) ;                Move ( hi(psz) - 4 - cht - 8) to ht
25912>>>>>>>>>>>            Else Begin
25913>>>>>>>>>>>                Move Button_ids to obj
25914>>>>>>>>>>>                Get integer_value of obj 0 to bobj
25915>>>>>>>>>>>                Get guisize of bobj to ht
25916>>>>>>>>>>>                Move (low(ht)) to wd
25917>>>>>>>>>>>                Move ( hi(ht)) to ht
25918>>>>>>>>>>>                Move 8 to swd // width of each space
25919>>>>>>>>>>>                If ( (rmrgn - ((wd+swd)*nb-swd)) < 0 ) ;                    Move 2 to swd
25922>>>>>>>>>>>                Move ( hi(psz) - ht - 4 - cht - 8) to ht
25923>>>>>>>>>>>                
25923>>>>>>>>>>>                Move (rmrgn-wd) to col
25924>>>>>>>>>>>                Decrement nb
25925>>>>>>>>>>>                While nb ge 0
25929>>>>>>>>>>>                    Get integer_value of obj nb to bobj
25930>>>>>>>>>>>                    Set GUIlocation of bobj to ht col
25931>>>>>>>>>>>                    Send Adjust_Logicals to bobj
25932>>>>>>>>>>>                    Move (col - swd - wd) to col
25933>>>>>>>>>>>                    Decrement nb
25934>>>>>>>>>>>                End
25935>>>>>>>>>>>>
25935>>>>>>>>>>>            End
25935>>>>>>>>>>>>
25935>>>>>>>>>>>            
25935>>>>>>>>>>>            If list_obj Begin
25937>>>>>>>>>>>                Get GUISize of list_obj to lSz
25938>>>>>>>>>>>                Get GUIlocation of list_obj to llc
25939>>>>>>>>>>>                Move ( ht - Hi(llc) - 12 ) to ht
25940>>>>>>>>>>>                Set GUIsize of list_obj to ht (low(lsz))
25941>>>>>>>>>>>                Send Adjust_Logicals to list_obj
25942>>>>>>>>>>>            End
25942>>>>>>>>>>>>
25942>>>>>>>>>>>        End
25942>>>>>>>>>>>>
25942>>>>>>>>>>>        Else Begin
25943>>>>>>>>>>>            
25943>>>>>>>>>>>            // this is still obsolete, but we will make it work with client sizing, which makes it simpler actually
25943>>>>>>>>>>>            // bote that 8 is used through out as the GUI spacing amount. This is legacy and will not be changed
25943>>>>>>>>>>>            
25943>>>>>>>>>>>            Get GUISize to psz               // size of panel
25944>>>>>>>>>>>            Get List_Object to List_obj      // id of the list object
25945>>>>>>>>>>>            If list_obj Begin
25947>>>>>>>>>>>                Get GUISize of list_obj to lSz
25948>>>>>>>>>>>                Get GUIlocation of list_obj to llc
25949>>>>>>>>>>>                Move (low(llc)+low(lsz)) to rmrgn
25950>>>>>>>>>>>            End
25950>>>>>>>>>>>>
25950>>>>>>>>>>>            Else Begin
25951>>>>>>>>>>>                Move (low(psz)-8) to rmrgn
25952>>>>>>>>>>>            End
25952>>>>>>>>>>>>
25952>>>>>>>>>>>            
25952>>>>>>>>>>>            Get Button_count to nb        // number of buttons
25953>>>>>>>>>>>            
25953>>>>>>>>>>>            If (nb = 0) ;                Move ( hi(psz) ) to ht
25956>>>>>>>>>>>            Else Begin
25957>>>>>>>>>>>                Move Button_ids to obj
25958>>>>>>>>>>>                Get integer_value of obj 0 to bobj
25959>>>>>>>>>>>                Get guisize of bobj to ht
25960>>>>>>>>>>>                Move (low(ht)) to wd
25961>>>>>>>>>>>                Move ( hi(ht)) to ht
25962>>>>>>>>>>>                Move 8 to swd // width of each space
25963>>>>>>>>>>>                Move ( hi(psz) - ht - 8) to ht
25964>>>>>>>>>>>                
25964>>>>>>>>>>>                Move (rmrgn-wd) to col
25965>>>>>>>>>>>                Decrement nb
25966>>>>>>>>>>>                While (nb>=0)
25970>>>>>>>>>>>                    Get integer_value of obj nb to bobj
25971>>>>>>>>>>>                    Set GUIlocation of bobj to ht col
25972>>>>>>>>>>>                    Send Adjust_Logicals to bobj
25973>>>>>>>>>>>                    Move (col - swd - wd) to col
25974>>>>>>>>>>>                    Decrement nb
25975>>>>>>>>>>>                End
25976>>>>>>>>>>>>
25976>>>>>>>>>>>            End
25976>>>>>>>>>>>>
25976>>>>>>>>>>>            
25976>>>>>>>>>>>            If list_obj Begin
25978>>>>>>>>>>>                Get GUISize of list_obj to lSz
25979>>>>>>>>>>>                Get GUIlocation of list_obj to llc
25980>>>>>>>>>>>                Move ( ht - Hi(llc) - 8 ) to ht
25981>>>>>>>>>>>                Set GUIsize of list_obj to ht (low(lsz))
25982>>>>>>>>>>>                Send Adjust_Logicals of list_obj
25983>>>>>>>>>>>            End
25983>>>>>>>>>>>>
25983>>>>>>>>>>>        End
25983>>>>>>>>>>>>
25983>>>>>>>>>>>    End_Procedure
25984>>>>>>>>>>>    
25984>>>>>>>>>>>    Procedure End_Construct_Object
25986>>>>>>>>>>>        Send Size_Buttons
25987>>>>>>>>>>>        Send Position_Child_Objects
25988>>>>>>>>>>>        Forward Send end_construct_object
25990>>>>>>>>>>>    End_Procedure
25991>>>>>>>>>>>    
25991>>>>>>>>>>>    Procedure Search
25993>>>>>>>>>>>        Integer Obj#
25993>>>>>>>>>>>        Get List_Object to obj#
25994>>>>>>>>>>>        If Obj# ;            Send Search to Obj#
25997>>>>>>>>>>>    End_Procedure
25998>>>>>>>>>>>    
25998>>>>>>>>>>>    // created for advanced CD_popup_object support. Returns the true handle of the
25998>>>>>>>>>>>    // popup object whether it is a regular object or a CD popup object.
25998>>>>>>>>>>>    Function Popup_Handle Returns Handle
26000>>>>>>>>>>>        Function_Return Self
26001>>>>>>>>>>>    End_Function
26002>>>>>>>>>>>    
26002>>>>>>>>>>>End_Class
26003>>>>>>>>>>>
26003>>>>>>>>>>>//
26003>>>>>>>>>>>// Panel Based Classes
26003>>>>>>>>>>>//
26003>>>>>>>>>>>//  dbPanel_
26003>>>>>>>>>>>//     dbPanel
26003>>>>>>>>>>>//        dbViewPanel_
26003>>>>>>>>>>>//           dbViewPanel
26003>>>>>>>>>>>//
26003>>>>>>>>>>>// None of these are likely to be used
26003>>>>>>>>>>>//
26003>>>>>>>>>>>
26003>>>>>>>>>>>Class dbPanel_ is a BasicPanel STARTMAC ECstart
26004>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
26004>>>>>>>>>>>    
26004>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
26005>>>>>>>>>>>    
26005>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
26005>>>>>>>>>>>    //
26005>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
26005>>>>>>>>>>>    Procedure Activating //Returns Integer
26007>>>>>>>>>>>        Integer RVal
26007>>>>>>>>>>>        Forward Get MSG_activating to rVal
26009>>>>>>>>>>>        Procedure_Return rVal
26010>>>>>>>>>>>    End_Procedure
26011>>>>>>>>>>>End_Class
26012>>>>>>>>>>>
26012>>>>>>>>>>>Class dbPanel is a dbPanel_
26013>>>>>>>>>>>    Procedure Construct_Object
26015>>>>>>>>>>>        Forward Send Construct_Object No_Image
26017>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
26018>>>>>>>>>>>    End_Procedure
26019>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
26020>>>>>>>>>>>End_Class
26021>>>>>>>>>>>
26021>>>>>>>>>>>Class dbViewPanel_ is a dbPanel
26022>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
26023>>>>>>>>>>>End_Class
26024>>>>>>>>>>>
26024>>>>>>>>>>>Class dbViewPanel is a dbViewPanel_
26025>>>>>>>>>>>    Procedure Construct_Object
26027>>>>>>>>>>>        Forward Send Construct_Object No_Image
26029>>>>>>>>>>>    End_Procedure
26030>>>>>>>>>>>    
26030>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
26030>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
26030>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
26030>>>>>>>>>>>    //
26030>>>>>>>>>>>    Function DEO_Object Returns Integer
26032>>>>>>>>>>>        Function_Return 1
26033>>>>>>>>>>>    End_Function
26034>>>>>>>>>>>End_Class
26035>>>>>>>>>Use DFbitmap.pkg
Including file: Dfbitmap.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Dfbitmap.pkg)
26035>>>>>>>>>>>Use LanguageText.pkg
26035>>>>>>>>>>>Use Windows.pkg
26035>>>>>>>>>>>Use File_Dlg.pkg
26035>>>>>>>>>>>
26035>>>>>>>>>>>Class BitmapContainer is a Container3D
26036>>>>>>>>>>>    
26036>>>>>>>>>>>    Procedure Construct_Object
26038>>>>>>>>>>>        Forward Send Construct_Object
26040>>>>>>>>>>>        
26040>>>>>>>>>>>        Property Integer Changed_State False
26041>>>>>>>>>>>        
26041>>>>>>>>>>>        // If true, double click sends Get Select_Bitmap which invokes
26041>>>>>>>>>>>        // an open file dialog
26041>>>>>>>>>>>        Property Integer Allow_Select_Bitmap_State  False
26042>>>>>>>>>>>        
26042>>>>>>>>>>>        // title for common file dialog
26042>>>>>>>>>>>        Property String Dialog_Caption C_$SelectBitmapFile
26043>>>>>>>>>>>        
26043>>>>>>>>>>>        // start-up directory for common file dialog
26043>>>>>>>>>>>        Property String Initial_Folder ""
26044>>>>>>>>>>>        
26044>>>>>>>>>>>        Send Define_ToolTip_Support_Mixin
26045>>>>>>>>>>>        
26045>>>>>>>>>>>        // this object should not take the focus
26045>>>>>>>>>>>        Set Focus_Mode to NonFocusable
26046>>>>>>>>>>>        Set Client_Area_State to False
26047>>>>>>>>>>>        Set pbUseFormWindowHandle to False   // must come after Define_ToolTip_Support_Mixin
26048>>>>>>>>>>>    End_Procedure
26049>>>>>>>>>>>    
26049>>>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
26050>>>>>>>>>>>    
26050>>>>>>>>>>>    // Although this is not a client it should add child objects to
26050>>>>>>>>>>>    // the focus tree. Should only be textboxes!
26050>>>>>>>>>>>    //
26050>>>>>>>>>>>    Procedure Add_Focus Integer Obj
26052>>>>>>>>>>>        Forward Send Add_Focus Obj
26054>>>>>>>>>>>        Broadcast Send Add_Focus Self
26056>>>>>>>>>>>    End_Procedure
26057>>>>>>>>>>>    
26057>>>>>>>>>>>    // Popup an open file dialog and select a bitmap file. Returns file
26057>>>>>>>>>>>    // name
26057>>>>>>>>>>>    //
26057>>>>>>>>>>>    Function Select_Bitmap Returns String
26059>>>>>>>>>>>        String sFileName
26059>>>>>>>>>>>        String sPropVal
26059>>>>>>>>>>>        Integer iRet
26059>>>>>>>>>>>        Handle hoOpenFile
26059>>>>>>>>>>>        
26059>>>>>>>>>>>        Get Create U_OpenDialog to  hoOpenFile
26060>>>>>>>>>>>        // Mask will look like this: "Bitmaps (.bmp;*.rle)|*.bmp;*.rle|All Files (*.*)|*.*"
26060>>>>>>>>>>>        Set Filter_String  of hoOpenFile to (C_$Bitmaps * "(.bmp;*.rle)|*.bmp;*.rle|" + C_$AllFiles * "(*.*)|*.*")
26061>>>>>>>>>>>        Get Dialog_Caption to sPropVal
26062>>>>>>>>>>>        Set Dialog_Caption of hoOpenFile to sPropVal
26063>>>>>>>>>>>        Get Initial_Folder to sPropVal
26064>>>>>>>>>>>        Set Initial_Folder of hoOpenFile to sPropVal
26065>>>>>>>>>>>        Get Show_Dialog    of hoOpenFile  to iRet
26066>>>>>>>>>>>        If iRet ;            Get File_Name of hoOpenFile  to sFileName
26069>>>>>>>>>>>        Send Destroy of hoOpenFile
26070>>>>>>>>>>>        Function_Return sFileName
26071>>>>>>>>>>>    End_Function
26072>>>>>>>>>>>    
26072>>>>>>>>>>>    Procedure Invoke_Select_Bitmap
26074>>>>>>>>>>>        String sFileName
26074>>>>>>>>>>>        Get Select_Bitmap to sFileName
26075>>>>>>>>>>>        If (sFileName<>"") Begin
26077>>>>>>>>>>>            Set Bitmap to sFileName
26078>>>>>>>>>>>            Set Changed_State to True
26079>>>>>>>>>>>        End
26079>>>>>>>>>>>>
26079>>>>>>>>>>>    End_Procedure
26080>>>>>>>>>>>    
26080>>>>>>>>>>>    
26080>>>>>>>>>>>    // Augmented to invoke the filedialog to retrieve a new bitmap
26080>>>>>>>>>>>    Procedure Mouse_Click Integer i1 Integer i2
26082>>>>>>>>>>>        Forward Send Mouse_Click i1 i2
26084>>>>>>>>>>>        If (Allow_Select_Bitmap_State(Self)) Begin
26086>>>>>>>>>>>            Send Invoke_Select_Bitmap
26087>>>>>>>>>>>        End
26087>>>>>>>>>>>>
26087>>>>>>>>>>>    End_Procedure
26088>>>>>>>>>>>    
26088>>>>>>>>>>>    Procedure Page_Object Integer iState
26090>>>>>>>>>>>        Forward Send Page_Object iState
26092>>>>>>>>>>>        
26092>>>>>>>>>>>        // Handle tooltip support....
26092>>>>>>>>>>>        If (iState = 0) Begin
26094>>>>>>>>>>>            Send RequestDeleteToolTip
26095>>>>>>>>>>>        End
26095>>>>>>>>>>>>
26095>>>>>>>>>>>        Else Begin
26096>>>>>>>>>>>            Send RequestAddToolTip
26097>>>>>>>>>>>        End
26097>>>>>>>>>>>>
26097>>>>>>>>>>>    End_Procedure
26098>>>>>>>>>>>    
26098>>>>>>>>>>>    
26098>>>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
26098>>>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
26098>>>>>>>>>>>    // is implemented in a mixin class.
26098>>>>>>>>>>>    Procedure RequestAddToolTip
26100>>>>>>>>>>>        Send AddToolTip
26101>>>>>>>>>>>    End_Procedure
26102>>>>>>>>>>>    
26102>>>>>>>>>>>    
26102>>>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
26102>>>>>>>>>>>    Procedure RequestDeleteToolTip
26104>>>>>>>>>>>        Send DeleteToolTip
26105>>>>>>>>>>>    End_Procedure
26106>>>>>>>>>>>End_Class
26107>>>>>>>>>Use GlobalFunctionsProcedures.pkg
26107>>>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cRichEdit.pkg)
26107>>>>>>>>>>>Use Windows.pkg
26107>>>>>>>>>>>Use cEdit_Mixin.pkg
Including file: cEdit_mixin.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cEdit_mixin.pkg)
26107>>>>>>>>>>>>>// mixin used by both cRichEdit and cTextEdit
26107>>>>>>>>>>>>>Use Windows.pkg
26107>>>>>>>>>>>>>
26107>>>>>>>>>>>>>// for undoType and RedoType
26107>>>>>>>>>>>>>Enum_List
26107>>>>>>>>>>>>>    Define utUnknown
26107>>>>>>>>>>>>>    Define utTyping
26107>>>>>>>>>>>>>    Define utDelete
26107>>>>>>>>>>>>>    Define utDragDrop
26107>>>>>>>>>>>>>    Define utCut
26107>>>>>>>>>>>>>    Define utPaste
26107>>>>>>>>>>>>>End_Enum_List
26107>>>>>>>>>>>>>
26107>>>>>>>>>>>>>Class cEdit_Mixin is a Mixin
26108>>>>>>>>>>>>>    
26108>>>>>>>>>>>>>    Procedure Define_cEdit_Mixin
26110>>>>>>>>>>>>>        Send Define_Standard_Object_Mixin
26111>>>>>>>>>>>>>        Send Define_Dflabel_Mixin
26112>>>>>>>>>>>>>        Send Define_ToolTip_Support_Mixin
26113>>>>>>>>>>>>>        
26113>>>>>>>>>>>>>        Set Label_Offset to 1 0
26114>>>>>>>>>>>>>        Set Label_Justification_Mode to Jmode_Top
26115>>>>>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
26116>>>>>>>>>>>>>        Set Color     to clWindow      // should be the default...also system colors don't work
26117>>>>>>>>>>>>>        Set TextColor to clWindowText  // should be the default
26118>>>>>>>>>>>>>        
26118>>>>>>>>>>>>>        Property Boolean Changed_State False
26119>>>>>>>>>>>>>        
26119>>>>>>>>>>>>>        Property Integer pbSuppressChange False
26120>>>>>>>>>>>>>        
26120>>>>>>>>>>>>>        Property Integer piPriorEnabledColor 0 // private, used by shadow_display
26121>>>>>>>>>>>>>        
26121>>>>>>>>>>>>>        Send Define_Shadow_Mixin
26122>>>>>>>>>>>>>        
26122>>>>>>>>>>>>>        Property Integer Floating_Menu_Object Default_Form_Floating_Menu_Id
26123>>>>>>>>>>>>>        
26123>>>>>>>>>>>>>        On_Key kEnter Send default_key
26124>>>>>>>>>>>>>        
26124>>>>>>>>>>>>>        Set Disable_default_action_button_state to True
26125>>>>>>>>>>>>>        
26125>>>>>>>>>>>>>    End_Procedure
26126>>>>>>>>>>>>>    
26126>>>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
26127>>>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
26128>>>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
26129>>>>>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
26130>>>>>>>>>>>>>    
26130>>>>>>>>>>>>>    // currently there is no built in context menu support (old edit has one).
26130>>>>>>>>>>>>>    Procedure Mouse_Down2 Integer iWindowNumber Integer iPosition
26132>>>>>>>>>>>>>        Integer obj rval
26132>>>>>>>>>>>>>        Forward Send mouse_down2 iWindowNumber iPosition
26134>>>>>>>>>>>>>        Get Floating_Menu_object to obj
26135>>>>>>>>>>>>>        If obj Begin
26137>>>>>>>>>>>>>            If (Focus(desktop)<>Self) Begin
26139>>>>>>>>>>>>>                Get msg_Activate to rval
26140>>>>>>>>>>>>>            End
26140>>>>>>>>>>>>>>
26140>>>>>>>>>>>>>            If (Focus(desktop)=Self) Begin
26142>>>>>>>>>>>>>                Send Popup to obj
26143>>>>>>>>>>>>>            End
26143>>>>>>>>>>>>>>
26143>>>>>>>>>>>>>        End
26143>>>>>>>>>>>>>>
26143>>>>>>>>>>>>>    End_Procedure
26144>>>>>>>>>>>>>    
26144>>>>>>>>>>>>>    Function Object_Shadow_State Returns Integer
26146>>>>>>>>>>>>>        Function_Return (Private.Shadow_State(Self))
26147>>>>>>>>>>>>>    End_Function
26148>>>>>>>>>>>>>    
26148>>>>>>>>>>>>>    // enables or disables an active window. Allows enabled_state to be used after object is paged
26148>>>>>>>>>>>>>    Procedure Enable_Window Integer iState
26150>>>>>>>>>>>>>        Handle hWnd
26150>>>>>>>>>>>>>        Get Window_Handle to hWnd
26151>>>>>>>>>>>>>        If hWnd ;            Move (EnableWindow(hWnd,iState)) to hWnd
26154>>>>>>>>>>>>>    End_Procedure
26155>>>>>>>>>>>>>    
26155>>>>>>>>>>>>>    Procedure Set Current_Shadow_State Integer iState
26157>>>>>>>>>>>>>        Set Private.Shadow_State to iState     // used by get object_shadow_state/enabled_state
26158>>>>>>>>>>>>>        Set Window_Style to WS_DISABLED iState // used to set style before the object is paged
26159>>>>>>>>>>>>>        Send Enable_Window (not(iState))       // used to enable/disable after object is paged
26160>>>>>>>>>>>>>    End_Procedure
26161>>>>>>>>>>>>>    
26161>>>>>>>>>>>>>    
26161>>>>>>>>>>>>>    Procedure Shadow_Display
26163>>>>>>>>>>>>>        // control will take care of shadowing itself
26163>>>>>>>>>>>>>        Send Label_Shadow_Display // if object has a label text box, handle disabling this
26164>>>>>>>>>>>>>    End_Procedure
26165>>>>>>>>>>>>>    
26165>>>>>>>>>>>>>    Procedure Set Item_Shadow_State Integer iItem Integer iState
26167>>>>>>>>>>>>>    End_Procedure
26168>>>>>>>>>>>>>    
26168>>>>>>>>>>>>>    Function Item_Shadow_State Integer iItem Returns Integer
26170>>>>>>>>>>>>>    End_Function
26171>>>>>>>>>>>>>    
26171>>>>>>>>>>>>>    Procedure OnChange
26173>>>>>>>>>>>>>    End_Procedure
26174>>>>>>>>>>>>>    
26174>>>>>>>>>>>>>    Procedure OnMaxText
26176>>>>>>>>>>>>>    End_Procedure
26177>>>>>>>>>>>>>    
26177>>>>>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
26179>>>>>>>>>>>>>        Integer iParam
26179>>>>>>>>>>>>>        Forward Send Command wParam lParam
26181>>>>>>>>>>>>>        Move (hi(wParam)) to iParam
26182>>>>>>>>>>>>>        If (iParam=EN_CHANGE) Begin
26184>>>>>>>>>>>>>            // if we are supressing change notification, do nothing.
26184>>>>>>>>>>>>>            If (pbSuppressChange(Self)) ;                Procedure_Return
26187>>>>>>>>>>>>>            If not (changed_state(Self)) Begin
26189>>>>>>>>>>>>>                Set Changed_state to True
26190>>>>>>>>>>>>>            End
26190>>>>>>>>>>>>>>
26190>>>>>>>>>>>>>            Send OnChange
26191>>>>>>>>>>>>>        End
26191>>>>>>>>>>>>>>
26191>>>>>>>>>>>>>        Else If (iParam=EN_MAXTEXT) Begin
26194>>>>>>>>>>>>>            Send OnMaxText
26195>>>>>>>>>>>>>        End
26195>>>>>>>>>>>>>>
26195>>>>>>>>>>>>>    End_Procedure
26196>>>>>>>>>>>>>    
26196>>>>>>>>>>>>>    // Some messages trigger the command message with a change event. In some circumstances we must suppress this.
26196>>>>>>>>>>>>>    // The delete_data message and the page message both do this.
26196>>>>>>>>>>>>>    
26196>>>>>>>>>>>>>    Procedure Delete_Data
26198>>>>>>>>>>>>>        Boolean bWas
26198>>>>>>>>>>>>>        Get pbSuppressChange to bWas
26199>>>>>>>>>>>>>        Set pbSuppressChange to True // Delete_Data sends command which triggers change. We suppress that here
26200>>>>>>>>>>>>>        Forward Send delete_data
26202>>>>>>>>>>>>>        Set changed_state to False
26203>>>>>>>>>>>>>        Send OnChange
26204>>>>>>>>>>>>>        Set pbSuppressChange to bWas
26205>>>>>>>>>>>>>    End_Procedure
26206>>>>>>>>>>>>>    
26206>>>>>>>>>>>>>    Procedure Page Integer iState
26208>>>>>>>>>>>>>        Boolean bWas
26208>>>>>>>>>>>>>        Get pbSuppressChange to bWas
26209>>>>>>>>>>>>>        Set pbSuppressChange to True  // Page sends command which triggers change. We suppress that here
26210>>>>>>>>>>>>>        Forward Send Page iState
26212>>>>>>>>>>>>>        Set pbSuppressChange to bWas
26213>>>>>>>>>>>>>    End_Procedure
26214>>>>>>>>>>>>>    
26214>>>>>>>>>>>>>    
26214>>>>>>>>>>>>>    Procedure AppendTextLn String sText
26216>>>>>>>>>>>>>        Send AppendText sText
26217>>>>>>>>>>>>>        Send AppendText (character(10))
26218>>>>>>>>>>>>>    End_Procedure
26219>>>>>>>>>>>>>    
26219>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
26219>>>>>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
26219>>>>>>>>>>>>>    // is implemented in a mixin class.
26219>>>>>>>>>>>>>    Procedure RequestAddToolTip
26221>>>>>>>>>>>>>        Send AddToolTip
26222>>>>>>>>>>>>>    End_Procedure
26223>>>>>>>>>>>>>    
26223>>>>>>>>>>>>>    
26223>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
26223>>>>>>>>>>>>>    Procedure RequestDeleteToolTip
26225>>>>>>>>>>>>>        Send DeleteToolTip
26226>>>>>>>>>>>>>    End_Procedure
26227>>>>>>>>>>>>>End_Class
26228>>>>>>>>>>>
26228>>>>>>>>>>>// constants used for RichEdit Properties
26228>>>>>>>>>>>// peAlignment
26228>>>>>>>>>>>Enum_List
26228>>>>>>>>>>>    Define alLeft   for 1
26228>>>>>>>>>>>    Define alRight  for 2
26228>>>>>>>>>>>    Define alCenter for 3
26228>>>>>>>>>>>End_Enum_List
26228>>>>>>>>>>>
26228>>>>>>>>>>>// peBullets
26228>>>>>>>>>>>Enum_List
26228>>>>>>>>>>>    Define buNone
26228>>>>>>>>>>>    Define buBullets
26228>>>>>>>>>>>    Define buArabicNumbers
26228>>>>>>>>>>>    Define buLowerLetters
26228>>>>>>>>>>>    Define buUpperLetters
26228>>>>>>>>>>>    Define buLowerRomans
26228>>>>>>>>>>>    Define buUpperRomans
26228>>>>>>>>>>>End_Enum_List
26228>>>>>>>>>>>
26228>>>>>>>>>>>// peBulletStyle
26228>>>>>>>>>>>Enum_List
26228>>>>>>>>>>>    Define busRightParen   for 0
26228>>>>>>>>>>>    Define busEncloseParen for 256
26228>>>>>>>>>>>    Define busPeriod       for 512
26228>>>>>>>>>>>    Define busNumberOnly   for 768
26228>>>>>>>>>>>    Define busNoDisplay    for 1024
26228>>>>>>>>>>>End_Enum_List
26228>>>>>>>>>>>
26228>>>>>>>>>>>// peLineSpacingType
26228>>>>>>>>>>>Enum_List
26228>>>>>>>>>>>    Define lstSingle
26228>>>>>>>>>>>    Define lstSingleAndOneHalf
26228>>>>>>>>>>>    Define lstDouble
26228>>>>>>>>>>>End_Enum_List
26228>>>>>>>>>>>
26228>>>>>>>>>>>Class cRichEdit is a DFBaseRichEdit
26229>>>>>>>>>>>    
26229>>>>>>>>>>>    Procedure Construct_Object
26231>>>>>>>>>>>        Forward Send Construct_Object
26233>>>>>>>>>>>        Send Define_cEdit_Mixin
26234>>>>>>>>>>>        
26234>>>>>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
26235>>>>>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
26236>>>>>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
26237>>>>>>>>>>>        
26237>>>>>>>>>>>    End_Procedure
26238>>>>>>>>>>>    
26238>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
26239>>>>>>>>>>>    
26239>>>>>>>>>>>    Procedure ToggleBold
26241>>>>>>>>>>>        Set pbBold to (not(pbBold(Self)))
26242>>>>>>>>>>>    End_Procedure
26243>>>>>>>>>>>    
26243>>>>>>>>>>>    Procedure ToggleItalics
26245>>>>>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
26246>>>>>>>>>>>    End_Procedure
26247>>>>>>>>>>>    
26247>>>>>>>>>>>    Procedure ToggleUnderline
26249>>>>>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
26250>>>>>>>>>>>    End_Procedure
26251>>>>>>>>>>>    
26251>>>>>>>>>>>End_Class
26252>>>>>>>>>>>
26252>>>>>>>>>>>
26252>>>>>>>>>Use cTextEdit.pkg
Including file: cTextEdit.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cTextEdit.pkg)
26252>>>>>>>>>>>use Windows.pkg
26252>>>>>>>>>>>Use cEdit_Mixin.pkg
26252>>>>>>>>>>>
26252>>>>>>>>>>>Class cTextEdit is a DFBaseTextEdit
26253>>>>>>>>>>>    
26253>>>>>>>>>>>    Procedure Construct_Object
26255>>>>>>>>>>>        Forward Send Construct_Object
26257>>>>>>>>>>>        Send Define_cEdit_Mixin
26258>>>>>>>>>>>    End_Procedure
26259>>>>>>>>>>>    
26259>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
26260>>>>>>>>>>>    
26260>>>>>>>>>>>End_Class
26261>>>>>>>>>>>
26261>>>>>>>>>>>
26261>>>>>>>>>>>
26261>>>>>>>>>Use cRichEdit.pkg
26261>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 20.1\Pkg\gFormatNumbers.pkg)
26261>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cFormatter.pkg)
26261>>>>>>>>>>>>>Use VDFBase.pkg
26261>>>>>>>>>>>>>
26261>>>>>>>>>>>>>Class cFormatter is an cObject
26262>>>>>>>>>>>>>    
26262>>>>>>>>>>>>>    Procedure Construct_object
26264>>>>>>>>>>>>>        Integer iCh
26264>>>>>>>>>>>>>        Forward Send construct_object
26266>>>>>>>>>>>>>        Property String  psCurrencySymbol
26267>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
26268>>>>>>>>>>>>>        
26268>>>>>>>>>>>>>        Property String  psLeft
26269>>>>>>>>>>>>>        Property String  psright
26270>>>>>>>>>>>>>        Property Integer pbThousandsSep
26271>>>>>>>>>>>>>        Property Integer piPoints
26272>>>>>>>>>>>>>        
26272>>>>>>>>>>>>>        Property String  psCurPosLeft
26273>>>>>>>>>>>>>        Property String  psCurPosright
26274>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
26275>>>>>>>>>>>>>        Property Integer piCurPosPoints
26276>>>>>>>>>>>>>        
26276>>>>>>>>>>>>>        Property String  psCurNegLeft
26277>>>>>>>>>>>>>        Property String  psCurNegright
26278>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
26279>>>>>>>>>>>>>        Property Integer piCurNegPoints
26280>>>>>>>>>>>>>        
26280>>>>>>>>>>>>>        Property String  psNumPosLeft
26281>>>>>>>>>>>>>        Property String  psNumPosright
26282>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
26283>>>>>>>>>>>>>        Property Integer piNumPosPoints
26284>>>>>>>>>>>>>        
26284>>>>>>>>>>>>>        Property String  psNumNegLeft
26285>>>>>>>>>>>>>        Property String  psNumNegright
26286>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
26287>>>>>>>>>>>>>        Property Integer piNumNegPoints
26288>>>>>>>>>>>>>        
26288>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
26289>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
26290>>>>>>>>>>>>>        
26290>>>>>>>>>>>>>    End_Procedure
26291>>>>>>>>>>>>>    
26291>>>>>>>>>>>>>    // internal
26291>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
26291>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
26293>>>>>>>>>>>>>        
26293>>>>>>>>>>>>>        String sLeft sRight sDigit
26293>>>>>>>>>>>>>        Integer bSep iPos i iDigits
26293>>>>>>>>>>>>>        
26293>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
26293>>>>>>>>>>>>>        // some literals are special. $ . , / #
26293>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
26294>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
26295>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
26296>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
26297>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
26298>>>>>>>>>>>>>        Move (Character(9)) to sDigit
26299>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
26300>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
26301>>>>>>>>>>>>>        
26301>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
26302>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
26305>>>>>>>>>>>>>        
26305>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
26306>>>>>>>>>>>>>        
26306>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
26307>>>>>>>>>>>>>        
26307>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
26307>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
26308>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
26309>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
26310>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
26311>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
26312>>>>>>>>>>>>>        
26312>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
26314>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
26315>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
26317>>>>>>>>>>>>>                Move -2 to iDigits
26318>>>>>>>>>>>>>                Increment i
26319>>>>>>>>>>>>>            End
26319>>>>>>>>>>>>>>
26319>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
26323>>>>>>>>>>>>>                Increment i
26324>>>>>>>>>>>>>            Loop
26325>>>>>>>>>>>>>>
26325>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
26326>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
26329>>>>>>>>>>>>>            //
26329>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
26330>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
26334>>>>>>>>>>>>>                Increment i
26335>>>>>>>>>>>>>            Loop
26336>>>>>>>>>>>>>>
26336>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
26337>>>>>>>>>>>>>        End
26337>>>>>>>>>>>>>>
26337>>>>>>>>>>>>>        Else Begin                             // we have no decinal
26338>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
26339>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
26340>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
26342>>>>>>>>>>>>>                Move sFmt to sLeft
26343>>>>>>>>>>>>>                Move ""   to sRight
26344>>>>>>>>>>>>>            End
26344>>>>>>>>>>>>>>
26344>>>>>>>>>>>>>            Else Begin
26345>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
26346>>>>>>>>>>>>>                Move 1 to i
26347>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
26351>>>>>>>>>>>>>                    Increment i
26352>>>>>>>>>>>>>                Loop
26353>>>>>>>>>>>>>>
26353>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
26354>>>>>>>>>>>>>            End
26354>>>>>>>>>>>>>>
26354>>>>>>>>>>>>>        End
26354>>>>>>>>>>>>>>
26354>>>>>>>>>>>>>        // set temporary format properties and exit
26354>>>>>>>>>>>>>        Set pbThousandsSep to bSep
26355>>>>>>>>>>>>>        Set psLeft         to sLeft
26356>>>>>>>>>>>>>        Set psRight        to sRight
26357>>>>>>>>>>>>>        Set piPoints       to iDigits
26358>>>>>>>>>>>>>    End_Procedure
26359>>>>>>>>>>>>>    
26359>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
26359>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
26359>>>>>>>>>>>>>    //
26359>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
26359>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
26361>>>>>>>>>>>>>        String sPos sNeg
26361>>>>>>>>>>>>>        Integer iPos
26361>>>>>>>>>>>>>        
26361>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
26362>>>>>>>>>>>>>        If iPos Begin
26364>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
26365>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
26366>>>>>>>>>>>>>        End
26366>>>>>>>>>>>>>>
26366>>>>>>>>>>>>>        Else Begin
26367>>>>>>>>>>>>>            Move sFmt         to sPos
26368>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
26369>>>>>>>>>>>>>        End
26369>>>>>>>>>>>>>>
26369>>>>>>>>>>>>>        Send ParseFormat sPos
26370>>>>>>>>>>>>>        If bCurrency Begin
26372>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
26373>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
26374>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
26375>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
26376>>>>>>>>>>>>>        End
26376>>>>>>>>>>>>>>
26376>>>>>>>>>>>>>        Else Begin
26377>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
26378>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
26379>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
26380>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
26381>>>>>>>>>>>>>        End
26381>>>>>>>>>>>>>>
26381>>>>>>>>>>>>>        
26381>>>>>>>>>>>>>        Send ParseFormat sNeg
26382>>>>>>>>>>>>>        If bCurrency Begin
26384>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
26385>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
26386>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
26387>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
26388>>>>>>>>>>>>>        End
26388>>>>>>>>>>>>>>
26388>>>>>>>>>>>>>        Else Begin
26389>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
26390>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
26391>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
26392>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
26393>>>>>>>>>>>>>        End
26393>>>>>>>>>>>>>>
26393>>>>>>>>>>>>>    End_Procedure
26394>>>>>>>>>>>>>    
26394>>>>>>>>>>>>>    // low level formatting. Pass parameters
26394>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
26396>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
26396>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
26396>>>>>>>>>>>>>        
26396>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
26399>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
26400>>>>>>>>>>>>>        
26400>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
26401>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
26402>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
26403>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
26404>>>>>>>>>>>>>        // format for decimal separator
26404>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
26407>>>>>>>>>>>>>        
26407>>>>>>>>>>>>>        // format for thousand sep.
26407>>>>>>>>>>>>>        If bSep Begin
26409>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
26412>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
26413>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
26414>>>>>>>>>>>>>            While (iLen>3)
26418>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
26419>>>>>>>>>>>>>                Move (iLen-3) to iLen
26420>>>>>>>>>>>>>            Loop
26421>>>>>>>>>>>>>>
26421>>>>>>>>>>>>>        End
26421>>>>>>>>>>>>>>
26421>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
26421>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
26424>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
26425>>>>>>>>>>>>>    End_Function
26426>>>>>>>>>>>>>    
26426>>>>>>>>>>>>>    // Public: Format for currency
26426>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
26428>>>>>>>>>>>>>        String  sLeft sRight
26428>>>>>>>>>>>>>        Integer bSep
26428>>>>>>>>>>>>>        If (nNumber<0) Begin
26430>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
26431>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
26432>>>>>>>>>>>>>            Get psCurNegRight        to sRight
26433>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
26436>>>>>>>>>>>>>        End
26436>>>>>>>>>>>>>>
26436>>>>>>>>>>>>>        Else Begin
26437>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
26438>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
26439>>>>>>>>>>>>>            Get psCurPosRight        to sRight
26440>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
26443>>>>>>>>>>>>>        End
26443>>>>>>>>>>>>>>
26443>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26444>>>>>>>>>>>>>    End_Function
26445>>>>>>>>>>>>>    
26445>>>>>>>>>>>>>    // Public: Format for numeric
26445>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
26447>>>>>>>>>>>>>        String  sLeft sRight
26447>>>>>>>>>>>>>        Integer bSep
26447>>>>>>>>>>>>>        If (nNumber<0) Begin
26449>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
26450>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
26451>>>>>>>>>>>>>            Get psNumNegRight        to sRight
26452>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
26455>>>>>>>>>>>>>        End
26455>>>>>>>>>>>>>>
26455>>>>>>>>>>>>>        Else Begin
26456>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
26457>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
26458>>>>>>>>>>>>>            Get psNumPosRight        to sRight
26459>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
26462>>>>>>>>>>>>>        End
26462>>>>>>>>>>>>>>
26462>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26463>>>>>>>>>>>>>    End_Function
26464>>>>>>>>>>>>>    
26464>>>>>>>>>>>>>    
26464>>>>>>>>>>>>>    // Public: Format passing format string
26464>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
26466>>>>>>>>>>>>>        Integer iPos bIsNeg
26466>>>>>>>>>>>>>        String  sLeft sRight
26466>>>>>>>>>>>>>        Integer iPoints bSep
26466>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
26467>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
26468>>>>>>>>>>>>>        Case Begin
26468>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
26471>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
26475>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
26479>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
26481>>>>>>>>>>>>>        Case End
26481>>>>>>>>>>>>>        Send ParseFormat sFmt
26482>>>>>>>>>>>>>        Get pbThousandsSep to bSep
26483>>>>>>>>>>>>>        Get psLeft         to sLeft
26484>>>>>>>>>>>>>        Get psRight        to sRight
26485>>>>>>>>>>>>>        Get piPoints       to iPoints
26486>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26487>>>>>>>>>>>>>    End_Function
26488>>>>>>>>>>>>>    
26488>>>>>>>>>>>>>End_Class
26489>>>>>>>>>>>
26489>>>>>>>>>>>Global_Variable Handle ghoFormatter
26489>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
26490>>>>>>>>>>>
26490>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
26492>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
26493>>>>>>>>>>>End_Function
26494>>>>>>>>>>>
26494>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
26496>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
26497>>>>>>>>>>>End_Function
26498>>>>>>>>>>>
26498>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
26500>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
26501>>>>>>>>>>>End_Function
26502>>>>>>>>>>>
26502>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
26504>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
26505>>>>>>>>>>>End_Procedure
26506>>>>>>>>>>>
26506>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
26508>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
26509>>>>>>>>>>>End_Procedure
26510>>>>>>>>>>>
26510>>>>>>>>>>>
26510>>>>>>>>>Use tWinStructs.pkg
26510>>>>>>>>>
26510>>>>>>>>>Use cli.pkg
26510>>>>>>>>>Use DFBTRDRV.PKG
26510>>>>>>>>>Use MSSqldrv.pkg
26510>>>>>>>>>Use db2_drv.pkg
26510>>>>>>>>>Use odbc_drv.pkg
26510>>>>>>>>>Use seq_chnl.pkg
26510>>>>>>>>>
26510>>>>>>>>>Register_Function phoWorkspace Returns Handle
26510>>>>>>>>>Register_Function Help_filename Returns String
26510>>>>>>>>>Register_Function GetHelpFile Returns String
26510>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
26510>>>>>>>>>
26510>>>>>>>>>// Use of Mertech drivers:
26510>>>>>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>// *** Constant Declarations: ***
26510>>>>>>>>>//
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>// System icon menu constants. If the upper left hand
26510>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
26510>>>>>>>>>    Define SC_RESTORE  for |CI$F120
26510>>>>>>>>>    Define SC_MOVE     for |CI$F010
26510>>>>>>>>>    Define SC_SIZE     for |CI$F000
26510>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
26510>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
26510>>>>>>>>>    Define SC_CLOSE    for |CI$F060
26510>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
26510>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
26510>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
26510>>>>>>>>>
26510>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
26510>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
26510>>>>>>>>>Define CS_VerifyCredentials  for "verify"
26510>>>>>>>>>Define CS_VerifyFileParam    for "/a"
26510>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
26510>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
26510>>>>>>>>>
26510>>>>>>>>>// *** Struct Declarations: ***
26510>>>>>>>>>
26510>>>>>>>>>Struct AboutSHELLEXECUTEINFO
26510>>>>>>>>>    DWord   cbSize
26510>>>>>>>>>    Integer fMask
26510>>>>>>>>>    Handle  hwnd
26510>>>>>>>>>    Pointer lpVerb
26510>>>>>>>>>    Pointer lpFile
26510>>>>>>>>>    Pointer lpParameters
26510>>>>>>>>>    Pointer lpDirectory
26510>>>>>>>>>    Integer nShow
26510>>>>>>>>>    Pointer hInstApp
26510>>>>>>>>>    Pointer lpIDList
26510>>>>>>>>>    Pointer lpClass
26510>>>>>>>>>    Handle  hkeyClass
26510>>>>>>>>>    DWord   dwHotKey
26510>>>>>>>>>    Handle  hIconMonitor // Union
26510>>>>>>>>>    //Handle  hMonitor     // Union
26510>>>>>>>>>    Handle  hProcess
26510>>>>>>>>>End_Struct
26510>>>>>>>>>
26510>>>>>>>>>
26510>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
26510>>>>>>>>>//Type MEMORYSTATUS
26510>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
26510>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
26510>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
26510>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
26510>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
26510>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
26510>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
26510>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
26510>>>>>>>>>//End_Type
26510>>>>>>>>>
26510>>>>>>>>>// *** External Function calls: ***
26510>>>>>>>>>//
26510>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
26511>>>>>>>>>
26511>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
26512>>>>>>>>>
26512>>>>>>>>>// Do not call directly, use the wrapper function instead
26512>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
26513>>>>>>>>>
26513>>>>>>>>>    // Wrapper Function WNetGetUser
26513>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
26515>>>>>>>>>
26515>>>>>>>>>        DWord   dwResult
26515>>>>>>>>>        UWide   uwName uwUserName
26515>>>>>>>>>        UWide   uwName uwUserName
26515>>>>>>>>>
26515>>>>>>>>>        Send StringToWide lpName (&uwName)
26516>>>>>>>>>
26516>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
26517>>>>>>>>>
26517>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
26518>>>>>>>>>
26518>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
26519>>>>>>>>>
26519>>>>>>>>>        Function_Return dwResult
26520>>>>>>>>>    End_Function
26521>>>>>>>>>
26521>>>>>>>>>
26521>>>>>>>>>
26521>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
26522>>>>>>>>>
26522>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
26523>>>>>>>>>
26523>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
26524>>>>>>>>>
26524>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
26525>>>>>>>>>
26525>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
26526>>>>>>>>>
26526>>>>>>>>>// *** Global/Desktop Function Declarations: ***
26526>>>>>>>>>
26526>>>>>>>>>Function ComputerName Desktop Returns String
26528>>>>>>>>>    String sName
26528>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
26529>>>>>>>>>>
26529>>>>>>>>>    Function_Return sName
26530>>>>>>>>>End_Function
26531>>>>>>>>>
26531>>>>>>>>>Function Network_User_Name Desktop Returns String
26533>>>>>>>>>    WString wName
26533>>>>>>>>>    Integer iRetval iLength
26533>>>>>>>>>
26533>>>>>>>>>    Move 0 to iLength
26534>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
26535>>>>>>>>>    Move (ZeroString(iLength)) to wName
26536>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
26537>>>>>>>>>
26537>>>>>>>>>    If (iRetval = NO_ERROR) Begin
26539>>>>>>>>>        Function_Return (CString (wName))
26540>>>>>>>>>    End
26540>>>>>>>>>>
26540>>>>>>>>>
26540>>>>>>>>>    Function_Return "User Unknown"
26541>>>>>>>>>End_Function
26542>>>>>>>>>
26542>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
26544>>>>>>>>>    String sClient sDriver sClientDriver
26544>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
26544>>>>>>>>>    Handle hoMsqlDrv
26544>>>>>>>>>
26544>>>>>>>>>    Move 0 to iDriver
26545>>>>>>>>>    Move "" to sClient
26546>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
26549>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
26555>>>>>>>>>>
26555>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
26558>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
26560>>>>>>>>>            Move iCount to iDriver
26561>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
26562>>>>>>>>>        End
26562>>>>>>>>>>
26562>>>>>>>>>    Loop
26563>>>>>>>>>>
26563>>>>>>>>>
26563>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
26563>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
26565>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
26568>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
26569>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
26570>>>>>>>>>        Send Destroy of hoMsqlDrv
26571>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
26572>>>>>>>>>    End
26572>>>>>>>>>>
26572>>>>>>>>>
26572>>>>>>>>>    Function_Return sClient
26573>>>>>>>>>End_Function
26574>>>>>>>>>
26574>>>>>>>>>// *** Class Declarations: ***
26574>>>>>>>>>//
26574>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
26575>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
26577>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
26578>>>>>>>>>    End_Procedure
26579>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
26581>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
26583>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
26584>>>>>>>>>    End_Procedure
26585>>>>>>>>>End_Class
26586>>>>>>>>>
26586>>>>>>>>>Class cCopyEditorContentButton is a Button
26587>>>>>>>>>    Procedure Construct_Object
26589>>>>>>>>>        Forward Send Construct_Object
26591>>>>>>>>>        Property Handle phoEditorHandle
26592>>>>>>>>>        Set psToolTip to C_$DescCopy
26593>>>>>>>>>    End_Procedure
26594>>>>>>>>>
26594>>>>>>>>>    Procedure CopyToWindowsClipboard
26596>>>>>>>>>        Handle hoEditor
26596>>>>>>>>>        Boolean bCanCopy
26596>>>>>>>>>        Address aEditorAddress
26596>>>>>>>>>
26596>>>>>>>>>        Get phoEditorHandle to hoEditor
26597>>>>>>>>>        Send Select_All of hoEditor
26598>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
26599>>>>>>>>>        If (bCanCopy = True) Begin
26601>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
26602>>>>>>>>>            Send Copy   of hoEditor
26603>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
26603>>>>>>>>>            Send Beginning_of_Data of hoEditor
26604>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
26605>>>>>>>>>        End
26605>>>>>>>>>>
26605>>>>>>>>>    End_Procedure
26606>>>>>>>>>End_Class
26607>>>>>>>>>
26607>>>>>>>>>Class SysinfoDisplay is a cTextEdit
26608>>>>>>>>>    Procedure Construct_Object
26610>>>>>>>>>        Forward Send Construct_Object
26612>>>>>>>>>
26612>>>>>>>>>        Set Size to 100 245
26613>>>>>>>>>        Set Location to 6 6
26614>>>>>>>>>        Set Border_Style to Border_None
26615>>>>>>>>>        Set Read_Only_State to True
26616>>>>>>>>>        Set pbWrap to True
26617>>>>>>>>>        Set peAnchors to anAll
26618>>>>>>>>>    End_Procedure
26619>>>>>>>>>
26619>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
26619>>>>>>>>>
26619>>>>>>>>>    Procedure AppendTextLn String sText
26621>>>>>>>>>        String sWorkspaceWSFile
26621>>>>>>>>>
26621>>>>>>>>>        // Only works for English:
26621>>>>>>>>>        If (ghoApplication > 0) Begin
26623>>>>>>>>>            If (sText contains "Workspace Name") Begin
26625>>>>>>>>>                Move "Workspace Config Filename:" to sText
26626>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
26627>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
26628>>>>>>>>>            End
26628>>>>>>>>>>
26628>>>>>>>>>        End
26628>>>>>>>>>>
26628>>>>>>>>>        Send AppendText sText
26629>>>>>>>>>        Send AppendText (character(10))
26630>>>>>>>>>    End_Procedure
26631>>>>>>>>>
26631>>>>>>>>>    //    This method will show the name Of the current directory in the system
26631>>>>>>>>>    //    information box
26631>>>>>>>>>    Procedure Show_Current_Directory
26633>>>>>>>>>        String sDir
26633>>>>>>>>>
26633>>>>>>>>>        Get_Current_Directory To sDir
26634>>>>>>>>>
26634>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
26635>>>>>>>>>    End_Procedure
26636>>>>>>>>>
26636>>>>>>>>>    Procedure Show_Windows_Directory
26638>>>>>>>>>        String sWindir
26638>>>>>>>>>
26638>>>>>>>>>        Get_Windows_Directory To sWindir
26639>>>>>>>>>
26639>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
26640>>>>>>>>>    End_Procedure
26641>>>>>>>>>
26641>>>>>>>>>    Procedure Show_Current_User
26643>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
26644>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
26645>>>>>>>>>    End_Procedure
26646>>>>>>>>>
26646>>>>>>>>>    Procedure Show_Number_Format
26648>>>>>>>>>        Integer iFormat
26648>>>>>>>>>        String sFormatText
26648>>>>>>>>>
26648>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
26651>>>>>>>>>        Move (Character (iFormat)) To sFormatText
26652>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
26653>>>>>>>>>
26653>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
26656>>>>>>>>>        Move (Character (iFormat)) to sFormatText
26657>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
26658>>>>>>>>>    End_Procedure
26659>>>>>>>>>
26659>>>>>>>>>    Procedure Show_Filelist_Name
26661>>>>>>>>>        String sFilename
26661>>>>>>>>>
26661>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
26664>>>>>>>>>
26664>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
26665>>>>>>>>>    End_Procedure
26666>>>>>>>>>
26666>>>>>>>>>    Procedure Show_Lock_Delay
26668>>>>>>>>>        Integer iLockdelay
26668>>>>>>>>>
26668>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
26671>>>>>>>>>
26671>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
26672>>>>>>>>>    End_Procedure
26673>>>>>>>>>
26673>>>>>>>>>    Procedure Show_Lock_Timeout
26675>>>>>>>>>        Integer iLockTimeout
26675>>>>>>>>>
26675>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
26678>>>>>>>>>
26678>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
26679>>>>>>>>>    End_Procedure
26680>>>>>>>>>
26680>>>>>>>>>    Procedure Show_Screen_Size
26682>>>>>>>>>        Integer iYscreensize iXscreensize
26682>>>>>>>>>
26682>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
26683>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
26684>>>>>>>>>
26684>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
26685>>>>>>>>>    End_Procedure
26686>>>>>>>>>
26686>>>>>>>>>    Procedure Show_Page_Size
26688>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
26689>>>>>>>>>    End_procedure
26690>>>>>>>>>
26690>>>>>>>>>    Procedure Show_Date
26692>>>>>>>>>        Date dToday
26692>>>>>>>>>
26692>>>>>>>>>        Move (CurrentDateTime()) to dToday
26693>>>>>>>>>
26693>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
26694>>>>>>>>>    End_procedure
26695>>>>>>>>>
26695>>>>>>>>>    Procedure Show_Date_Format
26697>>>>>>>>>        Integer iDateFormat
26697>>>>>>>>>        String sDateFormat
26697>>>>>>>>>
26697>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
26700>>>>>>>>>        Case Begin
26700>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
26702>>>>>>>>>                Move C_$USA To sDateFormat
26703>>>>>>>>>                Case Break
26704>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
26707>>>>>>>>>                Move C_$European To sDateFormat
26708>>>>>>>>>                Case Break
26709>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
26712>>>>>>>>>                Move C_$Military To sDateFormat
26713>>>>>>>>>                Case Break
26714>>>>>>>>>            Case Else
26714>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
26715>>>>>>>>>                Case Break
26716>>>>>>>>>        Case End
26716>>>>>>>>>
26716>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
26717>>>>>>>>>    End_Procedure
26718>>>>>>>>>
26718>>>>>>>>>    // 2013-08-14 NGS
26718>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
26718>>>>>>>>>    Procedure Show_Systemresources
26720>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
26720>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
26720>>>>>>>>>        Integer iRetval
26720>>>>>>>>>        Number nValue
26720>>>>>>>>>        String sValue
26720>>>>>>>>>
26720>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
26721>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
26722>>>>>>>>>        If (iRetval = 0) Begin
26724>>>>>>>>>            Move (ShowLastError ()) to iRetval
26725>>>>>>>>>            Procedure_Return
26726>>>>>>>>>        End
26726>>>>>>>>>>
26726>>>>>>>>>
26726>>>>>>>>>        Send AppendTextLn ""
26727>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
26728>>>>>>>>>
26728>>>>>>>>>        // Show memory in Gigabytes:
26728>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
26729>>>>>>>>>        Move (Round(nValue)) to nValue
26730>>>>>>>>>        Get FormatNumber nValue 2 to sValue
26731>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
26732>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
26733>>>>>>>>>
26733>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
26733>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
26734>>>>>>>>>        Move (Round(nValue)) to nValue
26735>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26736>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
26737>>>>>>>>>
26737>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
26737>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
26738>>>>>>>>>        Move (Round(nValue)) to nValue
26739>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26740>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
26741>>>>>>>>>
26741>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
26741>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
26742>>>>>>>>>        Move (Round(nValue)) to nValue
26743>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26744>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
26745>>>>>>>>>
26745>>>>>>>>>        // Add an empty row after the memory information:
26745>>>>>>>>>        Send AppendTextLn ""
26746>>>>>>>>>    End_Procedure
26747>>>>>>>>>
26747>>>>>>>>>    Procedure Show_Registration
26749>>>>>>>>>        String sRegName
26749>>>>>>>>>        Integer iSN iUsersMax iUserCount
26749>>>>>>>>>
26749>>>>>>>>>        Registration sRegName iSN
26750>>>>>>>>>>
26750>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
26751>>>>>>>>>        Get_Current_User_Count to iUserCount
26752>>>>>>>>>
26752>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
26753>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
26754>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
26755>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
26756>>>>>>>>>    End_Procedure
26757>>>>>>>>>
26757>>>>>>>>>    //****************************************************************************
26757>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
26757>>>>>>>>>    // To the workspace object passing the an object and message To send back
26757>>>>>>>>>    // To this object. It is expected that the workspace object will send this
26757>>>>>>>>>    // message for every line Of information it wants displayed (passing the
26757>>>>>>>>>    // information To be displayed
26757>>>>>>>>>    //****************************************************************************
26757>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
26757>>>>>>>>>
26757>>>>>>>>>    Procedure Show_ServicePack
26759>>>>>>>>>        String sKey sVersion sDataFlex
26759>>>>>>>>>        Handle hoRegistry
26759>>>>>>>>>        Boolean bExists bOpened
26759>>>>>>>>>
26759>>>>>>>>>        Move "DataFlex"        to sDataFlex
26760>>>>>>>>>
26760>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
26761>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
26762>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
26763>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
26764>>>>>>>>>
26764>>>>>>>>>        If (bExists) Begin
26766>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
26767>>>>>>>>>        End
26767>>>>>>>>>>
26767>>>>>>>>>        Else Begin
26768>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
26769>>>>>>>>>        End
26769>>>>>>>>>>
26769>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
26770>>>>>>>>>        If (bExists) Begin
26772>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
26773>>>>>>>>>            If (bOpened) Begin
26775>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
26776>>>>>>>>>                If (bExists) Begin
26778>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
26779>>>>>>>>>                End
26779>>>>>>>>>>
26779>>>>>>>>>                Send CloseKey of hoRegistry
26780>>>>>>>>>            End
26780>>>>>>>>>>
26780>>>>>>>>>        End
26780>>>>>>>>>>
26780>>>>>>>>>        Send Destroy of hoRegistry
26781>>>>>>>>>
26781>>>>>>>>>        If (sVersion <> "") Begin
26783>>>>>>>>>           Send AppendTextLn sVersion
26784>>>>>>>>>           Send AppendTextLn ""
26785>>>>>>>>>        End
26785>>>>>>>>>>
26785>>>>>>>>>    End_Procedure
26786>>>>>>>>>
26786>>>>>>>>>    Procedure Show_WorkspaceInformation
26788>>>>>>>>>        Integer hoWorkspace
26788>>>>>>>>>
26788>>>>>>>>>        If (ghoApplication <> 0) Begin
26790>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
26791>>>>>>>>>            If (hoWorkspace <> 0) Begin
26793>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
26794>>>>>>>>>            End
26794>>>>>>>>>>
26794>>>>>>>>>        End
26794>>>>>>>>>>
26794>>>>>>>>>    End_Procedure
26795>>>>>>>>>
26795>>>>>>>>>    //****************************************************************************
26795>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
26795>>>>>>>>>    // to the connection manager object passing the an object and message to send
26795>>>>>>>>>    // back to this object. It is expected that the connection manager object will
26795>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
26795>>>>>>>>>    // the information To be displayed
26795>>>>>>>>>    //****************************************************************************
26795>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
26795>>>>>>>>>
26795>>>>>>>>>    Procedure Show_ConnectionIdInformation
26797>>>>>>>>>        If (ghoConnection > 0) Begin
26799>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
26800>>>>>>>>>            Send AppendTextLn ""
26801>>>>>>>>>        End
26801>>>>>>>>>>
26801>>>>>>>>>    End_Procedure
26802>>>>>>>>>
26802>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
26804>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
26805>>>>>>>>>    End_Function
26806>>>>>>>>>
26806>>>>>>>>>    Procedure Show_Versions
26808>>>>>>>>>        Integer iVersion iRevision iBuild
26808>>>>>>>>>
26808>>>>>>>>>        Version_information iVersion iRevision iBuild
26810>>>>>>>>>
26810>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
26811>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
26812>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
26813>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
26814>>>>>>>>>    End_Procedure
26815>>>>>>>>>
26815>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
26817>>>>>>>>>        Boolean bOK
26817>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
26818>>>>>>>>>        Function_Return bOK
26819>>>>>>>>>    End_Function
26820>>>>>>>>>
26820>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
26822>>>>>>>>>        Boolean bOK
26822>>>>>>>>>        Function_Return bOK
26823>>>>>>>>>    End_Function
26824>>>>>>>>>
26824>>>>>>>>>    //***
26824>>>>>>>>>    //*** BW
26824>>>>>>>>>    //*** Procedure: Show_Drivers
26824>>>>>>>>>    //*** Purpose  : Show loaded database drivers
26824>>>>>>>>>    //***
26824>>>>>>>>>
26824>>>>>>>>>    Procedure Show_Drivers
26826>>>>>>>>>        String sDriverID sVersion sClient sValue
26826>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
26826>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
26826>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
26826>>>>>>>>>
26826>>>>>>>>>        Move False to bStudioLicense
26827>>>>>>>>>
26827>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
26828>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
26829>>>>>>>>>
26829>>>>>>>>>        // For testing purposes:
26829>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
26829>>>>>>>>>//        Load_Driver MSSQLDRV_ID
26829>>>>>>>>>//        Load_Driver ODBC_DRV_ID
26829>>>>>>>>>//        Load_Driver DB2_DRV_ID
26829>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
26829>>>>>>>>>//
26829>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
26829>>>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
26829>>>>>>>>>//            Load_Driver SQLFLEX
26829>>>>>>>>>//            Load_Driver MDSPgSQL
26829>>>>>>>>>//            Load_Driver MDSMySQL
26829>>>>>>>>>//            Load_Driver ORAFLEX
26829>>>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
26829>>>>>>>>>//        #ENDIF
26829>>>>>>>>>        Move False to Err
26830>>>>>>>>>
26830>>>>>>>>>        // Loop through all loaded drivers.
26830>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
26833>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
26835>>>>>>>>>            Send AppendTextLn ""
26836>>>>>>>>>        End
26836>>>>>>>>>>
26836>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
26842>>>>>>>>>>
26842>>>>>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
26842>>>>>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
26842>>>>>>>>>            // would be thrown, so we safeguard from that here.
26842>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
26843>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
26846>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
26847>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
26848>>>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
26849>>>>>>>>>
26849>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
26851>>>>>>>>>
26851>>>>>>>>>                // Pervasive/Btrieve database
26851>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
26853>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
26854>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
26855>>>>>>>>>                    If (sClient <> "0.0.0") Begin
26857>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
26858>>>>>>>>>                    End
26858>>>>>>>>>>
26858>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
26859>>>>>>>>>                    If (sClient <> "0.0.0") Begin
26861>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
26862>>>>>>>>>                    End
26862>>>>>>>>>>
26862>>>>>>>>>                End
26862>>>>>>>>>>
26862>>>>>>>>>
26862>>>>>>>>>                Else Begin
26863>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
26864>>>>>>>>>                    Move 0 to iNumServers
26865>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
26867>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
26870>>>>>>>>>                    End
26870>>>>>>>>>>
26870>>>>>>>>>
26870>>>>>>>>>                    If (bIsDAWDriver = True) Begin
26872>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
26874>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
26875>>>>>>>>>                        End
26875>>>>>>>>>>
26875>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
26876>>>>>>>>>                    End
26876>>>>>>>>>>
26876>>>>>>>>>
26876>>>>>>>>>                    If (bIsMertechDriver = True) Begin
26878>>>>>>>>>                    End
26878>>>>>>>>>>
26878>>>>>>>>>
26878>>>>>>>>>                    // If the serialnumber is = 0, it means that the
26878>>>>>>>>>                    // Studio licens is in use and there is no
26878>>>>>>>>>                    // number of max users defined because the driver is
26878>>>>>>>>>                    // relying on the info from the VDF license.
26878>>>>>>>>>                    If (bStudioLicense = False) Begin
26880>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
26881>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
26882>>>>>>>>>                    End
26882>>>>>>>>>>
26882>>>>>>>>>                End
26882>>>>>>>>>>
26882>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
26883>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
26885>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
26886>>>>>>>>>                End
26886>>>>>>>>>>
26886>>>>>>>>>                If (iNumServers <> 0) Begin
26888>>>>>>>>>                    For iCount from 1 to iNumServers
26894>>>>>>>>>>
26894>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
26897>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
26899>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
26900>>>>>>>>>                        End
26900>>>>>>>>>>
26900>>>>>>>>>                    Loop
26901>>>>>>>>>>
26901>>>>>>>>>                End
26901>>>>>>>>>>
26901>>>>>>>>>            End
26901>>>>>>>>>>
26901>>>>>>>>>        Loop
26902>>>>>>>>>>
26902>>>>>>>>>
26902>>>>>>>>>        Send AppendTextLn ""
26903>>>>>>>>>        If (bStudioLicense = False) Begin
26905>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
26906>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
26907>>>>>>>>>        End
26907>>>>>>>>>>
26907>>>>>>>>>        Else Begin
26908>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
26909>>>>>>>>>        End
26909>>>>>>>>>>
26909>>>>>>>>>        Send Destroy of hoCLIHandler
26910>>>>>>>>>        Send Destroy of hoBtrvHandler
26911>>>>>>>>>    End_Procedure
26912>>>>>>>>>
26912>>>>>>>>>    Procedure Show_HelpFile
26914>>>>>>>>>        String sHelpFile
26914>>>>>>>>>        Integer eHelpType
26914>>>>>>>>>
26914>>>>>>>>>        If (ghoApplication <> 0) Begin
26916>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
26917>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
26919>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
26920>>>>>>>>>            End
26920>>>>>>>>>>
26920>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
26923>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
26924>>>>>>>>>            End
26924>>>>>>>>>>
26924>>>>>>>>>            Else Begin
26925>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
26926>>>>>>>>>            End
26926>>>>>>>>>>
26926>>>>>>>>>
26926>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
26927>>>>>>>>>        End
26927>>>>>>>>>>
26927>>>>>>>>>    End_Procedure
26928>>>>>>>>>
26928>>>>>>>>>    Procedure Show_EnterAsTab
26930>>>>>>>>>        Boolean bEnterKeyAsTabKey
26930>>>>>>>>>        String sText
26930>>>>>>>>>
26930>>>>>>>>>        If (ghoApplication <> 0) Begin
26932>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
26933>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
26935>>>>>>>>>                Move "True" To sText
26936>>>>>>>>>            End
26936>>>>>>>>>>
26936>>>>>>>>>            Else Begin
26937>>>>>>>>>                Move "False" To sText
26938>>>>>>>>>            End
26938>>>>>>>>>>
26938>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
26939>>>>>>>>>        End
26939>>>>>>>>>>
26939>>>>>>>>>    End_Procedure
26940>>>>>>>>>
26940>>>>>>>>>    //    During activation we will remove the old information and add the newly
26940>>>>>>>>>    //    found systeminformation
26940>>>>>>>>>    Procedure Add_Focus Integer hoRoot
26942>>>>>>>>>        Forward Send Add_Focus hoRoot
26944>>>>>>>>>
26944>>>>>>>>>        Send Delete_Data
26945>>>>>>>>>
26945>>>>>>>>>        Set Changed_State To False
26946>>>>>>>>>        Set Read_Only_State To True
26947>>>>>>>>>
26947>>>>>>>>>        Send Show_Registration
26948>>>>>>>>>        Send Show_Drivers
26949>>>>>>>>>        Send Show_ServicePack
26950>>>>>>>>>        Send Show_Versions
26951>>>>>>>>>        Send AppendTextLn ""
26952>>>>>>>>>
26952>>>>>>>>>        If (ghoApplication <> 0) Begin
26954>>>>>>>>>            Send Show_WorkSpaceInformation
26955>>>>>>>>>            Send Show_HelpFile
26956>>>>>>>>>            Send AppendTextLn ""
26957>>>>>>>>>        End
26957>>>>>>>>>>
26957>>>>>>>>>        Else Begin
26958>>>>>>>>>            Send AppendTextLn ""
26959>>>>>>>>>        End
26959>>>>>>>>>>
26959>>>>>>>>>
26959>>>>>>>>>        If (ghoConnection <> 0) Begin
26961>>>>>>>>>            Send Show_ConnectionIdInformation
26962>>>>>>>>>        End
26962>>>>>>>>>>
26962>>>>>>>>>
26962>>>>>>>>>        Send Show_Current_User
26963>>>>>>>>>        Send Show_Windows_Directory
26964>>>>>>>>>        Send Show_Current_Directory
26965>>>>>>>>>
26965>>>>>>>>>        // This is already shown in the workspace details,
26965>>>>>>>>>        // unless no workspace object is present:
26965>>>>>>>>>        If (ghoApplication = 0) Begin
26967>>>>>>>>>            Send Show_Filelist_Name
26968>>>>>>>>>        End
26968>>>>>>>>>>
26968>>>>>>>>>
26968>>>>>>>>>        If (ghoApplication <> 0) Begin
26970>>>>>>>>>            Send AppendTextLn ""
26971>>>>>>>>>            Send Show_EnterAsTab
26972>>>>>>>>>        End
26972>>>>>>>>>>
26972>>>>>>>>>
26972>>>>>>>>>        Send Show_Screen_Size
26973>>>>>>>>>        Send Show_Page_Size
26974>>>>>>>>>        Send Show_Number_Format
26975>>>>>>>>>        Send Show_Date_Format
26976>>>>>>>>>        Send Show_Lock_Delay
26977>>>>>>>>>        Send Show_Lock_Timeout
26978>>>>>>>>>        Send Show_Date
26979>>>>>>>>>        Send Show_Systemresources
26980>>>>>>>>>        Send Beginning_of_Data
26981>>>>>>>>>
26981>>>>>>>>>        Set Icon to 'default.ico'
26982>>>>>>>>>    End_Procedure
26983>>>>>>>>>End_Class
26984>>>>>>>>>
26984>>>>>>>>>Class SysInfoDialog is a ModalPanel
26985>>>>>>>>>    Procedure Construct_Object
26987>>>>>>>>>        Forward Send Construct_Object
26989>>>>>>>>>
26989>>>>>>>>>        Set Label to C_$SystemInformation
26990>>>>>>>>>        Set Size to 140 267
26991>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
26992>>>>>>>>>        Set Border_Style to Border_Thick
26993>>>>>>>>>        Set Sysmenu_Icon to False
26994>>>>>>>>>
26994>>>>>>>>>        // "+1" will make the panel to paint correctly.
26994>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
26995>>>>>>>>>
26995>>>>>>>>>        // 2014-09-14 NGS
26995>>>>>>>>>        // Added a container object around the cTexteditor
26995>>>>>>>>>        // object to get a border around the text.
26995>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
26997>>>>>>>>>            Set Location to 2 4
26998>>>>>>>>>            Set Size to 110 255
26999>>>>>>>>>            Set Border_Style to Border_ClientEdge
27000>>>>>>>>>            Set Color to clWhite
27001>>>>>>>>>            Set peAnchors to anAll
27002>>>>>>>>>
27002>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
27004>>>>>>>>>            End_Object
27005>>>>>>>>>
27005>>>>>>>>>        End_Object
27006>>>>>>>>>
27006>>>>>>>>>        Object oCloseButton is a Button
27008>>>>>>>>>            Set Label to C_$Close
27009>>>>>>>>>            Set Location to 120 210
27010>>>>>>>>>            Set Message item 0 to msg_Close_Panel
27011>>>>>>>>>            Set Default_State To True
27012>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
27012>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
27012>>>>>>>>>            // for that situation.
27012>>>>>>>>>            Set peAnchors to anBottomRight
27013>>>>>>>>>        End_Object
27014>>>>>>>>>
27014>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
27016>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
27017>>>>>>>>>            Set Size to 14 50
27018>>>>>>>>>            Set Location to 120 158
27019>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27019>>>>>>>>>            // we might as well prepare the object for it.
27019>>>>>>>>>            Set peAnchors to anBottomRight
27020>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
27021>>>>>>>>>        End_Object
27022>>>>>>>>>
27022>>>>>>>>>        On_Key kCancel Send Close_Panel
27023>>>>>>>>>    End_Procedure
27024>>>>>>>>>
27024>>>>>>>>>    Procedure Page Integer iPageObject
27026>>>>>>>>>        Handle hMenu
27026>>>>>>>>>        Integer iPrevState
27026>>>>>>>>>
27026>>>>>>>>>        Forward Send Page iPageObject
27028>>>>>>>>>
27028>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
27028>>>>>>>>>        //
27028>>>>>>>>>    End_Procedure
27029>>>>>>>>>
27029>>>>>>>>>End_Class
27030>>>>>>>>>
27030>>>>>>>>>Class cAboutEdit is an cRichEdit
27031>>>>>>>>>    Procedure Construct_Object
27033>>>>>>>>>        Forward Send Construct_Object
27035>>>>>>>>>
27035>>>>>>>>>        Property String psContentText
27036>>>>>>>>>
27036>>>>>>>>>        Set Size to 77 153
27037>>>>>>>>>        Set Location to 8 60
27038>>>>>>>>>        Set Read_Only_State to True
27039>>>>>>>>>        Set Skip_State to True
27040>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
27040>>>>>>>>>        // or 1/20 of a printer's point.
27040>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
27041>>>>>>>>>        Set Border_Style  to Border_None
27042>>>>>>>>>    End_Procedure
27043>>>>>>>>>
27043>>>>>>>>>    // Adds a line of text to the edit object
27043>>>>>>>>>    Procedure Add_Line String sText
27045>>>>>>>>>        String sContentText
27045>>>>>>>>>        Get psContentText to sContentText
27046>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
27047>>>>>>>>>        Set psContentText to sContentText
27048>>>>>>>>>    End_Procedure
27049>>>>>>>>>
27049>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
27049>>>>>>>>>    // Note that we use a property psContentText and add to it,
27049>>>>>>>>>    // because the object isn't paged yet when we add these
27049>>>>>>>>>    // values and the COM edit object needs to be paged
27049>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
27049>>>>>>>>>    Procedure Add_LineLn String sText
27051>>>>>>>>>        String sContentText sCR
27051>>>>>>>>>
27051>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
27052>>>>>>>>>        Get psContentText to sContentText
27053>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
27054>>>>>>>>>        Set psContentText to sContentText
27055>>>>>>>>>    End_Procedure
27056>>>>>>>>>
27056>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
27058>>>>>>>>>        String sLinkText
27058>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
27059>>>>>>>>>        Send Show_HomePage sLinkText
27060>>>>>>>>>    End_Procedure
27061>>>>>>>>>
27061>>>>>>>>>    Procedure Page Integer iPageObject
27063>>>>>>>>>        String sContentText
27063>>>>>>>>>
27063>>>>>>>>>        Forward Send Page iPageObject
27065>>>>>>>>>        Get psContentText to sContentText
27066>>>>>>>>>        Send AppendText sContentText
27067>>>>>>>>>        send Beginning_of_Data
27068>>>>>>>>>    End_Procedure
27069>>>>>>>>>
27069>>>>>>>>>End_Class
27070>>>>>>>>>
27070>>>>>>>>>Class AboutDialog is a ModalPanel
27071>>>>>>>>>    Procedure Construct_Object
27073>>>>>>>>>
27073>>>>>>>>>        Forward Send Construct_Object
27075>>>>>>>>>
27075>>>>>>>>>        Set Label to C_$About
27076>>>>>>>>>        Set Size to 118 230
27077>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
27078>>>>>>>>>        Set Border_Style to Border_Thick
27079>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
27080>>>>>>>>>
27080>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
27082>>>>>>>>>        End_Object
27083>>>>>>>>>
27083>>>>>>>>>        Object oBox is a Container3d
27085>>>>>>>>>            Set Border_Style to Border_Normal
27086>>>>>>>>>            Set Size to 90 220
27087>>>>>>>>>            Set Location to 4 5
27088>>>>>>>>>            Set Color to clWhite
27089>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27089>>>>>>>>>            // we might as well prepare the object for it.
27089>>>>>>>>>            Set peAnchors to anAll
27090>>>>>>>>>
27090>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
27092>>>>>>>>>                Set Border_Style To Border_None
27093>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
27094>>>>>>>>>                Set Color to clWhite
27095>>>>>>>>>                Set Size to 45 50
27096>>>>>>>>>                Set Location to 0 3
27097>>>>>>>>>            End_Object
27098>>>>>>>>>
27098>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
27100>>>>>>>>>                Set Border_Style to Border_None
27101>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
27102>>>>>>>>>                Set Color to clWhite
27103>>>>>>>>>                Set Size to 30 55
27104>>>>>>>>>                Set Location to 50 3
27105>>>>>>>>>            End_Object
27106>>>>>>>>>
27106>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
27108>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
27108>>>>>>>>>                // we might as well prepare the object for it.
27108>>>>>>>>>                Set peAnchors to anAll
27109>>>>>>>>>            End_Object
27110>>>>>>>>>
27110>>>>>>>>>            // These objects are here for backwards compatability only.
27110>>>>>>>>>            // They are not used.
27110>>>>>>>>>            Object oProductName is a TextBox
27112>>>>>>>>>                Set Label To C_$ProductName
27113>>>>>>>>>                Set Size To 10 45
27114>>>>>>>>>                Set Location To 8 53
27115>>>>>>>>>                Set Visible_State to False
27116>>>>>>>>>                Set Focus_Mode to NonFocusable
27117>>>>>>>>>            End_Object
27118>>>>>>>>>
27118>>>>>>>>>            Object oVersion is a TextBox
27120>>>>>>>>>                Set Label To C_$Version
27121>>>>>>>>>                Set Size To 10 25
27122>>>>>>>>>                Set Location To 21 53
27123>>>>>>>>>                Set Visible_State to False
27124>>>>>>>>>                Set Focus_Mode to NonFocusable
27125>>>>>>>>>            End_Object
27126>>>>>>>>>
27126>>>>>>>>>            Object oCopyright is a TextBox
27128>>>>>>>>>                Set Label To C_$Copyright
27129>>>>>>>>>                Set Size To 10 31
27130>>>>>>>>>                Set Location To 34 53
27131>>>>>>>>>                Set Visible_State to False
27132>>>>>>>>>                Set Focus_Mode to NonFocusable
27133>>>>>>>>>            End_Object
27134>>>>>>>>>
27134>>>>>>>>>            Object oAuthor is a TextBox
27136>>>>>>>>>                Set Label To C_$Author
27137>>>>>>>>>                Set Size To 10 22
27138>>>>>>>>>                Set Location To 46 53
27139>>>>>>>>>                Set Visible_State to False
27140>>>>>>>>>                Set Focus_Mode to NonFocusable
27141>>>>>>>>>            End_Object
27142>>>>>>>>>
27142>>>>>>>>>        End_Object
27143>>>>>>>>>
27143>>>>>>>>>        Object oOKButton is a Button
27145>>>>>>>>>            On_Item C_$Close Send Close_Panel
27146>>>>>>>>>            Set Location to 98 176
27147>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27147>>>>>>>>>            // we might as well prepare the object for it.
27147>>>>>>>>>            Set peAnchors to anBottomRight
27148>>>>>>>>>        End_Object
27149>>>>>>>>>
27149>>>>>>>>>        Object oSysInfoButton is a Button
27151>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
27152>>>>>>>>>            Set Location to 98 123
27153>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27153>>>>>>>>>            // we might as well prepare the object for it.
27153>>>>>>>>>            Set peAnchors to anBottomRight
27154>>>>>>>>>        End_Object
27155>>>>>>>>>
27155>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
27157>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
27158>>>>>>>>>            Set Size to 14 50
27159>>>>>>>>>            Set Location to 98 70
27160>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27160>>>>>>>>>            // we might as well prepare the object for it.
27160>>>>>>>>>            Set peAnchors to anBottomRight
27161>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
27162>>>>>>>>>        End_Object
27163>>>>>>>>>
27163>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
27164>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
27165>>>>>>>>>        Set LogoDF to "DF32.bmp"
27166>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
27166>>>>>>>>>    End_Procedure
27167>>>>>>>>>
27167>>>>>>>>>    Procedure Page Integer iPageObject
27169>>>>>>>>>        Handle hMenu
27169>>>>>>>>>        Integer iPrevState
27169>>>>>>>>>
27169>>>>>>>>>        Forward Send Page iPageObject
27171>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
27171>>>>>>>>>        Set Icon to "Default.ico"
27172>>>>>>>>>
27172>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
27172>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
27173>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27174>>>>>>>>>        // The "Move" menu command may come in handy to have.
27174>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27174>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27175>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27176>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27177>>>>>>>>>        // The "Close" menu command may be good to have.
27177>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27177>>>>>>>>>    End_Procedure
27178>>>>>>>>>
27178>>>>>>>>>    Procedure Set ProductName String sText
27180>>>>>>>>>        Set Value of oProductName to sText
27181>>>>>>>>>    End_Procedure
27182>>>>>>>>>
27182>>>>>>>>>    Procedure Set Copyright String sText
27184>>>>>>>>>        Set Value of oCopyright to sText
27185>>>>>>>>>    End_Procedure
27186>>>>>>>>>
27186>>>>>>>>>    Procedure Set Author String sText
27188>>>>>>>>>        Set Value of oAuthor to sText
27189>>>>>>>>>    End_Procedure
27190>>>>>>>>>
27190>>>>>>>>>    Procedure Set Version String sVersion
27192>>>>>>>>>        Handle hoVersionInfo
27192>>>>>>>>>        Boolean bIncluded
27192>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
27192>>>>>>>>>        Date dCompileDate
27192>>>>>>>>>        String sCertInfo
27192>>>>>>>>>
27192>>>>>>>>>        If (sVersion = "") Begin
27194>>>>>>>>>            // This automatically shows the program version of the program, if available.
27194>>>>>>>>>            // It will be displayed as the second item in the edit object.
27194>>>>>>>>>            If (ghoApplication <> 0) Begin
27196>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
27197>>>>>>>>>                If (hoVersionInfo <> 0) Begin
27199>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
27200>>>>>>>>>                    If (bIncluded) Begin
27202>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
27203>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
27204>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
27205>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
27206>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
27207>>>>>>>>>                    End
27207>>>>>>>>>>
27207>>>>>>>>>                End
27207>>>>>>>>>>
27207>>>>>>>>>            End
27207>>>>>>>>>>
27207>>>>>>>>>        End
27207>>>>>>>>>>
27207>>>>>>>>>
27207>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
27207>>>>>>>>>        Get GetCompileDate to dCompileDate
27208>>>>>>>>>        If (sVersion <> "") Begin
27210>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
27211>>>>>>>>>        End
27211>>>>>>>>>>
27211>>>>>>>>>
27211>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
27212>>>>>>>>>        If (sCertInfo <> "-1") Begin
27214>>>>>>>>>            If (sCertInfo <> "") Begin
27216>>>>>>>>>                Send Add_LineLn sCertInfo
27217>>>>>>>>>            End
27217>>>>>>>>>>
27217>>>>>>>>>            Else Begin
27218>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
27219>>>>>>>>>            End
27219>>>>>>>>>>
27219>>>>>>>>>        End
27219>>>>>>>>>>
27219>>>>>>>>>    End_Procedure
27220>>>>>>>>>
27220>>>>>>>>>    Function IsDate String sDate Returns Boolean
27222>>>>>>>>>        Boolean bIsDate
27222>>>>>>>>>        String sGoodCharacters sChar
27222>>>>>>>>>        Integer iCount iLength
27222>>>>>>>>>
27222>>>>>>>>>        Move True to bIsDate
27223>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
27224>>>>>>>>>        Move (Length(sDate)) to iLength
27225>>>>>>>>>        For iCount from 1 to iLength
27231>>>>>>>>>>
27231>>>>>>>>>            Move (Left(sDate, 1)) to sChar
27232>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
27233>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
27234>>>>>>>>>            If (bIsDate = False) Begin
27236>>>>>>>>>                Move iLength to iCount
27237>>>>>>>>>            End
27237>>>>>>>>>>
27237>>>>>>>>>        Loop
27238>>>>>>>>>>
27238>>>>>>>>>        Function_Return bIsDate
27239>>>>>>>>>    End_Function
27240>>>>>>>>>
27240>>>>>>>>>    Function GetCompileDate Returns Date
27242>>>>>>>>>        Date dCompileDate
27242>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
27242>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
27242>>>>>>>>>        Boolean bIsValid
27242>>>>>>>>>
27242>>>>>>>>>        Move 0 to dCompileDate
27243>>>>>>>>>        // Get full path to the current running executable
27243>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
27244>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
27245>>>>>>>>>
27245>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
27245>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
27246>>>>>>>>>
27246>>>>>>>>>        Get_Argument_Size to iSize
27247>>>>>>>>>        Set_Argument_Size 15000000
27248>>>>>>>>>>
27248>>>>>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
27250>>>>>>>>>        Move (Pos(sProgram,sData)) to iPos
27251>>>>>>>>>        If (iPos > 0) Begin
27253>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
27253>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
27254>>>>>>>>>
27254>>>>>>>>>            // If the current date format is non US, we need to temporary
27254>>>>>>>>>            // change the format and then move the string to the date variable.
27254>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
27257>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
27260>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
27261>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
27264>>>>>>>>>        End
27264>>>>>>>>>>
27264>>>>>>>>>        Else Begin
27265>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
27266>>>>>>>>>>
27266>>>>>>>>>        End
27266>>>>>>>>>>
27266>>>>>>>>>
27266>>>>>>>>>        Send Seq_Close_Channel iChannel
27267>>>>>>>>>        Set_Argument_Size iSize
27268>>>>>>>>>>
27268>>>>>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
27268>>>>>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
27268>>>>>>>>>
27268>>>>>>>>>        // The data is padded with Character(0)s. Strip them out
27268>>>>>>>>>//        Move (CString(sData)) to sData
27268>>>>>>>>>
27268>>>>>>>>>        // The compile date is after the first ", ", so string parsing is required
27268>>>>>>>>>//        Move (Pos(", ", sData)) to iPos
27268>>>>>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
27268>>>>>>>>>        // If the current date format is non US, we need to temporary
27268>>>>>>>>>        // change the format and then move the string to the date variable.
27268>>>>>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
27268>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
27268>>>>>>>>>//
27268>>>>>>>>>//        // Note the build in IsDateValid can return the wrong result
27268>>>>>>>>>//        // when controls characters are part of the sCompileDate.
27268>>>>>>>>>//        Get IsDate sCompileDate))           to bIsValid
27268>>>>>>>>>//        If (bIsValid = True) Begin
27268>>>>>>>>>//            Move (Date(sCompileDate))       to dCompileDate
27268>>>>>>>>>//        End
27268>>>>>>>>>//
27268>>>>>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
27268>>>>>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
27268>>>>>>>>>//        // until we encounter the program name that appears just in front of the compile date.
27268>>>>>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
27268>>>>>>>>>//        If (dCompileDate = 0) Begin
27268>>>>>>>>>//            Move "" to sCompileDate
27268>>>>>>>>>//            Move 30000 to iSize
27268>>>>>>>>>//            For iCount from 1 to iSize
27268>>>>>>>>>//                Readln channel iChannel sData
27268>>>>>>>>>//                Move (Pos(sProgram, sData)) to iPos
27268>>>>>>>>>//                If (iPos <> 0) Begin
27268>>>>>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
27268>>>>>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
27268>>>>>>>>>//                    Move iSize to iCount // We're out of here.
27268>>>>>>>>>//                End
27268>>>>>>>>>//            Loop
27268>>>>>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
27268>>>>>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
27268>>>>>>>>>//            End
27268>>>>>>>>>//            Get IsDate sCompileDate)) to bIsValid
27268>>>>>>>>>//            If (bIsValid = True) Begin
27268>>>>>>>>>//                Move (Date(sCompileDate)) to dCompileDate
27268>>>>>>>>>//            End
27268>>>>>>>>>//        End
27268>>>>>>>>>//        Send Seq_Close_Channel iChannel
27268>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
27268>>>>>>>>>
27268>>>>>>>>>        Function_Return dCompileDate
27269>>>>>>>>>    End_Function
27270>>>>>>>>>
27270>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
27270>>>>>>>>>    // (the passed program), has been finished
27270>>>>>>>>>    // The DOS box does also _not_ flash briefly.
27270>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
27272>>>>>>>>>        Handle hProcess
27272>>>>>>>>>        Integer iVoid
27272>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
27272>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
27272>>>>>>>>>
27272>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
27273>>>>>>>>>
27273>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
27274>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
27275>>>>>>>>>
27275>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
27276>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
27277>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
27277>>>>>>>>>        Move 0                       to sInfo.nShow
27278>>>>>>>>>
27278>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
27279>>>>>>>>>        Move sInfo.hProcess to hProcess
27280>>>>>>>>>        If (hProcess) Begin
27282>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
27283>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
27284>>>>>>>>>        End
27284>>>>>>>>>>
27284>>>>>>>>>    End_Procedure
27285>>>>>>>>>
27285>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
27287>>>>>>>>>        String sDirSep
27287>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
27288>>>>>>>>>        Move (Trim(sPath)) to sPath
27289>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
27291>>>>>>>>>            Move (sPath + sDirSep) to sPath
27292>>>>>>>>>        End
27292>>>>>>>>>>
27292>>>>>>>>>        Function_Return sPath
27293>>>>>>>>>    End_Function
27294>>>>>>>>>
27294>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
27294>>>>>>>>>    // or there is a problem with the certificate.
27294>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
27294>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
27294>>>>>>>>>    Function IsProgramDigitallySigned Returns String
27296>>>>>>>>>        Boolean bExists
27296>>>>>>>>>        String sPath sProgram sParams sRetval
27296>>>>>>>>>        Integer iCh
27296>>>>>>>>>
27296>>>>>>>>>        Move "" to sRetval
27297>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
27298>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
27299>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
27300>>>>>>>>>        If (bExists = False) Begin
27302>>>>>>>>>            Function_Return "-1"
27303>>>>>>>>>        End
27303>>>>>>>>>>
27303>>>>>>>>>
27303>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
27304>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
27305>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
27306>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
27307>>>>>>>>>        Get Seq_New_Channel to iCh
27308>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
27310>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
27313>>>>>>>>>        Close_Output channel iCh
27315>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
27315>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
27316>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
27318>>>>>>>>>            Readln channel iCh sRetval
27320>>>>>>>>>            Readln channel iCh sRetval
27322>>>>>>>>>            Readln channel iCh sRetval
27324>>>>>>>>>            Readln channel iCh sRetval
27326>>>>>>>>>        Close_Input channel iCh
27328>>>>>>>>>        Send Seq_Release_Channel iCh
27329>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
27331>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
27332>>>>>>>>>        End
27332>>>>>>>>>>
27332>>>>>>>>>        Else Begin
27333>>>>>>>>>            Move "" to sRetval
27334>>>>>>>>>        End
27334>>>>>>>>>>
27334>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
27334>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
27335>>>>>>>>>>
27335>>>>>>>>>        Function_Return sRetval
27336>>>>>>>>>    End_Function
27337>>>>>>>>>
27337>>>>>>>>>    Procedure Add_LineLn String sValue
27339>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
27340>>>>>>>>>    End_Procedure
27341>>>>>>>>>
27341>>>>>>>>>    Procedure Add_Line String sValue
27343>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
27344>>>>>>>>>    End_Procedure
27345>>>>>>>>>
27345>>>>>>>>>    Procedure Set Logo string sLogo
27347>>>>>>>>>        // Square bitmaps of 80x80 work best
27347>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
27348>>>>>>>>>    End_Procedure
27349>>>>>>>>>
27349>>>>>>>>>    Procedure Set LogoDF String sLogo
27351>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
27352>>>>>>>>>    End_Procedure
27353>>>>>>>>>
27353>>>>>>>>>    Procedure Show_Sysinfo
27355>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
27356>>>>>>>>>    End_Procedure
27357>>>>>>>>>
27357>>>>>>>>>    Procedure Show_HomePage String sWebpage
27359>>>>>>>>>        Handle hWnd
27359>>>>>>>>>        Get Window_Handle to hWnd
27360>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
27361>>>>>>>>>    End_Procedure
27362>>>>>>>>>
27362>>>>>>>>>End_Class
27363>>>>>>>
27363>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
27363>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
27363>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
27363>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
27363>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
27363>>>>>>>//
27363>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
27363>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
27363>>>>>>>
27363>>>>>>>
27363>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
27363>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
27363>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
27363>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
27363>>>>>>>//
27363>>>>>>>
27363>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
27364>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
27365>>>>>>>>
27365>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
27367>>>>>>>>    Integer iStart iEnd
27367>>>>>>>>    String sRetval
27367>>>>>>>>
27367>>>>>>>>    Move (Trim(sConnect)) to sConnect
27368>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
27369>>>>>>>>    If (iStart = 0) Begin
27371>>>>>>>>        Function_Return ""
27372>>>>>>>>    End
27372>>>>>>>>>
27372>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
27373>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
27374>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
27376>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
27377>>>>>>>>    End
27377>>>>>>>>>
27377>>>>>>>>    Else Begin
27378>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
27379>>>>>>>>    End
27379>>>>>>>>>
27379>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
27381>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
27382>>>>>>>>        Decrement iEnd
27383>>>>>>>>    End
27383>>>>>>>>>
27383>>>>>>>>    If (iEnd <> 0) Begin
27385>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
27386>>>>>>>>    End
27386>>>>>>>>>
27386>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
27387>>>>>>>>
27387>>>>>>>>    Function_Return (Trim(sRetval))
27388>>>>>>>>End_Function
27389>>>>>>>>
27389>>>>>>>>
27389>>>>>>>
27389>>>>>>>    Procedure Construct_Object
27391>>>>>>>        Handle ho
27391>>>>>>>        Forward Send Construct_Object
27393>>>>>>>
27393>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
27394>>>>>>>
27394>>>>>>>        Send CreateDbUpdateLibraryProperties
27395>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
27395>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
27395>>>>>>>        // etc settings.
27395>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27397>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
27398>>>>>>>            Set phoSQLConnectionHandler to ho
27399>>>>>>>        End   
27399>>>>>>>>
27399>>>>>>>        
27399>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
27400>>>>>>>
27400>>>>>>>    End_Procedure
27401>>>>>>>
27401>>>>>>>    Procedure End_Construct_Object
27403>>>>>>>        Forward Send End_Construct_Object
27405>>>>>>>    End_Procedure
27406>>>>>>>
27406>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
27406>>>>>>>    //
27406>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27406>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
27408>>>>>>>        Function_Return False
27409>>>>>>>    End_Function
27410>>>>>>>
27410>>>>>>>    // Function for creating a new *Database*.
27410>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
27410>>>>>>>    // Returns True if successful.
27410>>>>>>>    // ToDo: Currently only works for MS-SQL...
27410>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
27412>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
27412>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
27412>>>>>>>        Handle hConnection hStmt hoSQLManager
27412>>>>>>>        Integer iFetchResult iDbType
27412>>>>>>>        Boolean bOK bMertechDriver bExists
27412>>>>>>>
27412>>>>>>>        Get piDbType to iDbType
27413>>>>>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
27413>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
27415>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
27416>>>>>>>>
27416>>>>>>>            Function_Return False
27417>>>>>>>        End
27417>>>>>>>>
27417>>>>>>>
27417>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
27418>>>>>>>        If (bExists = True) Begin
27420>>>>>>>            Function_Return True
27421>>>>>>>        End
27421>>>>>>>>
27421>>>>>>>
27421>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27422>>>>>>>        If (bMertechDriver = False) Begin
27424>>>>>>>            Get phoSQLManager to hoSQLManager
27425>>>>>>>        End
27425>>>>>>>>
27425>>>>>>>        Else Begin
27426>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
27427>>>>>>>        End
27427>>>>>>>>
27427>>>>>>>
27427>>>>>>>        Get psConnectionID     to sConnectionID
27428>>>>>>>        Get psConnectionString to sConnectionString
27429>>>>>>>        Move 0 to LastErr
27430>>>>>>>
27430>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
27432>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
27432>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
27432>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
27432>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
27432>>>>>>>//                If (iPos > 0) Begin
27432>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
27432>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
27432>>>>>>>//                End
27432>>>>>>>//            End
27432>>>>>>>        End
27432>>>>>>>>
27432>>>>>>>
27432>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27433>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
27434>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27435>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
27437>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
27438>>>>>>>>
27438>>>>>>>            Function_Return False
27439>>>>>>>        End
27439>>>>>>>>
27439>>>>>>>
27439>>>>>>>        Get SqlOpen of hConnection to hStmt
27440>>>>>>>
27440>>>>>>>        If (hStmt = 0) Begin
27442>>>>>>>            Send SqlDisconnect of hoSQLManager
27443>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
27444>>>>>>>>
27444>>>>>>>            Function_Return False
27445>>>>>>>        End
27445>>>>>>>>
27445>>>>>>>
27445>>>>>>>        Get psCollation to sCollation
27446>>>>>>>
27446>>>>>>>        Case Begin
27446>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
27448>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
27449>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
27450>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
27451>>>>>>>
27451>>>>>>>                // Check if database exists
27451>>>>>>>                Send SqlExecDirect of hStmt sSQL
27452>>>>>>>                Get SqlFetch of hStmt to iFetchResult
27453>>>>>>>                Send SqlClose of hStmt
27454>>>>>>>                Send SqlDisconnect of hConnection
27455>>>>>>>                // If database already exists we're out of here!
27455>>>>>>>                // Note that we return True as this is not an error.
27455>>>>>>>                If (iFetchResult > 0) Begin
27457>>>>>>>                    Function_Return True
27458>>>>>>>                End
27458>>>>>>>>
27458>>>>>>>                // Database doesn't exist, create it.
27458>>>>>>>                If (iFetchResult = 0) Begin
27460>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
27461>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27462>>>>>>>                    If (sCollation <> "") Begin
27464>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
27465>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
27466>>>>>>>                    End
27466>>>>>>>>
27466>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
27467>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27468>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
27470>>>>>>>                        Function_Return False
27471>>>>>>>                    End
27471>>>>>>>>
27471>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
27471>>>>>>>                    Sleep 1
27472>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
27473>>>>>>>                End
27473>>>>>>>>
27473>>>>>>>                Case Break
27474>>>>>>>
27474>>>>>>>            Case (sDriverID = MDSPgSQL)
27477>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
27477>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
27478>>>>>>>                Case Break
27479>>>>>>>
27479>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
27482>>>>>>>                // ToDo: How should this be set/checked?
27482>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
27482>>>>>>>//                    Set psCollation to "utf8"
27482>>>>>>>//                End
27482>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
27482>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
27483>>>>>>>                Case Break
27484>>>>>>>
27484>>>>>>>            Case (sDriverID = MDSDB2)
27487>>>>>>>                Case Break
27488>>>>>>>
27488>>>>>>>            Case Else
27488>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
27489>>>>>>>>
27489>>>>>>>        Case End
27489>>>>>>>
27489>>>>>>>        If (Err = False) Begin
27491>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
27492>>>>>>>        End
27492>>>>>>>>
27492>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
27492>>>>>>>        // the one we just created.
27492>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
27494>>>>>>>            Set psDatabase to sDatabase
27495>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
27495>>>>>>>            If (bPermanantly = True) Begin
27497>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
27499>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
27500>>>>>>>                End
27500>>>>>>>>
27500>>>>>>>            End
27500>>>>>>>>
27500>>>>>>>        End
27500>>>>>>>>
27500>>>>>>>
27500>>>>>>>        Function_Return (Err = False)
27501>>>>>>>    End_Function
27502>>>>>>>
27502>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
27502>>>>>>>    // will be used.
27502>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
27504>>>>>>>        Boolean bOK bExists bShowProgress
27504>>>>>>>        String sStatement sDriverID
27504>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27504>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27504>>>>>>>        Integer iDbType
27504>>>>>>>
27504>>>>>>>        If (sDatabase = "") Begin
27506>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
27507>>>>>>>>
27507>>>>>>>            Function_Return False
27508>>>>>>>        End
27508>>>>>>>>
27508>>>>>>>        If (sBackupName = "") Begin
27510>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
27511>>>>>>>>
27511>>>>>>>            Function_Return False
27512>>>>>>>        End
27512>>>>>>>>
27512>>>>>>>
27512>>>>>>>        // Create backup-folder if it doesn't exist
27512>>>>>>>        Get vFolderExists sPath to bExists
27513>>>>>>>        If (bExists = False) Begin
27515>>>>>>>            Get vCreateDirectory sPath to bOK
27516>>>>>>>            If (bOK = False) Begin
27518>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
27519>>>>>>>>
27519>>>>>>>                Function_Return False
27520>>>>>>>            End
27520>>>>>>>>
27520>>>>>>>        End
27520>>>>>>>>
27520>>>>>>>        // Make sure the path ends with a back-slash
27520>>>>>>>        If (sPath <> "") Begin
27522>>>>>>>            Get vFolderFormat sPath to sPath
27523>>>>>>>        End
27523>>>>>>>>
27523>>>>>>>
27523>>>>>>>        Get psDriverID to sDriverID
27524>>>>>>>        Get piDbType   to iDbType
27525>>>>>>>        If (num_arguments > 3) Begin
27527>>>>>>>            Move bShowProg to bShowProgress
27528>>>>>>>        End
27528>>>>>>>>
27528>>>>>>>
27528>>>>>>>        Case Begin
27528>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
27530>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
27530>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
27530>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
27531>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
27532>>>>>>>
27532>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
27533>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
27534>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
27535>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
27536>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
27537>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
27538>>>>>>>                Case Break
27539>>>>>>>            Case Else
27539>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
27540>>>>>>>        Case End
27540>>>>>>>
27540>>>>>>>        Function_Return bOK
27541>>>>>>>    End_Function
27542>>>>>>>
27542>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
27544>>>>>>>//        Boolean bOK bExists
27544>>>>>>>        String sStatement sDriverID sRetval //sPrevious
27544>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27544>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
27544>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
27544>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
27544>>>>>>>        tSQLConnection SQLConnection
27544>>>>>>>        tSQLConnection SQLConnection
27544>>>>>>>
27544>>>>>>>        If (sDatabase = "") Begin
27546>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
27547>>>>>>>>
27547>>>>>>>            Function_Return ""
27548>>>>>>>        End
27548>>>>>>>>
27548>>>>>>>
27548>>>>>>>        Move "" to sRetval
27549>>>>>>>        Get psDriverID to sDriverID
27550>>>>>>>        Get piDbType   to iDbType
27551>>>>>>>
27551>>>>>>>        Case Begin
27551>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
27553>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
27553>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
27554>>>>>>>
27554>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
27555>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
27556>>>>>>>                Get phoSQLManager to hoSQLHandler
27557>>>>>>>
27557>>>>>>>                If (hoSQLHandler <> 0) Begin
27559>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
27560>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
27561>>>>>>>
27561>>>>>>>                    If (hoSQLConnect <> 0) Begin
27563>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
27564>>>>>>>                        If (hstmt <> 0) Begin
27566>>>>>>>                            Send SqlExecDirect of hstmt sStatement
27567>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
27568>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
27569>>>>>>>                            If (iFetchResult <> 0) Begin
27571>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
27572>>>>>>>                            End
27572>>>>>>>>
27572>>>>>>>                            Send SQLClose of hstmt
27573>>>>>>>                        End
27573>>>>>>>>
27573>>>>>>>                        Send SQLDisconnect of hoSQLConnect
27574>>>>>>>                    End
27574>>>>>>>>
27574>>>>>>>                End
27574>>>>>>>>
27574>>>>>>>                Case Break
27575>>>>>>>            Case Else
27575>>>>>>>                If (bSilent = False) Begin
27577>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
27578>>>>>>>                End
27578>>>>>>>>
27578>>>>>>>        Case End
27578>>>>>>>
27578>>>>>>>        Function_Return sRetval
27579>>>>>>>    End_Function
27580>>>>>>>
27580>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
27582>>>>>>>        Boolean bMertechDriver // bOK bExists 
27582>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
27582>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
27582>>>>>>>        Handle hConnection hStmt hoSQLManager
27582>>>>>>>        Integer iDbType // iFetchResult
27582>>>>>>>
27582>>>>>>>        If (sDatabase = "") Begin
27584>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
27585>>>>>>>>
27585>>>>>>>            Function_Return False
27586>>>>>>>        End
27586>>>>>>>>
27586>>>>>>>
27586>>>>>>>        If (sSQLCollation = "") Begin
27588>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
27589>>>>>>>>
27589>>>>>>>            Function_Return False
27590>>>>>>>        End
27590>>>>>>>>
27590>>>>>>>
27590>>>>>>>        Get psDriverID to sDriverID
27591>>>>>>>        Get piDbType   to iDbType
27592>>>>>>>
27592>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27593>>>>>>>        If (bMertechDriver = False) Begin
27595>>>>>>>            Get phoSQLManager to hoSQLManager
27596>>>>>>>        End
27596>>>>>>>>
27596>>>>>>>        Else Begin
27597>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
27598>>>>>>>        End
27598>>>>>>>>
27598>>>>>>>
27598>>>>>>>        Get psConnectionID     to sConnectionID
27599>>>>>>>        Get psConnectionString to sConnectionString
27600>>>>>>>        Move 0 to LastErr
27601>>>>>>>
27601>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27602>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
27603>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
27604>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
27606>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
27607>>>>>>>>
27607>>>>>>>            Function_Return False
27608>>>>>>>        End
27608>>>>>>>>
27608>>>>>>>
27608>>>>>>>        Get SqlOpen of hConnection to hStmt
27609>>>>>>>
27609>>>>>>>        If (hStmt = 0) Begin
27611>>>>>>>            Send SqlDisconnect of hoSQLManager
27612>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
27613>>>>>>>>
27613>>>>>>>            Function_Return False
27614>>>>>>>        End
27614>>>>>>>>
27614>>>>>>>
27614>>>>>>>        // Check if collation already exists
27614>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
27615>>>>>>>        // If the current collate is the same as the new; do nothing.
27615>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
27617>>>>>>>            Function_Return True
27618>>>>>>>        End
27618>>>>>>>>
27618>>>>>>>
27618>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
27619>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
27620>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
27621>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
27622>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
27623>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
27624>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
27625>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
27626>>>>>>>
27626>>>>>>>        // MS-SQL Syntax:
27626>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
27626>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
27626>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
27626>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
27627>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
27628>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
27629>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
27629>>>>>>>
27629>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27630>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
27631>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27632>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
27634>>>>>>>           Function_Return False
27635>>>>>>>        End
27635>>>>>>>>
27635>>>>>>>
27635>>>>>>>        Function_Return (Err = False)
27636>>>>>>>    End_Function
27637>>>>>>>
27637>>>>>>>
27637>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27637>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
27639>>>>>>>        Function_Return False
27640>>>>>>>    End_Function
27641>>>>>>>
27641>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
27641>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
27641>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
27641>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
27641>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
27641>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
27643>>>>>>>        Handle hToTable
27643>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
27643>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
27643>>>>>>>        tSQLConnection SQLConnection
27643>>>>>>>        tSQLConnection SQLConnection
27643>>>>>>>        Integer iPos iMaxRecords
27643>>>>>>>
27643>>>>>>>        Get psDriverID to sDriverID
27644>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
27645>>>>>>>        If (bExists = False) Begin
27647>>>>>>>            Function_Return False
27648>>>>>>>        End
27648>>>>>>>>
27648>>>>>>>
27648>>>>>>>        If (num_arguments > 1) Begin
27650>>>>>>>            Move bCpyDat to bCopyData
27651>>>>>>>        End
27651>>>>>>>>
27651>>>>>>>        Else Begin
27652>>>>>>>            Move False to bCopyData
27653>>>>>>>        End
27653>>>>>>>>
27653>>>>>>>
27653>>>>>>>        Open hTable
27655>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
27658>>>>>>>        If (bOpened = False) Begin
27660>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
27661>>>>>>>>
27661>>>>>>>            Function_Return False
27662>>>>>>>        End
27662>>>>>>>>
27662>>>>>>>        Move 0 to hToTable
27663>>>>>>>
27663>>>>>>>        Move 16711679 to iMaxRecords
27664>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
27667>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
27668>>>>>>>        If (iPos > 0) Begin
27670>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
27671>>>>>>>        End
27671>>>>>>>>
27671>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
27674>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
27675>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
27676>>>>>>>
27676>>>>>>>        If (ghoProgressBar <> 0) Begin
27678>>>>>>>            Send DoAdvance of ghoProgressBar
27679>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
27680>>>>>>>        End
27680>>>>>>>>
27680>>>>>>>
27680>>>>>>>        Move False to Err
27681>>>>>>>
27681>>>>>>>        Structure_Start hToTable DATAFLEX_ID
27682>>>>>>>            Structure_Copy hTable to hToTable
27683>>>>>>>
27683>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
27686>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
27689>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
27692>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
27695>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
27698>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27699>>>>>>>
27699>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27701>>>>>>>
27701>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27702>>>>>>>        Move (not(Err)) to bOK
27703>>>>>>>        If (bOK = True and bCopyData = True) Begin
27705>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
27706>>>>>>>        End
27706>>>>>>>>
27706>>>>>>>
27706>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27707>>>>>>>        If (bMertechDriver = True) Begin
27709>>>>>>>            Open hTable
27711>>>>>>>        End
27711>>>>>>>>
27711>>>>>>>
27711>>>>>>>        // This must be after copying data...
27711>>>>>>>        If (Err = False) Begin
27713>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
27716>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
27719>>>>>>>        End
27719>>>>>>>>
27719>>>>>>>        Move (not(Err)) to bOK
27720>>>>>>>
27720>>>>>>>        Function_Return (bOK = True)
27721>>>>>>>    End_Function
27722>>>>>>>
27722>>>>>>>    Function AddFolderDelimiter String sPath Returns String
27724>>>>>>>        String sDirSep
27724>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
27725>>>>>>>        Move (Trim(sPath)) to sPath
27726>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
27728>>>>>>>            Move (sPath + sDirSep) to sPath
27729>>>>>>>        End
27729>>>>>>>>
27729>>>>>>>        Function_Return sPath
27730>>>>>>>    End_Function
27731>>>>>>>
27731>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
27731>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
27731>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
27733>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
27733>>>>>>>        Integer iDbType
27733>>>>>>>        Boolean bExists
27733>>>>>>>
27733>>>>>>>        Get psDriverID to sDriverID
27734>>>>>>>        Get UtilTableHandleToString hTable to sTableName
27735>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
27736>>>>>>>        If (bExists = True) Begin
27738>>>>>>>            Function_Return False
27739>>>>>>>        End
27739>>>>>>>>
27739>>>>>>>
27739>>>>>>>        Get psDataPathFirstPart to sPath
27740>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
27741>>>>>>>
27741>>>>>>>        Get piDbType to iDbType
27742>>>>>>>        Get _SqlProperTableName sTableName to sTableName
27743>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
27744>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
27745>>>>>>>
27745>>>>>>>        Move False to Err
27746>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27747>>>>>>>
27747>>>>>>>        Function_Return (Err = False)
27748>>>>>>>    End_Function
27749>>>>>>>
27749>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
27749>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
27749>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
27751>>>>>>>        String sSQLString sPath sCreateTable sDriverID
27751>>>>>>>        Integer iDbType
27751>>>>>>>        Boolean bExists
27751>>>>>>>
27751>>>>>>>        Get psDriverID to sDriverID
27752>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
27753>>>>>>>        If (bExists = True) Begin
27755>>>>>>>            Function_Return False
27756>>>>>>>        End
27756>>>>>>>>
27756>>>>>>>
27756>>>>>>>        Get psDataPathFirstPart to sPath
27757>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
27758>>>>>>>        If (bExists = True) Begin
27760>>>>>>>            // ToDo: What should we do if an .int file already exists?
27760>>>>>>>        End
27760>>>>>>>>
27760>>>>>>>
27760>>>>>>>        Get piDbType to iDbType
27761>>>>>>>        Get _SqlProperTableName sTableName to sTableName
27762>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
27763>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
27764>>>>>>>
27764>>>>>>>        Move False to Err
27765>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27766>>>>>>>
27766>>>>>>>        Function_Return (Err = False)
27767>>>>>>>    End_Function
27768>>>>>>>    
27768>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
27768>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
27768>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
27770>>>>>>>        Boolean bOK                                                            
27770>>>>>>>        String sStatement
27770>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
27771>>>>>>>        Function_Return bOK
27772>>>>>>>    End_Function
27773>>>>>>>    
27773>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
27773>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
27773>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
27773>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
27775>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
27775>>>>>>>        Integer iRetval iDbType
27775>>>>>>>        Boolean bExists bMertechDriver bOK
27775>>>>>>>
27775>>>>>>>        Get psDriverID to sDriverID
27776>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27777>>>>>>>        Get UtilTableHandleToString hTable to sTableName
27778>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
27779>>>>>>>        If (bExists = False) Begin
27781>>>>>>>            Function_Return False
27782>>>>>>>        End
27782>>>>>>>>
27782>>>>>>>
27782>>>>>>>        Get psDataPathFirstPart to sPath
27783>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
27784>>>>>>>
27784>>>>>>>        Get piDbType to iDbType
27785>>>>>>>        Get _SqlProperTableName sTableName to sTableName
27786>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
27787>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
27788>>>>>>>
27788>>>>>>>        Move False to Err
27789>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27790>>>>>>>
27790>>>>>>>        // We also need to remove the cache-file since the table has been changed
27790>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
27791>>>>>>>
27791>>>>>>>        Function_Return (Err = False)
27792>>>>>>>    End_Function
27793>>>>>>>
27793>>>>>>>    // First deletes the data cache file and then drops the passed data table.
27793>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
27795>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
27795>>>>>>>        Integer iRetval iDbType
27795>>>>>>>        Boolean bMertechDriver bOK
27795>>>>>>>
27795>>>>>>>        Get psDriverID to sDriverID
27796>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27797>>>>>>>        Get psDataPathFirstPart to sPath
27798>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
27799>>>>>>>
27799>>>>>>>        Get piDbType to iDbType
27800>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
27801>>>>>>>        Get psSchema to sSchema
27802>>>>>>>        If (sSchema = "") Begin
27804>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
27805>>>>>>>        End
27805>>>>>>>>
27805>>>>>>>        Move (Uppercase(sTableName)) to sVal
27806>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
27808>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
27809>>>>>>>        End
27809>>>>>>>>
27809>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
27810>>>>>>>
27810>>>>>>>        Move False to Err
27811>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27812>>>>>>>
27812>>>>>>>        // We also need to remove the cache-file since the table has been changed
27812>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
27813>>>>>>>
27813>>>>>>>        Function_Return (Err = False)
27814>>>>>>>    End_Function
27815>>>>>>>
27815>>>>>>>    // *** Sql View Messages ***
27815>>>>>>>
27815>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
27815>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
27817>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
27817>>>>>>>        Integer iRetval
27817>>>>>>>        Boolean bMertechDriver bOK
27817>>>>>>>
27817>>>>>>>        Get psDriverID to sDriverID
27818>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
27819>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
27820>>>>>>>
27820>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
27821>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
27822>>>>>>>        Set psSQLStatementString to sSQLString
27823>>>>>>>
27823>>>>>>>        // As we don't check if the view exist or not, it might happen
27823>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
27823>>>>>>>        Move False to Err
27824>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27825>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27826>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27827>>>>>>>        Move 0 to LastErr
27828>>>>>>>
27828>>>>>>>        // We also need to remove the cache-file since the table has been changed
27828>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
27829>>>>>>>
27829>>>>>>>        Function_Return (Err = False)
27830>>>>>>>    End_Function
27831>>>>>>>
27831>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
27833>>>>>>>        Boolean bOK
27833>>>>>>>        Integer iDbType
27833>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
27833>>>>>>>
27833>>>>>>>        Get psDriverID to sDriverID
27834>>>>>>>        Get piDbType   to iDbType
27835>>>>>>>
27835>>>>>>>        Case Begin
27835>>>>>>>            Case (iDbType = EN_DbTypeDB2)
27837>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
27838>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
27839>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
27840>>>>>>>            Break
27841>>>>>>>
27841>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
27844>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
27845>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
27846>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
27847>>>>>>>            Break
27848>>>>>>>
27848>>>>>>>            Case (iDbType = EN_DbTypeOracle)
27851>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
27852>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
27853>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
27854>>>>>>>            Break
27855>>>>>>>
27855>>>>>>>            Case (iDbType = EN_DbTypePostgre)
27858>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
27859>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
27860>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
27861>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
27862>>>>>>>            Break
27863>>>>>>>
27863>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
27866>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
27867>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
27868>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
27869>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
27870>>>>>>>            Break
27871>>>>>>>        Case End
27871>>>>>>>
27871>>>>>>>        Move False to Err
27872>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
27873>>>>>>>        Move (Err = False) to bOK
27874>>>>>>>
27874>>>>>>>        Function_Return bOK
27875>>>>>>>    End_Function
27876>>>>>>>
27876>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27876>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
27878>>>>>>>        Function_Return False
27879>>>>>>>    End_Function
27880>>>>>>>
27880>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
27880>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
27882>>>>>>>        Integer iLength iDecimals
27882>>>>>>>        String sColumnValue
27882>>>>>>>        String sTableName sDriverID
27882>>>>>>>        Boolean bOK bInitializeValue
27882>>>>>>>
27882>>>>>>>        Get psDriverID to sDriverID
27883>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
27884>>>>>>>        If (bOK = False) Begin
27886>>>>>>>            Function_Return False
27887>>>>>>>        End
27887>>>>>>>>
27887>>>>>>>
27887>>>>>>>        Get UtilTableHandleToString hTable to sTableName
27888>>>>>>>        If (sTableName = "") Begin
27890>>>>>>>            Function_Return False
27891>>>>>>>        End
27891>>>>>>>>
27891>>>>>>>
27891>>>>>>>        If (num_arguments > 3) Begin
27893>>>>>>>            Move iLen     to iLength
27894>>>>>>>            Move iDec     to iDecimals
27895>>>>>>>            Move bInitVal to bInitializeValue
27896>>>>>>>            Move sColVal  to sColumnValue
27897>>>>>>>        End
27897>>>>>>>>
27897>>>>>>>
27897>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
27898>>>>>>>
27898>>>>>>>        Function_Return (bOK = True)
27899>>>>>>>    End_Function
27900>>>>>>>
27900>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
27900>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
27902>>>>>>>        Integer iDbType iLength iDecimals iDriver
27902>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
27902>>>>>>>        String sDriverID sNotNull
27902>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
27902>>>>>>>        Handle hTable
27902>>>>>>>
27902>>>>>>>        Get psDriverID to sDriverID
27903>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
27904>>>>>>>        If (bOK = False) Begin
27906>>>>>>>            Function_Return True
27907>>>>>>>        End
27907>>>>>>>>
27907>>>>>>>
27907>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
27908>>>>>>>        If (hTable = 0) Begin
27910>>>>>>>            Get NextFreeFilelistSlot to hTable
27911>>>>>>>        End
27911>>>>>>>>
27911>>>>>>>
27911>>>>>>>        Get piDbType to iDbType
27912>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
27912>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
27913>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
27915>>>>>>>            Function_Return True
27916>>>>>>>        End
27916>>>>>>>>
27916>>>>>>>
27916>>>>>>>        Get DriverIndex sDriverID to iDriver
27917>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
27918>>>>>>>        If (bIsMertechDriver = False) Begin
27920>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
27923>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
27926>>>>>>>        End
27926>>>>>>>>
27926>>>>>>>
27926>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
27927>>>>>>>        If (num_arguments > 3) Begin
27929>>>>>>>            Move iLen     to iLength
27930>>>>>>>            Move iDec     to iDecimals
27931>>>>>>>            Move bInitVal to bInitializeValue
27932>>>>>>>            Move sColVal  to sColumnValue
27933>>>>>>>        End
27933>>>>>>>>
27933>>>>>>>
27933>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
27934>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
27935>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
27936>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
27937>>>>>>>
27937>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
27938>>>>>>>        If (bFixed = False) Begin
27940>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
27941>>>>>>>        End
27941>>>>>>>>
27941>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
27942>>>>>>>
27942>>>>>>>        Move False to Err
27943>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
27944>>>>>>>
27944>>>>>>>        If (bInitializeValue = True and Err = False) Begin
27946>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
27947>>>>>>>        End
27947>>>>>>>>
27947>>>>>>>
27947>>>>>>>        If (Err = False) Begin
27949>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
27950>>>>>>>        End
27950>>>>>>>>
27950>>>>>>>
27950>>>>>>>        Move (not(Err)) to bRetval
27951>>>>>>>
27951>>>>>>>        // We also need to remove the cache-file since the table has been changed
27951>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
27952>>>>>>>        If (bIsMertechDriver = False) Begin
27954>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
27957>>>>>>>        End
27957>>>>>>>>
27957>>>>>>>        Function_Return bRetval
27958>>>>>>>    End_Function
27959>>>>>>>
27959>>>>>>>    // To update all current rows for a table column with a common value.
27959>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
27961>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
27961>>>>>>>        Boolean bRetval bSQLDriver
27961>>>>>>>        Integer iCurrErr iDbType
27961>>>>>>>
27961>>>>>>>        Move False to bRetval
27962>>>>>>>        Get piDbType to iDbType
27963>>>>>>>        Get psDriverID to sDriverID
27964>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
27965>>>>>>>        If (bSQLDriver = False) Begin
27967>>>>>>>            Function_Return bRetval
27968>>>>>>>        End
27968>>>>>>>>
27968>>>>>>>        Get UtilTableHandleToString hTable to sTableName
27969>>>>>>>
27969>>>>>>>        Move Err to iCurrErr
27970>>>>>>>        Move False to Err
27971>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
27972>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
27973>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
27974>>>>>>>        If (sDriverID = MDSMySQL) Begin
27976>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
27977>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
27978>>>>>>>        End
27978>>>>>>>>
27978>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
27978>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
27980>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
27981>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
27982>>>>>>>        End
27982>>>>>>>>
27982>>>>>>>        Else Begin
27983>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
27984>>>>>>>        End
27984>>>>>>>>
27984>>>>>>>
27984>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
27985>>>>>>>        Move (Err = False) to bRetval
27986>>>>>>>        Move iCurrErr to Err
27987>>>>>>>
27987>>>>>>>        Function_Return bRetval
27988>>>>>>>    End_Function
27989>>>>>>>
27989>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
27989>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
27989>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
27991>>>>>>>        String sDriverID sTableName
27991>>>>>>>        Boolean bOK
27991>>>>>>>
27991>>>>>>>        Get psDriverID to sDriverID
27992>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
27993>>>>>>>        If (bOK = False) Begin
27995>>>>>>>            Function_Return False
27996>>>>>>>        End
27996>>>>>>>>
27996>>>>>>>
27996>>>>>>>        Get UtilTableHandleToString hTable to sTableName
27997>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
27998>>>>>>>
27998>>>>>>>        Function_Return (Err = False)
27999>>>>>>>    End_Function
28000>>>>>>>
28000>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
28000>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
28000>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
28000>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
28002>>>>>>>        Integer iDbType iLength iDecimals
28002>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
28002>>>>>>>        Boolean bExists bOK bFixed
28002>>>>>>>        Handle hTable
28002>>>>>>>
28002>>>>>>>        Get psDriverID to sDriverID
28003>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28004>>>>>>>        If (bOK = False) Begin
28006>>>>>>>            Function_Return False
28007>>>>>>>        End
28007>>>>>>>>
28007>>>>>>>
28007>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
28008>>>>>>>        If (hTable = 0) Begin
28010>>>>>>>            Get NextFreeFilelistSlot to hTable
28011>>>>>>>        End
28011>>>>>>>>
28011>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
28012>>>>>>>        If (bExists = False) Begin
28014>>>>>>>            Function_Return False
28015>>>>>>>        End
28015>>>>>>>>
28015>>>>>>>
28015>>>>>>>        If (num_arguments > 3) Begin
28017>>>>>>>            Move iLen to iLength
28018>>>>>>>        End
28018>>>>>>>>
28018>>>>>>>        If (num_arguments > 4) Begin
28020>>>>>>>            Move iDec to iDecimals
28021>>>>>>>        End
28021>>>>>>>>
28021>>>>>>>
28021>>>>>>>        Get piDbType to iDbType
28022>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
28023>>>>>>>
28023>>>>>>>        Move False to Err
28024>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
28025>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
28026>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
28027>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
28028>>>>>>>
28028>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
28029>>>>>>>        If (bFixed = False) Begin
28031>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
28032>>>>>>>        End
28032>>>>>>>>
28032>>>>>>>
28032>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
28033>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28034>>>>>>>
28034>>>>>>>        // We also need to remove the cache-file since the table has been changed
28034>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28035>>>>>>>
28035>>>>>>>        Function_Return (Err = False)
28036>>>>>>>    End_Function
28037>>>>>>>
28037>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
28039>>>>>>>        Boolean bOK bErr bIsSQLDriver
28039>>>>>>>        String sDriverID
28039>>>>>>>        Integer iDataType
28039>>>>>>>
28039>>>>>>>        Get psDriverID to sDriverID
28040>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
28041>>>>>>>        If (bIsSQLDriver = False) Begin
28043>>>>>>>            Function_Return False
28044>>>>>>>        End
28044>>>>>>>>
28044>>>>>>>
28044>>>>>>>        Move Err to bErr
28045>>>>>>>        Move False to bErr
28046>>>>>>>
28046>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
28046>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
28046>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
28047>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
28050>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
28052>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
28053>>>>>>>        End
28053>>>>>>>>
28053>>>>>>>
28053>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
28056>>>>>>>        Move (not(Err)) to bOK
28057>>>>>>>        Move bErr to Err
28058>>>>>>>
28058>>>>>>>        Function_Return bOK
28059>>>>>>>    End_Function
28060>>>>>>>
28060>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
28062>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
28062>>>>>>>        String sDriverID
28062>>>>>>>
28062>>>>>>>        Get psDriverID to sDriverID
28063>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
28064>>>>>>>        If (bIsSQLDriver = False) Begin
28066>>>>>>>            Function_Return False
28067>>>>>>>        End
28067>>>>>>>>
28067>>>>>>>
28067>>>>>>>        Move Err to bErr
28068>>>>>>>        Move False to bErr
28069>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
28072>>>>>>>        If (bNullable = bCurrentState) Begin
28074>>>>>>>            Function_Return True
28075>>>>>>>        End
28075>>>>>>>>
28075>>>>>>>
28075>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
28078>>>>>>>        If (bOpen = False) Begin
28080>>>>>>>            Get AutoConnectionIDLogin to bOK
28081>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28082>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
28083>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
28084>>>>>>>            Open hTable
28086>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28087>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
28088>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
28089>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
28092>>>>>>>        End
28092>>>>>>>>
28092>>>>>>>        If (bOpen = True) Begin
28094>>>>>>>            Structure_Start hTable sDriverID
28095>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
28098>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
28099>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28101>>>>>>>            Set Action_Text of ghoStatusPanel to ""
28102>>>>>>>        End
28102>>>>>>>>
28102>>>>>>>
28102>>>>>>>        Move (not(Err)) to bOK
28103>>>>>>>        Move bErr to Err
28104>>>>>>>
28104>>>>>>>        Function_Return bOK
28105>>>>>>>    End_Function
28106>>>>>>>
28106>>>>>>>    // Drop column by its table handle
28106>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
28108>>>>>>>        String sDriverID sTableName
28108>>>>>>>        Boolean bOK
28108>>>>>>>
28108>>>>>>>        Get psDriverID to sDriverID
28109>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28110>>>>>>>        If (bOK = False) Begin
28112>>>>>>>            Function_Return False
28113>>>>>>>        End
28113>>>>>>>>
28113>>>>>>>
28113>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28114>>>>>>>        If (sTableName = "") Begin
28116>>>>>>>            Function_Return False
28117>>>>>>>        End
28117>>>>>>>>
28117>>>>>>>
28117>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
28118>>>>>>>
28118>>>>>>>        Function_Return (bOK = True)
28119>>>>>>>    End_Function
28120>>>>>>>
28120>>>>>>>    // Drop column by its table name as a string.
28120>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
28122>>>>>>>        Integer iDbType iDriver
28122>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
28122>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
28122>>>>>>>        Handle hTable
28122>>>>>>>
28122>>>>>>>        Get psDriverID to sDriverID
28123>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28124>>>>>>>        If (bOK = False) Begin
28126>>>>>>>            Function_Return False
28127>>>>>>>        End
28127>>>>>>>>
28127>>>>>>>
28127>>>>>>>        Get DriverIndex sDriverID to iDriver
28128>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28131>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
28134>>>>>>>
28134>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
28135>>>>>>>        If (hTable <> 0) Begin
28137>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
28138>>>>>>>            If (bExists = False) Begin
28140>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28143>>>>>>>                Function_Return False
28144>>>>>>>            End
28144>>>>>>>>
28144>>>>>>>        End
28144>>>>>>>>
28144>>>>>>>
28144>>>>>>>        Get piDbType to iDbType
28145>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
28147>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
28148>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
28149>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28152>>>>>>>            Function_Return bOK
28153>>>>>>>        End
28153>>>>>>>>
28153>>>>>>>
28153>>>>>>>        Move False to Err
28154>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
28155>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
28156>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
28157>>>>>>>
28157>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
28158>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28159>>>>>>>        Move (not(Err)) to bRetval
28160>>>>>>>
28160>>>>>>>        // We also need to remove the cache-file since the table has been changed
28160>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28161>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
28164>>>>>>>
28164>>>>>>>        Function_Return bRetval
28165>>>>>>>    End_Function
28166>>>>>>>
28166>>>>>>>    // Rename a field/column by table handle (filelist number)
28166>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
28168>>>>>>>        String sDriverID sTableName
28168>>>>>>>        Boolean bOK
28168>>>>>>>
28168>>>>>>>        Get psDriverID to sDriverID
28169>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28170>>>>>>>        If (bOK = False) Begin
28172>>>>>>>            Function_Return False
28173>>>>>>>        End
28173>>>>>>>>
28173>>>>>>>
28173>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28174>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
28175>>>>>>>
28175>>>>>>>        Function_Return (Err = False)
28176>>>>>>>    End_Function
28177>>>>>>>
28177>>>>>>>    // Rename a field/column by table name.
28177>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
28179>>>>>>>        Integer iDbType iDataType
28179>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
28179>>>>>>>        Boolean bOK bRetval
28179>>>>>>>        Handle hTable
28179>>>>>>>
28179>>>>>>>        Move sTableName to sOrgTableName
28180>>>>>>>        Get psDriverID to sDriverID
28181>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28182>>>>>>>        If (bOK = False) Begin
28184>>>>>>>            Function_Return False
28185>>>>>>>        End
28185>>>>>>>>
28185>>>>>>>
28185>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
28186>>>>>>>        If (sVal = "") Begin
28188>>>>>>>            Function_Return False
28189>>>>>>>        End
28189>>>>>>>>
28189>>>>>>>
28189>>>>>>>        Get piDbType to iDbType
28190>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
28191>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
28192>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
28193>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
28194>>>>>>>
28194>>>>>>>        Case Begin
28194>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
28196>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
28197>>>>>>>                Case Break
28198>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
28198>>>>>>>            Case (iDbType = EN_dbTypeOracle)
28201>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
28202>>>>>>>                Case Break
28203>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
28203>>>>>>>            Case (iDbType = EN_dbTypeDB2)
28206>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
28207>>>>>>>                Case Break
28208>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
28208>>>>>>>            Case (iDbType = EN_dbTypePostgre)
28211>>>>>>>                Move sOrgTableName to sTableName
28212>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
28213>>>>>>>                Case Break
28214>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
28217>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
28217>>>>>>>                Move sOrgTableName to sTableName
28218>>>>>>>                Get psDatabase to sDatabase
28219>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
28220>>>>>>>                If (hTable = 0) Begin
28222>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
28223>>>>>>>                    If (bOK = False) Begin
28225>>>>>>>                        Function_Return False
28226>>>>>>>                    End
28226>>>>>>>>
28226>>>>>>>                    Get NextFreeFilelistSlot to hTable
28227>>>>>>>                End
28227>>>>>>>>
28227>>>>>>>                Else Begin
28228>>>>>>>                    Open hTable
28230>>>>>>>                End
28230>>>>>>>>
28230>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
28231>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
28232>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
28233>>>>>>>                Case Break
28234>>>>>>>            Case Else
28234>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
28235>>>>>>>        Case End
28235>>>>>>>
28235>>>>>>>        Move False to Err
28236>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
28237>>>>>>>        Move (Err = False) to bRetval
28238>>>>>>>        // We also need to remove the cache-file since the table has been changed
28238>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28239>>>>>>>
28239>>>>>>>        Function_Return bRetval
28240>>>>>>>    End_Function
28241>>>>>>>
28241>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
28243>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
28243>>>>>>>        Boolean bMertechDriver
28243>>>>>>>        Integer iNumCols iCount iDataType
28243>>>>>>>        String sValue
28243>>>>>>>
28243>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28244>>>>>>>        If (bMertechDriver = False) Begin
28246>>>>>>>            Get phoSQLManager to hoSQLHandler
28247>>>>>>>        End
28247>>>>>>>>
28247>>>>>>>        Else Begin
28248>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
28249>>>>>>>        End
28249>>>>>>>>
28249>>>>>>>
28249>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
28250>>>>>>>        If (hSQLConnect <> 0) Begin
28252>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
28253>>>>>>>            If (hStmt <> 0) Begin
28255>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
28256>>>>>>>
28256>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
28257>>>>>>>                For iCount from 1 to iNumCols
28263>>>>>>>>
28263>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
28264>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
28266>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
28267>>>>>>>                        Move iNumCols to iCount // We're out of here
28268>>>>>>>                    End
28268>>>>>>>>
28268>>>>>>>                Loop
28269>>>>>>>>
28269>>>>>>>
28269>>>>>>>                Send SQLClose of hStmt
28270>>>>>>>            End
28270>>>>>>>>
28270>>>>>>>            Send SQLDisconnect of hSQLConnect
28271>>>>>>>        End
28271>>>>>>>>
28271>>>>>>>
28271>>>>>>>        Function_Return iDataType
28272>>>>>>>    End_Function
28273>>>>>>>
28273>>>>>>>    // * Dummy function for the Studio's Code Explorer *
28273>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
28275>>>>>>>        Function_Return False
28276>>>>>>>    End_Function
28277>>>>>>>
28277>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
28279>>>>>>>        String sMessage // sConnectionString
28279>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
28279>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
28279>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
28282>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
28282>>>>>>>        TimeSpan tsQuery tsFetch
28282>>>>>>>        tSqlErrorArray aSqlErrorArray
28282>>>>>>>        tSqlErrorArray aSqlErrorArray
28282>>>>>>>        Boolean bOK bMertechDriver bShowProgress
28282>>>>>>>        tSQLConnection SQLConnection
28282>>>>>>>        tSQLConnection SQLConnection
28282>>>>>>>
28282>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28283>>>>>>>        If (bOK = False) Begin
28285>>>>>>>            Procedure_Return
28286>>>>>>>        End
28286>>>>>>>>
28286>>>>>>>
28286>>>>>>>        If (num_arguments > 2) Begin
28288>>>>>>>            Move bShowProgr to bShowProgress
28289>>>>>>>        End
28289>>>>>>>>
28289>>>>>>>
28289>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28290>>>>>>>
28290>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28291>>>>>>>        If (bMertechDriver = True) Begin
28293>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
28294>>>>>>>        End
28294>>>>>>>>
28294>>>>>>>        If (bMertechDriver = False) Begin
28296>>>>>>>            Get phoSQLManager to hoSqlHandler
28297>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
28298>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
28299>>>>>>>        End
28299>>>>>>>>
28299>>>>>>>
28299>>>>>>>        If (hoSQLConnect <> 0) Begin
28301>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
28302>>>>>>>            If (hoStmt <> 0) Begin
28304>>>>>>>                // record starting date/time stamp
28304>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
28305>>>>>>>                // turn on error handling if enabled
28305>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
28307>>>>>>>                    Set pbSqlError to False
28308>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
28309>>>>>>>                    Move Error_Object_Id to hoError
28310>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
28312>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
28313>>>>>>>                    End
28313>>>>>>>>
28313>>>>>>>                    Else Begin
28314>>>>>>>                        Move Self to Error_Object_Id
28315>>>>>>>                    End
28315>>>>>>>>
28315>>>>>>>                End
28315>>>>>>>>
28315>>>>>>>
28315>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
28315>>>>>>>                Set psSQLStatementString to sStmt
28316>>>>>>>                Send Cursor_Wait of Cursor_Control
28317>>>>>>>                Send SqlExecDirect of hoStmt sStmt
28318>>>>>>>                Send Cursor_Ready of Cursor_Control
28319>>>>>>>
28319>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
28321>>>>>>>                    Move hoError to Error_Object_Id
28322>>>>>>>                End
28322>>>>>>>>
28322>>>>>>>
28322>>>>>>>                Move 0 to iMsgs
28323>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
28323>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
28323>>>>>>>                If (bMertechDriver = False) Begin
28325>>>>>>>                    Move Err to iErr
28326>>>>>>>                    Move LastErr to iLastErr
28327>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
28328>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
28329>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
28330>>>>>>>                    Send _SqlColumnInfo hoStmt
28331>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
28332>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28333>>>>>>>                    Repeat
28333>>>>>>>>
28333>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
28334>>>>>>>                        If (iFetchResult <> 0) Begin
28336>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
28337>>>>>>>                        End
28337>>>>>>>>
28337>>>>>>>                    Until (iFetchResult = 0)
28339>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
28340>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
28341>>>>>>>                    Move iErr to Err
28342>>>>>>>                    Move iLastErr to LastErr
28343>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
28344>>>>>>>                End
28344>>>>>>>>
28344>>>>>>>
28344>>>>>>>                Set piRows    to iRows
28345>>>>>>>                Set piRowType to iRowType
28346>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
28347>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
28348>>>>>>>
28348>>>>>>>                If (iMsgs <> 0) Begin
28350>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
28352>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28353>>>>>>>                    End
28353>>>>>>>>
28353>>>>>>>                    For i from 1 to iMsgs
28359>>>>>>>>
28359>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
28360>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
28361>>>>>>>                        If (bShowProgress = True) Begin
28363>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
28365>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
28366>>>>>>>                            End
28366>>>>>>>>
28366>>>>>>>                            Else Begin
28367>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
28369>>>>>>>                            End
28369>>>>>>>>
28369>>>>>>>                        End
28369>>>>>>>>
28369>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
28370>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
28371>>>>>>>                    Loop
28372>>>>>>>>
28372>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
28374>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28375>>>>>>>                    End
28375>>>>>>>>
28375>>>>>>>                    Set paQueryMessages to sMsg
28376>>>>>>>                End
28376>>>>>>>>
28376>>>>>>>                Else Begin
28377>>>>>>>                    If (bShowProgress = True) Begin
28379>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
28380>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
28382>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
28383>>>>>>>                            Decrement iMsgs
28384>>>>>>>                            For i from 0 to iMsgs
28390>>>>>>>>
28390>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
28393>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
28396>>>>>>>                            Loop
28397>>>>>>>>
28397>>>>>>>                        End
28397>>>>>>>>
28397>>>>>>>                    End
28397>>>>>>>>
28397>>>>>>>                End
28397>>>>>>>>
28397>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
28398>>>>>>>            End
28398>>>>>>>>
28398>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
28399>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
28400>>>>>>>            Set ptsQueryExec to tsQuery
28401>>>>>>>            Set ptsFetchResults to tsFetch
28402>>>>>>>            Send SqlClose of hoStmt
28403>>>>>>>        End
28403>>>>>>>>
28403>>>>>>>
28403>>>>>>>        Send SqlDisconnect of hoSQLConnect
28404>>>>>>>    End_Procedure
28405>>>>>>>
28405>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
28405>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
28405>>>>>>>    // Returns False if no error occured.
28405>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
28407>>>>>>>        Boolean bOK bShowProgress
28407>>>>>>>        tSQLScriptArray SQLScriptArray
28407>>>>>>>        tSQLScriptArray SQLScriptArray
28407>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
28407>>>>>>>        TimeSpan tsTotalTime
28407>>>>>>>
28407>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
28408>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
28409>>>>>>>        If (SQLScriptArray.bError = True) Begin
28411>>>>>>>            Function_Return False
28412>>>>>>>        End
28412>>>>>>>>
28412>>>>>>>
28412>>>>>>>        If (num_arguments > 3) Begin
28414>>>>>>>            Move bShowProgr to bShowProgress
28415>>>>>>>        End
28415>>>>>>>>
28415>>>>>>>
28415>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28416>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
28417>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
28418>>>>>>>
28418>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
28419>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
28420>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
28421>>>>>>>
28421>>>>>>>        Function_Return bOK
28422>>>>>>>    End_Function
28423>>>>>>>
28423>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
28423>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
28423>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
28423>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
28425>>>>>>>        Integer iChannel iArgumentSize iCount
28425>>>>>>>        Number nByteCount
28425>>>>>>>        String sSQLScript
28425>>>>>>>        tSQLScriptArray SqlScriptArray
28425>>>>>>>        tSQLScriptArray SqlScriptArray
28425>>>>>>>        UChar[] uCharData
28426>>>>>>>
28426>>>>>>>        Move False to Err
28427>>>>>>>        Get Seq_New_Channel to iChannel
28428>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28430>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
28431>>>>>>>>
28431>>>>>>>            Move True to SqlScriptArray.bError
28432>>>>>>>            Function_Return SqlScriptArray
28433>>>>>>>        End
28433>>>>>>>>
28433>>>>>>>
28433>>>>>>>        // First decide the size of the script
28433>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
28435>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
28437>>>>>>>        Close_Input channel iChannel
28439>>>>>>>
28439>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
28440>>>>>>>        If (nByteCount  < 1) Begin
28442>>>>>>>            Send Seq_Release_Channel iChannel
28443>>>>>>>            Move True to SqlScriptArray.bError
28444>>>>>>>            Function_Return SqlScriptArray
28445>>>>>>>        End
28445>>>>>>>>
28445>>>>>>>
28445>>>>>>>        // If necessary change the string argument_size
28445>>>>>>>        // Read the script file from memory line-by-line
28445>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
28447>>>>>>>            Move 0 to iCount
28448>>>>>>>            Repeat
28448>>>>>>>>
28448>>>>>>>                Readln channel iChannel sSQLScript
28450>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
28451>>>>>>>                Increment iCount
28452>>>>>>>            Until (SeqEof = True)
28454>>>>>>>        Close_Input channel iChannel
28456>>>>>>>        Send Seq_Release_Channel iChannel
28457>>>>>>>
28457>>>>>>>        // Finally "sanitize" the script by removing all comments.
28457>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
28458>>>>>>>
28458>>>>>>>        Function_Return SqlScriptArray
28459>>>>>>>    End_Function
28460>>>>>>>
28460>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
28462>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
28462>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
28462>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
28462>>>>>>>        String[] sMsg aSQLQueryMessages
28464>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
28464>>>>>>>        TimeSpan tsQuery
28464>>>>>>>        tSqlErrorArray aSqlErrorArray
28464>>>>>>>        tSqlErrorArray aSqlErrorArray
28464>>>>>>>        tSQLConnection SQLConnection
28464>>>>>>>        tSQLConnection SQLConnection
28464>>>>>>>        Boolean bMertechDriver bShowProgress
28464>>>>>>>
28464>>>>>>>        If (num_arguments > 4) Begin
28466>>>>>>>            Move bShowProgr to bShowProgress
28467>>>>>>>        End
28467>>>>>>>>
28467>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28468>>>>>>>        If (bMertechDriver = False) Begin
28470>>>>>>>            Get phoSQLManager to hoSql
28471>>>>>>>        End
28471>>>>>>>>
28471>>>>>>>        Else Begin
28472>>>>>>>            Get _MertechSQLManagerHandle to hoSql
28473>>>>>>>        End
28473>>>>>>>>
28473>>>>>>>
28473>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
28474>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
28474>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
28474>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
28474>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
28474>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
28474>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
28474>>>>>>>        Get piChunkMax to iChunkMax
28475>>>>>>>        Move 0 to iChunkCounter
28476>>>>>>>        Move "" to sStmt
28477>>>>>>>
28477>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
28478>>>>>>>        Move (Character(13) + Character(10)) to sCR
28479>>>>>>>
28479>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28480>>>>>>>
28480>>>>>>>        If (bMertechDriver = True) Begin
28482>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
28483>>>>>>>        End
28483>>>>>>>>
28483>>>>>>>        If (bMertechDriver = False) Begin
28485>>>>>>>            Get phoSQLManager  to hoSQL
28486>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
28488>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
28490>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
28491>>>>>>>                    If (iPos > 0) Begin
28493>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
28494>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
28495>>>>>>>                    End
28495>>>>>>>>
28495>>>>>>>                End
28495>>>>>>>>
28495>>>>>>>            End
28495>>>>>>>>
28495>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
28496>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
28497>>>>>>>        End
28497>>>>>>>>
28497>>>>>>>
28497>>>>>>>        If (hoSQLConnect <> 0) Begin
28499>>>>>>>            Move False to Err
28500>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
28501>>>>>>>            If (hoStmt <> 0) Begin
28503>>>>>>>
28503>>>>>>>                // If the embedded resource should be written as a script file to disk:
28503>>>>>>>                If (bCreateScriptFile = True) Begin
28505>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
28506>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
28507>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
28508>>>>>>>                    Get Seq_New_Channel to iOut
28509>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28511>>>>>>>                        Direct_Output channel iOut sExportFile
28513>>>>>>>                    End
28513>>>>>>>>
28513>>>>>>>                End
28513>>>>>>>>
28513>>>>>>>
28513>>>>>>>                // Record starting date/time stamp
28513>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
28514>>>>>>>                // Turn on error handling if enabled
28514>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
28516>>>>>>>                    Set pbSqlError to False
28517>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
28518>>>>>>>                    Move Error_Object_Id to hoError
28519>>>>>>>                    Move Self to Error_Object_Id
28520>>>>>>>                End
28520>>>>>>>>
28520>>>>>>>
28520>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
28521>>>>>>>                Decrement iRows
28522>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
28524>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
28525>>>>>>>                End
28525>>>>>>>>
28525>>>>>>>
28525>>>>>>>                For iCount from 0 to iRows
28531>>>>>>>>
28531>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
28532>>>>>>>
28532>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
28534>>>>>>>                        If (sSQLVal <> "") Begin
28536>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
28537>>>>>>>                        End
28537>>>>>>>>
28537>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
28538>>>>>>>                    End
28538>>>>>>>>
28538>>>>>>>
28538>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
28538>>>>>>>                    // or if at the very end of the script.
28538>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
28540>>>>>>>
28540>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
28540>>>>>>>                        // instead of all in one go.
28540>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
28541>>>>>>>
28541>>>>>>>                        If (bCreateScriptFile = True) Begin
28543>>>>>>>                            Write channel iOut sStmt
28545>>>>>>>                        End
28545>>>>>>>>
28545>>>>>>>                        Move "" to sStmt
28546>>>>>>>                        Move 0 to iChunkCounter
28547>>>>>>>                    End
28547>>>>>>>>
28547>>>>>>>                    Increment iChunkCounter
28548>>>>>>>                Loop
28549>>>>>>>>
28549>>>>>>>
28549>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
28549>>>>>>>                //       so not used for now.
28549>>>>>>>                If (bMertechDriver = False) Begin
28551>>>>>>>                    Repeat
28551>>>>>>>>
28551>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
28553>>>>>>>                            Move hoError to Error_Object_Id
28554>>>>>>>                        End
28554>>>>>>>>
28554>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
28555>>>>>>>
28555>>>>>>>                        Send _SqlColumnInfo hoStmt
28556>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
28557>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
28558>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
28559>>>>>>>                        Set piRows    to iRows
28560>>>>>>>                        Set piRowType to iRowType
28561>>>>>>>
28561>>>>>>>                        If (iMsgs <> 0) Begin
28563>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
28565>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28566>>>>>>>                            End
28566>>>>>>>>
28566>>>>>>>                            For i from 1 to iMsgs
28572>>>>>>>>
28572>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
28573>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
28574>>>>>>>                                If (bShowProgress = True) Begin
28576>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
28578>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
28579>>>>>>>                                    End
28579>>>>>>>>
28579>>>>>>>                                    Else Begin
28580>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
28582>>>>>>>                                    End
28582>>>>>>>>
28582>>>>>>>                                End
28582>>>>>>>>
28582>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
28583>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
28584>>>>>>>                            Loop
28585>>>>>>>>
28585>>>>>>>
28585>>>>>>>
28585>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
28587>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
28588>>>>>>>                            End
28588>>>>>>>>
28588>>>>>>>                            Set paQueryMessages to sMsg
28589>>>>>>>                        End
28589>>>>>>>>
28589>>>>>>>
28589>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
28590>>>>>>>                    Until (iNextSet = 0)
28592>>>>>>>                End
28592>>>>>>>>
28592>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
28593>>>>>>>            End
28593>>>>>>>>
28593>>>>>>>
28593>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
28594>>>>>>>            Set ptsQueryExec to tsQuery
28595>>>>>>>            Send SqlClose of hoStmt
28596>>>>>>>
28596>>>>>>>            If (bCreateScriptFile = True) Begin
28598>>>>>>>                Close_Output channel iOut
28600>>>>>>>                Send Seq_Release_Channel iOut
28601>>>>>>>            End
28601>>>>>>>>
28601>>>>>>>        End
28601>>>>>>>>
28601>>>>>>>        Send SqlDisconnect of hoSQLConnect
28602>>>>>>>
28602>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
28603>>>>>>>    End_Function
28604>>>>>>>
28604>>>>>>>    // * Dummy function for the Studio's Code Explorer *
28604>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
28606>>>>>>>        Function_Return False
28607>>>>>>>    End_Function
28608>>>>>>>
28608>>>>>>>    // Does three things with auxilirary files;
28608>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
28608>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
28608>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
28608>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
28610>>>>>>>        String sDataPath sDDSrcPath sDriverID
28610>>>>>>>        Boolean bOK bExists bMertechDriver
28610>>>>>>>        Integer iCount iCh iPos
28610>>>>>>>
28610>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
28610>>>>>>>        If (sTableName contains ".") Begin
28612>>>>>>>            Move (Pos(".", sTableName)) to iPos
28613>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
28614>>>>>>>        End
28614>>>>>>>>
28614>>>>>>>
28614>>>>>>>        Get psDriverID to sDriverID
28615>>>>>>>        Get psDataPathFirstPart to sDataPath
28616>>>>>>>        Get vFolderExists sDataPath to bOK
28617>>>>>>>        If (bOK = False) Begin
28619>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
28620>>>>>>>>
28620>>>>>>>            Function_Return False
28621>>>>>>>        End
28621>>>>>>>>
28621>>>>>>>
28621>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
28622>>>>>>>        // First delete the cache file:
28622>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
28623>>>>>>>
28623>>>>>>>        Get Seq_New_Channel to iCh
28624>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28626>>>>>>>            Function_Return False
28627>>>>>>>        End
28627>>>>>>>>
28627>>>>>>>
28627>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
28628>>>>>>>        If (bExists = False) Begin
28630>>>>>>>            Function_Return False
28631>>>>>>>        End
28631>>>>>>>>
28631>>>>>>>
28631>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
28632>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
28632>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
28633>>>>>>>
28633>>>>>>>        // If in development environment; output new .fd file:
28633>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
28634>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
28635>>>>>>>        If (iCount > 1) Begin
28637>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
28638>>>>>>>        End
28638>>>>>>>>
28638>>>>>>>        Get vFolderExists sDDSrcPath to bExists
28639>>>>>>>        If (bExists = True) Begin
28641>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
28642>>>>>>>            Move False to Err
28643>>>>>>>            Get AutoConnectionIDLogin to bOK
28644>>>>>>>            If (hTable <> 0) Begin
28646>>>>>>>                Open hTable
28648>>>>>>>            End
28648>>>>>>>>
28648>>>>>>>            Else Begin
28649>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
28650>>>>>>>            End
28650>>>>>>>>
28650>>>>>>>
28650>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
28653>>>>>>>            If (bOK = True) Begin
28655>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
28657>>>>>>>            End
28657>>>>>>>>
28657>>>>>>>            If (Err = True) Begin
28659>>>>>>>                Move False to bOK
28660>>>>>>>            End
28660>>>>>>>>
28660>>>>>>>        End
28660>>>>>>>>
28660>>>>>>>
28660>>>>>>>        Function_Return (bOK = True)
28661>>>>>>>    End_Function
28662>>>>>>>
28662>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
28664>>>>>>>        Integer iChIn iChOut // iCount
28664>>>>>>>        Boolean bExists
28664>>>>>>>        String sExistingColumn
28664>>>>>>>
28664>>>>>>>        Move False to bExists
28665>>>>>>>        Get Seq_New_Channel to iChIn
28666>>>>>>>        Get Seq_New_Channel to iChOut
28667>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
28669>>>>>>>            Function_Return True
28670>>>>>>>        End
28670>>>>>>>>
28670>>>>>>>
28670>>>>>>>        Move False to Err
28671>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
28671>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
28673>>>>>>>        While (not(SeqEof))
28677>>>>>>>            Readln channel iChIn sExistingColumn
28679>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
28681>>>>>>>                Move True to bExists
28682>>>>>>>            End
28682>>>>>>>>
28682>>>>>>>            If (Trim(sExistingColumn) = "") Begin
28684>>>>>>>                Move True to SeqEof
28685>>>>>>>            End
28685>>>>>>>>
28685>>>>>>>        Loop
28686>>>>>>>>
28686>>>>>>>        Close_Input channel iChIn
28688>>>>>>>        Send Seq_Release_Channel iChIn
28689>>>>>>>
28689>>>>>>>        If (bExists = False) Begin
28691>>>>>>>            Append_Output channel iChOut sFullTAGFileName
28693>>>>>>>            Writeln channel iChOut sColumnName
28696>>>>>>>            Close_Output channel iChOut
28698>>>>>>>            Send Seq_Release_Channel iChOut
28699>>>>>>>        End
28699>>>>>>>>
28699>>>>>>>
28699>>>>>>>        Function_Return (Err = False)
28700>>>>>>>    End_Function
28701>>>>>>>
28701>>>>>>>    // Message for changing .int files to use connection ID's
28701>>>>>>>    //
28701>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
28701>>>>>>>    // OR changes an existing connection id to a new id.
28701>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
28701>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
28701>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
28703>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
28703>>>>>>>        String[] sFilesData
28704>>>>>>>        Boolean bOK bCancel
28704>>>>>>>        Integer iSize iCount
28704>>>>>>>
28704>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
28705>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
28706>>>>>>>        If (iSize = 0) Begin
28708>>>>>>>            If (ghoStatusPanel <> 0) Begin
28710>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
28712>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
28713>>>>>>>                End
28713>>>>>>>>
28713>>>>>>>            End
28713>>>>>>>>
28713>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
28714>>>>>>>            Procedure_Return
28715>>>>>>>        End
28715>>>>>>>>
28715>>>>>>>
28715>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
28716>>>>>>>        Get vFolderFormat sDataPath to sDataPath
28717>>>>>>>        Decrement iSize
28718>>>>>>>        For iCount from 0 to iSize
28724>>>>>>>>
28724>>>>>>>            Move sFilesData[iCount] to sFileName
28725>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
28725>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
28726>>>>>>>            If (ghoStatusPanel <> 0) Begin
28728>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
28730>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
28731>>>>>>>                    If (bCancel = True) Begin
28733>>>>>>>                        Send Deactivate of ghoStatusPanel
28734>>>>>>>                        Procedure_Return
28735>>>>>>>                    End
28735>>>>>>>>
28735>>>>>>>                End
28735>>>>>>>>
28735>>>>>>>            End
28735>>>>>>>>
28735>>>>>>>        Loop
28736>>>>>>>>
28736>>>>>>>
28736>>>>>>>        Get psDriverID to sDriverID
28737>>>>>>>
28737>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
28737>>>>>>>        Move "" to sFileName
28738>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
28740>>>>>>>            Move "MSSQLDrv.int" to sFileName
28741>>>>>>>        End
28741>>>>>>>>
28741>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
28743>>>>>>>            Move "DB2_Drv.int" to sFileName
28744>>>>>>>        End
28744>>>>>>>>
28744>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
28746>>>>>>>            Move "ODBC_Drv.int" to sFileName
28747>>>>>>>        End
28747>>>>>>>>
28747>>>>>>>        If (sFileName <> "") Begin
28749>>>>>>>            Move "" to sDriverFile
28750>>>>>>>            Get_File_Path sFileName to sDriverFile
28751>>>>>>>            If (sDriverFile <> "") Begin
28753>>>>>>>                Get psConnectionString to sConnectionString
28754>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
28755>>>>>>>            End
28755>>>>>>>>
28755>>>>>>>        End
28755>>>>>>>>
28755>>>>>>>    End_Procedure
28756>>>>>>>
28756>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
28756>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
28758>>>>>>>        String[] sDatabaseArray
28759>>>>>>>        String sVal sServer sDriverID
28759>>>>>>>        Integer iCount iSize iPos
28759>>>>>>>        Boolean bExists
28759>>>>>>>        tSQLConnection SQLConnection
28759>>>>>>>        tSQLConnection SQLConnection
28759>>>>>>>
28759>>>>>>>        Move False to bExists
28760>>>>>>>        Get psDriverID to sDriverID
28761>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
28761>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
28763>>>>>>>            Function_Return bExists
28764>>>>>>>        End
28764>>>>>>>>
28764>>>>>>>
28764>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
28765>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
28767>>>>>>>            Function_Return False
28768>>>>>>>        End
28768>>>>>>>>
28768>>>>>>>
28768>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28769>>>>>>>        Move SQLConnection.sServer to sServer
28770>>>>>>>
28770>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
28770>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
28772>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
28773>>>>>>>        End
28773>>>>>>>>
28773>>>>>>>        Else If (sServer contains "/") Begin
28776>>>>>>>            Move (Pos("/", sServer)) to iPos
28777>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
28778>>>>>>>        End
28778>>>>>>>>
28778>>>>>>>
28778>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
28779>>>>>>>        Decrement iSize
28780>>>>>>>        For iCount from 0 to iSize
28786>>>>>>>>
28786>>>>>>>            Move sDatabaseArray[iCount] to sVal
28787>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
28789>>>>>>>                Move True to bExists
28790>>>>>>>                If (bExists = True) Begin
28792>>>>>>>                    Move iSize to iCount // We're done.
28793>>>>>>>                End
28793>>>>>>>>
28793>>>>>>>            End
28793>>>>>>>>
28793>>>>>>>        Loop
28794>>>>>>>>
28794>>>>>>>
28794>>>>>>>        Function_Return bExists
28795>>>>>>>    End_Function
28796>>>>>>>
28796>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
28796>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
28798>>>>>>>        String sDatabase sSchema sTableName sVal
28798>>>>>>>        Boolean bExists
28798>>>>>>>        String[] sTablesArray
28799>>>>>>>        Integer iSize iCount
28799>>>>>>>
28799>>>>>>>        Move False to bExists
28800>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28801>>>>>>>        Get psDatabase to sDatabase
28802>>>>>>>        Get psSchema   to sSchema
28803>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
28804>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
28805>>>>>>>        Decrement iSize
28806>>>>>>>        For iCount from 0 to iSize
28812>>>>>>>>
28812>>>>>>>            Move sTablesArray[iCount] to sVal
28813>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
28815>>>>>>>                Move True to bExists
28816>>>>>>>                Move iSize to iCount // We're done!
28817>>>>>>>            End
28817>>>>>>>>
28817>>>>>>>        Loop
28818>>>>>>>>
28818>>>>>>>
28818>>>>>>>        Function_Return bExists
28819>>>>>>>    End_Function
28820>>>>>>>
28820>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
28820>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
28822>>>>>>>        String sDatabase sSchema sVal
28822>>>>>>>        Boolean bExists
28822>>>>>>>        String[] sTablesArray
28823>>>>>>>        Integer iSize iCount
28823>>>>>>>
28823>>>>>>>        Move False to bExists
28824>>>>>>>        Get psDatabase to sDatabase
28825>>>>>>>        Get psSchema   to sSchema
28826>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
28827>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
28828>>>>>>>        Decrement iSize
28829>>>>>>>        For iCount from 0 to iSize
28835>>>>>>>>
28835>>>>>>>            Move sTablesArray[iCount] to sVal
28836>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
28838>>>>>>>                Move True to bExists
28839>>>>>>>                Move iSize to iCount // We're done!
28840>>>>>>>            End
28840>>>>>>>>
28840>>>>>>>        Loop
28841>>>>>>>>
28841>>>>>>>
28841>>>>>>>        Function_Return bExists
28842>>>>>>>    End_Function
28843>>>>>>>
28843>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
28845>>>>>>>        String sVal sTableSpelledCorrectly
28845>>>>>>>        Boolean bExists
28845>>>>>>>        String[] sTablesArray
28846>>>>>>>        Integer iSize iCount
28846>>>>>>>
28846>>>>>>>        Move False to bExists
28847>>>>>>>        Move sTableName to sTableSpelledCorrectly
28848>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
28849>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
28850>>>>>>>        Decrement iSize
28851>>>>>>>        For iCount from 0 to iSize
28857>>>>>>>>
28857>>>>>>>            Move sTablesArray[iCount] to sVal
28858>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
28860>>>>>>>                Move sVal to sTableSpelledCorrectly
28861>>>>>>>                Move iSize to iCount // We're done!
28862>>>>>>>            End
28862>>>>>>>>
28862>>>>>>>        Loop
28863>>>>>>>>
28863>>>>>>>
28863>>>>>>>        Function_Return sTableSpelledCorrectly
28864>>>>>>>    End_Function
28865>>>>>>>
28865>>>>>>>    // ToDo: This index name function needs to be finished...
28865>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
28867>>>>>>>        String sSchema sTableName sDriverID
28867>>>>>>>        Boolean bExists
28867>>>>>>>
28867>>>>>>>        Get psDriverID to sDriverID
28868>>>>>>>        Get psSchema to sSchema
28869>>>>>>>        Get UtilTableHandleToString hTable to sTableName
28870>>>>>>>
28870>>>>>>>        Function_Return bExists
28871>>>>>>>    End_Function
28872>>>>>>>
28872>>>>>>>    // Checks if a column/field name exists in a SQL table definition
28872>>>>>>>    // Returns True if it does
28872>>>>>>>    // Sample:
28872>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
28872>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
28874>>>>>>>        Integer iNumColumns iColumn
28874>>>>>>>        String sColumn sDriverID
28874>>>>>>>        String[] sColumnsArray
28875>>>>>>>        Boolean bExists bOK
28875>>>>>>>
28875>>>>>>>        Move False to bExists
28876>>>>>>>        Get AutoConnectionIDLogin to bOK
28877>>>>>>>        Get psDriverID to sDriverID
28878>>>>>>>
28878>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
28879>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
28880>>>>>>>        Decrement iNumColumns
28881>>>>>>>        For iColumn from 0 to iNumColumns
28887>>>>>>>>
28887>>>>>>>            Move sColumnsArray[iColumn] to sColumn
28888>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
28890>>>>>>>                Move True to bExists
28891>>>>>>>                Move iNumColumns to iColumn // We're out of here
28892>>>>>>>            End
28892>>>>>>>>
28892>>>>>>>        Loop
28893>>>>>>>>
28893>>>>>>>
28893>>>>>>>        Function_Return bExists
28894>>>>>>>    End_Function
28895>>>>>>>
28895>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
28897>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
28897>>>>>>>        Boolean bOpened bOK
28897>>>>>>>        String sColumnName sNativeTypeName
28897>>>>>>>
28897>>>>>>>        Get AutoConnectionIDLogin to bOK
28898>>>>>>>        Get OpenTableExclusive hTable to bOK
28899>>>>>>>        If (bOK = False) Begin
28901>>>>>>>            Function_Return False
28902>>>>>>>        End
28902>>>>>>>>
28902>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
28905>>>>>>>        If (bOpened = False) Begin
28907>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
28908>>>>>>>>
28908>>>>>>>            Function_Return False
28909>>>>>>>        End
28909>>>>>>>>
28909>>>>>>>
28909>>>>>>>        Move False to Err
28910>>>>>>>
28910>>>>>>>        Structure_Start hTable
28911>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
28914>>>>>>>
28914>>>>>>>            For iColumn from 1 to iNumColumns
28920>>>>>>>>
28920>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
28923>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
28926>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
28929>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
28932>>>>>>>
28932>>>>>>>                Case Begin
28932>>>>>>>                    Case (iDFType = DF_DATE)
28934>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
28936>>>>>>>                            // Convert datetime to date
28936>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
28939>>>>>>>                        End
28939>>>>>>>>
28939>>>>>>>                        Case Break
28940>>>>>>>                    Case (iDFType = DF_DATETIME)
28943>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
28945>>>>>>>                            // Convert datetime to datetime2
28945>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
28948>>>>>>>                        End
28948>>>>>>>>
28948>>>>>>>                        Case Break
28949>>>>>>>                    Case (iDFType = DF_ASCII)
28952>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
28954>>>>>>>                            // Convert char to varchar
28954>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
28957>>>>>>>                        End
28957>>>>>>>>
28957>>>>>>>                        Case Break
28958>>>>>>>                    Case (iDFType = DF_TEXT)
28961>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
28963>>>>>>>                            // Convert text to varchar(max)
28963>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
28966>>>>>>>                        End
28966>>>>>>>>
28966>>>>>>>                        Case Break
28967>>>>>>>                    Case (iDFType = DF_BINARY)
28970>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
28972>>>>>>>                            // Convert image to varbinary(max)
28972>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
28975>>>>>>>                        End
28975>>>>>>>>
28975>>>>>>>                        Case Break
28976>>>>>>>                Case End
28976>>>>>>>            Loop
28977>>>>>>>>
28977>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
28978>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28980>>>>>>>
28980>>>>>>>        Set Action_Text of ghoStatusPanel to ""
28981>>>>>>>        Function_Return (Err = False)
28982>>>>>>>    End_Function
28983>>>>>>>
28983>>>>>>>
28983>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
28983>>>>>>>    // the DbUpdateVersion database revision in.
28983>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
28983>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
28983>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
28985>>>>>>>        Boolean bOK bOpened
28985>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
28985>>>>>>>
28985>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
28988>>>>>>>        Get _TableNameOnly sTableName to sTableName
28989>>>>>>>        If (sTableName = "") Begin
28991>>>>>>>            Function_Return False
28992>>>>>>>        End
28992>>>>>>>>
28992>>>>>>>
28992>>>>>>>        // This just creates the table and a "dummy" column.
28992>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
28993>>>>>>>        If (bOK = False) Begin
28995>>>>>>>            Function_Return False
28996>>>>>>>        End
28996>>>>>>>>
28996>>>>>>>
28996>>>>>>>        Close hTable
28997>>>>>>>        Move False to Err
28998>>>>>>>
28998>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
28999>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
29000>>>>>>>        Move "Decimal" to sDataType
29001>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
29002>>>>>>>
29002>>>>>>>        // Adds the "sColumnName" passed to the function
29002>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
29003>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
29004>>>>>>>
29004>>>>>>>        // Now we can delete the dummy column:
29004>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
29005>>>>>>>
29005>>>>>>>        // Finally, we attach to the newly created table.
29005>>>>>>>        If (Err = False) Begin
29007>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
29008>>>>>>>        End
29008>>>>>>>>
29008>>>>>>>        Open hTable
29010>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
29013>>>>>>>
29013>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
29014>>>>>>>    End_Function
29015>>>>>>>
29015>>>>>>>    // The table must already exist in the filelist for this function to work.
29015>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
29015>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
29017>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
29017>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
29017>>>>>>>        String[] sIndexArray
29018>>>>>>>        Integer iCount iCh iSize
29018>>>>>>>
29018>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
29019>>>>>>>        Get psConnectionString to sConnectionString
29020>>>>>>>
29020>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
29021>>>>>>>        If (bANSI = False) Begin
29023>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
29024>>>>>>>        End
29024>>>>>>>>
29024>>>>>>>
29024>>>>>>>        Get psDataPathFirstPart to sDataPath
29025>>>>>>>        Get vFolderExists sDataPath to bOK
29026>>>>>>>        If (bOK = False) Begin
29028>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
29029>>>>>>>>
29029>>>>>>>            Function_Return False
29030>>>>>>>        End
29030>>>>>>>>
29030>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29031>>>>>>>
29031>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29034>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
29037>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
29038>>>>>>>        Move sLogicalName  to sPhysicalFileName
29039>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
29040>>>>>>>
29040>>>>>>>        Get IsMertechDriver sDriverID to bMertech
29041>>>>>>>        If (bMertech = True) Begin
29043>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
29043>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
29043>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
29043>>>>>>>            Function_Return (bOK = True)
29044>>>>>>>        End
29044>>>>>>>>
29044>>>>>>>
29044>>>>>>>        Get psSchema hTable to sSchemaName
29045>>>>>>>        If (sSchemaName = "") Begin
29047>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
29048>>>>>>>        End
29048>>>>>>>>
29048>>>>>>>
29048>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
29048>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
29049>>>>>>>        If (bExists = True) Begin
29051>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
29052>>>>>>>        End
29052>>>>>>>>
29052>>>>>>>
29052>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
29053>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
29054>>>>>>>
29054>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
29055>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
29060>>>>>>>            If (bUseConnectionID = True) Begin
29062>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
29069>>>>>>>            End
29069>>>>>>>>
29069>>>>>>>            Else Begin
29070>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
29077>>>>>>>            End
29077>>>>>>>>
29077>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
29082>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
29087>>>>>>>            // There seems to be a new order how these are set from DF19.
29087>>>>>>>            If (bSysFile = True) Begin
29089>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
29094>>>>>>>            End
29094>>>>>>>>
29094>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
29099>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
29104>>>>>>>            If (bSysFile = True) Begin
29106>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
29111>>>>>>>            End
29111>>>>>>>>
29111>>>>>>>
29111>>>>>>>            If (bSysFile = False) Begin
29113>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
29114>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
29115>>>>>>>                If (iSize > 0) Begin
29117>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
29120>>>>>>>                    Writeln channel iCh // Just an empty line
29122>>>>>>>                End
29122>>>>>>>>
29122>>>>>>>                Decrement iSize
29123>>>>>>>                For iCount from 0 to iSize
29129>>>>>>>>
29129>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
29132>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
29135>>>>>>>                    Writeln channel iCh
29137>>>>>>>                Loop
29138>>>>>>>>
29138>>>>>>>            End
29138>>>>>>>>
29138>>>>>>>        Send Seq_Close_Channel iCh
29139>>>>>>>
29139>>>>>>>        // Wait a sec for Windows to finish writing the file:
29139>>>>>>>        Sleep 1
29140>>>>>>>
29140>>>>>>>        Function_Return (bOK = True)
29141>>>>>>>    End_Function
29142>>>>>>>
29142>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
29142>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
29142>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
29142>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
29142>>>>>>>    // column types.
29142>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
29144>>>>>>>        Handle hDatabase
29144>>>>>>>        Integer iDriver iServers iCount
29144>>>>>>>        String sValue
29144>>>>>>>
29144>>>>>>>        If (sServer = "") Begin
29146>>>>>>>            Function_Return 0
29147>>>>>>>        End
29147>>>>>>>>
29147>>>>>>>
29147>>>>>>>        Get DriverIndex sDriverID to iDriver
29148>>>>>>>        If (iDriver = 0) Begin
29150>>>>>>>            Function_Return 0
29151>>>>>>>        End
29151>>>>>>>>
29151>>>>>>>
29151>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
29154>>>>>>>        For iCount from 1 to iServers
29160>>>>>>>>
29160>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
29163>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
29165>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
29168>>>>>>>            End
29168>>>>>>>>
29168>>>>>>>        Loop
29169>>>>>>>>
29169>>>>>>>
29169>>>>>>>        Function_Return hDatabase
29170>>>>>>>    End_Function
29171>>>>>>>
29171>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
29171>>>>>>>//        String sRootName
29171>>>>>>>//        Boolean bOK
29171>>>>>>>//
29171>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29171>>>>>>>//        Move (sRootName contains sDriverID) to bOK
29171>>>>>>>//
29171>>>>>>>//        Function_Return bOK
29171>>>>>>>//    End_Function
29171>>>>>>>
29171>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
29171>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
29171>>>>>>>//        Integer iDbType
29171>>>>>>>//        Boolean bOK
29171>>>>>>>//
29171>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
29171>>>>>>>//        If (bOK = True) Begin
29171>>>>>>>//            Function_Return False
29171>>>>>>>//        End
29171>>>>>>>//
29171>>>>>>>//        Get psDriverID to sDriverID
29171>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29171>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
29171>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
29171>>>>>>>//
29171>>>>>>>//        Get psDriverID to sDriverID
29171>>>>>>>//        Get piDbType   to iDbType
29171>>>>>>>//        Get psSchema   to sSchema
29171>>>>>>>//        If (sSchema = "") Begin
29171>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
29171>>>>>>>//        End
29171>>>>>>>//
29171>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
29171>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
29171>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
29171>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
29171>>>>>>>//            End
29171>>>>>>>//            Else Begin
29171>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
29171>>>>>>>//            End
29171>>>>>>>//        End
29171>>>>>>>//
29171>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29171>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
29171>>>>>>>//
29171>>>>>>>//        Function_Return True
29171>>>>>>>//    End_Function
29171>>>>>>>
29171>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
29171>>>>>>>    // from the passed filelist.
29171>>>>>>>    // Returns the number of tables affected.
29171>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
29173>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
29173>>>>>>>        Integer iRetval
29173>>>>>>>        Handle hTable
29173>>>>>>>
29173>>>>>>>        // We first save the current filelist as the passed filelist name
29173>>>>>>>        // may come from another workspace, to restore it when we're ready.
29173>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
29176>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
29179>>>>>>>        Move 0 to hTable
29180>>>>>>>        Move 0 to iRetval
29181>>>>>>>
29181>>>>>>>        Repeat
29181>>>>>>>>
29181>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
29184>>>>>>>            If (hTable <> 0) Begin
29186>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29189>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
29192>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
29195>>>>>>>                Move (Uppercase(sRootName)) to sVal
29196>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
29198>>>>>>>                    // Prefixes:
29198>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
29199>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
29200>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
29201>>>>>>>                    // Suffixes:
29201>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
29202>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
29203>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
29204>>>>>>>
29204>>>>>>>                    // Change Filelist entry:
29204>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
29207>>>>>>>
29207>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
29208>>>>>>>                    If (sVal contains "dbo.") Begin
29210>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
29211>>>>>>>
29211>>>>>>>                        // Change Filelist entry:
29211>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
29214>>>>>>>                    End
29214>>>>>>>>
29214>>>>>>>                    Increment iRetval
29215>>>>>>>                End
29215>>>>>>>>
29215>>>>>>>            End
29215>>>>>>>>
29215>>>>>>>        Until (hTable = 0)
29217>>>>>>>
29217>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
29220>>>>>>>
29220>>>>>>>        Function_Return iRetval
29221>>>>>>>    End_Function
29222>>>>>>>
29222>>>>>>>    // To open all Sql based tables in Filelist.cfg
29222>>>>>>>    Procedure SqlUtilOpenAllTables
29224>>>>>>>        Handle hTable
29224>>>>>>>        String sRoot sDriverID
29224>>>>>>>        Boolean bOK
29224>>>>>>>
29224>>>>>>>        Move 0 to hTable
29225>>>>>>>        Move "" to sDriverID
29226>>>>>>>        Get AutoConnectionIDLogin to bOK
29227>>>>>>>
29227>>>>>>>        Repeat
29227>>>>>>>>
29227>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
29230>>>>>>>            If (hTable > 0) Begin
29232>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
29235>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
29237>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
29240>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
29242>>>>>>>                        Open hTable
29244>>>>>>>                    End
29244>>>>>>>>
29244>>>>>>>                End
29244>>>>>>>>
29244>>>>>>>            End
29244>>>>>>>>
29244>>>>>>>
29244>>>>>>>        Until (hTable = 0)
29246>>>>>>>    End_Procedure
29247>>>>>>>
29247>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
29247>>>>>>>//        String sRetval sDriverID
29247>>>>>>>//        String sTableName
29247>>>>>>>//        Integer iDbType iIndex
29247>>>>>>>//        Boolean bOK
29247>>>>>>>//
29247>>>>>>>//        Get psDriverID to sDriverID
29247>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
29247>>>>>>>//        If (hTable = 0 or bOK = False) Begin
29247>>>>>>>//            Function_Return ""
29247>>>>>>>//        End
29247>>>>>>>//
29247>>>>>>>//        Move False to Err
29247>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
29247>>>>>>>//        Get piDbType to iDbType
29247>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
29247>>>>>>>//        If (iIndex = -1) Begin
29247>>>>>>>//            Function_Return ""
29247>>>>>>>//        End
29247>>>>>>>//
29247>>>>>>>//        Function_Return sRetval
29247>>>>>>>//    End_Function
29247>>>>>>>
29247>>>>>>>    // Checks if the passed Table;
29247>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
29247>>>>>>>    // 2) It has an .int file.
29247>>>>>>>    // If both is True it should already be connected to SQL
29247>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
29249>>>>>>>        Boolean bExists bRootName
29249>>>>>>>        String sRootName sDataPath
29249>>>>>>>
29249>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29252>>>>>>>        Move (sRootName contains sDriverID) to bRootName
29253>>>>>>>
29253>>>>>>>        Get psDataPathFirstPart to sDataPath
29254>>>>>>>        Get vFolderExists sDataPath to bExists
29255>>>>>>>        If (bExists = False) Begin
29257>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
29257>>>>>>>            Function_Return False
29258>>>>>>>        End
29258>>>>>>>>
29258>>>>>>>
29258>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29259>>>>>>>        Get _TableNameOnly sRootName to sRootName
29260>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
29261>>>>>>>
29261>>>>>>>        Function_Return (bRootName = True and bExists = True)
29262>>>>>>>    End_Function
29263>>>>>>>
29263>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
29265>>>>>>>        Boolean bViewTableType bOpen bOK
29265>>>>>>>        Integer iTableCount iNumTables
29265>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
29265>>>>>>>        Handle hoCliHandler
29265>>>>>>>        tSQLConnection SQLConnection
29265>>>>>>>        tSQLConnection SQLConnection
29265>>>>>>>
29265>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
29268>>>>>>>        If (bOpen = False) Begin
29270>>>>>>>            Get AutoConnectionIDLogin to bOK
29271>>>>>>>            Open hTable
29273>>>>>>>        End
29273>>>>>>>>
29273>>>>>>>
29273>>>>>>>        Get pSQLConnection to SQLConnection
29274>>>>>>>        Get phoCLIHandler to hoCliHandler
29275>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
29276>>>>>>>
29276>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
29279>>>>>>>        Get _TableNameOnly sTableName to sTableName
29280>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
29283>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
29284>>>>>>>
29284>>>>>>>        For iTableCount from 1 to iNumTables
29290>>>>>>>>
29290>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
29291>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
29292>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
29294>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
29295>>>>>>>                Move iNumTables to iTableCount // We're done.
29296>>>>>>>            End
29296>>>>>>>>
29296>>>>>>>        Loop
29297>>>>>>>>
29297>>>>>>>
29297>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
29298>>>>>>>        If (bOpen = False) Begin
29300>>>>>>>            Close hTable
29301>>>>>>>        End
29301>>>>>>>>
29301>>>>>>>
29301>>>>>>>        Function_Return bViewTableType
29302>>>>>>>    End_Function
29303>>>>>>>
29303>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
29303>>>>>>>    //
29303>>>>>>>    // SQL utility function that returns a database type (string) constant
29303>>>>>>>    // corresponding to the passed iDbType.
29303>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
29305>>>>>>>        String sRetval
29305>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
29306>>>>>>>        Function_Return sRetval
29307>>>>>>>    End_Function
29308>>>>>>>
29308>>>>>>>    // SQL utility function that returns a database type constant (integer)
29308>>>>>>>    // corresponding to the passed sDbType string constant.
29308>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
29310>>>>>>>        Integer iRetval
29310>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
29311>>>>>>>        Function_Return iRetval
29312>>>>>>>    End_Function
29313>>>>>>>
29313>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
29313>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
29313>>>>>>>    // the SQL Connection program's grid.
29313>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
29315>>>>>>>        String sRetval
29315>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
29316>>>>>>>        Function_Return sRetval
29317>>>>>>>    End_Function
29318>>>>>>>
29318>>>>>>>    // Pass a driver name as a string and the function will return
29318>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
29318>>>>>>>    // quite work and always returns "MS SQL Server"
29318>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
29320>>>>>>>        Integer iRetval
29320>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
29321>>>>>>>        Function_Return iRetval
29322>>>>>>>    End_Function
29323>>>>>>>
29323>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
29323>>>>>>>    // that "fits" in the max allowed length for table names.
29323>>>>>>>    // Max number of characters allowed for table names;
29323>>>>>>>    // IBM DB2      = 128
29323>>>>>>>    // MS-SQL       = 128
29323>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
29323>>>>>>>    // MySQL        = 64
29323>>>>>>>    // PostgreSQL   = 64
29323>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
29325>>>>>>>        String sGUIDName
29325>>>>>>>        Integer iDbType iLength
29325>>>>>>>
29325>>>>>>>        Get piDbType to iDbType
29326>>>>>>>        Move (RandomHexUUID()) to sGUIDName
29327>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
29328>>>>>>>        Move (Length(sGUIDName)) to iLength
29329>>>>>>>
29329>>>>>>>        Case Begin
29329>>>>>>>            Case (iDbType = EN_DbTypeDB2)
29331>>>>>>>            If (iLength > 128) Begin
29333>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
29334>>>>>>>            End
29334>>>>>>>>
29334>>>>>>>            Case Break
29335>>>>>>>
29335>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
29338>>>>>>>            If (iLength > 128) Begin
29340>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
29341>>>>>>>            End
29341>>>>>>>>
29341>>>>>>>            Case Break
29342>>>>>>>
29342>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
29345>>>>>>>            If (iLength > 128) Begin
29347>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
29348>>>>>>>            End
29348>>>>>>>>
29348>>>>>>>            Case Break
29349>>>>>>>
29349>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
29352>>>>>>>            If (iLength > 64) Begin
29354>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
29355>>>>>>>            End
29355>>>>>>>>
29355>>>>>>>            Case Break
29356>>>>>>>
29356>>>>>>>            Case (iDbType = EN_DbTypePostgre)
29359>>>>>>>            If (iLength > 64) Begin
29361>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
29362>>>>>>>            End
29362>>>>>>>>
29362>>>>>>>        Case End
29362>>>>>>>
29362>>>>>>>        Function_Return sGUIDName
29363>>>>>>>    End_Function
29364>>>>>>>
29364>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
29364>>>>>>>    // Pass the memory resource file reference and the filename to be created,
29364>>>>>>>    // including full path.
29364>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
29366>>>>>>>        String sText
29366>>>>>>>        Integer iCh iSize iArgSize
29366>>>>>>>
29366>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
29367>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
29368>>>>>>>        Get_Channel_Size iCh to iSize
29369>>>>>>>        Read_Block channel iCh sText iSize
29371>>>>>>>        Send Seq_Close_Channel iCh
29372>>>>>>>
29372>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
29373>>>>>>>            Write channel iCh sText
29375>>>>>>>        Send Seq_Close_Channel iCh
29376>>>>>>>
29376>>>>>>>        // Wait for file to be written to disk.
29376>>>>>>>        Sleep 2
29377>>>>>>>    End_Procedure
29378>>>>>>>
29378>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
29380>>>>>>>        String sNotNull sRetval sDefaultValue
29380>>>>>>>        Boolean bOK
29380>>>>>>>
29380>>>>>>>        Get IsSQLDriver sDriverID to bOK
29381>>>>>>>        If (bOK = False) Begin
29383>>>>>>>            Function_Return ""
29384>>>>>>>        End
29384>>>>>>>>
29384>>>>>>>
29384>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
29385>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
29386>>>>>>>
29386>>>>>>>        Case Begin
29386>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
29388>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
29389>>>>>>>                Case Break
29390>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
29393>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
29394>>>>>>>                Case Break
29395>>>>>>>            Case (iDbType = EN_dbTypePostgre)
29398>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
29399>>>>>>>                Case Break
29400>>>>>>>            Case (iDbType = EN_dbTypeDB2)
29403>>>>>>>                Move (String(sNotNull))                                     to sRetval
29404>>>>>>>                Case Break
29405>>>>>>>
29405>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
29405>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
29405>>>>>>>            Case (iDbType = EN_dbTypeOracle)
29408>>>>>>>                Move  ""                                                    to sRetval
29409>>>>>>>                Case Break
29410>>>>>>>
29410>>>>>>>            Case Else
29410>>>>>>>                Move  ""                                                    to sRetval
29411>>>>>>>        Case End
29411>>>>>>>
29411>>>>>>>        Function_Return sRetval
29412>>>>>>>    End_Function
29413>>>>>>>
29413>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
29415>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
29415>>>>>>>        Boolean bOpened bOK bMertech
29415>>>>>>>
29415>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
29415>>>>>>>        // which makes the program unable to run because they can't be opened.
29415>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
29415>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
29415>>>>>>>        // proper .int files for the two tables.
29415>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
29417>>>>>>>            Function_Return True
29418>>>>>>>        End
29418>>>>>>>>
29418>>>>>>>
29418>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29421>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
29422>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
29423>>>>>>>        Move CS_ANSI_Txt to sNewFormat
29424>>>>>>>        Get AutoConnectionIDLogin to bOK
29425>>>>>>>
29425>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
29425>>>>>>>        Sleep 1
29426>>>>>>>
29426>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
29429>>>>>>>        If (bOpened = False) Begin
29431>>>>>>>            Open hTable
29433>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
29436>>>>>>>        End
29436>>>>>>>>
29436>>>>>>>        If (bOpened = False) Begin
29438>>>>>>>            Function_Return False
29439>>>>>>>        End
29439>>>>>>>>
29439>>>>>>>
29439>>>>>>>        Get psDriverID to sDriverID
29440>>>>>>>        Get IsMertechDriver sDriverID to bMertech
29441>>>>>>>        If (bMertech = True) Begin
29443>>>>>>>            Get psDataPathFirstPart to sDataPath
29444>>>>>>>            Get vFolderExists sDataPath to bOK
29445>>>>>>>            If (bOK = False) Begin
29447>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
29448>>>>>>>>
29448>>>>>>>                Function_Return False
29449>>>>>>>            End
29449>>>>>>>>
29449>>>>>>>            Get vFolderFormat sDataPath to sDataPath
29450>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29453>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
29454>>>>>>>            Move sDatabaseName to sPhysicalFileName
29455>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
29456>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
29457>>>>>>>            Function_Return (bOK = True)
29458>>>>>>>        End
29458>>>>>>>>
29458>>>>>>>
29458>>>>>>>        Move False to Err
29459>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29462>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
29463>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
29463>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
29463>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
29464>>>>>>>
29464>>>>>>>        Move False to Err
29465>>>>>>>
29465>>>>>>>        If (hTable > 0) Begin
29467>>>>>>>            Structure_Start hTable
29468>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
29471>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29474>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
29476>>>>>>>        End
29476>>>>>>>>
29476>>>>>>>        Else Begin
29477>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
29480>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29483>>>>>>>        End
29483>>>>>>>>
29483>>>>>>>        Function_Return (Err = False)
29484>>>>>>>    End_Function
29485>>>>>>>
29485>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
29487>>>>>>>        String[] sReturnArray
29488>>>>>>>        String sValue // sUserID sPassword
29488>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
29488>>>>>>>        Integer iFetchResult iRetval
29488>>>>>>>        tSQLConnection SQLConnection
29488>>>>>>>        tSQLConnection SQLConnection
29488>>>>>>>
29488>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
29489>>>>>>>        If (hoSQLHandler <> 0) Begin
29491>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
29492>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
29493>>>>>>>            If (hoSQLConnect <> 0) Begin
29495>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
29496>>>>>>>                If (hStmt <> 0) Begin
29498>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
29499>>>>>>>                    If (sArgument <> "") Begin
29501>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
29502>>>>>>>                    End
29502>>>>>>>>
29502>>>>>>>                    Send SQLCall of hStmt
29503>>>>>>>
29503>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
29504>>>>>>>                    If (iRetval = 0) Begin
29506>>>>>>>                        Repeat
29506>>>>>>>>
29506>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
29507>>>>>>>                            If (iFetchResult <> 0) Begin
29509>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
29510>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
29511>>>>>>>                            End
29511>>>>>>>>
29511>>>>>>>                        Until (iFetchResult = 0)
29513>>>>>>>                        Send SQLClose of hStmt
29514>>>>>>>                    End
29514>>>>>>>>
29514>>>>>>>                End
29514>>>>>>>>
29514>>>>>>>                Send SQLDisconnect of hoSQLConnect
29515>>>>>>>            End
29515>>>>>>>>
29515>>>>>>>        End
29515>>>>>>>>
29515>>>>>>>
29515>>>>>>>        Function_Return sReturnArray
29516>>>>>>>    End_Function
29517>>>>>>>
29517>>>>>>>    // * Dummy function for the Studio's Code Explorer *
29517>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
29519>>>>>>>        Function_Return False
29520>>>>>>>    End_Function
29521>>>>>>>
29521>>>>>>>    // Enumerate SQL Servers.
29521>>>>>>>    // Pass a driver id. Returns a string array.
29521>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
29521>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
29521>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
29523>>>>>>>        String[] sReturnArray
29524>>>>>>>        Handle hoSQLHandler
29524>>>>>>>        String sServer
29524>>>>>>>        Integer iCount iNumItems iDataSourceType
29524>>>>>>>
29524>>>>>>>        If (num_arguments > 1) Begin
29526>>>>>>>            Move iDatSrcType to iDataSourceType
29527>>>>>>>        End
29527>>>>>>>>
29527>>>>>>>
29527>>>>>>>        Case Begin
29527>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29529>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
29530>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
29531>>>>>>>                For iCount from 0 to (iNumItems - 1)
29537>>>>>>>>
29537>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
29538>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
29539>>>>>>>                Loop
29540>>>>>>>>
29540>>>>>>>                Case Break
29541>>>>>>>
29541>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29544>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
29545>>>>>>>                Send SeedDataSources of hoSQLHandler
29546>>>>>>>                Move 0 to iCount
29547>>>>>>>                Repeat
29547>>>>>>>>
29547>>>>>>>                    Get DataSources of hoSQLHandler to sServer
29548>>>>>>>                    If (sServer <> "") Begin
29550>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
29551>>>>>>>                        Move sServer to sReturnArray[iCount]
29552>>>>>>>                    End
29552>>>>>>>>
29552>>>>>>>                    Increment iCount
29553>>>>>>>                Until (sServer = "")
29555>>>>>>>                Case Break
29556>>>>>>>
29556>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29559>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
29560>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
29561>>>>>>>                Move 0 to iCount
29562>>>>>>>                Repeat
29562>>>>>>>>
29562>>>>>>>                    Get DataSources of hoSQLHandler to sServer
29563>>>>>>>                    If (sServer <> "") Begin
29565>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
29566>>>>>>>                        Move sServer to sReturnArray[iCount]
29567>>>>>>>                    End
29567>>>>>>>>
29567>>>>>>>                    Increment iCount
29568>>>>>>>                Until (sServer = "")
29570>>>>>>>                Case Break
29571>>>>>>>
29571>>>>>>>            Case (sDriverID = SQLFLEX)
29574>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
29575>>>>>>>                Case Break
29576>>>>>>>
29576>>>>>>>            Case (sDriverID = ORAFLEX)
29579>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
29580>>>>>>>                Case Break
29581>>>>>>>
29581>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
29581>>>>>>>            Case (sDriverID = MDSPgSQL)
29584>>>>>>>                Move "localhost" to sReturnArray[0]
29585>>>>>>>                Case Break
29586>>>>>>>
29586>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
29586>>>>>>>            Case (sDriverID = MDSMySQL)
29589>>>>>>>                Move "localhost" to sReturnArray[0]
29590>>>>>>>                Case Break
29591>>>>>>>
29591>>>>>>>            Case Else
29591>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
29592>>>>>>>>
29592>>>>>>>        Case End
29592>>>>>>>
29592>>>>>>>        Function_Return sReturnArray
29593>>>>>>>    End_Function
29594>>>>>>>
29594>>>>>>>    // Returns all databases as a string array for the passed driver id.
29594>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
29596>>>>>>>        String[] sReturnArray
29597>>>>>>>        String sServer sVal
29597>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
29597>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
29598>>>>>>>        tSQLConnection SQLConnection
29598>>>>>>>        tSQLConnection SQLConnection
29598>>>>>>>        Boolean bOK
29598>>>>>>>        Integer iCount iSize
29598>>>>>>>
29598>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29599>>>>>>>        If (bOK = False) Begin
29601>>>>>>>            Function_Return sReturnArray
29602>>>>>>>        End
29602>>>>>>>>
29602>>>>>>>
29602>>>>>>>        Case Begin
29602>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29604>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
29605>>>>>>>                Case Break
29606>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29609>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
29610>>>>>>>                Case Break
29611>>>>>>>
29611>>>>>>>            // This is needed to be able to check if a database exists or not.
29611>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29614>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
29615>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
29617>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
29619>>>>>>>                        // If a FILEDSN: (can only be one database name)
29619>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
29620>>>>>>>                    End
29620>>>>>>>>
29620>>>>>>>                    Else Begin
29621>>>>>>>                        // Else the DSN's were read from the registry.
29621>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
29622>>>>>>>                        Move SQLConnection.sServer to sServer
29623>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
29624>>>>>>>                        Decrement iSize
29625>>>>>>>                        for iCount from 0 to iSize
29631>>>>>>>>
29631>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
29632>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
29634>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
29635>>>>>>>                                Move iSize to iCount // We're done.
29636>>>>>>>                            End
29636>>>>>>>>
29636>>>>>>>                        Loop
29637>>>>>>>>
29637>>>>>>>                    End
29637>>>>>>>>
29637>>>>>>>                End
29637>>>>>>>>
29637>>>>>>>                Case Break
29638>>>>>>>
29638>>>>>>>            Case (sDriverID = SQLFLEX)
29641>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
29642>>>>>>>                Case Break
29643>>>>>>>
29643>>>>>>>            Case (sDriverID = MDSPgSQL)
29646>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
29647>>>>>>>                Case Break
29648>>>>>>>
29648>>>>>>>            Case (sDriverID = MDSMySQL)
29651>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
29652>>>>>>>                Case Break
29653>>>>>>>
29653>>>>>>>            Case (sDriverID = ORAFLEX)
29656>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
29657>>>>>>>                Case Break
29658>>>>>>>
29658>>>>>>>            Case Else
29658>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
29658>>>>>>>        Case End
29658>>>>>>>
29658>>>>>>>        Function_Return sReturnArray
29659>>>>>>>    End_Function
29660>>>>>>>
29660>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
29660>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
29662>>>>>>>        String[] sReturnArray
29663>>>>>>>        Boolean bOK
29663>>>>>>>
29663>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29664>>>>>>>        If (bOK = False) Begin
29666>>>>>>>            Function_Return sReturnArray
29667>>>>>>>        End
29667>>>>>>>>
29667>>>>>>>
29667>>>>>>>        Case Begin
29667>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29669>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
29670>>>>>>>                Case Break
29671>>>>>>>
29671>>>>>>>            Case (sDriverID = MDSPgSQL)
29674>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
29675>>>>>>>                Case Break
29676>>>>>>>
29676>>>>>>>            Case (sDriverID = ORAFLEX)
29679>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
29680>>>>>>>                Case Break
29681>>>>>>>
29681>>>>>>>            Case Else
29681>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
29682>>>>>>>>
29682>>>>>>>                Case Break
29683>>>>>>>        Case End
29683>>>>>>>
29683>>>>>>>        Function_Return sReturnArray
29684>>>>>>>    End_Function
29685>>>>>>>
29685>>>>>>>    // Returns all schemas as a string array for the passed driver id.
29685>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
29687>>>>>>>        String[] sReturnArray
29688>>>>>>>        Boolean bOK
29688>>>>>>>
29688>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29689>>>>>>>        If (bOK = False) Begin
29691>>>>>>>            Function_Return sReturnArray
29692>>>>>>>        End
29692>>>>>>>>
29692>>>>>>>
29692>>>>>>>        Case Begin
29692>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29694>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
29695>>>>>>>                Case Break
29696>>>>>>>
29696>>>>>>>            Case (sDriverID = MDSPgSQL)
29699>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
29700>>>>>>>                Case Break
29701>>>>>>>
29701>>>>>>>            Case (sDriverID = ORAFLEX)
29704>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
29705>>>>>>>                Case Break
29706>>>>>>>
29706>>>>>>>            Case Else
29706>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
29707>>>>>>>>
29707>>>>>>>                Case Break
29708>>>>>>>        Case End
29708>>>>>>>
29708>>>>>>>        Function_Return sReturnArray
29709>>>>>>>    End_Function
29710>>>>>>>
29710>>>>>>>    // Returns a string array with all tables for the current database.
29710>>>>>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
29712>>>>>>>        String[] sReturnArray sArray
29714>>>>>>>        String sConnectionString sSelect
29714>>>>>>>        Integer iSize iCount iDbType
29714>>>>>>>        Boolean bOK
29714>>>>>>>
29714>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
29716>>>>>>>            Function_Return sArray
29717>>>>>>>        End
29717>>>>>>>>
29717>>>>>>>
29717>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29718>>>>>>>        If (bOK = False) Begin
29720>>>>>>>            Function_Return sReturnArray
29721>>>>>>>        End
29721>>>>>>>>
29721>>>>>>>        If (sSchema = "") Begin
29723>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
29724>>>>>>>        End
29724>>>>>>>>
29724>>>>>>>
29724>>>>>>>        Get psConnectionString to sConnectionString
29725>>>>>>>
29725>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
29725>>>>>>>        // the dbType.
29725>>>>>>>        Get piDbType to iDbType
29726>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
29728>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
29730>>>>>>>                Move MDSMySQL to sDriverID
29731>>>>>>>            End
29731>>>>>>>>
29731>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
29733>>>>>>>                Move MSSQLDRV_ID to sDriverID
29734>>>>>>>            End
29734>>>>>>>>
29734>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
29736>>>>>>>                Move DB2_DRV_ID to sDriverID
29737>>>>>>>            End
29737>>>>>>>>
29737>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
29739>>>>>>>                Move MDSPgSQL to sDriverID
29740>>>>>>>            End
29740>>>>>>>>
29740>>>>>>>        End
29740>>>>>>>>
29740>>>>>>>
29740>>>>>>>        Case Begin
29740>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29742>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
29743>>>>>>>                Case Break
29744>>>>>>>
29744>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29747>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
29748>>>>>>>                Case Break
29749>>>>>>>
29749>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29752>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
29753>>>>>>>                Case Break
29754>>>>>>>
29754>>>>>>>            Case (sDriverID = SQLFLEX)
29757>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
29758>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
29759>>>>>>>                Case Break
29760>>>>>>>
29760>>>>>>>            Case (sDriverID = MDSMySQL)
29763>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
29764>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
29765>>>>>>>                Case Break
29766>>>>>>>
29766>>>>>>>            Case (sDriverID = MDSPgSQL)
29769>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
29770>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
29771>>>>>>>                Case Break
29772>>>>>>>
29772>>>>>>>            Case (sDriverID = ORAFLEX)
29775>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
29776>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
29777>>>>>>>                Move (SizeOfArray(sArray)) to iSize
29778>>>>>>>                Decrement iSize
29779>>>>>>>                For iCount from 0 to iSize
29785>>>>>>>>
29785>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
29787>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
29788>>>>>>>                    End
29788>>>>>>>>
29788>>>>>>>                Loop
29789>>>>>>>>
29789>>>>>>>                Case Break
29790>>>>>>>
29790>>>>>>>            Case Else
29790>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
29791>>>>>>>>
29791>>>>>>>                Case Break
29792>>>>>>>        Case End
29792>>>>>>>
29792>>>>>>>        Function_Return sReturnArray
29793>>>>>>>    End_Function
29794>>>>>>>
29794>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
29794>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
29796>>>>>>>        String[] sReturnArray
29797>>>>>>>        String sConnectionString sSelect sSchema
29797>>>>>>>        Boolean bOK
29797>>>>>>>        Integer iDbType
29797>>>>>>>
29797>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29798>>>>>>>        If (bOK = False) Begin
29800>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
29801>>>>>>>>
29801>>>>>>>            Function_Return sReturnArray
29802>>>>>>>        End
29802>>>>>>>>
29802>>>>>>>
29802>>>>>>>        Get psConnectionString to sConnectionString
29803>>>>>>>        Get psSchema to sSchema
29804>>>>>>>
29804>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
29804>>>>>>>        // the dbType.
29804>>>>>>>        Get piDbType to iDbType
29805>>>>>>>
29805>>>>>>>        Case Begin
29805>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
29807>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
29809>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
29810>>>>>>>                End
29810>>>>>>>>
29810>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
29812>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
29813>>>>>>>                End
29813>>>>>>>>
29813>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
29815>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
29816>>>>>>>                End
29816>>>>>>>>
29816>>>>>>>
29816>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
29817>>>>>>>                Case Break
29818>>>>>>>
29818>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29821>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
29822>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
29823>>>>>>>                Case Break
29824>>>>>>>
29824>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29827>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
29828>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
29829>>>>>>>                Case Break
29830>>>>>>>
29830>>>>>>>            Case (sDriverID = SQLFLEX)
29833>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
29834>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
29835>>>>>>>                Case Break
29836>>>>>>>
29836>>>>>>>            Case (sDriverID = MDSMySQL)
29839>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
29840>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
29841>>>>>>>                Case Break
29842>>>>>>>
29842>>>>>>>            Case (sDriverID = MDSPgSQL)
29845>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
29846>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
29847>>>>>>>                Case Break
29848>>>>>>>
29848>>>>>>>            Case (sDriverID = ORAFLEX)
29851>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
29852>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
29853>>>>>>>                Case Break
29854>>>>>>>
29854>>>>>>>            Case Else
29854>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
29855>>>>>>>>
29855>>>>>>>                Case Break
29856>>>>>>>        Case End
29856>>>>>>>
29856>>>>>>>        Function_Return sReturnArray
29857>>>>>>>    End_Function
29858>>>>>>>
29858>>>>>>>
29858>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
29858>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
29860>>>>>>>        String[] sReturnArray sReturnArray2
29862>>>>>>>        String sConnectionString sSelect sSchema
29862>>>>>>>        Boolean bOK
29862>>>>>>>        Integer iCount iSize
29862>>>>>>>
29862>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29863>>>>>>>        If (bOK = False) Begin
29865>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
29866>>>>>>>>
29866>>>>>>>            Function_Return sReturnArray
29867>>>>>>>        End
29867>>>>>>>>
29867>>>>>>>
29867>>>>>>>        Get psConnectionString to sConnectionString
29868>>>>>>>        Get psSchema to sSchema
29869>>>>>>>
29869>>>>>>>        Case Begin
29869>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29871>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
29872>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
29873>>>>>>>                Case Break
29874>>>>>>>
29874>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29877>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29878>>>>>>>>
29878>>>>>>>//                Move () to sSelect
29878>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
29878>>>>>>>                Case Break
29879>>>>>>>
29879>>>>>>>            Case (sDriverID = SQLFLEX)
29882>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29883>>>>>>>>
29883>>>>>>>//                Move () to sSelect
29883>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
29883>>>>>>>                Case Break
29884>>>>>>>
29884>>>>>>>            Case (sDriverID = MDSMySQL)
29887>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29888>>>>>>>>
29888>>>>>>>//                Move () to sSelect
29888>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
29888>>>>>>>                Case Break
29889>>>>>>>
29889>>>>>>>            Case (sDriverID = MDSPgSQL)
29892>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29893>>>>>>>>
29893>>>>>>>//                Move () to sSelect
29893>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
29893>>>>>>>                Case Break
29894>>>>>>>
29894>>>>>>>            Case (sDriverID = ORAFLEX)
29897>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29898>>>>>>>>
29898>>>>>>>//                Move () to sSelect
29898>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
29898>>>>>>>                Case Break
29899>>>>>>>
29899>>>>>>>            Case Else
29899>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
29900>>>>>>>>
29900>>>>>>>                Case Break
29901>>>>>>>        Case End
29901>>>>>>>
29901>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
29902>>>>>>>        Decrement iSize
29903>>>>>>>        For iCount from 0 to iSize
29909>>>>>>>>
29909>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
29911>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
29912>>>>>>>            End
29912>>>>>>>>
29912>>>>>>>        Loop
29913>>>>>>>>
29913>>>>>>>
29913>>>>>>>        Function_Return sReturnArray2
29914>>>>>>>    End_Function
29915>>>>>>>
29915>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
29915>>>>>>>    // The format of the array is "TableName.FieldName"
29915>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
29917>>>>>>>        String[] sFileNameArray sFieldNameArray
29919>>>>>>>        tSQLRelation[] sRelationsArray
29919>>>>>>>        tSQLRelation[] sRelationsArray
29920>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
29920>>>>>>>        Boolean bOK
29920>>>>>>>        Integer iCount iSize iLength
29920>>>>>>>
29920>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
29921>>>>>>>        If (bOK = False) Begin
29923>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
29924>>>>>>>>
29924>>>>>>>            Function_Return sRelationsArray
29925>>>>>>>        End
29925>>>>>>>>
29925>>>>>>>
29925>>>>>>>        Get psConnectionString to sConnectionString
29926>>>>>>>        Get psSchema to sSchema
29927>>>>>>>
29927>>>>>>>        Case Begin
29927>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29929>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
29930>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
29931>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
29932>>>>>>>                Case Break
29933>>>>>>>
29933>>>>>>>            Case (sDriverID = DB2_DRV_ID)
29936>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29937>>>>>>>>
29937>>>>>>>//                Move () to sSelect
29937>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
29937>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
29937>>>>>>>                Case Break
29938>>>>>>>
29938>>>>>>>            Case (sDriverID = SQLFLEX)
29941>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29942>>>>>>>>
29942>>>>>>>//                Move () to sSelect
29942>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
29942>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
29942>>>>>>>                Case Break
29943>>>>>>>
29943>>>>>>>            Case (sDriverID = MDSMySQL)
29946>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29947>>>>>>>>
29947>>>>>>>//                Move () to sSelect
29947>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
29947>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
29947>>>>>>>                Case Break
29948>>>>>>>
29948>>>>>>>            Case (sDriverID = MDSPgSQL)
29951>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29952>>>>>>>>
29952>>>>>>>//                Move () to sSelect
29952>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
29952>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
29952>>>>>>>                Case Break
29953>>>>>>>
29953>>>>>>>            Case (sDriverID = ORAFLEX)
29956>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
29957>>>>>>>>
29957>>>>>>>//                Move () to sSelect
29957>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
29957>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
29957>>>>>>>                Case Break
29958>>>>>>>
29958>>>>>>>            Case Else
29958>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
29959>>>>>>>>
29959>>>>>>>                Case Break
29960>>>>>>>        Case End
29960>>>>>>>
29960>>>>>>>        Move (Length(sTableName)) to iLength
29961>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
29962>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
29963>>>>>>>        Decrement iSize
29964>>>>>>>        For iCount from 0 to iSize
29970>>>>>>>>
29970>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
29972>>>>>>>                Move sFileNameArray[iCount]         to sFileName
29973>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
29974>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
29975>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
29976>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
29977>>>>>>>            End
29977>>>>>>>>
29977>>>>>>>        Loop
29978>>>>>>>>
29978>>>>>>>
29978>>>>>>>        Function_Return sRelationsArray
29979>>>>>>>    End_Function
29980>>>>>>>
29980>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
29982>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
29982>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
29983>>>>>>>        String[] sUsers sPrograms
29985>>>>>>>        String sSelect
29985>>>>>>>        Integer iSize iCount
29985>>>>>>>
29985>>>>>>>        Case Begin
29985>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
29987>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
29988>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
29989>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
29990>>>>>>>                Case Break
29991>>>>>>>            Case (sDriverID = SQLFLEX)
29994>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
29995>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
29996>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
29997>>>>>>>                Case Break
29998>>>>>>>            Case Else
29998>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
29999>>>>>>>>
29999>>>>>>>        Case End
29999>>>>>>>
29999>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
30000>>>>>>>        Decrement iSize
30001>>>>>>>        For iCount from 0 to iSize
30007>>>>>>>>
30007>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
30008>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
30009>>>>>>>        Loop
30010>>>>>>>>
30010>>>>>>>
30010>>>>>>>        Function_Return SQLLoggedInUser
30011>>>>>>>    End_Function
30012>>>>>>>
30012>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
30012>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
30012>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
30014>>>>>>>        String[] sFilesData
30015>>>>>>>        Boolean bExists
30015>>>>>>>        Integer iCh
30015>>>>>>>        String sFileName sExt
30015>>>>>>>
30015>>>>>>>        Get vFolderExists sDataPath to bExists
30016>>>>>>>        If (bExists = True) Begin
30018>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
30019>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
30020>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
30021>>>>>>>            Direct_Input channel iCh sDataPath
30023>>>>>>>                Repeat
30023>>>>>>>>
30023>>>>>>>                    Readln channel iCh sFileName
30025>>>>>>>                    Get ParseFileExtension sFileName to sExt
30026>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
30028>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
30030>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
30031>>>>>>>                        End
30031>>>>>>>>
30031>>>>>>>                    End
30031>>>>>>>>
30031>>>>>>>                Until (SeqEof = True)
30033>>>>>>>            Close_Input channel iCh
30035>>>>>>>            Send Seq_Release_Channel iCh
30036>>>>>>>        End
30036>>>>>>>>
30036>>>>>>>        Function_Return sFilesData
30037>>>>>>>    End_Function
30038>>>>>>>
30038>>>>>>>    // Only done for MSSQLDRV_ID so far...
30038>>>>>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
30040>>>>>>>        Boolean bMertechDriver
30040>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
30040>>>>>>>        String sDescription sFrom sSys sValue sPrevious
30040>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
30040>>>>>>>        Integer iFetchResult iRows iColumn iPos
30040>>>>>>>        tSQLConnection SQLConnection
30040>>>>>>>        tSQLConnection SQLConnection
30040>>>>>>>        String[] asCollations
30041>>>>>>>        
30041>>>>>>>        If (sDriverID = "") Begin
30043>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
30044>>>>>>>>
30044>>>>>>>            Function_Return asCollations
30045>>>>>>>        End
30045>>>>>>>>
30045>>>>>>>
30045>>>>>>>        // Only done for MSSQLDRV_ID so far...
30045>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
30047>>>>>>>            Function_Return asCollations
30048>>>>>>>        End                 
30048>>>>>>>>
30048>>>>>>>
30048>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
30049>>>>>>>        If (bMertechDriver = False) Begin
30051>>>>>>>            Get phoSQLManager to hoSQLManager
30052>>>>>>>        End
30052>>>>>>>>
30052>>>>>>>        Else Begin
30053>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
30054>>>>>>>        End
30054>>>>>>>>
30054>>>>>>>
30054>>>>>>>        Get psConnectionID     to sConnectionID
30055>>>>>>>        Get psConnectionString to sConnectionString
30056>>>>>>>        Move 0 to LastErr
30057>>>>>>>
30057>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30058>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
30059>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30060>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
30062>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
30063>>>>>>>>
30063>>>>>>>            Function_Return asCollations
30064>>>>>>>        End
30064>>>>>>>>
30064>>>>>>>
30064>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
30065>>>>>>>
30065>>>>>>>        If (hStmt = 0) Begin
30067>>>>>>>            Send SqlDisconnect of hoSQLManager
30068>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
30069>>>>>>>>
30069>>>>>>>            Function_Return asCollations
30070>>>>>>>        End
30070>>>>>>>>
30070>>>>>>>
30070>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
30071>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
30072>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
30073>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
30074>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
30075>>>>>>>
30075>>>>>>>        // MS-SQL Syntax:  
30075>>>>>>>        // SELECT name, description
30075>>>>>>>        //   from sys.fn_helpcollations();
30075>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
30076>>>>>>>
30076>>>>>>>        Move 1 to iColumn
30077>>>>>>>        Send SqlExecDirect of hStmt sSQL
30078>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
30079>>>>>>>        Repeat
30079>>>>>>>>
30079>>>>>>>            Get SQLFetch of hStmt to iFetchResult
30080>>>>>>>            If (iFetchResult <> 0) Begin
30082>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
30083>>>>>>>                If (sValue <> sPrevious) Begin         
30085>>>>>>>                    // We need to skip all collations starting with "SQL" because they
30085>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
30085>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
30086>>>>>>>                    If (iPos <> 1) Begin
30088>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
30089>>>>>>>                    End
30089>>>>>>>>
30089>>>>>>>                End
30089>>>>>>>>
30089>>>>>>>                Move sValue to sPrevious
30090>>>>>>>            End
30090>>>>>>>>
30090>>>>>>>        Until (iFetchResult = 0)
30092>>>>>>>        Send SQLClose of hStmt
30093>>>>>>>        Send SQLDisconnect of hoSQLConnect
30094>>>>>>>
30094>>>>>>>        Function_Return asCollations
30095>>>>>>>    End_Function
30096>>>>>>>
30096>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
30096>>>>>>>    // for DAW drivers.
30096>>>>>>>    // Returns: A string array.
30096>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
30098>>>>>>>        String[] sReturnArray
30099>>>>>>>        String sValue sPrevious
30099>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
30099>>>>>>>        Integer iFetchResult iRows
30099>>>>>>>        tSQLConnection SQLConnection
30099>>>>>>>        tSQLConnection SQLConnection
30099>>>>>>>
30099>>>>>>>        Get phoSQLManager to hoSQLHandler
30100>>>>>>>
30100>>>>>>>        If (hoSQLHandler <> 0) Begin
30102>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30103>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
30104>>>>>>>
30104>>>>>>>            If (hoSQLConnect <> 0) Begin
30106>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
30107>>>>>>>                If (hstmt <> 0) Begin
30109>>>>>>>                    Send SqlExecDirect of hstmt sStmt
30110>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
30111>>>>>>>                    Repeat
30111>>>>>>>>
30111>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
30112>>>>>>>                        If (iFetchResult <> 0) Begin
30114>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
30115>>>>>>>                            If (sValue <> sPrevious) Begin
30117>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
30118>>>>>>>                            End
30118>>>>>>>>
30118>>>>>>>                            Move sValue to sPrevious
30119>>>>>>>                        End
30119>>>>>>>>
30119>>>>>>>                    Until (iFetchResult = 0)
30121>>>>>>>                    Send SQLClose of hstmt
30122>>>>>>>                End
30122>>>>>>>>
30122>>>>>>>                Send SQLDisconnect of hoSQLConnect
30123>>>>>>>            End
30123>>>>>>>>
30123>>>>>>>        End
30123>>>>>>>>
30123>>>>>>>
30123>>>>>>>        Function_Return sReturnArray
30124>>>>>>>    End_Function
30125>>>>>>>
30125>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
30125>>>>>>>    // for Mertech drivers.
30125>>>>>>>    // Returns: A string array.
30125>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
30127>>>>>>>        String[] sReturnArray
30128>>>>>>>        String sValue
30128>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
30128>>>>>>>        Integer iFetchResult iRows
30128>>>>>>>        tSQLConnection SQLConnection
30128>>>>>>>        tSQLConnection SQLConnection
30128>>>>>>>
30128>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
30129>>>>>>>
30129>>>>>>>        If (hoSQLHandler <> 0) Begin
30131>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30132>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
30133>>>>>>>
30133>>>>>>>            If (hoSQLConnect <> 0) Begin
30135>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
30136>>>>>>>                If (hStmt <> 0) Begin
30138>>>>>>>                    Send SqlExecDirect of hStmt sStmt
30139>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
30140>>>>>>>                    Repeat
30140>>>>>>>>
30140>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
30141>>>>>>>                        If (iFetchResult <> 0) Begin
30143>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
30144>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
30145>>>>>>>                        End
30145>>>>>>>>
30145>>>>>>>                    Until (iFetchResult = 0)
30147>>>>>>>                    Send SQLClose of hStmt
30148>>>>>>>                End
30148>>>>>>>>
30148>>>>>>>                Send SQLDisconnect of hoSQLConnect
30149>>>>>>>            End
30149>>>>>>>>
30149>>>>>>>        End
30149>>>>>>>>
30149>>>>>>>
30149>>>>>>>        Function_Return sReturnArray
30150>>>>>>>    End_Function
30151>>>>>>>
30151>>>>>>>    // * Dummy function for the Studio's Code Explorer *
30151>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
30153>>>>>>>        Function_Return False
30154>>>>>>>    End_Function
30155>>>>>>>
30155>>>>>>>    // Returns the index for the passed sTableName
30155>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
30155>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
30157>>>>>>>        Integer iIndex iSize iCount
30157>>>>>>>        String[] sTablesArray
30158>>>>>>>        String sDatabase sSchema sVal sConnectionString
30158>>>>>>>
30158>>>>>>>        Move -1 to iIndex
30159>>>>>>>        Get psConnectionString to sConnectionString
30160>>>>>>>        Get psDatabase to sDatabase
30161>>>>>>>        Get psSchema   to sSchema
30162>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
30163>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
30164>>>>>>>        Decrement iSize
30165>>>>>>>        For iCount from 0 to iSize
30171>>>>>>>>
30171>>>>>>>            Move sTablesArray[iCount] to sVal
30172>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
30174>>>>>>>                Move iCount to iIndex // We found it!
30175>>>>>>>                Move iSize to iCount  // End the loop
30176>>>>>>>            End
30176>>>>>>>>
30176>>>>>>>        Loop
30177>>>>>>>>
30177>>>>>>>
30177>>>>>>>        Function_Return iIndex
30178>>>>>>>    End_Function
30179>>>>>>>
30179>>>>>>>    // Helper function that builds a string like;
30179>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
30179>>>>>>>    Function _SqlSelectFromWhereName Returns String
30181>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
30181>>>>>>>
30181>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
30182>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
30183>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
30184>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
30185>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
30186>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
30187>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
30188>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
30189>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
30190>>>>>>>        Function_Return sRetval
30191>>>>>>>    End_Function
30192>>>>>>>
30192>>>>>>>    // Helper function to create a SQL statement like;
30192>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
30192>>>>>>>    // Used for checking if an index exists.
30192>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
30194>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
30194>>>>>>>
30194>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
30195>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
30196>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
30197>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
30198>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
30199>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
30200>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
30201>>>>>>>
30201>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
30202>>>>>>>
30202>>>>>>>        Function_Return sRetval
30203>>>>>>>    End_Function
30204>>>>>>>
30204>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
30204>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
30204>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
30206>>>>>>>        String sRetval
30206>>>>>>>        If (iLength <> 0) Begin
30208>>>>>>>            Move ("(" + String(iLength)) to sRetval
30209>>>>>>>            If (iDecimals <> 0) Begin
30211>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
30212>>>>>>>            End
30212>>>>>>>>
30212>>>>>>>            Move (sRetval + ")") to sRetval
30213>>>>>>>        End
30213>>>>>>>>
30213>>>>>>>        Function_Return sRetval
30214>>>>>>>    End_Function
30215>>>>>>>
30215>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
30217>>>>>>>        Integer i iCols iItem
30217>>>>>>>        tSqlColumnNew[] aQueryColumns
30217>>>>>>>        tSqlColumnNew[] aQueryColumns
30218>>>>>>>
30218>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
30219>>>>>>>        For i from 1 to iCols
30225>>>>>>>>
30225>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
30226>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
30227>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
30228>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
30229>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
30230>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
30231>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
30232>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
30233>>>>>>>        Loop
30234>>>>>>>>
30234>>>>>>>        Set piColumns to iCols
30235>>>>>>>        Set paQueryColumns to aQueryColumns
30236>>>>>>>    End_Procedure
30237>>>>>>>
30237>>>>>>>    // Checks that the passed sDriverID is defined.
30237>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
30237>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
30239>>>>>>>        Boolean bOK
30239>>>>>>>        Integer iDriver
30239>>>>>>>
30239>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
30241>>>>>>>            Function_Return False
30242>>>>>>>        End
30242>>>>>>>>
30242>>>>>>>
30242>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
30243>>>>>>>
30243>>>>>>>        If (bOK = False) Begin
30245>>>>>>>            Get IsMertechDriver sDriverID to bOK
30246>>>>>>>        End
30246>>>>>>>>
30246>>>>>>>
30246>>>>>>>        If (bOK = False) Begin
30248>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
30249>>>>>>>>
30249>>>>>>>            Function_Return False
30250>>>>>>>        End
30250>>>>>>>>
30250>>>>>>>
30250>>>>>>>        Get DriverIndex sDriverID to iDriver
30251>>>>>>>        If (iDriver = 0) Begin
30253>>>>>>>            Load_Driver sDriverID
30254>>>>>>>        End
30254>>>>>>>>
30254>>>>>>>
30254>>>>>>>        Function_Return True
30255>>>>>>>    End_Function
30256>>>>>>>
30256>>>>>>>    // Checks that the length parameter has been passed correctly.
30256>>>>>>>    // This is only of concern for certain SQL data types.
30256>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
30258>>>>>>>        Integer iLength
30258>>>>>>>        Boolean bOK bCheckTypeLength
30258>>>>>>>
30258>>>>>>>        If (num_arguments > 1) Begin
30260>>>>>>>            Move iLen to iLength
30261>>>>>>>        End
30261>>>>>>>>
30261>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
30262>>>>>>>
30262>>>>>>>        If (bCheckTypeLength = True) Begin
30264>>>>>>>            Move (iLength > 0) to bOK
30265>>>>>>>        End
30265>>>>>>>>
30265>>>>>>>
30265>>>>>>>        Function_Return (bOK = True)
30266>>>>>>>    End_Function
30267>>>>>>>
30267>>>>>>>    Function _SqlProperTableName String sTableName Returns String
30269>>>>>>>        String sVal sSchema sDriverID
30269>>>>>>>        Integer iDbType
30269>>>>>>>
30269>>>>>>>        If (Trim(sTableName) = "") Begin
30271>>>>>>>            Function_Return ""
30272>>>>>>>        End
30272>>>>>>>>
30272>>>>>>>
30272>>>>>>>        Get psDriverID to sDriverID
30273>>>>>>>        Get piDbType   to iDbType
30274>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
30276>>>>>>>            Get psUserID to sSchema
30277>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
30277>>>>>>>            Move (Uppercase(sSchema)) to sSchema
30278>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
30279>>>>>>>            Function_Return sTableName
30280>>>>>>>        End
30280>>>>>>>>
30280>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
30282>>>>>>>            Get psDatabase to sVal
30283>>>>>>>            Move (sVal + "." + sTableName) to sTableName
30284>>>>>>>            Function_Return sTableName
30285>>>>>>>        End
30285>>>>>>>>
30285>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
30287>>>>>>>            Move ('"' + sTableName + '"') to sTableName
30288>>>>>>>            Function_Return sTableName
30289>>>>>>>        End
30289>>>>>>>>
30289>>>>>>>
30289>>>>>>>        Get psSchema to sSchema
30290>>>>>>>        If (sSchema = "") Begin
30292>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
30293>>>>>>>        End
30293>>>>>>>>
30293>>>>>>>
30293>>>>>>>        Move (Uppercase(sTableName)) to sVal
30294>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
30296>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
30298>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
30299>>>>>>>            End
30299>>>>>>>>
30299>>>>>>>            Else Begin
30300>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
30301>>>>>>>            End
30301>>>>>>>>
30301>>>>>>>        End
30301>>>>>>>>
30301>>>>>>>
30301>>>>>>>        Function_Return sTableName
30302>>>>>>>    End_Function
30303>>>>>>>
30303>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
30303>>>>>>>    // the passed sFieldName has the correct spelling.
30303>>>>>>>    // Used with Embedded SQL statement calls.
30303>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
30303>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
30305>>>>>>>        String sRetval sValue sDriverID
30305>>>>>>>        String[] sColumnNamesArray
30306>>>>>>>        Integer iCount iColumns
30306>>>>>>>
30306>>>>>>>        Move "" to sRetval
30307>>>>>>>        Get psDriverID to sDriverID
30308>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
30309>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
30310>>>>>>>        Decrement iColumns
30311>>>>>>>
30311>>>>>>>        For iCount from 0 to iColumns
30317>>>>>>>>
30317>>>>>>>            Move sColumnNamesArray[iCount] to sValue
30318>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
30320>>>>>>>                Move sValue to sRetval
30321>>>>>>>                Move iColumns to iCount // We're done.
30322>>>>>>>            End
30322>>>>>>>>
30322>>>>>>>        Loop
30323>>>>>>>>
30323>>>>>>>
30323>>>>>>>        Function_Return sRetval
30324>>>>>>>    End_Function
30325>>>>>>>
30325>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
30327>>>>>>>        String[] sReturnArray
30328>>>>>>>        Handle hoSQLHandler
30328>>>>>>>        Integer iCount iSize iItem
30328>>>>>>>        String sServer
30328>>>>>>>        tSQLConnection SQLConnection
30328>>>>>>>        tSQLConnection SQLConnection
30328>>>>>>>
30328>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
30329>>>>>>>        Send Delete_Data    of hoSQLHandler
30330>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
30331>>>>>>>
30331>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30332>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
30333>>>>>>>        Decrement iSize
30334>>>>>>>
30334>>>>>>>        For iCount from 0 to iSize
30340>>>>>>>>
30340>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
30341>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
30342>>>>>>>            Increment iItem
30343>>>>>>>        Loop
30344>>>>>>>>
30344>>>>>>>
30344>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30345>>>>>>>
30345>>>>>>>        Function_Return sReturnArray
30346>>>>>>>    End_Function
30347>>>>>>>
30347>>>>>>>    Function _SqlTableArrayDAW Returns String[]
30349>>>>>>>        String[] sReturnArray
30350>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
30350>>>>>>>        Handle hoSQLHandler
30350>>>>>>>        Integer iCount iSize iItem iPos
30350>>>>>>>        Boolean bOK
30350>>>>>>>        tSQLConnection SQLConnection
30350>>>>>>>        tSQLConnection SQLConnection
30350>>>>>>>
30350>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30351>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
30353>>>>>>>            Function_Return sReturnArray
30354>>>>>>>        End
30354>>>>>>>>
30354>>>>>>>
30354>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
30355>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
30356>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
30357>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
30358>>>>>>>
30358>>>>>>>        Get phoCLIHandler to hoSQLHandler
30359>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
30360>>>>>>>        Send Delete_Data  of hoSQLHandler
30361>>>>>>>
30361>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30362>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
30363>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
30363>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
30363>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
30363>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
30363>>>>>>>//                If (iPos > 0) Begin
30363>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
30363>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
30363>>>>>>>//                End
30363>>>>>>>//            End
30363>>>>>>>//        End
30363>>>>>>>
30363>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
30364>>>>>>>        Move False to Err
30365>>>>>>>        Move 0 to iItem
30366>>>>>>>
30366>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
30366>>>>>>>        for iCount from 1 to iSize
30372>>>>>>>>
30372>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
30373>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
30374>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
30375>>>>>>>            If (sSchema = "") Begin
30377>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
30378>>>>>>>            End
30378>>>>>>>>
30378>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
30379>>>>>>>            Move (Trim(sTable)) to sTable
30380>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
30382>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
30383>>>>>>>            End
30383>>>>>>>>
30383>>>>>>>            Else Begin
30384>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
30385>>>>>>>            End
30385>>>>>>>>
30385>>>>>>>            If (bOK = True) Begin
30387>>>>>>>                Move sTable to sReturnArray[iItem]
30388>>>>>>>                Increment iItem
30389>>>>>>>            End
30389>>>>>>>>
30389>>>>>>>        Loop
30390>>>>>>>>
30390>>>>>>>
30390>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30391>>>>>>>
30391>>>>>>>        Function_Return sReturnArray
30392>>>>>>>    End_Function
30393>>>>>>>
30393>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
30395>>>>>>>        String[] sReturnArray
30396>>>>>>>        String sValue
30396>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
30396>>>>>>>        Integer iRetval iCols iFetchResult
30396>>>>>>>        tSQLConnection SQLConnection
30396>>>>>>>        tSQLConnection SQLConnection
30396>>>>>>>
30396>>>>>>>        Get phoSQLManager to hoSQLHandler
30397>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30398>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
30399>>>>>>>
30399>>>>>>>        If (hoSQLConnect <> 0) Begin
30401>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
30402>>>>>>>            If (hStmt <> 0) Begin
30404>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
30405>>>>>>>                If (sArgument <> "") Begin
30407>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
30408>>>>>>>                End
30408>>>>>>>>
30408>>>>>>>
30408>>>>>>>                Send SqlCall             of hStmt
30409>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
30410>>>>>>>                If (iRetval = 0) Begin
30412>>>>>>>                    Repeat
30412>>>>>>>>
30412>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
30413>>>>>>>                        If (iCols > 0) Begin
30415>>>>>>>                            Repeat
30415>>>>>>>>
30415>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
30416>>>>>>>                                If (iFetchResult <> 0) Begin
30418>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
30419>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
30420>>>>>>>                                End
30420>>>>>>>>
30420>>>>>>>                            Until (iFetchResult = 0)
30422>>>>>>>                        End
30422>>>>>>>>
30422>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
30423>>>>>>>                    Until (iRetval = 0)
30425>>>>>>>                    Send SqlClose of hStmt
30426>>>>>>>                End
30426>>>>>>>>
30426>>>>>>>            End
30426>>>>>>>>
30426>>>>>>>            Send SqlDisconnect of hoSQLConnect
30427>>>>>>>        End
30427>>>>>>>>
30427>>>>>>>        Function_Return sReturnArray
30428>>>>>>>    End_Function
30429>>>>>>>
30429>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
30431>>>>>>>        String[] sReturnArray
30432>>>>>>>        String sDataSource
30432>>>>>>>        Handle hoSQLHandler
30432>>>>>>>        Integer iItem
30432>>>>>>>
30432>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
30433>>>>>>>        Send SeedDataSources of hoSQLHandler
30434>>>>>>>
30434>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30435>>>>>>>
30435>>>>>>>        Repeat
30435>>>>>>>>
30435>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
30436>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
30437>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
30438>>>>>>>            Increment iItem
30439>>>>>>>        Until (sDataSource = "")
30441>>>>>>>
30441>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30442>>>>>>>
30442>>>>>>>        Function_Return sReturnArray
30443>>>>>>>    End_Function
30444>>>>>>>
30444>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
30446>>>>>>>        String[] sReturnArray
30447>>>>>>>        String sDataSource
30447>>>>>>>        Handle hoSQLHandler
30447>>>>>>>        Integer iItem
30447>>>>>>>
30447>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
30448>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30449>>>>>>>
30449>>>>>>>        Send SeedDataSources of hoSQLHandler
30450>>>>>>>
30450>>>>>>>        Repeat
30450>>>>>>>>
30450>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
30451>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
30453>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
30454>>>>>>>                Increment iItem
30455>>>>>>>            End
30455>>>>>>>>
30455>>>>>>>        Until (sDataSource = "")
30457>>>>>>>
30457>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30458>>>>>>>
30458>>>>>>>        Function_Return sReturnArray
30459>>>>>>>    End_Function
30460>>>>>>>
30460>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
30462>>>>>>>        String[] sDataSources
30463>>>>>>>        tSQLConnection SQLConnection
30463>>>>>>>        tSQLConnection SQLConnection
30463>>>>>>>        tSQLIntTableInfo[] sReturnArray
30463>>>>>>>        tSQLIntTableInfo[] sReturnArray
30464>>>>>>>        Integer iDataSources iCount iItem
30464>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
30464>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
30464>>>>>>>        Boolean bExists bKeyOpened
30464>>>>>>>
30464>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30465>>>>>>>        Move SQLConnection.sConnectionString to sConnection
30466>>>>>>>        Move SQLConnection.sServer           to sServer
30467>>>>>>>
30467>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
30467>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
30469>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
30470>>>>>>>            Set psFileName of hoIniFile to sServer
30471>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
30472>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
30473>>>>>>>            Send Destroy of hoIniFile
30474>>>>>>>        End
30474>>>>>>>>
30474>>>>>>>
30474>>>>>>>        // DSN - read DATABASE name from the registry
30474>>>>>>>        Else Begin
30475>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
30476>>>>>>>
30476>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
30476>>>>>>>            // most probably place the info is kept that we're after.
30476>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
30477>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
30478>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
30479>>>>>>>            If (bExists = True) Begin
30481>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
30482>>>>>>>            End
30482>>>>>>>>
30482>>>>>>>            Else Begin
30483>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
30484>>>>>>>            End
30484>>>>>>>>
30484>>>>>>>
30484>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
30485>>>>>>>            If (bExists) Begin
30487>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
30488>>>>>>>                If (bKeyOpened) Begin
30490>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
30491>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
30492>>>>>>>                    If (iDataSources > 0) Begin
30494>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
30495>>>>>>>                        Decrement iDataSources
30496>>>>>>>                        for iCount from 0 to iDataSources
30502>>>>>>>>
30502>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
30503>>>>>>>                        Loop
30504>>>>>>>>
30504>>>>>>>                        Move 0 to iItem
30505>>>>>>>                        for iCount from 0 to iDataSources
30511>>>>>>>>
30511>>>>>>>                            Move sDataSources[iCount] to sSubKey
30512>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
30513>>>>>>>                            If (bKeyOpened = True) Begin
30515>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
30516>>>>>>>                                If (bExists = True) Begin
30518>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
30519>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
30520>>>>>>>                                    Increment iItem
30521>>>>>>>                                End
30521>>>>>>>>
30521>>>>>>>                            End
30521>>>>>>>>
30521>>>>>>>                        Loop
30522>>>>>>>>
30522>>>>>>>                    End
30522>>>>>>>>
30522>>>>>>>                    Send CloseKey of hoRegistry
30523>>>>>>>                    Send Destroy of hoODBCDataSources
30524>>>>>>>                End
30524>>>>>>>>
30524>>>>>>>            End
30524>>>>>>>>
30524>>>>>>>
30524>>>>>>>            // We then check the "User DNS" area in the registry.
30524>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
30525>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
30526>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
30527>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
30528>>>>>>>
30528>>>>>>>            If (bExists) Begin
30530>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
30531>>>>>>>                If (bKeyOpened) Begin
30533>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
30534>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
30535>>>>>>>                    If (iDataSources > 0) Begin
30537>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
30538>>>>>>>                        Decrement iDataSources
30539>>>>>>>                        for iCount from 0 to iDataSources
30545>>>>>>>>
30545>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
30546>>>>>>>                        Loop
30547>>>>>>>>
30547>>>>>>>                        for iCount from 0 to iDataSources
30553>>>>>>>>
30553>>>>>>>                            Move sDataSources[iCount] to sSubKey
30554>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
30555>>>>>>>                            If (bKeyOpened = True) Begin
30557>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
30558>>>>>>>                                If (bExists = True) Begin
30560>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
30561>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
30562>>>>>>>                                    Increment iItem
30563>>>>>>>                                End
30563>>>>>>>>
30563>>>>>>>                            End
30563>>>>>>>>
30563>>>>>>>                        Loop
30564>>>>>>>>
30564>>>>>>>                    End
30564>>>>>>>>
30564>>>>>>>                    Send CloseKey of hoRegistry
30565>>>>>>>                    Send Destroy of hoODBCDataSources
30566>>>>>>>                End
30566>>>>>>>>
30566>>>>>>>            End
30566>>>>>>>>
30566>>>>>>>
30566>>>>>>>            Send Destroy of hoRegistry
30567>>>>>>>        End
30567>>>>>>>>
30567>>>>>>>
30567>>>>>>>        Function_Return sReturnArray
30568>>>>>>>    End_Function
30569>>>>>>>
30569>>>>>>>    // We might have a split Sql script where the info about which database to use is
30569>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
30569>>>>>>>    // insert it for scriplets to come after the first one.
30569>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
30571>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
30571>>>>>>>        Integer iStart iEnd iDbType
30571>>>>>>>        Boolean bOK
30571>>>>>>>
30571>>>>>>>        Get piDbType to iDbType
30572>>>>>>>        Get psDriverID to sDriverID
30573>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
30574>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
30575>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
30576>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
30577>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
30578>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
30580>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
30581>>>>>>>            Move (Pos("]", sTmp)) to iEnd
30582>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
30583>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
30584>>>>>>>            Set Private.psUseDatabase to sUseDatabase
30585>>>>>>>        End
30585>>>>>>>>
30585>>>>>>>        Else Begin
30586>>>>>>>            Move (Uppercase(sStmt)) to sTmp
30587>>>>>>>
30587>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
30587>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
30589>>>>>>>                Get Private.psUseDatabase to sUseDatabase
30590>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
30591>>>>>>>            End
30591>>>>>>>>
30591>>>>>>>
30591>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
30591>>>>>>>            // We will get an error when trying to create a view if it already exists.
30591>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
30591>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
30594>>>>>>>                // Make sure we only have one space between statements/words.
30594>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
30595>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
30596>>>>>>>                Move (Trim(sTmp)) to sTmp
30597>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
30598>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
30599>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
30601>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
30602>>>>>>>                End
30602>>>>>>>>
30602>>>>>>>                Move (Trim(sTmp)) to sTmp
30603>>>>>>>                // Remove data view as it already exists!
30603>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
30604>>>>>>>            End
30604>>>>>>>>
30604>>>>>>>        End
30604>>>>>>>>
30604>>>>>>>
30604>>>>>>>        Function_Return sStmt
30605>>>>>>>    End_Function
30606>>>>>>>
30606>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
30606>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
30608>>>>>>>        String sRetval
30608>>>>>>>        Integer iDbType iIndex
30608>>>>>>>        tSQLKeyWords[] SQLKeywordArray
30608>>>>>>>        tSQLKeyWords[] SQLKeywordArray
30609>>>>>>>        tSQLKeyWords   SQLKeyWords
30609>>>>>>>        tSQLKeyWords   SQLKeyWords
30609>>>>>>>
30609>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
30609>>>>>>>        Move "" to sRetval
30610>>>>>>>        Get piDbType to iDbType
30611>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
30612>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
30613>>>>>>>
30613>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
30614>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
30615>>>>>>>        If (iIndex >= 0) Begin
30617>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
30618>>>>>>>        End
30618>>>>>>>>
30618>>>>>>>
30618>>>>>>>        Function_Return sRetval
30619>>>>>>>    End_Function
30620>>>>>>>
30620>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
30620>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
30622>>>>>>>        String[] sSQLScriptArray
30623>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
30623>>>>>>>        Integer iSize iCount
30623>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
30623>>>>>>>
30623>>>>>>>        Move False to bCommentStart
30624>>>>>>>        Move False to bCommentEnd
30625>>>>>>>        Move False to bDashComment
30626>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
30627>>>>>>>        Move "*/"  to sCommentEnd
30628>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
30629>>>>>>>
30629>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
30630>>>>>>>        Decrement iSize
30631>>>>>>>        Move "" to sText
30632>>>>>>>
30632>>>>>>>        For iCount from 0 to iSize
30638>>>>>>>>
30638>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
30639>>>>>>>            Move (Trim(sLine)) to sTmp
30640>>>>>>>            If (sTmp <> "") Begin
30642>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
30643>>>>>>>                If (bCommentStart = False) Begin
30645>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
30646>>>>>>>                    If (bCommentStart = False) Begin
30648>>>>>>>                    End
30648>>>>>>>>
30648>>>>>>>                End
30648>>>>>>>>
30648>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
30649>>>>>>>                If (bCommentEnd = True) Begin
30651>>>>>>>                    Move False to bCommentStart
30652>>>>>>>                End
30652>>>>>>>>
30652>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
30654>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
30655>>>>>>>                End
30655>>>>>>>>
30655>>>>>>>            End
30655>>>>>>>>
30655>>>>>>>        Loop
30656>>>>>>>>
30656>>>>>>>
30656>>>>>>>        // Update the retval struct array:
30656>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
30657>>>>>>>        Function_Return SqlScriptArray
30658>>>>>>>    End_Function
30659>>>>>>>
30659>>>>>>>
30659>>>>>>>    // *** Database API Functions: ***
30659>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
30659>>>>>>>    // make changes/updates to the database.
30659>>>>>>>
30659>>>>>>>    // * Dummy function for the Studio's Code Explorer *
30659>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
30661>>>>>>>        Function_Return False
30662>>>>>>>    End_Function
30663>>>>>>>
30663>>>>>>>    // This might not do what you think - Here's what it does:
30663>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
30663>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
30663>>>>>>>    // to the SQL table.
30663>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
30663>>>>>>>    // already exists in SQL.
30663>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
30663>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
30663>>>>>>>    // restructuring an existing table.
30663>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
30665>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
30665>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
30665>>>>>>>        Handle hToTable
30665>>>>>>>
30665>>>>>>>        Move True to bUseConnectionID
30666>>>>>>>        If (num_arguments > 1) Begin
30668>>>>>>>            Move bUseConnID to bUseConnectionID
30669>>>>>>>        End
30669>>>>>>>>
30669>>>>>>>
30669>>>>>>>        Get psDriverID to sDriverID
30670>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
30670>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
30671>>>>>>>        If (bExists = False) Begin
30673>>>>>>>            Function_Return False
30674>>>>>>>        End
30674>>>>>>>>
30674>>>>>>>
30674>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
30675>>>>>>>
30675>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
30676>>>>>>>        If (bOK = False) Begin
30678>>>>>>>            Function_Return False
30679>>>>>>>        End
30679>>>>>>>>
30679>>>>>>>
30679>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
30679>>>>>>>        // we do nothing
30679>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
30680>>>>>>>        If (bExists = True) Begin
30682>>>>>>>            Function_Return False
30683>>>>>>>        End
30683>>>>>>>>
30683>>>>>>>
30683>>>>>>>        Get psConnectionID     to sConnectionID
30684>>>>>>>        Get psConnectionString to sConnectionString
30685>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
30687>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
30688>>>>>>>>
30688>>>>>>>            Function_Return False
30689>>>>>>>        End
30689>>>>>>>>
30689>>>>>>>
30689>>>>>>>        Set Private.phCurrentTable to hTable
30690>>>>>>>        Get psSchema to sSchema
30691>>>>>>>        If (sSchema = "") Begin
30693>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
30694>>>>>>>        End
30694>>>>>>>>
30694>>>>>>>
30694>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
30695>>>>>>>
30695>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
30695>>>>>>>        // was a programmer's error and we adjust for it here.
30695>>>>>>>        If (bMertechDriver = True) Begin
30697>>>>>>>            Move False to bUseConnectionID
30698>>>>>>>        End
30698>>>>>>>>
30698>>>>>>>
30698>>>>>>>        // If we should use a connection id we need to check it exists;
30698>>>>>>>        // else we create it before attempting creating the table
30698>>>>>>>        If (bUseConnectionID = True) Begin
30700>>>>>>>            Get AutoConnectionIDLogin to bOK
30701>>>>>>>            If (bOk = False) Begin
30703>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
30704>>>>>>>>
30704>>>>>>>                Function_Return False
30705>>>>>>>            End
30705>>>>>>>>
30705>>>>>>>        End
30705>>>>>>>>
30705>>>>>>>
30705>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30708>>>>>>>        Get _TableNameOnly sRootName to sRootName
30709>>>>>>>        If (sRootName = "") Begin
30711>>>>>>>            Function_Return False
30712>>>>>>>        End
30712>>>>>>>>
30712>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
30713>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
30716>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
30719>>>>>>>
30719>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
30719>>>>>>>        //
30719>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
30719>>>>>>>        // because then the table should not be visible to users.
30719>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
30719>>>>>>>//        If (iPos <> 1) Begin
30719>>>>>>>//            If (sDisplayName contains ".") Begin
30719>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
30719>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
30719>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
30719>>>>>>>//            End
30719>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
30719>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
30719>>>>>>>//            End
30719>>>>>>>//        End
30719>>>>>>>
30719>>>>>>>        If (bIsAlias = False) Begin
30721>>>>>>>            Get OpenTableExclusive hTable to bOpened
30722>>>>>>>            If (bOpened = False) Begin
30724>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
30725>>>>>>>>
30725>>>>>>>                Function_Return False
30726>>>>>>>            End
30726>>>>>>>>
30726>>>>>>>        End
30726>>>>>>>>
30726>>>>>>>
30726>>>>>>>        If (ghoProgressBar <> 0) Begin
30728>>>>>>>            Send DoAdvance of ghoProgressBar
30729>>>>>>>            Set Message_Text of ghoStatusPanel to ""
30730>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
30731>>>>>>>        End
30731>>>>>>>>
30731>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
30731>>>>>>>        Move hTable to hToTable
30732>>>>>>>        Move False to Err
30733>>>>>>>
30733>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
30733>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
30733>>>>>>>        // a proper and updated .int file.
30733>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
30736>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
30737>>>>>>>
30737>>>>>>>        If (bIsAlias = False) Begin
30739>>>>>>>            Structure_Start hToTable sDriverID
30740>>>>>>>                Set Private.phCurrentTable to hTable
30741>>>>>>>                If (bUseConnectionID = True) Begin
30743>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
30746>>>>>>>                End
30746>>>>>>>>
30746>>>>>>>                Else Begin
30747>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
30750>>>>>>>                End
30750>>>>>>>>
30750>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
30753>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
30753>>>>>>>                Move False to Err
30754>>>>>>>                Move 0 to LastErr
30755>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
30756>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
30758>>>>>>>            Set Action_Text of ghoStatusPanel to ""
30759>>>>>>>        End
30759>>>>>>>>
30759>>>>>>>
30759>>>>>>>        Move (not(Err)) to bOK
30760>>>>>>>        If (bOK = True) Begin
30762>>>>>>>            // The attributes set above will always trigger an error
30762>>>>>>>            // We also adjust the Filelist entries
30762>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
30765>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
30768>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
30771>>>>>>>
30771>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
30771>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
30772>>>>>>>        End
30772>>>>>>>>
30772>>>>>>>
30772>>>>>>>        Function_Return (bOK = True)
30773>>>>>>>    End_Function
30774>>>>>>>
30774>>>>>>>    // Sample usage:
30774>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
30774>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
30774>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
30776>>>>>>>        Boolean bOK bIsSQLTable
30776>>>>>>>
30776>>>>>>>        Get AutoConnectionIDLogin to bOK
30777>>>>>>>        Move False to Err
30778>>>>>>>        Get OpenTableExclusive hTable to bOK
30779>>>>>>>        If (bOK = False) Begin
30781>>>>>>>            Function_Return False
30782>>>>>>>        End
30782>>>>>>>>
30782>>>>>>>
30782>>>>>>>        // ToDo: Add to all table change functions!
30782>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
30783>>>>>>>            If (bIsSQLTable = True) Begin
30785>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
30788>>>>>>>            End
30788>>>>>>>>
30788>>>>>>>
30788>>>>>>>        Set Private.phCurrentTable to hTable
30789>>>>>>>        Structure_Start hTable
30790>>>>>>>            Set_Attribute iAttribute of hTable to iValue
30793>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
30794>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
30796>>>>>>>
30796>>>>>>>        Set Action_Text of ghoStatusPanel to ""
30797>>>>>>>        Function_Return (Err = False)
30798>>>>>>>    End_Function
30799>>>>>>>
30799>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
30801>>>>>>>        Boolean bOK
30801>>>>>>>        
30801>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
30802>>>>>>>        If (bOK = True) Begin
30804>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
30805>>>>>>>        End
30805>>>>>>>>
30805>>>>>>>        
30805>>>>>>>        Function_Return (bOK = True)
30806>>>>>>>    End_Function
30807>>>>>>>    
30807>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
30807>>>>>>>    // or to change the filelist slot names.
30807>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
30809>>>>>>>        String sFileListName
30809>>>>>>>        
30809>>>>>>>        Move False to Err
30810>>>>>>>
30810>>>>>>>        If (ghoProgressBar <> 0) Begin
30812>>>>>>>            Send DoAdvance of ghoProgressBar
30813>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
30814>>>>>>>        End
30814>>>>>>>>
30814>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
30814>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
30816>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
30819>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
30822>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
30825>>>>>>>            Function_Return (Err = False) // And we're done.
30826>>>>>>>        End
30826>>>>>>>>
30826>>>>>>>
30826>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
30828>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
30828>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
30829>>>>>>>        End
30829>>>>>>>>
30829>>>>>>>//        Else Begin
30829>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30829>>>>>>>//        End
30829>>>>>>>//
30829>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
30829>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
30829>>>>>>>
30829>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
30832>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
30835>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
30838>>>>>>>        
30838>>>>>>>        Function_Return (Err = False)
30839>>>>>>>    End_Function
30840>>>>>>>
30840>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
30842>>>>>>>        Boolean bOK
30842>>>>>>>
30842>>>>>>>        Get AutoConnectionIDLogin to bOK
30843>>>>>>>        Move False to Err
30844>>>>>>>        Get OpenTableExclusive hTable to bOK
30845>>>>>>>        If (bOK = False) Begin
30847>>>>>>>            Function_Return False
30848>>>>>>>        End
30848>>>>>>>>
30848>>>>>>>
30848>>>>>>>        Set Private.phCurrentTable to hTable
30849>>>>>>>        Structure_Start hTable
30850>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
30853>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
30854>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
30856>>>>>>>
30856>>>>>>>        Set Action_Text of ghoStatusPanel to ""
30857>>>>>>>        Function_Return (Err = False)
30858>>>>>>>    End_Function
30859>>>>>>>
30859>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
30861>>>>>>>        Boolean bOK bIsSQLTable
30861>>>>>>>
30861>>>>>>>        Move False to Err
30862>>>>>>>        Get AutoConnectionIDLogin to bOK
30863>>>>>>>        Open hToTable
30865>>>>>>>        Get OpenTableExclusive hTable to bOK
30866>>>>>>>        If (bOK = False) Begin
30868>>>>>>>            Function_Return False
30869>>>>>>>        End
30869>>>>>>>>
30869>>>>>>>
30869>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
30870>>>>>>>            If (bIsSQLTable = True) Begin
30872>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
30875>>>>>>>            End
30875>>>>>>>>
30875>>>>>>>
30875>>>>>>>        Set Private.phCurrentTable to hTable
30876>>>>>>>        Structure_Start hTable
30877>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
30880>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
30883>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
30884>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
30886>>>>>>>
30886>>>>>>>        Set Action_Text of ghoStatusPanel to ""
30887>>>>>>>        Function_Return (Err = False)
30888>>>>>>>    End_Function
30889>>>>>>>
30889>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
30891>>>>>>>        Integer[] aTableConvertExceptions
30892>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
30893>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
30894>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
30895>>>>>>>    End_Procedure
30896>>>>>>>
30896>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
30898>>>>>>>        Integer[] aTableDateCorrectionExceptions
30899>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
30900>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
30901>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
30902>>>>>>>    End_Procedure
30903>>>>>>>
30903>>>>>>>    Procedure ApiTableConvertALLToSql
30905>>>>>>>        Integer[] iTablesArray
30906>>>>>>>        Integer iSize iCount
30906>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
30906>>>>>>>        String sDriverID
30906>>>>>>>
30906>>>>>>>        Get psDriverID to sDriverID
30907>>>>>>>        Get pbUseConnectionID to bUseConnectionID
30908>>>>>>>        Get pbToANSI          to bToANSI
30909>>>>>>>        Get pbRecnum          to bRecnum
30910>>>>>>>        Get pbCopyData        to bCopyData
30911>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
30913>>>>>>>            Get pbContinueOnError to bContinueOnError
30914>>>>>>>        End
30914>>>>>>>>
30914>>>>>>>
30914>>>>>>>        Get _AllTablesToConvert to iTablesArray
30915>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
30916>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
30917>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
30918>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
30919>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
30920>>>>>>>
30920>>>>>>>        Decrement iSize
30921>>>>>>>        For iCount from 0 to iSize
30927>>>>>>>>
30927>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
30928>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
30929>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
30929>>>>>>>            // if there was an error converting one table...
30929>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
30929>>>>>>>        Loop
30930>>>>>>>>
30930>>>>>>>
30930>>>>>>>    End_Procedure
30931>>>>>>>
30931>>>>>>>    Procedure ApiTableAttachALLToSql
30933>>>>>>>        Integer[] iTablesArray
30934>>>>>>>        Integer iSize iCount
30934>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
30934>>>>>>>        String sDriverID
30934>>>>>>>
30934>>>>>>>        Get psDriverID to sDriverID
30935>>>>>>>        Get pbUseConnectionID to bUseConnectionID
30936>>>>>>>        Get pbToANSI          to bToANSI
30937>>>>>>>        Get pbRecnum          to bRecnum
30938>>>>>>>        Get pbCopyData        to bCopyData
30939>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
30941>>>>>>>            Get pbContinueOnError to bContinueOnError
30942>>>>>>>        End
30942>>>>>>>>
30942>>>>>>>
30942>>>>>>>        Get _AllTablesToConvert to iTablesArray
30943>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
30944>>>>>>>        Decrement iSize
30945>>>>>>>        For iCount from 0 to iSize
30951>>>>>>>>
30951>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
30952>>>>>>>        Loop
30953>>>>>>>>
30953>>>>>>>
30953>>>>>>>    End_Procedure
30954>>>>>>>
30954>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
30954>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
30956>>>>>>>        Handle hTable
30956>>>>>>>        String sConnectionID
30956>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
30956>>>>>>>
30956>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
30957>>>>>>>        If (bSameTableNames = True) Begin
30959>>>>>>>            Function_Return True
30960>>>>>>>        End
30960>>>>>>>>
30960>>>>>>>
30960>>>>>>>        Move True to bOK
30961>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
30962>>>>>>>        Set Private.phCurrentTable              to hTable
30963>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
30966>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
30969>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
30972>>>>>>>
30972>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
30974>>>>>>>            Get psConnectionID to sConnectionID
30975>>>>>>>            Get UtilTableExists hTable to bTableExists
30976>>>>>>>            If (bTableExists = True) Begin
30978>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
30979>>>>>>>            End
30979>>>>>>>>
30979>>>>>>>            Else Begin
30980>>>>>>>                Get pbToANSI to bANSI
30981>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
30982>>>>>>>            End
30982>>>>>>>>
30982>>>>>>>        End
30982>>>>>>>>
30982>>>>>>>
30982>>>>>>>        Function_Return bOK
30983>>>>>>>    End_Function
30984>>>>>>>
30984>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
30986>>>>>>>        Handle hToTable hoLogFile
30986>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
30986>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
30986>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
30986>>>>>>>        tSQLConnection SQLConnection
30986>>>>>>>        tSQLConnection SQLConnection
30986>>>>>>>
30986>>>>>>>        Get UtilTableExists hTable to bExists
30987>>>>>>>        If (bExists = False) Begin
30989>>>>>>>            Set Private.phCurrentTable to hTable
30990>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
30991>>>>>>>>
30991>>>>>>>            Function_Return False
30992>>>>>>>        End
30992>>>>>>>>
30992>>>>>>>
30992>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
30993>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
30993>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
30993>>>>>>>        If (bIsAlias = True) Begin
30995>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30998>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
31000>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
31003>>>>>>>                Get psConnectionID to sConnectionID
31004>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
31005>>>>>>>            End
31005>>>>>>>>
31005>>>>>>>            Function_Return True
31006>>>>>>>        End
31006>>>>>>>>
31006>>>>>>>
31006>>>>>>>        Set Private.phCurrentTable to hTable
31007>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
31010>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
31013>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
31016>>>>>>>
31016>>>>>>>        If (ghoProgressBar <> 0) Begin
31018>>>>>>>            Send DoAdvance of ghoProgressBar
31019>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
31020>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
31021>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
31022>>>>>>>        End
31022>>>>>>>>
31022>>>>>>>
31022>>>>>>>        // Marco Kuipers suggestion;
31022>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
31022>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
31022>>>>>>>        // SQL table.
31022>>>>>>>        Get UtilTableIsSQL hTable to bOK
31023>>>>>>>        If (bOK = False) Begin
31025>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
31026>>>>>>>            If (bExists = True) Begin
31028>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
31028>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
31028>>>>>>>                Get phoLogFile to hoLogFile
31029>>>>>>>                If (hoLogFile <> 0) Begin          
31031>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
31032>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
31032>>>>>>>                    Send LogError sWarning False
31033>>>>>>>                End
31033>>>>>>>>
31033>>>>>>>                Else Begin
31034>>>>>>>                    Error DFERR_PROGRAM sWarning
31035>>>>>>>>
31035>>>>>>>                End                                                       
31035>>>>>>>>
31035>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
31036>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
31037>>>>>>>            End
31037>>>>>>>>
31037>>>>>>>        End
31037>>>>>>>>
31037>>>>>>>
31037>>>>>>>        // Does the rootname contain a driver?
31037>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
31039>>>>>>>            // Does the table already exist as an SQL table?
31039>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
31040>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
31040>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
31040>>>>>>>            If (bExists = False) Begin
31042>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
31043>>>>>>>            End
31043>>>>>>>>
31043>>>>>>>            If (bExists = True) Begin
31045>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
31046>>>>>>>                Function_Return False
31047>>>>>>>            End
31047>>>>>>>>
31047>>>>>>>        End
31047>>>>>>>>
31047>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
31048>>>>>>>
31048>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
31049>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
31049>>>>>>>        // passed as True, we adjust for that here.
31049>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
31050>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
31052>>>>>>>            Move False to bUseConnectionID
31053>>>>>>>        End
31053>>>>>>>>
31053>>>>>>>
31053>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
31054>>>>>>>        Move SQLConnection.sSchema           to sSchema
31055>>>>>>>        If (sSchema = "") Begin
31057>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
31058>>>>>>>            Move (Lowercase(sSchema))        to sSchema
31059>>>>>>>        End
31059>>>>>>>>
31059>>>>>>>
31059>>>>>>>        If (sDriverID = ORAFLEX) Begin
31061>>>>>>>            Move SQLConnection.sUserID       to sSchema
31062>>>>>>>        End
31062>>>>>>>>
31062>>>>>>>
31062>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
31063>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
31064>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
31065>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
31067>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
31068>>>>>>>>
31068>>>>>>>            Function_Return False
31069>>>>>>>        End
31069>>>>>>>>
31069>>>>>>>
31069>>>>>>>        Get AutoConnectionIDLogin to bOK
31070>>>>>>>        Open hTable
31072>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
31075>>>>>>>        If (bOpened = False) Begin
31077>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
31078>>>>>>>>
31078>>>>>>>            Function_Return False
31079>>>>>>>        End
31079>>>>>>>>
31079>>>>>>>
31079>>>>>>>        If (ghoProgressBar <> 0) Begin
31081>>>>>>>            Send DoAdvance of ghoProgressBar
31082>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
31083>>>>>>>        End
31083>>>>>>>>
31083>>>>>>>
31083>>>>>>>        Move 0 to hToTable
31084>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
31085>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
31086>>>>>>>
31086>>>>>>>        Case Begin
31086>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
31088>>>>>>>                Case Break
31089>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
31092>>>>>>>                Case Break
31093>>>>>>>            Case (sDriverID = DB2_DRV_ID)
31096>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
31097>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
31098>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
31099>>>>>>>                Case Break
31100>>>>>>>            Case (sDriverID = ORAFLEX)
31103>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
31104>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
31105>>>>>>>                Case Break
31106>>>>>>>            Case (sDriverID = MDSMySQL)
31109>>>>>>>                Case Break
31110>>>>>>>            Case (sDriverID = MDSPgSQL)
31113>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
31114>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
31115>>>>>>>                Case Break
31116>>>>>>>            Case (sDriverID = DATAFLEX_ID)
31119>>>>>>>                Case Break
31120>>>>>>>            Case Else
31120>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
31121>>>>>>>>
31121>>>>>>>                Case Break
31122>>>>>>>        Case End
31122>>>>>>>
31122>>>>>>>        Move False to Err
31123>>>>>>>
31123>>>>>>>        If (bMertechDriver = True) Begin
31125>>>>>>>            // Note: This function also sets the Err flag.
31125>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
31126>>>>>>>        End
31126>>>>>>>>
31126>>>>>>>
31126>>>>>>>        If (bMertechDriver = False) Begin
31128>>>>>>>            Structure_Start hToTable sDriverID
31129>>>>>>>                Structure_Copy hTable to hToTable
31130>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
31133>>>>>>>
31133>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
31135>>>>>>>                    If (bUseConnectionID = True) Begin
31137>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
31140>>>>>>>                    End
31140>>>>>>>>
31140>>>>>>>                    Else Begin
31141>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
31144>>>>>>>                    End
31144>>>>>>>>
31144>>>>>>>
31144>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
31147>>>>>>>
31147>>>>>>>                    If (sSchema <> "") Begin
31149>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
31152>>>>>>>                    End
31152>>>>>>>>
31152>>>>>>>
31152>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
31154>>>>>>>                        If (sLongTableSpace <> "") Begin
31156>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
31159>>>>>>>                        End
31159>>>>>>>>
31159>>>>>>>                        If (sBaseTableSpace <> "") Begin
31161>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
31164>>>>>>>                        End
31164>>>>>>>>
31164>>>>>>>                        If (sIndexTableSpace <> "") Begin
31166>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
31169>>>>>>>                        End
31169>>>>>>>>
31169>>>>>>>                    End
31169>>>>>>>>
31169>>>>>>>                End
31169>>>>>>>>
31169>>>>>>>
31169>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
31170>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31172>>>>>>>            Set Action_Text of ghoStatusPanel to ""
31173>>>>>>>        End
31173>>>>>>>>
31173>>>>>>>
31173>>>>>>>        Move (not(Err)) to bOK
31174>>>>>>>
31174>>>>>>>        If (bOK = True and bCopyData = True) Begin
31176>>>>>>>            If (bMertechDriver = False) Begin
31178>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
31179>>>>>>>            End
31179>>>>>>>>
31179>>>>>>>            Else Begin
31180>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
31181>>>>>>>            End
31181>>>>>>>>
31181>>>>>>>
31181>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
31183>>>>>>>                Get pbContinueOnError to bContinueOnError
31184>>>>>>>            End
31184>>>>>>>>
31184>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
31184>>>>>>>            // rename it by adding a GUID to the end of the table name
31184>>>>>>>            // - or as much as "fit" because different SQL back-ends have
31184>>>>>>>            // different rules how long a table name can be.
31184>>>>>>>            // The new table will probably contain data but something went
31184>>>>>>>            // wrong while converting the data from embedded to SQL.
31184>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
31186>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
31187>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
31188>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
31189>>>>>>>>
31189>>>>>>>            End
31189>>>>>>>>
31189>>>>>>>        End
31189>>>>>>>>
31189>>>>>>>
31189>>>>>>>        // This must be after copying data...
31189>>>>>>>        If (Err = False) Begin
31191>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
31194>>>>>>>            // It seems the Studio does not do this any more, so commented out.
31194>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
31194>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
31194>>>>>>>            //                // The max length for the display_name is 31 characters...
31194>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
31194>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
31194>>>>>>>            //                End
31194>>>>>>>            //            End
31194>>>>>>>        End
31194>>>>>>>>
31194>>>>>>>
31194>>>>>>>        Close hTable
31195>>>>>>>        Move (not(Err)) to bOK
31196>>>>>>>        Function_Return bOK
31197>>>>>>>    End_Function
31198>>>>>>>
31198>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
31198>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
31198>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
31198>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
31200>>>>>>>        Boolean bOpened bOK
31200>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
31200>>>>>>>        String sErrorFile sEmpty sPath
31200>>>>>>>
31200>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
31203>>>>>>>        Get AutoConnectionIDLogin to bOK
31204>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
31206>>>>>>>            Send IncreaseSortBufferSize
31207>>>>>>>//            Send SetAllIndexesToBatch hToTable
31207>>>>>>>        End
31207>>>>>>>>
31207>>>>>>>
31207>>>>>>>        Move False to Err
31208>>>>>>>        Open sPhysicalName as hToTable
31210>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
31213>>>>>>>        If (bOpened = False) Begin
31215>>>>>>>            Function_Return False
31216>>>>>>>        End
31216>>>>>>>>
31216>>>>>>>
31216>>>>>>>        If (ghoStatusPanel <> 0) Begin
31218>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
31219>>>>>>>            Set piMinimum of ghoProgressBar to 0
31220>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
31221>>>>>>>        End
31221>>>>>>>>
31221>>>>>>>
31221>>>>>>>        Move "" to sEmpty
31222>>>>>>>        Move False to Err
31223>>>>>>>        Move True to bOK
31224>>>>>>>        Set Private.phCurrentTable to hToTable
31225>>>>>>>
31225>>>>>>>        // No need to get the record identifier
31225>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
31228>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31231>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31233>>>>>>>            // Remove all indices to speed up copying of data:
31233>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
31238>>>>>>>            If (iRetval <> 0) Begin       
31240>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
31241>>>>>>>>
31241>>>>>>>                Close hToTable
31242>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31245>>>>>>>                Function_Return False
31246>>>>>>>            End
31246>>>>>>>>
31246>>>>>>>        End
31246>>>>>>>>
31246>>>>>>>
31246>>>>>>>        Move (sRootName + ".err") to sErrorFile
31247>>>>>>>        Move 0 to iIndex
31248>>>>>>>        Move False to Err
31249>>>>>>>
31249>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
31251>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
31254>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
31259>>>>>>>            If (iRetval <> 0) Begin
31261>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
31262>>>>>>>>
31262>>>>>>>                Close hToTable
31263>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31266>>>>>>>                Function_Return False
31267>>>>>>>            End
31267>>>>>>>>
31267>>>>>>>        End
31267>>>>>>>>
31267>>>>>>>        Else Begin
31268>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
31271>>>>>>>        End
31271>>>>>>>>
31271>>>>>>>
31271>>>>>>>        If (Err = False) Begin
31273>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
31274>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
31275>>>>>>>        End
31275>>>>>>>>
31275>>>>>>>
31275>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31277>>>>>>>            // Recreate indices:
31277>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
31282>>>>>>>            If (iRetval <> 0) Begin
31284>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
31285>>>>>>>>
31285>>>>>>>                Close hToTable
31286>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31289>>>>>>>                Function_Return False
31290>>>>>>>            End
31290>>>>>>>>
31290>>>>>>>        End
31290>>>>>>>>
31290>>>>>>>
31290>>>>>>>        Close hToTable
31291>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
31294>>>>>>>
31294>>>>>>>        If (bOK = True) Begin
31296>>>>>>>            Move (not(Err)) to bOK
31297>>>>>>>        End
31297>>>>>>>>
31297>>>>>>>
31297>>>>>>>        If (ghoStatusPanel <> 0) Begin
31299>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
31300>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
31301>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
31302>>>>>>>        End
31302>>>>>>>>
31302>>>>>>>
31302>>>>>>>        Function_Return (bOK = True)
31303>>>>>>>    End_Function
31304>>>>>>>
31304>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
31304>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
31304>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
31306>>>>>>>        Handle hFile
31306>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
31306>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
31306>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
31306>>>>>>>        tSQLConnection SQLConnection
31306>>>>>>>        tSQLConnection SQLConnection
31306>>>>>>>        tAPIColumn[] aColumns
31306>>>>>>>        tAPIColumn[] aColumns
31307>>>>>>>        tColumnType ColumnType
31307>>>>>>>        tColumnType ColumnType
31307>>>>>>>
31307>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
31307>>>>>>>        Get UtilTableExists hTable to bOk
31308>>>>>>>        If (bOk = True) Begin
31310>>>>>>>            Function_Return False
31311>>>>>>>        End
31311>>>>>>>>
31311>>>>>>>
31311>>>>>>>        Set Private.phCurrentTable to hTable
31312>>>>>>>        Move sLogicalName to sTableName
31313>>>>>>>        If (ghoProgressBar <> 0) Begin
31315>>>>>>>            Send DoAdvance of ghoProgressBar
31316>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
31317>>>>>>>        End
31317>>>>>>>>
31317>>>>>>>
31317>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
31318>>>>>>>        Get psDriverID to sDriverID
31319>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
31320>>>>>>>        Get piDbType to iDbType
31321>>>>>>>
31321>>>>>>>        // If no columns passed in, we need to create a "dummy" column
31321>>>>>>>        Move False to bDeleteDummy
31322>>>>>>>        If (Num_Arguments = 8) Begin
31324>>>>>>>            Move aColumnIn to aColumns
31325>>>>>>>        End
31325>>>>>>>>
31325>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
31327>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
31328>>>>>>>            Move ColumnType.iSQLType to iDataType
31329>>>>>>>            If (bRecnum = False) Begin
31331>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
31332>>>>>>>            End
31332>>>>>>>>
31332>>>>>>>            Else Begin
31333>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
31334>>>>>>>            End
31334>>>>>>>>
31334>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
31335>>>>>>>            Move True to bDeleteDummy
31336>>>>>>>        End
31336>>>>>>>>
31336>>>>>>>
31336>>>>>>>        // If columns have been passed as an array we need to check if an identity column
31336>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
31336>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
31336>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
31336>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
31338>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
31339>>>>>>>            Decrement iSize
31340>>>>>>>            for iCount from 0 to iSize
31346>>>>>>>>
31346>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
31348>>>>>>>                    Move False to bRecnum
31349>>>>>>>                    Move iSize to iCount
31350>>>>>>>                End
31350>>>>>>>>
31350>>>>>>>            Loop
31351>>>>>>>>
31351>>>>>>>        End
31351>>>>>>>>
31351>>>>>>>
31351>>>>>>>        // If this is a SQL based driver we also check if the table exists
31351>>>>>>>        // in the SQL back end; in case we do nothing.
31351>>>>>>>        If (bSqlDriver = True) Begin
31353>>>>>>>            // Get all connection properties
31353>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
31354>>>>>>>            Move SQLConnection.sSchema to sSchema
31355>>>>>>>            If (sSchema = "") Begin
31357>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
31358>>>>>>>            End
31358>>>>>>>>
31358>>>>>>>
31358>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
31359>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
31359>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
31359>>>>>>>            If (bExists = False) Begin
31361>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
31362>>>>>>>            End
31362>>>>>>>>
31362>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
31362>>>>>>>            // we will just add it to Filelist.cfg
31362>>>>>>>            If (bExists = True) Begin
31364>>>>>>>                If (bExistsInFilelist = False) Begin
31366>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
31368>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
31369>>>>>>>                    End
31369>>>>>>>>
31369>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31372>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31375>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31378>>>>>>>                    Move False to bSysFile
31379>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
31380>>>>>>>                End
31380>>>>>>>>
31380>>>>>>>                Function_Return False
31381>>>>>>>            End
31381>>>>>>>>
31381>>>>>>>        End
31381>>>>>>>>
31381>>>>>>>
31381>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
31382>>>>>>>        If (num_arguments > 6) Begin
31384>>>>>>>            If (bANSI = False) Begin
31386>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
31387>>>>>>>            End
31387>>>>>>>>
31387>>>>>>>        End
31387>>>>>>>>
31387>>>>>>>
31387>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
31387>>>>>>>        // is a programmer's error and we auto-correct for it here.
31387>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
31387>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
31387>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
31387>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
31387>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
31388>>>>>>>        If (bMertechDriver = True) Begin
31390>>>>>>>            If (bUseConnectionID = True) Begin
31392>>>>>>>                Move False to bUseConnectionID
31393>>>>>>>            End
31393>>>>>>>>
31393>>>>>>>            Move sDriverID to sOriginalDriverID
31394>>>>>>>            Move DATAFLEX_ID to sDriverID
31395>>>>>>>        End
31395>>>>>>>>
31395>>>>>>>
31395>>>>>>>        Move False to Err
31396>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
31398>>>>>>>            Move sRootName to sPhysicalFile
31399>>>>>>>        End
31399>>>>>>>>
31399>>>>>>>
31399>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31401>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
31402>>>>>>>
31402>>>>>>>            // If DAW driver and we should use a connection id we need to
31402>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
31402>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
31404>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
31405>>>>>>>                If (bExists = False) Begin
31407>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
31408>>>>>>>                    If (bOk = False) Begin
31410>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
31411>>>>>>>>
31411>>>>>>>                        Function_Return False
31412>>>>>>>                    End
31412>>>>>>>>
31412>>>>>>>                End
31412>>>>>>>>
31412>>>>>>>            End
31412>>>>>>>>
31412>>>>>>>
31412>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
31414>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
31415>>>>>>>            End
31415>>>>>>>>
31415>>>>>>>            Else Begin
31416>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
31417>>>>>>>            End
31417>>>>>>>>
31417>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
31418>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
31418>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
31418>>>>>>>//            End
31418>>>>>>>        End
31418>>>>>>>>
31418>>>>>>>        Move False to Err
31419>>>>>>>        Move 0 to hFile
31420>>>>>>>
31420>>>>>>>        Structure_Start hFile sDriverID
31421>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
31423>>>>>>>                If (bUseConnectionID = True) Begin
31425>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
31428>>>>>>>                End
31428>>>>>>>>
31428>>>>>>>                Else Begin
31429>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
31432>>>>>>>                End
31432>>>>>>>>
31432>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
31435>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
31438>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
31441>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
31444>>>>>>>
31444>>>>>>>                If (sSchema <> "") Begin
31446>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
31449>>>>>>>                End
31449>>>>>>>>
31449>>>>>>>
31449>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
31451>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
31453>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
31456>>>>>>>                    End
31456>>>>>>>>
31456>>>>>>>                End
31456>>>>>>>>
31456>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
31458>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
31460>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
31463>>>>>>>                    End
31463>>>>>>>>
31463>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
31465>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
31468>>>>>>>                    End
31468>>>>>>>>
31468>>>>>>>                End
31468>>>>>>>>
31468>>>>>>>            End
31468>>>>>>>>
31468>>>>>>>
31468>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
31471>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
31472>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31473>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31475>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31476>>>>>>>
31476>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
31476>>>>>>>        If (bMertechDriver = True) Begin
31478>>>>>>>            Move sOriginalDriverID to sDriverID
31479>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
31481>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
31482>>>>>>>            End
31482>>>>>>>>
31482>>>>>>>            // Note: This function also sets the Err flag.
31482>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
31482>>>>>>>        End
31482>>>>>>>>
31482>>>>>>>
31482>>>>>>>        Move (not(Err)) to bOK
31483>>>>>>>        If (bOk = True) Begin
31485>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
31487>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
31488>>>>>>>            End
31488>>>>>>>>
31488>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31491>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31494>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31497>>>>>>>
31497>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
31497>>>>>>>            If (bDeleteDummy) Begin
31499>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
31500>>>>>>>            End
31500>>>>>>>>
31500>>>>>>>        End
31500>>>>>>>>
31500>>>>>>>
31500>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
31501>>>>>>>        Close hTable
31502>>>>>>>        Function_Return (bOK = True)
31503>>>>>>>    End_Function
31504>>>>>>>
31504>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
31506>>>>>>>        Move False to Err
31507>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
31510>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
31513>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
31516>>>>>>>
31516>>>>>>>        Function_Return (Err = False)
31517>>>>>>>    End_Function
31518>>>>>>>
31518>>>>>>>    // ToDo: Needs to be revised
31518>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
31520>>>>>>>        Handle hTable
31520>>>>>>>        String sDEFName sDataPath
31520>>>>>>>        Boolean bExists
31520>>>>>>>
31520>>>>>>>        // Do nothing if MSSQL Driver.
31520>>>>>>>//        Get IsMSSQLDriver to bExists
31520>>>>>>>//        If (bExists = True) Begin
31520>>>>>>>//            Procedure_Return
31520>>>>>>>//        End
31520>>>>>>>
31520>>>>>>>        Get psDataPathFirstPart to sDataPath
31521>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
31522>>>>>>>        If (bExists = True) Begin
31524>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
31524>>>>>>>            // still be missing from the filelist and needs to be added.
31524>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
31525>>>>>>>            If (bExists = True) Begin
31527>>>>>>>                Procedure_Return
31528>>>>>>>            End
31528>>>>>>>>
31528>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
31528>>>>>>>            Else Begin
31529>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
31532>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
31535>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
31538>>>>>>>                Procedure_Return
31539>>>>>>>            End
31539>>>>>>>>
31539>>>>>>>        End
31539>>>>>>>>
31539>>>>>>>
31539>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
31540>>>>>>>        Move 0 to hTable
31541>>>>>>>        Move False to Err
31542>>>>>>>
31542>>>>>>>        Structure_Start hTable DATAFLEX_ID
31543>>>>>>>            Load_Def sDEFName Onto hTable
31544>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
31547>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31548>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31550>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31551>>>>>>>
31551>>>>>>>        Move iFilelistSlot to hTable
31552>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
31555>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
31558>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
31561>>>>>>>
31561>>>>>>>    End_Procedure
31562>>>>>>>
31562>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
31564>>>>>>>        Boolean bTmp bErr bOK
31564>>>>>>>        String sTableName sDisplayName sFileName
31564>>>>>>>
31564>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
31564>>>>>>>        Move Err to bTmp
31565>>>>>>>        Move False to Err
31566>>>>>>>
31566>>>>>>>        Get AutoConnectionIDLogin to bOK
31567>>>>>>>        // First get the info for the current filelist slot:
31567>>>>>>>        Open iFromFileSlot
31569>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
31572>>>>>>>        If (bOK = True) Begin
31574>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
31577>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
31580>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
31583>>>>>>>
31583>>>>>>>            //...then move it.
31583>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
31586>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
31589>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
31592>>>>>>>
31592>>>>>>>            //...and finally remove the old filelist values.
31592>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
31595>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
31598>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
31601>>>>>>>        End
31601>>>>>>>>
31601>>>>>>>        Close iFromFileSlot
31602>>>>>>>
31602>>>>>>>        Move Err to bErr
31603>>>>>>>        Move bTmp to Err
31604>>>>>>>        Function_Return (bErr = False)
31605>>>>>>>    End_Function
31606>>>>>>>
31606>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
31608>>>>>>>        Handle hTable
31608>>>>>>>        Boolean bOK
31608>>>>>>>        String sDriverID
31608>>>>>>>
31608>>>>>>>        Get UtilTableExists hTableFrom to bOK
31609>>>>>>>        If (bOK = False) Begin
31611>>>>>>>            Set Private.phCurrentTable to hTableFrom
31612>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
31613>>>>>>>>
31613>>>>>>>            Function_Return False
31614>>>>>>>        End
31614>>>>>>>>
31614>>>>>>>
31614>>>>>>>        Get UtilTableExists hTableTo to bOK
31615>>>>>>>        If (bOK = False) Begin
31617>>>>>>>            Set Private.phCurrentTable to hTableTo
31618>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
31619>>>>>>>>
31619>>>>>>>            Function_Return False
31620>>>>>>>        End
31620>>>>>>>>
31620>>>>>>>
31620>>>>>>>        Get AutoConnectionIDLogin to bOK
31621>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
31622>>>>>>>        If (bOK = False) Begin
31624>>>>>>>            Function_Return False
31625>>>>>>>        End
31625>>>>>>>>
31625>>>>>>>
31625>>>>>>>        Move False to Err
31626>>>>>>>        Open hTableTo
31628>>>>>>>
31628>>>>>>>        Move hTableFrom to hTable
31629>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
31632>>>>>>>        Set Private.phCurrentTable to hTable
31633>>>>>>>
31633>>>>>>>        Structure_Start hTable sDriverID
31634>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
31637>>>>>>>            If (iColumnTo <> 0) Begin
31639>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
31642>>>>>>>            End
31642>>>>>>>>
31642>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31643>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31645>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31646>>>>>>>
31646>>>>>>>        If (hTableTo > 0) Begin
31648>>>>>>>            Close hTableTo
31649>>>>>>>        End
31649>>>>>>>>
31649>>>>>>>
31649>>>>>>>        Function_Return (Err = False)
31650>>>>>>>    End_Function
31651>>>>>>>
31651>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
31651>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
31653>>>>>>>        String sTableName sDriverID
31653>>>>>>>        Boolean bOk
31653>>>>>>>        String sDataPath
31653>>>>>>>
31653>>>>>>>        Get AutoConnectionIDLogin to bOK
31654>>>>>>>        Move False to Err
31655>>>>>>>        Get psDriverID to sDriverID
31656>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
31657>>>>>>>        If (sTableName = "") Begin
31659>>>>>>>            Function_Return False
31660>>>>>>>        End
31660>>>>>>>>
31660>>>>>>>
31660>>>>>>>        Set Private.phCurrentTable to hTable
31661>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
31662>>>>>>>        Delete_db sTableName
31663>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
31664>>>>>>>
31664>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31666>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
31666>>>>>>>            Get psDataPathFirstPart to sDataPath
31667>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
31668>>>>>>>        End
31668>>>>>>>>
31668>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
31668>>>>>>>        If (hTable <> 0) Begin
31670>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
31673>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
31676>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
31679>>>>>>>        End
31679>>>>>>>>
31679>>>>>>>
31679>>>>>>>        Close hTable
31680>>>>>>>        Function_Return (hTable <> 0)
31681>>>>>>>    End_Function
31682>>>>>>>
31682>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
31684>>>>>>>        Handle hTable
31684>>>>>>>        Boolean bOK
31684>>>>>>>
31684>>>>>>>        Get AutoConnectionIDLogin to bOK
31685>>>>>>>        Move False to Err
31686>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
31688>>>>>>>        Move hTableFrom to hTable
31689>>>>>>>
31689>>>>>>>        Structure_Start hTable
31690>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
31693>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31694>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
31696>>>>>>>        Set Action_Text of ghoStatusPanel to ""
31697>>>>>>>
31697>>>>>>>        Close hTableFrom
31698>>>>>>>        Function_Return (Err = False)
31699>>>>>>>    End_Function
31700>>>>>>>
31700>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
31702>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
31702>>>>>>>        Boolean bOK bExists bOpened
31702>>>>>>>        tAPITableNameInfo APITableNameInfo
31702>>>>>>>        tAPITableNameInfo APITableNameInfo
31702>>>>>>>
31702>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
31705>>>>>>>        If (bOpened = False) Begin
31707>>>>>>>            Get OpenTableExclusive hTable to bOpened
31708>>>>>>>            If (bOpened = False) Begin
31710>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
31711>>>>>>>                Function_Return False
31712>>>>>>>            End
31712>>>>>>>>
31712>>>>>>>        End
31712>>>>>>>>
31712>>>>>>>
31712>>>>>>>        Set Private.phCurrentTable to hTable
31713>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
31714>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
31715>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
31716>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
31717>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
31718>>>>>>>        If (bExists = True) Begin
31720>>>>>>>            Function_Return True
31721>>>>>>>        End
31721>>>>>>>>
31721>>>>>>>
31721>>>>>>>        Set Private.phCurrentTable to hTable
31722>>>>>>>        Move False to Err
31723>>>>>>>        Get psDataPathFirstPart to sDataPath
31724>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
31727>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
31730>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
31733>>>>>>>
31733>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
31736>>>>>>>        Close hTable
31737>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
31739>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
31740>>>>>>>            If (bExists = True) Begin
31742>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
31744>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
31747>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
31747>>>>>>>                    // might report "File in use..." and the deletion will fail.
31747>>>>>>>                    Sleep 2
31748>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
31749>>>>>>>                End
31749>>>>>>>>
31749>>>>>>>            End
31749>>>>>>>>
31749>>>>>>>        End
31749>>>>>>>>
31749>>>>>>>
31749>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
31751>>>>>>>            If (not(sPhysicalName contains ".")) Begin
31753>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
31754>>>>>>>            End
31754>>>>>>>>
31754>>>>>>>
31754>>>>>>>            // Change the table name in the .int file to the new table new:
31754>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
31755>>>>>>>            If (bOK = False) Begin
31757>>>>>>>                Function_Return False
31758>>>>>>>            End
31758>>>>>>>>
31758>>>>>>>
31758>>>>>>>            // Change table name at the SQL side:
31758>>>>>>>            Get psSchema to sSchema
31759>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
31760>>>>>>>
31760>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
31761>>>>>>>            // Remove cache file and Rename the physical file names:
31761>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
31762>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
31763>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
31764>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
31765>>>>>>>
31765>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
31765>>>>>>>//            If (not(sDisplayName contains ".")) Begin
31765>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
31765>>>>>>>//            End
31765>>>>>>>        End
31765>>>>>>>>
31765>>>>>>>
31765>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
31768>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31771>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31774>>>>>>>
31774>>>>>>>        Function_Return (Err = False)
31775>>>>>>>    End_Function
31776>>>>>>>
31776>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
31778>>>>>>>        Move False to Err
31779>>>>>>>        Set Private.phCurrentTable to hTable
31780>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
31783>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
31786>>>>>>>
31786>>>>>>>        Function_Return (Err = False)
31787>>>>>>>    End_Function
31788>>>>>>>
31788>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
31788>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
31788>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
31790>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
31790>>>>>>>        Handle hTable
31790>>>>>>>        Boolean bIsSame
31790>>>>>>>
31790>>>>>>>        Move APITableInfo.iTableNumber      to hTable
31791>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
31792>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
31795>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
31796>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
31799>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
31802>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
31803>>>>>>>
31803>>>>>>>        If (bCompareFilelistUppercase = True) Begin
31805>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
31806>>>>>>>        End
31806>>>>>>>>
31806>>>>>>>        Else Begin
31807>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
31808>>>>>>>        End
31808>>>>>>>>
31808>>>>>>>
31808>>>>>>>        Function_Return bIsSame
31809>>>>>>>    End_Function
31810>>>>>>>
31810>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
31810>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
31812>>>>>>>        Handle hTable
31812>>>>>>>        String sTableName
31812>>>>>>>        String sDriverIDFrom sDriverIDTo
31812>>>>>>>        Integer iDbType
31812>>>>>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
31812>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
31812>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
31812>>>>>>>        tSQLConnection SQLConnection
31812>>>>>>>        tSQLConnection SQLConnection
31812>>>>>>>        tAPITable      APITableFrom APITableTo
31812>>>>>>>        tAPITable      APITableFrom APITableTo
31812>>>>>>>        tColumnType    ColumnType
31812>>>>>>>        tColumnType    ColumnType
31812>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
31812>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
31813>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
31813>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
31814>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
31814>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
31815>>>>>>>
31815>>>>>>>        // We don't allow changes to the framework's DbVersion table.
31815>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
31817>>>>>>>            Function_Return False
31818>>>>>>>        End
31818>>>>>>>>
31818>>>>>>>
31818>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
31819>>>>>>>        Get piDbType                            to iDbType
31820>>>>>>>        Get pbRecnum                            to bRecnum
31821>>>>>>>        Get pbToANSI                            to bToANSI
31822>>>>>>>        Get pbCopyData                          to bCopyData
31823>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
31824>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
31825>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
31826>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
31827>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
31828>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
31829>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
31831>>>>>>>            Move False                          to bUseConnectionID
31832>>>>>>>        End
31832>>>>>>>>
31832>>>>>>>
31832>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
31833>>>>>>>        Set Private.phCurrentTable              to hTable
31834>>>>>>>        Get UtilTableExists  hTable             to bTableExists
31835>>>>>>>
31835>>>>>>>        If (ghoProgressBar <> 0) Begin
31837>>>>>>>            Send DoAdvance of ghoProgressBar
31838>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
31839>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
31840>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
31841>>>>>>>        End
31841>>>>>>>>
31841>>>>>>>
31841>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
31842>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
31843>>>>>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
31844>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
31845>>>>>>>        Move True                               to APITableFrom.bFromTable
31846>>>>>>>        Move hTable                             to APITableFrom.hTable
31847>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
31848>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
31849>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
31850>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
31851>>>>>>>
31851>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
31853>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
31854>>>>>>>            If (bOk = True) Begin
31856>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
31857>>>>>>>                Function_Return bOk
31858>>>>>>>            End 
31858>>>>>>>>
31858>>>>>>>        End
31858>>>>>>>>
31858>>>>>>>
31858>>>>>>>        If (bTableExists = True) Begin
31860>>>>>>>            If (bIsSQLTableTo = True) Begin
31862>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
31863>>>>>>>            End
31863>>>>>>>>
31863>>>>>>>
31863>>>>>>>            Get OpenTableExclusive hTable to bOpened
31864>>>>>>>            If (bOpened = False) Begin
31866>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
31867>>>>>>>                Function_Return False
31868>>>>>>>            End
31868>>>>>>>>
31868>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
31869>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
31870>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
31871>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
31872>>>>>>>        End
31872>>>>>>>>
31872>>>>>>>
31872>>>>>>>        Move False to Err
31873>>>>>>>        Case Begin
31873>>>>>>>            // Alias table:
31873>>>>>>>            Case (bIsAliasFrom = True)
31875>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
31876>>>>>>>                Case Break
31877>>>>>>>
31877>>>>>>>            // New Table:
31877>>>>>>>            Case (bTableExists = False)
31880>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
31881>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
31881>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
31883>>>>>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
31884>>>>>>>                End                                                                 
31884>>>>>>>>
31884>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
31885>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
31886>>>>>>>                Case Break
31887>>>>>>>
31887>>>>>>>            // Update table:
31887>>>>>>>            Case (bTableExists = True)
31890>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
31891>>>>>>>                If (bIsSame = True) Begin
31893>>>>>>>                    Case Break
31894>>>>>>>                End
31894>>>>>>>>
31894>>>>>>>                If (bFilelistError = True) Begin
31896>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
31897>>>>>>>                    If (bOk = False) Begin
31899>>>>>>>                        Case Break
31900>>>>>>>                    End
31900>>>>>>>>
31900>>>>>>>                End
31900>>>>>>>>
31900>>>>>>>
31900>>>>>>>                If (ghoProgressBar <> 0) Begin
31902>>>>>>>                    Send DoAdvance of ghoProgressBar
31903>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
31904>>>>>>>                End
31904>>>>>>>>
31904>>>>>>>
31904>>>>>>>                // Columns:
31904>>>>>>>                Move True to bOk
31905>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
31906>>>>>>>                If (bIsSame = False) Begin
31908>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
31909>>>>>>>                End
31909>>>>>>>>
31909>>>>>>>                If (bOk = False) Begin
31911>>>>>>>                    Case Break
31912>>>>>>>                End
31912>>>>>>>>
31912>>>>>>>
31912>>>>>>>                // Indexes:
31912>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
31913>>>>>>>                If (bIsSame = False) Begin
31915>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
31916>>>>>>>                End
31916>>>>>>>>
31916>>>>>>>
31916>>>>>>>                // Relations:
31916>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
31917>>>>>>>                If (bIsSame = False) Begin
31919>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
31920>>>>>>>                    If (bOk = False) Begin
31922>>>>>>>                        Case Break
31923>>>>>>>                    End
31923>>>>>>>>
31923>>>>>>>                End
31923>>>>>>>>
31923>>>>>>>
31923>>>>>>>                Case Break
31924>>>>>>>
31924>>>>>>>            Case Else
31924>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
31925>>>>>>>>
31925>>>>>>>                Move False to bOk
31926>>>>>>>        Case End
31926>>>>>>>        
31926>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
31926>>>>>>>        // or convert an embedded table to SQL
31926>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
31928>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
31929>>>>>>>            If (bOk = False) Begin
31931>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
31932>>>>>>>            End
31932>>>>>>>>
31932>>>>>>>        End
31932>>>>>>>>
31932>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
31935>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
31936>>>>>>>        End
31936>>>>>>>>
31936>>>>>>>        
31936>>>>>>>        // Filelist Names:
31936>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
31937>>>>>>>        Close hTable
31938>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
31939>>>>>>>
31939>>>>>>>        Function_Return (bOK = True)
31940>>>>>>>    End_Function
31941>>>>>>>
31941>>>>>>>    // * Dummy function for the Studio's Code Explorer *
31941>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
31943>>>>>>>        Function_Return False
31944>>>>>>>    End_Function
31945>>>>>>>
31945>>>>>>>    // Adds a column name to the passed table number.
31945>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
31947>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
31947>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
31947>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
31947>>>>>>>
31947>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
31948>>>>>>>        If (bExists = True) Begin
31950>>>>>>>            Function_Return False
31951>>>>>>>        End
31951>>>>>>>>
31951>>>>>>>
31951>>>>>>>        Move False to Err
31952>>>>>>>        If (num_arguments > 4) Begin
31954>>>>>>>            Move iPrec to iPrecision
31955>>>>>>>        End
31955>>>>>>>>
31955>>>>>>>        If (num_arguments > 6) Begin
31957>>>>>>>            Move bInitVal to bInitializeValue
31958>>>>>>>            Move sColVal  to sColumnValue
31959>>>>>>>        End
31959>>>>>>>>
31959>>>>>>>        If (iType < -1490) Begin
31961>>>>>>>            Move (iType + 1500) to iType
31962>>>>>>>        End
31962>>>>>>>>
31962>>>>>>>
31962>>>>>>>        Move hTable to iFile
31963>>>>>>>        Get psDriverID to sDriverID
31964>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
31965>>>>>>>        Get AutoConnectionIDLogin to bOK
31966>>>>>>>        Move False to Err
31967>>>>>>>        Move LastErr to iLastErr
31968>>>>>>>        Open iFile Mode DF_EXCLUSIVE
31970>>>>>>>        Set Private.phCurrentTable to hTable
31971>>>>>>>        Structure_Start iFile sDriverID
31972>>>>>>>            Move 0 to iColumn
31973>>>>>>>            Set Private.piCurrentField to iColumn
31974>>>>>>>            Create_Field hTable At iColumn
31975>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
31978>>>>>>>            If (bMertechDriver = True) Begin
31980>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
31981>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
31982>>>>>>>            End
31982>>>>>>>>
31982>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
31985>>>>>>>            If (bMertechDriver = True) Begin
31987>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
31988>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
31989>>>>>>>                Move False to Err
31990>>>>>>>                Move iLastErr to LastErr
31991>>>>>>>            End
31991>>>>>>>>
31991>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
31994>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
31997>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
31998>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32000>>>>>>>
32000>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32001>>>>>>>
32001>>>>>>>        // If in development environment; create .fd file:
32001>>>>>>>        Open hTable
32003>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
32004>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32005>>>>>>>        If (iCount > 1) Begin
32007>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32008>>>>>>>        End
32008>>>>>>>>
32008>>>>>>>        Get vFolderExists sDDSrcPath to bExists
32009>>>>>>>        If (bExists = True) Begin
32011>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
32012>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
32015>>>>>>>            Get _TableNameOnly sTableName to sTableName
32016>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32018>>>>>>>        End
32018>>>>>>>>
32018>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
32020>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
32021>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
32022>>>>>>>            If (iCount > 1) Begin
32024>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
32025>>>>>>>            End
32025>>>>>>>>
32025>>>>>>>            Get vFolderFormat sDataPath to sDataPath
32026>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
32026>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
32026>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
32026>>>>>>>        End
32026>>>>>>>>
32026>>>>>>>        // Check for a default value
32026>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
32028>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
32029>>>>>>>        End
32029>>>>>>>>
32029>>>>>>>        Close hTable
32030>>>>>>>
32030>>>>>>>        Function_Return (Err = False)
32031>>>>>>>    End_Function
32032>>>>>>>
32032>>>>>>>    // Adds a column name to the passed table number.
32032>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
32034>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
32034>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
32034>>>>>>>        String sDdSrcPath sTableName
32034>>>>>>>
32034>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
32035>>>>>>>        Move False to Err
32036>>>>>>>        If (bExists = True) Begin
32038>>>>>>>            Function_Return False
32039>>>>>>>        End
32039>>>>>>>>
32039>>>>>>>        If (num_arguments > 4) Begin
32041>>>>>>>            Move iPrec to iPrecision
32042>>>>>>>        End
32042>>>>>>>>
32042>>>>>>>        If (iType < -1490) Begin
32044>>>>>>>            Move (iType + 1500) to iType
32045>>>>>>>        End
32045>>>>>>>>
32045>>>>>>>
32045>>>>>>>        Get AutoConnectionIDLogin to bOK
32046>>>>>>>        Move False to Err
32047>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
32048>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
32048>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
32048>>>>>>>        Get piDbType to iDbType
32049>>>>>>>        If (bIsSQLTypeTo = False) Begin
32051>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
32052>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32054>>>>>>>                Move DF_DATE to iType
32055>>>>>>>            End
32055>>>>>>>>
32055>>>>>>>        End
32055>>>>>>>>
32055>>>>>>>
32055>>>>>>>        // Structure_start will change the value of hTable...
32055>>>>>>>        Move hTable to iFile
32056>>>>>>>        Get OpenTableExclusive iFile to bOK
32057>>>>>>>        If (bOK = False) Begin
32059>>>>>>>            Function_Return False
32060>>>>>>>        End
32060>>>>>>>>
32060>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
32063>>>>>>>
32063>>>>>>>        // If the passed column number is higher than the current number of fields
32063>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
32063>>>>>>>        // a new field to the end:
32063>>>>>>>        If (iColumn > iNumberOfFields) Begin
32065>>>>>>>            Move 0 to iColumn
32066>>>>>>>        End
32066>>>>>>>>
32066>>>>>>>
32066>>>>>>>        Set Private.phCurrentTable to hTable
32067>>>>>>>        Set Private.piCurrentField to iColumn
32068>>>>>>>
32068>>>>>>>        Structure_Start iFile
32069>>>>>>>            Create_Field iFile At iColumn
32070>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
32073>>>>>>>            If (bIsSQLTypeTo = False) Begin
32075>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
32078>>>>>>>            End
32078>>>>>>>>
32078>>>>>>>            Else Begin
32079>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
32082>>>>>>>            End
32082>>>>>>>>
32082>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
32083>>>>>>>            If (bIsDateType = False) Begin
32085>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
32088>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
32091>>>>>>>            End
32091>>>>>>>>
32091>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32092>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32094>>>>>>>
32094>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32095>>>>>>>        // If in development environment; create .fd file:
32095>>>>>>>        Open hTable
32097>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
32098>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32099>>>>>>>        If (iCount > 1) Begin
32101>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32102>>>>>>>        End
32102>>>>>>>>
32102>>>>>>>        Get vFolderExists sDDSrcPath to bExists
32103>>>>>>>        If (bExists = True) Begin
32105>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
32106>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
32109>>>>>>>            Get _TableNameOnly sTableName to sTableName
32110>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32112>>>>>>>        End
32112>>>>>>>>
32112>>>>>>>
32112>>>>>>>        // Check for a default value
32112>>>>>>>        Close hTable
32113>>>>>>>
32113>>>>>>>        Function_Return (Err = False)
32114>>>>>>>    End_Function
32115>>>>>>>
32115>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
32115>>>>>>>//        Integer iColumn iCount iFile
32115>>>>>>>//        Boolean bExists bOK
32115>>>>>>>//        String sDdSrcPath sTableName
32115>>>>>>>//
32115>>>>>>>//        Get AutoConnectionIDLogin to bOK
32115>>>>>>>//        Move False to Err
32115>>>>>>>//
32115>>>>>>>//        // Structure_start will change the value of hTable...
32115>>>>>>>//        Move hTable to iFile
32115>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
32115>>>>>>>//
32115>>>>>>>//        Structure_Start iFile
32115>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
32115>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32115>>>>>>>//
32115>>>>>>>//        // If in development environment; create .fd file:
32115>>>>>>>//        Open hTable
32115>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
32115>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32115>>>>>>>//        If (iCount > 1) Begin
32115>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32115>>>>>>>//        End
32115>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
32115>>>>>>>//        If (bExists = True) Begin
32115>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
32115>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
32115>>>>>>>//            Get _TableNameOnly sTableName to sTableName
32115>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32115>>>>>>>//        End
32115>>>>>>>//        Close hTable
32115>>>>>>>//
32115>>>>>>>//        Function_Return (Err = False)
32115>>>>>>>//    End_Function
32115>>>>>>>
32115>>>>>>>    // To update all records for a table column with a fixed value.
32115>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
32117>>>>>>>        Integer iRecs iCurrErr iField iRecord
32117>>>>>>>        Boolean bRetval bOpen
32117>>>>>>>
32117>>>>>>>        Move 0 to iRecs
32118>>>>>>>        Move False to bRetval
32119>>>>>>>        Move Err to iCurrErr
32120>>>>>>>        Move False to Err
32121>>>>>>>
32121>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
32124>>>>>>>        If (bOpen = False) Begin
32126>>>>>>>            Open hTable
32128>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
32131>>>>>>>            If (bOpen = False) Begin
32133>>>>>>>                Function_Return bRetval
32134>>>>>>>            End
32134>>>>>>>>
32134>>>>>>>        End
32134>>>>>>>>
32134>>>>>>>
32134>>>>>>>        Field_Map hTable sFieldName to iField
32136>>>>>>>        If (iField <> 0) Begin
32138>>>>>>>            Set Private.phCurrentTable to hTable
32139>>>>>>>            Set Private.piCurrentField to iField
32140>>>>>>>            Clear hTable
32141>>>>>>>            Repeat
32141>>>>>>>>
32141>>>>>>>                Vfind hTable 0 GT
32143>>>>>>>                If (Found) Begin
32145>>>>>>>                    If (ghoStatusPanel <> 0) Begin
32147>>>>>>>                        Get_Field_Value hTable 0 to iRecord
32150>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
32151>>>>>>>                    End
32151>>>>>>>>
32151>>>>>>>                    Reread hTable
32155>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
32158>>>>>>>                        SaveRecord hTable
32159>>>>>>>                    Unlock
32160>>>>>>>>
32160>>>>>>>                End
32160>>>>>>>>
32160>>>>>>>           Until (not(Found))
32162>>>>>>>        End
32162>>>>>>>>
32162>>>>>>>
32162>>>>>>>        Move (Err = False) to bRetval
32163>>>>>>>        Move iCurrErr to Err
32164>>>>>>>
32164>>>>>>>        Function_Return bRetval
32165>>>>>>>    End_Function
32166>>>>>>>
32166>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
32166>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
32168>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
32168>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
32168>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
32168>>>>>>>
32168>>>>>>>//        Set Private.phCurrentTable to hTable
32168>>>>>>>        Get psDriverID to sDriverID
32169>>>>>>>        Get piDbType to iDbType
32170>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32171>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
32172>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
32173>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
32174>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
32176>>>>>>>            Move True to bIsSqlTable
32177>>>>>>>        End
32177>>>>>>>>
32177>>>>>>>        Move False to bIsOpen
32178>>>>>>>        If (hTable > 0) Begin
32180>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
32183>>>>>>>        End
32183>>>>>>>>
32183>>>>>>>        If (bIsOpen = True) Begin
32185>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
32188>>>>>>>        End
32188>>>>>>>>
32188>>>>>>>        Else Begin
32189>>>>>>>            Get pbRecnum to bRecnumTable
32190>>>>>>>        End
32190>>>>>>>>
32190>>>>>>>
32190>>>>>>>        Move False to Err
32191>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
32192>>>>>>>        Decrement iSize
32193>>>>>>>        for iCount from 0 to iSize
32199>>>>>>>>
32199>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
32200>>>>>>>            If (hTable > 0) Begin
32202>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32203>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32204>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
32207>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
32208>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
32209>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32210>>>>>>>            End
32210>>>>>>>>
32210>>>>>>>            Else Begin
32211>>>>>>>                Move False to bFieldExists
32212>>>>>>>            End
32212>>>>>>>>
32212>>>>>>>
32212>>>>>>>            If (bFieldExists = False) Begin
32214>>>>>>>                Move 0 to iColumn
32215>>>>>>>                Create_Field hTable At iColumn
32216>>>>>>>            End
32216>>>>>>>>
32216>>>>>>>            Else Begin
32217>>>>>>>                Move iCount to iColumn
32218>>>>>>>            End
32218>>>>>>>>
32218>>>>>>>
32218>>>>>>>            Set Private.piCurrentField to iColumn
32219>>>>>>>
32219>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
32220>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
32223>>>>>>>
32223>>>>>>>            Move aColumns[iCount].iType to iType
32224>>>>>>>            Move (not(iType < -1490)) to bNativeType
32225>>>>>>>            If (iType < -1490) Begin
32227>>>>>>>                Move (iType + 1500) to iType
32228>>>>>>>            End
32228>>>>>>>>
32228>>>>>>>
32228>>>>>>>            If (bIsSqlTable = True) Begin
32230>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
32232>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
32233>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
32236>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
32239>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
32242>>>>>>>
32242>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
32243>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
32245>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
32246>>>>>>>                    End
32246>>>>>>>>
32246>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
32249>>>>>>>
32249>>>>>>>                End
32249>>>>>>>>
32249>>>>>>>                Else Begin
32250>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
32253>>>>>>>                End
32253>>>>>>>>
32253>>>>>>>            End
32253>>>>>>>>
32253>>>>>>>            Else Begin
32254>>>>>>>                If (bCreating = False) Begin
32256>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
32257>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32259>>>>>>>                        Move DF_DATE to iType
32260>>>>>>>                    End
32260>>>>>>>>
32260>>>>>>>                End
32260>>>>>>>>
32260>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
32263>>>>>>>            End
32263>>>>>>>>
32263>>>>>>>
32263>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
32264>>>>>>>            If (bIsDateType = False) Begin
32266>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
32269>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
32272>>>>>>>            End
32272>>>>>>>>
32272>>>>>>>
32272>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
32274>>>>>>>                Move 0 to iIndex
32275>>>>>>>                Create_Index hTable at iIndex
32276>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
32279>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
32282>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
32285>>>>>>>
32285>>>>>>>                // If we have an identity table - we must create a primary_key table.
32285>>>>>>>                If (bIsSqlTable = True) Begin
32287>>>>>>>                End
32287>>>>>>>>
32287>>>>>>>            End
32287>>>>>>>>
32287>>>>>>>        Loop
32288>>>>>>>>
32288>>>>>>>
32288>>>>>>>        Function_Return (Err = False)
32289>>>>>>>    End_Function
32290>>>>>>>
32290>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
32290>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
32292>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
32292>>>>>>>        Boolean bOK bIsSqlTable
32292>>>>>>>        String sFieldNameTo
32292>>>>>>>
32292>>>>>>>        If (num_arguments > 4) Begin
32294>>>>>>>            Move iPrec to iPrecFrom
32295>>>>>>>        End
32295>>>>>>>>
32295>>>>>>>        If (iTypeFrom < -1490) Begin
32297>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
32298>>>>>>>        End
32298>>>>>>>>
32298>>>>>>>
32298>>>>>>>        Get AutoConnectionIDLogin to bOK
32299>>>>>>>        Move False to Err
32300>>>>>>>        Get OpenTableExclusive hTable to bOK
32301>>>>>>>        If (bOK = False) Begin
32303>>>>>>>            Function_Return False
32304>>>>>>>        End
32304>>>>>>>>
32304>>>>>>>
32304>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32305>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32306>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
32308>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32309>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32310>>>>>>>        If (Err = True) Begin
32312>>>>>>>            Function_Return False
32313>>>>>>>        End
32313>>>>>>>>
32313>>>>>>>
32313>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
32316>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
32317>>>>>>>        If (bIsSqlTable = False) Begin
32319>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
32322>>>>>>>        End
32322>>>>>>>>
32322>>>>>>>        Else Begin
32323>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
32326>>>>>>>        End
32326>>>>>>>>
32326>>>>>>>        // Let the driver decide the other values;
32326>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
32329>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
32332>>>>>>>
32332>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
32334>>>>>>>            Function_Return False
32335>>>>>>>        End
32335>>>>>>>>
32335>>>>>>>
32335>>>>>>>        Set Private.phCurrentTable to hTable
32336>>>>>>>        Set Private.piCurrentField to iColumn
32337>>>>>>>
32337>>>>>>>        Structure_Start hTable
32338>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
32341>>>>>>>//            If (bIsSqlTable = False) Begin
32341>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
32344>>>>>>>//            End
32344>>>>>>>//            Else Begin
32344>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
32344>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
32344>>>>>>>//            End
32344>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
32347>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
32350>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32351>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32353>>>>>>>
32353>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32354>>>>>>>        Function_Return (Err = False)
32355>>>>>>>    End_Function
32356>>>>>>>
32356>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
32356>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
32358>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
32358>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
32358>>>>>>>        String sFieldNameTo sDriverIDTo
32358>>>>>>>        tColumnType ColumnType
32358>>>>>>>        tColumnType ColumnType
32358>>>>>>>
32358>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
32359>>>>>>>        Get piDbType to iDbType
32360>>>>>>>        If (num_arguments > 4) Begin
32362>>>>>>>            Move iPrec to iPrecFrom
32363>>>>>>>            Move iOpt  to iOptionFrom
32364>>>>>>>        End
32364>>>>>>>>
32364>>>>>>>        If (iTypeFrom < -1490) Begin
32366>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
32367>>>>>>>        End
32367>>>>>>>>
32367>>>>>>>
32367>>>>>>>        Get AutoConnectionIDLogin to bOK
32368>>>>>>>        Move False to Err
32369>>>>>>>        Close hTable
32370>>>>>>>        Get OpenTableExclusive hTable to bOK
32371>>>>>>>        If (bOK = False) Begin
32373>>>>>>>            Function_Return False
32374>>>>>>>        End
32374>>>>>>>>
32374>>>>>>>
32374>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
32377>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
32380>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
32381>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32383>>>>>>>            Move DF_DATE to iDataFlexType
32384>>>>>>>        End
32384>>>>>>>>
32384>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
32387>>>>>>>
32387>>>>>>>        If (bIsSQLTableTo = True) Begin
32389>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
32392>>>>>>>        End
32392>>>>>>>>
32392>>>>>>>        Else Begin
32393>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
32396>>>>>>>        End
32396>>>>>>>>
32396>>>>>>>
32396>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
32399>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
32402>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
32405>>>>>>>
32405>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
32405>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
32405>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
32407>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
32408>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32410>>>>>>>                Move DF_DATE to iTypeTo  
32411>>>>>>>            End
32411>>>>>>>>
32411>>>>>>>        End
32411>>>>>>>>
32411>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
32414>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
32415>>>>>>>        End
32415>>>>>>>>
32415>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
32416>>>>>>>
32416>>>>>>>        If (bCompareDate_DateTime = False) Begin
32418>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
32419>>>>>>>            If (bSkip = True) Begin
32421>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
32423>>>>>>>                    Function_Return True
32424>>>>>>>                End
32424>>>>>>>>
32424>>>>>>>            End
32424>>>>>>>>
32424>>>>>>>        End
32424>>>>>>>>
32424>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
32427>>>>>>>            Function_Return True
32428>>>>>>>        End
32428>>>>>>>>
32428>>>>>>>
32428>>>>>>>        Set Private.phCurrentTable to hTable
32429>>>>>>>        Set Private.piCurrentField to iColumn
32430>>>>>>>
32430>>>>>>>        Structure_Start hTable
32431>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
32433>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
32436>>>>>>>            End
32436>>>>>>>>
32436>>>>>>>
32436>>>>>>>            If (bIsSameDataType = False) Begin
32438>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
32441>>>>>>>                If (bIsSQLTableTo = True) Begin
32443>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
32446>>>>>>>                End
32446>>>>>>>>
32446>>>>>>>            End
32446>>>>>>>>
32446>>>>>>>
32446>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
32448>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
32451>>>>>>>            End
32451>>>>>>>>
32451>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
32453>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
32456>>>>>>>            End
32456>>>>>>>>
32456>>>>>>>
32456>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
32458>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
32458>>>>>>>                If (bRecnumTable = True) Begin
32460>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
32463>>>>>>>                End
32463>>>>>>>>
32463>>>>>>>
32463>>>>>>>                // We might need to create an index here.
32463>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
32463>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
32463>>>>>>>                // index update checking logic.
32463>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
32466>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
32468>>>>>>>                    Create_Index hTable At iIndex
32469>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
32472>>>>>>>                End
32472>>>>>>>>
32472>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
32475>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
32478>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
32481>>>>>>>                If (bIsSQLTableTo = True) Begin
32483>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
32486>>>>>>>                End
32486>>>>>>>>
32486>>>>>>>            End
32486>>>>>>>>
32486>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32487>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32489>>>>>>>
32489>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32490>>>>>>>        Function_Return (Err = False)
32491>>>>>>>    End_Function
32492>>>>>>>
32492>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
32494>>>>>>>        Boolean bOK
32494>>>>>>>
32494>>>>>>>        Get AutoConnectionIDLogin to bOK
32495>>>>>>>        Move False to Err
32496>>>>>>>        Get OpenTableExclusive hTable to bOK
32497>>>>>>>        If (bOK = False) Begin
32499>>>>>>>            Function_Return False
32500>>>>>>>        End
32500>>>>>>>>
32500>>>>>>>
32500>>>>>>>        Structure_Start hTable
32501>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
32504>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32505>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32507>>>>>>>
32507>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32508>>>>>>>        Function_Return (Err = False)
32509>>>>>>>    End_Function
32510>>>>>>>
32510>>>>>>>    // To move an existing field to another position in a table.
32510>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
32512>>>>>>>        String sColumn sDriverID
32512>>>>>>>        Integer iType
32512>>>>>>>        Boolean bOK bIsDate
32512>>>>>>>
32512>>>>>>>        Close hTable
32513>>>>>>>        Get AutoConnectionIDLogin to bOK
32514>>>>>>>        Get OpenTableExclusive hTable to bOK
32515>>>>>>>        If (bOK = False) Begin
32517>>>>>>>            Function_Return False
32518>>>>>>>        End
32518>>>>>>>>
32518>>>>>>>
32518>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
32521>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
32523>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
32524>>>>>>>>
32524>>>>>>>            Function_Return False
32525>>>>>>>        End
32525>>>>>>>>
32525>>>>>>>
32525>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
32528>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
32531>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
32532>>>>>>>
32532>>>>>>>        Set Private.phCurrentTable to hTable
32533>>>>>>>        Set Private.piCurrentField to iOld
32534>>>>>>>
32534>>>>>>>//        If (bIsDate = False) Begin
32534>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
32534>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
32534>>>>>>>//        End
32534>>>>>>>//        Else Begin
32534>>>>>>>//            Move 6 to iLength
32534>>>>>>>//            Move 0 to iPrecision
32534>>>>>>>//        End
32534>>>>>>>
32534>>>>>>>        Move False to Err
32535>>>>>>>
32535>>>>>>>        Structure_Start hTable
32536>>>>>>>            Delete_Field hTable iOld
32537>>>>>>>            Create_Field hTable At iNew
32538>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
32541>>>>>>>
32541>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
32544>>>>>>>            If (bIsSQLType = False) Begin
32546>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
32549>>>>>>>            End
32549>>>>>>>>
32549>>>>>>>            Else Begin
32550>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
32553>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
32553>>>>>>>            End
32553>>>>>>>>
32553>>>>>>>
32553>>>>>>>            If (bIsDate = False) Begin
32555>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
32558>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
32561>>>>>>>            End
32561>>>>>>>>
32561>>>>>>>
32561>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32562>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32564>>>>>>>
32564>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32565>>>>>>>        Function_Return (Err = False)
32566>>>>>>>    End_Function
32567>>>>>>>
32567>>>>>>>    // Deletes a column name for the passed table number (and column number).
32567>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
32569>>>>>>>        Integer iColumn
32569>>>>>>>        Boolean bOK
32569>>>>>>>
32569>>>>>>>        Get AutoConnectionIDLogin to bOK
32570>>>>>>>        Move False to Err
32571>>>>>>>        Close hTable
32572>>>>>>>        Get OpenTableExclusive hTable to bOK
32573>>>>>>>        If (bOK = False) Begin
32575>>>>>>>            Function_Return False
32576>>>>>>>        End
32576>>>>>>>>
32576>>>>>>>
32576>>>>>>>        If (not(Err)) Begin
32578>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32579>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32580>>>>>>>            Field_Map hTable sFieldName to iColumn
32582>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
32583>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32584>>>>>>>            If (iColumn = 0) Begin
32586>>>>>>>                Move 0 to LastErr
32587>>>>>>>                Function_Return False
32588>>>>>>>            End
32588>>>>>>>>
32588>>>>>>>            Move False to Err
32589>>>>>>>
32589>>>>>>>            Set Private.phCurrentTable to hTable
32590>>>>>>>            Set Private.piCurrentField to iColumn
32591>>>>>>>
32591>>>>>>>            Structure_Start hTable
32592>>>>>>>                Delete_Field hTable iColumn
32593>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
32594>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32596>>>>>>>            Set Action_Text of ghoStatusPanel to ""
32597>>>>>>>        End
32597>>>>>>>>
32597>>>>>>>        Else Begin
32598>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
32599>>>>>>>>
32599>>>>>>>        End
32599>>>>>>>>
32599>>>>>>>
32599>>>>>>>        Function_Return (Err = False)
32600>>>>>>>    End_Function
32601>>>>>>>
32601>>>>>>>    // Renames a field for the passed table number & old field name & new field name
32601>>>>>>>    // Returns True if no errors occured.
32601>>>>>>>    // Sample usage:
32601>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
32601>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
32603>>>>>>>        Integer iField
32603>>>>>>>        Boolean bOK bExists bIsOpen
32603>>>>>>>
32603>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
32604>>>>>>>        If (bExists = True) Begin
32606>>>>>>>            Function_Return False
32607>>>>>>>        End
32607>>>>>>>>
32607>>>>>>>
32607>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
32607>>>>>>>        //       opened exclusively, so we first open it in normal mode.
32607>>>>>>>        Close hTable
32608>>>>>>>        Open hTable
32610>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
32613>>>>>>>        If (bIsOpen = False) Begin
32615>>>>>>>            Function_Return False
32616>>>>>>>        End
32616>>>>>>>>
32616>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32617>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32618>>>>>>>        Field_Map hTable sOldFieldName to iField
32620>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32621>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32622>>>>>>>
32622>>>>>>>        Get AutoConnectionIDLogin to bOK
32623>>>>>>>        Get OpenTableExclusive hTable to bOK
32624>>>>>>>        If (bOK = False) Begin
32626>>>>>>>            Function_Return False
32627>>>>>>>        End
32627>>>>>>>>
32627>>>>>>>
32627>>>>>>>        Move False to Err
32628>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
32629>>>>>>>        Set Private.phCurrentTable to hTable
32630>>>>>>>        Set Private.piCurrentField to iField
32631>>>>>>>
32631>>>>>>>        If (iField > 0) Begin
32633>>>>>>>            Structure_Start hTable
32634>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
32637>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
32638>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32640>>>>>>>        End
32640>>>>>>>>
32640>>>>>>>        Else Begin
32641>>>>>>>            Move 0 to LastErr
32642>>>>>>>            Move False to Err
32643>>>>>>>        End
32643>>>>>>>>
32643>>>>>>>
32643>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32644>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
32645>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32646>>>>>>>
32646>>>>>>>        Function_Return (Err = False)
32647>>>>>>>    End_Function
32648>>>>>>>
32648>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
32650>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
32650>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
32651>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
32651>>>>>>>        Boolean bRenameField
32651>>>>>>>
32651>>>>>>>        Open hTable
32653>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32654>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32655>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
32656>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
32659>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
32660>>>>>>>        Decrement iSize
32661>>>>>>>        for iCount from 0 to iSize
32667>>>>>>>>
32667>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
32669>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32670>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32671>>>>>>>
32671>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
32673>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
32675>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
32676>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
32677>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
32679>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
32680>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
32681>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
32682>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
32683>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
32684>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
32685>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
32686>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
32687>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
32688>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
32689>>>>>>>                        Increment iItem
32690>>>>>>>                    End
32690>>>>>>>>
32690>>>>>>>                End
32690>>>>>>>>
32690>>>>>>>            End
32690>>>>>>>>
32690>>>>>>>        Loop
32691>>>>>>>>
32691>>>>>>>
32691>>>>>>>        Move False to Err
32692>>>>>>>        Move 0 to LastErr
32693>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32694>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
32695>>>>>>>        Function_Return aAPIColumnsToInsert
32696>>>>>>>    End_Function
32697>>>>>>>
32697>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
32699>>>>>>>        Integer iSize iCount
32699>>>>>>>        Boolean bOK
32699>>>>>>>        tAPIColumn[] aColumnsTo
32699>>>>>>>        tAPIColumn[] aColumnsTo
32700>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32700>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32701>>>>>>>
32701>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
32702>>>>>>>        If (iSize = 0) Begin
32704>>>>>>>            Function_Return True
32705>>>>>>>        End
32705>>>>>>>>
32705>>>>>>>
32705>>>>>>>        Move False to Err
32706>>>>>>>        Decrement iSize
32707>>>>>>>        for iCount from 0 to iSize
32713>>>>>>>>
32713>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
32714>>>>>>>        Loop
32715>>>>>>>>
32715>>>>>>>
32715>>>>>>>        Function_Return bOK
32716>>>>>>>    End_Function
32717>>>>>>>
32717>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
32717>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
32719>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
32719>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
32720>>>>>>>        Integer iSize iCount iItem iShouldMove
32720>>>>>>>
32720>>>>>>>        Move 0 to iItem
32721>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
32722>>>>>>>        Decrement iSize
32723>>>>>>>        for iCount from 0 to iSize
32729>>>>>>>>
32729>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
32731>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
32732>>>>>>>                If (iShouldMove <> -1) Begin
32734>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
32735>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
32736>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
32737>>>>>>>                    Increment iItem
32738>>>>>>>                End
32738>>>>>>>>
32738>>>>>>>            End
32738>>>>>>>>
32738>>>>>>>        Loop
32739>>>>>>>>
32739>>>>>>>
32739>>>>>>>        Move False to Err
32740>>>>>>>        Move 0 to LastErr
32741>>>>>>>        Function_Return aAPIColumnsToMove
32742>>>>>>>    End_Function
32743>>>>>>>
32743>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
32745>>>>>>>        Integer iSize iCount
32745>>>>>>>        Boolean bOK
32745>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32745>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32746>>>>>>>
32746>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
32747>>>>>>>        If (iSize = 0) Begin
32749>>>>>>>            Function_Return True
32750>>>>>>>        End
32750>>>>>>>>
32750>>>>>>>
32750>>>>>>>        Move False to Err
32751>>>>>>>        Decrement iSize
32752>>>>>>>        for iCount from 0 to iSize
32758>>>>>>>>
32758>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32759>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
32760>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
32762>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
32763>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
32764>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32765>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
32766>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
32768>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
32769>>>>>>>                    Decrement iSize
32770>>>>>>>                    Move 0 to iCount
32771>>>>>>>                End
32771>>>>>>>>
32771>>>>>>>            End
32771>>>>>>>>
32771>>>>>>>        Loop
32772>>>>>>>>
32772>>>>>>>
32772>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32773>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
32774>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
32776>>>>>>>            Move 0 to LastErr
32777>>>>>>>        End
32777>>>>>>>>
32777>>>>>>>        Function_Return bOK
32778>>>>>>>    End_Function
32779>>>>>>>
32779>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
32779>>>>>>>    // We then assume this field should be renamed.
32779>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
32779>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
32779>>>>>>>//
32779>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32779>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
32779>>>>>>>//
32779>>>>>>>//        If (bDifferentFieldNames = True) Begin
32779>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
32779>>>>>>>//            If (bShouldBeRenamed = False) Begin
32779>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32779>>>>>>>//                Function_Return False
32779>>>>>>>//            End
32779>>>>>>>//
32779>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
32779>>>>>>>//            If (bShouldBeRenamed = False) Begin
32779>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32779>>>>>>>//                Function_Return False
32779>>>>>>>//            End
32779>>>>>>>//
32779>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
32779>>>>>>>//            If (bShouldBeRenamed = False) Begin
32779>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32779>>>>>>>//                Function_Return False
32779>>>>>>>//            End
32779>>>>>>>//
32779>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
32779>>>>>>>//            If (bShouldBeRenamed = False) Begin
32779>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
32779>>>>>>>//                Function_Return False
32779>>>>>>>//            End
32779>>>>>>>//        End
32779>>>>>>>//
32779>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
32779>>>>>>>//        Function_Return True
32779>>>>>>>//    End_Function
32779>>>>>>>
32779>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
32779>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
32779>>>>>>>    // - The "FROM" field name is <> "TO" field name
32779>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
32779>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
32779>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
32781>>>>>>>        Boolean bShouldRename
32781>>>>>>>        String sFieldNameFrom sFieldNameTo
32781>>>>>>>
32781>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
32782>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
32783>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
32785>>>>>>>            Function_Return False
32786>>>>>>>        End
32786>>>>>>>>
32786>>>>>>>
32786>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
32787>>>>>>>//        If (bShouldRename = False) Begin
32787>>>>>>>//            Function_Return False
32787>>>>>>>//        End
32787>>>>>>>//
32787>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
32787>>>>>>>//            Function_Return True
32787>>>>>>>//        End
32787>>>>>>>
32787>>>>>>>        Function_Return bShouldRename
32788>>>>>>>    End_Function
32789>>>>>>>
32789>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
32789>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
32789>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
32791>>>>>>>        Integer iCount iSize iRetval
32791>>>>>>>        String sFieldNameFrom
32791>>>>>>>
32791>>>>>>>        Move -1 to iRetval
32792>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
32794>>>>>>>            Function_Return iRetval
32795>>>>>>>        End
32795>>>>>>>>
32795>>>>>>>
32795>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
32796>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
32797>>>>>>>        Decrement iSize
32798>>>>>>>        for iCount from 0 to iSize
32804>>>>>>>>
32804>>>>>>>            // We're only interested in fields other than the passed field/column number:
32804>>>>>>>            If (iCount <> iColumn) Begin
32806>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
32808>>>>>>>                    Move (iCount + 1) to iRetval
32809>>>>>>>                End
32809>>>>>>>>
32809>>>>>>>            End
32809>>>>>>>>
32809>>>>>>>        Loop
32810>>>>>>>>
32810>>>>>>>
32810>>>>>>>        Move 0 to LastErr
32811>>>>>>>        Function_Return iRetval
32812>>>>>>>    End_Function
32813>>>>>>>
32813>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
32815>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
32815>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
32816>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
32816>>>>>>>        Boolean bRenameField
32816>>>>>>>
32816>>>>>>>        Open hTable
32818>>>>>>>        Move 0 to iItem
32819>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
32820>>>>>>>        Decrement iSize
32821>>>>>>>        for iCount from 0 to iSize
32827>>>>>>>>
32827>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
32829>>>>>>>                // Check if the field exists in another position (other field number)
32829>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
32830>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
32831>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
32833>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
32834>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
32835>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
32836>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
32837>>>>>>>                    Increment iItem
32838>>>>>>>                End
32838>>>>>>>>
32838>>>>>>>            End
32838>>>>>>>>
32838>>>>>>>        Loop
32839>>>>>>>>
32839>>>>>>>
32839>>>>>>>        Move False to Err
32840>>>>>>>        Move 0 to LastErr
32841>>>>>>>        Function_Return aAPIColumnsToRename
32842>>>>>>>    End_Function
32843>>>>>>>
32843>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
32845>>>>>>>        Integer iSize iCount
32845>>>>>>>        Boolean bOK
32845>>>>>>>        tAPIColumn[] aColumnsTo
32845>>>>>>>        tAPIColumn[] aColumnsTo
32846>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32846>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
32847>>>>>>>
32847>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
32848>>>>>>>        If (iSize = 0) Begin
32850>>>>>>>            Function_Return True
32851>>>>>>>        End
32851>>>>>>>>
32851>>>>>>>
32851>>>>>>>        Move False to Err
32852>>>>>>>        Decrement iSize
32853>>>>>>>        For iCount from 0 to iSize
32859>>>>>>>>
32859>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32860>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
32861>>>>>>>        Loop
32862>>>>>>>>
32862>>>>>>>
32862>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32863>>>>>>>        Function_Return bOK
32864>>>>>>>    End_Function
32865>>>>>>>
32865>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
32867>>>>>>>        Boolean bDateType
32867>>>>>>>
32867>>>>>>>        If (bIsSQLTableTo = True) Begin
32869>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
32870>>>>>>>        End
32870>>>>>>>>
32870>>>>>>>        Else Begin
32871>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
32872>>>>>>>        End
32872>>>>>>>>
32872>>>>>>>
32872>>>>>>>        Function_Return bDateType
32873>>>>>>>    End_Function
32874>>>>>>>
32874>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
32876>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
32876>>>>>>>        Integer iCount2 iColumn2
32876>>>>>>>        Handle hFile
32876>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
32876>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
32876>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
32876>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
32876>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
32881>>>>>>>        tColumnType ColumnType
32881>>>>>>>        tColumnType ColumnType
32881>>>>>>>
32881>>>>>>>        Move False to Err
32882>>>>>>>        Close hTable
32883>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
32884>>>>>>>        If (bIsOpen = False) Begin
32886>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
32887>>>>>>>>
32887>>>>>>>            Function_Return False
32888>>>>>>>        End 
32888>>>>>>>>
32888>>>>>>>        
32888>>>>>>>        Get piDbType to iDbType
32889>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
32892>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
32893>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
32894>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
32897>>>>>>>
32897>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32898>>>>>>>
32898>>>>>>>        // Before we start to change the table we need to do three things;
32898>>>>>>>        // 1) Insert any new fields
32898>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
32899>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
32901>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
32902>>>>>>>            If (bOK = False) Begin
32904>>>>>>>                Function_Return False
32905>>>>>>>            End
32905>>>>>>>>
32905>>>>>>>            // Update info with changes made.
32905>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
32906>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32907>>>>>>>        End
32907>>>>>>>>
32907>>>>>>>
32907>>>>>>>        // 2) Move fields with same names
32907>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
32908>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
32910>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
32911>>>>>>>            If (bOK = False) Begin
32913>>>>>>>                Function_Return False
32914>>>>>>>            End
32914>>>>>>>>
32914>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
32915>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32916>>>>>>>        End
32916>>>>>>>>
32916>>>>>>>        
32916>>>>>>>        // 3) Rename fields
32916>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
32917>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
32919>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
32920>>>>>>>            If (bOK = False) Begin
32922>>>>>>>                Function_Return False
32923>>>>>>>            End
32923>>>>>>>>
32923>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
32924>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32925>>>>>>>        End
32925>>>>>>>>
32925>>>>>>>
32925>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
32925>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
32925>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
32925>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
32925>>>>>>>//            If (bOK = False) Begin
32925>>>>>>>//                Function_Return False
32925>>>>>>>//            End
32925>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
32925>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
32925>>>>>>>//        End
32925>>>>>>>
32925>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
32925>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
32927>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
32928>>>>>>>            If (bIsSame = True) Begin
32930>>>>>>>                Function_Return True
32931>>>>>>>            End
32931>>>>>>>>
32931>>>>>>>        End
32931>>>>>>>>
32931>>>>>>>
32931>>>>>>>        // We can now continue to make standard field changes:
32931>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
32932>>>>>>>        Set Private.phCurrentTable to hTable
32933>>>>>>>        Move hTable to hFile
32934>>>>>>>        Structure_Start hFile sDriverIDTo
32935>>>>>>>
32935>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
32936>>>>>>>            Decrement iColumns
32937>>>>>>>            for iCount from 0 to iColumns
32943>>>>>>>>
32943>>>>>>>                Send DoAdvance of ghoProgressBar
32944>>>>>>>
32944>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
32945>>>>>>>                Set Private.piCurrentField                  to iColumn
32946>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
32947>>>>>>>                If (bIsSame = False) Begin
32949>>>>>>>
32949>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
32950>>>>>>>                    If (bFieldExistsFrom = True) Begin
32952>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
32953>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
32954>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
32955>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
32956>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
32957>>>>>>>
32957>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
32958>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
32959>>>>>>>                        If (iTypeFrom < -1490) Begin
32961>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
32962>>>>>>>                        End
32962>>>>>>>>
32962>>>>>>>
32962>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
32962>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
32962>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
32964>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
32965>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
32967>>>>>>>                                Move DF_DATE to iTypeFrom
32968>>>>>>>                            End
32968>>>>>>>>
32968>>>>>>>                        End
32968>>>>>>>>
32968>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
32971>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
32972>>>>>>>                        End
32972>>>>>>>>
32972>>>>>>>
32972>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
32973>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
32974>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
32975>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
32976>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
32977>>>>>>>
32977>>>>>>>                        Move False to bSkipTypeChange
32978>>>>>>>                        If (bCompareDate_DateTime = False) Begin
32980>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
32981>>>>>>>                        End
32981>>>>>>>>
32981>>>>>>>
32981>>>>>>>                        If (bFieldExistsTo = False) Begin
32983>>>>>>>                            Move 0 to iColumn
32984>>>>>>>                            Create_Field hFile At iColumn
32985>>>>>>>                            Set Private.piCurrentField to iColumn
32986>>>>>>>                        End
32986>>>>>>>>
32986>>>>>>>
32986>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
32988>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
32991>>>>>>>                        End
32991>>>>>>>>
32991>>>>>>>
32991>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
32993>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
32996>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
32997>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
32999>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
33000>>>>>>>                            End
33000>>>>>>>>
33000>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
33003>>>>>>>                        End
33003>>>>>>>>
33003>>>>>>>
33003>>>>>>>                        If (bSkipTypeChange = False) Begin
33005>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
33007>>>>>>>                                If (bIsSQLTableTo = True) Begin
33009>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
33012>>>>>>>                                End
33012>>>>>>>>
33012>>>>>>>                                Else Begin                                                   
33013>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
33015>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
33016>>>>>>>                                    End
33016>>>>>>>>
33016>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
33019>>>>>>>                                End
33019>>>>>>>>
33019>>>>>>>                            End
33019>>>>>>>>
33019>>>>>>>                        End
33019>>>>>>>>
33019>>>>>>>
33019>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
33020>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
33020>>>>>>>                        If (bIsDateType = False) Begin
33022>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
33024>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
33027>>>>>>>                            End
33027>>>>>>>>
33027>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
33029>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
33032>>>>>>>                            End
33032>>>>>>>>
33032>>>>>>>                        End
33032>>>>>>>>
33032>>>>>>>
33032>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
33034>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
33034>>>>>>>                            If (bRecnumTable = True) Begin
33036>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
33039>>>>>>>                            End
33039>>>>>>>>
33039>>>>>>>
33039>>>>>>>                            // We might need to create an index here.
33039>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
33039>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
33039>>>>>>>                            // index update checking logic.
33039>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
33042>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
33044>>>>>>>                                Create_Index hFile at iIndex
33045>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
33048>>>>>>>                            End
33048>>>>>>>>
33048>>>>>>>
33048>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
33051>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
33054>>>>>>>                                // Note: The order of these two are crucial!
33054>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
33057>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
33060>>>>>>>                        End
33060>>>>>>>>
33060>>>>>>>                    End
33060>>>>>>>>
33060>>>>>>>                    Else Begin
33061>>>>>>>                        Delete_Field hFile iColumn
33062>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
33063>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
33064>>>>>>>                        Decrement iCount2
33065>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
33065>>>>>>>                        // starting with the array number we just deleted the field for.
33065>>>>>>>                        for iColumn2 from iCount to iCount2
33071>>>>>>>>
33071>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
33072>>>>>>>                        Loop
33073>>>>>>>>
33073>>>>>>>                        Decrement iCount
33074>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
33075>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
33076>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
33078>>>>>>>                            Move iColumns to iCount 
33079>>>>>>>                        End
33079>>>>>>>>
33079>>>>>>>                    End
33079>>>>>>>>
33079>>>>>>>                End
33079>>>>>>>>
33079>>>>>>>            Loop
33080>>>>>>>>
33080>>>>>>>
33080>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33081>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33083>>>>>>>
33083>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33084>>>>>>>        Function_Return (Err = False)
33085>>>>>>>    End_Function
33086>>>>>>>
33086>>>>>>>    // * Dummy function for the Studio's Code Explorer *
33086>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
33088>>>>>>>        Function_Return False
33089>>>>>>>    End_Function
33090>>>>>>>
33090>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
33090>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
33090>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
33090>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
33092>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
33092>>>>>>>        String sDriverID
33092>>>>>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
33092>>>>>>>
33092>>>>>>>        Get AutoConnectionIDLogin to bOK
33093>>>>>>>        Get OpenTableExclusive hTable to bOK
33094>>>>>>>        If (bOK = False) Begin
33096>>>>>>>            Function_Return False
33097>>>>>>>        End
33097>>>>>>>>
33097>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33100>>>>>>>
33100>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33101>>>>>>>            If (bIsSQLTable = True) Begin
33103>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33106>>>>>>>            End
33106>>>>>>>>
33106>>>>>>>
33106>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
33109>>>>>>>            Move (iIndexSegments > 0) to bExists
33110>>>>>>>        If (bExists = True) Begin
33112>>>>>>>            Function_Return True
33113>>>>>>>        End
33113>>>>>>>>
33113>>>>>>>
33113>>>>>>>        Move -1 to iSegment1
33114>>>>>>>        Move -1 to iSegment2
33115>>>>>>>        Move -1 to iSegment3
33116>>>>>>>        Move -1 to iSegment4
33117>>>>>>>        Move -1 to iSegment5
33118>>>>>>>        Move -1 to iSegment6
33119>>>>>>>        Move -1 to iSegment7
33120>>>>>>>        Move -1 to iSegment8
33121>>>>>>>        Move -1 to iSegment9
33122>>>>>>>        Move -1 to iSegment10
33123>>>>>>>
33123>>>>>>>        If (num_arguments > 3) Begin
33125>>>>>>>            Move iSgmnt1 to iSegment1
33126>>>>>>>        End
33126>>>>>>>>
33126>>>>>>>        If (num_arguments > 4) Begin
33128>>>>>>>            Move iSgmnt2 to iSegment2
33129>>>>>>>        End
33129>>>>>>>>
33129>>>>>>>        If (num_arguments > 5) Begin
33131>>>>>>>            Move iSgmnt3 to iSegment3
33132>>>>>>>        End
33132>>>>>>>>
33132>>>>>>>        If (num_arguments > 6) Begin
33134>>>>>>>            Move iSgmnt4 to iSegment4
33135>>>>>>>        End
33135>>>>>>>>
33135>>>>>>>        If (num_arguments > 7) Begin
33137>>>>>>>            Move iSgmnt5 to iSegment5
33138>>>>>>>        End
33138>>>>>>>>
33138>>>>>>>        If (num_arguments > 8) Begin
33140>>>>>>>            Move iSgmnt6 to iSegment6
33141>>>>>>>        End
33141>>>>>>>>
33141>>>>>>>        If (num_arguments > 9) Begin
33143>>>>>>>            Move iSgmnt7 to iSegment7
33144>>>>>>>        End
33144>>>>>>>>
33144>>>>>>>        If (num_arguments > 10) Begin
33146>>>>>>>            Move iSgmnt8 to iSegment8
33147>>>>>>>        End
33147>>>>>>>>
33147>>>>>>>        If (num_arguments > 11) Begin
33149>>>>>>>            Move iSgmnt9 to iSegment9
33150>>>>>>>        End
33150>>>>>>>>
33150>>>>>>>        If (num_arguments > 12) Begin
33152>>>>>>>            Move iSgmnt10 to iSegment10
33153>>>>>>>        End
33153>>>>>>>>
33153>>>>>>>
33153>>>>>>>        Move False to Err
33154>>>>>>>        Move hTable to iTableNo
33155>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33156>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
33157>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
33158>>>>>>>
33158>>>>>>>        // We start by deleting the index, if it exists.
33158>>>>>>>        If (bExists = True) Begin
33160>>>>>>>            Structure_Start hTable sDriverID
33161>>>>>>>                Delete_Index iTableNo iIndex
33162>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
33163>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33165>>>>>>>        End
33165>>>>>>>>
33165>>>>>>>
33165>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
33166>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
33167>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
33168>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33169>>>>>>>        Move False to Err
33170>>>>>>>        Move 0 to LastErr
33171>>>>>>>
33171>>>>>>>        // Need to re-open if index deleted.
33171>>>>>>>        Move iTableNo to hTable
33172>>>>>>>        Get OpenTableExclusive hTable to bOK
33173>>>>>>>        If (bOK = False) Begin
33175>>>>>>>            Function_Return False
33176>>>>>>>        End
33176>>>>>>>>
33176>>>>>>>
33176>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33177>>>>>>>        Structure_Start hTable sDriverID
33178>>>>>>>            Create_Index hTable At iIndex
33179>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
33182>>>>>>>
33182>>>>>>>            If (iSgmnt1 <> -1) Begin
33184>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
33187>>>>>>>            End
33187>>>>>>>>
33187>>>>>>>            If (iSegment2 <> -1) Begin
33189>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
33192>>>>>>>            End
33192>>>>>>>>
33192>>>>>>>            If (iSegment3 <> -1) Begin
33194>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
33197>>>>>>>            End
33197>>>>>>>>
33197>>>>>>>            If (iSegment4 <> -1) Begin
33199>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
33202>>>>>>>            End
33202>>>>>>>>
33202>>>>>>>            If (iSegment5 <> -1) Begin
33204>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
33207>>>>>>>            End
33207>>>>>>>>
33207>>>>>>>            If (iSegment6 <> -1) Begin
33209>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
33212>>>>>>>            End
33212>>>>>>>>
33212>>>>>>>            If (iSegment7 <> -1) Begin
33214>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
33217>>>>>>>            End
33217>>>>>>>>
33217>>>>>>>            If (iSegment8 <> -1) Begin
33219>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
33222>>>>>>>            End
33222>>>>>>>>
33222>>>>>>>            If (iSegment9 <> -1) Begin
33224>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
33227>>>>>>>            End
33227>>>>>>>>
33227>>>>>>>            If (iSegment10 <> -1) Begin
33229>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
33232>>>>>>>            End
33232>>>>>>>>
33232>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33233>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33235>>>>>>>
33235>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33236>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33237>>>>>>>
33237>>>>>>>        Function_Return (Err = False)
33238>>>>>>>    End_Function
33239>>>>>>>
33239>>>>>>>    // Example:
33239>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
33239>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
33239>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
33241>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
33241>>>>>>>        String sDriverID
33241>>>>>>>        Boolean bOK bIsSQLTable
33241>>>>>>>
33241>>>>>>>        Get AutoConnectionIDLogin to bOK
33242>>>>>>>
33242>>>>>>>        Move False to Err
33243>>>>>>>        Move hTable to iTableNo
33244>>>>>>>        Get OpenTableExclusive hTable to bOK
33245>>>>>>>        If (bOK = False) Begin
33247>>>>>>>            Function_Return False
33248>>>>>>>        End
33248>>>>>>>>
33248>>>>>>>
33248>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33251>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33252>>>>>>>            If (bIsSQLTable = True) Begin
33254>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33257>>>>>>>            End
33257>>>>>>>>
33257>>>>>>>
33257>>>>>>>        // We start by deleting the index
33257>>>>>>>        Structure_Start hTable sDriverID
33258>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33259>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
33260>>>>>>>            Delete_Index iTableNo iIndex
33261>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
33262>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
33263>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
33265>>>>>>>
33265>>>>>>>        Move False to Err
33266>>>>>>>        Move iTableNo to hTable
33267>>>>>>>        Get OpenTableExclusive hTable to bOK
33268>>>>>>>        If (bOK = False) Begin
33270>>>>>>>            Function_Return False
33271>>>>>>>        End
33271>>>>>>>>
33271>>>>>>>
33271>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33272>>>>>>>        Structure_Start hTable sDriverID
33273>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
33274>>>>>>>
33274>>>>>>>            Create_Index hTable at iIndex
33275>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
33278>>>>>>>
33278>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
33284>>>>>>>>
33284>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
33287>>>>>>>            Loop
33288>>>>>>>>
33288>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
33290>>>>>>>
33290>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
33291>>>>>>>
33291>>>>>>>        Function_Return (Err = False)
33292>>>>>>>    End_Function
33293>>>>>>>
33293>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
33295>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
33295>>>>>>>        String sDriverID sSQLIndexName
33295>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
33295>>>>>>>
33295>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
33296>>>>>>>        If (iSegmentsFrom = 0) Begin
33298>>>>>>>            Function_Return False
33299>>>>>>>        End
33299>>>>>>>>
33299>>>>>>>
33299>>>>>>>        Get AutoConnectionIDLogin to bOK
33300>>>>>>>        Move False to Err
33301>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
33302>>>>>>>        If (bIsOpen = False) Begin
33304>>>>>>>            Function_Return False
33305>>>>>>>        End
33305>>>>>>>>
33305>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33308>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
33309>>>>>>>            If (bIsSQLTable = True) Begin
33311>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33314>>>>>>>            End
33314>>>>>>>>
33314>>>>>>>
33314>>>>>>>        Move 0     to iSegmentsTo
33315>>>>>>>        Move 0     to iSQLIndexType
33316>>>>>>>        Move ""    to sSQLIndexName
33317>>>>>>>        Move False to bIsSQLTemporaryIndex
33318>>>>>>>        Move False to bIsSQLPrimaryKey
33319>>>>>>>        Move False to bIsSQLClustered
33320>>>>>>>
33320>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
33321>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
33324>>>>>>>        Move (iSegmentsTo > 0) to bExists
33325>>>>>>>        If (bExists = True) Begin
33327>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
33329>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
33332>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
33335>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
33336>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
33339>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
33342>>>>>>>            End
33342>>>>>>>>
33342>>>>>>>        End
33342>>>>>>>>
33342>>>>>>>
33342>>>>>>>        Move hTable to iTableNo
33343>>>>>>>        Move False to Err
33344>>>>>>>        Move 0 to LastErr
33345>>>>>>>
33345>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
33345>>>>>>>        //       _outside_ the Structure_Start/End construct.
33345>>>>>>>//        Move False to bIsSQLTemporaryIndex
33345>>>>>>>//        #IF (!@ > 170)
33345>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
33345>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
33345>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
33345>>>>>>>//                End
33345>>>>>>>//            End
33345>>>>>>>//        #ENDIF
33345>>>>>>>
33345>>>>>>>        Structure_Start hTable sDriverID
33346>>>>>>>            If (bExists = True) Begin
33348>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
33349>>>>>>>            End
33349>>>>>>>>
33349>>>>>>>
33349>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
33350>>>>>>>
33350>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
33352>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
33355>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
33358>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
33361>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
33364>>>>>>>            End
33364>>>>>>>>
33364>>>>>>>
33364>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
33367>>>>>>>
33367>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
33373>>>>>>>>
33373>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
33374>>>>>>>                If (iFieldFrom <> -1 ) Begin
33376>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
33379>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
33382>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
33385>>>>>>>                End
33385>>>>>>>>
33385>>>>>>>            Loop
33386>>>>>>>>
33386>>>>>>>
33386>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33387>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33389>>>>>>>
33389>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33390>>>>>>>
33390>>>>>>>        Function_Return (Err = False)
33391>>>>>>>    End_Function
33392>>>>>>>
33392>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
33392>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
33392>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
33394>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
33394>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
33394>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
33394>>>>>>>
33394>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
33394>>>>>>>        // so we can then not rename the index.
33394>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
33395>>>>>>>        If (bIsMertechDriver = True) Begin
33397>>>>>>>            Function_Return False
33398>>>>>>>        End    
33398>>>>>>>>
33398>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
33399>>>>>>>        
33399>>>>>>>        If (bIsSQLDriver = False) Begin
33401>>>>>>>            Function_Return False
33402>>>>>>>        End
33402>>>>>>>>
33402>>>>>>>
33402>>>>>>>        Move False to Err
33403>>>>>>>        Move hTable to iTableNo
33404>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
33407>>>>>>>        for iCount from 0 to iLastIndex
33413>>>>>>>>
33413>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
33416>>>>>>>            Move (iSegments > 0) to bExists
33417>>>>>>>            If (bExists = True) Begin
33419>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
33422>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
33424>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
33425>>>>>>>                    Structure_Start iTableNo sDriverID
33426>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
33429>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33431>>>>>>>                    Open hTable
33433>>>>>>>                End
33433>>>>>>>>
33433>>>>>>>            End
33433>>>>>>>>
33433>>>>>>>        Loop
33434>>>>>>>>
33434>>>>>>>
33434>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
33437>>>>>>>        If (bIsOpen = False) Begin
33439>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
33440>>>>>>>        End
33440>>>>>>>>
33440>>>>>>>        If (bIsOpen = False) Begin
33442>>>>>>>            Function_Return False
33443>>>>>>>        End
33443>>>>>>>>
33443>>>>>>>
33443>>>>>>>        Function_Return (Err = False)
33444>>>>>>>    End_Function
33445>>>>>>>
33445>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
33445>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
33445>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
33447>>>>>>>        Integer iSize iCount
33447>>>>>>>        Integer iRetVal
33447>>>>>>>
33447>>>>>>>        Move 0 to iRetVal
33448>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
33451>>>>>>>        If (iRetVal = 0) Begin
33453>>>>>>>            Function_Return 0
33454>>>>>>>        End
33454>>>>>>>>
33454>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
33455>>>>>>>        Decrement iSize
33456>>>>>>>        for iCount from 0 to iSize
33462>>>>>>>>
33462>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
33464>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
33466>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
33467>>>>>>>                End
33467>>>>>>>>
33467>>>>>>>            End
33467>>>>>>>>
33467>>>>>>>        Loop
33468>>>>>>>>
33468>>>>>>>
33468>>>>>>>        Function_Return iRetVal
33469>>>>>>>    End_Function
33470>>>>>>>
33470>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
33472>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
33472>>>>>>>        Boolean bIsSQLTable
33472>>>>>>>        
33472>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33473>>>>>>>            If (bIsSQLTable = True) Begin
33475>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33478>>>>>>>            End
33478>>>>>>>>
33478>>>>>>>
33478>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33481>>>>>>>        If (iSegment = iNumSegments) Begin
33483>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33483>>>>>>>        End
33483>>>>>>>>
33483>>>>>>>
33483>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
33486>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
33492>>>>>>>>
33492>>>>>>>                //*** Move index segment attributes
33492>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
33495>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
33498>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
33501>>>>>>>
33501>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
33504>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
33507>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
33510>>>>>>>            Loop
33511>>>>>>>>
33511>>>>>>>
33511>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33514>>>>>>>        End
33514>>>>>>>>
33514>>>>>>>
33514>>>>>>>        Function_Return (Err = False)
33515>>>>>>>    End_Function
33516>>>>>>>
33516>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
33518>>>>>>>        Integer iCount iSize iIndex
33518>>>>>>>        String sDriverID
33518>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
33518>>>>>>>
33518>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
33519>>>>>>>        If (iSize = 0) Begin
33521>>>>>>>            Function_Return True
33522>>>>>>>        End
33522>>>>>>>>
33522>>>>>>>
33522>>>>>>>        Get AutoConnectionIDLogin to bOK
33523>>>>>>>        Move False to Err
33524>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
33527>>>>>>>        If (bIsOpen = False) Begin
33529>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
33530>>>>>>>            If (bIsOpen = False) Begin
33532>>>>>>>                Function_Return False
33533>>>>>>>            End
33533>>>>>>>>
33533>>>>>>>        End
33533>>>>>>>>
33533>>>>>>>
33533>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33536>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
33537>>>>>>>            If (bIsSQLTable = True) Begin
33539>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33542>>>>>>>            End
33542>>>>>>>>
33542>>>>>>>
33542>>>>>>>        Move False to Err
33543>>>>>>>        Move 0 to LastErr
33544>>>>>>>        Decrement iSize
33545>>>>>>>
33545>>>>>>>        Structure_Start hTable sDriverID
33546>>>>>>>            for iCount from 0 to iSize
33552>>>>>>>>
33552>>>>>>>//                Move False to bIsSQLPrimaryKey
33552>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
33552>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33552>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
33552>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
33552>>>>>>>//                #ENDIF
33552>>>>>>>                // We can't delete if this is a primary key index:
33552>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
33552>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
33553>>>>>>>                    Delete_Index hTable iIndex
33554>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
33554>>>>>>>//                End
33554>>>>>>>            Loop
33555>>>>>>>>
33555>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33556>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33558>>>>>>>//        Move False to Err
33558>>>>>>>        Move 0 to LastErr
33559>>>>>>>
33559>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33560>>>>>>>        Function_Return (Err = False)
33561>>>>>>>    End_Function
33562>>>>>>>
33562>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
33564>>>>>>>        Boolean bOK
33564>>>>>>>
33564>>>>>>>        Get AutoConnectionIDLogin to bOK
33565>>>>>>>        Move False to Err
33566>>>>>>>        Get OpenTableExclusive hTable to bOK
33567>>>>>>>        If (bOK = False) Begin
33569>>>>>>>            Function_Return False
33570>>>>>>>        End
33570>>>>>>>>
33570>>>>>>>        Structure_Start hTable
33571>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
33574>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33575>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33577>>>>>>>
33577>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33578>>>>>>>        Function_Return (Err = False)
33579>>>>>>>    End_Function
33580>>>>>>>
33580>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
33582>>>>>>>        Integer iCase
33582>>>>>>>        Boolean bOK
33582>>>>>>>
33582>>>>>>>        If (bUppercase = True) Begin
33584>>>>>>>            Move DF_CASE_IGNORED to iCase
33585>>>>>>>        End
33585>>>>>>>>
33585>>>>>>>        Else Begin
33586>>>>>>>            Move DF_CASE_USED to iCase
33587>>>>>>>        End
33587>>>>>>>>
33587>>>>>>>
33587>>>>>>>        Get AutoConnectionIDLogin to bOK
33588>>>>>>>        Move False to Err
33589>>>>>>>        Get OpenTableExclusive hTable to bOK
33590>>>>>>>        If (bOK = False) Begin
33592>>>>>>>            Function_Return False
33593>>>>>>>        End
33593>>>>>>>>
33593>>>>>>>        Structure_Start hTable
33594>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
33597>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33598>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33600>>>>>>>
33600>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33601>>>>>>>        Function_Return (Err = False)
33602>>>>>>>    End_Function
33603>>>>>>>
33603>>>>>>>    // To delete an index
33603>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
33605>>>>>>>        Integer iTableNo iNumSegments
33605>>>>>>>        String sDriverID
33605>>>>>>>        Boolean bOK bIsSQLTable
33605>>>>>>>
33605>>>>>>>        Get AutoConnectionIDLogin to bOK
33606>>>>>>>        Move False to Err
33607>>>>>>>        Move hTable to iTableNo
33608>>>>>>>        Get OpenTableExclusive hTable to bOK
33609>>>>>>>        If (bOK = False) Begin
33611>>>>>>>            Function_Return False
33612>>>>>>>        End
33612>>>>>>>>
33612>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33615>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33616>>>>>>>            If (bIsSQLTable = True) Begin
33618>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33621>>>>>>>            End
33621>>>>>>>>
33621>>>>>>>
33621>>>>>>>        // Check to see if the index exists or not...
33621>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33624>>>>>>>        If (iNumSegments = 0) Begin
33626>>>>>>>            Function_Return True // Then nothing to do.
33627>>>>>>>        End
33627>>>>>>>>
33627>>>>>>>
33627>>>>>>>        Structure_Start hTable sDriverID
33628>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
33629>>>>>>>            Delete_Index iTableNo iIndex
33630>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
33631>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33632>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33634>>>>>>>
33634>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33635>>>>>>>        Function_Return (Err = False)
33636>>>>>>>    End_Function
33637>>>>>>>
33637>>>>>>>    // Delete an Index Segment
33637>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
33639>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
33639>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
33639>>>>>>>        Integer iIndexType
33639>>>>>>>        String sDriverID
33639>>>>>>>
33639>>>>>>>        Get AutoConnectionIDLogin to bOK
33640>>>>>>>        Move False to Err
33641>>>>>>>
33641>>>>>>>        Get OpenTableExclusive hTable to bOK
33642>>>>>>>        If (bOK = False) Begin
33644>>>>>>>            Function_Return False
33645>>>>>>>        End
33645>>>>>>>>
33645>>>>>>>
33645>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33646>>>>>>>            If (bIsSQLTable = True) Begin
33648>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33651>>>>>>>            End
33651>>>>>>>>
33651>>>>>>>
33651>>>>>>>        // Check to see if the index exists or not...
33651>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33654>>>>>>>        If (iNumSegments = 0) Begin
33656>>>>>>>            Function_Return False
33657>>>>>>>        End
33657>>>>>>>>
33657>>>>>>>
33657>>>>>>>        Move False to bIndexTemporary
33658>>>>>>>        Get psDriverID to sDriverID
33659>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
33660>>>>>>>        If (bSQLDriver) Begin
33662>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
33665>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
33668>>>>>>>                Move True to bIndexTemporary
33669>>>>>>>        End
33669>>>>>>>>
33669>>>>>>>
33669>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
33669>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
33671>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33674>>>>>>>            If (iSegment = iNumSegments) Begin
33676>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33679>>>>>>>            End
33679>>>>>>>>
33679>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
33682>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
33688>>>>>>>>
33688>>>>>>>                    //*** Move index segment attributes
33688>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
33691>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
33694>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
33697>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
33700>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
33703>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
33706>>>>>>>                Loop
33707>>>>>>>>
33707>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33710>>>>>>>            End
33710>>>>>>>>
33710>>>>>>>        End
33710>>>>>>>>
33710>>>>>>>
33710>>>>>>>        Else Begin
33711>>>>>>>           Structure_Start hTable
33712>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33715>>>>>>>               If (iSegment = iNumSegments) Begin
33717>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33720>>>>>>>               End
33720>>>>>>>>
33720>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
33723>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
33729>>>>>>>>
33729>>>>>>>                       //*** Move index segment attributes
33729>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
33732>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
33735>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
33738>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
33741>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
33744>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
33747>>>>>>>                   Loop
33748>>>>>>>>
33748>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
33751>>>>>>>               End
33751>>>>>>>>
33751>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
33752>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33754>>>>>>>            Set Action_Text of ghoStatusPanel to ""
33755>>>>>>>        End
33755>>>>>>>>
33755>>>>>>>
33755>>>>>>>        Function_Return (Err = False)
33756>>>>>>>    End_Function
33757>>>>>>>
33757>>>>>>>    // Add/Insert an Index Segment
33757>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
33759>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
33759>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
33759>>>>>>>        Integer iIndexType
33759>>>>>>>        String sDriverId
33759>>>>>>>
33759>>>>>>>        Get AutoConnectionIDLogin to bOK
33760>>>>>>>        Move False to Err
33761>>>>>>>
33761>>>>>>>        Get OpenTableExclusive hTable to bOK
33762>>>>>>>        If (bOK = False) Begin
33764>>>>>>>            Function_Return False
33765>>>>>>>        End
33765>>>>>>>>
33765>>>>>>>
33765>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
33766>>>>>>>            If (bIsSQLTable = True) Begin
33768>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33771>>>>>>>            End
33771>>>>>>>>
33771>>>>>>>
33771>>>>>>>        Move False to bIndexTemporary
33772>>>>>>>        // Check to see if the index exists or not...
33772>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33775>>>>>>>        If (iNumSegments = 0) Begin
33777>>>>>>>            Function_Return False
33778>>>>>>>        End
33778>>>>>>>>
33778>>>>>>>
33778>>>>>>>        Get psDriverID to sDriverID
33779>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
33780>>>>>>>        If (bSQLDriver) Begin
33782>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
33785>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
33788>>>>>>>                Move True to bIndexTemporary
33789>>>>>>>        End
33789>>>>>>>>
33789>>>>>>>
33789>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
33789>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
33791>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33794>>>>>>>
33794>>>>>>>           If (iSegment > iNumSegments) Begin
33796>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
33799>>>>>>>               Move (iNumSegments + 1) to iCurSegment
33800>>>>>>>           End
33800>>>>>>>>
33800>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
33803>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
33806>>>>>>>               Move iNumSegments to iCurSegment
33807>>>>>>>
33807>>>>>>>               While (iCurSegment > iSegment)
33811>>>>>>>                   //*** Move index segment attributes
33811>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
33814>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
33817>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
33820>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
33823>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
33826>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
33829>>>>>>>                   Decrement iCurSegment
33830>>>>>>>               Loop
33831>>>>>>>>
33831>>>>>>>
33831>>>>>>>               //*** Now set new segment attributes
33831>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
33834>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
33837>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
33840>>>>>>>           End
33840>>>>>>>>
33840>>>>>>>        End
33840>>>>>>>>
33840>>>>>>>
33840>>>>>>>        Else Begin
33841>>>>>>>        Structure_Start hTable
33842>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33845>>>>>>>
33845>>>>>>>            If (iSegment > iNumSegments) Begin
33847>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
33850>>>>>>>                Move (iNumSegments + 1) to iCurSegment
33851>>>>>>>            End
33851>>>>>>>>
33851>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
33854>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
33857>>>>>>>                Move iNumSegments to iCurSegment
33858>>>>>>>
33858>>>>>>>                While (iCurSegment > iSegment)
33862>>>>>>>                    //*** Move index segment attributes
33862>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
33865>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
33868>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
33871>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
33874>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
33877>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
33880>>>>>>>                    Decrement iCurSegment
33881>>>>>>>                Loop
33882>>>>>>>>
33882>>>>>>>
33882>>>>>>>                //*** Now set new segment attributes
33882>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
33885>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
33888>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
33891>>>>>>>            End
33891>>>>>>>>
33891>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33892>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33894>>>>>>>            Set Action_Text of ghoStatusPanel to ""
33895>>>>>>>        End
33895>>>>>>>>
33895>>>>>>>
33895>>>>>>>        Function_Return (Err = False)
33896>>>>>>>    End_Function
33897>>>>>>>
33897>>>>>>>    // * Dummy function for the Studio's Code Explorer *
33897>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
33899>>>>>>>        Function_Return False
33900>>>>>>>    End_Function  
33901>>>>>>>    
33901>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
33901>>>>>>>    // for an SQL conversion.
33901>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
33903>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
33903>>>>>>>        
33903>>>>>>>        Move True to bConvertTo30FormatbOK
33904>>>>>>>        Move True to bRepairAndReindexOK
33905>>>>>>>        Move True to bFixBogusDatesOK
33906>>>>>>>        Move True to bMoveMiscFilesToBackupOK
33907>>>>>>>        
33907>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
33909>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
33910>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
33911>>>>>>>        End                                                                                
33911>>>>>>>>
33911>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
33913>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
33914>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
33915>>>>>>>        End
33915>>>>>>>>
33915>>>>>>>        If (bConvertTo30Format = True) Begin
33917>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
33918>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
33919>>>>>>>        End                                                 
33919>>>>>>>>
33919>>>>>>>        If (bRepairAndReindex = True) Begin
33921>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
33922>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
33923>>>>>>>        End  
33923>>>>>>>>
33923>>>>>>>        If (bFixBogusDates = True) Begin
33925>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
33926>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
33927>>>>>>>        End                                    
33927>>>>>>>>
33927>>>>>>>        
33927>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
33928>>>>>>>    End_Function
33929>>>>>>>
33929>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
33931>>>>>>>        Boolean bOK bFlexErrs bTemp
33931>>>>>>>        Handle hTable
33931>>>>>>>        String sTableName
33931>>>>>>>        Integer iCount iSize
33931>>>>>>>        
33931>>>>>>>        Move True to bOK
33932>>>>>>>        Move 0 to hTable    
33933>>>>>>>
33933>>>>>>>        Get UtilFilelistNoOfTables to iSize
33934>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
33935>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
33936>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
33937>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
33938>>>>>>>
33938>>>>>>>        Repeat
33938>>>>>>>>
33938>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
33939>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
33940>>>>>>>            Increment iCount
33941>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33944>>>>>>>            If (hTable > 0) Begin
33946>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
33949>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
33950>>>>>>>                If (bFlexErrs = False) Begin
33952>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
33953>>>>>>>                    If (bTemp = False) Begin
33955>>>>>>>                        Move False to bOK
33956>>>>>>>                    End
33956>>>>>>>>
33956>>>>>>>                End
33956>>>>>>>>
33956>>>>>>>            End
33956>>>>>>>>
33956>>>>>>>        Until (hTable = 0)
33958>>>>>>>        
33958>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33959>>>>>>>        Function_Return bOK
33960>>>>>>>    End_Function
33961>>>>>>>    
33961>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
33961>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
33961>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
33961>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
33963>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
33963>>>>>>>        String sRevision
33963>>>>>>>        
33963>>>>>>>        Get AutoConnectionIDLogin to bOK
33964>>>>>>>        If (bOK = False) Begin
33966>>>>>>>            Function_Return True
33967>>>>>>>        End
33967>>>>>>>>
33967>>>>>>>        Get OpenTableExclusive hTable to bOK
33968>>>>>>>        If (bOK = False) Begin
33970>>>>>>>            Function_Return True
33971>>>>>>>        End
33971>>>>>>>>
33971>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
33972>>>>>>>        If (bIsEmbedded = False) Begin
33974>>>>>>>            Function_Return True
33975>>>>>>>        End                             
33975>>>>>>>>
33975>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
33976>>>>>>>        If (bIsAlias = True) Begin
33978>>>>>>>            Function_Return True
33979>>>>>>>        End                     
33979>>>>>>>>
33979>>>>>>>        
33979>>>>>>>        Move False to Err
33980>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
33983>>>>>>>        If (sRevision contains "2.3") Begin
33985>>>>>>>            Move False to Err
33986>>>>>>>            Set Private.phCurrentTable to hTable
33987>>>>>>>            Structure_Start hTable    
33988>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
33991>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
33992>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
33994>>>>>>>            Set Action_Text of ghoStatusPanel to ""
33995>>>>>>>        End
33995>>>>>>>>
33995>>>>>>>        
33995>>>>>>>        Function_Return (Err = False)
33996>>>>>>>    End_Function
33997>>>>>>>
33997>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
33999>>>>>>>        Boolean bIgnore bExists bOK bResponse
33999>>>>>>>        Handle hTable   
33999>>>>>>>        String sTableName
33999>>>>>>>        
33999>>>>>>>        Move False to Err 
34000>>>>>>>        Move True to bOK
34001>>>>>>>        Move 0 to hTable
34002>>>>>>>        Repeat
34002>>>>>>>>
34002>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34005>>>>>>>            If (hTable > 0) Begin
34007>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
34010>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
34011>>>>>>>                If (bIgnore = False) Begin
34013>>>>>>>                    Get UtilTableExists hTable to bExists
34014>>>>>>>                    If (bExists = False) Begin
34016>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
34017>>>>>>>                        If (bResponse = False) Begin
34019>>>>>>>                            Move False to bOK
34020>>>>>>>                        End
34020>>>>>>>>
34020>>>>>>>                        
34020>>>>>>>                    End
34020>>>>>>>>
34020>>>>>>>                End
34020>>>>>>>>
34020>>>>>>>            End
34020>>>>>>>>
34020>>>>>>>        Until (hTable = 0)                     
34022>>>>>>>        
34022>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
34023>>>>>>>        Function_Return bOK
34024>>>>>>>    End_Function
34025>>>>>>>    
34025>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
34025>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
34025>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
34025>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
34025>>>>>>>    //
34025>>>>>>>    // The root of the problem is the following:
34025>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
34025>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
34025>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
34025>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
34025>>>>>>>    // an SQL error will be thrown;
34025>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
34025>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
34027>>>>>>>        Boolean bOK bIsAlias bIsSQL
34027>>>>>>>        Integer iCount iSize iDateSize
34027>>>>>>>        Handle hTable
34027>>>>>>>        String sLogicalName
34027>>>>>>>        Integer[] aTablesToCheck aDateFields
34029>>>>>>>
34029>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
34030>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
34031>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
34032>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
34033>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
34034>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
34035>>>>>>>
34035>>>>>>>        Move True to bOK
34036>>>>>>>        Decrement iSize
34037>>>>>>>        for iCount from 0 to iSize
34043>>>>>>>>
34043>>>>>>>            Move aTablesToCheck[iCount] to hTable
34044>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
34045>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
34046>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
34047>>>>>>>
34047>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
34050>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
34051>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
34052>>>>>>>
34052>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
34054>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
34055>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
34056>>>>>>>                If (iDateSize > 0) Begin
34058>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
34059>>>>>>>                    Close hTable
34060>>>>>>>                End
34060>>>>>>>>
34060>>>>>>>            End
34060>>>>>>>>
34060>>>>>>>        Loop
34061>>>>>>>>
34061>>>>>>>
34061>>>>>>>        Close DF_ALL
34062>>>>>>>        Function_Return bOK
34063>>>>>>>    End_Function
34064>>>>>>>
34064>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
34064>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
34066>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
34068>>>>>>>        Integer iSize iCount iType
34068>>>>>>>        Boolean bOpen bOK
34068>>>>>>>        
34068>>>>>>>        Get UtilTableExists hTable to bOK
34069>>>>>>>        If (bOK = False) Begin
34071>>>>>>>            Set Private.phCurrentTable to hTable
34072>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
34073>>>>>>>>
34073>>>>>>>            Function_Return aDateFieldsEmpty
34074>>>>>>>        End
34074>>>>>>>>
34074>>>>>>>        Set Private.phCurrentTable to hTable
34075>>>>>>>        Set Private.piCurrentField to 0
34076>>>>>>>
34076>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34076>>>>>>>        Open hTable
34078>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
34081>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
34081>>>>>>>        If (bOpen = False) Begin
34083>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
34083>>>>>>>            Function_Return aDateFieldsEmpty
34084>>>>>>>        End
34084>>>>>>>>
34084>>>>>>>
34084>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
34087>>>>>>>        For iCount from 1 to iSize
34093>>>>>>>>
34093>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
34096>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
34098>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
34099>>>>>>>            End
34099>>>>>>>>
34099>>>>>>>        Loop
34100>>>>>>>>
34100>>>>>>>
34100>>>>>>>        Function_Return aDateFields
34101>>>>>>>    End_Function
34102>>>>>>>
34102>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
34102>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
34102>>>>>>>    // and the record is saved
34102>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
34102>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
34102>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
34104>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
34104>>>>>>>        String sDriverID sDateMin
34104>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
34104>>>>>>>        Date dDate dDateMin
34104>>>>>>>        Integer[] iaChangeField
34105>>>>>>>
34105>>>>>>>        Get UtilTableExists hTable to bOK
34106>>>>>>>        // I believe we should just skip files not found and not report an error.
34106>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
34106>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
34106>>>>>>>        // Especially considering that this call is probably done at the very
34106>>>>>>>        // beginning of a DUF update.
34106>>>>>>>        If (bOK = False) Begin
34108>>>>>>>//            Set Private.phCurrentTable to hTable
34108>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
34108>>>>>>>//            Function_Return False
34108>>>>>>>            Function_Return True
34109>>>>>>>        End
34109>>>>>>>>
34109>>>>>>>
34109>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
34109>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
34109>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
34112>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
34115>>>>>>>
34115>>>>>>>//        Send SetAllIndexesToBatch hTable True
34115>>>>>>>        Open hTable
34117>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
34120>>>>>>>        If (bOpened = False) Begin
34122>>>>>>>            Function_Return False
34123>>>>>>>        End
34123>>>>>>>>
34123>>>>>>>        
34123>>>>>>>        Set Private.phCurrentTable to hTable
34124>>>>>>>        Move 0 to iRecord
34125>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
34126>>>>>>>        Decrement iSize
34127>>>>>>>
34127>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
34130>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
34131>>>>>>>        If (iDriverIndex <> 0) Begin
34133>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
34136>>>>>>>            If (sDateMin = "") Begin
34138>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
34139>>>>>>>            End
34139>>>>>>>>
34139>>>>>>>            Else Begin
34140>>>>>>>                If (IsDate(sDateMin)) Begin
34142>>>>>>>                    Move sDateMin to dDateMin
34143>>>>>>>                End
34143>>>>>>>>
34143>>>>>>>                Else Begin
34144>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
34145>>>>>>>                End
34145>>>>>>>>
34145>>>>>>>            End
34145>>>>>>>>
34145>>>>>>>        End
34145>>>>>>>>
34145>>>>>>>        Else Begin
34146>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
34147>>>>>>>        End
34147>>>>>>>>
34147>>>>>>>
34147>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
34150>>>>>>>        Set piPosition   of ghoProgressBar to 0
34151>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
34152>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
34153>>>>>>>        Move False to Err
34154>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34155>>>>>>>
34155>>>>>>>        Clear hTable
34156>>>>>>>        Repeat
34156>>>>>>>>
34156>>>>>>>            Vfind hTable 0 GT
34158>>>>>>>            Move Found to bFound
34159>>>>>>>            If (bFound = True) Begin
34161>>>>>>>                Move False to bSaveChanges
34162>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
34163>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
34164>>>>>>>                Decrement iSize
34165>>>>>>>                For iCount from 0 to iSize
34171>>>>>>>>
34171>>>>>>>                    Move aDateFields[iCount] to iField
34172>>>>>>>                    Get_Field_Value hTable iField to dDate
34175>>>>>>>                    If (bFixZeroDates = True) Begin
34177>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
34178>>>>>>>                    End
34178>>>>>>>>
34178>>>>>>>                    Else Begin
34179>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
34180>>>>>>>                    End
34180>>>>>>>>
34180>>>>>>>                    If (bChange = True) Begin
34182>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
34183>>>>>>>                    End
34183>>>>>>>>
34183>>>>>>>                Loop
34184>>>>>>>>
34184>>>>>>>
34184>>>>>>>                // Only change Date fields that needs to be changed.
34184>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
34186>>>>>>>                    Reread hTable
34190>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
34191>>>>>>>                        Decrement iSize
34192>>>>>>>                        For iCount from 0 to iSize
34198>>>>>>>>
34198>>>>>>>                            Move iaChangeField[iCount] to iField
34199>>>>>>>                            Set Private.piCurrentField to iField
34200>>>>>>>                            Set_Field_Value hTable iField to dDateMin
34203>>>>>>>                        Loop
34204>>>>>>>>
34204>>>>>>>                        Move False to Err
34205>>>>>>>                        SaveRecord hTable
34206>>>>>>>                    Unlock
34207>>>>>>>>
34207>>>>>>>                End
34207>>>>>>>>
34207>>>>>>>
34207>>>>>>>                Increment iRecord
34208>>>>>>>                // Increment the StatusPanel counter and check the
34208>>>>>>>                // cancel status every 100 records rather than every
34208>>>>>>>                // record, it's way faster.
34208>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
34210>>>>>>>                    Send DoAdvance of ghoProgressBar
34211>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
34212>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
34213>>>>>>>                End
34213>>>>>>>>
34213>>>>>>>            End
34213>>>>>>>>
34213>>>>>>>        Until (bFound = False)
34215>>>>>>>
34215>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
34218>>>>>>>        If (bResetIndexesToOnLine = True) Begin
34220>>>>>>>            Send SetAllIndexesToBatch hTable False
34221>>>>>>>        End
34221>>>>>>>>
34221>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34222>>>>>>>
34222>>>>>>>        Function_Return (Err = False)
34223>>>>>>>    End_Function
34224>>>>>>>
34224>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
34224>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
34224>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
34226>>>>>>>        Boolean bIsSame
34226>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
34226>>>>>>>
34226>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
34227>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
34228>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
34229>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
34230>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
34231>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
34232>>>>>>>
34232>>>>>>>        If (bCompareFilelistUppercase = True) Begin
34234>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
34235>>>>>>>        End
34235>>>>>>>>
34235>>>>>>>        Else Begin
34236>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
34237>>>>>>>        End
34237>>>>>>>>
34237>>>>>>>        If (bIsSame = False) Begin
34239>>>>>>>            Function_Return False
34240>>>>>>>        End
34240>>>>>>>>
34240>>>>>>>
34240>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
34241>>>>>>>        If (bIsSame = False) Begin
34243>>>>>>>            Function_Return False
34244>>>>>>>        End
34244>>>>>>>>
34244>>>>>>>
34244>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
34245>>>>>>>        If (bIsSame = False) Begin
34247>>>>>>>            Function_Return False
34248>>>>>>>        End
34248>>>>>>>>
34248>>>>>>>
34248>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
34249>>>>>>>        If (bIsSame = False) Begin
34251>>>>>>>            Function_Return False
34252>>>>>>>        End
34252>>>>>>>>
34252>>>>>>>
34252>>>>>>>        Function_Return bIsSame
34253>>>>>>>    End_Function
34254>>>>>>>
34254>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
34256>>>>>>>        Handle hTableFrom hTableTo
34256>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
34256>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
34256>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
34256>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34256>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34257>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34257>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34258>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34258>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34259>>>>>>>
34259>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
34260>>>>>>>        If (bIsSame = True) Begin
34262>>>>>>>            Function_Return True
34263>>>>>>>        End
34263>>>>>>>>
34263>>>>>>>
34263>>>>>>>        Move False to bFilelistError
34264>>>>>>>        Move True to bIsSame
34265>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
34266>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
34267>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
34268>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
34269>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
34270>>>>>>>
34270>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
34271>>>>>>>        Get _TableNameOnly sRootName             to sRootName
34272>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
34273>>>>>>>
34273>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
34273>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
34273>>>>>>>        If (bCodeGenerateMode = True) Begin
34275>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
34275>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
34277>>>>>>>                Function_Return False
34278>>>>>>>            End
34278>>>>>>>>
34278>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
34279>>>>>>>            If (bIsSame = False) Begin
34281>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
34282>>>>>>>                Move True to bFilelistError
34283>>>>>>>                Function_Return False
34284>>>>>>>            End
34284>>>>>>>>
34284>>>>>>>        End
34284>>>>>>>>
34284>>>>>>>
34284>>>>>>>        If (bCodeGenerateMode = False) Begin
34286>>>>>>>            // Then we want to create this table
34286>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
34288>>>>>>>                Function_Return False
34289>>>>>>>            End
34289>>>>>>>>
34289>>>>>>>
34289>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
34290>>>>>>>            If (bIsSame = False) Begin
34292>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
34293>>>>>>>>
34293>>>>>>>                Move True to bFilelistError
34294>>>>>>>                Function_Return False
34295>>>>>>>            End
34295>>>>>>>>
34295>>>>>>>        End
34295>>>>>>>>
34295>>>>>>>
34295>>>>>>>        // Check columns:
34295>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
34296>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
34297>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
34298>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
34299>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
34300>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
34301>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
34302>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
34303>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
34304>>>>>>>        If (bIsSame = False) Begin
34306>>>>>>>            Function_Return False
34307>>>>>>>        End
34307>>>>>>>>
34307>>>>>>>
34307>>>>>>>        // ...then check indexes:
34307>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
34308>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
34309>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
34310>>>>>>>        If (bIsSame = False) Begin
34312>>>>>>>            Function_Return False
34313>>>>>>>        End
34313>>>>>>>>
34313>>>>>>>
34313>>>>>>>        // ...and finally relationships:
34313>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
34314>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
34315>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
34316>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
34317>>>>>>>
34317>>>>>>>        Function_Return (bIsSame = True)
34318>>>>>>>    End_Function
34319>>>>>>>
34319>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
34319>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
34321>>>>>>>        Handle hTable
34321>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
34321>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
34321>>>>>>>
34321>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
34323>>>>>>>            Move True to bFilelistError
34324>>>>>>>            Function_Return False
34325>>>>>>>        End
34325>>>>>>>>
34325>>>>>>>
34325>>>>>>>        Move APITableCompare.hTable to hTable
34326>>>>>>>        Move True  to bIsSame
34327>>>>>>>        Move False to bFilelistError
34328>>>>>>>
34328>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
34330>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
34331>>>>>>>        End
34331>>>>>>>>
34331>>>>>>>        Else Begin
34332>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
34333>>>>>>>        End
34333>>>>>>>>
34333>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
34334>>>>>>>
34334>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
34335>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
34336>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
34337>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
34338>>>>>>>
34338>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
34338>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
34338>>>>>>>        If (bCodeGenerateMode = True) Begin
34340>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
34340>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
34342>>>>>>>                Function_Return False
34343>>>>>>>            End
34343>>>>>>>>
34343>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
34344>>>>>>>            If (bIsSame = False) Begin
34346>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
34347>>>>>>>                Move True to bFilelistError
34348>>>>>>>                Function_Return False
34349>>>>>>>            End
34349>>>>>>>>
34349>>>>>>>        End
34349>>>>>>>>
34349>>>>>>>
34349>>>>>>>        If (bCodeGenerateMode = False) Begin
34351>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
34353>>>>>>>                // Then we might want to create this table
34353>>>>>>>                Function_Return False
34354>>>>>>>            End
34354>>>>>>>>
34354>>>>>>>
34354>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
34355>>>>>>>            If (bIsSame = False) Begin
34357>>>>>>>                Function_Return False
34358>>>>>>>            End
34358>>>>>>>>
34358>>>>>>>
34358>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
34359>>>>>>>            If (bIsSame = False) Begin
34361>>>>>>>                Function_Return False
34362>>>>>>>            End
34362>>>>>>>>
34362>>>>>>>
34362>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
34363>>>>>>>            If (bIsSame = False) Begin
34365>>>>>>>                Function_Return False
34366>>>>>>>            End
34366>>>>>>>>
34366>>>>>>>
34366>>>>>>>            // Check table names et al.
34366>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
34367>>>>>>>            If (bIsSame = False) Begin
34369>>>>>>>                Function_Return False
34370>>>>>>>            End
34370>>>>>>>>
34370>>>>>>>        End
34370>>>>>>>>
34370>>>>>>>
34370>>>>>>>        // Check Columns:
34370>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
34371>>>>>>>        If (bIsSame = False) Begin
34373>>>>>>>            Function_Return False
34374>>>>>>>        End
34374>>>>>>>>
34374>>>>>>>
34374>>>>>>>        // ...then check Indexes:
34374>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
34375>>>>>>>        If (bIsSame = False) Begin
34377>>>>>>>            Function_Return False
34378>>>>>>>        End
34378>>>>>>>>
34378>>>>>>>
34378>>>>>>>        // ...and finally Relationships:
34378>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
34379>>>>>>>
34379>>>>>>>        Function_Return (bIsSame = True)
34380>>>>>>>    End_Function
34381>>>>>>>
34381>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
34381>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
34381>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
34381>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
34381>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
34383>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34383>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34383>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
34383>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
34385>>>>>>>        tAPIColumn[]    aApiColumns
34385>>>>>>>        tAPIColumn[]    aApiColumns
34386>>>>>>>        tAPIIndex[]     aApiIndexes
34386>>>>>>>        tAPIIndex[]     aApiIndexes
34387>>>>>>>        tAPIRelation[]  aApiRelations
34387>>>>>>>        tAPIRelation[]  aApiRelations
34388>>>>>>>        Handle hTable
34388>>>>>>>        Integer iCount
34388>>>>>>>        Boolean bUserCancel bOK
34388>>>>>>>        String sLogicalName sMessageText
34388>>>>>>>
34388>>>>>>>        Get AutoConnectionIDLogin to bOK
34389>>>>>>>        Move 0 to hTable
34390>>>>>>>        If (bFromTables = True) Begin
34392>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
34393>>>>>>>            If (bCompareUtil = True) Begin
34395>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
34396>>>>>>>            End
34396>>>>>>>>
34396>>>>>>>        End
34396>>>>>>>>
34396>>>>>>>        Else Begin
34397>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
34398>>>>>>>            If (bCompareUtil = True) Begin
34400>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
34401>>>>>>>            End
34401>>>>>>>>
34401>>>>>>>        End
34401>>>>>>>>
34401>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
34402>>>>>>>
34402>>>>>>>        Get UtilFilelistNoOfTables to iCount
34403>>>>>>>        Set piMaximum of ghoProgressBar to iCount
34404>>>>>>>        Move 0 to iCount
34405>>>>>>>
34405>>>>>>>        Repeat
34405>>>>>>>>
34405>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34408>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
34410>>>>>>>
34410>>>>>>>                Open hTable
34412>>>>>>>                // ToDo: Needs to be revised
34412>>>>>>>                // For some reason tables may be reported as "unopened", while in
34412>>>>>>>                // fact the open was successful (!)
34412>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34412>>>>>>>//                If (bIsOpen = False) Begin
34412>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
34412>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
34412>>>>>>>//                    Function_Return aApiTablesEmpty
34412>>>>>>>//                End
34412>>>>>>>
34412>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
34415>>>>>>>                Set piPosition of ghoProgressBar to iCount
34416>>>>>>>                Send DoAdvance of ghoProgressBarOverall
34417>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
34418>>>>>>>
34418>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
34419>>>>>>>//                Close hTable DF_PERMANENT
34419>>>>>>>                Increment iCount
34420>>>>>>>            End
34420>>>>>>>>
34420>>>>>>>
34420>>>>>>>            If (bStatusPanel = True) Begin
34422>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
34423>>>>>>>                If (bUserCancel = True) Begin
34425>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
34426>>>>>>>                    Function_Return aApiTablesEmpty
34427>>>>>>>                End
34427>>>>>>>>
34427>>>>>>>            End
34427>>>>>>>>
34427>>>>>>>
34427>>>>>>>        Until (hTable = 0)
34429>>>>>>>
34429>>>>>>>        Function_Return aApiTables
34430>>>>>>>    End_Function
34431>>>>>>>
34431>>>>>>>    // Returns a 'single' table APITable struct.
34431>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
34433>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34433>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34433>>>>>>>        tAPITable         ApiTable ApiTableEmpty
34433>>>>>>>        tAPITable         ApiTable ApiTableEmpty
34433>>>>>>>        tAPIColumn[]     aApiColumns
34433>>>>>>>        tAPIColumn[]     aApiColumns
34434>>>>>>>        tAPIIndex[]      aApiIndexes
34434>>>>>>>        tAPIIndex[]      aApiIndexes
34435>>>>>>>        tAPIRelation[]   aApiRelations
34435>>>>>>>        tAPIRelation[]   aApiRelations
34436>>>>>>>        Boolean bIsOpen
34436>>>>>>>
34436>>>>>>>        Open hTable
34438>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34441>>>>>>>        If (bIsOpen = False) Begin
34443>>>>>>>            Move True to ApiTableEmpty.bError
34444>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34445>>>>>>>            Function_Return ApiTableEmpty
34446>>>>>>>        End
34446>>>>>>>>
34446>>>>>>>
34446>>>>>>>        // Fill Table Name Info
34446>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
34447>>>>>>>
34447>>>>>>>        // Fill columns
34447>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
34448>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
34450>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
34452>>>>>>>                Move True to ApiTableEmpty.bError
34453>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34454>>>>>>>                Function_Return ApiTableEmpty
34455>>>>>>>            End
34455>>>>>>>>
34455>>>>>>>        End
34455>>>>>>>>
34455>>>>>>>
34455>>>>>>>        // Fill indexes
34455>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
34456>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
34458>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
34460>>>>>>>                Move True to ApiTableEmpty.bError
34461>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34462>>>>>>>                Function_Return ApiTableEmpty
34463>>>>>>>            End
34463>>>>>>>>
34463>>>>>>>        End
34463>>>>>>>>
34463>>>>>>>
34463>>>>>>>        // Fill relationships
34463>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
34464>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
34466>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
34468>>>>>>>                Move True to ApiTableEmpty.bError
34469>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
34470>>>>>>>                Function_Return ApiTableEmpty
34471>>>>>>>            End
34471>>>>>>>>
34471>>>>>>>        End
34471>>>>>>>>
34471>>>>>>>
34471>>>>>>>        Move hTable             to ApiTable.hTable
34472>>>>>>>        Move bFromTables        to ApiTable.bFromTable
34473>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
34474>>>>>>>
34474>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
34475>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
34476>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
34477>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
34478>>>>>>>
34478>>>>>>>        Function_Return ApiTable
34479>>>>>>>    End_Function
34480>>>>>>>
34480>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
34482>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
34482>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
34482>>>>>>>        Boolean bIsOpen
34482>>>>>>>
34482>>>>>>>        Open hTable
34484>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34487>>>>>>>        If (bIsOpen = False) Begin
34489>>>>>>>            Move True   to APITableNameInfoEmpty.bError
34490>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
34491>>>>>>>            Function_Return APITableNameInfoEmpty
34492>>>>>>>        End
34492>>>>>>>>
34492>>>>>>>
34492>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
34493>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
34496>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
34499>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
34502>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
34505>>>>>>>
34505>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
34506>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
34507>>>>>>>
34507>>>>>>>        Function_Return APITableNameInfo
34508>>>>>>>    End_Function
34509>>>>>>>
34509>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
34511>>>>>>>        Integer iSize iCount iItem
34511>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34511>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34511>>>>>>>
34511>>>>>>>        Move -1 to iItem
34512>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
34513>>>>>>>        Decrement iSize
34514>>>>>>>        for iCount from 0 to iSize
34520>>>>>>>>
34520>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
34521>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
34523>>>>>>>                Move iCount to iItem
34524>>>>>>>                Move iSize  to iCount // We're done.
34525>>>>>>>            End
34525>>>>>>>>
34525>>>>>>>        Loop
34526>>>>>>>>
34526>>>>>>>
34526>>>>>>>        Function_Return iItem
34527>>>>>>>    End_Function
34528>>>>>>>
34528>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
34530>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
34533>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
34536>>>>>>>
34536>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
34539>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
34542>>>>>>>
34542>>>>>>>        Function_Return (EQ)
34543>>>>>>>    End_Function
34544>>>>>>>
34544>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
34546>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
34546>>>>>>>        Handle hTable
34546>>>>>>>        tAPITable[] aAPITableFromAndTo
34546>>>>>>>        tAPITable[] aAPITableFromAndTo
34547>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
34547>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
34547>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34547>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34547>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
34547>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
34548>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34548>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34549>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34549>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34550>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34550>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34551>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
34551>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
34551>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
34551>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
34554>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
34554>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
34557>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
34557>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
34560>>>>>>>
34560>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
34561>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
34562>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
34564>>>>>>>            Function_Return aAPITableCompare
34565>>>>>>>        End
34565>>>>>>>>
34565>>>>>>>
34565>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
34566>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
34567>>>>>>>
34567>>>>>>>        Move 0 to iItem
34568>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
34569>>>>>>>        Decrement iSize
34570>>>>>>>        for iCount from 0 to iSize
34576>>>>>>>>
34576>>>>>>>
34576>>>>>>>            Move iCount to iItemFrom
34577>>>>>>>            Move iCount to iItemTo
34578>>>>>>>            Move APITableEmpty to APITableFrom
34579>>>>>>>            Move APITableEmpty to APITableTo
34580>>>>>>>
34580>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
34582>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
34583>>>>>>>            End
34583>>>>>>>>
34583>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
34585>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
34586>>>>>>>            End
34586>>>>>>>>
34586>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
34588>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
34589>>>>>>>                Move (iCount + 1) to iItemTo
34590>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
34591>>>>>>>            End
34591>>>>>>>>
34591>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
34593>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
34594>>>>>>>                If (iItemTo <> -1) Begin
34596>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
34597>>>>>>>                End
34597>>>>>>>>
34597>>>>>>>                Else Begin
34598>>>>>>>                    Move APITableEmpty to APITableTo
34599>>>>>>>                End
34599>>>>>>>>
34599>>>>>>>            End
34599>>>>>>>>
34599>>>>>>>
34599>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
34600>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
34601>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
34602>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
34603>>>>>>>
34603>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
34604>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
34605>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
34606>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
34607>>>>>>>
34607>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
34608>>>>>>>
34608>>>>>>>            If (hTable > 0) Begin
34610>>>>>>>
34610>>>>>>>                // Table info:
34610>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
34611>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
34612>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
34613>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
34614>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
34615>>>>>>>
34615>>>>>>>                // Column info:
34615>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
34616>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
34617>>>>>>>
34617>>>>>>>                // Index info:
34617>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
34618>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
34619>>>>>>>
34619>>>>>>>                // Relation info:
34619>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
34620>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
34621>>>>>>>
34621>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
34622>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
34623>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
34624>>>>>>>                If (iItemTo > iItemFrom) Begin
34626>>>>>>>                    Increment iCount
34627>>>>>>>                End
34627>>>>>>>>
34627>>>>>>>                Increment iItem
34628>>>>>>>            End
34628>>>>>>>>
34628>>>>>>>
34628>>>>>>>        Loop
34629>>>>>>>>
34629>>>>>>>
34629>>>>>>>        Function_Return aAPITableCompare
34630>>>>>>>    End_Function
34631>>>>>>>
34631>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
34633>>>>>>>        Integer iSize iCount iItem
34633>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34633>>>>>>>        tAPITableNameInfo ApiTableNameInfo
34633>>>>>>>
34633>>>>>>>        Move -1 to iItem
34634>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
34635>>>>>>>        Decrement iSize
34636>>>>>>>        For iCount from 0 to iSize
34642>>>>>>>>
34642>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
34643>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
34645>>>>>>>                Move iCount to iItem
34646>>>>>>>                Move iSize  to iCount // We're done.
34647>>>>>>>            End
34647>>>>>>>>
34647>>>>>>>        Loop
34648>>>>>>>>
34648>>>>>>>
34648>>>>>>>        Function_Return iItem
34649>>>>>>>    End_Function
34650>>>>>>>
34650>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
34652>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34652>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
34652>>>>>>>
34652>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
34654>>>>>>>            Function_Return APITableNameInfoCompare
34655>>>>>>>        End
34655>>>>>>>>
34655>>>>>>>
34655>>>>>>>        // FROM database info:
34655>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
34657>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
34658>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
34659>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
34660>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
34661>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
34662>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
34663>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
34664>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
34665>>>>>>>        End
34665>>>>>>>>
34665>>>>>>>
34665>>>>>>>        // TO database info:
34665>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
34667>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
34668>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
34669>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
34670>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
34671>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
34672>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
34673>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
34674>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
34675>>>>>>>        End
34675>>>>>>>>
34675>>>>>>>
34675>>>>>>>        Function_Return APITableNameInfoCompare
34676>>>>>>>    End_Function
34677>>>>>>>
34677>>>>>>>    // Note:
34677>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
34677>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
34677>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
34677>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
34677>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
34677>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
34679>>>>>>>        String sTableName
34679>>>>>>>        Boolean bOpen bExists bOK
34679>>>>>>>
34679>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
34680>>>>>>>        If (bExists = False) Begin
34682>>>>>>>            Function_Return ""
34683>>>>>>>        End
34683>>>>>>>>
34683>>>>>>>
34683>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34684>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
34687>>>>>>>        If (bOpen = False) Begin
34689>>>>>>>            Get AutoConnectionIDLogin to bOK
34690>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
34691>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
34692>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
34693>>>>>>>            Open hTable
34695>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
34696>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
34697>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
34698>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
34701>>>>>>>        End
34701>>>>>>>>
34701>>>>>>>        If (bOpen = True) Begin
34703>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
34704>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
34707>>>>>>>            // If blank it is an embedded table:
34707>>>>>>>            If (sTableName = "") Begin
34709>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
34712>>>>>>>                Move 0 to LastErr
34713>>>>>>>                Move False to Err
34714>>>>>>>            End
34714>>>>>>>>
34714>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
34715>>>>>>>        End
34715>>>>>>>>
34715>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34716>>>>>>>        Move 0 to LastErr
34717>>>>>>>
34717>>>>>>>        Function_Return sTableName
34718>>>>>>>    End_Function
34719>>>>>>>
34719>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
34719>>>>>>>    // Returns 0 if unsuccessful.
34719>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
34719>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
34721>>>>>>>        String sValue sPrefixTableName sDriverID
34721>>>>>>>        Handle hTable hRetval
34721>>>>>>>
34721>>>>>>>        Get psDriverID to sDriverID
34722>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
34724>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
34725>>>>>>>        End
34725>>>>>>>>
34725>>>>>>>        Move 0 to hTable
34726>>>>>>>        Move 0 to hRetval
34727>>>>>>>        Repeat
34727>>>>>>>>
34727>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34730>>>>>>>            If (hTable <> 0) Begin
34732>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
34735>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
34737>>>>>>>                    Move hTable to hRetval
34738>>>>>>>                    Move 0 to hTable
34739>>>>>>>                End
34739>>>>>>>>
34739>>>>>>>            End
34739>>>>>>>>
34739>>>>>>>        Until (hTable = 0)
34741>>>>>>>
34741>>>>>>>        Function_Return hRetval
34742>>>>>>>    End_Function
34743>>>>>>>
34743>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
34743>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
34743>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
34745>>>>>>>        Boolean bOK bExists
34745>>>>>>>        String sDataPath sBackupFolder
34745>>>>>>>
34745>>>>>>>        Close DF_ALL DF_PERMANENT
34746>>>>>>>        Send DoAdvance of ghoProgressBar
34747>>>>>>>
34747>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
34748>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
34749>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
34750>>>>>>>        Get vFolderFormat sDataPath to sDataPath
34751>>>>>>>
34751>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
34752>>>>>>>        If (bExists = False) Begin
34754>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
34755>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
34756>>>>>>>            If (bExists = False) Begin
34758>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
34759>>>>>>>>
34759>>>>>>>                Function_Return False
34760>>>>>>>            End
34760>>>>>>>>
34760>>>>>>>        End
34760>>>>>>>>
34760>>>>>>>
34760>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
34761>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
34762>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
34763>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
34764>>>>>>>        // We need to wait for Windows before we can copy files back
34764>>>>>>>        Sleep 2  
34765>>>>>>>        
34765>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
34765>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
34766>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
34767>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
34768>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
34769>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
34770>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
34771>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
34771>>>>>>>        
34771>>>>>>>
34771>>>>>>>        Set Message_Text of ghoStatusPanel to ""
34772>>>>>>>        Function_Return True
34773>>>>>>>    End_Function
34774>>>>>>>    
34774>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
34776>>>>>>>        Boolean bOK bRetval
34776>>>>>>>        Handle hTable
34776>>>>>>>        Integer iSize iCount
34776>>>>>>>        
34776>>>>>>>        Move True to bOK
34777>>>>>>>        Get UtilFilelistNoOfTables to iSize
34778>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
34779>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
34780>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
34781>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
34782>>>>>>>
34782>>>>>>>        Repeat
34782>>>>>>>>
34782>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
34783>>>>>>>            Increment iCount
34784>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34787>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
34789>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
34790>>>>>>>                If (bRetval = False) Begin
34792>>>>>>>                    Move False to bOK
34793>>>>>>>                End
34793>>>>>>>>
34793>>>>>>>            End
34793>>>>>>>>
34793>>>>>>>        Until (hTable = 0)
34795>>>>>>>                
34795>>>>>>>        Function_Return bOK
34796>>>>>>>    End_Function           
34797>>>>>>>    
34797>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
34797>>>>>>>    // After the header has been repaired - also makes a re-index.  
34797>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
34797>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
34799>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
34799>>>>>>>        Integer iRetval
34799>>>>>>>        String sRootName sFileName sDataPath
34799>>>>>>>        
34799>>>>>>>        Move False to Err
34800>>>>>>>        Move 0 to LastErr 
34801>>>>>>>        Move True to bOK
34802>>>>>>>        
34802>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
34803>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
34805>>>>>>>            Function_Return True
34806>>>>>>>        End
34806>>>>>>>>
34806>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
34807>>>>>>>        If (bIsAlias = True) Begin
34809>>>>>>>            Function_Return True
34810>>>>>>>        End
34810>>>>>>>>
34810>>>>>>>        
34810>>>>>>>        // Check for bad file and remove if exists
34810>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
34813>>>>>>>        Set private.phCurrentTable to hTable  
34814>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
34815>>>>>>>        
34815>>>>>>>        // This is important! Else it can happen that the table can't be opened,
34815>>>>>>>        // with a "4077 - File in use" error.
34815>>>>>>>        Close DF_ALL DF_PERMANENT    
34816>>>>>>>        Open hTable
34818>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34821>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34822>>>>>>>        If (bIsOpen = False) Begin
34824>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
34825>>>>>>>>
34825>>>>>>>            Function_Return False        
34826>>>>>>>        End
34826>>>>>>>>
34826>>>>>>>
34826>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
34827>>>>>>>        If (bBadExists = True) Begin
34829>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
34830>>>>>>>            Get vDeleteFile sFileName to iRetval
34831>>>>>>>        End
34831>>>>>>>>
34831>>>>>>>        
34831>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
34832>>>>>>>        
34832>>>>>>>        Move False to Err
34833>>>>>>>        // **** Repair and reindex the table. ****
34833>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
34834>>>>>>>
34834>>>>>>>        // Check for bad file: if it exists, something went wrong
34834>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
34835>>>>>>>        Get vFolderFormat sDataPath to sDataPath
34836>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
34837>>>>>>>        If (bBadExists = True) Begin
34839>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
34840>>>>>>>>
34840>>>>>>>            Move False to bOK
34841>>>>>>>        End
34841>>>>>>>>
34841>>>>>>>        Close hTable
34842>>>>>>>
34842>>>>>>>        Function_Return bOK
34843>>>>>>>    End_Function
34844>>>>>>>
34844>>>>>>>    // Repair and reindex the named DataFlex data-table.
34844>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
34844>>>>>>>    // so use with care (make sure you only pass embedded table names).
34844>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
34846>>>>>>>        String sMode
34846>>>>>>>        Integer iVoid
34846>>>>>>>
34846>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
34847>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
34848>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
34849>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
34854>>>>>>>        Set Message_Text of ghoStatusPanel to ""
34855>>>>>>>        Function_Return (iVoid = 0)
34856>>>>>>>    End_Function
34857>>>>>>>
34857>>>>>>>    // Returns _two_ arrays.
34857>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
34857>>>>>>>    // Also returns all files that are Alias files in a second array.
34857>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
34857>>>>>>>    //            the DoSetAllMasterAndAlias message.
34857>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
34859>>>>>>>        Integer[] iaFileIsAlias
34860>>>>>>>        Integer hTable iFileAlias iSize
34860>>>>>>>        Boolean bOpen
34860>>>>>>>
34860>>>>>>>        Move 0 to hTable
34861>>>>>>>        Repeat
34861>>>>>>>>
34861>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
34864>>>>>>>            If (hTable <> 0) Begin
34866>>>>>>>                Open hTable
34868>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
34871>>>>>>>                If (bOpen = True) Begin
34873>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
34876>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
34878>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
34879>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
34880>>>>>>>                    End
34880>>>>>>>>
34880>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
34883>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
34884>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
34885>>>>>>>                    End
34885>>>>>>>>
34885>>>>>>>                End
34885>>>>>>>>
34885>>>>>>>            End
34885>>>>>>>>
34885>>>>>>>        Until (hTable = 0)
34887>>>>>>>
34887>>>>>>>        Function_Return iaFileIsAlias
34888>>>>>>>    End_Function  
34889>>>>>>>    
34889>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
34889>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
34891>>>>>>>        String sMode
34891>>>>>>>        Integer iRepairNeeded bIsOpen
34891>>>>>>>
34891>>>>>>>        Move "0" to sMode
34892>>>>>>>        Set private.phCurrentTable to hTable 
34893>>>>>>>        Close hTable
34894>>>>>>>        Open hTable
34896>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34899>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
34904>>>>>>>
34904>>>>>>>        Function_Return iRepairNeeded
34905>>>>>>>    End_Function
34906>>>>>>>
34906>>>>>>>
34906>>>>>>>    // Helper function
34906>>>>>>>    // Takes two params:
34906>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
34906>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
34906>>>>>>>    // Returns:
34906>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
34906>>>>>>>    //  DF_FILE_IS_MASTER if master
34906>>>>>>>    //  DF_FILE_IS_ALIAS if alias
34906>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
34908>>>>>>>        Integer i iSize
34908>>>>>>>
34908>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
34909>>>>>>>        Decrement iSize
34910>>>>>>>        for i from 0 to iSize
34916>>>>>>>>
34916>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
34918>>>>>>>                Function_Return DF_FILE_IS_MASTER
34919>>>>>>>            End
34919>>>>>>>>
34919>>>>>>>        Loop
34920>>>>>>>>
34920>>>>>>>
34920>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
34921>>>>>>>        Decrement iSize
34922>>>>>>>        for i from 0 to iSize
34928>>>>>>>>
34928>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
34930>>>>>>>                Function_Return DF_FILE_IS_ALIAS
34931>>>>>>>            End
34931>>>>>>>>
34931>>>>>>>        Loop
34932>>>>>>>>
34932>>>>>>>
34932>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
34933>>>>>>>    End_Function
34934>>>>>>>
34934>>>>>>>    // Determine the available indexes of a table.
34934>>>>>>>    //
34934>>>>>>>    // Arguments:
34934>>>>>>>    //   Handle hTable - The number of the table
34934>>>>>>>    //
34934>>>>>>>    // Returns:
34934>>>>>>>    //   String - A string to be used with the sort command
34934>>>>>>>    //   to re-index all indexes of a table.
34934>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
34936>>>>>>>        String  sSortString
34936>>>>>>>        Integer iLastIndex iNumSegments iCount
34936>>>>>>>
34936>>>>>>>        Move "" to sSortString
34937>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
34940>>>>>>>
34940>>>>>>>        for iCount from 1 to iLastIndex
34946>>>>>>>>
34946>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
34949>>>>>>>            If iNumSegments Begin
34951>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
34954>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
34955>>>>>>>            End
34955>>>>>>>>
34955>>>>>>>        Loop
34956>>>>>>>>
34956>>>>>>>
34956>>>>>>>        Function_Return sSortString
34957>>>>>>>    End_Function
34958>>>>>>>
34958>>>>>>>    
34958>>>>>>>    // * Dummy function for the Studio's Code Explorer *
34958>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
34960>>>>>>>        Function_Return False
34961>>>>>>>    End_Function
34962>>>>>>>
34962>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
34962>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
34964>>>>>>>        Boolean bIsSame
34964>>>>>>>        Integer iCount iColumns iColumn
34964>>>>>>>
34964>>>>>>>        Move True to bIsSame
34965>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
34966>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
34967>>>>>>>        Decrement iColumns
34968>>>>>>>
34968>>>>>>>        for iCount from 0 to iColumns
34974>>>>>>>>
34974>>>>>>>            Set piPosition of ghoProgressBar to iCount
34975>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
34976>>>>>>>            If (bIsSame = False) Begin
34978>>>>>>>                Function_Return False
34979>>>>>>>            End
34979>>>>>>>>
34979>>>>>>>        Loop
34980>>>>>>>>
34980>>>>>>>
34980>>>>>>>        Function_Return (bIsSame = True)
34981>>>>>>>    End_Function
34982>>>>>>>
34982>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
34982>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
34984>>>>>>>        Integer iFromType iToType iDbType
34984>>>>>>>        tColumnType ColumnType
34984>>>>>>>        tColumnType ColumnType
34984>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
34984>>>>>>>
34984>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
34986>>>>>>>            Function_Return False
34987>>>>>>>        End
34987>>>>>>>>
34987>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
34989>>>>>>>            Function_Return False
34990>>>>>>>        End
34990>>>>>>>>
34990>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
34992>>>>>>>            Function_Return False
34993>>>>>>>        End                                                                
34993>>>>>>>>
34993>>>>>>>
34993>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
34995>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
34997>>>>>>>                Function_Return False
34998>>>>>>>            End
34998>>>>>>>>
34998>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
35000>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
35002>>>>>>>                    End
35002>>>>>>>>
35002>>>>>>>                Else Begin
35003>>>>>>>                    Function_Return False
35004>>>>>>>                End
35004>>>>>>>>
35004>>>>>>>            End
35004>>>>>>>>
35004>>>>>>>        End
35004>>>>>>>>
35004>>>>>>>
35004>>>>>>>        Get piDbType                       to iDbType
35005>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
35006>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
35007>>>>>>>
35007>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
35007>>>>>>>        // data types between Embedded and SQL.
35007>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
35009>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
35010>>>>>>>        End
35010>>>>>>>>
35010>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
35012>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
35013>>>>>>>        End
35013>>>>>>>>
35013>>>>>>>
35013>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
35014>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
35015>>>>>>>
35015>>>>>>>        // Make Date and DateTime comparison?
35015>>>>>>>        If (bCompareDate_DataTime = True) Begin
35017>>>>>>>            If (iFromType <> iToType) Begin
35019>>>>>>>                Function_Return False
35020>>>>>>>            End
35020>>>>>>>>
35020>>>>>>>        End
35020>>>>>>>>
35020>>>>>>>
35020>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
35020>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
35022>>>>>>>            If (iFromType <> iToType) Begin
35024>>>>>>>                Function_Return False
35025>>>>>>>            End
35025>>>>>>>>
35025>>>>>>>        End
35025>>>>>>>>
35025>>>>>>>
35025>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
35025>>>>>>>        If (bIsDateTypeFrom = False) Begin
35027>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
35029>>>>>>>                Function_Return False
35030>>>>>>>            End
35030>>>>>>>>
35030>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
35032>>>>>>>                Function_Return False
35033>>>>>>>            End
35033>>>>>>>>
35033>>>>>>>        End
35033>>>>>>>>
35033>>>>>>>
35033>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
35035>>>>>>>            Function_Return False
35036>>>>>>>        End
35036>>>>>>>>
35036>>>>>>>
35036>>>>>>>        Function_Return True
35037>>>>>>>    End_Function
35038>>>>>>>
35038>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
35040>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
35040>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
35040>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
35040>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
35042>>>>>>>        String sDriverID sRootName sLogicalName
35042>>>>>>>
35042>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35043>>>>>>>        Get piDbType to iDbType
35044>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
35047>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
35050>>>>>>>
35050>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35053>>>>>>>        If (bIsOpen = False) Begin
35055>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35056>>>>>>>            Open hTable
35058>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35059>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35062>>>>>>>            If (bIsOpen = False) Begin
35064>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35065>>>>>>>                Move True to APIColumnsEmpty[0].bError
35066>>>>>>>                Function_Return APIColumnsEmpty
35067>>>>>>>            End
35067>>>>>>>>
35067>>>>>>>        End
35067>>>>>>>>
35067>>>>>>>
35067>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35070>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
35071>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
35072>>>>>>>
35072>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
35073>>>>>>>        If (bIsSqlTable = True) Begin
35075>>>>>>>            Get UtilTableExists hTable to bExists
35076>>>>>>>            If (bExists = False) Begin
35078>>>>>>>                Move True to APIColumnsEmpty[0].bError
35079>>>>>>>                Function_Return APIColumnsEmpty
35080>>>>>>>            End
35080>>>>>>>>
35080>>>>>>>        End
35080>>>>>>>>
35080>>>>>>>
35080>>>>>>>        Move 0 to iCount
35081>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35084>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
35085>>>>>>>
35085>>>>>>>        for iColumn from 1 to iNumColumns
35091>>>>>>>>
35091>>>>>>>            Move 0 to iOptions
35092>>>>>>>            Move False to bIdentityKey
35093>>>>>>>            Move False to Err
35094>>>>>>>            Move 0     to LastErr
35095>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
35096>>>>>>>            Set piPosition of ghoProgressBar to iColumn
35097>>>>>>>            If (bDawSqlDriver = True) Begin
35099>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35100>>>>>>>                If (bIsSqlTable = True) Begin
35102>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
35105>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
35106>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
35109>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
35112>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
35115>>>>>>>                End
35115>>>>>>>>
35115>>>>>>>                Else Begin
35116>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
35119>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
35120>>>>>>>                End
35120>>>>>>>>
35120>>>>>>>
35120>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
35120>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
35123>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
35124>>>>>>>                If (bExists = False) Begin
35126>>>>>>>                    Move 0 to APIColumns[iCount].iType
35127>>>>>>>                End
35127>>>>>>>>
35127>>>>>>>                If (bExists = True) Begin
35129>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
35132>>>>>>>                End
35132>>>>>>>>
35132>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35133>>>>>>>                If (bIdentityKey = True) Begin
35135>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
35136>>>>>>>                End
35136>>>>>>>>
35136>>>>>>>            End
35136>>>>>>>>
35136>>>>>>>            Else Begin
35137>>>>>>>                Move False to Err
35138>>>>>>>                Move 0     to LastErr
35139>>>>>>>                If (bIsSqlTable = True) Begin
35141>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
35144>>>>>>>                End
35144>>>>>>>>
35144>>>>>>>                Else Begin
35145>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
35148>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
35149>>>>>>>                End
35149>>>>>>>>
35149>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
35149>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
35150>>>>>>>                If (bExists = False) Begin
35152>>>>>>>                    Move 0 to APIColumns[iCount].iType
35153>>>>>>>                End
35153>>>>>>>>
35153>>>>>>>            End
35153>>>>>>>>
35153>>>>>>>
35153>>>>>>>            If (bExists = True) Begin
35155>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
35156>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
35159>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
35159>>>>>>>//                If (bIsSqlTable = True) Begin
35159>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
35159>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
35159>>>>>>>//                End
35159>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
35162>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
35165>>>>>>>
35165>>>>>>>                // If the length was zero we might have an Overlap(!) field.
35165>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
35165>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
35167>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
35170>>>>>>>                    If (iType = DF_OVERLAP) Begin
35172>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
35173>>>>>>>                        Move 0 to APIColumns[iCount].iLength
35174>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
35175>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
35176>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
35177>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
35178>>>>>>>                        Decrement iCount
35179>>>>>>>                    End
35179>>>>>>>>
35179>>>>>>>                End
35179>>>>>>>>
35179>>>>>>>            End
35179>>>>>>>>
35179>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
35180>>>>>>>            If (bUserCancel = True) Begin
35182>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
35183>>>>>>>                Function_Return APIColumnsEmpty
35184>>>>>>>            End
35184>>>>>>>>
35184>>>>>>>            Increment iCount
35185>>>>>>>        Loop
35186>>>>>>>>
35186>>>>>>>
35186>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35187>>>>>>>        Function_Return APIColumns
35188>>>>>>>    End_Function
35189>>>>>>>
35189>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
35189>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
35189>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
35189>>>>>>>    // have "holes" in the series of index numbers.
35189>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
35191>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35191>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35192>>>>>>>        tAPIColumnCompare   APIColumnCompare
35192>>>>>>>        tAPIColumnCompare   APIColumnCompare
35192>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
35192>>>>>>>
35192>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
35193>>>>>>>        Decrement iSizeFrom
35194>>>>>>>        for iCount from 0 to iSizeFrom
35200>>>>>>>>
35200>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
35201>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
35202>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
35203>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
35204>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
35205>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
35206>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
35207>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
35208>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
35209>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
35210>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
35211>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
35212>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
35213>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
35214>>>>>>>        Loop
35215>>>>>>>>
35215>>>>>>>
35215>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
35216>>>>>>>        Decrement iSizeTo
35217>>>>>>>        for iCount from 0 to iSizeTo
35223>>>>>>>>
35223>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
35224>>>>>>>            // Search if the field number already exists in the array; else add it.
35224>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
35225>>>>>>>            If (iItem = -1) Begin
35227>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
35228>>>>>>>            End
35228>>>>>>>>
35228>>>>>>>
35228>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
35229>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
35230>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
35231>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
35232>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
35233>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
35234>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
35235>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
35236>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
35237>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
35238>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
35239>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
35240>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
35241>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
35242>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
35243>>>>>>>        Loop
35244>>>>>>>>
35244>>>>>>>
35244>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
35245>>>>>>>
35245>>>>>>>        Function_Return aAPIColumnCompare
35246>>>>>>>    End_Function
35247>>>>>>>
35247>>>>>>>    // Checks if a field name exists in a table definition
35247>>>>>>>    // Returns True if it does
35247>>>>>>>    // Sample:
35247>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
35247>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
35249>>>>>>>        Integer iNumColumns iColumn
35249>>>>>>>        String sColumn
35249>>>>>>>        Boolean bExists bOK bOpen
35249>>>>>>>
35249>>>>>>>        Get AutoConnectionIDLogin to bOK
35250>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35251>>>>>>>        Open hTable
35253>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35254>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
35257>>>>>>>        If (bOpen = False) Begin
35259>>>>>>>            Function_Return False
35260>>>>>>>        End
35260>>>>>>>>
35260>>>>>>>
35260>>>>>>>        Move False to bExists
35261>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35264>>>>>>>        for iColumn from 1 to iNumColumns
35270>>>>>>>>
35270>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
35273>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
35275>>>>>>>                Move iNumColumns to iColumn
35276>>>>>>>                Move True to bExists
35277>>>>>>>            End
35277>>>>>>>>
35277>>>>>>>        Loop
35278>>>>>>>>
35278>>>>>>>        Close hTable
35279>>>>>>>
35279>>>>>>>        Function_Return bExists
35280>>>>>>>    End_Function
35281>>>>>>>
35281>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
35281>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
35283>>>>>>>        Integer iNumColumns iColumn iRetval
35283>>>>>>>        String sColumn
35283>>>>>>>        Boolean bOK bOpen
35283>>>>>>>
35283>>>>>>>        Get AutoConnectionIDLogin to bOK
35284>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35285>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35286>>>>>>>        Open hTable
35288>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35289>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
35292>>>>>>>        If (bOpen = False) Begin
35294>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35295>>>>>>>            Function_Return False
35296>>>>>>>        End
35296>>>>>>>>
35296>>>>>>>
35296>>>>>>>        Move 0 to iColumn
35297>>>>>>>        Move 0 to iRetval
35298>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35301>>>>>>>        for iColumn from 1 to iNumColumns
35307>>>>>>>>
35307>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
35310>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
35312>>>>>>>                Move iColumn to iRetval
35313>>>>>>>                Move iNumColumns to iColumn
35314>>>>>>>            End
35314>>>>>>>>
35314>>>>>>>        Loop
35315>>>>>>>>
35315>>>>>>>        Close hTable
35316>>>>>>>
35316>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35317>>>>>>>        Function_Return iRetval
35318>>>>>>>    End_Function
35319>>>>>>>
35319>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
35319>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
35319>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
35321>>>>>>>        tColumnType RetvalType
35321>>>>>>>        tColumnType RetvalType
35321>>>>>>>
35321>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
35322>>>>>>>        Function_Return RetvalType.iSQLType
35323>>>>>>>    End_Function
35324>>>>>>>
35324>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
35324>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
35324>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
35326>>>>>>>        tColumnType RetvalType
35326>>>>>>>        tColumnType RetvalType
35326>>>>>>>
35326>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35327>>>>>>>        Function_Return RetvalType.sSQLType
35328>>>>>>>    End_Function
35329>>>>>>>
35329>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
35331>>>>>>>        tColumnType RetvalType
35331>>>>>>>        tColumnType RetvalType
35331>>>>>>>
35331>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35332>>>>>>>        Function_Return RetvalType.sPrecision
35333>>>>>>>    End_Function
35334>>>>>>>
35334>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
35336>>>>>>>        tColumnType RetvalType
35336>>>>>>>        tColumnType RetvalType
35336>>>>>>>
35336>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35337>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
35337>>>>>>>        // if the column type length is _not_ fixed.
35337>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
35338>>>>>>>    End_Function
35339>>>>>>>
35339>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
35341>>>>>>>        tColumnType RetvalType
35341>>>>>>>        tColumnType RetvalType
35341>>>>>>>        String sValue
35341>>>>>>>        Integer iRetval iPos
35341>>>>>>>
35341>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35342>>>>>>>        Move RetvalType.sPrecision to sValue
35343>>>>>>>        Move (Pos(".", sValue)) to iPos
35344>>>>>>>        If (iPos <> 0) Begin
35346>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
35347>>>>>>>        End
35347>>>>>>>>
35347>>>>>>>        Else Begin
35348>>>>>>>            Move sValue to iRetval
35349>>>>>>>        End
35349>>>>>>>>
35349>>>>>>>        Function_Return iRetval
35350>>>>>>>    End_Function
35351>>>>>>>
35351>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
35353>>>>>>>        tColumnType RetvalType
35353>>>>>>>        tColumnType RetvalType
35353>>>>>>>        String sValue
35353>>>>>>>        Integer iRetval iPos
35353>>>>>>>
35353>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
35354>>>>>>>        Move RetvalType.sPrecision to sValue
35355>>>>>>>        Move (Pos(".", sValue)) to iPos
35356>>>>>>>        If (iPos = 0) Begin
35358>>>>>>>            Function_Return 0
35359>>>>>>>        End
35359>>>>>>>>
35359>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
35360>>>>>>>
35360>>>>>>>        Function_Return iRetval
35361>>>>>>>    End_Function
35362>>>>>>>
35362>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35362>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
35364>>>>>>>        Function_Return False
35365>>>>>>>    End_Function
35366>>>>>>>
35366>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
35366>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
35368>>>>>>>        Boolean bIsSame
35368>>>>>>>        Integer iCount iSize
35368>>>>>>>
35368>>>>>>>        Move True to bIsSame
35369>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
35370>>>>>>>        Decrement iSize
35371>>>>>>>        For iCount from 0 to iSize
35377>>>>>>>>
35377>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35378>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35379>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
35380>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35381>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35382>>>>>>>            If (bIsSame = False) Begin
35384>>>>>>>                Function_Return False
35385>>>>>>>            End
35385>>>>>>>>
35385>>>>>>>        Loop
35386>>>>>>>>
35386>>>>>>>
35386>>>>>>>        Function_Return bIsSame
35387>>>>>>>    End_Function
35388>>>>>>>
35388>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
35388>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
35390>>>>>>>        Boolean bIsSame
35390>>>>>>>        Integer iSegment
35390>>>>>>>
35390>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
35391>>>>>>>        If (bIsSame = False) Begin
35393>>>>>>>            Function_Return False
35394>>>>>>>        End
35394>>>>>>>>
35394>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
35395>>>>>>>        If (bIsSame = False) Begin
35397>>>>>>>            Function_Return False
35398>>>>>>>        End
35398>>>>>>>>
35398>>>>>>>
35398>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
35400>>>>>>>            // * We should probably not compare SQL index names?
35400>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
35400>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
35400>>>>>>>            //     Function_Return False
35400>>>>>>>            // End
35400>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
35401>>>>>>>            If (bIsSame = False) Begin
35403>>>>>>>                Function_Return False
35404>>>>>>>            End
35404>>>>>>>>
35404>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
35405>>>>>>>            If (bIsSame = False) Begin
35407>>>>>>>                Function_Return False
35408>>>>>>>            End
35408>>>>>>>>
35408>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
35409>>>>>>>            If (bIsSame = False) Begin
35411>>>>>>>                Function_Return False
35412>>>>>>>            End
35412>>>>>>>>
35412>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
35413>>>>>>>            If (bIsSame = False) Begin
35415>>>>>>>                Function_Return False
35416>>>>>>>            End
35416>>>>>>>>
35416>>>>>>>        End
35416>>>>>>>>
35416>>>>>>>
35416>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
35417>>>>>>>        Move (iSegment = -1) to bIsSame
35418>>>>>>>
35418>>>>>>>        Function_Return (bIsSame = True)
35419>>>>>>>    End_Function
35420>>>>>>>
35420>>>>>>>    // Compares each segment for the passed index.
35420>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
35420>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
35422>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
35422>>>>>>>        Boolean bIsSame
35422>>>>>>>
35422>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35423>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35424>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
35425>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
35426>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
35427>>>>>>>
35427>>>>>>>        Decrement iNumSegments
35428>>>>>>>        for iSegment from 0 to iNumSegments
35434>>>>>>>>
35434>>>>>>>            Move False to bIsSame
35435>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
35437>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
35438>>>>>>>            End
35438>>>>>>>>
35438>>>>>>>            If (bIsSame = False) Begin
35440>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35441>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35442>>>>>>>                Function_Return iSegment
35443>>>>>>>            End
35443>>>>>>>>
35443>>>>>>>        Loop
35444>>>>>>>>
35444>>>>>>>
35444>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35445>>>>>>>        Function_Return -1 // This means bIsSame = True
35446>>>>>>>    End_Function
35447>>>>>>>
35447>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
35449>>>>>>>        Boolean bIsSame
35449>>>>>>>
35449>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
35450>>>>>>>        If (bIsSame = False) Begin
35452>>>>>>>            Function_Return False
35453>>>>>>>        End
35453>>>>>>>>
35453>>>>>>>        If (bCompareIndexUppercase = True) Begin
35455>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
35456>>>>>>>            If (bIsSame = False) Begin
35458>>>>>>>                Function_Return False
35459>>>>>>>            End
35459>>>>>>>>
35459>>>>>>>        End
35459>>>>>>>>
35459>>>>>>>        If (bCompareIndexAscending = True) Begin
35461>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
35462>>>>>>>            If (bIsSame = False) Begin
35464>>>>>>>                Function_Return False
35465>>>>>>>            End
35465>>>>>>>>
35465>>>>>>>        End
35465>>>>>>>>
35465>>>>>>>
35465>>>>>>>        Function_Return True
35466>>>>>>>    End_Function
35467>>>>>>>
35467>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
35469>>>>>>>        Boolean bIsSame bOK
35469>>>>>>>        Integer iSize iSizeTo iCount
35469>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35469>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35470>>>>>>>
35470>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
35471>>>>>>>        If (iSize = 0) Begin
35473>>>>>>>            Function_Return True
35474>>>>>>>        End
35474>>>>>>>>
35474>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
35475>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
35476>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
35477>>>>>>>
35477>>>>>>>        for iCount from 0 to (iSize - 1)
35483>>>>>>>>
35483>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
35484>>>>>>>            If (bIsSame = False) Begin
35486>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
35487>>>>>>>            End
35487>>>>>>>>
35487>>>>>>>        Loop
35488>>>>>>>>
35488>>>>>>>
35488>>>>>>>        // We probably should delete other indexes if they exists.
35488>>>>>>>        for iCount from (iSize +1) to iSizeTo
35494>>>>>>>>
35494>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
35495>>>>>>>        Loop
35496>>>>>>>>
35496>>>>>>>
35496>>>>>>>        Function_Return bOK
35497>>>>>>>    End_Function
35498>>>>>>>
35498>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
35498>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
35498>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
35498>>>>>>>//        String sFieldName sDriverID
35498>>>>>>>//
35498>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35498>>>>>>>//        If (bIsOpen = False) Begin
35498>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35498>>>>>>>//            Open hTable
35498>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35498>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35498>>>>>>>//            If (bIsOpen = False) Begin
35498>>>>>>>//                Function_Return False
35498>>>>>>>//            End
35498>>>>>>>//        End
35498>>>>>>>//
35498>>>>>>>//        Move True to bEqual
35498>>>>>>>//        Get psDriverID to sDriverID
35498>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
35498>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
35498>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
35498>>>>>>>//        Decrement iSize
35498>>>>>>>//
35498>>>>>>>//        For iCount from 0 to iSize
35498>>>>>>>//            Move 0 to iOptions
35498>>>>>>>//            Move False to bIdentityKey
35498>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
35498>>>>>>>//
35498>>>>>>>//            // We need to use the column name - not the column integer as
35498>>>>>>>//            // the order does not need to be the same, and the logic should still work.
35498>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
35498>>>>>>>//            If (iColumn > 0) Begin
35498>>>>>>>//                If (bDawSqlDriver = True) Begin
35498>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35498>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
35498>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
35498>>>>>>>//                        Move False to bEqual
35498>>>>>>>//                    End
35498>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
35498>>>>>>>//                    If (bIdentityKey = True) Begin
35498>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
35498>>>>>>>//                    End
35498>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
35498>>>>>>>//                        Move False to bEqual
35498>>>>>>>//                    End
35498>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
35498>>>>>>>//                End
35498>>>>>>>//                Else Begin
35498>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
35498>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
35498>>>>>>>//                        Move False to bEqual
35498>>>>>>>//                    End
35498>>>>>>>//                End
35498>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
35498>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
35498>>>>>>>//                    Move False to bEqual
35498>>>>>>>//                End
35498>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
35498>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
35498>>>>>>>//                    Move False to bEqual
35498>>>>>>>//                End
35498>>>>>>>//                If (bEqual = False) Begin
35498>>>>>>>//                    Function_Return False
35498>>>>>>>//                End
35498>>>>>>>//            End
35498>>>>>>>//
35498>>>>>>>//            Else Begin
35498>>>>>>>//                Function_Return False
35498>>>>>>>//            End
35498>>>>>>>//        Loop
35498>>>>>>>//
35498>>>>>>>//        Function_Return bEqual
35498>>>>>>>//    End_Function
35498>>>>>>>
35498>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
35500>>>>>>>        tAPIIndex[] APIIndexes
35500>>>>>>>        tAPIIndex[] APIIndexes
35501>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
35501>>>>>>>        String sDriverID
35501>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
35501>>>>>>>
35501>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35502>>>>>>>        Get psDriverID to sDriverID
35503>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
35504>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
35505>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35508>>>>>>>        If (bIsOpen = False) Begin
35510>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35511>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35512>>>>>>>            Open hTable
35514>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35515>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35516>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35519>>>>>>>            If (bIsOpen = False) Begin
35521>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35522>>>>>>>                Move True to APIIndexes[0].bError
35523>>>>>>>                Function_Return APIIndexes
35524>>>>>>>            End
35524>>>>>>>>
35524>>>>>>>        End
35524>>>>>>>>
35524>>>>>>>
35524>>>>>>>        Move 0 to iCount
35525>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
35528>>>>>>>        for iIndex from 1 to iIndexes
35534>>>>>>>>
35534>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
35534>>>>>>>            // numbers doesn't not need to be consequitive:
35534>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
35537>>>>>>>            If (iNumSegments > 0) Begin
35539>>>>>>>
35539>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
35540>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
35543>>>>>>>                If (bIsSQLTable = True) Begin
35545>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
35548>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
35551>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
35554>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
35557>>>>>>>                End
35557>>>>>>>>
35557>>>>>>>
35557>>>>>>>                Move 0 to iSegmentCount
35558>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
35561>>>>>>>                For iSegment from 1 to iNumSegments
35567>>>>>>>>
35567>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
35570>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
35571>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
35574>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
35577>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
35580>>>>>>>                    Increment iSegmentCount
35581>>>>>>>                Loop
35582>>>>>>>>
35582>>>>>>>                Increment iCount
35583>>>>>>>            End
35583>>>>>>>>
35583>>>>>>>        Loop
35584>>>>>>>>
35584>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35585>>>>>>>
35585>>>>>>>        Function_Return APIIndexes
35586>>>>>>>    End_Function
35587>>>>>>>
35587>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
35587>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
35587>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
35587>>>>>>>    // have "holes" in the series of index numbers.
35587>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
35589>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35589>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
35590>>>>>>>        tAPIIndexCompare   APIIndexCompare
35590>>>>>>>        tAPIIndexCompare   APIIndexCompare
35590>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
35590>>>>>>>
35590>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
35591>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
35592>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
35594>>>>>>>            Function_Return aAPIIndexCompare
35595>>>>>>>        End
35595>>>>>>>>
35595>>>>>>>
35595>>>>>>>        Decrement iSizeFrom
35596>>>>>>>        for iCount from 0 to iSizeFrom
35602>>>>>>>>
35602>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
35603>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
35604>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
35605>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
35606>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
35607>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
35608>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
35609>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
35610>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
35611>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
35612>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
35613>>>>>>>        Loop
35614>>>>>>>>
35614>>>>>>>
35614>>>>>>>        Decrement iSizeTo
35615>>>>>>>        for iCount from 0 to iSizeTo
35621>>>>>>>>
35621>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
35622>>>>>>>            // Search if the Index number already exists in the array; else add it.
35622>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
35623>>>>>>>            If (iItem = -1) Begin
35625>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
35626>>>>>>>            End
35626>>>>>>>>
35626>>>>>>>
35626>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
35627>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
35628>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
35629>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
35630>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
35631>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
35632>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
35633>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
35634>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
35635>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
35636>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
35637>>>>>>>        Loop
35638>>>>>>>>
35638>>>>>>>
35638>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
35639>>>>>>>
35639>>>>>>>        Function_Return aAPIIndexCompare
35640>>>>>>>    End_Function
35641>>>>>>>
35641>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
35641>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
35643>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
35643>>>>>>>        String sDriverID
35643>>>>>>>
35643>>>>>>>        Get psDriverID to sDriverID
35644>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
35645>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
35646>>>>>>>        If (bIsSqlTable = True) Begin
35648>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
35649>>>>>>>        End
35649>>>>>>>>
35649>>>>>>>
35649>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
35650>>>>>>>        If (bIsSame = False) Begin
35652>>>>>>>            Function_Return False
35653>>>>>>>        End
35653>>>>>>>>
35653>>>>>>>
35653>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
35655>>>>>>>            // Don't think we should do this. Or should we?
35655>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
35655>>>>>>>
35655>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
35656>>>>>>>            If (bIsSame = False) Begin
35658>>>>>>>                Function_Return False
35659>>>>>>>            End
35659>>>>>>>>
35659>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
35660>>>>>>>            If (bIsSame = False) Begin
35662>>>>>>>                Function_Return False
35663>>>>>>>            End
35663>>>>>>>>
35663>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
35664>>>>>>>            If (bIsSame = False) Begin
35666>>>>>>>                Function_Return False
35667>>>>>>>            End
35667>>>>>>>>
35667>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
35668>>>>>>>            If (bIsSame = False) Begin
35670>>>>>>>                Function_Return False
35671>>>>>>>            End
35671>>>>>>>>
35671>>>>>>>        End
35671>>>>>>>>
35671>>>>>>>
35671>>>>>>>        Function_Return bIsSame
35672>>>>>>>    End_Function
35673>>>>>>>
35673>>>>>>>    // DF_INDEX_SQL_TYPE values
35673>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
35673>>>>>>>    // returns a string with the name.
35673>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
35675>>>>>>>        String sRetval
35675>>>>>>>        Case Begin
35675>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
35677>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
35678>>>>>>>                Case Break
35679>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
35682>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
35683>>>>>>>                Case Break
35684>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
35687>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
35688>>>>>>>                Case Break
35689>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
35692>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
35693>>>>>>>                Case Break
35694>>>>>>>            Case Else
35694>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
35695>>>>>>>        Case End
35695>>>>>>>        Function_Return sRetval
35696>>>>>>>    End_Function
35697>>>>>>>
35697>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35697>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
35699>>>>>>>        Function_Return False
35700>>>>>>>    End_Function
35701>>>>>>>
35701>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
35701>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
35703>>>>>>>        Boolean bIsSame
35703>>>>>>>        Integer iSize iCount
35703>>>>>>>
35703>>>>>>>        Move True to bIsSame
35704>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
35705>>>>>>>        Decrement iSize
35706>>>>>>>        For iCount from 0 to iSize
35712>>>>>>>>
35712>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
35713>>>>>>>            If (bIsSame = False) Begin
35715>>>>>>>                Function_Return False
35716>>>>>>>            End
35716>>>>>>>>
35716>>>>>>>        Loop
35717>>>>>>>>
35717>>>>>>>
35717>>>>>>>        Function_Return bIsSame
35718>>>>>>>    End_Function
35719>>>>>>>
35719>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
35719>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
35721>>>>>>>        Boolean bIsSame
35721>>>>>>>
35721>>>>>>>        Move True to bIsSame
35722>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
35724>>>>>>>            Function_Return False
35725>>>>>>>        End
35725>>>>>>>>
35725>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
35727>>>>>>>            Function_Return False
35728>>>>>>>        End
35728>>>>>>>>
35728>>>>>>>
35728>>>>>>>        // We could also compare field names, but I don't think that is necessary...
35728>>>>>>>
35728>>>>>>>        Function_Return bIsSame
35729>>>>>>>    End_Function
35730>>>>>>>
35730>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
35730>>>>>>>    // already exists.
35730>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
35732>>>>>>>        Boolean bOK
35732>>>>>>>        Integer iSizeTo iSize iCount iColumn
35732>>>>>>>        String sDriverID
35732>>>>>>>
35732>>>>>>>        Move True to bOK
35733>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
35734>>>>>>>        If (iSizeTo > 0) Begin
35736>>>>>>>            Get AutoConnectionIDLogin to bOK
35737>>>>>>>            Move False to Err
35738>>>>>>>            Open hTable Mode DF_EXCLUSIVE
35740>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35743>>>>>>>            Decrement iSizeTo
35744>>>>>>>
35744>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
35744>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
35744>>>>>>>            Structure_Start hTable sDriverID
35745>>>>>>>                for iCount from 0 to iSizeTo
35751>>>>>>>>
35751>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
35752>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
35755>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
35758>>>>>>>                Loop
35759>>>>>>>>
35759>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
35760>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35762>>>>>>>            Set Action_Text of ghoStatusPanel to ""
35763>>>>>>>        End
35763>>>>>>>>
35763>>>>>>>
35763>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
35764>>>>>>>        Decrement iSize
35765>>>>>>>        for iCount from 0 to iSize
35771>>>>>>>>
35771>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
35772>>>>>>>        Loop
35773>>>>>>>>
35773>>>>>>>
35773>>>>>>>        Function_Return bOK
35774>>>>>>>    End_Function
35775>>>>>>>
35775>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
35777>>>>>>>        tAPIRelation[] APIRelations
35777>>>>>>>        tAPIRelation[] APIRelations
35778>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
35778>>>>>>>        Handle hParent
35778>>>>>>>        Boolean bIsOpen
35778>>>>>>>
35778>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35779>>>>>>>        Move 0 to iCount
35780>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35783>>>>>>>        If (bIsOpen = False) Begin
35785>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35786>>>>>>>            Open hTable
35788>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
35789>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35792>>>>>>>            If (bIsOpen = False) Begin
35794>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
35795>>>>>>>                Move True to APIRelations[0].bError
35796>>>>>>>                Function_Return APIRelations
35797>>>>>>>            End
35797>>>>>>>>
35797>>>>>>>        End
35797>>>>>>>>
35797>>>>>>>
35797>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
35800>>>>>>>        For iColumn from 1 to iNumColumns
35806>>>>>>>>
35806>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
35809>>>>>>>            If (hParent <> 0) Begin
35811>>>>>>>                Open hParent
35813>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
35814>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
35817>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
35818>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
35821>>>>>>>
35821>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
35822>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
35825>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
35828>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
35829>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
35832>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
35833>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
35834>>>>>>>                Move False                                              to APIRelations[iCount].bError
35835>>>>>>>                Close hParent
35836>>>>>>>                Increment iCount
35837>>>>>>>            End
35837>>>>>>>>
35837>>>>>>>        Loop
35838>>>>>>>>
35838>>>>>>>
35838>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35839>>>>>>>        Function_Return APIRelations
35840>>>>>>>    End_Function
35841>>>>>>>
35841>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
35843>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
35845>>>>>>>            Function_Return (EQ)
35846>>>>>>>        End
35846>>>>>>>>
35846>>>>>>>
35846>>>>>>>        Function_Return (GT)
35847>>>>>>>    End_Function
35848>>>>>>>
35848>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
35850>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
35853>>>>>>>
35853>>>>>>>        Function_Return (GT)
35854>>>>>>>    End_Function
35855>>>>>>>
35855>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
35855>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
35855>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
35857>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
35857>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
35858>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
35858>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
35859>>>>>>>        tAPIRelationCompare   APIRelationCompare
35859>>>>>>>        tAPIRelationCompare   APIRelationCompare
35859>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
35859>>>>>>>
35859>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
35860>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
35861>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
35863>>>>>>>            Function_Return aAPIRelationCompare
35864>>>>>>>        End
35864>>>>>>>>
35864>>>>>>>
35864>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
35865>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
35866>>>>>>>
35866>>>>>>>        Decrement iSizeFrom
35867>>>>>>>        for iCount from 0 to iSizeFrom
35873>>>>>>>>
35873>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
35874>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
35875>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
35876>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
35877>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
35878>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
35879>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
35880>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
35881>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
35882>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
35883>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
35884>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
35885>>>>>>>        Loop
35886>>>>>>>>
35886>>>>>>>
35886>>>>>>>        Decrement iSizeTo
35887>>>>>>>        for iCount from 0 to iSizeTo
35893>>>>>>>>
35893>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
35894>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
35895>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
35896>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
35897>>>>>>>
35897>>>>>>>            // Search if the relation already exists in the array; else add it.
35897>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
35898>>>>>>>            If (iItem = -1) Begin
35900>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
35901>>>>>>>            End
35901>>>>>>>>
35901>>>>>>>
35901>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
35902>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
35903>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
35904>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
35905>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
35906>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
35907>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
35908>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
35909>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
35910>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
35911>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
35912>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
35913>>>>>>>        Loop
35914>>>>>>>>
35914>>>>>>>
35914>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
35915>>>>>>>
35915>>>>>>>        Function_Return aAPIRelationCompare
35916>>>>>>>    End_Function
35917>>>>>>>
35917>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35917>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
35919>>>>>>>        Function_Return False
35920>>>>>>>    End_Function
35921>>>>>>>
35921>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
35921>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
35921>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
35921>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
35923>>>>>>>        Boolean bFound
35923>>>>>>>
35923>>>>>>>        Move False to Err
35924>>>>>>>        Open CodeMast
35926>>>>>>>        Open CodeType
35928>>>>>>>
35928>>>>>>>        If (bCodeType = True) Begin
35930>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
35931>>>>>>>            Clear CodeType
35932>>>>>>>            Move sTypeValue to CODETYPE.Type
35933>>>>>>>            Find eq CODETYPE by 1
35934>>>>>>>>
35934>>>>>>>            Move Found to bFound
35935>>>>>>>            If (bFound = True) Begin
35937>>>>>>>                Reread CodeType
35941>>>>>>>            End
35941>>>>>>>>
35941>>>>>>>            Else Begin
35942>>>>>>>                Clear CodeType
35943>>>>>>>            End
35943>>>>>>>>
35943>>>>>>>
35943>>>>>>>            Move sTypeValue to CODETYPE.Type
35944>>>>>>>            Move sValue2    to CODETYPE.Description
35945>>>>>>>            Move sValue3    to CODETYPE.Comment
35946>>>>>>>            SaveRecord CODETYPE
35947>>>>>>>
35947>>>>>>>            If (bFound = True) Begin
35949>>>>>>>                Unlock
35950>>>>>>>>
35950>>>>>>>            End
35950>>>>>>>>
35950>>>>>>>        End
35950>>>>>>>>
35950>>>>>>>
35950>>>>>>>        If (bCodeType = False) Begin
35952>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
35953>>>>>>>            Clear CODEMAST
35954>>>>>>>            Move sTypeValue to CODEMAST.Type
35955>>>>>>>            Move sValue2    to CODEMAST.Code
35956>>>>>>>            Find eq CODEMAST by 1
35957>>>>>>>>
35957>>>>>>>            Move Found to bFound
35958>>>>>>>            If (bFound = True) Begin
35960>>>>>>>                Reread CODEMAST
35964>>>>>>>            End
35964>>>>>>>>
35964>>>>>>>            Else Begin
35965>>>>>>>                Clear CODEMAST
35966>>>>>>>            End
35966>>>>>>>>
35966>>>>>>>
35966>>>>>>>            Move sTypeValue to CODEMAST.Type
35967>>>>>>>            Move sValue2    to CODEMAST.Code
35968>>>>>>>            Move sValue3    to CODEMAST.Description
35969>>>>>>>            SaveRecord CODEMAST
35970>>>>>>>
35970>>>>>>>            If (bFound = True) Begin
35972>>>>>>>                Unlock
35973>>>>>>>>
35973>>>>>>>            End
35973>>>>>>>>
35973>>>>>>>        End
35973>>>>>>>>
35973>>>>>>>
35973>>>>>>>        Close CodeMast
35974>>>>>>>        Close CodeType
35975>>>>>>>
35975>>>>>>>        Function_Return (Err = False)
35976>>>>>>>    End_Function
35977>>>>>>>
35977>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
35977>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
35977>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
35979>>>>>>>        Boolean bFound
35979>>>>>>>
35979>>>>>>>        Move False to Err
35980>>>>>>>        Open CodeMast
35982>>>>>>>        Open CodeType
35984>>>>>>>
35984>>>>>>>        Clear CodeType
35985>>>>>>>        Move sFromValue to CODETYPE.Type
35986>>>>>>>        Find eq CODETYPE.Type
35987>>>>>>>>
35987>>>>>>>        If (Found = True) Begin
35989>>>>>>>            Reread CODETYPE
35993>>>>>>>                Move sToValue to CODETYPE.Type
35994>>>>>>>                SaveRecord CODETYPE
35995>>>>>>>            Unlock
35996>>>>>>>>
35996>>>>>>>        End
35996>>>>>>>>
35996>>>>>>>
35996>>>>>>>        Clear CODEMAST
35997>>>>>>>        Find gt CODEMAST by Recnum
35998>>>>>>>>
35998>>>>>>>        While (Found = True)
36002>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
36003>>>>>>>            If (bFound = True) Begin
36005>>>>>>>                Reread CODEMAST
36009>>>>>>>                    Move sToValue to CODEMAST.Type
36010>>>>>>>                    SaveRecord CODEMAST
36011>>>>>>>                Unlock
36012>>>>>>>>
36012>>>>>>>            End
36012>>>>>>>>
36012>>>>>>>            Find gt CODEMAST by Recnum
36013>>>>>>>>
36013>>>>>>>        Loop
36014>>>>>>>>
36014>>>>>>>
36014>>>>>>>        Close CodeMast
36015>>>>>>>        Close CodeType
36016>>>>>>>
36016>>>>>>>        Function_Return (Err = False)
36017>>>>>>>    End_Function
36018>>>>>>>
36018>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
36018>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
36020>>>>>>>        Boolean bFound
36020>>>>>>>
36020>>>>>>>        Move False to Err
36021>>>>>>>        Open CodeMast
36023>>>>>>>
36023>>>>>>>        Clear CODEMAST
36024>>>>>>>        Move sTypeValue to CODEMAST.Type
36025>>>>>>>        Move sValue2    to CODEMAST.Code
36026>>>>>>>        Find eq CODEMAST.Code
36027>>>>>>>>
36027>>>>>>>        Move Found to bFound
36028>>>>>>>        If (bFound = True) Begin
36030>>>>>>>            Delete CODEMAST
36031>>>>>>>        End
36031>>>>>>>>
36031>>>>>>>
36031>>>>>>>        Close CodeMast
36032>>>>>>>
36032>>>>>>>        Function_Return (Err = False)
36033>>>>>>>    End_Function
36034>>>>>>>
36034>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
36036>>>>>>>        Boolean bRecnum bToAnsi
36036>>>>>>>        Integer iCh
36036>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
36036>>>>>>>
36036>>>>>>>        If (Trim(sDataPath) = "") Begin
36038>>>>>>>            Function_Return False
36039>>>>>>>        End
36039>>>>>>>>
36039>>>>>>>
36039>>>>>>>        Move False to Err
36040>>>>>>>        Get psDriverID     to sDriverID
36041>>>>>>>        Get psConnectionID to sConnectionID
36042>>>>>>>        Get psSchema       to sSchemaName
36043>>>>>>>        Get True           to bRecnum
36044>>>>>>>        Get pbToANSI       to bToAnsi
36045>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
36046>>>>>>>        If (bToAnsi = False) Begin
36048>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
36049>>>>>>>        End
36049>>>>>>>>
36049>>>>>>>
36049>>>>>>>        Get vFolderFormat sDataPath to sDataPath
36050>>>>>>>        Move "CodeMast.int"         to sFileName
36051>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
36052>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
36055>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
36058>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
36061>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
36064>>>>>>>            Writeln channel iCh ("")
36067>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
36070>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
36073>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
36076>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
36079>>>>>>>            Writeln channel iCh ("")
36082>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
36085>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
36088>>>>>>>            Writeln channel iCh ("")
36091>>>>>>>        Send Seq_Close_Channel iCh
36092>>>>>>>
36092>>>>>>>        Get vFolderFormat sDataPath to sDataPath
36093>>>>>>>        Move "CodeType.int"         to sFileName
36094>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
36095>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
36098>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
36101>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
36104>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
36107>>>>>>>            Writeln channel iCh ("")
36110>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
36113>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
36116>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
36119>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
36122>>>>>>>            Writeln channel iCh ("")
36125>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
36128>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
36131>>>>>>>            Writeln channel iCh ("")
36134>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
36137>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
36140>>>>>>>            Writeln channel iCh ("")
36143>>>>>>>        Send Seq_Close_Channel iCh
36144>>>>>>>
36144>>>>>>>        Function_Return (Err = False)
36145>>>>>>>    End_Function
36146>>>>>>>
36146>>>>>>>    // * Dummy function for the Studio's Code Explorer *
36146>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
36148>>>>>>>        Function_Return False
36149>>>>>>>    End_Function
36150>>>>>>>
36150>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
36150>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
36150>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
36152>>>>>>>        Boolean bOK bExists
36152>>>>>>>        String sDataPath sBackupFolder
36152>>>>>>>
36152>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
36153>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
36154>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
36155>>>>>>>        Get vFolderFormat sDataPath to sDataPath
36156>>>>>>>
36156>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
36157>>>>>>>        If (bExists = False) Begin
36159>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
36160>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
36161>>>>>>>            If (bExists = False) Begin
36163>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
36164>>>>>>>>
36164>>>>>>>                Function_Return False
36165>>>>>>>            End
36165>>>>>>>>
36165>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
36166>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
36167>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
36168>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
36169>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
36170>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
36171>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
36172>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
36173>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
36174>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
36175>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
36176>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
36177>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
36178>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
36179>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
36180>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
36181>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
36182>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
36183>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
36184>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
36185>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
36186>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
36187>>>>>>>        End
36187>>>>>>>>
36187>>>>>>>
36187>>>>>>>        Set Message_Text of ghoStatusPanel to ""
36188>>>>>>>        Function_Return True
36189>>>>>>>    End_Function
36190>>>>>>>    
36190>>>>>>>    // Check if the file exists in the Data folder,
36190>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
36190>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
36192>>>>>>>        String sPath
36192>>>>>>>        Boolean bExists
36192>>>>>>>
36192>>>>>>>        Get psDataPathFirstPart to sPath
36193>>>>>>>        Move (sPath + sFileName) to sFileName
36194>>>>>>>        Get vFilePathExists sFileName to bExists
36195>>>>>>>
36195>>>>>>>        If (bExists = False) Begin
36197>>>>>>>            // Read from memory & create file on disk.
36197>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
36198>>>>>>>            Get vFilePathExists sFileName to bExists
36199>>>>>>>        End
36199>>>>>>>>
36199>>>>>>>        Function_Return bExists
36200>>>>>>>    End_Function
36201>>>>>>>
36201>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
36203>>>>>>>        tColumnType RetvalType
36203>>>>>>>        tColumnType RetvalType
36203>>>>>>>        Integer iRetval
36203>>>>>>>
36203>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
36204>>>>>>>        Move RetvalType.iDataFlexType to iRetval
36205>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
36207>>>>>>>            If (iLength <= 255) Begin
36209>>>>>>>                Move DF_ASCII to iRetval
36210>>>>>>>            End
36210>>>>>>>>
36210>>>>>>>        End
36210>>>>>>>>
36210>>>>>>>        Function_Return iRetval
36211>>>>>>>    End_Function
36212>>>>>>>
36212>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
36214>>>>>>>        String sRetval
36214>>>>>>>
36214>>>>>>>        Case Begin
36214>>>>>>>            Case (iDataType = DF_ASCII)
36216>>>>>>>                Move "DF_ASCII" to sRetval
36217>>>>>>>                Case Break
36218>>>>>>>            Case (iDataType = DF_BCD)
36221>>>>>>>                Move "DF_BCD" to sRetval
36222>>>>>>>                Case Break
36223>>>>>>>            Case (iDataType = DF_BINARY)
36226>>>>>>>                Move "DF_BINARY" to sRetval
36227>>>>>>>                Case Break
36228>>>>>>>            Case (iDataType = DF_DATE)
36231>>>>>>>                Move "DF_DATE" to sRetval
36232>>>>>>>                Case Break
36233>>>>>>>            Case (iDataType = DF_DATETIME)
36236>>>>>>>                Move "DF_DATETIME" to sRetval
36237>>>>>>>                Case Break
36238>>>>>>>            Case (iDataType = DF_TEXT)
36241>>>>>>>                Move "DF_TEXT" to sRetval
36242>>>>>>>                Case Break
36243>>>>>>>            Case Else
36243>>>>>>>                Move "" to sRetval
36244>>>>>>>        Case End
36244>>>>>>>
36244>>>>>>>        Function_Return sRetval
36245>>>>>>>    End_Function
36246>>>>>>>
36246>>>>>>>    // The default value used for a datatype as specified in the driver int file.
36246>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
36248>>>>>>>        String sRetval sServer
36248>>>>>>>        tColumnType RetvalType
36248>>>>>>>        tColumnType RetvalType
36248>>>>>>>        Integer iDriver iDataFlexType
36248>>>>>>>        Handle hDatabase
36248>>>>>>>
36248>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
36249>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
36250>>>>>>>        Get DriverIndex sDriverID to iDriver
36251>>>>>>>        Get psServer to sServer
36252>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
36253>>>>>>>        If (hDatabase = 0) Begin
36255>>>>>>>            Function_Return ""
36256>>>>>>>        End
36256>>>>>>>>
36256>>>>>>>
36256>>>>>>>        Case Begin
36256>>>>>>>            Case (iDataFlexType = DF_ASCII)
36258>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
36261>>>>>>>                Case Break
36262>>>>>>>            Case (iDataFlexType = DF_BCD)
36265>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
36268>>>>>>>                Case Break
36269>>>>>>>            Case (iDataFlexType = DF_BINARY)
36272>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
36275>>>>>>>                Case Break
36276>>>>>>>            Case (iDataFlexType = DF_DATE)
36279>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
36282>>>>>>>                Case Break
36283>>>>>>>            Case (iDataFlexType = DF_DATETIME)
36286>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
36289>>>>>>>                Case Break
36290>>>>>>>            Case (iDataFlexType = DF_TEXT)
36293>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
36296>>>>>>>                Case Break
36297>>>>>>>            Case Else
36297>>>>>>>                Move "" to sRetval
36298>>>>>>>        Case End
36298>>>>>>>
36298>>>>>>>        Function_Return sRetval
36299>>>>>>>    End_Function
36300>>>>>>>
36300>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
36302>>>>>>>        String sDriverID sServer
36302>>>>>>>        tColumnType RetvalType
36302>>>>>>>        tColumnType RetvalType
36302>>>>>>>        Integer iDbType iDriver
36302>>>>>>>        Handle hDatabase
36302>>>>>>>
36302>>>>>>>        Get psDriverID to sDriverID
36303>>>>>>>        Get piDbType   to iDbType
36304>>>>>>>        Get DriverIndex sDriverID to iDriver
36305>>>>>>>        Get psServer to sServer
36306>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
36307>>>>>>>        If (hDatabase = 0) Begin
36309>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
36310>>>>>>>>
36310>>>>>>>            Procedure_Return
36311>>>>>>>        End
36311>>>>>>>>
36311>>>>>>>
36311>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
36314>>>>>>>
36314>>>>>>>    End_Procedure
36315>>>>>>>
36315>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
36317>>>>>>>        String sDriverID sServer
36317>>>>>>>        tColumnType RetvalType
36317>>>>>>>        tColumnType RetvalType
36317>>>>>>>        Integer iDbType iDriver
36317>>>>>>>        Handle hDatabase
36317>>>>>>>
36317>>>>>>>        Get psDriverID to sDriverID
36318>>>>>>>        Get piDbType   to iDbType
36319>>>>>>>        Get DriverIndex sDriverID to iDriver
36320>>>>>>>        Get psServer to sServer
36321>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
36322>>>>>>>        If (hDatabase = 0) Begin
36324>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
36325>>>>>>>>
36325>>>>>>>            Procedure_Return
36326>>>>>>>        End
36326>>>>>>>>
36326>>>>>>>
36326>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
36329>>>>>>>
36329>>>>>>>    End_Procedure
36330>>>>>>>
36330>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
36330>>>>>>>    // are mapped to the standard DataFlex data types.
36330>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
36330>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
36332>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
36332>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
36334>>>>>>>        String sDataType
36334>>>>>>>        Integer iDataType iDriverID iCount
36334>>>>>>>        Boolean bSQLDriver
36334>>>>>>>
36334>>>>>>>        Move 0 to iCount
36335>>>>>>>        Get DriverIndex sDriverID to iDriverID
36336>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
36337>>>>>>>        If (bSQLDriver = False) Begin
36339>>>>>>>            Function_Return EmptyArray
36340>>>>>>>        End
36340>>>>>>>>
36340>>>>>>>
36340>>>>>>>        // DF_ASCII
36340>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36342>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
36345>>>>>>>        End
36345>>>>>>>>
36345>>>>>>>        Else Begin
36346>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
36349>>>>>>>        End
36349>>>>>>>>
36349>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36350>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
36351>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
36352>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36353>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36354>>>>>>>        Increment iCount
36355>>>>>>>
36355>>>>>>>        // DF_BINARY
36355>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36357>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
36360>>>>>>>        End
36360>>>>>>>>
36360>>>>>>>        Else Begin
36361>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
36364>>>>>>>        End
36364>>>>>>>>
36364>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36365>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
36366>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
36367>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36368>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36369>>>>>>>        Increment iCount
36370>>>>>>>
36370>>>>>>>        // DF_DATE
36370>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36372>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
36375>>>>>>>        End
36375>>>>>>>>
36375>>>>>>>        Else Begin
36376>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
36379>>>>>>>        End
36379>>>>>>>>
36379>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36380>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
36381>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
36382>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36383>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36384>>>>>>>        Increment iCount
36385>>>>>>>
36385>>>>>>>        // DF_DATETIME
36385>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36387>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
36390>>>>>>>        End
36390>>>>>>>>
36390>>>>>>>        Else Begin
36391>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
36394>>>>>>>        End
36394>>>>>>>>
36394>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36395>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
36396>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
36397>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36398>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36399>>>>>>>        Increment iCount
36400>>>>>>>
36400>>>>>>>        // DF_NUMERIC
36400>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
36400>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
36400>>>>>>>        // we make them here all "Numeric"...
36400>>>>>>>        Case Begin
36400>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
36402>>>>>>>                Move SQL_NUMERIC to iDataType
36403>>>>>>>                Move "numeric"   to sDataType
36404>>>>>>>                Case Break
36405>>>>>>>            Case (sDriverID = DB2_DRV_ID)
36408>>>>>>>                Move SQL_NUMERIC to iDataType
36409>>>>>>>                Move "NUMERIC"   to sDataType
36410>>>>>>>                Case Break
36411>>>>>>>            Case (sDriverID = SQLFLEX)
36414>>>>>>>                Move eSQLServer_NUMERIC to iDataType
36415>>>>>>>                Move "numeric"   to sDataType
36416>>>>>>>                Case Break
36417>>>>>>>            Case (sDriverID = MDSMySQL)
36420>>>>>>>                Move eMySQL_DECIMAL to iDataType
36421>>>>>>>                Move "decimal"   to sDataType
36422>>>>>>>                Case Break
36423>>>>>>>            Case (sDriverID = ORAFLEX)
36426>>>>>>>                Move eOracle_NUMBER to iDataType
36427>>>>>>>                Move "NUMBER"   to sDataType
36428>>>>>>>                Case Break
36429>>>>>>>            Case (sDriverID = MDSPgSQL)
36432>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
36433>>>>>>>                Move "decimal"   to sDataType
36434>>>>>>>                Case Break
36435>>>>>>>            Case Else
36435>>>>>>>                Move DF_BCD      to iDataType
36436>>>>>>>                Move "Numeric"   to sDataType
36437>>>>>>>        Case End
36437>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
36438>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
36439>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36440>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36441>>>>>>>        Increment iCount
36442>>>>>>>
36442>>>>>>>        // DF_TEXT
36442>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
36444>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
36447>>>>>>>        End
36447>>>>>>>>
36447>>>>>>>        Else Begin
36448>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
36451>>>>>>>        End
36451>>>>>>>>
36451>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
36452>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
36453>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
36454>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
36455>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
36456>>>>>>>
36456>>>>>>>        Function_Return ColumnTypeArray
36457>>>>>>>    End_Function
36458>>>>>>>
36458>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
36460>>>>>>>        tColumnType[] ColumnTypeArray
36460>>>>>>>        tColumnType[] ColumnTypeArray
36461>>>>>>>        tColumnType   ColumnType
36461>>>>>>>        tColumnType   ColumnType
36461>>>>>>>        Integer iCount iSize
36461>>>>>>>
36461>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
36462>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
36463>>>>>>>        Decrement iSize
36464>>>>>>>
36464>>>>>>>        for iCount from 0 to iSize
36470>>>>>>>>
36470>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
36472>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
36473>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
36474>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
36475>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
36476>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
36477>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
36478>>>>>>>                Move iSize to iCount
36479>>>>>>>            End
36479>>>>>>>>
36479>>>>>>>        Loop
36480>>>>>>>>
36480>>>>>>>
36480>>>>>>>        Function_Return ColumnType
36481>>>>>>>    End_Function
36482>>>>>>>
36482>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
36482>>>>>>>    // are mapped to a DUF data type.
36482>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
36484>>>>>>>        tColumnType ColumnType
36484>>>>>>>        tColumnType ColumnType
36484>>>>>>>        String sDataType
36484>>>>>>>        Integer iDriverID iCount
36484>>>>>>>
36484>>>>>>>        Move 0 to iCount
36485>>>>>>>        Get DriverIndex sDriverID to iDriverID
36486>>>>>>>
36486>>>>>>>        Case Begin
36486>>>>>>>            // DF_ASCII
36486>>>>>>>            Case (iType = DF_ASCII_DUF)
36488>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36490>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
36493>>>>>>>                End
36493>>>>>>>>
36493>>>>>>>                Else Begin
36494>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
36497>>>>>>>                End
36497>>>>>>>>
36497>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
36498>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
36499>>>>>>>                Move sDataType   to ColumnType.sSQLType
36500>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
36501>>>>>>>                Move False       to ColumnType.bCanEditSize
36502>>>>>>>                Case Break
36503>>>>>>>
36503>>>>>>>            // DF_BINARY
36503>>>>>>>            Case (iType = DF_BINARY_DUF)
36506>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36508>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
36511>>>>>>>                End
36511>>>>>>>>
36511>>>>>>>                Else Begin
36512>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
36515>>>>>>>                End
36515>>>>>>>>
36515>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
36516>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
36517>>>>>>>                Move sDataType   to ColumnType.sSQLType
36518>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
36519>>>>>>>                Move False       to ColumnType.bCanEditSize
36520>>>>>>>                Case Break
36521>>>>>>>
36521>>>>>>>            // DF_DATE
36521>>>>>>>            Case (iType = DF_DATE_DUF)
36524>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36526>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
36529>>>>>>>                End
36529>>>>>>>>
36529>>>>>>>                Else Begin
36530>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
36533>>>>>>>                End
36533>>>>>>>>
36533>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
36534>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
36535>>>>>>>                Move sDataType   to ColumnType.sSQLType
36536>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
36537>>>>>>>                Move True        to ColumnType.bCanEditSize
36538>>>>>>>                Case Break
36539>>>>>>>
36539>>>>>>>            // DF_DATETIME
36539>>>>>>>            Case (iType = DF_DATETIME_DUF)
36542>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36544>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
36547>>>>>>>                End
36547>>>>>>>>
36547>>>>>>>                Else Begin
36548>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
36551>>>>>>>                End
36551>>>>>>>>
36551>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
36552>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
36553>>>>>>>                Move sDataType   to ColumnType.sSQLType
36554>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
36555>>>>>>>                Move True        to ColumnType.bCanEditSize
36556>>>>>>>                Case Break
36557>>>>>>>
36557>>>>>>>            // DF_NUMERIC
36557>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
36557>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
36557>>>>>>>            // we make them here all "Numeric"...
36557>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
36557>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
36557>>>>>>>            // End
36557>>>>>>>            // Else Begin
36557>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
36557>>>>>>>            // End
36557>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
36557>>>>>>>            Case (iType = DF_BCD_DUF)
36560>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
36561>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
36562>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
36563>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
36564>>>>>>>                Move False       to ColumnType.bCanEditSize
36565>>>>>>>                Case Break
36566>>>>>>>
36566>>>>>>>            // DF_TEXT
36566>>>>>>>            Case (iType = DF_TEXT_DUF)
36569>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
36571>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
36574>>>>>>>                End
36574>>>>>>>>
36574>>>>>>>                Else Begin
36575>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
36578>>>>>>>                End
36578>>>>>>>>
36578>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
36579>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
36580>>>>>>>                Move sDataType   to ColumnType.sSQLType
36581>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
36582>>>>>>>                Move False       to ColumnType.bCanEditSize
36583>>>>>>>                Case Break
36584>>>>>>>
36584>>>>>>>            Case Else
36584>>>>>>>                Move -1999       to ColumnType.iDataFlexType
36585>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
36586>>>>>>>                Move "Undefined" to ColumnType.sSQLType
36587>>>>>>>                Move -1999       to ColumnType.iSQLType
36588>>>>>>>                Move True        to ColumnType.bCanEditSize
36589>>>>>>>
36589>>>>>>>        Case End
36589>>>>>>>
36589>>>>>>>        Function_Return ColumnType
36590>>>>>>>    End_Function
36591>>>>>>>
36591>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
36593>>>>>>>        String sDataPath sDriverID
36593>>>>>>>        Boolean bMertechDriver bOK
36593>>>>>>>        Integer iPos
36593>>>>>>>
36593>>>>>>>        If (sTableName contains ".") Begin
36595>>>>>>>            Move (Pos(".", sTableName)) to iPos
36596>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
36597>>>>>>>        End
36597>>>>>>>>
36597>>>>>>>
36597>>>>>>>        Get psDriverID to sDriverID
36598>>>>>>>        Get psDataPathFirstPart to sDataPath
36599>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
36600>>>>>>>        // First delete the cache file:
36600>>>>>>>        If (bMertechDriver = False) Begin
36602>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
36603>>>>>>>        End
36603>>>>>>>>
36603>>>>>>>        Else Begin
36604>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
36605>>>>>>>        End
36605>>>>>>>>
36605>>>>>>>
36605>>>>>>>        Function_Return bOK
36606>>>>>>>    End_Function
36607>>>>>>>
36607>>>>>>>    // Changes source code files.
36607>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
36607>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
36607>>>>>>>    // to use a Connection ID.
36607>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
36607>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
36607>>>>>>>    // Returns True if no errors occured.
36607>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
36609>>>>>>>        Integer iCh iRow iItems iCount
36609>>>>>>>        String sValue sRow
36609>>>>>>>        String[] sFileArray
36610>>>>>>>        Boolean bExists bIsActive
36610>>>>>>>
36610>>>>>>>        Move False to Err
36611>>>>>>>        Move 0 to iRow
36612>>>>>>>
36612>>>>>>>        If (ghoStatusPanel <> 0) Begin
36614>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
36615>>>>>>>        End
36615>>>>>>>>
36615>>>>>>>
36615>>>>>>>        Get vFilePathExists sFileName to bExists
36616>>>>>>>        If (bExists = False) Begin
36618>>>>>>>            If (bShowResult = True) Begin
36620>>>>>>>                If (bIsActive = True) Begin
36622>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
36623>>>>>>>                End
36623>>>>>>>>
36623>>>>>>>                Else Begin
36624>>>>>>>                    Showln "File does not exist: " sFileName
36627>>>>>>>                End
36627>>>>>>>>
36627>>>>>>>            End
36627>>>>>>>>
36627>>>>>>>            Function_Return False
36628>>>>>>>        End
36628>>>>>>>>
36628>>>>>>>
36628>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
36629>>>>>>>        If (iCh < 1) Begin
36631>>>>>>>            Function_Return False
36632>>>>>>>        End
36632>>>>>>>>
36632>>>>>>>
36632>>>>>>>        If (bShowResult = True) Begin
36634>>>>>>>            If (ghoStatusPanel <> 0) Begin
36636>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
36637>>>>>>>                If (bIsActive = True) Begin
36639>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
36640>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
36641>>>>>>>                    Send DoAdvance of ghoProgressBar
36642>>>>>>>                End
36642>>>>>>>>
36642>>>>>>>            End
36642>>>>>>>>
36642>>>>>>>            Else Begin
36643>>>>>>>                Showln ""
36645>>>>>>>                Showln "sFileName = " sFileName
36648>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
36653>>>>>>>            End
36653>>>>>>>>
36653>>>>>>>        End
36653>>>>>>>>
36653>>>>>>>
36653>>>>>>>        While (not(SeqEof))
36657>>>>>>>            Readln channel iCh sRow
36659>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
36661>>>>>>>//                If (bShowResult = True) Begin
36661>>>>>>>//                    If (bIsActive = True) Begin
36661>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
36661>>>>>>>//                    End
36661>>>>>>>//                    Else Begin
36661>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
36661>>>>>>>//                    End
36661>>>>>>>//                End
36661>>>>>>>                // Change the whole line to the new connection id:
36661>>>>>>>                Move sChangeTo to sRow
36662>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
36662>>>>>>>            End
36662>>>>>>>>
36662>>>>>>>            Move sRow to sFileArray[iRow]
36663>>>>>>>            Increment iRow
36664>>>>>>>        Loop
36665>>>>>>>>
36665>>>>>>>        Send Seq_Close_Channel iCh
36666>>>>>>>
36666>>>>>>>        Sleep 1 // Wait for Windows to close the file
36667>>>>>>>
36667>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
36668>>>>>>>        If (iCh < 1) Begin
36670>>>>>>>            Function_Return False
36671>>>>>>>        End
36671>>>>>>>>
36671>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
36672>>>>>>>        Decrement iItems
36673>>>>>>>
36673>>>>>>>        For iCount from 0 to iItems
36679>>>>>>>>
36679>>>>>>>            Move sFileArray[iCount] to sValue
36680>>>>>>>            Writeln channel iCh sValue
36683>>>>>>>        Loop
36684>>>>>>>>
36684>>>>>>>        Send Seq_Close_Channel iCh
36685>>>>>>>
36685>>>>>>>        Function_Return (Err = False)
36686>>>>>>>    End_Function
36687>>>>>>>
36687>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
36689>>>>>>>        Integer iRetval
36689>>>>>>>        Move 1 to iRetval
36690>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
36692>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
36693>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
36694>>>>>>>        End
36694>>>>>>>>
36694>>>>>>>        Function_Return (iRetval = 0)
36695>>>>>>>    End_Function
36696>>>>>>>
36696>>>>>>>    // *** DEPRECIATED ***
36696>>>>>>>    // Use the AutoSetConnectionID function instead.
36696>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
36696>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
36696>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
36696>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
36696>>>>>>>//        String sConnectionString sDriverID
36696>>>>>>>//        Boolean bOK bSilent bDawDriver
36696>>>>>>>//        Handle hoCLI
36696>>>>>>>//
36696>>>>>>>//        Move False to bOK
36696>>>>>>>//        Get psDriverID to sDriverID
36696>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
36696>>>>>>>//        If (bDawDriver = False) Begin
36696>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
36696>>>>>>>//            Function_Return False
36696>>>>>>>//        End
36696>>>>>>>//
36696>>>>>>>//        Get psConnectionString to sConnectionString
36696>>>>>>>//        Get pbSilentLogin      to bSilent
36696>>>>>>>//
36696>>>>>>>//        Get phoCLIHandler to hoCLI
36696>>>>>>>//        If (hoCLI <> 0) Begin
36696>>>>>>>//            Set psDriverID of hoCLI to sDriverID
36696>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
36696>>>>>>>//        End
36696>>>>>>>//
36696>>>>>>>//        Function_Return (bOK = False)
36696>>>>>>>//    End_Function
36696>>>>>>>
36696>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
36696>>>>>>>    // and opens it in "notepad.exe".
36696>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
36696>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
36696>>>>>>>    Procedure UtilShowErrorList
36698>>>>>>>        tSqlErrorArray aSqlErrorArray
36698>>>>>>>        tSqlErrorArray aSqlErrorArray
36698>>>>>>>        Integer iRows iCount iCh iErrorNum
36698>>>>>>>        String sPath sFileName sErrorTxt sStatement
36698>>>>>>>
36698>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
36699>>>>>>>        Get vFolderFormat sPath to sPath
36700>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
36701>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
36702>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
36703>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
36704>>>>>>>            If (iRows > 0) Begin
36706>>>>>>>                Decrement iRows
36707>>>>>>>                for iCount from 0 to iRows
36713>>>>>>>>
36713>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
36714>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
36715>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
36716>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
36722>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
36726>>>>>>>                Loop
36727>>>>>>>>
36727>>>>>>>            End
36727>>>>>>>>
36727>>>>>>>        Send Seq_Close_Channel iCh
36728>>>>>>>
36728>>>>>>>        If (iRows > 0) Begin
36730>>>>>>>            Runprogram Shell Background (sPath + sFileName)
36731>>>>>>>        End
36731>>>>>>>>
36731>>>>>>>    End_Procedure
36732>>>>>>>
36732>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
36732>>>>>>>    // and the table needs to exist as an SQL table.
36732>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
36734>>>>>>>        String sRootName sDriverID
36734>>>>>>>        Boolean bIsSQL
36734>>>>>>>
36734>>>>>>>        Move False to bIsSQL
36735>>>>>>>        If (hTable > 0) Begin
36737>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
36740>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
36741>>>>>>>            If (bIsSQL = True) Begin
36743>>>>>>>                Get psDriverID to sDriverID
36744>>>>>>>                Get _TableNameOnly sRootName to sRootName
36745>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
36746>>>>>>>            End
36746>>>>>>>>
36746>>>>>>>        End
36746>>>>>>>>
36746>>>>>>>
36746>>>>>>>        Function_Return bIsSQL
36747>>>>>>>    End_Function
36748>>>>>>>
36748>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
36750>>>>>>>        Boolean bIsSQL
36750>>>>>>>        Move (sRootName contains ":") to bIsSQL
36751>>>>>>>        Function_Return bIsSQL
36752>>>>>>>    End_Function
36753>>>>>>>
36753>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
36753>>>>>>>    // that the embedded .dat file exists on disk.
36753>>>>>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
36755>>>>>>>        Boolean bExists bIsEmbedded
36755>>>>>>>        String sDataPath sRootName
36755>>>>>>>
36755>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
36756>>>>>>>        If (bExists = False) Begin
36758>>>>>>>            Function_Return False
36759>>>>>>>        End
36759>>>>>>>>
36759>>>>>>>
36759>>>>>>>        Move False to bIsEmbedded
36760>>>>>>>        If (hTable > 0) Begin
36762>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
36765>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
36766>>>>>>>        End
36766>>>>>>>>
36766>>>>>>>        If (bIsEmbedded = True) Begin
36768>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
36769>>>>>>>            Get vFolderFormat sDataPath to sDataPath
36770>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
36771>>>>>>>        End
36771>>>>>>>>
36771>>>>>>>
36771>>>>>>>        Function_Return bIsEmbedded
36772>>>>>>>    End_Function
36773>>>>>>>
36773>>>>>>>
36773>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
36773>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
36773>>>>>>>    // but the Logical name is different.
36773>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
36773>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
36775>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
36775>>>>>>>        Handle hInTable hMasterTable 
36775>>>>>>>        Boolean bIsAlias
36775>>>>>>>        
36775>>>>>>>        Move hTable to hInTable
36776>>>>>>>        Move False to bIsAlias
36777>>>>>>>        Move 0 to hMasterTable
36778>>>>>>>        
36778>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
36781>>>>>>>        // Remove any prefix with a driver name.
36781>>>>>>>        Get _TableNameOnly sRootName to sRootName     
36782>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
36785>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
36786>>>>>>>        
36786>>>>>>>        // If the table has the same root and logical name it can't be an alias,
36786>>>>>>>        // so we can safely return a "False".
36786>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
36788>>>>>>>            Function_Return False
36789>>>>>>>        End
36789>>>>>>>>
36789>>>>>>>        
36789>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
36789>>>>>>>        // as the passed hTable root name.
36789>>>>>>>        // A master table always has the same root and logical name.
36789>>>>>>>        Move 0 to hTable
36790>>>>>>>        Repeat
36790>>>>>>>>
36790>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
36793>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
36795>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
36798>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
36799>>>>>>>                // If we found another table with the same root and logical name
36799>>>>>>>                // we have found a master table.
36799>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
36801>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
36804>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
36805>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
36807>>>>>>>                        Move hTable to hMasterTable   
36808>>>>>>>                        Move 0 to hTable // To end the loop.
36809>>>>>>>                    End
36809>>>>>>>>
36809>>>>>>>                End
36809>>>>>>>>
36809>>>>>>>            End
36809>>>>>>>>
36809>>>>>>>        Until (hTable = 0)
36811>>>>>>>        
36811>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
36813>>>>>>>            Move True to bIsAlias
36814>>>>>>>        End
36814>>>>>>>>
36814>>>>>>>        
36814>>>>>>>        Function_Return bIsAlias
36815>>>>>>>    End_Function
36816>>>>>>>
36816>>>>>>>    // To Open a table with any driver.
36816>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
36816>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
36816>>>>>>>    //
36816>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
36816>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
36816>>>>>>>    // returns a True if successful (table could be opened).
36816>>>>>>>    //
36816>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
36816>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
36816>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
36816>>>>>>>    // set properly we can open the table.
36816>>>>>>>    //
36816>>>>>>>    // DAW Driver Syntax:
36816>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
36816>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
36816>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
36816>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
36816>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
36816>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
36816>>>>>>>    //
36816>>>>>>>    // DAW Driver Sample:
36816>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
36816>>>>>>>    //
36816>>>>>>>    // Mertech Driver Samples:
36816>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
36816>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
36816>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
36816>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
36816>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
36818>>>>>>>        String sTableNameOrg
36818>>>>>>>        Boolean bOpen bOK
36818>>>>>>>        tSQLConnection SQLConnection
36818>>>>>>>        tSQLConnection SQLConnection
36818>>>>>>>        
36818>>>>>>>        Move False to bOpen
36819>>>>>>>        Move sTableName to sTableNameOrg
36820>>>>>>>        If (hTable > 0) Begin
36822>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
36823>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
36824>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
36825>>>>>>>            Send Ignore_Error of Error_Object_Id 10
36826>>>>>>>            Open hTable Mode iMode
36828>>>>>>>            Send Trap_Error of Error_Object_Id 20529
36829>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
36830>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
36831>>>>>>>            Send Trap_Error of Error_Object_Id 10
36832>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
36835>>>>>>>            If (bOpen = True) Begin
36837>>>>>>>                Function_Return True
36838>>>>>>>            End
36838>>>>>>>>
36838>>>>>>>        End
36838>>>>>>>>
36838>>>>>>>
36838>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
36839>>>>>>>        If (hTable > 0) Begin
36841>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
36844>>>>>>>        End
36844>>>>>>>>
36844>>>>>>>
36844>>>>>>>        Function_Return bOpen
36845>>>>>>>    End_Function
36846>>>>>>>
36846>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
36848>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
36848>>>>>>>        Boolean bOpen bMertechDriver bOK
36848>>>>>>>        tSQLConnection SQLConnection
36848>>>>>>>        tSQLConnection SQLConnection
36848>>>>>>>
36848>>>>>>>        If (hTable < 1) Begin
36850>>>>>>>            Function_Return False
36851>>>>>>>        End
36851>>>>>>>>
36851>>>>>>>
36851>>>>>>>        Move sTableName to sTableNameOrg
36852>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
36853>>>>>>>        Move SQLConnection.sDriverID to sDriverID
36854>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
36855>>>>>>>        Move SQLConnection.sConnectionString to sConnection
36856>>>>>>>        Move SQLConnection.sSchema to sSchema
36857>>>>>>>        If (sSchema = "") Begin
36859>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
36860>>>>>>>        End
36860>>>>>>>>
36860>>>>>>>
36860>>>>>>>        // We need to remove the ".int" part of the table name because
36860>>>>>>>        // the table name after the "#" in the connection syntax below wants the
36860>>>>>>>        // "bare" table name without any extension.
36860>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
36862>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
36864>>>>>>>                Get ParseFileExtension sTableName to sExt
36865>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
36866>>>>>>>            End
36866>>>>>>>>
36866>>>>>>>            Else Begin
36867>>>>>>>                Move sTableName to sTableNameShort
36868>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
36869>>>>>>>            End
36869>>>>>>>>
36869>>>>>>>            If (bMertechDriver = False) Begin
36871>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
36872>>>>>>>                Move sConnection to sTableName
36873>>>>>>>            End
36873>>>>>>>>
36873>>>>>>>        End
36873>>>>>>>>
36873>>>>>>>
36873>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
36874>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
36875>>>>>>>        If (hTable = 0) Begin
36877>>>>>>>            Get NextFreeFilelistSlot to hTable
36878>>>>>>>        End
36878>>>>>>>>
36878>>>>>>>
36878>>>>>>>        Case Begin
36878>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
36880>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36880>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
36882>>>>>>>                    Close hTable
36883>>>>>>>                    Open sTableName as hTable
36885>>>>>>>                End
36885>>>>>>>>
36885>>>>>>>                Else Begin
36886>>>>>>>                    Get OpenTableExclusive hTable to bOK
36887>>>>>>>                    If (bOK = False) Begin
36889>>>>>>>                        Function_Return False
36890>>>>>>>                    End
36890>>>>>>>>
36890>>>>>>>                End
36890>>>>>>>>
36890>>>>>>>                Case Break
36891>>>>>>>
36891>>>>>>>            Case (sDriverID = DB2_DRV_ID)
36894>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36894>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
36896>>>>>>>                    Close hTable
36897>>>>>>>                    Open sTableName as hTable
36899>>>>>>>                End
36899>>>>>>>>
36899>>>>>>>                Else Begin
36900>>>>>>>                    Get OpenTableExclusive hTable to bOK
36901>>>>>>>                    If (bOK = False) Begin
36903>>>>>>>                        Function_Return False
36904>>>>>>>                    End
36904>>>>>>>>
36904>>>>>>>                End
36904>>>>>>>>
36904>>>>>>>                Case Break
36905>>>>>>>
36905>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
36908>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36908>>>>>>>                If (iMode = DF_SHARE) Begin
36910>>>>>>>                    Close hTable
36911>>>>>>>                    Open sTableName as hTable
36913>>>>>>>                End
36913>>>>>>>>
36913>>>>>>>                Else Begin
36914>>>>>>>                    Get OpenTableExclusive hTable to bOK
36915>>>>>>>                    If (bOK = False) Begin
36917>>>>>>>                        Function_Return False
36918>>>>>>>                    End
36918>>>>>>>>
36918>>>>>>>                End
36918>>>>>>>>
36918>>>>>>>                Case Break
36919>>>>>>>
36919>>>>>>>            Case (sDriverID = SQLFLEX)
36922>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
36922>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
36922>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
36923>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36923>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
36925>>>>>>>                    Close hTable
36926>>>>>>>                    Open sTableName as hTable
36928>>>>>>>                End
36928>>>>>>>>
36928>>>>>>>                Else Begin
36929>>>>>>>                    Get OpenTableExclusive hTable to bOK
36930>>>>>>>                    If (bOK = False) Begin
36932>>>>>>>                        Function_Return False
36933>>>>>>>                    End
36933>>>>>>>>
36933>>>>>>>                End
36933>>>>>>>>
36933>>>>>>>                Case Break
36934>>>>>>>
36934>>>>>>>            Case (sDriverID = MDSMySQL)
36937>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
36937>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
36938>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36938>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
36940>>>>>>>                    Close hTable
36941>>>>>>>                    Open sTableName as hTable
36943>>>>>>>                End
36943>>>>>>>>
36943>>>>>>>                Else Begin
36944>>>>>>>                    Get OpenTableExclusive hTable to bOK
36945>>>>>>>                    If (bOK = False) Begin
36947>>>>>>>                        Function_Return False
36948>>>>>>>                    End
36948>>>>>>>>
36948>>>>>>>                End
36948>>>>>>>>
36948>>>>>>>                Case Break
36949>>>>>>>
36949>>>>>>>            Case (sDriverID = MDSPgSQL)
36952>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
36952>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
36953>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36953>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
36955>>>>>>>                    Close hTable
36956>>>>>>>                    Open sTableName as hTable
36958>>>>>>>                End
36958>>>>>>>>
36958>>>>>>>                Else Begin
36959>>>>>>>                    Get OpenTableExclusive hTable to bOK
36960>>>>>>>                    If (bOK = False) Begin
36962>>>>>>>                        Function_Return False
36963>>>>>>>                    End
36963>>>>>>>>
36963>>>>>>>                End
36963>>>>>>>>
36963>>>>>>>                Case Break
36964>>>>>>>
36964>>>>>>>            Case (sDriverID = ORAFLEX)
36967>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
36967>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
36967>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
36968>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
36968>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
36970>>>>>>>                    Close hTable
36971>>>>>>>                    Open sTableName as hTable
36973>>>>>>>                End
36973>>>>>>>>
36973>>>>>>>                Else Begin
36974>>>>>>>                    Get OpenTableExclusive hTable to bOK
36975>>>>>>>                    If (bOK = False) Begin
36977>>>>>>>                        Function_Return False
36978>>>>>>>                    End
36978>>>>>>>>
36978>>>>>>>                End
36978>>>>>>>>
36978>>>>>>>                Case Break
36979>>>>>>>
36979>>>>>>>            Case (sDriverID = DATAFLEX_ID)
36982>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
36984>>>>>>>                    Close hTable
36985>>>>>>>                    Open sTableName as hTable
36987>>>>>>>                End
36987>>>>>>>>
36987>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
36990>>>>>>>                    Get OpenTableExclusive hTable to bOK
36991>>>>>>>                    If (bOK = False) Begin
36993>>>>>>>                        Function_Return False
36994>>>>>>>                    End
36994>>>>>>>>
36994>>>>>>>                End
36994>>>>>>>>
36994>>>>>>>                Else Begin
36995>>>>>>>                    Open hTable
36997>>>>>>>                End
36997>>>>>>>>
36997>>>>>>>                Case Break
36998>>>>>>>
36998>>>>>>>            Case Else
36998>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
36999>>>>>>>>
36999>>>>>>>        Case End
36999>>>>>>>
36999>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
37000>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
37001>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
37003>>>>>>>            Move False to Found
37004>>>>>>>        End
37004>>>>>>>>
37004>>>>>>>        // If open failed, the Err is set to true,
37004>>>>>>>        // but we don't want that because it could end our loop.
37004>>>>>>>        Move False to Err
37005>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
37008>>>>>>>
37008>>>>>>>        Function_Return bOpen
37009>>>>>>>    End_Function
37010>>>>>>>
37010>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
37010>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
37010>>>>>>>    // if it is an SQL table
37010>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
37012>>>>>>>        Boolean bExists bIsSQLTable
37012>>>>>>>        String sDataPath sRootName
37012>>>>>>>
37012>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
37013>>>>>>>        If (bExists = False) Begin
37015>>>>>>>            Function_Return False
37016>>>>>>>        End
37016>>>>>>>>
37016>>>>>>>
37016>>>>>>>        Move False to bIsSQLTable
37017>>>>>>>        If (hTable > 0) Begin
37019>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
37022>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
37023>>>>>>>        End
37023>>>>>>>>
37023>>>>>>>        If (bIsSQLTable = True) Begin
37025>>>>>>>            Get UtilTableIsSQL hTable to bExists
37026>>>>>>>            Function_Return bExists
37027>>>>>>>        End
37027>>>>>>>>
37027>>>>>>>        Else Begin
37028>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
37029>>>>>>>            Get vFolderFormat sDataPath to sDataPath
37030>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
37031>>>>>>>        End
37031>>>>>>>>
37031>>>>>>>
37031>>>>>>>        Function_Return bExists
37032>>>>>>>    End_Function
37033>>>>>>>
37033>>>>>>>    // Pass a table handle
37033>>>>>>>    // Returns True if the table exists in filelist.cfg.
37033>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
37035>>>>>>>        Handle hTable
37035>>>>>>>        Boolean bFound
37035>>>>>>>
37035>>>>>>>        Move False to bFound
37036>>>>>>>        Move 0 to hTable
37037>>>>>>>        Repeat
37037>>>>>>>>
37037>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37040>>>>>>>            If (hTable > 0) Begin
37042>>>>>>>                If (hTable = hCheckTable) Begin
37044>>>>>>>                    Move True to bFound
37045>>>>>>>                End
37045>>>>>>>>
37045>>>>>>>            End
37045>>>>>>>>
37045>>>>>>>            If (bFound = True) ;                Break
37048>>>>>>>        Until (hTable = 0)
37050>>>>>>>
37050>>>>>>>        Function_Return (bFound = True)
37051>>>>>>>    End_Function
37052>>>>>>>
37052>>>>>>>    // Pass a table's logical name
37052>>>>>>>    // Returns True if the table exists in filelist.cfg.
37052>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
37054>>>>>>>        Handle hTable
37054>>>>>>>        Boolean bFound
37054>>>>>>>        String sCompareTable
37054>>>>>>>
37054>>>>>>>        Move False to bFound
37055>>>>>>>        Move 0 to hTable
37056>>>>>>>        Repeat
37056>>>>>>>>
37056>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37059>>>>>>>            If (hTable > 0) Begin
37061>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
37064>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
37066>>>>>>>                    Move True to bFound
37067>>>>>>>                End
37067>>>>>>>>
37067>>>>>>>            End
37067>>>>>>>>
37067>>>>>>>            If (bFound = True) ;                Break
37070>>>>>>>        Until (hTable = 0)
37072>>>>>>>
37072>>>>>>>        Function_Return (bFound = True)
37073>>>>>>>    End_Function
37074>>>>>>>
37074>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
37074>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
37076>>>>>>>        Boolean bOK bExists
37076>>>>>>>        String sDriverID
37076>>>>>>>
37076>>>>>>>        Get UtilTableExists hTable to bExists
37077>>>>>>>        If (bExists = False) Begin
37079>>>>>>>            Function_Return DATAFLEX_ID
37080>>>>>>>        End
37080>>>>>>>>
37080>>>>>>>        Get OpenTableExclusive hTable to bOK
37081>>>>>>>        If (bOK = False) Begin
37083>>>>>>>            Function_Return DATAFLEX_ID
37084>>>>>>>        End
37084>>>>>>>>
37084>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
37087>>>>>>>        Function_Return sDriverID
37088>>>>>>>    End_Function
37089>>>>>>>
37089>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
37089>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
37091>>>>>>>        Handle hTable
37091>>>>>>>        Integer iRetval
37091>>>>>>>
37091>>>>>>>        Move 0 to hTable
37092>>>>>>>        Move 0 to iRetval
37093>>>>>>>
37093>>>>>>>        Repeat
37093>>>>>>>>
37093>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37096>>>>>>>            If (hTable > 0) Begin
37098>>>>>>>                Increment iRetval
37099>>>>>>>            End
37099>>>>>>>>
37099>>>>>>>        Until (hTable = 0)
37101>>>>>>>
37101>>>>>>>        Function_Return iRetval
37102>>>>>>>    End_Function
37103>>>>>>>
37103>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
37103>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
37105>>>>>>>        Handle hTable
37105>>>>>>>        String sRoot sDriverID
37105>>>>>>>        Boolean bIsSQLTable
37105>>>>>>>        Integer iPos
37105>>>>>>>
37105>>>>>>>        Move 0 to hTable
37106>>>>>>>        Move "" to sDriverID
37107>>>>>>>        Move False to bIsSQLTable
37108>>>>>>>
37108>>>>>>>        Repeat
37108>>>>>>>>
37108>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37111>>>>>>>            If (hTable > 0) Begin
37113>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
37116>>>>>>>                If (sRoot contains ":") Begin
37118>>>>>>>                    Move (Pos(":", sRoot)) to iPos
37119>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
37120>>>>>>>                End
37120>>>>>>>>
37120>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
37121>>>>>>>            End
37121>>>>>>>>
37121>>>>>>>
37121>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
37123>>>>>>>
37123>>>>>>>        Function_Return sDriverID
37124>>>>>>>    End_Function
37125>>>>>>>
37125>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
37127>>>>>>>        String sRootName
37127>>>>>>>        Boolean bIsSQL
37127>>>>>>>        Handle hTable
37127>>>>>>>
37127>>>>>>>        Move False to bIsSQL
37128>>>>>>>        Move 0 to hTable
37129>>>>>>>        Repeat
37129>>>>>>>>
37129>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37132>>>>>>>            If (hTable > 0) Begin
37134>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
37137>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
37138>>>>>>>                If (bIsSQL = True) Begin
37140>>>>>>>                    Move 0 to hTable
37141>>>>>>>                End
37141>>>>>>>>
37141>>>>>>>            End
37141>>>>>>>>
37141>>>>>>>        Until (hTable = 0)
37143>>>>>>>
37143>>>>>>>        Function_Return (bIsSQL = False)
37144>>>>>>>    End_Function
37145>>>>>>>
37145>>>>>>>    // * Dummy function for the Studio's Code Explorer *
37145>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
37147>>>>>>>        Function_Return False
37148>>>>>>>    End_Function
37149>>>>>>>
37149>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
37151>>>>>>>        String  sRetval
37151>>>>>>>        String[] sOverlapFieldsArray
37152>>>>>>>        Integer iType iColumn iColumns
37152>>>>>>>        Boolean bOpen bOverlap
37152>>>>>>>
37152>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
37155>>>>>>>        If (bOpen = False) Begin
37157>>>>>>>            Open hTable
37159>>>>>>>        End
37159>>>>>>>>
37159>>>>>>>
37159>>>>>>>        Move "" to sRetval
37160>>>>>>>
37160>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
37163>>>>>>>
37163>>>>>>>        for iColumn from 0 to iColumns
37169>>>>>>>>
37169>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
37172>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
37174>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
37177>>>>>>>                If (bOverlap) Begin
37179>>>>>>>                    If (sRetval <> "") Begin
37181>>>>>>>                        Append sRetval ","
37182>>>>>>>                    End
37182>>>>>>>>
37182>>>>>>>                    Append sRetval iColumn
37183>>>>>>>                End
37183>>>>>>>>
37183>>>>>>>            End
37183>>>>>>>>
37183>>>>>>>        Loop
37184>>>>>>>>
37184>>>>>>>
37184>>>>>>>        If (bOpen = False) Begin
37186>>>>>>>            Close hTable
37187>>>>>>>        End
37187>>>>>>>>
37187>>>>>>>
37187>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
37188>>>>>>>
37188>>>>>>>        Function_Return sOverlapFieldsArray
37189>>>>>>>    End_Function
37190>>>>>>>
37190>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
37190>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
37192>>>>>>>        tColumnType[] ColumnType
37192>>>>>>>        tColumnType[] ColumnType
37193>>>>>>>
37193>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
37193>>>>>>>        // the dbType.
37193>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
37195>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
37197>>>>>>>                Move MDSMySQL to sDriverID
37198>>>>>>>            End
37198>>>>>>>>
37198>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
37200>>>>>>>                Move MSSQLDRV_ID to sDriverID
37201>>>>>>>            End
37201>>>>>>>>
37201>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
37203>>>>>>>                Move DB2_DRV_ID to sDriverID
37204>>>>>>>            End
37204>>>>>>>>
37204>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
37206>>>>>>>                Move MDSPgSQL to sDriverID
37207>>>>>>>            End
37207>>>>>>>>
37207>>>>>>>        End
37207>>>>>>>>
37207>>>>>>>
37207>>>>>>>        Case Begin
37207>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
37209>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
37210>>>>>>>                Case Break
37211>>>>>>>
37211>>>>>>>            Case (iDbType = EN_DbTypeDB2)
37214>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
37215>>>>>>>                Case Break
37216>>>>>>>
37216>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
37219>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
37220>>>>>>>                Case Break
37221>>>>>>>
37221>>>>>>>            Case (sDriverID = MDSMySQL)
37224>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
37225>>>>>>>                Case Break
37226>>>>>>>
37226>>>>>>>            Case (sDriverID = ORAFLEX)
37229>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
37230>>>>>>>                Case Break
37231>>>>>>>
37231>>>>>>>            Case (sDriverID = MDSPgSQL)
37234>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
37235>>>>>>>                Case Break
37236>>>>>>>        Case End
37236>>>>>>>
37236>>>>>>>        Function_Return ColumnType
37237>>>>>>>    End_Function
37238>>>>>>>
37238>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
37240>>>>>>>        Handle hoRegistry hoODBCDriverNames
37240>>>>>>>        Boolean bExists bKeyOpened
37240>>>>>>>        String sKey
37240>>>>>>>        String[] sDrivers
37241>>>>>>>        Integer iDriverNames iDriverName
37241>>>>>>>
37241>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
37242>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
37243>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
37244>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
37245>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
37246>>>>>>>        If (bExists) Begin
37248>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
37249>>>>>>>            If (bKeyOpened) Begin
37251>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
37252>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
37253>>>>>>>                If (iDriverNames > 0) Begin
37255>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
37256>>>>>>>                    Decrement iDriverNames
37257>>>>>>>                    for iDriverName from 0 to iDriverNames
37263>>>>>>>>
37263>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
37264>>>>>>>                    Loop
37265>>>>>>>>
37265>>>>>>>                End
37265>>>>>>>>
37265>>>>>>>                Send CloseKey of hoRegistry
37266>>>>>>>            End
37266>>>>>>>>
37266>>>>>>>        End
37266>>>>>>>>
37266>>>>>>>        Send Destroy of hoRegistry
37267>>>>>>>
37267>>>>>>>        Function_Return sDrivers
37268>>>>>>>    End_Function
37269>>>>>>>
37269>>>>>>>    // DataFlex Embedded Database Data Types:
37269>>>>>>>    // Helper function for UtilEnumerateColumnTypes
37269>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
37271>>>>>>>        tColumnType[] ColumnType
37271>>>>>>>        tColumnType[] ColumnType
37272>>>>>>>        Integer i
37272>>>>>>>
37272>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
37273>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
37274>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
37275>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
37276>>>>>>>        Move "254"              to ColumnType[i].sPrecision
37277>>>>>>>        Increment i
37278>>>>>>>
37278>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
37279>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
37280>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
37281>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
37282>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
37283>>>>>>>        Increment i
37284>>>>>>>
37284>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
37285>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
37286>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
37287>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
37288>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
37289>>>>>>>        Move True               to ColumnType[i].bCanEditSize
37290>>>>>>>        Increment i
37291>>>>>>>
37291>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
37292>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
37293>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
37294>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
37295>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
37296>>>>>>>        Increment i
37297>>>>>>>
37297>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
37298>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
37299>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
37300>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
37301>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
37302>>>>>>>        Increment i
37303>>>>>>>
37303>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
37304>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
37305>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
37306>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
37307>>>>>>>        Move "23"               to ColumnType[i].sPrecision
37308>>>>>>>        Move True               to ColumnType[i].bCanEditSize
37309>>>>>>>        Increment i
37310>>>>>>>
37310>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
37311>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
37312>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
37313>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
37314>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
37315>>>>>>>
37315>>>>>>>        Function_Return ColumnType
37316>>>>>>>    End_Function
37317>>>>>>>
37317>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
37319>>>>>>>        tColumnType[] aColumnType
37319>>>>>>>        tColumnType[] aColumnType
37320>>>>>>>        Integer i
37320>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\DB2_DRV_DriverDef.inc)
37320>>>>>>>>// Generated By The Database Update Framework
37320>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
37320>>>>>>>>// Driver COLUMN DATA TYPES
37320>>>>>>>>//
37320>>>>>>>>// Created: 2019-07-18 18:57:13.935
37320>>>>>>>>
37320>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
37321>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
37322>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37323>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37324>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37325>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37326>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37327>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37328>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37329>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37330>>>>>>>>            Increment i
37331>>>>>>>>
37331>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
37332>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
37333>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37334>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37335>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37336>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37337>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37338>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37339>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37340>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37341>>>>>>>>            Increment i
37342>>>>>>>>
37342>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
37343>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
37344>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37345>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37346>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37347>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37348>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37349>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37350>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37351>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37352>>>>>>>>            Increment i
37353>>>>>>>>
37353>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
37354>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
37355>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37356>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37357>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37358>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37359>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37360>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37361>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37362>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37363>>>>>>>>            Increment i
37364>>>>>>>>
37364>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
37365>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
37366>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37367>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37368>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37369>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37370>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37371>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37372>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37373>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37374>>>>>>>>            Increment i
37375>>>>>>>>
37375>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
37376>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
37377>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37378>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37379>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37380>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
37381>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
37382>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37383>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37384>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37385>>>>>>>>            Increment i
37386>>>>>>>>
37386>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
37387>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
37388>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37389>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37390>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
37391>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
37392>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
37393>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37394>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37395>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37396>>>>>>>>            Increment i
37397>>>>>>>>
37397>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
37398>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
37399>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37400>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37401>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
37402>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
37403>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
37404>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37405>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37406>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
37407>>>>>>>>            Increment i
37408>>>>>>>>
37408>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
37409>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
37410>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37411>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37412>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37413>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37414>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37415>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37416>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37417>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37418>>>>>>>>            Increment i
37419>>>>>>>>
37419>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
37420>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
37421>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37422>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37423>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37424>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37425>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37426>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37427>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37428>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37429>>>>>>>>            Increment i
37430>>>>>>>>
37430>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
37431>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
37432>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37433>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37434>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37435>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37436>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37437>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37438>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37439>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37440>>>>>>>>            Increment i
37441>>>>>>>>
37441>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
37442>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
37443>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37444>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37445>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
37446>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37447>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
37448>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37449>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37450>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
37451>>>>>>>>            Increment i
37452>>>>>>>>
37452>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
37453>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
37454>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37455>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37456>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37457>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37458>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37459>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37460>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37461>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37462>>>>>>>>            Increment i
37463>>>>>>>>
37463>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
37464>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
37465>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37466>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37467>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37468>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37469>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
37470>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37471>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37472>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
37473>>>>>>>>            Increment i
37474>>>>>>>>
37474>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
37475>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
37476>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37477>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37478>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37479>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37480>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37481>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37482>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37483>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37484>>>>>>>>            Increment i
37485>>>>>>>>
37485>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
37486>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
37487>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37488>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37489>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37490>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37491>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37492>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
37493>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
37494>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
37495>>>>>>>>            Increment i
37496>>>>>>>>
37496>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
37497>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
37498>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37499>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37500>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37501>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37502>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
37503>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37504>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37505>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
37506>>>>>>>>            Increment i
37507>>>>>>>>
37507>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
37508>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
37509>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37510>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37511>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37512>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37513>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37514>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37515>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37516>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37517>>>>>>>>            Increment i
37518>>>>>>>>
37518>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
37519>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
37520>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37521>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37522>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37523>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37524>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37525>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37526>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37527>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37528>>>>>>>>            Increment i
37529>>>>>>>>
37529>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
37530>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
37531>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37532>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37533>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37534>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37535>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37536>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37537>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37538>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37539>>>>>>>>            Increment i
37540>>>>>>>>
37540>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
37541>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
37542>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37543>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37544>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
37545>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37546>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
37547>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37548>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37549>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
37550>>>>>>>>            Increment i
37551>>>>>>>>
37551>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
37552>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
37553>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37554>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37555>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37556>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37557>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37558>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37559>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37560>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37561>>>>>>>>            Increment i
37562>>>>>>>>
37562>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
37563>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
37564>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37565>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37566>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37567>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37568>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37569>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37570>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37571>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37572>>>>>>>>            Increment i
37573>>>>>>>>
37573>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
37574>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
37575>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37576>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37577>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
37578>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
37579>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
37580>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37581>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37582>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
37583>>>>>>>>            Increment i
37584>>>>>>>>
37584>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
37585>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
37586>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37587>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37588>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
37589>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37590>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
37591>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37592>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37593>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
37594>>>>>>>>            Increment i
37595>>>>>>>>
37595>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
37596>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
37597>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37598>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37599>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37600>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37601>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37602>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37603>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37604>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37605>>>>>>>>            Increment i
37606>>>>>>>>
37606>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
37607>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
37608>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37609>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37610>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
37611>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37612>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37613>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37614>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37615>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37616>>>>>>>>            Increment i
37617>>>>>>>>
37617>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
37618>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
37619>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37620>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37621>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37622>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37623>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37624>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37625>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37626>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37627>>>>>>>>            Increment i
37628>>>>>>>>
37628>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
37629>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
37630>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37631>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37632>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37633>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37634>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37635>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37636>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37637>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37638>>>>>>>>            Increment i
37639>>>>>>>>
37639>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
37640>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
37641>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37642>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37643>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37644>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37645>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37646>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37647>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37648>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37649>>>>>>>>            Increment i
37650>>>>>>>>
37650>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
37651>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
37652>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37653>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37654>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37655>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37656>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37657>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37658>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37659>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37660>>>>>>>>            Increment i
37661>>>>>>>>
37661>>>>>>>>
37661>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
37661>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
37661>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
37661>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
37661>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        // ToDo: We need to change the sType when using this!
37661>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
37661>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
37661>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
37661>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
37661>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
37661>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
37661>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
37661>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
37661>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
37661>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
37661>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
37661>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
37661>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
37661>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
37661>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
37661>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
37661>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
37661>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
37661>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
37661>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
37661>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        // ToDo: We need to change the sType when using this!
37661>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
37661>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
37661>>>>>>>//        Increment i
37661>>>>>>>//
37661>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
37661>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37661>>>>>>>//
37661>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
37661>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
37661>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
37661>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
37661>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
37661>>>>>>>
37661>>>>>>>        Function_Return aColumnType
37662>>>>>>>    End_Function
37663>>>>>>>
37663>>>>>>>    // Microsoft SQL Server Database Data Types:
37663>>>>>>>    // Helper function for UtilEnumerateColumnTypes
37663>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
37665>>>>>>>        tColumnType[] aColumnType
37665>>>>>>>        tColumnType[] aColumnType
37666>>>>>>>        Integer i
37666>>>>>>>
37666>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\MSSQLDRV_DriverDef.inc)
37668>>>>>>>>// Generated By The Database Update Framework
37668>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
37668>>>>>>>>// Driver COLUMN DATA TYPES
37668>>>>>>>>//
37668>>>>>>>>// Created: 2019-11-15 21:57:51.001
37668>>>>>>>>
37668>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
37669>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
37670>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37671>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37672>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37673>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37674>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37675>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37676>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37677>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37678>>>>>>>>            Increment i
37679>>>>>>>>
37679>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
37680>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
37681>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37682>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37683>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37684>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37685>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37686>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37687>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37688>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37689>>>>>>>>            Increment i
37690>>>>>>>>
37690>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
37691>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
37692>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37693>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37694>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37695>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37696>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37697>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37698>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37699>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37700>>>>>>>>            Increment i
37701>>>>>>>>
37701>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
37702>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
37703>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37704>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37705>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37706>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37707>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37708>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37709>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37710>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37711>>>>>>>>            Increment i
37712>>>>>>>>
37712>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
37713>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
37714>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37715>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37716>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37717>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37718>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37719>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
37720>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
37721>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
37722>>>>>>>>            Increment i
37723>>>>>>>>
37723>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
37724>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
37725>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37726>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37727>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37728>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
37729>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
37730>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37731>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37732>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37733>>>>>>>>            Increment i
37734>>>>>>>>
37734>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
37735>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
37736>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37737>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37738>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
37739>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
37740>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
37741>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37742>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37743>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
37744>>>>>>>>            Increment i
37745>>>>>>>>
37745>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
37746>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
37747>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37748>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37749>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
37750>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
37751>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
37752>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37753>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37754>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
37755>>>>>>>>            Increment i
37756>>>>>>>>
37756>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
37757>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
37758>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37759>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37760>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37761>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37762>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37763>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37764>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37765>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37766>>>>>>>>            Increment i
37767>>>>>>>>
37767>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
37768>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
37769>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37770>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37771>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37772>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37773>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37774>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37775>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37776>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37777>>>>>>>>            Increment i
37778>>>>>>>>
37778>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
37779>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
37780>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37781>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37782>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37783>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37784>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37785>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37786>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37787>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37788>>>>>>>>            Increment i
37789>>>>>>>>
37789>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
37790>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
37791>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37792>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37793>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
37794>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37795>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
37796>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37797>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37798>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
37799>>>>>>>>            Increment i
37800>>>>>>>>
37800>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
37801>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
37802>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37803>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37804>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37805>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37806>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37807>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37808>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37809>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37810>>>>>>>>            Increment i
37811>>>>>>>>
37811>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
37812>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
37813>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37814>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37815>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37816>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37817>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
37818>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37819>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37820>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
37821>>>>>>>>            Increment i
37822>>>>>>>>
37822>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
37823>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
37824>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37825>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37826>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37827>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37828>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37829>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
37830>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
37831>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37832>>>>>>>>            Increment i
37833>>>>>>>>
37833>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
37834>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
37835>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37836>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37837>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37838>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37839>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37840>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37841>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37842>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37843>>>>>>>>            Increment i
37844>>>>>>>>
37844>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
37845>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
37846>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37847>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37848>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37849>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37850>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
37851>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37852>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37853>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
37854>>>>>>>>            Increment i
37855>>>>>>>>
37855>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
37856>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
37857>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37858>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37859>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37860>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37861>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37862>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37863>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37864>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37865>>>>>>>>            Increment i
37866>>>>>>>>
37866>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
37867>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
37868>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37869>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37870>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
37871>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37872>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
37873>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37874>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37875>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
37876>>>>>>>>            Increment i
37877>>>>>>>>
37877>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
37878>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
37879>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37880>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37881>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37882>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37883>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37884>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
37885>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
37886>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37887>>>>>>>>            Increment i
37888>>>>>>>>
37888>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
37889>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
37890>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37891>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37892>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
37893>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37894>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
37895>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37896>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37897>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
37898>>>>>>>>            Increment i
37899>>>>>>>>
37899>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
37900>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
37901>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37902>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37903>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37904>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37905>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37906>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37907>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37908>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37909>>>>>>>>            Increment i
37910>>>>>>>>
37910>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
37911>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
37912>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37913>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37914>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37915>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37916>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37917>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
37918>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
37919>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37920>>>>>>>>            Increment i
37921>>>>>>>>
37921>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
37922>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
37923>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37924>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37925>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
37926>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
37927>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
37928>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37929>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37930>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
37931>>>>>>>>            Increment i
37932>>>>>>>>
37932>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
37933>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
37934>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37935>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37936>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
37937>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37938>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
37939>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
37940>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
37941>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
37942>>>>>>>>            Increment i
37943>>>>>>>>
37943>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
37944>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
37945>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
37946>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37947>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
37948>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
37949>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
37950>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37951>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37952>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
37953>>>>>>>>            Increment i
37954>>>>>>>>
37954>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
37955>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
37956>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37957>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37958>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
37959>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37960>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37961>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
37962>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
37963>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37964>>>>>>>>            Increment i
37965>>>>>>>>
37965>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
37966>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
37967>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37968>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37969>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37970>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37971>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37972>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37973>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37974>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37975>>>>>>>>            Increment i
37976>>>>>>>>
37976>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
37977>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
37978>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37979>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37980>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
37981>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37982>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
37983>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
37984>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
37985>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
37986>>>>>>>>            Increment i
37987>>>>>>>>
37987>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
37988>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
37989>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
37990>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
37991>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
37992>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
37993>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
37994>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
37995>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
37996>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
37997>>>>>>>>            Increment i
37998>>>>>>>>
37998>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
37999>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
38000>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38001>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38002>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
38003>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38004>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
38005>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38006>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38007>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
38008>>>>>>>>            Increment i
38009>>>>>>>>
38009>>>>>>>>
38009>>>>>>>
38009>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
38009>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
38009>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
38009>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
38009>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
38009>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
38009>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
38009>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
38009>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
38009>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
38009>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
38009>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
38009>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
38009>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
38009>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
38009>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
38009>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
38009>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
38009>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
38009>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
38009>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
38009>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
38009>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
38009>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
38009>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
38009>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
38009>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
38009>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
38009>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
38009>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
38009>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
38009>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
38009>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
38009>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
38009>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>//
38009>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
38009>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
38009>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
38009>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
38009>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
38009>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38009>>>>>>>//            Increment i
38009>>>>>>>
38009>>>>>>>        End
38009>>>>>>>>
38009>>>>>>>
38009>>>>>>>        // Mertech SQLFlex driver
38009>>>>>>>        If (sDriverID = SQLFLEX) Begin
38011>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\sql_drv_DriverDef.inc)
38011>>>>>>>>// Generated By The Database Update Framework
38011>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
38011>>>>>>>>// Driver COLUMN DATA TYPES
38011>>>>>>>>//
38011>>>>>>>>// Created: 2018-03-14 23:47:46.885
38011>>>>>>>>
38011>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
38012>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
38013>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38014>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38015>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38016>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38017>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38018>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38019>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38020>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38021>>>>>>>>            Increment i
38022>>>>>>>>
38022>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
38023>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
38024>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38025>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38026>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38027>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38028>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38029>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38030>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38031>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38032>>>>>>>>            Increment i
38033>>>>>>>>
38033>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
38034>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
38035>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38036>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38037>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38038>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38039>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38040>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38041>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38042>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38043>>>>>>>>            Increment i
38044>>>>>>>>
38044>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38045>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
38046>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38047>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38048>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38049>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38050>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38051>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38052>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38053>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38054>>>>>>>>            Increment i
38055>>>>>>>>
38055>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38056>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
38057>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38058>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38059>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
38060>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38061>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38062>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38063>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38064>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38065>>>>>>>>            Increment i
38066>>>>>>>>
38066>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
38067>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
38068>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38069>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38070>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38071>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38072>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38073>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38074>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38075>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38076>>>>>>>>            Increment i
38077>>>>>>>>
38077>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
38078>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
38079>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38080>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38081>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38082>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38083>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38084>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38085>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38086>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38087>>>>>>>>            Increment i
38088>>>>>>>>
38088>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
38089>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
38090>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38091>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38092>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
38093>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
38094>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38095>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38096>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38097>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38098>>>>>>>>            Increment i
38099>>>>>>>>
38099>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
38100>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
38101>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38102>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38103>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38104>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38105>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38106>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38107>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38108>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38109>>>>>>>>            Increment i
38110>>>>>>>>
38110>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
38111>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
38112>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38113>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38114>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38115>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38116>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38117>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38118>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38119>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38120>>>>>>>>            Increment i
38121>>>>>>>>
38121>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
38122>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
38123>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38124>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38125>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38126>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38127>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38128>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38129>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38130>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38131>>>>>>>>            Increment i
38132>>>>>>>>
38132>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
38133>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
38134>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38135>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38136>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38137>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38138>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38139>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38140>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38141>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38142>>>>>>>>            Increment i
38143>>>>>>>>
38143>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
38144>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
38145>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38146>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38147>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38148>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38149>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38150>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38151>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38152>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38153>>>>>>>>            Increment i
38154>>>>>>>>
38154>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
38155>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
38156>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38157>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38158>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38159>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38160>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38161>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38162>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38163>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38164>>>>>>>>            Increment i
38165>>>>>>>>
38165>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38166>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38167>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38168>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38169>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
38170>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38171>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
38172>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38173>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38174>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
38175>>>>>>>>            Increment i
38176>>>>>>>>
38176>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
38177>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
38178>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38179>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38180>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38181>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38182>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38183>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38184>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38185>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38186>>>>>>>>            Increment i
38187>>>>>>>>
38187>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
38188>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
38189>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38190>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38191>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38192>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38193>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38194>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38195>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38196>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38197>>>>>>>>            Increment i
38198>>>>>>>>
38198>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
38199>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
38200>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38201>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38202>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38203>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38204>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38205>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38206>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38207>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38208>>>>>>>>            Increment i
38209>>>>>>>>
38209>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
38210>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
38211>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38212>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38213>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38214>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38215>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38216>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38217>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38218>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38219>>>>>>>>            Increment i
38220>>>>>>>>
38220>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
38221>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
38222>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38223>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38224>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38225>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38226>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38227>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38228>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38229>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38230>>>>>>>>            Increment i
38231>>>>>>>>
38231>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
38232>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
38233>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38234>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38235>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38236>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38237>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38238>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38239>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38240>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38241>>>>>>>>            Increment i
38242>>>>>>>>
38242>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
38243>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
38244>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38245>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38246>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
38247>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
38248>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38249>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38250>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38251>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38252>>>>>>>>            Increment i
38253>>>>>>>>
38253>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
38254>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
38255>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38256>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38257>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38258>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38259>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
38260>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38261>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38262>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38263>>>>>>>>            Increment i
38264>>>>>>>>
38264>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
38265>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
38266>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38267>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38268>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
38269>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38270>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38271>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38272>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38273>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38274>>>>>>>>            Increment i
38275>>>>>>>>
38275>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
38276>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
38277>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38278>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38279>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38280>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38281>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38282>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38283>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38284>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38285>>>>>>>>            Increment i
38286>>>>>>>>
38286>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
38287>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
38288>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38289>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38290>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
38291>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
38292>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
38293>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38294>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38295>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
38296>>>>>>>>            Increment i
38297>>>>>>>>
38297>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
38298>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
38299>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38300>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38301>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
38302>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38303>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38304>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38305>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38306>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38307>>>>>>>>            Increment i
38308>>>>>>>>
38308>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
38309>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
38310>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38311>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38312>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
38313>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38314>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
38315>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38316>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38317>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
38318>>>>>>>>            Increment i
38319>>>>>>>>
38319>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
38320>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
38321>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38322>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38323>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
38324>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38325>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38326>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38327>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38328>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38329>>>>>>>>            Increment i
38330>>>>>>>>
38330>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
38331>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
38332>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38333>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38334>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
38335>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38336>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38337>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38338>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38339>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38340>>>>>>>>            Increment i
38341>>>>>>>>
38341>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
38342>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
38343>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38344>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38345>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38346>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38347>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38348>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38349>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38350>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38351>>>>>>>>            Increment i
38352>>>>>>>>
38352>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
38353>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38354>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38355>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38356>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38357>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38358>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
38359>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38360>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38361>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
38362>>>>>>>>            Increment i
38363>>>>>>>>
38363>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
38364>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
38365>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38366>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38367>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38368>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38369>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38370>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38371>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38372>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38373>>>>>>>>            Increment i
38374>>>>>>>>
38374>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
38375>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
38376>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38377>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38378>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38379>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38380>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38381>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38382>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38383>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38384>>>>>>>>            Increment i
38385>>>>>>>>
38385>>>>>>>>
38385>>>>>>>
38385>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
38385>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
38385>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
38385>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
38385>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
38385>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
38385>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38385>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
38385>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
38385>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
38385>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
38385>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
38385>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
38385>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
38385>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
38385>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
38385>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
38385>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
38385>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
38385>>>>>>>//            Increment i
38385>>>>>>>//
38385>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
38385>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
38385>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
38385>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
38385>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
38385>>>>>>>        End
38385>>>>>>>>
38385>>>>>>>
38385>>>>>>>        Function_Return aColumnType
38386>>>>>>>    End_Function
38387>>>>>>>
38387>>>>>>>    // MySQL Data Types
38387>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
38389>>>>>>>        tColumnType[] aColumnType
38389>>>>>>>        tColumnType[] aColumnType
38390>>>>>>>        Integer i
38390>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\mdsmysql_DriverDef.inc)
38390>>>>>>>>// Generated By The Database Update Framework
38390>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
38390>>>>>>>>// Driver COLUMN DATA TYPES
38390>>>>>>>>//
38390>>>>>>>>// Created: 2018-03-14 23:46:49.593
38390>>>>>>>>
38390>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
38391>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
38392>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38393>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38394>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38395>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38396>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38397>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38398>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38399>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38400>>>>>>>>            Increment i
38401>>>>>>>>
38401>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
38402>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
38403>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38404>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38405>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38406>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38407>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
38408>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38409>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38410>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
38411>>>>>>>>            Increment i
38412>>>>>>>>
38412>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
38413>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
38414>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38415>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38416>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38417>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38418>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38419>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38420>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38421>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38422>>>>>>>>            Increment i
38423>>>>>>>>
38423>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38424>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
38425>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38426>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38427>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38428>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38429>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38430>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38431>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38432>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38433>>>>>>>>            Increment i
38434>>>>>>>>
38434>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38435>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
38436>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38437>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38438>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38439>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38440>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38441>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
38442>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
38443>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38444>>>>>>>>            Increment i
38445>>>>>>>>
38445>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
38446>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38447>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38448>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38449>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38450>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38451>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38452>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38453>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38454>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38455>>>>>>>>            Increment i
38456>>>>>>>>
38456>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
38457>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
38458>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38459>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38460>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38461>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38462>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38463>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38464>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38465>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38466>>>>>>>>            Increment i
38467>>>>>>>>
38467>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
38468>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
38469>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38470>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38471>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38472>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38473>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38474>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38475>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38476>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38477>>>>>>>>            Increment i
38478>>>>>>>>
38478>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
38479>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
38480>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38481>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38482>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38483>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38484>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38485>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38486>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38487>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38488>>>>>>>>            Increment i
38489>>>>>>>>
38489>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
38490>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
38491>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38492>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38493>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38494>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38495>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38496>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38497>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38498>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38499>>>>>>>>            Increment i
38500>>>>>>>>
38500>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
38501>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38502>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38503>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38504>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
38505>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38506>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38507>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38508>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38509>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38510>>>>>>>>            Increment i
38511>>>>>>>>
38511>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38512>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
38513>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38514>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38515>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
38516>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38517>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
38518>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38519>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38520>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
38521>>>>>>>>            Increment i
38522>>>>>>>>
38522>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
38523>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
38524>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38525>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38526>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38527>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38528>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38529>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38530>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38531>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38532>>>>>>>>            Increment i
38533>>>>>>>>
38533>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
38534>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
38535>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38536>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38537>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38538>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38539>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38540>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38541>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38542>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38543>>>>>>>>            Increment i
38544>>>>>>>>
38544>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
38545>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
38546>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38547>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38548>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38549>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38550>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38551>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38552>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38553>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38554>>>>>>>>            Increment i
38555>>>>>>>>
38555>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
38556>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
38557>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38558>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38559>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
38560>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38561>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
38562>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38563>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38564>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
38565>>>>>>>>            Increment i
38566>>>>>>>>
38566>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
38567>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
38568>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38569>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38570>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38571>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38572>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38573>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38574>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38575>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38576>>>>>>>>            Increment i
38577>>>>>>>>
38577>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
38578>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
38579>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38580>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38581>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38582>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38583>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38584>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38585>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38586>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38587>>>>>>>>            Increment i
38588>>>>>>>>
38588>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
38589>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
38590>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38591>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38592>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
38593>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38594>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
38595>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38596>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38597>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38598>>>>>>>>            Increment i
38599>>>>>>>>
38599>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
38600>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
38601>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38602>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38603>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38604>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38605>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38606>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38607>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38608>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38609>>>>>>>>            Increment i
38610>>>>>>>>
38610>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
38611>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
38612>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38613>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38614>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
38615>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38616>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38617>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38618>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38619>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38620>>>>>>>>            Increment i
38621>>>>>>>>
38621>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
38622>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
38623>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38624>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38625>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38626>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38627>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38628>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38629>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38630>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
38631>>>>>>>>            Increment i
38632>>>>>>>>
38632>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
38633>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
38634>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38635>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38636>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
38637>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38638>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38639>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38640>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38641>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38642>>>>>>>>            Increment i
38643>>>>>>>>
38643>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
38644>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
38645>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38646>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38647>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
38648>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38649>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
38650>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38651>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38652>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
38653>>>>>>>>            Increment i
38654>>>>>>>>
38654>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
38655>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
38656>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38657>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38658>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
38659>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38660>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
38661>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38662>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38663>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
38664>>>>>>>>            Increment i
38665>>>>>>>>
38665>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
38666>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
38667>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38668>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38669>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
38670>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38671>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38672>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38673>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38674>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38675>>>>>>>>            Increment i
38676>>>>>>>>
38676>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
38677>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
38678>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38679>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38680>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
38681>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38682>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38683>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38684>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38685>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38686>>>>>>>>            Increment i
38687>>>>>>>>
38687>>>>>>>>
38687>>>>>>>
38687>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
38687>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
38687>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
38687>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
38687>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
38687>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
38687>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
38687>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
38687>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
38687>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
38687>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
38687>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
38687>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
38687>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
38687>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
38687>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
38687>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
38687>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
38687>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
38687>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
38687>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
38687>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
38687>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
38687>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
38687>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38687>>>>>>>//        Increment i
38687>>>>>>>//
38687>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
38687>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
38687>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38687>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
38687>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
38687>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38687>>>>>>>//        Increment i
38687>>>>>>>
38687>>>>>>>        Function_Return aColumnType
38688>>>>>>>    End_Function
38689>>>>>>>
38689>>>>>>>    // Oracle Data Types
38689>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
38691>>>>>>>        tColumnType[] aColumnType
38691>>>>>>>        tColumnType[] aColumnType
38692>>>>>>>        Integer i
38692>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\ora_drv_DriverDef.inc)
38692>>>>>>>>// Generated By The Database Update Framework
38692>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
38692>>>>>>>>// Driver COLUMN DATA TYPES
38692>>>>>>>>//
38692>>>>>>>>// Created: 2018-03-14 23:47:34.82
38692>>>>>>>>
38692>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
38693>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
38694>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38695>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38696>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38697>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38698>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38699>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38700>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38701>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38702>>>>>>>>            Increment i
38703>>>>>>>>
38703>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38704>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
38705>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38706>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38707>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38708>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38709>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
38710>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38711>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38712>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
38713>>>>>>>>            Increment i
38714>>>>>>>>
38714>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
38715>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
38716>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38717>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38718>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38719>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38720>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38721>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38722>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38723>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38724>>>>>>>>            Increment i
38725>>>>>>>>
38725>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38726>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
38727>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38728>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38729>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38730>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
38731>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
38732>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
38733>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
38734>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38735>>>>>>>>            Increment i
38736>>>>>>>>
38736>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
38737>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
38738>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38739>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38740>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38741>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38742>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38743>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38744>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38745>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38746>>>>>>>>            Increment i
38747>>>>>>>>
38747>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
38748>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
38749>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38750>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38751>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38752>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38753>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38754>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38755>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38756>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38757>>>>>>>>            Increment i
38758>>>>>>>>
38758>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
38759>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
38760>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38761>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38762>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38763>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38764>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38765>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38766>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38767>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38768>>>>>>>>            Increment i
38769>>>>>>>>
38769>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
38770>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
38771>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38772>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38773>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38774>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38775>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38776>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38777>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38778>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38779>>>>>>>>            Increment i
38780>>>>>>>>
38780>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
38781>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
38782>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38783>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38784>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38785>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38786>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38787>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38788>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38789>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38790>>>>>>>>            Increment i
38791>>>>>>>>
38791>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
38792>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
38793>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38794>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38795>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38796>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38797>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38798>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38799>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38800>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38801>>>>>>>>            Increment i
38802>>>>>>>>
38802>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
38803>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
38804>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38805>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38806>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38807>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38808>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
38809>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38810>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38811>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
38812>>>>>>>>            Increment i
38813>>>>>>>>
38813>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
38814>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
38815>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38816>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38817>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
38818>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38819>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38820>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
38821>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
38822>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38823>>>>>>>>            Increment i
38824>>>>>>>>
38824>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
38825>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
38826>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38827>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38828>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38829>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38830>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38831>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38832>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38833>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38834>>>>>>>>            Increment i
38835>>>>>>>>
38835>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
38836>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
38837>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38838>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38839>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38840>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38841>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38842>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38843>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38844>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38845>>>>>>>>            Increment i
38846>>>>>>>>
38846>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
38847>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
38848>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38849>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38850>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38851>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38852>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
38853>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38854>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38855>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
38856>>>>>>>>            Increment i
38857>>>>>>>>
38857>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
38858>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
38859>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38860>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38861>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38862>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38863>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38864>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38865>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38866>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38867>>>>>>>>            Increment i
38868>>>>>>>>
38868>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
38869>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
38870>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38871>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38872>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38873>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38874>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38875>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38876>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38877>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38878>>>>>>>>            Increment i
38879>>>>>>>>
38879>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
38880>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
38881>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38882>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38883>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
38884>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38885>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38886>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
38887>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
38888>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38889>>>>>>>>            Increment i
38890>>>>>>>>
38890>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
38891>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
38892>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38893>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38894>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38895>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38896>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
38897>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38898>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38899>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
38900>>>>>>>>            Increment i
38901>>>>>>>>
38901>>>>>>>>
38901>>>>>>>
38901>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
38901>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
38901>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
38901>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
38901>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
38901>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
38901>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
38901>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
38901>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
38901>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
38901>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
38901>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
38901>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
38901>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
38901>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
38901>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
38901>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
38901>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
38901>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
38901>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
38901>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
38901>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
38901>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
38901>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
38901>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
38901>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
38901>>>>>>>//        Increment i
38901>>>>>>>//
38901>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
38901>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
38901>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
38901>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
38901>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
38901>>>>>>>
38901>>>>>>>        Function_Return aColumnType
38902>>>>>>>    End_Function
38903>>>>>>>
38903>>>>>>>    // PostgreSQL Data Types
38903>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
38905>>>>>>>        tColumnType[] aColumnType
38905>>>>>>>        tColumnType[] aColumnType
38906>>>>>>>        Integer i
38906>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\mdspgsql_DriverDef.inc)
38906>>>>>>>>// Generated By The Database Update Framework
38906>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
38906>>>>>>>>// Driver COLUMN DATA TYPES
38906>>>>>>>>//
38906>>>>>>>>// Created: 2018-03-14 23:47:02.984
38906>>>>>>>>
38906>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
38907>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
38908>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38909>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38910>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38911>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38912>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38913>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
38914>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
38915>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38916>>>>>>>>            Increment i
38917>>>>>>>>
38917>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
38918>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
38919>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38920>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38921>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38922>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38923>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38924>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38925>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38926>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38927>>>>>>>>            Increment i
38928>>>>>>>>
38928>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
38929>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
38930>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38931>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38932>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38933>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38934>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38935>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38936>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38937>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
38938>>>>>>>>            Increment i
38939>>>>>>>>
38939>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
38940>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
38941>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38942>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38943>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38944>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38945>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38946>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
38947>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
38948>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38949>>>>>>>>            Increment i
38950>>>>>>>>
38950>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
38951>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
38952>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38953>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38954>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38955>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38956>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38957>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38958>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38959>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38960>>>>>>>>            Increment i
38961>>>>>>>>
38961>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
38962>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
38963>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38964>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38965>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
38966>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38967>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
38968>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38969>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38970>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
38971>>>>>>>>            Increment i
38972>>>>>>>>
38972>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
38973>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
38974>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
38975>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38976>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
38977>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
38978>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
38979>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
38980>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
38981>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
38982>>>>>>>>            Increment i
38983>>>>>>>>
38983>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
38984>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
38985>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38986>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38987>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
38988>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
38989>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
38990>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
38991>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
38992>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
38993>>>>>>>>            Increment i
38994>>>>>>>>
38994>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
38995>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
38996>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
38997>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
38998>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
38999>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39000>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
39001>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39002>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39003>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
39004>>>>>>>>            Increment i
39005>>>>>>>>
39005>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
39006>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
39007>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39008>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39009>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
39010>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39011>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
39012>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39013>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39014>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
39015>>>>>>>>            Increment i
39016>>>>>>>>
39016>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
39017>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
39018>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39019>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39020>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
39021>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39022>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
39023>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39024>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39025>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
39026>>>>>>>>            Increment i
39027>>>>>>>>
39027>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
39028>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
39029>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39030>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39031>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
39032>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39033>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39034>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
39035>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
39036>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39037>>>>>>>>            Increment i
39038>>>>>>>>
39038>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
39039>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
39040>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39041>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39042>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
39043>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39044>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
39045>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39046>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39047>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
39048>>>>>>>>            Increment i
39049>>>>>>>>
39049>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
39050>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
39051>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39052>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39053>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
39054>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39055>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39056>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39057>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39058>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39059>>>>>>>>            Increment i
39060>>>>>>>>
39060>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
39061>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
39062>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39063>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39064>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
39065>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39066>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
39067>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
39068>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
39069>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
39070>>>>>>>>            Increment i
39071>>>>>>>>
39071>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
39072>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
39073>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39074>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39075>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39076>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39077>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39078>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39079>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39080>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39081>>>>>>>>            Increment i
39082>>>>>>>>
39082>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
39083>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
39084>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39085>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39086>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
39087>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
39088>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
39089>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39090>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39091>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
39092>>>>>>>>            Increment i
39093>>>>>>>>
39093>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
39094>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
39095>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39096>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39097>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39098>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39099>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39100>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
39101>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
39102>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39103>>>>>>>>            Increment i
39104>>>>>>>>
39104>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
39105>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
39106>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39107>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39108>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
39109>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39110>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39111>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39112>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39113>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39114>>>>>>>>            Increment i
39115>>>>>>>>
39115>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
39116>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
39117>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
39118>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39119>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
39120>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
39121>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
39122>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39123>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39124>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
39125>>>>>>>>            Increment i
39126>>>>>>>>
39126>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
39127>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
39128>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39129>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39130>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39131>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39132>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39133>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39134>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39135>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39136>>>>>>>>            Increment i
39137>>>>>>>>
39137>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
39138>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
39139>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
39140>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
39141>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
39142>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
39143>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
39144>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
39145>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
39146>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
39147>>>>>>>>            Increment i
39148>>>>>>>>
39148>>>>>>>>
39148>>>>>>>
39148>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
39148>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
39148>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
39148>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
39148>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
39148>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
39148>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
39148>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
39148>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
39148>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
39148>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
39148>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
39148>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
39148>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
39148>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
39148>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
39148>>>>>>>//        Increment i
39148>>>>>>>//
39148>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
39148>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
39148>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
39148>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
39148>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
39148>>>>>>>//        Increment i
39148>>>>>>>
39148>>>>>>>        Function_Return aColumnType
39149>>>>>>>    End_Function
39150>>>>>>>
39150>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
39150>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
39152>>>>>>>        Integer iValue iSize iCount iStart
39152>>>>>>>        tColumnType[] ColumnTypeArray
39152>>>>>>>        tColumnType[] ColumnTypeArray
39153>>>>>>>        tColumnType RetvalType
39153>>>>>>>        tColumnType RetvalType
39153>>>>>>>        String sValue
39153>>>>>>>        Boolean bFrameworkDataFlexType
39153>>>>>>>
39153>>>>>>>        Move "Undefined" to RetvalType.sSQLType
39154>>>>>>>        Move -1999       to RetvalType.iSQLType
39155>>>>>>>
39155>>>>>>>        Move 0 to iStart
39156>>>>>>>        Move (Uppercase(sType)) to sType
39157>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
39158>>>>>>>        If (bFrameworkDataFlexType = True) Begin
39160>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
39161>>>>>>>            Function_Return RetvalType
39162>>>>>>>        End
39162>>>>>>>>
39162>>>>>>>
39162>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
39163>>>>>>>
39163>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
39164>>>>>>>        Decrement iSize
39165>>>>>>>
39165>>>>>>>        for iCount from iStart to iSize
39171>>>>>>>>
39171>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
39172>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
39173>>>>>>>            If (bIntegerInputType = True) Begin
39175>>>>>>>                If (iValue = iType) Begin
39177>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
39178>>>>>>>                    Move iType                                  to RetvalType.iSQLType
39179>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
39180>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
39181>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
39182>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
39183>>>>>>>                    Move iSize to iCount // We're done!
39184>>>>>>>                End
39184>>>>>>>>
39184>>>>>>>            End
39184>>>>>>>>
39184>>>>>>>            Else Begin
39185>>>>>>>                Move (Uppercase(sValue)) to sValue
39186>>>>>>>                If (sValue = sType) Begin
39188>>>>>>>                    Move sType                                  to RetvalType.sSQLType
39189>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
39190>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
39191>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
39192>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
39193>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
39194>>>>>>>                    Move iSize to iCount // We're done!
39195>>>>>>>                End
39195>>>>>>>>
39195>>>>>>>            End
39195>>>>>>>>
39195>>>>>>>        Loop
39196>>>>>>>>
39196>>>>>>>
39196>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
39196>>>>>>>        // In which case we search for a match in DataFlex standard types:
39196>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
39198>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
39199>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
39200>>>>>>>            Decrement iSize
39201>>>>>>>
39201>>>>>>>            for iCount from iStart to iSize
39207>>>>>>>>
39207>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
39208>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
39209>>>>>>>                If (iValue = iType) Begin
39211>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
39212>>>>>>>                    Move iType                                  to RetvalType.iSQLType
39213>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
39214>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
39215>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
39216>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
39217>>>>>>>                    Move iSize to iCount // We're done!
39218>>>>>>>                End
39218>>>>>>>>
39218>>>>>>>            Loop
39219>>>>>>>>
39219>>>>>>>        End
39219>>>>>>>>
39219>>>>>>>
39219>>>>>>>        Function_Return RetvalType
39220>>>>>>>    End_Function
39221>>>>>>>
39221>>>>>>>    Function _AllTablesToConvert Returns Integer[]
39223>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
39225>>>>>>>        Handle hTable
39225>>>>>>>        Integer iIndex
39225>>>>>>>        String sTableName
39225>>>>>>>        Boolean bFlexErrs
39225>>>>>>>
39225>>>>>>>        // a) Get the exception table array the developer has specified
39225>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
39226>>>>>>>
39226>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
39226>>>>>>>        Repeat
39226>>>>>>>>
39226>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39229>>>>>>>            If (hTable <> 0) Begin
39231>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39234>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
39235>>>>>>>                If (bFlexErrs = False) Begin
39237>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
39239>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
39240>>>>>>>                        If (iIndex = -1) Begin
39242>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
39243>>>>>>>                        End
39243>>>>>>>>
39243>>>>>>>                    End
39243>>>>>>>>
39243>>>>>>>                End
39243>>>>>>>>
39243>>>>>>>            End
39243>>>>>>>>
39243>>>>>>>        Until (hTable = 0)
39245>>>>>>>
39245>>>>>>>        Move 0 to hTable
39246>>>>>>>
39246>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
39246>>>>>>>        Repeat
39246>>>>>>>>
39246>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39249>>>>>>>            If (hTable > 0) Begin
39251>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39254>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
39255>>>>>>>                If (bFlexErrs = False) Begin
39257>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
39258>>>>>>>                    If (iIndex = -1) Begin
39260>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
39261>>>>>>>                    End
39261>>>>>>>>
39261>>>>>>>                End
39261>>>>>>>>
39261>>>>>>>            End
39261>>>>>>>>
39261>>>>>>>        Until (hTable = 0)
39263>>>>>>>
39263>>>>>>>        Function_Return iTablesArray
39264>>>>>>>    End_Function
39265>>>>>>>
39265>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
39267>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
39269>>>>>>>        Handle hTable
39269>>>>>>>        Integer iIndex
39269>>>>>>>        String sTableName
39269>>>>>>>        Boolean bFlexErrs
39269>>>>>>>
39269>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
39270>>>>>>>        Move 0 to hTable
39271>>>>>>>
39271>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
39271>>>>>>>        Repeat
39271>>>>>>>>
39271>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39274>>>>>>>            If (hTable > 0) Begin
39276>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39279>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
39280>>>>>>>                If (bFlexErrs = False) Begin
39282>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
39283>>>>>>>                    If (iIndex = -1) Begin
39285>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
39286>>>>>>>                    End
39286>>>>>>>>
39286>>>>>>>                End
39286>>>>>>>>
39286>>>>>>>            End
39286>>>>>>>>
39286>>>>>>>        Until (hTable = 0)
39288>>>>>>>
39288>>>>>>>        Function_Return iTablesArray
39289>>>>>>>    End_Function
39290>>>>>>>
39290>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
39292>>>>>>>        tAPIColumn NewAPIColumn
39292>>>>>>>        tAPIColumn NewAPIColumn
39292>>>>>>>
39292>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
39293>>>>>>>        Move iType      to NewAPIColumn.iType
39294>>>>>>>        Move iLength    to NewAPIColumn.iLength
39295>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
39296>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
39297>>>>>>>
39297>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
39298>>>>>>>
39298>>>>>>>        Function_Return aCurrent
39299>>>>>>>    End_Function
39300>>>>>>>
39300>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
39302>>>>>>>        String sRetval sFieldName
39302>>>>>>>        Integer iCount iSize
39302>>>>>>>
39302>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
39303>>>>>>>        Decrement iSize
39304>>>>>>>        for iCount from 0 to iSize
39310>>>>>>>>
39310>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
39311>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
39312>>>>>>>        Loop
39313>>>>>>>>
39313>>>>>>>        Move (Trim(sRetval)) to sRetval
39314>>>>>>>
39314>>>>>>>        Function_Return sRetval
39315>>>>>>>    End_Function
39316>>>>>>>
39316>>>>>>>    // *** Miscellaneous other functions ***
39316>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
39316>>>>>>>    //
39316>>>>>>>
39316>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
39316>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
39318>>>>>>>        Integer iPerc
39318>>>>>>>        Number nReady nTotal
39318>>>>>>>
39318>>>>>>>        Send DoAdvance of ghoProgressBar
39319>>>>>>>
39319>>>>>>>        If (sCallback_Text contains "Copy records") Begin
39321>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
39322>>>>>>>        End
39322>>>>>>>>
39322>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
39324>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
39325>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
39326>>>>>>>        End
39326>>>>>>>>
39326>>>>>>>        If (sCallback_Text contains "Creating index") Begin
39328>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
39329>>>>>>>        End
39329>>>>>>>>
39329>>>>>>>
39329>>>>>>>        Case Begin
39329>>>>>>>            Case (iCallback_Type = DF_Message_Text)
39331>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39332>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39333>>>>>>>                Case Break
39334>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
39337>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39338>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39339>>>>>>>                Case Break
39340>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
39343>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39344>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39345>>>>>>>                Case Break
39346>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
39349>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39350>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39351>>>>>>>                Case Break
39352>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
39355>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39356>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39357>>>>>>>                Case Break
39358>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
39361>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39362>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39363>>>>>>>                Case Break
39364>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
39367>>>>>>>                Send None
39368>>>>>>>                Case Break
39369>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
39372>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
39373>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
39374>>>>>>>                Case Break
39375>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
39378>>>>>>>                //*** Interpret numbers
39378>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
39379>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
39380>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
39381>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
39382>>>>>>>                Case Break
39383>>>>>>>            Case Else
39383>>>>>>>                Set Message_Text to ""
39384>>>>>>>                Set Action_Text  to ""
39385>>>>>>>        Case End
39385>>>>>>>
39385>>>>>>>        Send ProcessEvents of ghoStatusPanel
39386>>>>>>>        Function_Return False
39387>>>>>>>    End_Function
39388>>>>>>>
39388>>>>>>>    Procedure IncreaseSortBufferSize
39390>>>>>>>        String sNull
39390>>>>>>>        Integer iSortBufferSize
39390>>>>>>>        Boolean bBufferSet
39390>>>>>>>
39390>>>>>>>        Move "" to sNull
39391>>>>>>>        Move (1024 * 128) to iSortBufferSize
39392>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
39397>>>>>>>
39397>>>>>>>    End_Procedure
39398>>>>>>>
39398>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
39400>>>>>>>        Integer iLastIndex iIndex iNumSegments
39400>>>>>>>        Boolean bOK
39400>>>>>>>        String sDriverID
39400>>>>>>>
39400>>>>>>>        If (hTable > 0) Begin
39402>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
39403>>>>>>>            Close hTable
39404>>>>>>>            Get OpenTableExclusive hTable to bOK
39405>>>>>>>            If (bOK = False) Begin
39407>>>>>>>                Procedure_Return
39408>>>>>>>            End
39408>>>>>>>>
39408>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
39411>>>>>>>            Structure_Start hTable sDriverID
39412>>>>>>>                for iIndex from 1 to iLastIndex
39418>>>>>>>>
39418>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
39421>>>>>>>                    If (iNumSegments > 0) Begin
39423>>>>>>>                        If (bSetToBatch = True) Begin
39425>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
39428>>>>>>>                        End
39428>>>>>>>>
39428>>>>>>>                        Else Begin
39429>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
39432>>>>>>>                        End
39432>>>>>>>>
39432>>>>>>>                    End
39432>>>>>>>>
39432>>>>>>>                Loop
39433>>>>>>>>
39433>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
39435>>>>>>>        End
39435>>>>>>>>
39435>>>>>>>    End_Procedure
39436>>>>>>>
39436>>>>>>>    Function NextFreeFilelistSlot Returns Handle
39438>>>>>>>        Handle hTable
39438>>>>>>>
39438>>>>>>>        Move 0 to hTable
39439>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
39442>>>>>>>
39442>>>>>>>        Function_Return hTable
39443>>>>>>>    End_Function
39444>>>>>>>
39444>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
39444>>>>>>>    Procedure DebugPrint String sStmt String sFileName
39446>>>>>>>        Integer iCh
39446>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
39447>>>>>>>            Write channel iCh sStmt
39449>>>>>>>        Send Seq_Close_Channel iCh
39450>>>>>>>    End_Procedure
39451>>>>>>>
39451>>>>>>>    // Returns the integer number for the passed Driver ID that is
39451>>>>>>>    // needed by some database API calls.
39451>>>>>>>    Function DriverIndex String sDriverID Returns Integer
39453>>>>>>>        String  sCurrentDriver
39453>>>>>>>        Integer iNumberOfDrivers iDriver iCount
39453>>>>>>>
39453>>>>>>>        Move 0 to iDriver
39454>>>>>>>
39454>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
39457>>>>>>>        for iCount from 1 to iNumberOfDrivers
39463>>>>>>>>
39463>>>>>>>
39463>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
39466>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
39468>>>>>>>                Move iCount to iDriver
39469>>>>>>>            End
39469>>>>>>>>
39469>>>>>>>        Loop
39470>>>>>>>>
39470>>>>>>>
39470>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
39470>>>>>>>        If (iDriver = 0) Begin
39472>>>>>>>            Move False to Err
39473>>>>>>>            Load_Driver sDriverID
39474>>>>>>>            If (Err = False) Begin
39476>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
39479>>>>>>>            End
39479>>>>>>>>
39479>>>>>>>        End
39479>>>>>>>>
39479>>>>>>>
39479>>>>>>>        Function_Return iDriver
39480>>>>>>>    End_Function
39481>>>>>>>
39481>>>>>>>    
39481>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
39483>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
39483>>>>>>>        Integer iNumberOfDrivers iDriver iClient
39483>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
39483>>>>>>>        Boolean bOK
39483>>>>>>>        
39483>>>>>>>        Move "" to sRetval
39484>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
39485>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
39486>>>>>>>        Load_Driver MSSQLDRV_ID
39487>>>>>>>
39487>>>>>>>        // Loop through all loaded drivers.
39487>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
39490>>>>>>>        For iDriver from 1 to iNumberOfDrivers
39496>>>>>>>>
39496>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
39499>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
39501>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
39502>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
39505>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
39506>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
39507>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
39508>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
39509>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
39511>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
39512>>>>>>>                End                                
39512>>>>>>>>
39512>>>>>>>                Else Begin
39513>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
39514>>>>>>>                End
39514>>>>>>>>
39514>>>>>>>            End
39514>>>>>>>>
39514>>>>>>>        Loop
39515>>>>>>>>
39515>>>>>>>        Send Destroy of hoCLIHandler  
39516>>>>>>>        Send Destroy of hoMSSQLHandler  
39517>>>>>>>        If (bShowErrorDialog = True) Begin
39519>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
39520>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
39522>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
39523>>>>>>>                If (bExitProgram = True) Begin
39525>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
39526>>>>>>>                End
39526>>>>>>>>
39526>>>>>>>                Send Stop_Box sRetval  
39527>>>>>>>                If (bExitProgram = True) Begin
39529>>>>>>>                    Send Exit_Application
39530>>>>>>>                End
39530>>>>>>>>
39530>>>>>>>            End
39530>>>>>>>>
39530>>>>>>>        End
39530>>>>>>>>
39530>>>>>>>        
39530>>>>>>>        Function_Return sRetval
39531>>>>>>>    End_Function  
39532>>>>>>>    
39532>>>>>>>    // Returns True if first "." separated string is greater than the second.
39532>>>>>>>    // It checks from left to right, one part of the string at a time.
39532>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
39532>>>>>>>    Function IsFirstStringGreaterThanSecond String sVersion String sSQLVersion Returns Boolean
39534>>>>>>>        String[] asVersion asSQLVersion          
39536>>>>>>>        Integer iSize iCount iVersion iSQLVersion
39536>>>>>>>        
39536>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
39537>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
39538>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
39539>>>>>>>        Decrement iSize
39540>>>>>>>        for iCount from 0 to iSize
39546>>>>>>>>
39546>>>>>>>            Move asVersion[iCount]    to iVersion
39547>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
39548>>>>>>>            CompilerWarnings Off
39548>>>>>>>            If (iVersion > iSQLVersion) Break
39551>>>>>>>            CompilerWarnings On
39551>>>>>>>        Loop
39552>>>>>>>>
39552>>>>>>>        
39552>>>>>>>        Function_Return (iVersion > iSQLVersion)
39553>>>>>>>    End_Function
39554>>>>>>>
39554>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
39554>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
39554>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
39554>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
39556>>>>>>>        Integer iMode
39556>>>>>>>        Boolean bOpened
39556>>>>>>>        String sTableName
39556>>>>>>>
39556>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
39557>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
39560>>>>>>>        If (bOpened) Begin
39562>>>>>>>            If (IsDebuggerPresent()) Begin
39564>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39567>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
39569>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39570>>>>>>>                    Function_Return True
39571>>>>>>>                End
39571>>>>>>>>
39571>>>>>>>            End
39571>>>>>>>>
39571>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
39574>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
39576>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39577>>>>>>>                Function_Return True
39578>>>>>>>            End
39578>>>>>>>>
39578>>>>>>>            Close hTable
39579>>>>>>>        End
39579>>>>>>>>
39579>>>>>>>        Else Begin
39580>>>>>>>            Open hTable
39582>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
39585>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
39587>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39590>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
39592>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39593>>>>>>>                    Function_Return True
39594>>>>>>>                End
39594>>>>>>>>
39594>>>>>>>            End
39594>>>>>>>>
39594>>>>>>>
39594>>>>>>>        End
39594>>>>>>>>
39594>>>>>>>
39594>>>>>>>        Close hTable
39595>>>>>>>        Open hTable Mode DF_EXCLUSIVE
39597>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
39600>>>>>>>
39600>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
39601>>>>>>>        Function_Return bOpened
39602>>>>>>>    End_Function
39603>>>>>>>
39603>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
39605>>>>>>>        String sConnectionID sConnectionString sDriverID
39605>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
39605>>>>>>>        Handle hoCLI hoDriver
39605>>>>>>>        Integer iRetval
39605>>>>>>>        tSQLConnection SQLConnection
39605>>>>>>>        tSQLConnection SQLConnection
39605>>>>>>>
39605>>>>>>>        Get psDriverID to sDriverID
39606>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
39607>>>>>>>        If (bSQLDriver = False) Begin
39609>>>>>>>            Function_Return True
39610>>>>>>>        End
39610>>>>>>>>
39610>>>>>>>
39610>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
39611>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
39612>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
39613>>>>>>>        Get IsMertechDriver sDriverID to bMertech
39614>>>>>>>        If (bMertech = True) Begin
39616>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
39617>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
39618>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
39619>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
39620>>>>>>>            Send Destroy of hoDriver
39621>>>>>>>            Function_Return bOK
39622>>>>>>>        End
39622>>>>>>>>
39622>>>>>>>
39622>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
39623>>>>>>>
39623>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
39624>>>>>>>        If (bExists = False) Begin
39626>>>>>>>            // We always start by deleting the current connection - if any - because the
39626>>>>>>>            // login details my have changed.
39626>>>>>>>            Get phoCLIHandler to hoCLI
39627>>>>>>>            Set psDriverID    of hoCLI to sDriverID
39628>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
39629>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
39630>>>>>>>            If (bOk = False) Begin
39632>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
39633>>>>>>>>
39633>>>>>>>                Function_Return False
39634>>>>>>>            End
39634>>>>>>>>
39634>>>>>>>            Move bOK to bExists
39635>>>>>>>        End
39635>>>>>>>>
39635>>>>>>>
39635>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
39636>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
39637>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
39638>>>>>>>        Send Destroy of hoDriver
39639>>>>>>>
39639>>>>>>>        Function_Return (bExists = True)
39640>>>>>>>    End_Function
39641>>>>>>>
39641>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
39641>>>>>>>    // Returns: False if nobody else is running
39641>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
39641>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
39641>>>>>>>    //      tables are not locked as DataFlex tables are.
39641>>>>>>>    Function IsDatabaseInUse Returns Boolean
39643>>>>>>>        Handle  hTable
39643>>>>>>>        String  sRootName
39643>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
39643>>>>>>>        Integer iCount iTables
39643>>>>>>>
39643>>>>>>>        Move 0 to iTables
39644>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
39645>>>>>>>        Get AutoConnectionIDLogin to bOK
39646>>>>>>>        Get UtilFilelistNoOfTables to iTables
39647>>>>>>>        Set piPosition   of ghoProgressBar to 0
39648>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
39649>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
39650>>>>>>>        Move 0 to hTable
39651>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39654>>>>>>>        Move False to bErr
39655>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
39656>>>>>>>
39656>>>>>>>        Repeat
39656>>>>>>>>
39656>>>>>>>            Set piPosition of ghoProgressBar to iCount
39657>>>>>>>            Increment iCount
39658>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
39661>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
39662>>>>>>>
39662>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
39662>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
39663>>>>>>>            Move False to bOpen
39664>>>>>>>            Get UtilTableExists hTable to bExists
39665>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
39665>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
39667>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
39668>>>>>>>                Open hTable
39670>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
39673>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
39674>>>>>>>                If (bOpen = True) Begin
39676>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
39676>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
39677>>>>>>>                    If (bAlias = False) Begin
39679>>>>>>>                        Close hTable
39680>>>>>>>                        Get OpenTableExclusive hTable to bOpen
39681>>>>>>>                        If (bOpen = False) Begin
39683>>>>>>>                            Move True to bErr
39684>>>>>>>                        End
39684>>>>>>>>
39684>>>>>>>                    End
39684>>>>>>>>
39684>>>>>>>                End
39684>>>>>>>>
39684>>>>>>>                Close hTable
39685>>>>>>>            End
39685>>>>>>>>
39685>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39688>>>>>>>            If (bErr = True ) ;                Break
39691>>>>>>>        Until (not(hTable))
39693>>>>>>>
39693>>>>>>>        Set Action_Text of ghoStatusPanel to ""
39694>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
39695>>>>>>>        Move False to Err
39696>>>>>>>
39696>>>>>>>        Function_Return bErr
39697>>>>>>>    End_Function
39698>>>>>>>
39698>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
39698>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
39698>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
39698>>>>>>>    // NOTE: Only applicable for DAW drivers.
39698>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
39700>>>>>>>        String sID sConnString
39700>>>>>>>        Integer iDriver iNumConn iCount
39700>>>>>>>        Handle hoCLI
39700>>>>>>>        Boolean bOK
39700>>>>>>>
39700>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
39701>>>>>>>        If (bOK = False) Begin
39703>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
39704>>>>>>>>
39704>>>>>>>            Function_Return False
39705>>>>>>>        End
39705>>>>>>>>
39705>>>>>>>
39705>>>>>>>        Move False to bOK
39706>>>>>>>        Get phoCLIHandler to hoCLI
39707>>>>>>>        If (hoCLI <> 0) Begin
39709>>>>>>>            Set psDriverID of hoCLI to sDriverID
39710>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
39711>>>>>>>
39711>>>>>>>            // If driver not loaded; load it.
39711>>>>>>>            If (iDriver = 0) Begin
39713>>>>>>>                Load_Driver sDriverID
39714>>>>>>>                Get DriverIndex sDriverID to iDriver
39715>>>>>>>            End
39715>>>>>>>>
39715>>>>>>>            If (iDriver <> 0) Begin
39717>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
39720>>>>>>>                Decrement iNumConn
39721>>>>>>>                for iCount from 0 to iNumConn
39727>>>>>>>>
39727>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
39730>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
39733>>>>>>>                    If (sID = sConnectionID) Begin
39735>>>>>>>                        Move True to bOK
39736>>>>>>>                    End
39736>>>>>>>>
39736>>>>>>>                Loop
39737>>>>>>>>
39737>>>>>>>            End
39737>>>>>>>>
39737>>>>>>>        End
39737>>>>>>>>
39737>>>>>>>
39737>>>>>>>        Function_Return bOK
39738>>>>>>>    End_Function
39739>>>>>>>
39739>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
39741>>>>>>>        Boolean bOK
39741>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
39742>>>>>>>        Function_Return bOK
39743>>>>>>>    End_Function
39744>>>>>>>
39744>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
39746>>>>>>>        Boolean bOK
39746>>>>>>>        Move False to bOK
39747>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
39748>>>>>>>        Function_Return bOK
39749>>>>>>>    End_Function
39750>>>>>>>
39750>>>>>>>    Function IsMSSQLDriver Returns Boolean
39752>>>>>>>        Integer iDriverIndex
39752>>>>>>>
39752>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
39753>>>>>>>
39753>>>>>>>        Function_Return (iDriverIndex <> 0)
39754>>>>>>>    End_Function
39755>>>>>>>
39755>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
39755>>>>>>>    // attempt to load the driver.
39755>>>>>>>    // Returns true if the passed driver is SQL based.
39755>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
39757>>>>>>>        Boolean bOK
39757>>>>>>>
39757>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
39758>>>>>>>
39758>>>>>>>        If (bOK = False) Begin
39760>>>>>>>            Get IsMertechDriver sDriverID to bOK
39761>>>>>>>        End
39761>>>>>>>>
39761>>>>>>>
39761>>>>>>>        Function_Return bOK
39762>>>>>>>    End_Function
39763>>>>>>>
39763>>>>>>>    // *** Error Handler ***
39763>>>>>>>    //
39763>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
39763>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
39763>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
39765>>>>>>>        Integer iSize iErrorMode
39765>>>>>>>        tSqlErrorArray aSqlErrorArray
39765>>>>>>>        tSqlErrorArray aSqlErrorArray
39765>>>>>>>
39765>>>>>>>        If (pbProcessingError(Self)) Begin
39767>>>>>>>            Procedure_Return
39768>>>>>>>        End
39768>>>>>>>>
39768>>>>>>>
39768>>>>>>>        Get Error_Report_Mode to iErrorMode
39769>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
39771>>>>>>>            Procedure_Return
39772>>>>>>>        End
39772>>>>>>>>
39772>>>>>>>
39772>>>>>>>        Set pbProcessingError to True
39773>>>>>>>        Set pbSqlError to True
39774>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
39775>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
39776>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
39777>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
39778>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
39779>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
39780>>>>>>>        Set pbProcessingError to False
39781>>>>>>>    End_Procedure
39782>>>>>>>
39782>>>>>>>    // *** Miscellanous Helper Functions ***
39782>>>>>>>    //
39782>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
39782>>>>>>>    // returns the table name only; stripped of any path or filename extension.
39782>>>>>>>    Function _TableNameOnly String sName Returns String
39784>>>>>>>        String sPath sExt
39784>>>>>>>
39784>>>>>>>        Get ParseFolderName sName to sPath
39785>>>>>>>        If (sPath <> "") Begin
39787>>>>>>>            Move (Replace(sPath, sName, "")) to sName
39788>>>>>>>        End
39788>>>>>>>>
39788>>>>>>>        Get ParseFileExtension sName to sExt
39789>>>>>>>        If (sExt <> "") Begin
39791>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
39792>>>>>>>        End
39792>>>>>>>>
39792>>>>>>>
39792>>>>>>>        Function_Return sName
39793>>>>>>>    End_Function
39794>>>>>>>
39794>>>>>>>    // Removes any prefix to a table name.
39794>>>>>>>    // Example mssqldrv:mytable returns mytable
39794>>>>>>>    //         dbo.mytable returns mytable
39794>>>>>>>    Function _TableNoPrefix String sName Returns String
39796>>>>>>>        Integer iPos
39796>>>>>>>
39796>>>>>>>        Move (Pos(":", sName)) to iPos
39797>>>>>>>        If (iPos <> 0) Begin
39799>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
39800>>>>>>>        End
39800>>>>>>>>
39800>>>>>>>        Move (Pos(".", sName)) to iPos
39801>>>>>>>        If (iPos <> 0) Begin
39803>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
39804>>>>>>>        End
39804>>>>>>>>
39804>>>>>>>
39804>>>>>>>        Function_Return sName
39805>>>>>>>    End_Function
39806>>>>>>>
39806>>>>>>>    // Returns the first datapath found in the psDataPath property.
39806>>>>>>>    // The returned path always ends with a "\"
39806>>>>>>>    Function psDataPathFirstPart Returns String
39808>>>>>>>        String sDataPath
39808>>>>>>>        Integer iCount
39808>>>>>>>
39808>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
39809>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
39810>>>>>>>        If (iCount > 1) Begin
39812>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
39813>>>>>>>        End
39813>>>>>>>>
39813>>>>>>>        If (sDataPath <> "") Begin
39815>>>>>>>            Get vFolderFormat sDataPath to sDataPath
39816>>>>>>>        End
39816>>>>>>>>
39816>>>>>>>
39816>>>>>>>        Function_Return sDataPath
39817>>>>>>>    End_Function
39818>>>>>>>
39818>>>>>>>    Function psLogTextFileWithPath Returns String
39820>>>>>>>        String sFileName
39820>>>>>>>        Handle hoLogFile
39820>>>>>>>        Get phoLogFile to hoLogFile
39821>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
39822>>>>>>>        Function_Return sFileName
39823>>>>>>>    End_Function
39824>>>>>>>
39824>>>>>>>    // *** Property Messages ***
39824>>>>>>>    //
39824>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
39824>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
39824>>>>>>>    //
39824>>>>>>>
39824>>>>>>>    Function pSQLConnection Returns tSQLConnection
39826>>>>>>>        tSQLConnection SQLConnection
39826>>>>>>>        tSQLConnection SQLConnection
39826>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39828>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
39828>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39829>>>>>>>>
39829>>>>>>>            Function_Return
39830>>>>>>>        End
39830>>>>>>>>
39830>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
39831>>>>>>>        Function_Return SQLConnection
39832>>>>>>>    End_Function
39833>>>>>>>
39833>>>>>>>    // * Dummy function for the Studio's Code Explorer *
39833>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
39835>>>>>>>        Function_Return False
39836>>>>>>>    End_Function
39837>>>>>>>
39837>>>>>>>    Procedure Set psServer String sValue
39839>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39841>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
39841>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39842>>>>>>>>
39842>>>>>>>            Procedure_Return
39843>>>>>>>        End
39843>>>>>>>>
39843>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
39844>>>>>>>    End_Procedure
39845>>>>>>>
39845>>>>>>>    Function psServer Returns String
39847>>>>>>>        String sValue
39847>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39849>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39850>>>>>>>>
39850>>>>>>>            Function_Return
39851>>>>>>>        End
39851>>>>>>>>
39851>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
39852>>>>>>>        Function_Return sValue
39853>>>>>>>    End_Function
39854>>>>>>>
39854>>>>>>>    Procedure Set psDatabase String sValue
39856>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39858>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39859>>>>>>>>
39859>>>>>>>            Procedure_Return
39860>>>>>>>        End
39860>>>>>>>>
39860>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
39861>>>>>>>    End_Procedure
39862>>>>>>>
39862>>>>>>>    Function psDatabase Returns String
39864>>>>>>>        String sValue
39864>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39866>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39867>>>>>>>>
39867>>>>>>>            Function_Return
39868>>>>>>>        End
39868>>>>>>>>
39868>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
39869>>>>>>>        Function_Return sValue
39870>>>>>>>    End_Function
39871>>>>>>>
39871>>>>>>>    Procedure Set psUserID String sValue
39873>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39875>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39876>>>>>>>>
39876>>>>>>>            Procedure_Return
39877>>>>>>>        End
39877>>>>>>>>
39877>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
39878>>>>>>>    End_Procedure
39879>>>>>>>
39879>>>>>>>    Function psUserID Returns String
39881>>>>>>>        String sValue
39881>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39883>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39884>>>>>>>>
39884>>>>>>>            Function_Return
39885>>>>>>>        End
39885>>>>>>>>
39885>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
39886>>>>>>>        Function_Return sValue
39887>>>>>>>    End_Function
39888>>>>>>>
39888>>>>>>>    Procedure Set psPassword String sValue
39890>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39892>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39893>>>>>>>>
39893>>>>>>>            Procedure_Return
39894>>>>>>>        End
39894>>>>>>>>
39894>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
39895>>>>>>>    End_Procedure
39896>>>>>>>
39896>>>>>>>    Function psPassword Returns String
39898>>>>>>>        String sValue
39898>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39900>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39901>>>>>>>>
39901>>>>>>>            Function_Return
39902>>>>>>>        End
39902>>>>>>>>
39902>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
39903>>>>>>>        Function_Return sValue
39904>>>>>>>    End_Function
39905>>>>>>>
39905>>>>>>>    Procedure Set pbTrusted Boolean bValue
39907>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39909>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39910>>>>>>>>
39910>>>>>>>            Procedure_Return
39911>>>>>>>        End
39911>>>>>>>>
39911>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
39912>>>>>>>    End_Procedure
39913>>>>>>>
39913>>>>>>>    Function pbTrusted Returns Boolean
39915>>>>>>>        Boolean bValue
39915>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39917>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39918>>>>>>>>
39918>>>>>>>            Function_Return
39919>>>>>>>        End
39919>>>>>>>>
39919>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
39920>>>>>>>        Function_Return bValue
39921>>>>>>>    End_Function
39922>>>>>>>
39922>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
39924>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39926>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39927>>>>>>>>
39927>>>>>>>            Procedure_Return
39928>>>>>>>        End
39928>>>>>>>>
39928>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
39929>>>>>>>    End_Procedure
39930>>>>>>>
39930>>>>>>>    Function pbSilentLogin Returns Boolean
39932>>>>>>>        Boolean bValue
39932>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39934>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39935>>>>>>>>
39935>>>>>>>            Function_Return
39936>>>>>>>        End
39936>>>>>>>>
39936>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
39937>>>>>>>        Function_Return bValue
39938>>>>>>>    End_Function
39939>>>>>>>
39939>>>>>>>    Procedure Set psConnectionID String sValue
39941>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39943>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39944>>>>>>>>
39944>>>>>>>            Procedure_Return
39945>>>>>>>        End
39945>>>>>>>>
39945>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
39946>>>>>>>    End_Procedure
39947>>>>>>>
39947>>>>>>>    Function psConnectionID Returns String
39949>>>>>>>        String sValue
39949>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39951>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39952>>>>>>>>
39952>>>>>>>            Function_Return
39953>>>>>>>        End
39953>>>>>>>>
39953>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
39954>>>>>>>        Function_Return sValue
39955>>>>>>>    End_Function
39956>>>>>>>
39956>>>>>>>    Procedure Set psConnectionString String sValue
39958>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39960>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39961>>>>>>>>
39961>>>>>>>            Procedure_Return
39962>>>>>>>        End
39962>>>>>>>>
39962>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
39963>>>>>>>    End_Procedure
39964>>>>>>>
39964>>>>>>>    Function psConnectionString Returns String
39966>>>>>>>        String sValue
39966>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39968>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39969>>>>>>>>
39969>>>>>>>            Function_Return
39970>>>>>>>        End
39970>>>>>>>>
39970>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
39971>>>>>>>        Function_Return sValue
39972>>>>>>>    End_Function
39973>>>>>>>
39973>>>>>>>    // The normal connection string looks something like this;
39973>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
39973>>>>>>>    // ...and the full connection string looks like this;
39973>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
39973>>>>>>>    Function psFullConnectionString Returns String
39975>>>>>>>        String sConnectionID sConnectionString
39975>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39977>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39978>>>>>>>>
39978>>>>>>>            Function_Return
39979>>>>>>>        End
39979>>>>>>>>
39979>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
39980>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
39981>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
39982>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
39983>>>>>>>    End_Function
39984>>>>>>>
39984>>>>>>>    Function piConnectionOptions Returns Integer
39986>>>>>>>        Integer iValue
39986>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39988>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39989>>>>>>>>
39989>>>>>>>            Function_Return
39990>>>>>>>        End
39990>>>>>>>>
39990>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
39991>>>>>>>        Function_Return iValue
39992>>>>>>>    End_Function
39993>>>>>>>
39993>>>>>>>    Procedure Set psSchema String sValue
39995>>>>>>>        tSQLConnection SQLConnection
39995>>>>>>>        tSQLConnection SQLConnection
39995>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
39997>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
39998>>>>>>>>
39998>>>>>>>            Procedure_Return
39999>>>>>>>        End
39999>>>>>>>>
39999>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
40000>>>>>>>    End_Procedure
40001>>>>>>>
40001>>>>>>>    Function psSchema Returns String
40003>>>>>>>        String sRetval
40003>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40005>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40006>>>>>>>>
40006>>>>>>>            Function_Return
40007>>>>>>>        End
40007>>>>>>>>
40007>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
40008>>>>>>>        Function_Return sRetval
40009>>>>>>>    End_Function
40010>>>>>>>
40010>>>>>>>    Procedure Set psBaseTableSpace String sValue
40012>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40014>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40015>>>>>>>>
40015>>>>>>>            Procedure_Return
40016>>>>>>>        End
40016>>>>>>>>
40016>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
40017>>>>>>>    End_Procedure
40018>>>>>>>
40018>>>>>>>    Function psBaseTableSpace Returns String
40020>>>>>>>        String sRetval
40020>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40022>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40023>>>>>>>>
40023>>>>>>>            Function_Return
40024>>>>>>>        End
40024>>>>>>>>
40024>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
40025>>>>>>>        Function_Return sRetval
40026>>>>>>>    End_Function
40027>>>>>>>
40027>>>>>>>    Procedure Set psLongTableSpace String sValue
40029>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40031>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40032>>>>>>>>
40032>>>>>>>            Procedure_Return
40033>>>>>>>        End
40033>>>>>>>>
40033>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
40034>>>>>>>    End_Procedure
40035>>>>>>>
40035>>>>>>>    Function psLongTableSpace Returns String
40037>>>>>>>        String sRetval
40037>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40039>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40040>>>>>>>>
40040>>>>>>>            Function_Return
40041>>>>>>>        End
40041>>>>>>>>
40041>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
40042>>>>>>>        Function_Return sRetval
40043>>>>>>>    End_Function
40044>>>>>>>
40044>>>>>>>    Procedure Set psIndexTableSpace String sValue
40046>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40048>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40049>>>>>>>>
40049>>>>>>>            Procedure_Return
40050>>>>>>>        End
40050>>>>>>>>
40050>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
40051>>>>>>>    End_Procedure
40052>>>>>>>
40052>>>>>>>    Function psIndexTableSpace Returns String
40054>>>>>>>        String sRetval
40054>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40056>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40057>>>>>>>>
40057>>>>>>>            Function_Return
40058>>>>>>>        End
40058>>>>>>>>
40058>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
40059>>>>>>>        Function_Return sRetval
40060>>>>>>>    End_Function
40061>>>>>>>
40061>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
40063>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40065>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40066>>>>>>>>
40066>>>>>>>            Procedure_Return
40067>>>>>>>        End
40067>>>>>>>>
40067>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
40068>>>>>>>    End_Procedure
40069>>>>>>>
40069>>>>>>>    Function pbUseConnectionID Returns Boolean
40071>>>>>>>        Boolean bState
40071>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40073>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40074>>>>>>>>
40074>>>>>>>            Function_Return
40075>>>>>>>        End
40075>>>>>>>>
40075>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
40076>>>>>>>        Function_Return bState
40077>>>>>>>    End_Function
40078>>>>>>>
40078>>>>>>>    Procedure Set pbToANSI Boolean bState
40080>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40082>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40083>>>>>>>>
40083>>>>>>>            Procedure_Return
40084>>>>>>>        End
40084>>>>>>>>
40084>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
40085>>>>>>>    End_Procedure
40086>>>>>>>
40086>>>>>>>    Function pbToANSI Returns Boolean
40088>>>>>>>        Boolean bState
40088>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40090>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40091>>>>>>>>
40091>>>>>>>            Function_Return
40092>>>>>>>        End
40092>>>>>>>>
40092>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
40093>>>>>>>        Function_Return bState
40094>>>>>>>    End_Function
40095>>>>>>>
40095>>>>>>>    Procedure Set pbRecnum Boolean bState
40097>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40099>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40100>>>>>>>>
40100>>>>>>>            Procedure_Return
40101>>>>>>>        End
40101>>>>>>>>
40101>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
40102>>>>>>>    End_Procedure
40103>>>>>>>
40103>>>>>>>    Function pbRecnum Returns Boolean
40105>>>>>>>        Boolean bState
40105>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40107>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40108>>>>>>>>
40108>>>>>>>            Function_Return
40109>>>>>>>        End
40109>>>>>>>>
40109>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
40110>>>>>>>        Function_Return bState
40111>>>>>>>    End_Function
40112>>>>>>>
40112>>>>>>>    Procedure Set pbCopyData Boolean bState
40114>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40116>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40117>>>>>>>>
40117>>>>>>>            Procedure_Return
40118>>>>>>>        End
40118>>>>>>>>
40118>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
40119>>>>>>>    End_Procedure
40120>>>>>>>
40120>>>>>>>    Function pbCopyData Returns Boolean
40122>>>>>>>        Boolean bState
40122>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40124>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40125>>>>>>>>
40125>>>>>>>            Function_Return
40126>>>>>>>        End
40126>>>>>>>>
40126>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
40127>>>>>>>        Function_Return bState
40128>>>>>>>    End_Function
40129>>>>>>>
40129>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
40131>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40133>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40134>>>>>>>>
40134>>>>>>>            Procedure_Return
40135>>>>>>>        End
40135>>>>>>>>
40135>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40136>>>>>>>    End_Procedure
40137>>>>>>>
40137>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
40139>>>>>>>        Boolean bState
40139>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40141>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40142>>>>>>>>
40142>>>>>>>            Function_Return
40143>>>>>>>        End
40143>>>>>>>>
40143>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40144>>>>>>>        Function_Return bState
40145>>>>>>>    End_Function
40146>>>>>>>
40146>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
40148>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40150>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40151>>>>>>>>
40151>>>>>>>            Procedure_Return
40152>>>>>>>        End
40152>>>>>>>>
40152>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40153>>>>>>>    End_Procedure
40154>>>>>>>
40154>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
40156>>>>>>>        Boolean bState
40156>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40158>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40159>>>>>>>>
40159>>>>>>>            Function_Return
40160>>>>>>>        End
40160>>>>>>>>
40160>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40161>>>>>>>        Function_Return bState
40162>>>>>>>    End_Function
40163>>>>>>>
40163>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
40165>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40167>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40168>>>>>>>>
40168>>>>>>>            Procedure_Return
40169>>>>>>>        End
40169>>>>>>>>
40169>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40170>>>>>>>    End_Procedure
40171>>>>>>>
40171>>>>>>>    Function pbCompareIndexAscending Returns Boolean
40173>>>>>>>        Boolean bState
40173>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40175>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40176>>>>>>>>
40176>>>>>>>            Function_Return
40177>>>>>>>        End
40177>>>>>>>>
40177>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40178>>>>>>>        Function_Return bState
40179>>>>>>>    End_Function
40180>>>>>>>
40180>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
40182>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40184>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40185>>>>>>>>
40185>>>>>>>            Procedure_Return
40186>>>>>>>        End
40186>>>>>>>>
40186>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
40187>>>>>>>    End_Procedure
40188>>>>>>>
40188>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
40190>>>>>>>        Boolean bState
40190>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40192>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
40193>>>>>>>>
40193>>>>>>>            Function_Return
40194>>>>>>>        End
40194>>>>>>>>
40194>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
40195>>>>>>>        Function_Return bState
40196>>>>>>>    End_Function
40197>>>>>>>
40197>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
40199>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40201>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40202>>>>>>>>
40202>>>>>>>            Procedure_Return
40203>>>>>>>        End
40203>>>>>>>>
40203>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
40204>>>>>>>    End_Procedure
40205>>>>>>>
40205>>>>>>>    Function psDriverDefaultValueASCII Returns String
40207>>>>>>>        String sRetval
40207>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40209>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40210>>>>>>>>
40210>>>>>>>            Function_Return
40211>>>>>>>        End
40211>>>>>>>>
40211>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
40212>>>>>>>        Function_Return sRetval
40213>>>>>>>    End_Function
40214>>>>>>>
40214>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
40216>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40218>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40219>>>>>>>>
40219>>>>>>>            Procedure_Return
40220>>>>>>>        End
40220>>>>>>>>
40220>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
40221>>>>>>>    End_Procedure
40222>>>>>>>
40222>>>>>>>    Function psDriverDefaultValueBinary Returns String
40224>>>>>>>        String sRetval
40224>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40226>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40227>>>>>>>>
40227>>>>>>>            Function_Return
40228>>>>>>>        End
40228>>>>>>>>
40228>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
40229>>>>>>>        Function_Return sRetval
40230>>>>>>>    End_Function
40231>>>>>>>
40231>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
40233>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40235>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40236>>>>>>>>
40236>>>>>>>            Procedure_Return
40237>>>>>>>        End
40237>>>>>>>>
40237>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
40238>>>>>>>    End_Procedure
40239>>>>>>>
40239>>>>>>>    Function psDriverDefaultValueDate Returns String
40241>>>>>>>        String sRetval
40241>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40243>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40244>>>>>>>>
40244>>>>>>>            Function_Return
40245>>>>>>>        End
40245>>>>>>>>
40245>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
40246>>>>>>>        Function_Return sRetval
40247>>>>>>>    End_Function
40248>>>>>>>
40248>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
40250>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40252>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40253>>>>>>>>
40253>>>>>>>            Procedure_Return
40254>>>>>>>        End
40254>>>>>>>>
40254>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
40255>>>>>>>    End_Procedure
40256>>>>>>>
40256>>>>>>>    Function psDriverDefaultValueDateTime Returns String
40258>>>>>>>        String sRetval
40258>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40260>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40261>>>>>>>>
40261>>>>>>>            Function_Return
40262>>>>>>>        End
40262>>>>>>>>
40262>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
40263>>>>>>>        Function_Return sRetval
40264>>>>>>>    End_Function
40265>>>>>>>
40265>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
40267>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40269>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40270>>>>>>>>
40270>>>>>>>            Procedure_Return
40271>>>>>>>        End
40271>>>>>>>>
40271>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
40272>>>>>>>    End_Procedure
40273>>>>>>>
40273>>>>>>>    Function psDriverDefaultValueNumeric Returns String
40275>>>>>>>        String sRetval
40275>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40277>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40278>>>>>>>>
40278>>>>>>>            Function_Return
40279>>>>>>>        End
40279>>>>>>>>
40279>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
40280>>>>>>>        Function_Return sRetval
40281>>>>>>>    End_Function
40282>>>>>>>
40282>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
40284>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40286>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40287>>>>>>>>
40287>>>>>>>            Procedure_Return
40288>>>>>>>        End
40288>>>>>>>>
40288>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
40289>>>>>>>    End_Procedure
40290>>>>>>>
40290>>>>>>>    Function psDriverDefaultValueText Returns String
40292>>>>>>>        String sRetval
40292>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40294>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40295>>>>>>>>
40295>>>>>>>            Function_Return
40296>>>>>>>        End
40296>>>>>>>>
40296>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
40297>>>>>>>        Function_Return sRetval
40298>>>>>>>    End_Function
40299>>>>>>>
40299>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
40301>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40303>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40304>>>>>>>>
40304>>>>>>>            Procedure_Return
40305>>>>>>>        End
40305>>>>>>>>
40305>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
40306>>>>>>>    End_Procedure
40307>>>>>>>
40307>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
40309>>>>>>>        Boolean bState
40309>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40311>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40312>>>>>>>>
40312>>>>>>>            Function_Return
40313>>>>>>>        End
40313>>>>>>>>
40313>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
40314>>>>>>>        Function_Return bState
40315>>>>>>>    End_Function
40316>>>>>>>
40316>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
40318>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40320>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40321>>>>>>>>
40321>>>>>>>            Procedure_Return
40322>>>>>>>        End
40322>>>>>>>>
40322>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
40323>>>>>>>    End_Procedure
40324>>>>>>>
40324>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
40326>>>>>>>        Boolean bState
40326>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40328>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40329>>>>>>>>
40329>>>>>>>            Function_Return
40330>>>>>>>        End
40330>>>>>>>>
40330>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
40331>>>>>>>        Function_Return bState
40332>>>>>>>    End_Function
40333>>>>>>>
40333>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
40335>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40337>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40338>>>>>>>>
40338>>>>>>>            Procedure_Return
40339>>>>>>>        End
40339>>>>>>>>
40339>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
40340>>>>>>>    End_Procedure
40341>>>>>>>
40341>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
40343>>>>>>>        Boolean bState
40343>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40345>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40346>>>>>>>>
40346>>>>>>>            Function_Return
40347>>>>>>>        End
40347>>>>>>>>
40347>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
40348>>>>>>>        Function_Return bState
40349>>>>>>>    End_Function
40350>>>>>>>
40350>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
40352>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40354>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40355>>>>>>>>
40355>>>>>>>            Procedure_Return
40356>>>>>>>        End
40356>>>>>>>>
40356>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
40357>>>>>>>    End_Procedure
40358>>>>>>>
40358>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
40360>>>>>>>        Boolean bState
40360>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40362>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40363>>>>>>>>
40363>>>>>>>            Function_Return
40364>>>>>>>        End
40364>>>>>>>>
40364>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
40365>>>>>>>        Function_Return bState
40366>>>>>>>    End_Function
40367>>>>>>>
40367>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
40369>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40371>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40372>>>>>>>>
40372>>>>>>>            Procedure_Return
40373>>>>>>>        End
40373>>>>>>>>
40373>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
40374>>>>>>>    End_Procedure
40375>>>>>>>
40375>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
40377>>>>>>>        Boolean bState
40377>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40379>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40380>>>>>>>>
40380>>>>>>>            Function_Return
40381>>>>>>>        End
40381>>>>>>>>
40381>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
40382>>>>>>>        Function_Return bState
40383>>>>>>>    End_Function
40384>>>>>>>
40384>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
40386>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40388>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40389>>>>>>>>
40389>>>>>>>            Procedure_Return
40390>>>>>>>        End
40390>>>>>>>>
40390>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
40391>>>>>>>    End_Procedure
40392>>>>>>>
40392>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
40394>>>>>>>        Boolean bState
40394>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
40396>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
40397>>>>>>>>
40397>>>>>>>            Function_Return
40398>>>>>>>        End
40398>>>>>>>>
40398>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
40399>>>>>>>        Function_Return bState
40400>>>>>>>    End_Function
40401>>>>>>>
40401>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
40401>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
40401>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
40401>>>>>>>    //       for a connection string has the wrong format for that driver.
40401>>>>>>>    Procedure Set psDriverID String sValue
40403>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40404>>>>>>>        Delegate Set psDriverID to sValue
40406>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40407>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
40408>>>>>>>    End_Procedure
40409>>>>>>>
40409>>>>>>>    Function psDriverID Returns String
40411>>>>>>>        String sDriverID
40411>>>>>>>
40411>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40412>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
40412>>>>>>>        Delegate Get psDriverID to sDriverID
40414>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40415>>>>>>>        Move False to Err
40416>>>>>>>
40416>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
40416>>>>>>>        // probably used as "utilites" from a special made program and
40416>>>>>>>        // the ghoSQLConnectionHandler must have been setup
40416>>>>>>>        If (sDriverID = "") Begin
40418>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
40419>>>>>>>        End
40419>>>>>>>>
40419>>>>>>>        Function_Return sDriverID
40420>>>>>>>    End_Function
40421>>>>>>>
40421>>>>>>>    Procedure Set piDbType Integer iValue
40423>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40424>>>>>>>        Delegate Set piDbType to iValue
40426>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40427>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
40428>>>>>>>    End_Procedure
40429>>>>>>>
40429>>>>>>>    Function piDbType Returns Integer
40431>>>>>>>        Integer iRetval
40431>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
40432>>>>>>>        Function_Return iRetval
40433>>>>>>>    End_Function
40434>>>>>>>
40434>>>>>>>    Function phoLogFile Returns Handle
40436>>>>>>>        Handle hoLogFile   
40436>>>>>>>        Boolean bErr
40436>>>>>>>        
40436>>>>>>>        Move Err to bErr
40437>>>>>>>        Move 0 to hoLogFile
40438>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
40439>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40440>>>>>>>        Delegate Get phoLogFile to hoLogFile
40442>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40443>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
40444>>>>>>>        Move bErr to Err
40445>>>>>>>        
40445>>>>>>>        Function_Return hoLogFile
40446>>>>>>>    End_Function
40447>>>>>>>
40447>>>>>>>    Function pnCurrentVersionUpdate Returns Number
40449>>>>>>>        Number nCurrentVersionUpdate
40449>>>>>>>
40449>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
40450>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
40452>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
40453>>>>>>>
40453>>>>>>>        Function_Return nCurrentVersionUpdate
40454>>>>>>>    End_Function
40455>>>>>>>
40455>>>>>>>    Procedure LogError String sText Boolean bError
40457>>>>>>>        Handle hoLogFile
40457>>>>>>>        Number nCurrentVersionUpdate
40457>>>>>>>
40457>>>>>>>        Get phoLogFile to hoLogFile
40458>>>>>>>        If (hoLogFile = 0) Begin
40460>>>>>>>            Procedure_Return
40461>>>>>>>        End
40461>>>>>>>>
40461>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
40462>>>>>>>
40462>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
40463>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
40464>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
40465>>>>>>>    End_Procedure
40466>>>>>>>
40466>>>>>>>    Function pbContinueOnError Returns Boolean
40468>>>>>>>        Boolean bContinueOnError
40468>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
40470>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
40471>>>>>>>        End
40471>>>>>>>>
40471>>>>>>>        Function_Return bContinueOnError
40472>>>>>>>    End_Function
40473>>>>>>>
40473>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
40473>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
40473>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
40473>>>>>>>    // Good read about which collation to select:
40473>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
40473>>>>>>>    Procedure Set psCollation String sCollation
40475>>>>>>>        Set private.psCollation to sCollation
40476>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
40478>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
40479>>>>>>>        End
40479>>>>>>>>
40479>>>>>>>    End_Procedure
40480>>>>>>>
40480>>>>>>>    Function psCollation Returns String
40482>>>>>>>        String sCollation
40482>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
40484>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
40485>>>>>>>        End   
40485>>>>>>>>
40485>>>>>>>        Else Begin
40486>>>>>>>            Get private.psCollation to sCollation
40487>>>>>>>        End
40487>>>>>>>>
40487>>>>>>>        Function_Return sCollation
40488>>>>>>>    End_Function
40489>>>>>>>
40489>>>>>>>
40489>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
40491>>>>>>>        Integer iMax iPos
40491>>>>>>>        String sName
40491>>>>>>>
40491>>>>>>>        Move (Lowercase(sField)) to sField
40492>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
40495>>>>>>>        for iPos from 0 to iMax
40501>>>>>>>>
40501>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
40504>>>>>>>            Move (Lowercase(sName)) to sName
40505>>>>>>>            If (sName = sField) Begin
40507>>>>>>>                Function_Return iPos
40508>>>>>>>            End
40508>>>>>>>>
40508>>>>>>>        Loop
40509>>>>>>>>
40509>>>>>>>        Function_Return -1
40510>>>>>>>    End_Function
40511>>>>>>>
40511>>>>>>>
40511>>>>>>>    // * Dummy function for the Studio's Code Explorer *
40511>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
40513>>>>>>>        Function_Return False
40514>>>>>>>    End_Function
40515>>>>>>>
40515>>>>>>>    // *** Helper functions with compiled sql script code ***
40515>>>>>>>    //
40515>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
40515>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
40515>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
40515>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
40515>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
40515>>>>>>>    //   ALTER TABLE MyTable
40515>>>>>>>    //       REBUILD
40515>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
40517>>>>>>>        Boolean bOK
40517>>>>>>>
40517>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
40519>>>>>>>            Function_Return False
40520>>>>>>>        End
40520>>>>>>>>
40520>>>>>>>
40520>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
40520>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
40521>>>>>>>
40521>>>>>>>        Function_Return (bOK = True)
40522>>>>>>>    End_Function
40523>>>>>>>
40523>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
40523>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
40523>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
40523>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
40523>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
40523>>>>>>>    //   ALTER TABLE MyTable
40523>>>>>>>    //       REBUILD
40523>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
40525>>>>>>>        tSQLScriptArray SQLScriptArray
40525>>>>>>>        tSQLScriptArray SQLScriptArray
40525>>>>>>>        String sDriverID
40525>>>>>>>        Boolean bOK
40525>>>>>>>        Integer iSize iCount
40525>>>>>>>
40525>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
40527>>>>>>>            Function_Return False
40528>>>>>>>        End
40528>>>>>>>>
40528>>>>>>>
40528>>>>>>>        Get psDriverID to sDriverID
40529>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
40530>>>>>>>        If (SQLScriptArray.bError = True) Begin
40532>>>>>>>            Function_Return False
40533>>>>>>>        End
40533>>>>>>>>
40533>>>>>>>
40533>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
40534>>>>>>>        Decrement iSize
40535>>>>>>>
40535>>>>>>>        for iCount from 0 to iSize
40541>>>>>>>>
40541>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
40543>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
40544>>>>>>>            End
40544>>>>>>>>
40544>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
40546>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
40547>>>>>>>            End
40547>>>>>>>>
40547>>>>>>>        Loop
40548>>>>>>>>
40548>>>>>>>
40548>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
40549>>>>>>>
40549>>>>>>>        Function_Return (bOK = True)
40550>>>>>>>    End_Function
40551>>>>>>>
40551>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
40553>>>>>>>        tSQLScriptArray SQLScriptArray
40553>>>>>>>        tSQLScriptArray SQLScriptArray
40553>>>>>>>        String sDriverID sCollation
40553>>>>>>>        Boolean bOK
40553>>>>>>>        Integer iSize iCount
40553>>>>>>>
40553>>>>>>>        If (Trim(sDatabaseName) = "") Begin
40555>>>>>>>            Function_Return False
40556>>>>>>>        End
40556>>>>>>>>
40556>>>>>>>
40556>>>>>>>        Get psDriverID  to sDriverID
40557>>>>>>>        Get psCollation to sCollation
40558>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
40559>>>>>>>        If (SQLScriptArray.bError = True) Begin
40561>>>>>>>            Function_Return False
40562>>>>>>>        End
40562>>>>>>>>
40562>>>>>>>
40562>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
40563>>>>>>>        Decrement iSize
40564>>>>>>>
40564>>>>>>>        for iCount from 0 to iSize
40570>>>>>>>>
40570>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
40572>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
40573>>>>>>>            End
40573>>>>>>>>
40573>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
40575>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
40576>>>>>>>            End
40576>>>>>>>>
40576>>>>>>>        Loop
40577>>>>>>>>
40577>>>>>>>
40577>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
40578>>>>>>>
40578>>>>>>>        Function_Return (bOK = True)
40579>>>>>>>    End_Function
40580>>>>>>>
40580>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
40582>>>>>>>        tSQLScriptArray SQLScriptArray
40582>>>>>>>        tSQLScriptArray SQLScriptArray
40582>>>>>>>        String sDriverID sCollation
40582>>>>>>>        Boolean bOK
40582>>>>>>>        Integer iSize iCount
40582>>>>>>>
40582>>>>>>>        If (Trim(sDatabaseName) = "") Begin
40584>>>>>>>            Function_Return False
40585>>>>>>>        End
40585>>>>>>>>
40585>>>>>>>
40585>>>>>>>        Get psDriverID  to sDriverID
40586>>>>>>>        Get psCollation to sCollation
40587>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
40588>>>>>>>        If (SQLScriptArray.bError = True) Begin
40590>>>>>>>            Function_Return False
40591>>>>>>>        End
40591>>>>>>>>
40591>>>>>>>
40591>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
40592>>>>>>>        Decrement iSize
40593>>>>>>>
40593>>>>>>>        for iCount from 0 to iSize
40599>>>>>>>>
40599>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
40601>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
40602>>>>>>>            End
40602>>>>>>>>
40602>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
40604>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
40605>>>>>>>            End
40605>>>>>>>>
40605>>>>>>>        Loop
40606>>>>>>>>
40606>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
40606>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
40607>>>>>>>
40607>>>>>>>        Function_Return (bOK = True)
40608>>>>>>>    End_Function
40609>>>>>>>
40609>>>>>>>    // *** Helper functions for Mertech Drivers ***
40609>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
40609>>>>>>>    // and commands that the Studio editor knows nothing about.
40609>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
40611>>>>>>>        Integer iRetval
40611>>>>>>>        String sPath
40611>>>>>>>
40611>>>>>>>        If (sPath = "" or sTableName = "") Begin
40613>>>>>>>            Function_Return True
40614>>>>>>>        End
40614>>>>>>>>
40614>>>>>>>
40614>>>>>>>        Get vFolderFormat sPath to sPath
40615>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
40616>>>>>>>        Function_Return (iRetval = 0)
40617>>>>>>>    End_Function
40618>>>>>>>
40618>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
40620>>>>>>>        Boolean bOpen bOK
40620>>>>>>>        Move False to Err
40621>>>>>>>        Function_Return (Err = False)
40622>>>>>>>    End_Function
40623>>>>>>>
40623>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
40625>>>>>>>        Integer iNumItems iCount
40625>>>>>>>        String[] sReturnArray
40626>>>>>>>        String sServer
40626>>>>>>>
40626>>>>>>>
40626>>>>>>>        Function_Return sReturnArray
40627>>>>>>>    End_Function
40628>>>>>>>
40628>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
40630>>>>>>>        String[] sReturnArray
40631>>>>>>>        String sServer
40631>>>>>>>
40631>>>>>>>
40631>>>>>>>        Function_Return sReturnArray
40632>>>>>>>    End_Function
40633>>>>>>>
40633>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
40635>>>>>>>        Handle hoSQLHandler hoSQLConnect
40635>>>>>>>
40635>>>>>>>        Move 0 to hoSQLConnect
40636>>>>>>>
40636>>>>>>>        Function_Return hoSQLConnect
40637>>>>>>>    End_Function
40638>>>>>>>
40638>>>>>>>    // Returns the handle of the Mertech SQL handler.
40638>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
40638>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
40638>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
40640>>>>>>>        Handle hoSQLHandler
40640>>>>>>>        String sDriverID sServer sDatabase
40640>>>>>>>
40640>>>>>>>        Move 0 to hoSQLHandler
40641>>>>>>>        Get psDriverID to sDriverID
40642>>>>>>>        Get psServer   to sServer
40643>>>>>>>        Get psDatabase to sDatabase
40644>>>>>>>
40644>>>>>>>        Function_Return hoSQLHandler
40645>>>>>>>    End_Function
40646>>>>>>>
40646>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
40646>>>>>>>    // macro-commands <sigh!>
40646>>>>>>>    // Note: The function sets the Err flag.
40646>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
40648>>>>>>>
40648>>>>>>>        Move False to Err
40649>>>>>>>
40649>>>>>>>        Function_Return (Err = False)
40650>>>>>>>    End_Function
40651>>>>>>>
40651>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
40653>>>>>>>        Move False to Err
40654>>>>>>>        Function_Return (Err = False)
40655>>>>>>>    End_Function
40656>>>>>>>
40656>>>>>>>End_Class
40657>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 20.1\Pkg\for_all.pkg)
40657>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
40657>>>>>>>//
40657>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
40657>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
40657>>>>>>>// conjunction with constraint-clauses.
40657>>>>>>>//
40657>>>>>>>// SYNTAX:
40657>>>>>>>//
40657>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
40657>>>>>>>//    <Constraints...>
40657>>>>>>>//    {DO}
40657>>>>>>>//      <loop body>
40657>>>>>>>//  End_For_All
40657>>>>>>>//
40657>>>>>>>// This set of macros implements a constraint-oriented file enumeration
40657>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
40657>>>>>>>//
40657>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
40657>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
40657>>>>>>>//   End_For_All
40657>>>>>>>//
40657>>>>>>>// To list only Customers with a Balance greater than their credit limit:
40657>>>>>>>//
40657>>>>>>>//   For_All Customer BY Index.1
40657>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
40657>>>>>>>//     DO
40657>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
40657>>>>>>>//   End_For_All
40657>>>>>>>//
40657>>>>>>>// Constraint clauses are:
40657>>>>>>>//
40657>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
40657>>>>>>>//   CONSTRAIN <File> AS <Expression>
40657>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
40657>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
40657>>>>>>>//
40657>>>>>>>// For example, to list all customers with a bad status whose names start
40657>>>>>>>// with "A" and which have not made a payment in thirty days:
40657>>>>>>>//
40657>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
40657>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
40657>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
40657>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
40657>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
40657>>>>>>>//      DO
40657>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
40657>>>>>>>//    End_For_All
40657>>>>>>>//
40657>>>>>>>
40657>>>>>>>
40657>>>>>>>//This command starts the loop process body when constraints are used;
40657>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
40657>>>>>>>//command line, and not on a line by itself
40657>>>>>>>//
40657>>>>>>>
40657>>>>>>>//Ends a For_All loop
40657>>>>>>>//
40657>>>>>>>
40657>>>>>>>
40657>>>>>
40657>>>>>
40657>>>>>Class cDbUpdateVersion is a cObject
40658>>>>>
40658>>>>>    Procedure Construct_Object    
40660>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
40660>>>>>        String[] aSQLQueryMessages
40661>>>>>        
40661>>>>>        Forward Send Construct_Object
40663>>>>>
40663>>>>>        // cDbUpdateHandler object event.
40663>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
40665>>>>>        If (bOnCreateExecuted = False) Begin    
40667>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
40669>>>>>            If (bUseCustomDbVersion = False) Begin
40671>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
40673>>>>>            End
40673>>>>>>
40673>>>>>            Delegate Send CheckIntFilesIntegrity
40675>>>>>            Delegate Send OnCreate
40677>>>>>            Delegate Set Private.pbOnCreateExecuted to True
40679>>>>>        End
40679>>>>>>
40679>>>>>
40679>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
40679>>>>>        // event was triggered, thus an actual change of the database was made.
40679>>>>>        Property Boolean pbVersionUpdate False
40680>>>>>
40680>>>>>        // This property must be manually set within each cDbUpdateVersion object
40680>>>>>        // by the programmer, to a consecutive number.
40680>>>>>        Property Number pnVersionNumber
40681>>>>>
40681>>>>>        Property Boolean pbUseConnectionID True
40682>>>>>        Property Boolean private.pbToANSI   True
40683>>>>>        Property Boolean private.pbRecnum   True
40684>>>>>        Property Boolean private.pbCopyData True
40685>>>>>        Property Boolean private.pbApiTableUpdateAuto False
40686>>>>>        Property Boolean private.pbCompareDate_DateTime False
40687>>>>>        Property Boolean private.pbCompareIndexAscending False
40688>>>>>        Property Boolean private.pbCompareIndexUppercase False
40689>>>>>        Property String private.psSchema
40690>>>>>        Property String private.psBaseTableSpace
40691>>>>>        Property String private.psLongTableSpace
40692>>>>>        Property String private.psIndexTableSpace
40693>>>>>
40693>>>>>        // Driver default value settings:
40693>>>>>        Property String private.psDriverDefaultValueASCII    ""
40694>>>>>        Property String private.psDriverDefaultValueBinary   ""
40695>>>>>        Property String private.psDriverDefaultValueDate     ""
40696>>>>>        Property String private.psDriverDefaultValueDateTime ""
40697>>>>>        Property String private.psDriverDefaultValueNumeric  ""
40698>>>>>        Property String private.psDriverDefaultValueText     ""
40699>>>>>
40699>>>>>        // Driver "nullability" settings:
40699>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
40700>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
40701>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
40702>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
40703>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
40704>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
40705>>>>>
40705>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
40705>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
40705>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
40705>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
40705>>>>>        // We reset it here for each cDbUpdateVersion object
40705>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
40707>>>>>    End_Procedure
40708>>>>>
40708>>>>>    // *** Main hook event message ***
40708>>>>>    // Place your database update logic here!
40708>>>>>    Procedure OnUpdate
40710>>>>>    End_Procedure
40711>>>>>
40711>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
40711>>>>>    // imported to the cDbUpdateHandler container class which should be a
40711>>>>>    // parent object to this object. To have the Studio's Property Panel
40711>>>>>    // "behave" aka show these properties we need to duplicate them in this
40711>>>>>    // class and "relay" them to the parent object.
40711>>>>>    Procedure Set pbToANSI Boolean bState
40713>>>>>        Set private.pbToANSI  to bState
40714>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40715>>>>>        Delegate Set pbToANSI to bState
40717>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40718>>>>>    End_Procedure
40719>>>>>
40719>>>>>    Function pbToANSI Returns Boolean
40721>>>>>        Function_Return (private.pbToAnsi(Self))
40722>>>>>    End_Function
40723>>>>>
40723>>>>>    Procedure Set pbRecnum Boolean bState
40725>>>>>        Set private.pbRecnum  to bState
40726>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40727>>>>>        Delegate Set pbRecnum to bState
40729>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40730>>>>>    End_Procedure
40731>>>>>
40731>>>>>    Function pbRecnum Returns Boolean
40733>>>>>        Function_Return (private.pbRecnum(Self))
40734>>>>>    End_Function
40735>>>>>
40735>>>>>    Procedure Set pbCopyData Boolean bState
40737>>>>>        Set private.pbCopyData  to bState
40738>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40739>>>>>        Delegate Set pbCopyData to bState
40741>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40742>>>>>    End_Procedure
40743>>>>>
40743>>>>>    Function pbCopyData Returns Boolean
40745>>>>>        Function_Return (private.pbCopyData(Self))
40746>>>>>    End_Function
40747>>>>>
40747>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
40747>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
40749>>>>>        Set private.pbApiTableUpdateAuto  to bState
40750>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40751>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40752>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40753>>>>>    End_Procedure
40754>>>>>
40754>>>>>    Function pbApiTableUpdateAuto Returns Boolean
40756>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
40757>>>>>    End_Function
40758>>>>>
40758>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
40760>>>>>        Set private.pbCompareDate_DateTime  to bState
40761>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40762>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40763>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40764>>>>>    End_Procedure
40765>>>>>
40765>>>>>    Function pbCompareDate_DateTime Returns Boolean
40767>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
40768>>>>>    End_Function
40769>>>>>
40769>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
40771>>>>>        Set private.pbCompareIndexAscending  to bState
40772>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40773>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40774>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40775>>>>>    End_Procedure
40776>>>>>
40776>>>>>    Function pbCompareIndexAscending Returns Boolean
40778>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
40779>>>>>    End_Function
40780>>>>>
40780>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
40782>>>>>        Set private.pbCompareIndexUppercase  to bState
40783>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40784>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
40785>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40786>>>>>    End_Procedure
40787>>>>>
40787>>>>>    Function pbCompareIndexUppercase Returns Boolean
40789>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
40790>>>>>    End_Function
40791>>>>>
40791>>>>>    Procedure Set psSchema String sValue
40793>>>>>        Set private.psSchema  to sValue
40794>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40795>>>>>        Delegate Set psSchema to sValue
40797>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40798>>>>>    End_Procedure
40799>>>>>
40799>>>>>    // First retrieve the private value that might have been set in the object.
40799>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40799>>>>>    // it might have been specified in the SQLConnections.ini file.
40799>>>>>    Function psSchema Returns String
40801>>>>>        String sValue
40801>>>>>        Get private.psSchema to sValue
40802>>>>>        If (sValue = "") Begin
40804>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
40805>>>>>        End
40805>>>>>>
40805>>>>>        Function_Return sValue
40806>>>>>    End_Function
40807>>>>>
40807>>>>>    Procedure Set psBaseTableSpace String sValue
40809>>>>>        Set private.psBaseTableSpace  to sValue
40810>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40811>>>>>        Delegate Set psBaseTableSpace to sValue
40813>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40814>>>>>    End_Procedure
40815>>>>>
40815>>>>>    // First retrieve the private value that might have been set in the object.
40815>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40815>>>>>    // it might have been specified in the SQLConnections.ini file.
40815>>>>>    Function psBaseTableSpace Returns String
40817>>>>>        String sValue
40817>>>>>        Get private.psBaseTableSpace to sValue
40818>>>>>        If (sValue = "") Begin
40820>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
40821>>>>>        End
40821>>>>>>
40821>>>>>        Function_Return sValue
40822>>>>>    End_Function
40823>>>>>
40823>>>>>    Procedure Set psLongTableSpace String sValue
40825>>>>>        Set private.psLongTableSpace  to sValue
40826>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40827>>>>>        Delegate Set psLongTableSpace to sValue
40829>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40830>>>>>    End_Procedure
40831>>>>>
40831>>>>>    // First retrieve the private value that might have been set in the object.
40831>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40831>>>>>    // it might have been specified in the SQLConnections.ini file.
40831>>>>>    Function psLongTableSpace Returns String
40833>>>>>        String sValue
40833>>>>>        Get private.psLongTableSpace to sValue
40834>>>>>        If (sValue = "") Begin
40836>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
40837>>>>>        End
40837>>>>>>
40837>>>>>        Function_Return sValue
40838>>>>>    End_Function
40839>>>>>
40839>>>>>    Procedure Set psIndexTableSpace String sValue
40841>>>>>        Set private.psIndexTableSpace  to sValue
40842>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40843>>>>>        Delegate Set psIndexTableSpace to sValue
40845>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40846>>>>>    End_Procedure
40847>>>>>
40847>>>>>    // First retrieve the private value that might have been set in the object.
40847>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40847>>>>>    // it might have been specified in the SQLConnections.ini file.
40847>>>>>    Function psIndexTableSpace Returns String
40849>>>>>        String sValue
40849>>>>>        Get private.psIndexTableSpace to sValue
40850>>>>>        If (sValue = "") Begin
40852>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
40853>>>>>        End
40853>>>>>>
40853>>>>>        Function_Return sValue
40854>>>>>    End_Function
40855>>>>>
40855>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
40857>>>>>        Set private.psDriverDefaultValueASCII  to sValue
40858>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40859>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
40861>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40862>>>>>    End_Procedure
40863>>>>>
40863>>>>>    // First retrieve the private value that might have been set in the object.
40863>>>>>    // If blank; get it from the parent object
40863>>>>>    Function psDriverDefaultValueASCII Returns String
40865>>>>>        String sValue
40865>>>>>        Get private.psDriverDefaultValueASCII to sValue
40866>>>>>        If (sValue = "") Begin
40868>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
40870>>>>>        End
40870>>>>>>
40870>>>>>        Function_Return sValue
40871>>>>>    End_Function
40872>>>>>
40872>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
40874>>>>>        Set private.psDriverDefaultValueBinary  to sValue
40875>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40876>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
40878>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40879>>>>>    End_Procedure
40880>>>>>
40880>>>>>    // First retrieve the private value that might have been set in the object.
40880>>>>>    // If blank; get it from the parent object
40880>>>>>    Function psDriverDefaultValueBinary Returns String
40882>>>>>        String sValue
40882>>>>>        Get private.psDriverDefaultValueBinary to sValue
40883>>>>>        If (sValue = "") Begin
40885>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
40887>>>>>        End
40887>>>>>>
40887>>>>>        Function_Return sValue
40888>>>>>    End_Function
40889>>>>>
40889>>>>>    Procedure Set psDriverDefaultValueDate String sValue
40891>>>>>        Set private.psDriverDefaultValueDate  to sValue
40892>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40893>>>>>        Delegate Set psDriverDefaultValueDate to sValue
40895>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40896>>>>>    End_Procedure
40897>>>>>
40897>>>>>    // First retrieve the private value that might have been set in the object.
40897>>>>>    // If blank; get it from the parent object
40897>>>>>    Function psDriverDefaultValueDate Returns String
40899>>>>>        String sValue
40899>>>>>        Get private.psDriverDefaultValueDate to sValue
40900>>>>>        If (sValue = "") Begin
40902>>>>>            Delegate Get psDriverDefaultValueDate to sValue
40904>>>>>        End
40904>>>>>>
40904>>>>>        Function_Return sValue
40905>>>>>    End_Function
40906>>>>>
40906>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
40908>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
40909>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40910>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
40912>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40913>>>>>    End_Procedure
40914>>>>>
40914>>>>>    // First retrieve the private value that might have been set in the object.
40914>>>>>    // If blank; get it from the parent object
40914>>>>>    Function psDriverDefaultValueDateTime Returns String
40916>>>>>        String sValue
40916>>>>>        Get private.psDriverDefaultValueDateTime to sValue
40917>>>>>        If (sValue = "") Begin
40919>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
40921>>>>>        End
40921>>>>>>
40921>>>>>        Function_Return sValue
40922>>>>>    End_Function
40923>>>>>
40923>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
40925>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
40926>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40927>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
40929>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40930>>>>>    End_Procedure
40931>>>>>
40931>>>>>    // First retrieve the private value that might have been set in the object.
40931>>>>>    // If blank; get it from the parent object
40931>>>>>    Function psDriverDefaultValueNumeric Returns String
40933>>>>>        String sValue
40933>>>>>        Get private.psDriverDefaultValueNumeric to sValue
40934>>>>>        If (sValue = "") Begin
40936>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
40938>>>>>        End
40938>>>>>>
40938>>>>>        Function_Return sValue
40939>>>>>    End_Function
40940>>>>>
40940>>>>>    Procedure Set psDriverDefaultValueText String sValue
40942>>>>>        Set private.psDriverDefaultValueText  to sValue
40943>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40944>>>>>        Delegate Set psDriverDefaultValueText to sValue
40946>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40947>>>>>    End_Procedure
40948>>>>>
40948>>>>>    // First retrieve the private value that might have been set in the object.
40948>>>>>    // If blank; get it from the parent object
40948>>>>>    Function psDriverDefaultValueText Returns String
40950>>>>>        String sValue
40950>>>>>        Get private.psDriverDefaultValueText to sValue
40951>>>>>        If (sValue = "") Begin
40953>>>>>            Delegate Get psDriverDefaultValueText to sValue
40955>>>>>        End
40955>>>>>>
40955>>>>>        Function_Return sValue
40956>>>>>    End_Function
40957>>>>>
40957>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
40959>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
40960>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40961>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
40963>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40964>>>>>    End_Procedure
40965>>>>>
40965>>>>>    // First retrieve the private value that might have been set in the object.
40965>>>>>    // If blank; get it from the parent object
40965>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
40967>>>>>        Boolean bState
40967>>>>>        Get private.pbDriverDefaultNullableASCII to bState
40968>>>>>        If (bState = False) Begin
40970>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
40972>>>>>        End
40972>>>>>>
40972>>>>>        Function_Return bState
40973>>>>>    End_Function
40974>>>>>
40974>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
40976>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
40977>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40978>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
40980>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40981>>>>>    End_Procedure
40982>>>>>
40982>>>>>    // First retrieve the private value that might have been set in the object.
40982>>>>>    // If blank; get it from the parent object
40982>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
40984>>>>>        Boolean bState
40984>>>>>        Get private.pbDriverDefaultNullableBinary to bState
40985>>>>>        If (bState = False) Begin
40987>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
40989>>>>>        End
40989>>>>>>
40989>>>>>        Function_Return bState
40990>>>>>    End_Function
40991>>>>>
40991>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
40993>>>>>        Set private.pbDriverDefaultNullableDate  to bState
40994>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40995>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
40997>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40998>>>>>    End_Procedure
40999>>>>>
40999>>>>>    // First retrieve the private value that might have been set in the object.
40999>>>>>    // If blank; get it from the parent object
40999>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
41001>>>>>        Boolean bState
41001>>>>>        Get private.pbDriverDefaultNullableDate to bState
41002>>>>>        If (bState = False) Begin
41004>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
41006>>>>>        End
41006>>>>>>
41006>>>>>        Function_Return bState
41007>>>>>    End_Function
41008>>>>>
41008>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
41010>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
41011>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41012>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
41014>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41015>>>>>    End_Procedure
41016>>>>>
41016>>>>>    // First retrieve the private value that might have been set in the object.
41016>>>>>    // If blank; get it from the parent object
41016>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
41018>>>>>        Boolean bState
41018>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
41019>>>>>        If (bState = False) Begin
41021>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
41023>>>>>        End
41023>>>>>>
41023>>>>>        Function_Return bState
41024>>>>>    End_Function
41025>>>>>
41025>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
41027>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
41028>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41029>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
41031>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41032>>>>>    End_Procedure
41033>>>>>
41033>>>>>    // First retrieve the private value that might have been set in the object.
41033>>>>>    // If blank; get it from the parent object
41033>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
41035>>>>>        Boolean bState
41035>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
41036>>>>>        If (bState = False) Begin
41038>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
41040>>>>>        End
41040>>>>>>
41040>>>>>        Function_Return bState
41041>>>>>    End_Function
41042>>>>>
41042>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
41044>>>>>        Set private.pbDriverDefaultNullableText  to bState
41045>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41046>>>>>        Delegate Set pbDriverDefaultNullableText to bState
41048>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41049>>>>>    End_Procedure
41050>>>>>
41050>>>>>    // First retrieve the private value that might have been set in the object.
41050>>>>>    // If blank; get it from the parent object
41050>>>>>    Function pbDriverDefaultNullableText Returns Boolean
41052>>>>>        Boolean bState
41052>>>>>        Get private.pbDriverDefaultNullableText to bState
41053>>>>>        If (bState = False) Begin
41055>>>>>            Delegate Get pbDriverDefaultNullableText to bState
41057>>>>>        End
41057>>>>>>
41057>>>>>        Function_Return bState
41058>>>>>    End_Function
41059>>>>>
41059>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
41061>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
41061>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
41061>>>>>
41061>>>>>        Get psDriverID to sDriverID
41062>>>>>        Get psSchema to sSchema
41063>>>>>
41063>>>>>        Get psBaseTableSpace to sBaseTableSpace
41064>>>>>        If (sBaseTableSpace <> "") Begin
41066>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41067>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
41069>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41070>>>>>        End
41070>>>>>>
41070>>>>>
41070>>>>>        Get psLongTableSpace to sLongTableSpace
41071>>>>>        If (sLongTableSpace <> "") Begin
41073>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41074>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
41076>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41077>>>>>        End
41077>>>>>>
41077>>>>>
41077>>>>>        Get psIndexTableSpace to sIndexTableSpace
41078>>>>>        If (sIndexTableSpace <> "") Begin
41080>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
41081>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
41083>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
41084>>>>>        End
41084>>>>>>
41084>>>>>
41084>>>>>        Get pbUseConnectionID to bUseConnectionID
41085>>>>>        Get pbToANSI          to bToANSI
41086>>>>>        Get pbRecnum          to bRecnum
41087>>>>>        Get pbCopyData        to bCopyData
41088>>>>>
41088>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
41089>>>>>
41089>>>>>        Function_Return bOK
41090>>>>>    End_Function
41091>>>>>
41091>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
41091>>>>>//        Boolean bOK bExists
41091>>>>>//        String sDataPath sBackupFolder
41091>>>>>//        
41091>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
41091>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
41091>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
41091>>>>>//        Get vFolderFormat sDataPath to sDataPath
41091>>>>>//        
41091>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
41091>>>>>//        If (bExists = False) Begin
41091>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
41091>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
41091>>>>>//            If (bExists = False) Begin
41091>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
41091>>>>>//                Function_Return False
41091>>>>>//            End                                                                                                                                            
41091>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
41091>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
41091>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
41091>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
41091>>>>>//        End
41091>>>>>//        
41091>>>>>//        Set Message_Text of ghoStatusPanel to ""
41091>>>>>//        Function_Return bOK
41091>>>>>//    End_Function
41091>>>>>//
41091>>>>>    // This is automatically called after the OnUpdate
41091>>>>>    // event has been executed. It will automatically update the
41091>>>>>    // version database field/column with the "pnVersionNumber"
41091>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
41091>>>>>    Procedure UpdateVersionColumnValue
41093>>>>>        Number nVersion nCurrentValue
41093>>>>>        Integer hTable iColumn
41093>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
41093>>>>>
41093>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
41093>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
41093>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
41095>>>>>        Get pbVersionUpdate to bVersionUpdate
41096>>>>>
41096>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
41098>>>>>            Get pnVersionNumber to nVersion
41099>>>>>            Delegate Get piDbVersionFileNumber  to hTable
41101>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
41103>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
41103>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
41103>>>>>            Close DF_ALL DF_PERMANENT
41104>>>>>
41104>>>>>            Open hTable
41106>>>>>
41106>>>>>            // It is then the developer responsibility to take care of finding
41106>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
41106>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
41108>>>>>            If (bUseCustomDbVersion = True) Begin
41110>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
41112>>>>>            End
41112>>>>>>
41112>>>>>
41112>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
41115>>>>>            If (nCurrentValue < nVersion) Begin
41117>>>>>                Lock
41118>>>>>>
41118>>>>>                    If (bUseCustomDbVersion = False) Begin
41120>>>>>                        Vfind hTable Recnum GE                            
41122>>>>>                    End
41122>>>>>>
41122>>>>>                    Set_Field_Value hTable iColumn to nVersion
41125>>>>>                    SaveRecord hTable
41126>>>>>                Unlock
41127>>>>>>
41127>>>>>            End
41127>>>>>>
41127>>>>>            Close hTable
41128>>>>>        End
41128>>>>>>
41128>>>>>    End_Procedure
41129>>>>>
41129>>>>>// Property of the container object (cDbUpdateHandler)
41129>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
41129>>>>>
41129>>>>>    Procedure End_Construct_Object
41131>>>>>        Forward Send End_Construct_Object
41133>>>>>        Send ProcessUpdate True
41134>>>>>    End_Procedure
41135>>>>>    
41135>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
41137>>>>>        Number nVersion nCurrentValue
41137>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
41137>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
41137>>>>>        String sObjectName
41137>>>>>        tDbVersionInfo[] dbVersionInfoArray
41137>>>>>        tDbVersionInfo[] dbVersionInfoArray
41138>>>>>
41138>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
41140>>>>>
41140>>>>>        // If the programmer forgot to set the version number we do not allow for the application
41140>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
41140>>>>>        // one database update is depended on an earlier update and that earlier version
41140>>>>>        // update was never executed it could lead to disastrous results.
41140>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
41140>>>>>        Get pnVersionNumber to nVersion
41141>>>>>        If (nVersion = 0) Begin
41143>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
41144>>>>>            Move (Name(Self)) to sObjectName
41145>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
41146>>>>>>
41146>>>>>            Send Exit_Application
41147>>>>>        End
41147>>>>>>
41147>>>>>
41147>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
41147>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
41147>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
41149>>>>>        If (bOnPreUpdateExecuted = False) Begin
41151>>>>>            Delegate Send OnPreUpdate
41153>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
41155>>>>>        End
41155>>>>>>
41155>>>>>        
41155>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
41157>>>>>        
41157>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
41159>>>>>        If (bUseCustomDbVersion = False) Begin
41161>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
41161>>>>>        End
41161>>>>>>
41161>>>>>        Else Begin
41162>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
41163>>>>>            If (bTableExists = False) Begin
41165>>>>>                Delegate Send OnCreateCustomDbVersionTable
41167>>>>>            End
41167>>>>>>
41167>>>>>        End
41167>>>>>>
41167>>>>>        
41167>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
41167>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
41167>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
41169>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
41171>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
41172>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
41173>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
41174>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
41176>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
41178>>>>>        End
41178>>>>>>
41178>>>>>
41178>>>>>        Delegate Get piDbVersionFileNumber  to hTable
41180>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
41182>>>>>
41182>>>>>        Open hTable
41184>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
41187>>>>>        If (bOpened = False) Begin
41189>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
41190>>>>>            Send Exit_Application
41191>>>>>        End
41191>>>>>>
41191>>>>>        
41191>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
41191>>>>>        // in case we take care of it here.
41191>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
41194>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
41196>>>>>            Vfind hTable 0 GT
41198>>>>>        End
41198>>>>>>
41198>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
41201>>>>>        If (bSystemTable = True) Begin
41203>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
41206>>>>>        End
41206>>>>>>
41206>>>>>        Else Begin
41207>>>>>            If (bUseCustomDbVersion = True) Begin
41209>>>>>                Send OnFindVersionRecord
41210>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
41213>>>>>            End
41213>>>>>>
41213>>>>>        End
41213>>>>>>
41213>>>>>
41213>>>>>        Close hTable
41214>>>>>
41214>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
41214>>>>>        // If not set we do nothing.
41214>>>>>        If (nCurrentValue < nVersion) Begin
41216>>>>>
41216>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
41216>>>>>            // execution of database update code. So if true _and_ one error
41216>>>>>            // has already occured; we're out of here.
41216>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
41218>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
41220>>>>>            If (bStopOnFirstError = True) Begin
41222>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
41224>>>>>                    Procedure_Return
41225>>>>>                End
41225>>>>>>
41225>>>>>            End
41225>>>>>>
41225>>>>>
41225>>>>>            // This is send to the parent container object (cDbUpdateHandler)
41225>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
41227>>>>>
41227>>>>>            // If the parent property pbContinueOnError = False, an update
41227>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
41227>>>>>            Delegate Get pbContinueOnError to bContinueOnError
41229>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
41231>>>>>                Procedure_Return
41232>>>>>            End
41232>>>>>>
41232>>>>>
41232>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
41234>>>>>
41234>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
41235>>>>>
41235>>>>>            // *** Programmer's main hook event for database update functions:
41235>>>>>            Send OnUpdate
41236>>>>>
41236>>>>>            Set pbVersionUpdate to True
41237>>>>>            Send UpdateVersionColumnValue
41238>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
41240>>>>>        End
41240>>>>>>
41240>>>>>
41240>>>>>    End_Procedure
41241>>>>>
41241>>>>>End_Class
41242>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateUserCount.pkg)
41242>>>>>//****************************************************************************
41242>>>>>// $Module type: Class
41242>>>>>// $Module name: cDbUpdateUserCount.pkg
41242>>>>>// $Author     : Emil Stojanov Quantaris B.V.
41242>>>>>//
41242>>>>>//               Collected from DAW's newsgroups.
41242>>>>>//
41242>>>>>// Description : It uses the windows API to lock bytes in a file.
41242>>>>>//               If the application or PC craches it will release the lock
41242>>>>>//               automatically.
41242>>>>>//
41242>>>>>// Note 1      : It will count the number of running app's, so if a
41242>>>>>//               user starts the app twice on one machine it will count as two users.
41242>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
41242>>>>>//               However, to not conflict with any other usage of this class it was
41242>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
41242>>>>>//               and cDbUpdateVersion classes)
41242>>>>>//
41242>>>>>// $Rev History:
41242>>>>>//    2008-10-17  Module header created (Militaty data format)
41242>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
41242>>>>>//                for easy translation to other languages.
41242>>>>>//                Added the tUserCount struct for easier passing of parameters.
41242>>>>>//                Added the ApplicationPath message.
41242>>>>>//****************************************************************************
41242>>>>>Use LanguageText.pkg
41242>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework2.0\AppSrc\cDbUpdateUserCount.inc)
41242>>>>>>>Use GlobalFunctionsProcedures.pkg
41242>>>>>>>// Sample:
41242>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
41242>>>>>>>
41242>>>>>>>
41242>>>>>>>// Symbols used by UserCounting
41242>>>>>>>    Define GENERIC_READ         for |CI$80000000
41242>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
41242>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
41242>>>>>>>    Define GENERIC_ALL          for |CI$10000000
41242>>>>>>>    Define CREATE_NEW           for 1
41242>>>>>>>    Define CREATE_ALWAYS        for 2
41242>>>>>>>    Define OPEN_EXISTING        for 3
41242>>>>>>>    Define OPEN_ALWAYS          for 4
41242>>>>>>>    Define TRUNCATE_EXISTING    for 5
41242>>>>>>>    Define FILE_BEGIN           for 0
41242>>>>>>>    Define FILE_CURRENT         for 1
41242>>>>>>>    Define FILE_END             for 2
41242>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
41242>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
41242>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
41242>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
41242>>>>>>>    Define _MAX_PATH  for 260
41242>>>>>>>    Define _MAX_DRIVE for 3
41242>>>>>>>    Define _MAX_DIR   for 256
41242>>>>>>>    Define _MAX_FNAME for 256
41242>>>>>>>    Define _MAX_EXT   for 256
41242>>>>>>>
41242>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
41243>>>>>>>
41243>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
41244>>>>>>>
41244>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
41245>>>>>>>
41245>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
41246>>>>>>>
41246>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
41247>>>>>>>
41247>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
41248>>>>>>>
41248>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
41249>>>>>>>
41249>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
41250>>>>>>>// Sample:
41250>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
41250>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
41252>>>>>>>    Boolean bReturn
41252>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
41253>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
41254>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
41255>>>>>>>    Function_Return bReturn
41256>>>>>>>End_Function
41257>>>>>Use vWin32fh.pkg
41257>>>>>Use seq_chnl.pkg
41257>>>>>
41257>>>>>// User interface constant strings:
41257>>>>>    Define CS_UserCountError            for "User count error:"
41257>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
41257>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
41257>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
41257>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>
41257>>>>>    Struct tUserCount
41257>>>>>        Integer iUserCount
41257>>>>>        Integer iError
41257>>>>>        String  sErrorTxt
41257>>>>>    End_Struct
41257>>>>>
41257>>>>>    Define CI_UserCountMaxUsers for 9999
41257>>>>>
41257>>>>>Class cDbUpdateUserCount is a cObject
41258>>>>>    Procedure Construct_Object
41260>>>>>        Forward Send Construct_Object
41262>>>>>
41262>>>>>        Property String  psLockFileName
41263>>>>>        Property Integer piMaxUsers
41264>>>>>        Property Boolean pbCheckDataFlexUserCount True
41265>>>>>
41265>>>>>        Property Handle  phUserCountFile
41266>>>>>        Property Integer pdwLockPosition
41267>>>>>    End_Procedure
41268>>>>>
41268>>>>>    Function IsProgramRunning Returns Boolean
41270>>>>>        tUserCount UserCount
41270>>>>>        tUserCount UserCount
41270>>>>>
41270>>>>>        Get CheckUserCount to UserCount
41271>>>>>
41271>>>>>        Function_Return (UserCount.iUserCount > 1)
41272>>>>>    End_Function
41273>>>>>
41273>>>>>    // Returns the full path of the Application (no trailing "\")
41273>>>>>    Function ApplicationPath Returns String
41275>>>>>        String sApplicationFileName sPath
41275>>>>>        Integer iNumChars iRetval
41275>>>>>
41275>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
41276>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
41277>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
41278>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
41279>>>>>        Move (CString(sApplicationFileName)) to sPath
41280>>>>>
41280>>>>>        Function_Return sPath
41281>>>>>    End_Function
41282>>>>>
41282>>>>>    Function OpenUserCountFile String sFileName Returns Handle
41284>>>>>        Handle  hFile
41284>>>>>        Pointer pFileName
41284>>>>>        String sPath sFile
41284>>>>>        Integer iCh
41284>>>>>
41284>>>>>        Move (Addressof(sFileName)) to pFileName
41285>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
41286>>>>>
41286>>>>>        // If lock file doesn't exist, create it.
41286>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
41288>>>>>            Get ApplicationPath to sPath
41289>>>>>            Get vFolderFormat sPath to sPath
41290>>>>>            Move (sPath + psLockFileName(Self)) to sFile
41291>>>>>            Get Seq_Open_Output_Channel sFile to iCh
41292>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
41294>>>>>                Function_Return 0
41295>>>>>            End
41295>>>>>>
41295>>>>>            Direct_Output channel iCh sFile
41297>>>>>                Write channel iCh ""
41299>>>>>            Send Seq_Close_Channel iCh
41300>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
41301>>>>>        End
41301>>>>>>
41301>>>>>
41301>>>>>        Function_Return hFile
41302>>>>>    End_Function
41303>>>>>
41303>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
41305>>>>>        Integer iReturnValue 
41305>>>>>        Boolean bOK
41305>>>>>
41305>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
41306>>>>>        If (iReturnValue = 0) Begin
41308>>>>>            Move False to bOK
41309>>>>>        End
41309>>>>>>
41309>>>>>        Else Begin
41310>>>>>            Move True to bOK
41311>>>>>        End
41311>>>>>>
41311>>>>>        Function_Return bOK
41312>>>>>    End_Function
41313>>>>>
41313>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
41315>>>>>        Integer iReturnValue
41315>>>>>        Boolean bOK
41315>>>>>
41315>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
41316>>>>>        If (iReturnValue = 0) Begin
41318>>>>>            Move False to bOK
41319>>>>>        End
41319>>>>>>
41319>>>>>        Else Begin
41320>>>>>            Move True to bOK
41321>>>>>        End           
41321>>>>>>
41321>>>>>        Function_Return bOK
41322>>>>>    End_Function
41323>>>>>
41323>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
41325>>>>>        dWord dwCurrPos
41325>>>>>
41325>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
41326>>>>>        Function_Return dwCurrPos
41327>>>>>    End_Function
41328>>>>>
41328>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
41330>>>>>        DWord dwCurrPos
41330>>>>>
41330>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
41331>>>>>        Function_Return dwCurrPos
41332>>>>>    End_Function
41333>>>>>
41333>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
41335>>>>>        Integer iReturnValue                               
41335>>>>>        Boolean bOK
41335>>>>>        String  sBuffer
41335>>>>>        Pointer pBuffer
41335>>>>>        String  sSize
41335>>>>>        Pointer pSize
41335>>>>>
41335>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
41336>>>>>        Move (AddressOf(sBuffer)) to pBuffer
41337>>>>>
41337>>>>>        Move (Repeat((Character(0)),4)) to sSize
41338>>>>>        Move (AddressOf(sSize)) to pSize
41339>>>>>
41339>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
41340>>>>>        If (iReturnValue = 0) Begin
41342>>>>>            Move False to bOK
41343>>>>>        End
41343>>>>>>
41343>>>>>        Else Begin
41344>>>>>            Move True to bOK
41345>>>>>        End                 
41345>>>>>>
41345>>>>>        Function_Return bOK
41346>>>>>    End_Function
41347>>>>>
41347>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
41349>>>>>        Integer iReturnValue
41349>>>>>
41349>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
41350>>>>>        Function_Return iReturnValue
41351>>>>>    End_Function
41352>>>>>
41352>>>>>    Procedure DoCheckUserCount
41354>>>>>        tUserCount UserCount
41354>>>>>        tUserCount UserCount
41354>>>>>
41354>>>>>        Get CheckUserCount to UserCount
41355>>>>>        // If all is fine, we're done.
41355>>>>>        If (UserCount.iError = 0) Begin
41357>>>>>            Procedure_Return
41358>>>>>        End
41358>>>>>>
41358>>>>>
41358>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
41359>>>>>
41359>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
41361>>>>>            Abort
41362>>>>>>
41362>>>>>        End
41362>>>>>>
41362>>>>>    End_Procedure
41363>>>>>
41363>>>>>    Function CheckUserCount Returns tUserCount
41365>>>>>        Handle  hFile
41365>>>>>        String  sPath sFile
41365>>>>>        Integer iResult
41365>>>>>        DWord   dwFilePos
41365>>>>>        Integer bLocked
41365>>>>>        Integer iMaxUsers
41365>>>>>        Integer iCurUser
41365>>>>>        tUserCount UserCount
41365>>>>>        tUserCount UserCount
41365>>>>>
41365>>>>>        Move 0 to UserCount.iError
41366>>>>>
41366>>>>>        Get phUserCountFile to hFile
41367>>>>>        If (not(hFile)) Begin
41369>>>>>            Get ApplicationPath to sPath
41370>>>>>            Get vFolderFormat sPath to sPath
41371>>>>>            Move (sPath + psLockFileName(Self)) to sFile
41372>>>>>            Get OpenUserCountFile sFile to hFile
41373>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
41375>>>>>                Move 1 to UserCount.iUserCount
41376>>>>>                Move 1 to UserCount.iError
41377>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
41378>>>>>                Function_Return UserCount
41379>>>>>            End
41379>>>>>>
41379>>>>>            Else Begin
41380>>>>>                Move False to bLocked
41381>>>>>                Set phUserCountFile to hFile
41382>>>>>                Get piMaxUsers to iMaxUsers
41383>>>>>
41383>>>>>                // Set Filepointer to beginning of the file
41383>>>>>                Get ResetUserCountPointer hFile to dwFilePos
41384>>>>>                If (dwFilePos = -1) Begin
41386>>>>>                    Move 1 to UserCount.iUserCount
41387>>>>>                    Move 2 to UserCount.iError
41388>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
41389>>>>>                    Function_Return UserCount
41390>>>>>                End
41390>>>>>>
41390>>>>>                For iCurUser from 1 to iMaxUsers
41396>>>>>>
41396>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
41397>>>>>                    If (not(iResult)) Begin  // byte is locked
41399>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
41400>>>>>                        If (dwFilePos = -1) Begin
41402>>>>>                            Move 1 to UserCount.iUserCount
41403>>>>>                            Move 3 to UserCount.iError
41404>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
41405>>>>>                            Function_Return UserCount
41406>>>>>                        End
41406>>>>>>
41406>>>>>                    End
41406>>>>>>
41406>>>>>                    Else Begin  // byte is not locked
41407>>>>>                        Set pdwLockPosition to dwFilePos
41408>>>>>                        Move True to bLocked
41409>>>>>                        Move iMaxUsers to iCurUser
41410>>>>>                    End
41410>>>>>>
41410>>>>>                Loop
41411>>>>>>
41411>>>>>                If (not(bLocked)) Begin
41413>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
41414>>>>>                    Move 4 to UserCount.iError
41415>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
41416>>>>>                    Function_Return UserCount
41417>>>>>                End
41417>>>>>>
41417>>>>>            End
41417>>>>>>
41417>>>>>        End
41417>>>>>>
41417>>>>>
41417>>>>>        Function_Return UserCount
41418>>>>>    End_Function
41419>>>>>
41419>>>>>
41419>>>>>    Procedure DoReleaseUserCount
41421>>>>>        Integer iResult
41421>>>>>        Handle  hFile
41421>>>>>        DWord   dwLockPos
41421>>>>>
41421>>>>>        Get phUserCountFile to hFile
41422>>>>>        Get pdwLockPosition to dwLockPos
41423>>>>>        If (hFile) Begin
41425>>>>>            If (dwLockPos) Begin
41427>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
41428>>>>>            End
41428>>>>>>
41428>>>>>            Get CloseUserCountFile hFile to iResult
41429>>>>>        End
41429>>>>>>
41429>>>>>    End_Procedure
41430>>>>>
41430>>>>>    Function CurrentNumberOfUsers Returns Integer
41432>>>>>        Handle  hFile
41432>>>>>        Integer iMaxUsers
41432>>>>>        DWord   dwFilePos
41432>>>>>        Integer iCurUser
41432>>>>>        Integer iResult
41432>>>>>        Integer iNumberOfLocks
41432>>>>>        String  sPath sFile
41432>>>>>
41432>>>>>        Move 0 to iNumberOfLocks
41433>>>>>
41433>>>>>        Get ApplicationPath to sPath
41434>>>>>        Get vFolderFormat sPath to sPath
41435>>>>>        Move (sPath + psLockFileName(Self)) to sFile
41436>>>>>        Get OpenUserCountFile sFile to hFile
41437>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
41439>>>>>            Send UserError CS_UnableToInitUserCountSys
41440>>>>>            Abort
41441>>>>>>
41441>>>>>        End
41441>>>>>>
41441>>>>>
41441>>>>>        If (hFile > 0) Begin
41443>>>>>            Get piMaxUsers To iMaxUsers
41444>>>>>
41444>>>>>            // Set Filepointer to beginning of the file
41444>>>>>            Get ResetUserCountPointer hFile to dwFilePos
41445>>>>>            If (dwFilePos = -1) Begin
41447>>>>>                Send UserError CS_UnableResetUserCountSys
41448>>>>>                Abort
41449>>>>>>
41449>>>>>            End
41449>>>>>>
41449>>>>>            For iCurUser from 1 to iMaxUsers
41455>>>>>>
41455>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
41456>>>>>                If (Not(iResult)) Begin  // byte is locked
41458>>>>>                    Increment iNumberOfLocks
41459>>>>>                End
41459>>>>>>
41459>>>>>                Else Begin  // byte is not locked
41460>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
41461>>>>>                End
41461>>>>>>
41461>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
41462>>>>>                If (dwFilePos = -1) Begin
41464>>>>>                    Send UserError CS_ErrorAdvancingPointer
41465>>>>>                    Abort
41466>>>>>>
41466>>>>>                End
41466>>>>>>
41466>>>>>            Loop
41467>>>>>>
41467>>>>>        End
41467>>>>>>
41467>>>>>        Get CloseUserCountFile hFile to iResult
41468>>>>>        Function_Return iNumberOfLocks
41469>>>>>    End_Function
41470>>>>>
41470>>>>>End_Class
41471>>>Use cDbUpdateFunctionLibrary.pkg
41471>>>
41471>>>//{ DataBindable=True }
41471>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
41471>>>Class cDbUpdateHandler is a cObject
41472>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
41473>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
41474>>>
41474>>>    Procedure Construct_Object
41476>>>        tUserCount UserCount
41476>>>        tUserCount UserCount
41476>>>        Integer iUserCount
41476>>>        Handle ho                     
41476>>>
41476>>>        Forward Send Construct_Object
41478>>>        Move Self to ghoDbUpdateHandler  
41479>>>        
41479>>>        // Latin1_General_CI_AS = General Insensitive collation
41479>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
41479>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
41479>>>        // Good read about which collation to select:
41479>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
41479>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
41480>>>
41480>>>        // Struct array that will contain pnVersionNumbers & object id's of
41480>>>        // all child cDbVersion objects.
41480>>>        Property tDbVersionInfo[] paDbVersionInfoArray
41481>>>
41481>>>        Property Integer Error_Processing_State False  // internal use
41482>>>        
41482>>>        Property Boolean Private.pbDbVersionCheckDone False
41483>>>
41483>>>        Property Boolean pbUseCustomDbVersion False  
41484>>>        
41484>>>        // If this property = True _and_ no DbVersion table exists 
41484>>>        // when the framework is started, a DbVersion table will be created automatically.
41484>>>        Property Boolean pbAutoCreateDbVersionTable True
41485>>>
41485>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
41485>>>        // the Filelist.cfg slot number indicated by this property will be used
41485>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
41485>>>        // an Unhandled Exception Error will be genereted and the program halted. So
41485>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
41485>>>        // to a value that corresponds to a free Filelist.cfg slot number.
41485>>>        Property Integer Private.piDbVersionFileNumber -1
41486>>>        Property Integer Private.piDbVersionFieldNumber 1
41487>>>
41487>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
41487>>>        // that creates all library properties
41487>>>        Send CreateDbUpdateLibraryProperties
41488>>>
41488>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
41489>>>
41489>>>        // Error handling:
41489>>>        Property Boolean Private.pbOnCreateExecuted False
41490>>>        Property Boolean Private.pbOnPreUpdateExecuted False
41491>>>        Property Boolean Private.pbProcessingError False
41492>>>        Property Boolean pbDbUpdateErrorHasOccured False
41493>>>        // Don't touch. It is being used by the cDbUpdateVersion
41493>>>        // subclass to tell if that particular update went OK or not.
41493>>>        Property Boolean Private.pbUpdateVersionObjectError False
41494>>>        Property String[] paSQLQueryMessages
41495>>>
41495>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
41496>>>        Move Self to Error_Object_Id
41497>>>        // Error handling:
41497>>>        // Temporarily redirect all errors to this object so we can silently
41497>>>        // log all errors that might appear while updating the database.
41497>>>        // We temporarily redirect all errors to this object so we can
41497>>>        // log and write errors to the log file. It will be reset after
41497>>>        // the database updates have been finished.
41497>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
41498>>>
41498>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
41499>>>
41499>>>        // Error Reporting Related
41499>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
41499>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
41500>>>
41500>>>        // If the pbContinueOnError = False, an update
41500>>>        // of another cDbUpdateVersion object will _not_ be
41500>>>        // performed if an error occured in a previous
41500>>>        // cDbUpdateVersion object.
41500>>>        Property Boolean pbContinueOnError False
41501>>>        // Stops execution in other cDbUpdateVersion objecs,
41501>>>        // if errors occurred in one cDbUpdateVersion object.
41501>>>        Property Boolean pbStopOnFirstError False
41502>>>        // If True errors that occured while updating the database
41502>>>        // will be shown in the default app for .txt files when done.
41502>>>        // Note: The log file will _always_ be created in the Data folder.
41502>>>        Property Boolean pbShowErrorLogPostRun True
41503>>>
41503>>>        // Be _very_ careful to set this property to true!
41503>>>        // If = True, no question will be asked if the update
41503>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
41503>>>        // the error log won't be shown. The logfile itself will still be created though.
41503>>>        // You have to know what you're doing!
41503>>>        Property Boolean pbSilentMode False
41504>>>        
41504>>>        Property Boolean pbEnableCancelButton False
41505>>>
41505>>>        // Don't touch! Very private. The value is used by the error log to write for which
41505>>>        // cDbUpdateVersion object an error occured.
41505>>>        Property Number pnCurrentVersionUpdate 0
41506>>>
41506>>>        // The user counting logic is used to safe-guard agains anybody else is
41506>>>        // using the application when a database update is to be performed.
41506>>>        // (Garters & suspenders!)
41506>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
41507>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
41508>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
41509>>>
41509>>>        // This lock file is used to guard against somebody else tries to start the
41509>>>        // application while updates are in progress.
41509>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
41510>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
41511>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
41512>>>                                                                                      // Only the current user allowed.
41512>>>        // Properties for the table & column of a system file field/column where
41512>>>        // the database version update number gets saved.
41512>>>        Property Integer Private.Data_File  0
41513>>>        Property Integer Private.Data_Field 0
41514>>>
41514>>>        // Property that is used to indicate that we have already
41514>>>        // started the database update.
41514>>>        Property Boolean Private.pbDatabaseUpdateStarted False
41515>>>
41515>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
41515>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
41515>>>        // change of the database has been made.
41515>>>        Property Boolean Private.pbDatabaseWasUpdated False
41516>>>
41516>>>        // We need to trigger the user counting system so that a bit in the
41516>>>        // user counting file is locked. This is to guard that not more than one user
41516>>>        // is currently runnning the program.
41516>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
41517>>>
41517>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
41518>>>        If (iUserCount > 0) Begin
41520>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
41521>>>            Send Exit_Application
41522>>>        End
41522>>>>
41522>>>
41522>>>        Set pbHandleQueryErrors to False
41523>>>            
41523>>>        // This can't be right?    
41523>>>//        If (ghoDbUpdateFunctionLibrary = 0) Begin
41523>>>//            Move Self to ghoDbUpdateFunctionLibrary
41523>>>//        End
41523>>>
41523>>>        Property Handle phoSQLConnectionHandler 0
41524>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
41524>>>        // we will create one as it is used for all ConnectionID, ConnectionString
41524>>>        // etc information.
41524>>>        If (ghoSQLConnectionHandler = 0) Begin
41526>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
41527>>>            Set phoSQLConnectionHandler to ho
41528>>>        End             
41528>>>>
41528>>>        
41528>>>        Property Boolean pbCheckIntFiles False   
41529>>>        Property Handle  phIntFilesTable 2048
41530>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
41531>>>        
41531>>>        Set Icon to "Default.ico"
41532>>>    End_Procedure
41533>>>
41533>>>    Procedure End_Construct_Object
41535>>>        Boolean bCheckIntFiles
41535>>>        
41535>>>        Forward Send End_Construct_Object
41537>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
41539>>>            Send OnCreate
41540>>>            Set Private.pbOnCreateExecuted to True
41541>>>        End
41541>>>>
41541>>>        Send Cleanup
41542>>>    End_Procedure
41543>>>    
41543>>>    // Programmers hook event.
41543>>>    Procedure OnCreate
41545>>>    End_Procedure        
41546>>>                                 
41546>>>    // *** MAIN .Int file (and Filelist.cfg) Check Integrity Message ***
41546>>>    //                                                
41546>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
41546>>>    // cDbUpdateHandler object.
41546>>>    //
41546>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
41546>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
41546>>>    //
41546>>>    // If not done previously the phIntFilesTable will be created and filled with data
41546>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
41546>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
41546>>>    // of Filelist.cfg is made for backup purposes.
41546>>>    //
41546>>>    // Note: If an error occurrs the application will exit, as it means that at least one
41546>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
41546>>>    Procedure CheckIntFilesIntegrity
41548>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists
41548>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
41548>>>        String sFileListZipFile sParam sProgram sFile 
41548>>>        Integer iDataPaths iCount
41548>>>        Handle hTable hIntFilesTable                    
41548>>>        UChar[] asFileListArray 
41549>>>        String[] asSavedIntFile
41550>>>        tDUFIntFile[] DUFIntFiles
41550>>>        tDUFIntFile[] DUFIntFiles
41551>>>        
41551>>>        Get pbCheckIntFiles to bCheckIntFiles
41552>>>        If (bCheckIntFiles = False) Begin
41554>>>            Procedure_Return
41555>>>        End
41555>>>>
41555>>>        
41555>>>        Move True to bResult        
41556>>>        
41556>>>        // Note: Include_Resource is a compiler directive!
41556>>>        // It will embedd the Filelist.cfg from the developers machine
41556>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
41556>>>        // need to change the next code line.         
41556>>>        //
41556>>>        // This is a pickle (!) with the Filelist.cfg as it is "busy" as it is open in the Studio,
41556>>>        // when we get here and then it seems the compiler can't embedd it!        
41556>>>        // ToDo: Change compiler directives in Project properties (?)
41556>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
41556>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
41556>>>        
41556>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
41557>>>        Get vFilePathExists sFileListName to bExists 
41558>>>        If (bExists = True) Begin
41560>>>            Get ParseFolderName sFileListName to sDataPath    
41561>>>            Get vFolderFormat sDataPath to sDataPath                              
41562>>>            Get ParseFileName sFileListName to sFile
41563>>>            // We need to create a backup copy of Filelist.cfg.
41563>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
41564>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
41565>>>            If (bOK = False) Begin
41567>>>                Move False to bResult
41568>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
41569>>>>
41569>>>            End
41569>>>>
41569>>>        End
41569>>>>
41569>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
41569>>>        Else Begin
41570>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
41571>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
41571>>>            If (bOK = False) Begin   
41573>>>                Move False to bResult
41574>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
41575>>>>
41575>>>            End
41575>>>>
41575>>>        End
41575>>>>
41575>>>        
41575>>>        Get phIntFilesTable to hIntFilesTable
41576>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
41579>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
41580>>>        // This will automatically create the phIntFilesTable if not exists.
41580>>>        // It is used to save data from the current set of .int files.
41580>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
41582>>>            Send AutoCreateIntFilesTable
41583>>>        End                                                       
41583>>>>
41583>>>        
41583>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
41583>>>        // ToDo: Or should this always be attempted? Else the 
41583>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
41584>>>        Move (IsDebuggerPresent()) to bDevelop
41585>>>        If (bDevelop = False) Begin
41587>>>            Get vFolderExists sDDSrcPath to bDevelop
41588>>>        End
41588>>>>
41588>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
41589>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
41590>>>        For iCount from 1 to iDataPaths
41596>>>>
41596>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
41597>>>            Get vFolderFormat sDataPath to sDataPath 
41598>>>            Get vFolderExists sDataPath to bExists
41599>>>            If (bExists = True) Begin                  
41601>>>                Move 0 to hTable
41602>>>                Repeat
41602>>>>
41602>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
41605>>>                    If (hTable <> 0) Begin
41607>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
41610>>>                        Get UtilTableIsSqlByRootName sIntFileName to bIsSQL
41611>>>                        If (bIsSQL = True) Begin
41613>>>                            Get _TableNoPrefix sIntFileName to sIntFileName
41614>>>                            Move (sIntFileName + ".int")    to sIntFileName
41615>>>                            Get IsIntFileSaved sIntFileName to bSaved  
41616>>>                            Move True to bOK            
41617>>>                            
41617>>>                            // Save .int file to database if not done previously.
41617>>>                            // We only attempt to read .int files on a development machine.
41617>>>                            If (bDevelop = True) Begin
41619>>>                                If (bSaved = False) Begin
41621>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
41622>>>                                    If (bOK = False) Begin
41624>>>                                        Move False to bResult    
41625>>>                                    End
41625>>>>
41625>>>                                End         
41625>>>>
41625>>>                                If (bOK = True) Begin
41627>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
41628>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
41630>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
41631>>>                                        If (bOK = False) Begin
41633>>>                                            Move False to bResult
41634>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
41635>>>>
41635>>>                                        End
41635>>>>
41635>>>                                    End
41635>>>>
41635>>>                                End
41635>>>>
41635>>>                            End
41635>>>>
41635>>>                            
41635>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
41636>>>                            If (bExists = False) Begin                           
41638>>>                                // If the .int file is missing on disk; create it from database.
41638>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
41639>>>                                If (bOK = False) Begin         
41641>>>                                    Move False to bResult
41642>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
41643>>>>
41643>>>                                End
41643>>>>
41643>>>                            End
41643>>>>
41643>>>                        End
41643>>>>
41643>>>                    End
41643>>>>
41643>>>                Until (hTable = 0)
41645>>>            End
41645>>>>
41645>>>        Loop       
41646>>>>
41646>>>        
41646>>>        // If an error occured we need to exit the application.
41646>>>        If (bResult = False) Begin  
41648>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
41649>>>            Send Exit_Application
41650>>>        End
41650>>>>
41650>>>        
41650>>>    End_Procedure               
41651>>>
41651>>>    // To update currently saved IntFile data to the database.
41651>>>    // Because it is much easier, we first delete all current records and
41651>>>    // then saves the changed .int file to the database.
41651>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
41653>>>        Boolean bOK
41653>>>        
41653>>>        Move False to bOK
41654>>>
41654>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
41655>>>        If (bOK = True) Begin
41657>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
41658>>>        End
41658>>>>
41658>>>        
41658>>>        Function_Return bOK
41659>>>    End_Function
41660>>>    
41660>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
41662>>>        Handle hTable
41662>>>        Boolean bOK
41662>>>        Integer iColumn iIndex   
41662>>>        String sFileName
41662>>>        
41662>>>        Move False to bOK
41663>>>        Get phIntFilesTable to hTable
41664>>>        Move 2              to iColumn // This is the "InfFileName" field no.
41665>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
41666>>>
41666>>>        Open hTable
41668>>>        Set_Field_Value hTable iColumn to sIntFileName
41671>>>        Vfind hTable iIndex GE
41673>>>        Get_Field_Value hTable iColumn to sFileName
41676>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
41678>>>            Move True to bOK    
41679>>>        End
41679>>>>
41679>>>        Close hTable
41680>>>        
41680>>>        Function_Return bOK       
41681>>>    End_Function   
41682>>>    
41682>>>    // Checks that the passed .int file is the same as what is saved in the database.
41682>>>    // If not same, the return string array will contain the read .int file,
41682>>>    // else the returned array will be empty.
41682>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
41684>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
41688>>>        Boolean bIsSame
41688>>>        
41688>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
41689>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
41690>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
41691>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
41692>>>        
41692>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
41693>>>        If (bIsSame = False) Begin
41695>>>            Move asIntFileOrg to asReturnIntFile    
41696>>>        End
41696>>>>
41696>>>        
41696>>>        Function_Return asReturnIntFile    
41697>>>    End_Function                                   
41698>>>    
41698>>>    // Takes a string array as parameter and returns a new
41698>>>    // string array without any empty rows and all rows trimmed.
41698>>>    // This is e.g. used by the HasIntFileChanged message to compare
41698>>>    // two .int file arrays. 
41698>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
41700>>>        Integer iSize iCount iRow
41700>>>        String sVal        
41700>>>        String[] asRetValArray
41701>>>        
41701>>>        Move (SizeOfArray(asIntFile)) to iSize
41702>>>        If (iSize = 0) Begin
41704>>>            Function_Return asRetValArray
41705>>>        End                          
41705>>>>
41705>>>        Decrement iSize         
41706>>>        Move 0 to iRow
41707>>>        
41707>>>        For iCount from 0  to iSize
41713>>>>
41713>>>            Move asIntFile[iCount] to sVal
41714>>>            Move (Trim(sVal)) to sVal
41715>>>            If (sVal <> "") Begin
41717>>>                Move sVal to asRetValArray[iRow]
41718>>>                Increment iRow        
41719>>>            End
41719>>>>
41719>>>        Loop
41720>>>>
41720>>>        
41720>>>        Function_Return asRetValArray
41721>>>    End_Function
41722>>>    
41722>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
41724>>>        Handle hTable
41724>>>        Boolean bOK bErr
41724>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
41724>>>        Number iID
41724>>>        String sFileName
41724>>>        String[] asIntFile
41725>>>        
41725>>>        Move Err to bErr
41726>>>        Move False to Err
41727>>>        Move False to bOK
41728>>>        Get phIntFilesTable to hTable  
41729>>>        Move 1              to iIDCol
41730>>>        Move 2              to iFileCol
41731>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
41732>>>        Move 1              to iIDIdx   // Main ID index.
41733>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
41734>>>
41734>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
41735>>>        Move (SizeOfArray(asIntFile)) to iSize
41736>>>        If (iSize = 0) Begin
41738>>>            Function_Return False
41739>>>        End
41739>>>>
41739>>>        Decrement iSize
41740>>>        Open hTable  
41742>>>                  
41742>>>        // Find the last used ID no:
41742>>>        Fill_Field hTable iIDCol with DF_HIGH
41744>>>        Vfind hTable iIDIdx LE
41746>>>        Get_Field_Value hTable iIDCol to iID 
41749>>>        // This only happens the very first time we save a record.
41749>>>        If (iID = 999999999999) Begin
41751>>>            Move 0 to iID
41752>>>        End
41752>>>>
41752>>>        Increment iID        
41753>>>        
41753>>>        Lock
41754>>>>
41754>>>            For iCount from 0 to iSize
41760>>>>
41760>>>                Clear hTable
41761>>>                Set_Field_Value hTable iIDCol   to iID     
41764>>>                Set_Field_Value hTable iFileCol to sIntFileName
41767>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
41770>>>                SaveRecord hTable
41771>>>                Increment iID
41772>>>            Loop
41773>>>>
41773>>>        Unlock
41774>>>>
41774>>>        Close hTable
41775>>>        
41775>>>        Move (not(Err)) to bOK
41776>>>        Move bErr to Err
41777>>>        
41777>>>        Function_Return bOK
41778>>>    End_Function
41779>>>    
41779>>>    // Deletes all records for the passed sIntFileName value,
41779>>>    // from the phIntFilesTable.
41779>>>    // Returns True if no errors occured.
41779>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
41781>>>        Handle hTable
41781>>>        Boolean bOK bErr bFound
41781>>>        Integer iFileCol iIndex
41781>>>        String sVal
41781>>>        String[] asIntFile
41782>>>        
41782>>>        Move Err to bErr
41783>>>        Move False to Err
41784>>>        Move False to bOK
41785>>>        Move 2              to iFileCol
41786>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
41787>>>        Get phIntFilesTable to hTable  
41788>>>        Open hTable  
41790>>>                  
41790>>>        // Find the first record
41790>>>        Set_Field_Value hTable iFileCol to sIntFileName
41793>>>        Vfind hTable iIndex GE
41795>>>        Get_Field_Value hTable iFileCol to sVal
41798>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
41799>>>        While (bFound = True)
41803>>>            Delete hTable
41804>>>            Vfind hTable iIndex GT
41806>>>            Get_Field_Value hTable iFileCol to sVal
41809>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
41810>>>        Loop
41811>>>>
41811>>>        Unlock
41812>>>>
41812>>>        Close hTable
41813>>>        
41813>>>        Move (not(Err)) to bOK
41814>>>        Move bErr to Err
41815>>>        
41815>>>        Function_Return bOK
41816>>>    End_Function
41817>>>
41817>>>    // Returns all saved phIntFilesTable records for the passed 
41817>>>    // sIntFileName value as a string array.
41817>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
41819>>>        Handle hTable
41819>>>        Boolean bOK bErr bFound
41819>>>        Integer iFileCol iTextCol iIndex
41819>>>        String sVal sFileName
41819>>>        String[] asIntFile asEmptyArray
41821>>>        
41821>>>        Move Err to bErr
41822>>>        Move False to Err
41823>>>        Move False to bOK
41824>>>        Move 2              to iFileCol
41825>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
41826>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
41827>>>        Get phIntFilesTable to hTable  
41828>>>        Open hTable  
41830>>>
41830>>>        // Find the first record
41830>>>        Set_Field_Value hTable iFileCol to sIntFileName
41833>>>        Vfind hTable iIndex GE
41835>>>        Get_Field_Value hTable iFileCol to sFileName
41838>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
41839>>>        While (bFound = True)
41843>>>            Get_Field_Value hTable iFileCol to sFileName
41846>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
41847>>>            If (bFound = True) Begin
41849>>>                Get_Field_Value hTable iTextCol to sVal
41852>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
41853>>>            End
41853>>>>
41853>>>            Vfind hTable iIndex GT
41855>>>        Loop
41856>>>>
41856>>>        
41856>>>        Close hTable
41857>>>        Move (not(Err)) to bOK
41858>>>        If (bOK = False) Begin
41860>>>            Move asEmptyArray to asIntFile
41861>>>        End
41861>>>>
41861>>>        Move bErr to Err               
41862>>>        
41862>>>        Function_Return asIntFile
41863>>>    End_Function
41864>>>
41864>>>    // Reads the passed sIntFileName from disk and returns its value
41864>>>    // as a string array.
41864>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
41866>>>        String[] asIntFile       
41867>>>        String sFileName sLine
41867>>>        Integer iCh iSize iCount
41867>>>        
41867>>>        Get vFolderFormat sPath to sPath
41868>>>        If (not(sIntFileName contains ".")) Begin
41870>>>            Move (sIntFileName + ".int") to sIntFileName
41871>>>        End
41871>>>>
41871>>>        Move (sPath + sIntFileName) to sFileName
41872>>>        Get Seq_Open_input_Channel sFileName to iCh
41873>>>        If (iCh < 0) Begin
41875>>>            Function_Return asIntFile
41876>>>        End                                 
41876>>>>
41876>>>        
41876>>>        Repeat
41876>>>>
41876>>>            Readln channel iCh sLine
41878>>>            If (SeqEof = False) Begin
41880>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
41881>>>            End
41881>>>>
41881>>>        Until (SeqEof = True)
41883>>>        Send Seq_Close_Channel iCh    
41884>>>        
41884>>>        Function_Return asIntFile
41885>>>    End_Function
41886>>>    
41886>>>    // Reads the Filelist.cfg from memeory as a resource.
41886>>>    // The Filelist.cfg has been compiled into the program.
41886>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
41888>>>        Integer iCh iCount
41888>>>        Number nByteCount
41888>>>        String[] asFileListArray sEmptyArray
41890>>>        String sLine
41890>>>        UChar[] uCharData
41891>>>        
41891>>>        Move False to Err
41892>>>        Get Seq_New_Channel to iCh
41893>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
41895>>>            Error DFERR_PROGRAM 'No channel available...'
41896>>>>
41896>>>            Function_Return sEmptyArray
41897>>>        End
41897>>>>
41897>>>
41897>>>        // First decide the size of the script
41897>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
41899>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
41901>>>        Close_Input channel iCh
41903>>>        Send Seq_Release_Channel iCh
41904>>>
41904>>>        Function_Return uCharData
41905>>>    End_Function    
41906>>>    
41906>>>    // Writes a copy of the workspace Filelist.cfg to disk.
41906>>>    // It does so by reading from a memory resource, as the file has
41906>>>    // been compiled into the program.
41906>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
41908>>>        Boolean bOK bErr
41908>>>        Integer iSize iCh
41908>>>        
41908>>>        Move Err to bErr
41909>>>        Move False to Err
41910>>>        Move False to bOK
41911>>>        Move (SizeOfArray(asFileListArray)) to iSize
41912>>>        If (iSize = 0) Begin
41914>>>            Function_Return False
41915>>>        End
41915>>>>
41915>>>
41915>>>        Get Seq_New_Channel to iCh
41916>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
41918>>>            Error DFERR_PROGRAM 'No channel available...'
41919>>>>
41919>>>            Function_Return False
41920>>>        End                      
41920>>>>
41920>>>        
41920>>>        Direct_Output channel iCh sFileListName
41922>>>        Writeln channel iCh asFileListArray
41925>>>                
41925>>>        Close_Input channel iCh
41927>>>        Send Seq_Release_Channel iCh
41928>>>        Move (not(Err)) to bOK
41929>>>        Move bErr to Err
41930>>>        
41930>>>        Function_Return bOK
41931>>>    End_Function
41932>>>
41932>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
41932>>>    // It first deletes the .cch file (if any).
41932>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
41934>>>        Boolean bOK bFound bExists bErr
41934>>>        Integer iCh iSize iCount
41934>>>        String sFileName sCCHFileName sVal
41934>>>        String[] asIntFile
41935>>>        
41935>>>        Move Err to bErr   
41936>>>        Move False to Err
41937>>>        Move False to bOK
41938>>>
41938>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
41939>>>        Move (SizeOfArray(asIntFile)) to iSize
41940>>>        If (iSize = 0) Begin
41942>>>            Function_Return False        
41943>>>        End                      
41943>>>>
41943>>>        Decrement iSize
41944>>>        
41944>>>        Get Seq_New_Channel to iCh
41945>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
41947>>>            Function_Return False
41948>>>        End   
41948>>>>
41948>>>        
41948>>>        // Before we start to actually create the new .int file, make sure we delete
41948>>>        // the .cch file first.                                     
41948>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
41949>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
41950>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
41951>>>        If (bExists = True) Begin
41953>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
41954>>>            If (bOK = False) Begin
41956>>>                Function_Return False
41957>>>            End
41957>>>>
41957>>>        End
41957>>>>
41957>>>        
41957>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
41959>>>        For iCount from 0 to iSize
41965>>>>
41965>>>            Writeln channel iCh asIntFile[iCount]
41968>>>        Loop
41969>>>>
41969>>>        
41969>>>        Close_Input channel iCh
41971>>>        Send Seq_Release_Channel iCh
41972>>>        Move (not(Err)) to bOK
41973>>>        Move bErr to Err
41974>>>        
41974>>>        Function_Return bOK
41975>>>    End_Function   
41976>>>              
41976>>>    // Automatically writes .int files to disk that is missing.
41976>>>    // We only need to make this test this once, but because the message is called
41976>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
41976>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
41976>>>    Procedure AutoCreateIntFilesTable 
41978>>>        Integer hTable 
41978>>>        Boolean bIntFilesTablesCheckDone bTableExists
41978>>>        String sInfoTxt 
41978>>>        
41978>>>        Get phIntFilesTable to hTable  
41979>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
41980>>>        If (bIntFilesTablesCheckDone = True) Begin
41982>>>            Procedure_Return
41983>>>        End
41983>>>>
41983>>>
41983>>>        If (hTable < 1) Begin
41985>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
41986>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
41987>>>>
41987>>>            Procedure_Return
41988>>>        End
41988>>>>
41988>>>
41988>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
41989>>>        If (bTableExists = True) Begin
41991>>>            Set Private.pbIntFilesTablesCheckDone to True
41992>>>            Procedure_Return
41993>>>        End
41993>>>>
41993>>>
41993>>>        Send CreateIntFilesTable hTable
41994>>>
41994>>>        Set Private.pbIntFilesTablesCheckDone to True
41995>>>    End_Function
41996>>>                
41996>>>    Procedure CreateIntFilesTable Handle hTable
41998>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
41998>>>        Boolean bTableExists bOK bUseConnectionID bExists
41998>>>        tAPIColumn[] APIColumn
41998>>>        tAPIColumn[] APIColumn
41999>>>
41999>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
42000>>>        If (bTableExists = True) Begin
42002>>>            Procedure_Return
42003>>>        End
42003>>>>
42003>>>
42003>>>        Move False to Err
42004>>>        Get psDriverID to sDriverID
42005>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
42006>>>
42006>>>        Move CS_IntFilesTableRootName to sTableName
42007>>>
42007>>>        Move 1                  to APIColumn[0].iFieldNumber
42008>>>        Move "ID"               to APIColumn[0].sFieldName
42009>>>        Move DF_BCD             to APIColumn[0].iType
42010>>>        Move False              to APIColumn[0].bIsSQLType
42011>>>        Move 12                 to APIColumn[0].iLength
42012>>>        Move 0                  to APIColumn[0].iPrecision
42013>>>
42013>>>        Move 2                  to APIColumn[1].iFieldNumber
42014>>>        Move "IntFileName"      to APIColumn[1].sFieldName
42015>>>        Move DF_ASCII           to APIColumn[1].iType
42016>>>        Move False              to APIColumn[1].bIsSQLType
42017>>>        Move 50                 to APIColumn[1].iLength
42018>>>        Move 0                  to APIColumn[1].iPrecision
42019>>>
42019>>>        Move 3                  to APIColumn[2].iFieldNumber
42020>>>        Move "IntLineText"      to APIColumn[2].sFieldName
42021>>>        Move DF_ASCII           to APIColumn[2].iType
42022>>>        Move False              to APIColumn[2].bIsSQLType
42023>>>        Move 100                to APIColumn[2].iLength
42024>>>        Move 0                  to APIColumn[2].iPrecision
42025>>>
42025>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
42026>>>        
42026>>>        If (bOK = True and Err = False) Begin
42028>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
42029>>>        End
42029>>>>
42029>>>        Else Begin
42030>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
42031>>>            Error sInfoTxt
42032>>>>
42032>>>            Procedure_Return
42033>>>        End
42033>>>>
42033>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
42034>>>
42034>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
42035>>>        If (bOK = True) Begin
42037>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
42038>>>        End
42038>>>>
42038>>>        If (bOK = False) Begin
42040>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
42041>>>            Error sInfoTxt
42042>>>>
42042>>>            Procedure_Return
42043>>>        End                    
42043>>>>
42043>>>        
42043>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
42043>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
42044>>>        Get vFolderFormat sDataPath to sDataPath
42045>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
42046>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
42047>>>        If (bExists = True) Begin
42049>>>            Move CS_IntFilesTableRootName to sTableName
42050>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
42051>>>            If (bExists = True) Begin
42053>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
42054>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
42055>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
42056>>>            End
42056>>>>
42056>>>        End
42056>>>>
42056>>>        
42056>>>    End_Procedure
42057>>>
42057>>>    Procedure CheckAutoCreateDbVersionTable
42059>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
42059>>>        Integer iDbVersionFileNumber
42059>>>
42059>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
42060>>>        If (bDbVersionCheckDone = True) Begin
42062>>>            Procedure_Return
42063>>>        End
42063>>>>
42063>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
42064>>>        If (bUseCustomDbVersion = True) Begin
42066>>>            Procedure_Return
42067>>>        End
42067>>>>
42067>>>
42067>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
42068>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
42070>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42071>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
42072>>>>
42072>>>            Send Exit_Application
42073>>>        End
42073>>>>
42073>>>
42073>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
42074>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
42075>>>        If (bTableExists = True) Begin
42077>>>            Set Private.pbDbVersionCheckDone to True
42078>>>            Procedure_Return
42079>>>        End
42079>>>>
42079>>>
42079>>>        Send CreateDbVersionTable iDbVersionFileNumber
42080>>>
42080>>>        // We only need to these DbVersion checks once, but because this message is called
42080>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
42080>>>        // we use a property to only run these tests once.
42080>>>        Set Private.pbDbVersionCheckDone to True
42081>>>    End_Procedure
42082>>>
42082>>>    Procedure CreateDbVersionTable Handle hTable
42084>>>        String sTableName sColumnName sInfoTxt sDriverID 
42084>>>        Boolean bTableExists bOK bUseConnectionID
42084>>>        tAPIColumn[] APIColumn
42084>>>        tAPIColumn[] APIColumn
42085>>>
42085>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
42086>>>        If (bTableExists = True) Begin
42088>>>            Procedure_Return
42089>>>        End
42089>>>>
42089>>>
42089>>>        Get psDriverID to sDriverID
42090>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
42091>>>
42091>>>        Move "DbVersion"        to sTableName
42092>>>        Move 1                  to APIColumn[0].iFieldNumber
42093>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
42094>>>        Move DF_BCD             to APIColumn[0].iType
42095>>>        Move False              to APIColumn[0].bIsSQLType
42096>>>        Move 4                  to APIColumn[0].iLength
42097>>>        Move 2                  to APIColumn[0].iPrecision
42098>>>
42098>>>        Move False to Err                                
42099>>>        
42099>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
42099>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
42099>>>        Set psDriverID to DATAFLEX_ID
42100>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
42101>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
42102>>>        Set psDriverID to sDriverID
42103>>>        
42103>>>        If (bOK = True and Err = False) Begin
42105>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
42105>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
42106>>>        End
42106>>>>
42106>>>        Else Begin
42107>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
42108>>>        End
42108>>>>
42108>>>
42108>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
42109>>>    End_Procedure
42110>>>
42110>>>    Procedure Set pbVerboseState Boolean bVerboseState
42112>>>        Handle ho
42112>>>        Get phoLogFile to ho
42113>>>        Set pbVerboseState of ho to bVerboseState
42114>>>    End_Procedure
42115>>>
42115>>>    Function pbVerboseState Returns Boolean
42117>>>        Boolean bVerboseState
42117>>>        Handle ho
42117>>>        Get phoLogFile to ho
42118>>>        Get pbVerboseState of ho to bVerboseState
42119>>>        Function_Return bVerboseState
42120>>>    End_Function
42121>>>
42121>>>    // Callback functionality used when e.g. calling driver functions directly.
42121>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
42121>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
42123>>>        Integer iPerc
42123>>>        Number nReady nTotal nVersion
42123>>>        Boolean bVerboseState
42123>>>        Handle hoLogFile
42123>>>
42123>>>        Get pbVerboseState to bVerboseState
42124>>>        Get pnCurrentVersionUpdate to nVersion
42125>>>        Get phoLogFile     to hoLogFile
42126>>>        Send DoAdvance of ghoProgressBar
42127>>>
42127>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
42129>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
42130>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
42131>>>        End
42131>>>>
42131>>>        If (sCallback_Text contains "Creating index") Begin
42133>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
42134>>>        End
42134>>>>
42134>>>
42134>>>        Case Begin
42134>>>            Case (iCallback_Type = DF_Message_Text)
42136>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42137>>>                Set Action_Text  of ghoStatusPanel to ""
42138>>>                If (bVerboseState = True) Begin
42140>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42141>>>                End
42141>>>>
42141>>>                Case Break
42142>>>            Case (iCallback_Type = DF_Message_Heading_1)
42145>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42146>>>                If (bVerboseState = True) Begin
42148>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42149>>>                End
42149>>>>
42149>>>                Case Break
42150>>>            Case (iCallback_Type = DF_Message_Heading_2)
42153>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42154>>>                Set Action_Text  of ghoStatusPanel to ""
42155>>>                If (bVerboseState = True) Begin
42157>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42158>>>                End
42158>>>>
42158>>>                Case Break
42159>>>            Case (iCallback_Type = DF_Message_Heading_3)
42162>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42163>>>                Set Action_Text  of ghoStatusPanel to ""
42164>>>                If (bVerboseState = True) Begin
42166>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42167>>>                End
42167>>>>
42167>>>                Case Break
42168>>>            Case (iCallback_Type = DF_Message_Heading_4)
42171>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42172>>>                Set Action_Text  of ghoStatusPanel to ""
42173>>>                If (bVerboseState = True) Begin
42175>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42176>>>                End
42176>>>>
42176>>>                Case Break
42177>>>            Case (iCallback_Type = DF_Message_Heading_5)
42180>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42181>>>                Set Action_Text  of ghoStatusPanel to ""
42182>>>                If (bVerboseState = True) Begin
42184>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42185>>>                End
42185>>>>
42185>>>                Case Break
42186>>>            Case (iCallback_Type = DF_Message_Warning)
42189>>>                If (bVerboseState = True) Begin
42191>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42192>>>                End
42192>>>>
42192>>>                Case Break
42193>>>            Case (iCallback_Type = DF_Message_Progress_Title)
42196>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
42197>>>                Set Action_Text  of ghoStatusPanel to ""
42198>>>                If (bVerboseState = True) Begin
42200>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
42201>>>                End
42201>>>>
42201>>>                Case Break
42202>>>            Case (iCallback_Type = DF_Message_Progress_Value)
42205>>>                //*** Interpret numbers
42205>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
42206>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
42207>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
42208>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
42209>>>                Set piPosition of ghoProgressBar to iPerc
42210>>>                Case Break
42211>>>            Case Else
42211>>>                Set Message_Text to ""
42212>>>                Set Action_Text  to ""
42213>>>        Case End
42213>>>
42213>>>        Send ProcessEvents of ghoStatusPanel
42214>>>        Function_Return False
42215>>>    End_Function
42216>>>
42216>>>    // This was made to be a procedure/function pair so we
42216>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
42216>>>
42216>>>    Procedure Set piDbType Integer iDbType
42218>>>        If (ghoSQLConnectionHandler = 0) Begin
42220>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42221>>>>
42221>>>            Procedure_Return
42222>>>        End
42222>>>>
42222>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
42223>>>    End_Procedure
42224>>>
42224>>>    Function piDbType Returns Integer
42226>>>        Integer iDbType
42226>>>        If (ghoSQLConnectionHandler = 0) Begin
42228>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42229>>>>
42229>>>            Function_Return ""
42230>>>        End
42230>>>>
42230>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
42231>>>        Function_Return iDbType
42232>>>    End_Function
42233>>>
42233>>>    Procedure Set psDriverID String sDriverID
42235>>>        If (ghoSQLConnectionHandler = 0) Begin
42237>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42238>>>>
42238>>>            Procedure_Return
42239>>>        End
42239>>>>
42239>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
42240>>>    End_Procedure
42241>>>
42241>>>    Function psDriverID Returns String
42243>>>        String sValue
42243>>>        If (ghoSQLConnectionHandler = 0) Begin
42245>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42246>>>>
42246>>>            Function_Return ""
42247>>>        End
42247>>>>
42247>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
42248>>>        Function_Return sValue
42249>>>    End_Function
42250>>>
42250>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
42252>>>        If (ghoSQLConnectionHandler = 0) Begin
42254>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42255>>>>
42255>>>            Procedure_Return
42256>>>        End
42256>>>>
42256>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
42257>>>    End_Procedure
42258>>>
42258>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
42260>>>        Integer iRetval
42260>>>        If (ghoSQLConnectionHandler = 0) Begin
42262>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42263>>>>
42263>>>            Function_Return 2
42264>>>        End
42264>>>>
42264>>>
42264>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
42265>>>        Function_Return iRetval
42266>>>    End_Function
42267>>>
42267>>>    Procedure Set psConnectionID String sValue
42269>>>        If (ghoSQLConnectionHandler = 0) Begin
42271>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42272>>>>
42272>>>            Procedure_Return
42273>>>        End
42273>>>>
42273>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
42274>>>    End_Procedure
42275>>>
42275>>>    Function psConnectionID Returns String
42277>>>        String sValue
42277>>>        If (ghoSQLConnectionHandler = 0) Begin
42279>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42280>>>>
42280>>>            Function_Return ""
42281>>>        End
42281>>>>
42281>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
42282>>>
42282>>>        Function_Return sValue
42283>>>    End_Function
42284>>>
42284>>>    // These "properties" are settings of the cCLIHandler class, but are being
42284>>>    // relayed to the ghoSQLConnectionHandler object
42284>>>    // simply by changing one of its parameters.
42284>>>    Procedure Set psServer String sValue
42286>>>        If (ghoSQLConnectionHandler = 0) Begin
42288>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42289>>>>
42289>>>            Procedure_Return
42290>>>        End
42290>>>>
42290>>>        Set psServer of ghoSQLConnectionHandler to sValue
42291>>>    End_Procedure
42292>>>
42292>>>    Function psServer Returns String
42294>>>        String sValue
42294>>>        If (ghoSQLConnectionHandler = 0) Begin
42296>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42297>>>>
42297>>>            Function_Return ""
42298>>>        End
42298>>>>
42298>>>        Get psServer of ghoSQLConnectionHandler to sValue
42299>>>
42299>>>        Function_Return sValue
42300>>>    End_Function
42301>>>
42301>>>    Procedure Set psDatabase String sValue
42303>>>        If (ghoSQLConnectionHandler = 0) Begin
42305>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42306>>>>
42306>>>            Procedure_Return
42307>>>        End
42307>>>>
42307>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
42308>>>    End_Procedure
42309>>>
42309>>>    Function psDatabase Returns String
42311>>>        String sValue
42311>>>        If (ghoSQLConnectionHandler = 0) Begin
42313>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42314>>>>
42314>>>            Function_Return ""
42315>>>        End
42315>>>>
42315>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
42316>>>
42316>>>        Function_Return sValue
42317>>>    End_Function
42318>>>
42318>>>    Procedure Set psUserID String sValue
42320>>>        If (ghoSQLConnectionHandler = 0) Begin
42322>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42323>>>>
42323>>>            Procedure_Return
42324>>>        End
42324>>>>
42324>>>        Set psUserID of ghoSQLConnectionHandler to sValue
42325>>>    End_Procedure
42326>>>
42326>>>    Function psUserID Returns String
42328>>>        String sValue
42328>>>        If (ghoSQLConnectionHandler = 0) Begin
42330>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42331>>>>
42331>>>            Function_Return ""
42332>>>        End
42332>>>>
42332>>>        Get psUserID of ghoSQLConnectionHandler to sValue
42333>>>
42333>>>        Function_Return sValue
42334>>>    End_Function
42335>>>
42335>>>    Procedure Set psPassword String sValue
42337>>>        If (ghoSQLConnectionHandler = 0) Begin
42339>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42340>>>>
42340>>>            Procedure_Return
42341>>>        End
42341>>>>
42341>>>        Set psPassword of ghoSQLConnectionHandler to sValue
42342>>>    End_Procedure
42343>>>
42343>>>    Function psPassword Returns String
42345>>>        String sValue
42345>>>        If (ghoSQLConnectionHandler = 0) Begin
42347>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42348>>>>
42348>>>            Function_Return ""
42349>>>        End
42349>>>>
42349>>>        Get psPassword of ghoSQLConnectionHandler to sValue
42350>>>
42350>>>        Function_Return sValue
42351>>>    End_Function
42352>>>
42352>>>    Procedure Set pbTrusted Boolean bValue
42354>>>        If (ghoSQLConnectionHandler = 0) Begin
42356>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42357>>>>
42357>>>            Procedure_Return
42358>>>        End
42358>>>>
42358>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
42359>>>    End_Procedure
42360>>>
42360>>>    Function pbTrusted Returns Boolean
42362>>>        Boolean bValue
42362>>>        If (ghoSQLConnectionHandler = 0) Begin
42364>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42365>>>>
42365>>>            Function_Return False
42366>>>        End
42366>>>>
42366>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
42367>>>
42367>>>        Function_Return bValue
42368>>>    End_Function
42369>>>
42369>>>    Procedure Set psConnectionString String sValue
42371>>>        If (ghoSQLConnectionHandler = 0) Begin
42373>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42374>>>>
42374>>>            Procedure_Return
42375>>>        End
42375>>>>
42375>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
42376>>>    End_Procedure
42377>>>
42377>>>    Function psConnectionString Returns String
42379>>>        String sValue
42379>>>        If (ghoSQLConnectionHandler = 0) Begin
42381>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42382>>>>
42382>>>            Function_Return ""
42383>>>        End
42383>>>>
42383>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
42384>>>
42384>>>        Function_Return sValue
42385>>>    End_Function
42386>>>
42386>>>    Function piConnectionOptions Returns Integer
42388>>>        Integer iValue
42388>>>        If (ghoSQLConnectionHandler = 0) Begin
42390>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
42391>>>>
42391>>>            Function_Return 0
42392>>>        End
42392>>>>
42392>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
42393>>>
42393>>>        Function_Return iValue
42394>>>    End_Function
42395>>>
42395>>>
42395>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
42397>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
42398>>>    End_Procedure
42399>>>
42399>>>    Function pbCheckDataFlexUserCount Returns Boolean
42401>>>        Boolean bState
42401>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
42402>>>        Function_Return bState
42403>>>    End_Function
42404>>>
42404>>>    Procedure Set psLogTextFile String sValue
42406>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
42407>>>    End_Procedure
42408>>>
42408>>>    Function psLogTextFile Returns String
42410>>>        String sValue
42410>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
42411>>>        Function_Return sValue
42412>>>    End_Function
42413>>>
42413>>>    Procedure Set psEditorProgram String sValue
42415>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
42416>>>    End_Procedure
42417>>>
42417>>>    Function psEditorProgram Returns String
42419>>>        String sValue
42419>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
42420>>>        Function_Return sValue
42421>>>    End_Function
42422>>>
42422>>>    Procedure Set pbUseDataTableLog Boolean bState
42424>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
42425>>>    End_Procedure
42426>>>
42426>>>    Function pbUseDataTableLog Returns Boolean
42428>>>        Boolean bState
42428>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
42429>>>        Function_Return bState
42430>>>    End_Function
42431>>>
42431>>>    Procedure Set pbQuickWrite Boolean bState
42433>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
42434>>>    End_Procedure
42435>>>
42435>>>    Function pbQuickWrite Returns Boolean
42437>>>        Boolean bState
42437>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
42438>>>        Function_Return bState
42439>>>    End_Function
42440>>>
42440>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
42442>>>        Boolean bUpdateVersionObjectError bVerboseState
42442>>>        Integer iSize iCount
42442>>>        Number nVersion
42442>>>        String[] aSQLQueryMessages
42443>>>
42443>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
42444>>>        Set Private.pbDatabaseWasUpdated to bState
42445>>>        // If no errors occurred in the current cDbUpdateVersion object - write
42445>>>        // to the log that it was OK.
42445>>>        If (bUpdateVersionObjectError = False) Begin
42447>>>            Get pnCurrentVersionUpdate to nVersion
42448>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
42449>>>        End
42449>>>>
42449>>>
42449>>>        Get pbVerboseState to bVerboseState
42450>>>        If (bVerboseState = True) Begin
42452>>>            Get paSQLQueryMessages to aSQLQueryMessages
42453>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
42454>>>            Decrement iSize
42455>>>            For iCount from 0 to iSize
42461>>>>
42461>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
42462>>>            Loop
42463>>>>
42463>>>        End
42463>>>>
42463>>>
42463>>>    End_Procedure 
42464>>>    
42464>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
42466>>>        Set Private.piDbVersionFileNumber to iFileNumber
42467>>>    End_Procedure                                         
42468>>>    
42468>>>    Function piDbVersionFileNumber Returns Integer
42470>>>        Function_Return (Private.piDbVersionFileNumber(Self))
42471>>>    End_Function
42472>>>
42472>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
42474>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
42475>>>    End_Procedure                                         
42476>>>    
42476>>>    Function piDbVersionFieldNumber Returns Integer
42478>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
42479>>>    End_Function
42480>>>
42480>>>    Function pbDatabaseWasUpdated Returns Boolean
42482>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
42483>>>    End_Function
42484>>>    
42484>>>    //
42484>>>    Procedure ReinitializeFramework  
42486>>>        tDbVersionInfo[] aDbVersionInfoArray
42486>>>        tDbVersionInfo[] aDbVersionInfoArray
42487>>>        Handle hoDbVersionObject
42487>>>        Integer iSize iCount
42487>>>        
42487>>>        Set Private.pbDatabaseUpdateStarted to False
42488>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
42489>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
42490>>>        Decrement iSize
42491>>>        
42491>>>        For iCount from 0 to iSize
42497>>>>
42497>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
42498>>>            Send ProcessUpdate                  of hoDbVersionObject False
42499>>>        Loop
42500>>>>
42500>>>        Send Cleanup
42501>>>    End_Procedure
42502>>>    
42502>>>    // This event is triggered by the cDbUpdateVersion child class when
42502>>>    // a database change is to be started, and is considered private.
42502>>>    // It is only executed once for the first cDbUpateVersion object!
42502>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
42504>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
42504>>>        Integer iRetval iDataFlexUsers iUserCount
42504>>>        Handle hoUserCountSystem
42504>>>        tUserCount UserCount
42504>>>        tUserCount UserCount
42504>>>        DateTime dtUpdateStarted
42504>>>        tSQLConnection SQLConnection
42504>>>        tSQLConnection SQLConnection
42504>>>
42504>>>        // *Important:* If we already started the update; we do no further checking.
42504>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
42505>>>        If (bDatabaseUpdateStarted = True) Begin
42507>>>            Procedure_Return
42508>>>        End
42508>>>>
42508>>>
42508>>>        // If not silent mode; Ask user if OK to start database update.
42508>>>        If (pbSilentMode(Self) = False) Begin
42510>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
42511>>>            If (iRetval <> MBR_Yes) Begin
42513>>>                Send Exit_Application
42514>>>            End
42514>>>>
42514>>>        End
42514>>>>
42514>>>        
42514>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
42515>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
42516>>>        Send Start_StatusPanel      of ghoStatusPanel
42517>>>
42517>>>        // This will save the status of all open tables including Master/Alias settings,
42517>>>        // so we can restore them later;
42517>>>        Send SaveOpenTables
42518>>>
42518>>>        Move 0 to iDataFlexUsers
42519>>>        // Make various tests to check that the database is not in use.
42519>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
42520>>>        // We also use our own user counting mechanism to guard against the
42520>>>        // database isn't opened already as we need exclusive access to the tables.:
42520>>>        Get phoUserCountSystem to hoUserCountSystem
42521>>>        Get CheckUserCount of hoUserCountSystem to UserCount
42522>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
42523>>>
42523>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
42524>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
42524>>>        If (bCheckDataFlexUserCount = True) Begin
42526>>>            Get_Current_User_Count to iDataFlexUsers
42527>>>            // For some reason DataFlex - in some cases - might think that 2 users
42527>>>            // are in use while debugging from the Studio.
42527>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
42529>>>                Decrement iDataFlexUsers
42530>>>            End
42530>>>>
42530>>>        End 
42530>>>>
42530>>>        Else Begin
42531>>>            Move 1 to iDataFlexUsers 
42532>>>            Move 1 to iUserCount
42533>>>            Move False to bInUse
42534>>>        End
42534>>>>
42534>>>
42534>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
42536>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
42537>>>            If (iRetval <> MBR_Yes) Begin
42539>>>                Send Exit_Application
42540>>>            End
42540>>>>
42540>>>        End
42540>>>>
42540>>>
42540>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
42542>>>            Send Stop_Box CS_DUF_DatabaseInUseText
42543>>>            Send Exit_Application
42544>>>        End
42544>>>>
42544>>>
42544>>>        // This will put a look on the DbUpdateLock.ucf file.
42544>>>        // It is released when the update process is finished
42544>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
42545>>>
42545>>>        Move (CurrentDateTime()) to dtUpdateStarted
42546>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
42547>>>        Set Private.pbDatabaseUpdateStarted to True
42548>>>
42548>>>        // We need to close all tables before starting to make changes.
42548>>>        Close DF_ALL DF_PERMANENT
42549>>>
42549>>>        // If these properties has not exclicitly been set in the object, set them
42549>>>        // to settings from the SQLConnections.ini file;
42549>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
42550>>>        If (psSchema(Self) = "") Begin
42552>>>            Set psSchema            to SQLConnection.sSchema
42553>>>        End
42553>>>>
42553>>>        If (psBaseTableSpace(Self) = "") Begin
42555>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
42556>>>        End
42556>>>>
42556>>>        If (psLongTableSpace(Self) = "") Begin
42558>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
42559>>>        End
42559>>>>
42559>>>        If (psIndexTableSpace(Self) = "") Begin
42561>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
42562>>>        End
42562>>>>
42562>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
42564>>>            Procedure_Return
42565>>>        End
42565>>>>
42565>>>
42565>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
42566>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
42568>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42569>>>            Send Stop_StatusPanel of ghoStatusPanel
42570>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
42570>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
42571>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
42571>>>            Send Exit_Application
42572>>>        End
42572>>>>
42572>>>    End_Procedure
42573>>>
42573>>>    // *** Hook message for pre-processing ***
42573>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
42573>>>    // Aka, when another table than the standard "DbVersion" is used.
42573>>>    Procedure OnCreateCustomDbVersionTable
42575>>>    End_Procedure
42576>>>    
42576>>>    // *** Hook message for pre-processing ***
42576>>>    // The programmer can use this event for putting code that
42576>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
42576>>>    // child objects are executed.
42576>>>    Procedure OnPreUpdate
42578>>>    End_Procedure
42579>>>
42579>>>    // *** Hook message for post-processing ***
42579>>>    // The programmer should use this event for putting code that
42579>>>    // needs to be executed _after_ all database updates have finished.
42579>>>    Procedure OnPostUpdate
42581>>>    End_Procedure
42582>>>
42582>>>    // *** Hook message for custom DbVersion record find ***
42582>>>    // The programmer can use this event for putting code that
42582>>>    // needs to be executed to find a *custom* DbVersion table record.
42582>>>    // By default the DbVersion table is used but this can be
42582>>>    // customized by adding this line to the code;
42582>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
42582>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
42582>>>    //       to save the current database version to. Only if you use your own
42582>>>    //       table _and_ it is not a system table (contains only one record).
42582>>>    Procedure OnFindVersionRecord
42584>>>        // Open MyTable
42584>>>        // Move xx to MyTable.Field1
42584>>>        // Move yy to MyTable.Field2
42584>>>        // Find le MyTable by Index.x
42584>>>    End_Procedure
42585>>>
42585>>>    // Hook event for writing header error text (pre-update) to
42585>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
42585>>>    // Don't forget to Open the table first (!) as all
42585>>>    // tables have been closed at this stage.
42585>>>    // The start date & time is passed.
42585>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
42587>>>    End_Procedure
42588>>>
42588>>>    // Hook event to log errors to a database table.
42588>>>    // Only called if the pbUseDataTableLog = True.
42588>>>    // Don't forget to Open the table first (!) as all
42588>>>    // tables have been closed at this stage.
42588>>>    // If pbQuickWrite = True the DbUpdateErrorArray
42588>>>    // will contain just one row, as it is called for each error
42588>>>    // that occurred. Else it is called once at the end after all updates
42588>>>    // have run and contains all errors.
42588>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
42590>>>    End_Procedure
42591>>>
42591>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
42591>>>    Procedure Cleanup
42593>>>        Boolean bDatabaseWasUpdated bError
42593>>>
42593>>>        Send CheckAutoCreateDbVersionTable
42594>>>        Send RestoreOpenTables
42595>>>
42595>>>        // The function library have two purposes; one is to use it in the
42595>>>        // Database Update Framework, but it can also be used on its own.
42595>>>        // If that is the case it has its own error handling system, which
42595>>>        // we temporarily disbled when running updates because we have
42595>>>        // error handling/logging here too... We now restore its setting.
42595>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
42597>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
42598>>>        End
42598>>>>
42598>>>        Set pbHandleQueryErrors to True
42599>>>
42599>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
42600>>>        Get pbDbUpdateErrorHasOccured to bError
42601>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
42603>>>
42603>>>            // We should always create the log as it also contains info about
42603>>>            // the update being successful.
42603>>>            Send WriteErrorLog of (phoLogFile(Self))
42604>>>
42604>>>            // This is a programmer's hook message:
42604>>>            Send OnPostUpdate
42605>>>
42605>>>            Send Stop_StatusPanel of ghoStatusPanel
42606>>>
42606>>>            If (pbSilentMode(Self) = False) Begin
42608>>>                If (bError = True) Begin
42610>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
42612>>>                        Send ShowErrorLog of (phoLogFile(Self))
42613>>>                    End
42613>>>>
42613>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
42614>>>                    Send Exit_Application
42615>>>                End
42615>>>>
42615>>>                Else Begin
42616>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
42618>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
42619>>>                    End
42619>>>>
42619>>>                    Else Begin
42620>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
42621>>>                    End
42621>>>>
42621>>>
42621>>>                End
42621>>>>
42621>>>            End
42621>>>>
42621>>>        End
42621>>>>
42621>>>
42621>>>        // Restore the standard error handler:
42621>>>        Get piOrgErrorHandlerID to Error_Object_Id
42622>>>    End_Procedure
42623>>>
42623>>>    // We do this _before_ we close the database to make changes, and save
42623>>>    // all 'Master' & 'Alias' tables settings so we can restore when
42623>>>    // we reopen the database.
42623>>>    Procedure SaveOpenTables
42625>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42625>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42626>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
42627>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
42628>>>    End_Procedure
42629>>>
42629>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
42629>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
42629>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
42631>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42631>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42632>>>        Integer hTable iMasterAliasType iSize
42632>>>        Boolean bOpen
42632>>>
42632>>>        Move 0 to hTable
42633>>>        Repeat
42633>>>>
42633>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
42636>>>            If (hTable <> 0) Begin
42638>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
42641>>>                If (bOpen = True) Begin
42643>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
42646>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
42647>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
42648>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
42649>>>                End
42649>>>>
42649>>>            End
42649>>>>
42649>>>        Until (hTable = 0)
42651>>>
42651>>>        Function_Return aDbUpdateHandlerMasterAlias
42652>>>    End_Function
42653>>>
42653>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
42653>>>    // Takes one parameter:
42653>>>    //   A struct array with all master & alias
42653>>>    Procedure RestoreOpenTables
42655>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42655>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
42656>>>        Integer hTable iFileAlias iSize iCount
42656>>>        Boolean bOpen
42656>>>        String sRootName
42656>>>
42656>>>        Move 0 to hTable
42657>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
42658>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
42659>>>        Decrement iSize
42660>>>        For iCount from 0 to iSize
42666>>>>
42666>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
42667>>>            // We also need to check that the table hasn't been removed...
42667>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
42670>>>            If (hTable <> 0 and sRootName <> "") Begin
42672>>>                Open hTable
42674>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
42677>>>                If (bOpen = True) Begin
42679>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
42680>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
42682>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
42685>>>                    End
42685>>>>
42685>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
42688>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
42691>>>                    End
42691>>>>
42691>>>                End
42691>>>>
42691>>>            End
42691>>>>
42691>>>        Loop
42692>>>>
42692>>>    End_Procedure
42693>>>
42693>>>    // This checks for both duplicate pnVersionNumbers _and_ that
42693>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
42693>>>    Procedure CheckForDuplicates Number nVersion
42695>>>        tDbVersionInfo[] DbVersionInfoArray
42695>>>        tDbVersionInfo[] DbVersionInfoArray
42696>>>        Integer iCount iSize iHits iDuplicateIndex
42696>>>        Number nCompare
42696>>>        Handle hObject1 hObject2
42696>>>        String sObjectName1 sObjectName2
42696>>>        Boolean bObjectOrderError
42696>>>
42696>>>        Get paDbVersionInfoArray to DbVersionInfoArray
42697>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
42698>>>        Decrement iSize
42699>>>        Move 0 to iHits
42700>>>        Move 0 to nCompare
42701>>>        Move False to bObjectOrderError
42702>>>        For iCount from 0 to iSize
42708>>>>
42708>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
42710>>>                Increment iHits
42711>>>                If (iHits > 1) Begin
42713>>>                    Move iCount to iDuplicateIndex
42714>>>                    If (nCompare <> 0) Begin
42716>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
42717>>>                    End
42717>>>>
42717>>>                End
42717>>>>
42717>>>            End
42717>>>>
42717>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
42718>>>        Loop
42719>>>>
42719>>>        If (iHits > 1) Begin
42721>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42722>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
42723>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
42724>>>            Move (Name(hObject1)) to sObjectName1
42725>>>            Move (Name(hObject2)) to sObjectName2
42726>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
42727>>>>
42727>>>            Send Exit_Application
42728>>>        End
42728>>>>
42728>>>        Else If (bObjectOrderError = True) Begin
42731>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42732>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
42733>>>>
42733>>>            Send Exit_Application
42734>>>        End
42734>>>>
42734>>>    End_Procedure
42735>>>
42735>>>    // We take care of all errors in the Error_Report below and
42735>>>    // collect them all to an array property. So just ignore any
42735>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
42735>>>    // in some other package.
42735>>>    Procedure Ignore_Error Integer iError
42737>>>    End_Procedure
42738>>>
42738>>>    Procedure Trap_Error Integer iError
42740>>>    End_Procedure
42741>>>
42741>>>    // Build complete error description from Flexerrs and user error message.
42741>>>    Function Error_Description Integer Error# String ErrMsg Returns String
42743>>>        String Full_Error_Text
42743>>>        
42743>>>        Move (Trim(ErrMsg)) to ErrMsg
42744>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
42745>>>        
42745>>>        If (ErrMsg <> "") Begin
42747>>>            
42747>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
42749>>>                // Make sure last character of error text is a separating symbol.
42749>>>                // if not, add a "." So we have format of "error-text. error-detail"
42749>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
42752>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
42753>>>            End
42753>>>>
42753>>>            Else ;                Move ErrMsg to Full_Error_Text
42755>>>            
42755>>>        End
42755>>>>
42755>>>        
42755>>>        Function_Return Full_Error_Text
42756>>>    End_Function
42757>>>
42757>>>    // While we update the database we collect all errors in
42757>>>    // the struct array paDbUpdateErrorArray.
42757>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
42759>>>        Number nVersion
42759>>>        Handle hoLogFile 
42759>>>//        String sErrExtraText
42759>>>        
42759>>>        If (Private.pbProcessingError(Self)) Begin
42761>>>            Procedure_Return
42762>>>        End
42762>>>>
42762>>>
42762>>>        // The UtilTableNameFromHandleToString function does a:
42762>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
42762>>>        // and it generates an error if the table is of the embedded type.
42762>>>        // As we don't want to trigger an error in that very specific case,
42762>>>        // we just ignore it here.
42762>>>        //
42762>>>        // If no report mode, just set the err indicator to true.
42762>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
42764>>>            Move False to Err
42765>>>            Procedure_Return
42766>>>        End
42766>>>>
42766>>>
42766>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
42768>>>            Procedure_Return
42769>>>        End
42769>>>>
42769>>>
42769>>>        Set Private.pbProcessingError to True
42770>>>        Set Private.pbUpdateVersionObjectError to True
42771>>>
42771>>>        Set pbDbUpdateErrorHasOccured to True
42772>>>        Get pnCurrentVersionUpdate to nVersion
42773>>>        Get phoLogFile to hoLogFile
42774>>>//        Get Error_Description iErrorLine sErrorText to sErrorText
42774>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
42775>>>
42775>>>        Set Private.pbProcessingError to False
42776>>>    End_Procedure
42777>>>
42777>>>End_Class
42778>
42778>Object oApplication is a cApplication
42780>    Set psCompany to 'RDC Tools International'
42781>    Set psProduct to 'DUF Auto Update Program'
42782>    Set psProgram to 'Internal use/test of a DUF Update Package'
42783>    Set psVersion to '20.1'
42784>End_Object
42785>
42785>Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: 1 now?") to WindowIndex
42786>If (WindowIndex <> MBR_Yes) Begin
42788>    Send Exit_Application
42789>End
42789>
42789>Object oDbUpdateHandler is a cDbUpdateHandler
42791>    Set piDbVersionFileNumber  to 1
42792>    Set piDbVersionFieldNumber to 1
42793>    Set pbAutoCreateDbVersionTable to True
42794>
42794>//    Use DUF_MultipleTables1_0.pkg
42794>
42794>End_Object
42795>
42795>If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin
42797>   Send Info_Box 'Nothing to update. (Version number has not changed)'
42798>End
42798>
42798>Send Exit_Application
42799>// *** End-Of-Program Code ***
42799>
Including Resources...
Summary
Memory Available: 30575800320
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 25206
Total Resources: 6
Total Commands : 42798
Total Windows  : 0
Total Pages    : 0
Static Data    : 499677
Message area   : 202550
Total Blocks   : 17467
