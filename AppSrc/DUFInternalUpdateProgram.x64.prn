Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFInternalUpdateProgram.src
Memory Available: 103192047616
1>// *** DUF Auto-Generated Program - For Internal Usage Only! ***
1>// *** Use it to send to a collegue that is working on the same project, ***
1>// *** to update his/her database with database changes you have made. ***
1>    CompilerLevelWarning All On
1>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cApplication.pkg)
1>>>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\windows.x64.pkd)
8251>>>
8251>>>Use LanguageText.pkg
8251>>>Use WinUser.pkg
8251>>>Use WinShell.pkg
8251>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWorkspace.pkg)
8251>>>>>Use VdfBase.pkg
8251>>>>>Use tWinStructs.pkg
8251>>>>>Use LanguageText.pkg
8251>>>>>Use WinShell.pkg // Shell API functions
8251>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\seq_chnl.pkg)
8251>>>>>>>Use LanguageText.pkg
8251>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 24.0\Pkg\errornum.inc)
8251>>>>>>>>
8251>>>>>>>>//
8251>>>>>>>>// these will get defined in fmac
8251>>>>>>>>//
8251>>>>>>>>// already defined
8251>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
8251>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
8251>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
8251>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
8251>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
8251>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
8251>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
8251>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
8251>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
8251>>>>>>>>// new compiler errors used by fmac
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
8251>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
8251>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
8251>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
8251>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
8251>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
8251>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
8251>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
8251>>>>>>>>
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_STRING_CMD       |CI4531 // pertaining to string commands
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TYPE_CMD         |CI4532 // pertaining to type/end_type commands
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CMD              |CI4533 // pertaining to a more generic obsolete command 
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_GLOBAL_FUNCTION  |CI4534 // Global function is obsolete
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_TECHNIQUE        |CI4535 // Using some older technique
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_PACKAGE          |CI4536 // Package is obsolete, remove it if you can
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_CLASS            |CI4537 // Class is obsolete, remove it if you can
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_INDICATOR_USE    |CI4538 // Using indicators anywhere
8251>>>>>>>>//    
8251>>>>>>>>//    #Replace DFERR_COMP_ILLEGAL_CONVERSION                            |CI4539 // Datatype conversion is illegal, would cause runtime-error
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_OBSOLETE_OBJECT_FUNCTION  |CI4540 // Global function is obsolete
8251>>>>>>>>//    #Replace DFERR_INVALID_LOCALE_CODE                    |CI4541 // Error thown by Set_Attribute DF_LOCALE_CODE on invalid value
8251>>>>>>>>//    #Replace DFERR_STRING_COMPARISON_ERROR                |CI4542 // Error during string comparison (ICU returned an error)
8251>>>>>>>>//    #Replace DFERR_COMP_WARNING_REDEFINING_RETURN_TYPE    |CI4543 // Warning when redefining a function with a different return type
8251>>>>>>>>//    #Replace DFERR_COMP_AMBIGUOUS_FUNCTION_EXPRESSION     |CI4544 // Error when using ambiguous function in expression
8251>>>>>>>>    
8251>>>>>>>>
8251>>>>>>>>
8251>>>>>>>
8251>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8251>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8251>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8251>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8251>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8251>>>>>>>// so that programs that use direct_input/output
8251>>>>>>>// w/o specifying a channel will work.
8251>>>>>>>Enum_List
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8251>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8251>>>>>>>End_Enum_List
8251>>>>>>>
8251>>>>>>>Enum_List
8251>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8251>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8251>>>>>>>End_Enum_List
8251>>>>>>>
8251>>>>>>>Global_Variable Integer Seq$Channel$Error$Mode
8251>>>>>>>
8251>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer iMode
8253>>>>>>>    Move iMode to Seq$Channel$Error$Mode
8254>>>>>>>End_Procedure
8255>>>>>>>
8255>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8257>>>>>>>    Function_Return Seq$Channel$Error$Mode
8258>>>>>>>End_Function
8259>>>>>>>
8259>>>>>>>Global_Variable Integer[DF_SEQ_CHANNEL_MAX] giSeqChannelList
8259>>>>>>>// initialize array
8259>>>>>>>For WindowIndex from 0 to (DF_SEQ_CHANNEL_MAX-1)
8265>>>>>>>>
8265>>>>>>>    Move 0 to giSeqChannelList[WindowIndex]
8266>>>>>>>Loop
8267>>>>>>>>
8267>>>>>>>
8267>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8268>>>>>>>
8268>>>>>>>Function Seq_Channel_Mode Global Integer iChannel Returns Integer
8270>>>>>>>    Function_Return giSeqChannelList[iChannel]
8271>>>>>>>End_Function
8272>>>>>>>
8272>>>>>>>Procedure Set Seq_Channel_Mode Global Integer iChannel Integer iMode
8274>>>>>>>    Move iMode to giSeqChannelList[iChannel]
8275>>>>>>>End_Procedure
8276>>>>>>>
8276>>>>>>>Function Seq_New_Channel Global Returns Integer
8278>>>>>>>    Integer iObject iChannel
8278>>>>>>>    
8278>>>>>>>    Move DF_SEQ_START_CHANNEL to iChannel
8279>>>>>>>    
8279>>>>>>>    While (iChannel < DF_SEQ_CHANNEL_MAX)
8283>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8285>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8286>>>>>>>            Function_Return iChannel
8287>>>>>>>        End
8287>>>>>>>>
8287>>>>>>>        
8287>>>>>>>        Increment iChannel
8288>>>>>>>    Loop
8289>>>>>>>>
8289>>>>>>>    
8289>>>>>>>    // wrap back to beginning
8289>>>>>>>    Move 0 to iChannel
8290>>>>>>>    
8290>>>>>>>    While (iChannel < DF_SEQ_START_CHANNEL)
8294>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8296>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8297>>>>>>>            Function_Return iChannel
8298>>>>>>>        End
8298>>>>>>>>
8298>>>>>>>        
8298>>>>>>>        Increment iChannel
8299>>>>>>>    Loop
8300>>>>>>>>
8300>>>>>>>    
8300>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8301>>>>>>>End_Function
8302>>>>>>>
8302>>>>>>>Procedure Seq_Release_Channel Global Integer iChannel
8304>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8306>>>>>>>        Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_CLOSED
8307>>>>>>>    End
8307>>>>>>>>
8307>>>>>>>End_Procedure
8308>>>>>>>
8308>>>>>>>Function Seq_Open_Input_Channel Global String sChannel Returns Integer
8310>>>>>>>    Integer iChannel
8310>>>>>>>    
8310>>>>>>>    Move (Seq_New_Channel()) to iChannel
8311>>>>>>>    
8311>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8313>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8315>>>>>>>            Error DFERR_CANT_OPEN_INPUT_FILE (sChannel + ":" *C_$NoOpenChannels)
8316>>>>>>>>
8316>>>>>>>        End
8316>>>>>>>>
8316>>>>>>>        Function_Return iChannel
8317>>>>>>>    End
8317>>>>>>>>
8317>>>>>>>    
8317>>>>>>>    Move False to Err
8318>>>>>>>    Direct_Input channel iChannel sChannel
8320>>>>>>>    
8320>>>>>>>    If (Err) Begin
8322>>>>>>>        Send Seq_Release_Channel iChannel
8323>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8324>>>>>>>    End
8324>>>>>>>>
8324>>>>>>>    
8324>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_INPUT
8325>>>>>>>    
8325>>>>>>>    Function_Return iChannel
8326>>>>>>>End_Function
8327>>>>>>>
8327>>>>>>>Function Seq_Open_Output_Channel Global String sChannel Returns Integer
8329>>>>>>>    Integer iChannel
8329>>>>>>>    
8329>>>>>>>    Move (Seq_New_Channel()) to iChannel
8330>>>>>>>    
8330>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8332>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8334>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8335>>>>>>>>
8335>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8336>>>>>>>        End
8336>>>>>>>>
8336>>>>>>>        
8336>>>>>>>        Function_Return iChannel
8337>>>>>>>    End
8337>>>>>>>>
8337>>>>>>>    
8337>>>>>>>    Move False to Err
8338>>>>>>>    Direct_Output channel iChannel sChannel
8340>>>>>>>    
8340>>>>>>>    If (Err) Begin
8342>>>>>>>        Send Seq_Release_Channel iChannel
8343>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8344>>>>>>>    End
8344>>>>>>>>
8344>>>>>>>    
8344>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8345>>>>>>>    
8345>>>>>>>    Function_Return iChannel
8346>>>>>>>End_Function
8347>>>>>>>
8347>>>>>>>Function Seq_Append_Output_Channel Global String sChannel Returns Integer
8349>>>>>>>    Integer iChannel
8349>>>>>>>    
8349>>>>>>>    Move (Seq_New_Channel()) to iChannel
8350>>>>>>>    
8350>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8352>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8354>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8355>>>>>>>>
8355>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8356>>>>>>>        End
8356>>>>>>>>
8356>>>>>>>        
8356>>>>>>>        Function_Return iChannel
8357>>>>>>>    End
8357>>>>>>>>
8357>>>>>>>    
8357>>>>>>>    Move False to Err
8358>>>>>>>    Append_Output channel iChannel sChannel
8360>>>>>>>    
8360>>>>>>>    If (Err) Begin
8362>>>>>>>        Send Seq_Release_Channel iChannel
8363>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8364>>>>>>>    End
8364>>>>>>>>
8364>>>>>>>    
8364>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8365>>>>>>>    
8365>>>>>>>    Function_Return iChannel
8366>>>>>>>End_Function
8367>>>>>>>
8367>>>>>>>Procedure Seq_Close_Channel Global Integer iChannel
8369>>>>>>>    Integer iMode
8369>>>>>>>    
8369>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8371>>>>>>>        Move (Seq_Channel_Mode(iChannel)) to iMode
8372>>>>>>>        
8372>>>>>>>        If (iMode = DF_SEQ_CHANNEL_MODE_OUTPUT) Begin
8374>>>>>>>            Close_Output channel iChannel
8376>>>>>>>        End
8376>>>>>>>>
8376>>>>>>>        Else If (iMode = DF_SEQ_CHANNEL_MODE_INPUT) Begin
8379>>>>>>>            Close_Input channel iChannel
8381>>>>>>>        End
8381>>>>>>>>
8381>>>>>>>        // If channel not open, release it! No (fatal) Error.
8381>>>>>>>        Send Seq_Release_Channel iChannel
8382>>>>>>>    End
8382>>>>>>>>
8382>>>>>>>End_Procedure
8383>>>>>Use GlobalFunctionsProcedures.pkg
8383>>>>>
8383>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8383>>>>>Register_Function VdfSystemDfPath   Returns String
8383>>>>>Register_Function VdfSystemMakePath Returns String
8383>>>>>
8383>>>>>Enum_List
8383>>>>>    Define wsWorkspaceOpened       // WS opened ok
8383>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8383>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8383>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8383>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8383>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8383>>>>>End_Enum_List
8383>>>>>
8383>>>>>
8383>>>>>Define INVALID_HANDLE_VALUE for -1
8383>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8383>>>>>
8383>>>>>
8383>>>>>// Wide version
8383>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8384>>>>>
8384>>>>>// Wrapper Function winFindFirstFile
8384>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8386>>>>>    
8386>>>>>    Handle  hResult
8386>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8386>>>>>    Integer iSizeOfStructWithoutStrings
8386>>>>>    String  sFileName sAlternateFileName
8386>>>>>    WString wFileName wAlternateFileName
8386>>>>>    Pointer pWFD
8386>>>>>    tWin32FindDataW tWFD
8386>>>>>    tWin32FindDataW tWFD
8386>>>>>    
8386>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8386>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8386>>>>>
8386>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8387>>>>>    Move (AddressOf(tWFD)) to pWFD
8388>>>>>    
8388>>>>>    // Call the function
8388>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8389>>>>>
8389>>>>>    // Copy the struct contents back to the incoming one.
8389>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8390>>>>>    
8390>>>>>    // But do the strings separately and convert them to UTF8
8390>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8391>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8392>>>>>    
8392>>>>>    // Extend string with 0 to the maximum number of characters
8392>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8395>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8398>>>>>        
8398>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8399>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8400>>>>>    
8400>>>>>    Function_Return hResult
8401>>>>>End_Function
8402>>>>>
8402>>>>>// When used directly, be sure to use WString types (UTF16).
8402>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8403>>>>>
8403>>>>>// Wrapper Function winFindNextFile
8403>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8405>>>>>    
8405>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8405>>>>>    Integer iSizeOfStructWithoutStrings
8405>>>>>    String  sFileName sAlternateFileName
8405>>>>>    WString wFileName wAlternateFileName
8405>>>>>    Pointer pWFD
8405>>>>>    tWin32FindDataW tWFD
8405>>>>>    tWin32FindDataW tWFD
8405>>>>>
8405>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8405>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8405>>>>>
8405>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8405>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8406>>>>>    Move (AddressOf(tWFD)) to pWFD
8407>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8408>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8408>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8409>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8410>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8411>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8412>>>>>    
8412>>>>>    // Call the function
8412>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8413>>>>>
8413>>>>>    // Copy the struct contents back to the incoming one.
8413>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8414>>>>>    
8414>>>>>    // But do the strings separately and convert them to UTF8
8414>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8415>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8416>>>>>    
8416>>>>>    // Extend string with 0 to the maximum number of characters
8416>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8419>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8422>>>>>        
8422>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8423>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8424>>>>>    
8424>>>>>    Function_Return iResult
8425>>>>>End_Function
8426>>>>>
8426>>>>>
8426>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8427>>>>>
8427>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8429>>>>>    tWin32FindDataW Win32FindData
8429>>>>>    tWin32FindDataW Win32FindData
8429>>>>>    String sMask
8429>>>>>    Integer iVoid
8429>>>>>    Handle hFileFind
8429>>>>>    
8429>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8430>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8432>>>>>        Move (winFindClose(hFileFind)) to iVoid
8433>>>>>    End
8433>>>>>>
8433>>>>>    
8433>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8434>>>>>End_Function
8435>>>>>
8435>>>>>
8435>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cIniFile.pkg)
8435>>>>>>>Use Dll.pkg
8435>>>>>>>Use errornum.inc
8435>>>>>>>Use LanguageText.pkg
8435>>>>>>>Use GlobalFunctionsProcedures.pkg
8435>>>>>>>Use seq_chnl.pkg
8435>>>>>>>Use CharTranslate.pkg
8435>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCharTranslate.pkg)
8435>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Variant.pkg)
8435>>>>>>>>>>>Use ui
8435>>>>>>>>>>>Use errornum.inc
8435>>>>>>>>>>>
8435>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8435>>>>>>>>>>>
8435>>>>>>>>>>>
8435>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8436>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8437>>>>>>>>>>>
8437>>>>>>>>>>>//  Returns the variant type
8437>>>>>>>>>>>Function VariantType Global Variant vVal Returns Integer
8439>>>>>>>>>>>    Function_Return (DeRefW(AddressOf(vVal),0))
8440>>>>>>>>>>>End_Function
8441>>>>>>>>>>>
8441>>>>>>>>>>>
8441>>>>>>>>>>>// Returns the character length of the variant string. 
8441>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8443>>>>>>>>>>>    Integer iLen iType
8443>>>>>>>>>>>
8443>>>>>>>>>>>    Move (VariantType(bStr)) to iType
8444>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8446>>>>>>>>>>>        Function_Return 0
8447>>>>>>>>>>>    End
8447>>>>>>>>>>>>
8447>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8449>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8450>>>>>>>>>>>>
8450>>>>>>>>>>>        Function_Return 0
8451>>>>>>>>>>>    End
8451>>>>>>>>>>>>
8451>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(AddressOf(bStr),8))) to iLen
8452>>>>>>>>>>>    Function_Return iLen
8453>>>>>>>>>>>End_Function
8454>>>>>>>>>>>
8454>>>>>>>>>>>
8454>>>>>>>>>>>// returns true if char string in the buffer can fit into a string.
8454>>>>>>>>>>>// Changed this to always return True, because the Max_Argument_Size limitation has been removed.
8454>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8456>>>>>>>>>>>    Function_Return True
8457>>>>>>>>>>>End_Function
8458>>>>>>>>>>>
8458>>>>>>>>>>>
8458>>>>>>>>>Use CharTranslate.pkg
8458>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8458>>>>>>>>>
8458>>>>>>>>>// special for UTF16, which is really not a code page at all
8458>>>>>>>>>Define CP_UTF16 for -1
8458>>>>>>>>>
8458>>>>>>>>>Class cCharTranslate is a cObject
8459>>>>>>>>>    
8459>>>>>>>>>    
8459>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8459>>>>>>>>>    
8459>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8459>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8459>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8461>>>>>>>>>        Pointer pWideBuf
8461>>>>>>>>>        Integer iWideBufLen iStrLen
8461>>>>>>>>>        Move 0 to pWideBuf
8462>>>>>>>>>        Move 0 to iLen
8463>>>>>>>>>        If (pMultiCharBuffer) Begin
8465>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8466>>>>>>>>>            If (iStrLen) Begin
8468>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8469>>>>>>>>>                If (iLen=0) Begin
8471>>>>>>>>>                    Function_Return 0
8472>>>>>>>>>                End
8472>>>>>>>>>>
8472>>>>>>>>>            End
8472>>>>>>>>>>
8472>>>>>>>>>        End
8472>>>>>>>>>>
8472>>>>>>>>>        Function_Return pWideBuf
8473>>>>>>>>>    End_Function
8474>>>>>>>>>    
8474>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8476>>>>>>>>>        Pointer pValue
8476>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8477>>>>>>>>>        Function_Return pValue
8478>>>>>>>>>    End_Function
8479>>>>>>>>>    
8479>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8479>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8479>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8481>>>>>>>>>        Pointer pRetBuf
8481>>>>>>>>>        Integer iRetBufLen
8481>>>>>>>>>        Move 0 to pRetBuf
8482>>>>>>>>>        If (pWideBuf and iLen) Begin
8484>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8485>>>>>>>>>            If (iRetBufLen=0) Begin
8487>>>>>>>>>                Function_Return 0
8488>>>>>>>>>            End
8488>>>>>>>>>>
8488>>>>>>>>>        End
8488>>>>>>>>>>
8488>>>>>>>>>        Function_Return pRetBuf
8489>>>>>>>>>    End_Function
8490>>>>>>>>>    
8490>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8492>>>>>>>>>        String sValue
8492>>>>>>>>>        Pointer pValue
8492>>>>>>>>>        Boolean bOk
8492>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8493>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8495>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8496>>>>>>>>>>
8496>>>>>>>>>        End
8496>>>>>>>>>>
8496>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8497>>>>>>>>>        Move (Free(pValue)) to bOk
8498>>>>>>>>>        Function_Return sValue
8499>>>>>>>>>    End_Function
8500>>>>>>>>>    
8500>>>>>>>>>    
8500>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8500>>>>>>>>>    
8500>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8502>>>>>>>>>        Pointer pWideBuf
8502>>>>>>>>>        Pointer pUtf8Buf
8502>>>>>>>>>        Integer iLen iMultiBufLen
8502>>>>>>>>>        Boolean bOk
8502>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8503>>>>>>>>>        If (iLen=0) Begin
8505>>>>>>>>>            Function_Return 0
8506>>>>>>>>>        End
8506>>>>>>>>>>
8506>>>>>>>>>        Move 0 to pUtf8Buf
8507>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8508>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8509>>>>>>>>>        Function_Return pUtf8Buf
8510>>>>>>>>>    End_Function
8511>>>>>>>>>    
8511>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8513>>>>>>>>>        Pointer pValue
8513>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8514>>>>>>>>>        Function_Return pValue
8515>>>>>>>>>    End_Function
8516>>>>>>>>>    
8516>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8518>>>>>>>>>        Pointer pRetBuf pWideBuf
8518>>>>>>>>>        Integer iWideBufLen
8518>>>>>>>>>        Integer iRetBufLen
8518>>>>>>>>>        Boolean bOk
8518>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8519>>>>>>>>>        If (iWideBufLen=0) Begin
8521>>>>>>>>>            Function_Return 0
8522>>>>>>>>>        End
8522>>>>>>>>>>
8522>>>>>>>>>        Move 0 to pRetBuf
8523>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8524>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8525>>>>>>>>>        Function_Return pRetBuf
8526>>>>>>>>>    End_Function
8527>>>>>>>>>    
8527>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8529>>>>>>>>>        String sValue
8529>>>>>>>>>        Pointer pValue
8529>>>>>>>>>        Boolean bOk
8529>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8530>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8532>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8533>>>>>>>>>>
8533>>>>>>>>>        End
8533>>>>>>>>>>
8533>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8534>>>>>>>>>        Move (Free(pValue)) to bOk
8535>>>>>>>>>        Function_Return sValue
8536>>>>>>>>>    End_Function
8537>>>>>>>>>    
8537>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8537>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8537>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8537>>>>>>>>>    
8537>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8537>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8539>>>>>>>>>        Pointer pBSTR pRetStr
8539>>>>>>>>>        Integer iLen iBufLen
8539>>>>>>>>>        Boolean bOk
8539>>>>>>>>>        Move 0 to pRetStr
8540>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8541>>>>>>>>>        If (iLen) Begin
8543>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8544>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8545>>>>>>>>>        End
8545>>>>>>>>>>
8545>>>>>>>>>        Function_Return pRetStr
8546>>>>>>>>>    End_Function
8547>>>>>>>>>    
8547>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8547>>>>>>>>>    
8547>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8549>>>>>>>>>        String sValue
8549>>>>>>>>>        Pointer pValue
8549>>>>>>>>>        Boolean bOk
8549>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8550>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8552>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8553>>>>>>>>>>
8553>>>>>>>>>        End
8553>>>>>>>>>>
8553>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8554>>>>>>>>>        Move (Free(pValue)) to bOk
8555>>>>>>>>>        Function_Return sValue
8556>>>>>>>>>    End_Function
8557>>>>>>>>>    
8557>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8557>>>>>>>>>    
8557>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8559>>>>>>>>>        Variant vValue
8559>>>>>>>>>        Pointer pvValue
8559>>>>>>>>>        Boolean bOk
8559>>>>>>>>>        Pointer pWStr
8559>>>>>>>>>        Move "" to vValue
8560>>>>>>>>>        If (pSource) Begin
8562>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8562>>>>>>>>>            Move 0 to pWStr
8563>>>>>>>>>            //Convert the Ansi string to Unicode
8563>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8564>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8564>>>>>>>>>            Move 0 to vValue
8565>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8566>>>>>>>>>            //Change the Variant type to VT_BSTR
8566>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8567>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8567>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8568>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8568>>>>>>>>>            Move (Free(pWStr)) to bOk
8569>>>>>>>>>        End
8569>>>>>>>>>>
8569>>>>>>>>>        Function_Return vValue
8570>>>>>>>>>    End_Function
8571>>>>>>>>>    
8571>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8571>>>>>>>>>    
8571>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8573>>>>>>>>>        Variant vValue
8573>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8574>>>>>>>>>        Function_Return vValue
8575>>>>>>>>>    End_Function
8576>>>>>>>>>    
8576>>>>>>>>>    // Create buffer of utf16 data from variant.
8576>>>>>>>>>    // Returns newly created memory address and length (by reference)
8576>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8578>>>>>>>>>        Pointer pBSTR pRetStr
8578>>>>>>>>>        Boolean bOk
8578>>>>>>>>>        Move 0 to pRetStr
8579>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8580>>>>>>>>>        If (iLen) Begin
8582>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8583>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8584>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8585>>>>>>>>>        End
8585>>>>>>>>>>
8585>>>>>>>>>        Function_Return pRetStr
8586>>>>>>>>>    End_Function
8587>>>>>>>>>    
8587>>>>>>>>>    // Create variant from buffer of utf16 data
8587>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8589>>>>>>>>>        Variant vValue
8589>>>>>>>>>        Pointer pvValue
8589>>>>>>>>>        Boolean bOk
8589>>>>>>>>>        Move "" to vValue
8590>>>>>>>>>        If (pSource) Begin
8592>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8592>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8592>>>>>>>>>            Move 0 to vValue
8593>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8594>>>>>>>>>            //Change the Variant type to VT_BSTR
8594>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8595>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8595>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8596>>>>>>>>>        End
8596>>>>>>>>>>
8596>>>>>>>>>        Function_Return vValue
8597>>>>>>>>>    End_Function
8598>>>>>>>>>    
8598>>>>>>>>>    // Create Uchar array from variant string.
8598>>>>>>>>>    // Data buffer is encoded by eCharType
8598>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8600>>>>>>>>>        Pointer pBSTR pRetStr
8600>>>>>>>>>        Integer iLen iBufLen
8600>>>>>>>>>        Boolean bOk
8600>>>>>>>>>        UChar[] UC1
8601>>>>>>>>>        Move 0 to pRetStr
8602>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8603>>>>>>>>>        If (iLen) Begin
8605>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8606>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8608>>>>>>>>>                Move (iLen*2) to iBufLen
8609>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8610>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8611>>>>>>>>>            End
8611>>>>>>>>>>
8611>>>>>>>>>            Else Begin
8612>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8613>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8614>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8615>>>>>>>>>                Move (Free(pRetStr)) to bOk
8616>>>>>>>>>            End
8616>>>>>>>>>>
8616>>>>>>>>>        End
8616>>>>>>>>>>
8616>>>>>>>>>        Function_Return UC1
8617>>>>>>>>>    End_Function
8618>>>>>>>>>    
8618>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8618>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8620>>>>>>>>>        Variant vValue
8620>>>>>>>>>        Pointer pvValue
8620>>>>>>>>>        Boolean bOk
8620>>>>>>>>>        Pointer pWStr
8620>>>>>>>>>        Move "" to vValue
8621>>>>>>>>>        
8621>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8621>>>>>>>>>        Move 0 to pWStr
8622>>>>>>>>>        //Convert the Ansi string to Unicode
8622>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8624>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8625>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8626>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8627>>>>>>>>>        End
8627>>>>>>>>>>
8627>>>>>>>>>        Else Begin
8628>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8629>>>>>>>>>        End
8629>>>>>>>>>>
8629>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8629>>>>>>>>>        Move 0 to vValue
8630>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8631>>>>>>>>>        //Change the Variant type to VT_BSTR
8631>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8632>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8632>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8633>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8633>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8635>>>>>>>>>            Move (Free(pWStr)) to bOk
8636>>>>>>>>>        End
8636>>>>>>>>>>
8636>>>>>>>>>        Function_Return vValue
8637>>>>>>>>>    End_Function
8638>>>>>>>>>    
8638>>>>>>>>>    
8638>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8638>>>>>>>>>    // a new UChar array with to-encoding
8638>>>>>>>>>    
8638>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8640>>>>>>>>>        Pointer pFromBuf pToBuf
8640>>>>>>>>>        Integer iBytes iChars
8640>>>>>>>>>        Boolean bOk
8640>>>>>>>>>        
8640>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8641>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8643>>>>>>>>>            Function_Return UCharData
8644>>>>>>>>>        End
8644>>>>>>>>>>
8644>>>>>>>>>        
8644>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8646>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8647>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8648>>>>>>>>>        End
8648>>>>>>>>>>
8648>>>>>>>>>        Else Begin
8649>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8650>>>>>>>>>        End
8650>>>>>>>>>>
8650>>>>>>>>>        
8650>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8652>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8654>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8655>>>>>>>>>            End
8655>>>>>>>>>>
8655>>>>>>>>>            Else Begin
8656>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8657>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8658>>>>>>>>>            End
8658>>>>>>>>>>
8658>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8659>>>>>>>>>        End
8659>>>>>>>>>>
8659>>>>>>>>>        Else Begin
8660>>>>>>>>>            Move (iChars*2) to iBytes
8661>>>>>>>>>            Move pFromBuf to pToBuf
8662>>>>>>>>>        End
8662>>>>>>>>>>
8662>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8663>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8664>>>>>>>>>        Move (Free(pToBuf)) to bOk
8665>>>>>>>>>        Function_Return UCharData
8666>>>>>>>>>    End_Function
8667>>>>>>>>>    
8667>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8667>>>>>>>>>    // Variant strings. Binary data is always buffer
8667>>>>>>>>>    
8667>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8669>>>>>>>>>        Pointer pBase64
8669>>>>>>>>>        String sResult
8669>>>>>>>>>        Integer iVoid
8669>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8670>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8671>>>>>>>>>        Move (Free(pBase64)) to iVoid
8672>>>>>>>>>        Function_Return sResult
8673>>>>>>>>>    End_Function
8674>>>>>>>>>    
8674>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8676>>>>>>>>>        Pointer pBinaryData
8676>>>>>>>>>        String sBinary
8676>>>>>>>>>        Integer iVoid
8676>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8677>>>>>>>>>        Function_Return pBinaryData
8678>>>>>>>>>    End_Function
8679>>>>>>>>>    
8679>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8681>>>>>>>>>        Pointer pBase64
8681>>>>>>>>>        Variant vVar
8681>>>>>>>>>        Integer iBase64Len iVoid
8681>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8683>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8684>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8685>>>>>>>>>            Move (Free(pBase64)) to iVoid
8686>>>>>>>>>        End
8686>>>>>>>>>>
8686>>>>>>>>>        Function_Return vVar
8687>>>>>>>>>    End_Function
8688>>>>>>>>>    
8688>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8690>>>>>>>>>        Pointer pBase64 pBinaryData
8690>>>>>>>>>        Integer iVoid
8690>>>>>>>>>        Move 0 to iBinaryLen
8691>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8692>>>>>>>>>        If (pBase64) Begin
8694>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8695>>>>>>>>>            Move (Free(pBase64)) to iVoid
8696>>>>>>>>>        End
8696>>>>>>>>>>
8696>>>>>>>>>        Function_Return pBinaryData
8697>>>>>>>>>    End_Function
8698>>>>>>>>>    
8698>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8698>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8700>>>>>>>>>        Pointer pBase64
8700>>>>>>>>>        Integer iLen
8700>>>>>>>>>        Boolean bOk
8700>>>>>>>>>        
8700>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8701>>>>>>>>>        If (iLen) Begin
8703>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8704>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8705>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8706>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8707>>>>>>>>>            Move (Free(pBase64)) to bOk
8708>>>>>>>>>        End
8708>>>>>>>>>>
8708>>>>>>>>>        Function_Return UCharData
8709>>>>>>>>>    End_Function
8710>>>>>>>>>    
8710>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8710>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8712>>>>>>>>>        Pointer pData
8712>>>>>>>>>        Integer iLen
8712>>>>>>>>>        Boolean bOk
8712>>>>>>>>>        
8712>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8713>>>>>>>>>        If (iLen) Begin
8715>>>>>>>>>            Move 0 to UCharData[iLen]
8716>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8717>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8718>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8719>>>>>>>>>            Move (Free(pData)) to bOk
8720>>>>>>>>>        End
8720>>>>>>>>>>
8720>>>>>>>>>        Function_Return UCharData
8721>>>>>>>>>    End_Function
8722>>>>>>>>>    
8722>>>>>>>>>End_Class
8723>>>>>>>>>
8723>>>>>>>>>
8723>>>>>>>
8723>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8723>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8723>>>>>>>
8723>>>>>>>
8723>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8724>>>>>>>
8724>>>>>>>
8724>>>>>>>// When called directly, be sure to use WString types.
8724>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8725>>>>>>>
8725>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8726>>>>>>>    
8726>>>>>>>// When called directly, be sure to use String types.
8726>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8727>>>>>>>    
8727>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8727>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8727>>>>>>>    
8727>>>>>>>
8727>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8727>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8729>>>>>>>    
8729>>>>>>>    Integer iResult
8729>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8729>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8729>>>>>>>
8729>>>>>>>    Send StringToWide pSection (&uwSection)
8730>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8731>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8732>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8733>>>>>>>                           
8733>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8734>>>>>>>       
8734>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8735>>>>>>>        
8735>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8736>>>>>>>    
8736>>>>>>>    Function_Return iResult
8737>>>>>>>End_Function
8738>>>>>>> 
8738>>>>>>>
8738>>>>>>>Class cIniFile is a cObject
8739>>>>>>>    Procedure Construct_Object
8741>>>>>>>        Forward Send Construct_Object
8743>>>>>>>        
8743>>>>>>>        
8743>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8743>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8743>>>>>>>        Property Boolean pbWideAPI True
8744>>>>>>>        
8744>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8744>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8744>>>>>>>        // converted on first write (WriteString).
8744>>>>>>>        Property Boolean pbStoreAsUTF16 False
8745>>>>>>>        
8745>>>>>>>        Property String psPrivate_FileName ""
8746>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8747>>>>>>>    End_Procedure
8748>>>>>>>    
8748>>>>>>>    Procedure Set psFileName String sVal
8750>>>>>>>        Set pbPrivate_FirstWrite to True
8751>>>>>>>        Set psPrivate_FileName to sVal
8752>>>>>>>    End_Procedure
8753>>>>>>>    
8753>>>>>>>    Function psFileName Returns String
8755>>>>>>>        Function_Return (psPrivate_FileName(Self))
8756>>>>>>>    End_Function
8757>>>>>>>    
8757>>>>>>>    Procedure InitFile
8759>>>>>>>        Boolean bExists bHasBom
8759>>>>>>>        Integer iChnl
8759>>>>>>>        UChar[] ucData
8760>>>>>>>        Handle hoTranslate
8760>>>>>>>        
8760>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8762>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8763>>>>>>>            If (not(bExists)) Begin
8765>>>>>>>                //  Create the file with a UTF-16 BOM so
8765>>>>>>>                Move (Seq_New_Channel()) to iChnl
8766>>>>>>>                If (iChnl >= 0) Begin
8768>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8770>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8772>>>>>>>                    Close_Output channel iChnl
8774>>>>>>>                    Send Seq_Release_Channel iChnl
8775>>>>>>>                End
8775>>>>>>>>
8775>>>>>>>                Else If (iChnl = -1) Begin
8778>>>>>>>                    Error DFErr_Program "I/O Channel Error"
8779>>>>>>>>
8779>>>>>>>                End
8779>>>>>>>>
8779>>>>>>>                Else If (iChnl = -2) Begin
8782>>>>>>>                    Error DFErr_Program "No I/O Channel Available"
8783>>>>>>>>
8783>>>>>>>                End
8783>>>>>>>>
8783>>>>>>>            End
8783>>>>>>>>
8783>>>>>>>            Else Begin
8784>>>>>>>                //  Check for BOM
8784>>>>>>>                Move (Seq_New_Channel()) to iChnl
8785>>>>>>>                If (iChnl >= 0) Begin
8787>>>>>>>                    Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8789>>>>>>>                    Read_Block channel iChnl ucData 2
8791>>>>>>>                    
8791>>>>>>>                    Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8792>>>>>>>                    
8792>>>>>>>                    //  If no BOM we'll have to read the entire file to convert it
8792>>>>>>>                    If (not(bHasBom)) Begin
8794>>>>>>>                        Set_Channel_Position iChnl to 0
8795>>>>>>>>
8795>>>>>>>                        Read_Block ucData -1
8796>>>>>>>                    End
8796>>>>>>>>
8796>>>>>>>    
8796>>>>>>>                    Close_Input channel iChnl
8798>>>>>>>                    
8798>>>>>>>                    If (not(bHasBom)) Begin
8800>>>>>>>                        //  Convert thedata
8800>>>>>>>                        Get Create (RefClass(cCharTranslate)) to hoTranslate
8801>>>>>>>                        Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8802>>>>>>>                        
8802>>>>>>>                        //  Write out the UTF 16 file with BOM
8802>>>>>>>                        Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8804>>>>>>>                        Write channel iChnl C_BOM_UTF16LE
8806>>>>>>>                        
8806>>>>>>>                        Write channel iChnl ucData
8808>>>>>>>                        
8808>>>>>>>                        Close_Output channel iChnl
8810>>>>>>>                        
8810>>>>>>>                        Send Destroy of hoTranslate
8811>>>>>>>                    End
8811>>>>>>>>
8811>>>>>>>                    
8811>>>>>>>                    Send Seq_Release_Channel iChnl
8812>>>>>>>                End
8812>>>>>>>>
8812>>>>>>>                Else If (iChnl = -1) Begin
8815>>>>>>>                    Error DFErr_Program "I/O Channel Error"
8816>>>>>>>>
8816>>>>>>>                End
8816>>>>>>>>
8816>>>>>>>                Else If (iChnl = -2) Begin
8819>>>>>>>                    Error DFErr_Program "No I/O Channel Available"
8820>>>>>>>>
8820>>>>>>>                End
8820>>>>>>>>
8820>>>>>>>            End
8820>>>>>>>>
8820>>>>>>>            
8820>>>>>>>            Set pbPrivate_FirstWrite to False
8821>>>>>>>        End
8821>>>>>>>>
8821>>>>>>>    End_Procedure
8822>>>>>>>    
8822>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8824>>>>>>>        Boolean bSuccess
8824>>>>>>>        String sFileName
8824>>>>>>>        
8824>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8826>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8827>>>>>>>>
8827>>>>>>>            Procedure_Return
8828>>>>>>>        End
8828>>>>>>>>
8828>>>>>>>        
8828>>>>>>>        Send InitFile
8829>>>>>>>        
8829>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8829>>>>>>>        If (pbWideAPI(Self)) Begin
8831>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8832>>>>>>>        End
8832>>>>>>>>
8832>>>>>>>        Else Begin
8833>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8834>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8835>>>>>>>        End
8835>>>>>>>>
8835>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8838>>>>>>>    End_Procedure
8839>>>>>>>    
8839>>>>>>>    
8839>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8841>>>>>>>        Integer iNumChars iSizeValue
8841>>>>>>>        WString wValue wFileName wSection wKey wDefault
8841>>>>>>>        String sFileName sValue
8841>>>>>>>        
8841>>>>>>>        Move 2047 to iSizeValue
8842>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8843>>>>>>>        
8843>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8845>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8846>>>>>>>>
8846>>>>>>>            Function_Return ''
8847>>>>>>>        End
8847>>>>>>>>
8847>>>>>>>        
8847>>>>>>>        If (pbWideAPI(Self)) Begin
8849>>>>>>>            Move sSection to wSection
8850>>>>>>>            Move sKey to wKey
8851>>>>>>>            Move sDefault to wDefault
8852>>>>>>>            Move sValue to wValue
8853>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8854>>>>>>>            Move wValue to sValue
8855>>>>>>>        End
8855>>>>>>>>
8855>>>>>>>        Else Begin
8856>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8857>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8858>>>>>>>        End
8858>>>>>>>>
8858>>>>>>>        
8858>>>>>>>        Function_Return  (CString(sValue))
8859>>>>>>>    End_Function
8860>>>>>>>    
8860>>>>>>>    Function SectionExists String sSection Returns Boolean
8862>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8862>>>>>>>        Handle hoKeys
8862>>>>>>>        Integer icKey iKey
8862>>>>>>>        
8862>>>>>>>        Get Create U_ARRAY to hoKeys
8863>>>>>>>        Send ReadSection sSection hoKeys
8864>>>>>>>        Get Item_Count of hoKeys to icKey
8865>>>>>>>        Send Destroy of hoKeys
8866>>>>>>>        
8866>>>>>>>        Function_Return (icKey >0)
8867>>>>>>>    End_Function
8868>>>>>>>    
8868>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8870>>>>>>>        Integer iNumChars iSizeValue iPos
8870>>>>>>>        Pointer lpsKeys
8870>>>>>>>        WString wKeys wKey
8870>>>>>>>        
8870>>>>>>>        Move 16384 to iSizeValue
8871>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wKeys
8872>>>>>>>        
8872>>>>>>>        Move (AddressOf(wKeys)) to lpsKeys
8873>>>>>>>        
8873>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8875>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8876>>>>>>>>
8876>>>>>>>            Procedure_Return
8877>>>>>>>        End
8877>>>>>>>>
8877>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8877>>>>>>>        Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8878>>>>>>>        If (iNumChars >0) Begin
8880>>>>>>>            Repeat
8880>>>>>>>>
8880>>>>>>>                Move (Pos(Character(0),wKeys)) to iPos
8881>>>>>>>                If (iPos >1) Begin
8883>>>>>>>                    Move (Left(wKeys,iPos -1))  to wKey
8884>>>>>>>                    Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8885>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to wKey
8886>>>>>>>                End
8886>>>>>>>>
8886>>>>>>>            Until (iPos <=1)
8888>>>>>>>        End
8888>>>>>>>>
8888>>>>>>>    End_Procedure
8889>>>>>>>    
8889>>>>>>>    Procedure ReadSections Handle hoArray
8891>>>>>>>        Integer iNumChars iSizeValue iPos
8891>>>>>>>        Pointer lpwSections
8891>>>>>>>        WString wSections
8891>>>>>>>        String sSection
8891>>>>>>>        
8891>>>>>>>        Move 16384 to iSizeValue
8892>>>>>>>        
8892>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8893>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8894>>>>>>>        
8894>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8896>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8897>>>>>>>>
8897>>>>>>>            Procedure_Return
8898>>>>>>>        End
8898>>>>>>>>
8898>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8898>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8899>>>>>>>        If (iNumChars >0) Begin
8901>>>>>>>            Repeat
8901>>>>>>>>
8901>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8902>>>>>>>                If (iPos >1) Begin
8904>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8905>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8906>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8907>>>>>>>                End
8907>>>>>>>>
8907>>>>>>>            Until (iPos <=1)
8909>>>>>>>        End
8909>>>>>>>>
8909>>>>>>>        
8909>>>>>>>    End_Procedure
8910>>>>>>>    
8910>>>>>>>    Procedure DeleteSection String sSection
8912>>>>>>>        
8912>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8914>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8915>>>>>>>>
8915>>>>>>>            Procedure_Return
8916>>>>>>>        End
8916>>>>>>>>
8916>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8919>>>>>>>    End_Procedure
8920>>>>>>>    
8920>>>>>>>    Procedure DeleteKey String sSection String sKey
8922>>>>>>>        Integer iVoid
8922>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8924>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8925>>>>>>>>
8925>>>>>>>            Procedure_Return
8926>>>>>>>        End
8926>>>>>>>>
8926>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8927>>>>>>>    End_Procedure
8928>>>>>>>    
8928>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
8930>>>>>>>        Handle hoKeys
8930>>>>>>>        Integer iKey
8930>>>>>>>        Boolean bExists
8930>>>>>>>        
8930>>>>>>>        Move (False) to bExists
8931>>>>>>>        
8931>>>>>>>        Move (Uppercase(sKey)) to sKey
8932>>>>>>>        
8932>>>>>>>        Get Create U_ARRAY to hoKeys
8933>>>>>>>        
8933>>>>>>>        Send ReadSection sSection hoKeys
8934>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
8940>>>>>>>>
8940>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
8942>>>>>>>                Move (True) to bExists
8943>>>>>>>            End
8943>>>>>>>>
8943>>>>>>>        Loop
8944>>>>>>>>
8944>>>>>>>        
8944>>>>>>>        Send Destroy of hoKeys
8945>>>>>>>        
8945>>>>>>>        Function_Return bExists
8946>>>>>>>    End_Function
8947>>>>>>>    
8947>>>>>>>End_Class
8948>>>>>
8948>>>>>Class cWorkspace is a cObject
8949>>>>>    
8949>>>>>    Procedure Construct_Object
8951>>>>>        Forward Send Construct_Object
8953>>>>>        
8953>>>>>        
8953>>>>>        Property String psAppSrcPath
8954>>>>>        Property String psBitmapPath
8955>>>>>        Property String psDataPath
8956>>>>>        Property String psDdSrcPath
8957>>>>>        Property String psDescription
8958>>>>>        Property String psFileList
8959>>>>>        Property String psHelpPath
8960>>>>>        Property String psHome
8961>>>>>        Property String psIdeSrcPath
8962>>>>>        Property String psProgramPath
8963>>>>>        Property String psAppHtmlPath
8964>>>>>        Property String psWorkspaceName
8965>>>>>        Property String psWorkspaceWSFile
8966>>>>>        Property String psConnectionIni
8967>>>>>        
8967>>>>>        Property String psSystemDfPath // took from the Registry!
8968>>>>>        Property String psSystemMakePath // took from the Registry!
8969>>>>>        Property String psDfPath        // Calculated
8970>>>>>        
8970>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
8971>>>>>        
8971>>>>>    End_Procedure
8972>>>>>    
8972>>>>>    Function FullPathNames String sShortPathNames Returns String
8974>>>>>        String sFileName
8974>>>>>        String sFullPathNames 
8974>>>>>        WString sFullPathName sShortPathName
8974>>>>>        Pointer lpsFilePart
8974>>>>>        Integer icChar // the number of characters returned
8974>>>>>        Integer iPos
8974>>>>>        
8974>>>>>        Move (Pos(";", sShortPathNames)) to iPos
8975>>>>>        While (length(sShortPathNames) >0)
8979>>>>>            If (iPos =0) Begin
8981>>>>>                Move sShortPathNames to sShortPathName
8982>>>>>                Move "" to sShortPathNames
8983>>>>>            End
8983>>>>>>
8983>>>>>            Else Begin // multiple paths
8984>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
8985>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
8986>>>>>            End
8986>>>>>>
8986>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
8987>>>>>            Move -1 to lpsFilePart
8988>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
8989>>>>>            Append sFullPathNames (CString(sFullPathName))
8990>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
8993>>>>>            Move (Pos(";", sShortPathNames)) to iPos
8994>>>>>        Loop
8995>>>>>>
8995>>>>>        
8995>>>>>        Function_Return sFullPathNames
8996>>>>>    End_Function
8997>>>>>    
8997>>>>>    Function GetApplicationPath Returns String
8999>>>>>        // Returns the path of the Application (no trailing "\")
8999>>>>>        WString wApplicationFileName 
8999>>>>>        Boolean bRemoved
8999>>>>>        Integer iNumChars
8999>>>>>        String sFilename sPath
8999>>>>>        
8999>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
9000>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
9001>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
9002>>>>>        
9002>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
9003>>>>>        Move (CString(wApplicationFileName)) to sPath
9004>>>>>        
9004>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
9007>>>>>        Function_Return sPath
9008>>>>>    End_Function
9009>>>>>    
9009>>>>>    Procedure DoClearPaths
9011>>>>>        // Call this prior to changing from one WorkspAce to another
9011>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
9011>>>>>        Set psHome           to ""
9012>>>>>        Set psAppSrcPath     to ""
9013>>>>>        Set psBitmapPath     to ""
9014>>>>>        Set psDataPath       to ""
9015>>>>>        Set psDdSrcPath      to ""
9016>>>>>        Set psDescription    to ""
9017>>>>>        Set psFileList       to ""
9018>>>>>        Set psHelpPath       to ""
9019>>>>>        Set psIdeSrcPath     to ""
9020>>>>>        Set psAppHtmlPath    to ""
9021>>>>>        Set psProgramPath    to ""
9022>>>>>        Set psWorkspaceName  to ""
9023>>>>>        Set psSystemDfPath   to ""
9024>>>>>        Set psSystemMakePath to ""
9025>>>>>        Set psWorkspaceWSFile to ""
9026>>>>>        Set psConnectionIni to ""
9027>>>>>    End_Procedure
9028>>>>>    
9028>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
9030>>>>>        WString wApplicationStartPath
9030>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
9030>>>>>        Boolean bRemoved
9030>>>>>        Handle hoIniFile
9030>>>>>        Boolean bSuccess // call succeeded?
9030>>>>>        String sOldDirectory
9030>>>>>        String sSystemDfPath sSystemMakePath
9030>>>>>        Boolean bExist // does the WS file exist?
9030>>>>>        Boolean bChangingWorkspace
9030>>>>>        
9030>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
9030>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
9030>>>>>        
9030>>>>>        Set psWorkspaceWSFile to ""
9031>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
9034>>>>>        
9034>>>>>        // Append extension if not supplied...
9034>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
9036>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
9037>>>>>        End
9037>>>>>>
9037>>>>>        
9037>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
9038>>>>>        
9038>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
9040>>>>>            // Set the properties to the paths of the Workspace
9040>>>>>            // Find the WS file (with program)...
9040>>>>>            Get GetApplicationPath to wApplicationStartPath
9041>>>>>            
9041>>>>>            Move sWorkspaceFile to sWsName
9042>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
9043>>>>>        End
9043>>>>>>
9043>>>>>        Else Begin
9044>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
9045>>>>>            
9045>>>>>            Move sWorkspaceFile to wApplicationStartPath
9046>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
9047>>>>>        End
9047>>>>>>
9047>>>>>        
9047>>>>>        // Ensure that the file can be found...
9047>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
9047>>>>>        // [JVH] Turn off support for
9047>>>>>        // Ansi extended characters in workspace until we can
9047>>>>>        // resolve all open issues
9047>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
9048>>>>>        File_Exist sWorkspaceFile bExist
9049>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
9052>>>>>        
9052>>>>>        Get psHome           to sHome
9053>>>>>        Get psAppSrcPath     to sAppSrcPath
9054>>>>>        Get psAppHtmlPath    to sAppHtmlPath
9055>>>>>        Get psBitmapPath     to sBitmapPath
9056>>>>>        Get psDataPath       to sDataPath
9057>>>>>        Get psDdSrcPath      to sDdSrcPath
9058>>>>>        Get psDescription    to sDescription
9059>>>>>        Get psFileList       to sFileList
9060>>>>>        Get psHelpPath       to sHelpPath
9061>>>>>        Get psIdeSrcPath     to sIdeSrcPath
9062>>>>>        Get psProgramPath    to sProgramPath
9063>>>>>        Get psSystemDfPath   to sSystemDfPath
9064>>>>>        Get psSystemMakePath to sSystemMakePath
9065>>>>>        Get psWorkspaceName  to sWorkspaceName
9066>>>>>        Get psConnectionIni to sConnectionIni
9067>>>>>        
9067>>>>>        Get_Current_Directory to sOldDirectory
9068>>>>>        // Note- this conversion is temporarily rolled back
9068>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9068>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9069>>>>>        
9069>>>>>        Get Create U_cIniFile to hoIniFile
9070>>>>>        Set pbWideAPI of hoIniFile to False
9071>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9072>>>>>        
9072>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9075>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9078>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9081>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9084>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9087>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9090>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9093>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9096>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9099>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9102>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9105>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9108>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9111>>>>>        
9111>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9114>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9117>>>>>        
9117>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9118>>>>>        
9118>>>>>        // Set CWD to Home...
9118>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9119>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9120>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9121>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9122>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9123>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9124>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9125>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9126>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9127>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9128>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9129>>>>>        
9129>>>>>        Set psWorkspaceName to sWorkspaceName
9130>>>>>        Set psDescription   to sDescription
9131>>>>>        
9131>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9132>>>>>        
9132>>>>>        // Restore CWD...
9132>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9133>>>>>        
9133>>>>>        // Check for error conditions:
9133>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9133>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9136>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9139>>>>>        
9139>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9140>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9143>>>>>        
9143>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9146>>>>>        
9146>>>>>        Send DoAssignPaths // set psDfPath
9147>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9148>>>>>        Set pbWorkspaceOpened to True
9149>>>>>        
9149>>>>>        Function_Return wsWorkspaceOpened
9150>>>>>    End_Function
9151>>>>>    
9151>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9153>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9153>>>>>        
9153>>>>>        Handle hoSections hoIniFile
9153>>>>>        Integer iWorkspace eOpened
9153>>>>>        String sWorkspaceName sPath
9153>>>>>        String sVdfRootDir
9153>>>>>        
9153>>>>>        Get Create U_Array    to hoSections
9154>>>>>        Get Create U_cIniFile to hoIniFile
9155>>>>>        
9155>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9158>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9161>>>>>        
9161>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9162>>>>>        
9162>>>>>        Send ReadSections of hoIniFile hoSections
9163>>>>>        
9163>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9169>>>>>>
9169>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9170>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9172>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9173>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9176>>>>>                
9176>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9177>>>>>                Send Destroy of hoSections
9178>>>>>                Send Destroy of hoIniFile
9179>>>>>                Function_Return eOpened
9180>>>>>            End
9180>>>>>>
9180>>>>>        Loop
9181>>>>>>
9181>>>>>        
9181>>>>>        Send Destroy of hoSections
9182>>>>>        Send Destroy of hoIniFile
9183>>>>>        Function_Return wsWorkspaceNotFound
9184>>>>>    End_Function
9185>>>>>    
9185>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9187>>>>>        Boolean bRegistered
9187>>>>>        Handle hoIniFile
9187>>>>>        String sVdfRootDir
9187>>>>>        
9187>>>>>        Get Create U_cIniFile to hoIniFile
9188>>>>>        
9188>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9191>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9194>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9195>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9196>>>>>        
9196>>>>>        Send Destroy of hoIniFile
9197>>>>>        
9197>>>>>        Function_Return bRegistered
9198>>>>>    End_Function
9199>>>>>    
9199>>>>>    Function VdfSystemDfPath Returns String
9201>>>>>        String sSystemDfPath
9201>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9204>>>>>        
9204>>>>>        Function_Return sSystemDfPath
9205>>>>>    End_Function
9206>>>>>    
9206>>>>>    Function VdfSystemMakePath Returns String
9208>>>>>        String sSystemMakePath
9208>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9211>>>>>        
9211>>>>>        Function_Return sSystemMakePath
9212>>>>>    End_Function
9213>>>>>    
9213>>>>>    Procedure DoAssignPaths
9215>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9215>>>>>        
9215>>>>>        Get psDataPath     to sDataPath
9216>>>>>        Get psBitmapPath   to sBitmapPath
9217>>>>>        Get psHelpPath     to sHelpPath
9218>>>>>        Get psProgramPath  to sProgramPath
9219>>>>>        Get psSystemDfPath to sSystemDfPath
9220>>>>>        
9220>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9221>>>>>        
9221>>>>>    End_Procedure
9222>>>>>    
9222>>>>>    Procedure DoSetPaths
9224>>>>>        // [JVH] must convert paths to Ansi before setting these values
9224>>>>>        // Note- this conversion is temporarily rolled back
9224>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9224>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9224>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9227>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9230>>>>>    End_Procedure
9231>>>>>    
9231>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9233>>>>>        String sPath
9233>>>>>        
9233>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9236>>>>>        Else Begin
9237>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9238>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9239>>>>>            Send hmGeneric to hoCallBack ""
9240>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9241>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9242>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9243>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9244>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9245>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9246>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9247>>>>>        End
9247>>>>>>
9247>>>>>    End_Procedure
9248>>>>>    
9248>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9250>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9250>>>>>        // returns a corresponding message string.
9250>>>>>        String sError
9250>>>>>        
9250>>>>>        Case Begin
9250>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9252>>>>>                Move C_$NoErrors to sError
9253>>>>>                Case Break
9254>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9257>>>>>                Move C_$NoWsName to sError
9258>>>>>                Case Break
9259>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9262>>>>>                Move C_$NoWsFileFound to sError
9263>>>>>                Case Break
9264>>>>>            Case (eErrorCode = wsDataPathEmpty)
9267>>>>>                Move C_$NoWsDataPath to sError
9268>>>>>                Case Break
9269>>>>>            Case (eErrorCode = wsFileListEmpty)
9272>>>>>                Move C_$NoWsFileList to sError
9273>>>>>                Case Break
9274>>>>>            Case (eErrorCode = wsFileListNotExist)
9277>>>>>                Move C_$NoFileListCfg to sError
9278>>>>>                Case Break
9279>>>>>            Case Else
9279>>>>>                Move C_$UnknownError to sError
9280>>>>>                Case Break
9281>>>>>        Case End
9281>>>>>        
9281>>>>>        Function_Return (sError-".")
9282>>>>>    End_Function
9283>>>>>    
9283>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9285>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9285>>>>>        String sVdfRootDir
9285>>>>>        Handle hoIniFile
9285>>>>>        String sPath
9285>>>>>        String sFileName
9285>>>>>        String sWorkspacePath
9285>>>>>        
9285>>>>>        Move "" to sFileName
9286>>>>>        
9286>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9289>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9292>>>>>        
9292>>>>>        Get Create U_cIniFile to hoIniFile
9293>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9294>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9295>>>>>        If (sWorkspacePath <>"") Begin
9297>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9300>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9301>>>>>        End
9301>>>>>>
9301>>>>>        Send Destroy of hoIniFile
9302>>>>>        
9302>>>>>        Function_Return sFileName
9303>>>>>    End_Function
9304>>>>>    
9304>>>>>    Function CountOfPaths String sPaths Returns Integer
9306>>>>>        // Returns the number of paths defined in a string of paths
9306>>>>>        Integer iChar icChar icPath
9306>>>>>        
9306>>>>>        If (sPaths ="") ;            Function_Return 0
9309>>>>>        
9309>>>>>        Move (Length(sPaths) -1) to icChar
9310>>>>>        For iChar from 1 to icChar
9316>>>>>>
9316>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9319>>>>>        Loop
9320>>>>>>
9320>>>>>        
9320>>>>>        Function_Return (icPath +1)
9321>>>>>    End_Function
9322>>>>>    
9322>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9324>>>>>        // Returns the path at the 1-based index of passed paths.
9324>>>>>        // If the path contains a trailing "\", it will be removed
9324>>>>>        Integer iChar icPath iPath iPos
9324>>>>>        String sPath
9324>>>>>        
9324>>>>>        Move (sPaths +";") to sPaths
9325>>>>>        For iPath from 1 to iIndex
9331>>>>>>
9331>>>>>            Move (Pos(";", sPaths)) to iPos
9332>>>>>            If iPos Begin
9334>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9335>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9338>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9339>>>>>            End
9339>>>>>>
9339>>>>>            Else ;                Function_Return "" // index past number of paths
9341>>>>>        Loop
9342>>>>>>
9342>>>>>        
9342>>>>>        Function_Return sPath
9343>>>>>    End_Function
9344>>>>>    
9344>>>>>End_Class
9345>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCommandLine.pkg)
9345>>>>>Use VDFBase.pkg
9345>>>>>
9345>>>>>Class cCommandLine is a cObject
9346>>>>>    
9346>>>>>    Procedure Construct_Object
9348>>>>>        Forward Send Construct_Object
9350>>>>>        
9350>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9351>>>>>    End_Procedure
9352>>>>>    
9352>>>>>    Procedure Private_DoCreateArgsArray
9354>>>>>        // creates the array for holding the arguments. Created upon demand only!
9354>>>>>        Integer icArg
9354>>>>>        String sArg
9354>>>>>        
9354>>>>>        Object oArgs is an Array
9356>>>>>            Delegate Set phoArgs to Self
9358>>>>>            Repeat
9358>>>>>>
9358>>>>>                CmdLine sArg
9359>>>>>>
9359>>>>>                If (sArg <> "") Begin
9361>>>>>                    Increment icArg
9362>>>>>                    Set Value  (icArg -1) to sArg
9363>>>>>                End
9363>>>>>>
9363>>>>>            Until (sArg = "")
9365>>>>>        End_Object
9366>>>>>    End_Procedure
9367>>>>>    
9367>>>>>    Function CountOfArgs Returns Integer
9369>>>>>        //Returns the number of arguments passed
9369>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9372>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9373>>>>>    End_Function
9374>>>>>    
9374>>>>>    Function Argument Integer iIndex Returns String
9376>>>>>        //Returns the one-based argument string
9376>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9379>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9380>>>>>    End_Function
9381>>>>>    
9381>>>>>End_Class
9382>>>>>
9382>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cRegistry.pkg)
9382>>>>>Use Dll.pkg
9382>>>>>Use RegistryAPI.pkg
9382>>>>>Use tWinStructs.pkg
9382>>>>>
9382>>>>>Enum_List // Registry Data types
9382>>>>>    Define rdString
9382>>>>>    Define rdDword
9382>>>>>    Define rdBinary
9382>>>>>    Define rdUnknown
9382>>>>>End_Enum_List
9382>>>>>
9382>>>>>
9382>>>>>Class cRegistry is a cObject
9383>>>>>    Procedure Construct_Object
9385>>>>>        Forward Send Construct_Object
9387>>>>>        
9387>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9388>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9389>>>>>        Property Handle phCurrentKey
9390>>>>>        Property Boolean pbLazyWrite True
9391>>>>>    End_Procedure
9392>>>>>    
9392>>>>>    Function CountOfSubkeys Returns Integer
9394>>>>>        Integer dwCountOfSubkeys
9394>>>>>        Integer iError
9394>>>>>        String sError
9394>>>>>        
9394>>>>>        Move 0 to dwCountOfSubkeys
9395>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9396>>>>>        If iError Begin
9398>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9399>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9400>>>>>>
9400>>>>>        End
9400>>>>>>
9400>>>>>        Function_Return dwCountOfSubkeys
9401>>>>>    End_Function
9402>>>>>    
9402>>>>>    Function CountOfValues Returns Integer
9404>>>>>        Integer dwCountOfValues
9404>>>>>        Integer iError
9404>>>>>        String sError
9404>>>>>        
9404>>>>>        Move 0 to dwCountOfValues
9405>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9406>>>>>        If iError Begin
9408>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9409>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9410>>>>>>
9410>>>>>        End
9410>>>>>>
9410>>>>>        
9410>>>>>        Function_Return dwCountOfValues
9411>>>>>    End_Function
9412>>>>>    
9412>>>>>    Function LongestSubkeyLength Returns Integer
9414>>>>>        Integer dwLongestSubkeyLength
9414>>>>>        Integer iError
9414>>>>>        String sError
9414>>>>>        
9414>>>>>        Move 0 to dwLongestSubkeyLength
9415>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9416>>>>>        If iError Begin
9418>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9419>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9420>>>>>>
9420>>>>>        End
9420>>>>>>
9420>>>>>        
9420>>>>>        Function_Return dwLongestSubkeyLength
9421>>>>>    End_Function
9422>>>>>    
9422>>>>>    Function LongestValueLength Returns Integer
9424>>>>>        Integer dwLongestValueLength
9424>>>>>        Integer iError
9424>>>>>        String sError
9424>>>>>        
9424>>>>>        Move 0 to dwLongestValueLength
9425>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9426>>>>>        If iError Begin
9428>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9429>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9430>>>>>>
9430>>>>>        End
9430>>>>>>
9430>>>>>        
9430>>>>>        Function_Return dwLongestValueLength
9431>>>>>    End_Function
9432>>>>>    
9432>>>>>    Function LongestDataLength Returns Integer
9434>>>>>        Integer dwLongestDataLength
9434>>>>>        Integer iError
9434>>>>>        String sError
9434>>>>>        
9434>>>>>        Move 0 to dwLongestDataLength
9435>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9436>>>>>        If iError Begin
9438>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9439>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9440>>>>>>
9440>>>>>        End
9440>>>>>>
9440>>>>>        
9440>>>>>        Function_Return dwLongestDataLength
9441>>>>>    End_Function
9442>>>>>    
9442>>>>>    Function ValueType String sValueName Returns Integer
9444>>>>>        Integer dwType
9444>>>>>        Integer iError eType
9444>>>>>        String sError
9444>>>>>        
9444>>>>>        Move 0 to dwType
9445>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9446>>>>>        If iError Begin
9448>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9449>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9450>>>>>>
9450>>>>>        End
9450>>>>>>
9450>>>>>        
9450>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9453>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9457>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9461>>>>>        Else ;            Move rdUnknown to eType
9463>>>>>        
9463>>>>>        Function_Return eType
9464>>>>>    End_Function
9465>>>>>    
9465>>>>>    Function ValueLength String sValueName Returns Integer
9467>>>>>        Integer dwSize
9467>>>>>        Integer iError
9467>>>>>        String sError
9467>>>>>        
9467>>>>>        Move 0 to dwSize
9468>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9469>>>>>        If iError Begin
9471>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9472>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9473>>>>>>
9473>>>>>        End
9473>>>>>>
9473>>>>>        
9473>>>>>        Function_Return dwSize
9474>>>>>    End_Function
9475>>>>>    
9475>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9477>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9477>>>>>        Handle hKey hKeyOpened
9477>>>>>        Integer iError
9477>>>>>        String sError
9477>>>>>        
9477>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9478>>>>>        
9478>>>>>        Get phRootKey to hKey
9479>>>>>        
9479>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9480>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9483>>>>>        Else Begin
9484>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9485>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9486>>>>>>
9486>>>>>        End
9486>>>>>>
9486>>>>>        Function_Return iError
9487>>>>>    End_Function
9488>>>>>    
9488>>>>>    Procedure CloseKey
9490>>>>>        Integer iError
9490>>>>>        Handle hKey
9490>>>>>        
9490>>>>>        Get phCurrentKey to hKey
9491>>>>>        
9491>>>>>        If (hKey <>0) Begin
9493>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9496>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9498>>>>>            
9498>>>>>            Set phCurrentKey to 0
9499>>>>>        End
9499>>>>>>
9499>>>>>    End_Procedure
9500>>>>>    
9500>>>>>    Function OpenKey String sKeyName Returns Boolean
9502>>>>>        Handle hKey hKeyOpened
9502>>>>>        Integer iError
9502>>>>>        
9502>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9503>>>>>        
9503>>>>>        Get phRootKey to hKey
9504>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9505>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9508>>>>>        
9508>>>>>        Function_Return (iError=0)
9509>>>>>    End_Function
9510>>>>>    
9510>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9512>>>>>        Handle hKey
9512>>>>>        Integer iError
9512>>>>>        Integer iData
9512>>>>>        String sError
9512>>>>>        
9512>>>>>        Move iValueData to iData
9513>>>>>        Get phCurrentKey to hKey
9514>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9515>>>>>        If iError Begin
9517>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9518>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9519>>>>>>
9519>>>>>        End
9519>>>>>>
9519>>>>>    End_Procedure
9520>>>>>    
9520>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9520>>>>>    Procedure WriteDword String sValue Integer iValueData
9522>>>>>        Send WriteInteger of Self sValue iValueData
9523>>>>>    End_Procedure
9524>>>>>    
9524>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9526>>>>>        Handle hKey
9526>>>>>        Integer iError
9526>>>>>        UInteger uData
9526>>>>>        String sError
9526>>>>>        
9526>>>>>        Move uValueData to uData
9527>>>>>        Get phCurrentKey to hKey
9528>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9529>>>>>        If iError Begin
9531>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9532>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9533>>>>>>
9533>>>>>        End
9533>>>>>>
9533>>>>>    End_Procedure
9534>>>>>
9534>>>>>    Procedure WriteString WString sValue WString wValueData
9536>>>>>        Handle hKey
9536>>>>>        Integer iError cbData
9536>>>>>        String sError
9536>>>>>        
9536>>>>>        If (wValueData = "") Begin
9538>>>>>            Move (Character(0)) to wValueData
9539>>>>>            Move 1 to cbData
9540>>>>>        End
9540>>>>>>
9540>>>>>        Else Begin
9541>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9542>>>>>        End
9542>>>>>>
9542>>>>>        Get phCurrentKey to hKey
9543>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9544>>>>>        If iError Begin
9546>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9547>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9548>>>>>>
9548>>>>>        End
9548>>>>>>
9548>>>>>    End_Procedure
9549>>>>>    
9549>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9551>>>>>        Handle hKey
9551>>>>>        Integer iError
9551>>>>>        String sError
9551>>>>>        
9551>>>>>        Get phCurrentKey to hKey
9552>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9553>>>>>        If iError Begin
9555>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9556>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9557>>>>>>
9557>>>>>        End
9557>>>>>>
9557>>>>>    End_Procedure
9558>>>>>    
9558>>>>>    Function ReadInteger WString sValueName Returns Integer
9560>>>>>        Handle hKey
9560>>>>>        Integer iError
9560>>>>>        Integer iValueData iValueDataLength
9560>>>>>        String sError
9560>>>>>        
9560>>>>>        Move 0           to iValueData
9561>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9562>>>>>        
9562>>>>>        Get phCurrentKey to hKey
9563>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9564>>>>>        If iError Begin
9566>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9567>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9568>>>>>>
9568>>>>>        End
9568>>>>>>
9568>>>>>        
9568>>>>>        Function_Return iValueData
9569>>>>>    End_Function
9570>>>>>    
9570>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9570>>>>>    Function ReadDword String sValueName Returns Integer
9572>>>>>        Function_Return (ReadInteger(Self, sValueName))
9573>>>>>    End_Function
9574>>>>>
9574>>>>>    Function ReadUInt WString sValueName Returns UInteger
9576>>>>>        Handle hKey
9576>>>>>        Integer iError
9576>>>>>        UInteger uValueData uValueDataLength
9576>>>>>        String sError
9576>>>>>        
9576>>>>>        Move 0           to uValueData
9577>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9578>>>>>        
9578>>>>>        Get phCurrentKey to hKey
9579>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9580>>>>>        If iError Begin
9582>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9583>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9584>>>>>>
9584>>>>>        End
9584>>>>>>
9584>>>>>        
9584>>>>>        Function_Return uValueData
9585>>>>>    End_Function
9586>>>>>    
9586>>>>>    Function ReadString String sValueName Returns String
9588>>>>>        Handle hKey
9588>>>>>        Integer iError
9588>>>>>        WString wValueData
9588>>>>>        DWord dwValueDataLength dwType
9588>>>>>        Pointer lpsValueData
9588>>>>>        String sError
9588>>>>>        
9588>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9589>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9590>>>>>        
9590>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9591>>>>>        
9591>>>>>        Move REG_SZ to dwType
9592>>>>>        
9592>>>>>        Get phCurrentKey to hKey
9593>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9594>>>>>        If iError Begin
9596>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9597>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9598>>>>>>
9598>>>>>        End
9598>>>>>>
9598>>>>>        
9598>>>>>        Function_Return (CString(wValueData))
9599>>>>>    End_Function
9600>>>>>    
9600>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9602>>>>>        Handle hKey
9602>>>>>        Integer iError
9602>>>>>        String sError
9602>>>>>        
9602>>>>>        Get phCurrentKey to hKey
9603>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9604>>>>>        If iError Begin
9606>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9607>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9608>>>>>>
9608>>>>>        End
9608>>>>>>
9608>>>>>        
9608>>>>>        Function_Return (iDataLength >0)
9609>>>>>    End_Function
9610>>>>>    
9610>>>>>    
9610>>>>>    // Private....
9610>>>>>    Function GetBaseKey Returns Handle
9612>>>>>        Handle hBaseKey
9612>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9615>>>>>        Else ;            Get phCurrentKey to hBaseKey
9617>>>>>        
9617>>>>>        Function_Return hBaseKey
9618>>>>>    End_Function
9619>>>>>    
9619>>>>>    Function GetKey String sKeyName Returns Handle
9621>>>>>        Handle hKeyOpened
9621>>>>>        Integer iError
9621>>>>>        
9621>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9622>>>>>        
9622>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9623>>>>>        
9623>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9626>>>>>        Else ;            Function_Return 0
9628>>>>>    End_Function
9629>>>>>    
9629>>>>>    // Public
9629>>>>>    Function KeyExists String sKeyName Returns Boolean
9631>>>>>        Handle hKey
9631>>>>>        Integer iVoid
9631>>>>>        
9631>>>>>        If (Trim(sKeyName) = "") ;            Function_Return False
9634>>>>>        
9634>>>>>        Get GetKey sKeyName to hKey
9635>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9638>>>>>        Function_Return (hKey <>0)
9639>>>>>    End_Function
9640>>>>>    
9640>>>>>    Function ValueExists String sValueName Returns Boolean
9642>>>>>        // Determines whether a Value exists for the currently-opened Key.
9642>>>>>        Integer iError
9642>>>>>        DWord dwDataType
9642>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9643>>>>>        
9643>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9644>>>>>        
9644>>>>>        Function_Return (iError=0)
9645>>>>>    End_Function
9646>>>>>    
9646>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9648>>>>>        
9648>>>>>            If (Trim(sKeyName) = "") ;            Function_Return False
9651>>>>>        
9651>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9652>>>>>    End_Function
9653>>>>>    
9653>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9655>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9656>>>>>    End_Function
9657>>>>>    
9657>>>>>    Function Subkeys Returns String[]
9659>>>>>        Integer iError
9659>>>>>        Integer icValue iLongestSubkey
9659>>>>>        Handle hKey
9659>>>>>        DWord dwSubkeyNameLength
9659>>>>>        String sSubkeyName sFileTime
9659>>>>>        Pointer lpsSubkeyName
9659>>>>>        String[] aResult
9660>>>>>        tWinFileTime fileTime
9660>>>>>        tWinFileTime fileTime
9660>>>>>
9660>>>>>        Get LongestSubkeyLength to iLongestSubkey
9661>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
9662>>>>>        Move (AddressOf(sSubkeyName)) to lpsSubkeyName
9663>>>>>
9663>>>>>        Get phCurrentKey to hKey
9664>>>>>        Repeat
9664>>>>>>
9664>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9665>>>>>
9665>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(fileTime))) to iError
9666>>>>>            If (iError =0) Begin
9668>>>>>                Move (CString(sSubkeyName)) to aResult[icValue]
9669>>>>>                Increment icValue
9670>>>>>            End
9670>>>>>>
9670>>>>>        Until (iError)
9672>>>>>        Function_Return aResult
9673>>>>>    End_Function
9674>>>>>    
9674>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9676>>>>>        Integer iError
9676>>>>>        Integer icValue iLongestSubkey
9676>>>>>        Handle hKey
9676>>>>>        DWord dwSubkeyNameLength
9676>>>>>        WString wSubkeyName
9676>>>>>        tWinFileTime FileTime
9676>>>>>        tWinFileTime FileTime
9676>>>>>        
9676>>>>>        Get LongestSubkeyLength to iLongestSubkey
9677>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9678>>>>>        
9678>>>>>        Get phCurrentKey to hKey
9679>>>>>        Repeat
9679>>>>>>
9679>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9680>>>>>            
9680>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9681>>>>>            If (iError =0) Begin
9683>>>>>                Increment icValue
9684>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9685>>>>>            End
9685>>>>>>
9685>>>>>        Until (iError)
9687>>>>>        Function_Return icValue
9688>>>>>        
9688>>>>>    End_Function
9689>>>>>    
9689>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9691>>>>>        Integer iError
9691>>>>>        Integer icValue iLongestValue
9691>>>>>        Handle hKey
9691>>>>>        DWord dwValueNameLength
9691>>>>>        WString wValueName 
9691>>>>>        String sValueNameSize
9691>>>>>        Pointer lpsValueName
9691>>>>>        
9691>>>>>        Get LongestValueLength to iLongestValue
9692>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9693>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9694>>>>>        
9694>>>>>        Get phCurrentKey to hKey
9695>>>>>        Repeat
9695>>>>>>
9695>>>>>            Move (iLongestValue +1) to dwValueNameLength
9696>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9697>>>>>            If (iError =0) Begin
9699>>>>>                Increment icValue
9700>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9701>>>>>            End
9701>>>>>>
9701>>>>>        Until (iError)
9703>>>>>        Function_Return icValue
9704>>>>>        
9704>>>>>    End_Function
9705>>>>>    
9705>>>>>End_Class
9706>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cVersionInfo.pkg)
9706>>>>>Use VdfBase.pkg
9706>>>>>Use DLL.pkg
9706>>>>>Use tWinStructs.pkg
9706>>>>>Use WinKern.pkg
9706>>>>>
9706>>>>>Define VS_FF_DEBUG         for |CI$00000001
9706>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9706>>>>>Define VS_FF_PATCHED       for |CI$00000004
9706>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9706>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9706>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9706>>>>>
9706>>>>>// Note: String pointer lpFilename must refer to WString type.
9706>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9707>>>>>    
9707>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9707>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9709>>>>>    
9709>>>>>    DWord  dwResult
9709>>>>>    UWide  uwFileName
9709>>>>>    UWide  uwFileName
9709>>>>>
9709>>>>>    Send StringToWide aFilename (&uwFileName)
9710>>>>>    
9710>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9711>>>>>    Function_Return dwResult
9712>>>>>End_Function
9713>>>>>
9713>>>>>// Note: String pointers should be referring to WString items.
9713>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9714>>>>>    
9714>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9714>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9716>>>>>    
9716>>>>>    Integer iResult
9716>>>>>    UWide   uwFileName
9716>>>>>    UWide   uwFileName
9716>>>>>
9716>>>>>    Send StringToWide aFilename (&uwFileName)
9717>>>>>    
9717>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9718>>>>>    Function_Return iResult
9719>>>>>End_Function    
9720>>>>>
9720>>>>>// Note: String pointers should be referring to WString items.
9720>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9721>>>>>
9721>>>>>// Wrapper Function VerQueryValue (when using strings)
9721>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9723>>>>>    
9723>>>>>    Integer iResult
9723>>>>>    UWide   uwSubBlock
9723>>>>>    UWide   uwSubBlock
9723>>>>>    
9723>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9724>>>>>    
9724>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9725>>>>>    
9725>>>>>    Function_Return iResult
9726>>>>>End_Function
9727>>>>>
9727>>>>>
9727>>>>>Class cVersionInfo is a cObject
9728>>>>>    Procedure Construct_Object
9730>>>>>        Forward Send Construct_Object
9732>>>>>        
9732>>>>>        
9732>>>>>        Property Integer piVersionMajor
9733>>>>>        Property Integer piVersionMinor
9734>>>>>        Property Integer piVersionRelease
9735>>>>>        Property Integer piVersionBuild
9736>>>>>        
9736>>>>>        Property Boolean pbIncluded
9737>>>>>        Property Boolean pbSpecialBuild
9738>>>>>        Property Boolean pbPrivateBuild
9739>>>>>        
9739>>>>>    End_Procedure
9740>>>>>    
9740>>>>>    Procedure DoCreate WString sFileName
9742>>>>>        DWord dwHandle
9742>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9742>>>>>        WString sData
9742>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9742>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9742>>>>>        WString sSubBlock
9742>>>>>        Pointer pVsFixedFileInfo
9742>>>>>        
9742>>>>>        Move 0 to pVsFixedFileInfo
9743>>>>>        Move 0 to dwHandle
9744>>>>>        Move 0 to iVerSize
9745>>>>>        
9745>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9746>>>>>        Set pbIncluded to (iInfoSize <>0)
9747>>>>>        
9747>>>>>        If (pbIncluded(Self)) Begin
9749>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9750>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9751>>>>>            
9751>>>>>            If (iSuccess <>0) Begin
9753>>>>>                Move "\" to sSubBlock
9754>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9756>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9757>>>>>                    
9757>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9758>>>>>                    Set piVersionMajor to (Hi(iVersion))
9759>>>>>                    Set piVersionMinor to (Low(iVersion))
9760>>>>>                    
9760>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9761>>>>>                    Set piVersionRelease to (Hi(iVersion))
9762>>>>>                    Set piVersionBuild   to (Low(iVersion))
9763>>>>>                    
9763>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9764>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9765>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9766>>>>>                End
9766>>>>>>
9766>>>>>            End
9766>>>>>>
9766>>>>>            
9766>>>>>        End
9766>>>>>>
9766>>>>>    End_Procedure
9767>>>>>    
9767>>>>>End_Class
9768>>>Use GlobalFunctionsProcedures.pkg
9768>>>Use tWinStructs.pkg
9768>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9768>>>
9768>>>Register_Function phoWorkspace Returns Handle
9768>>>Register_Function phoCommandLine Returns Handle
9768>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9768>>>Register_Function GetApplicationName Returns String
9768>>>Register_Function GetApplicationFileName Returns String
9768>>>
9768>>>Register_Function Statusbar_State Returns Integer
9768>>>Register_Function Toolbar_State Returns Integer
9768>>>Register_Procedure Set Statusbar_State
9768>>>Register_Procedure Set Toolbar_State
9768>>>
9768>>>
9768>>>Class cApplication is a cObject
9769>>>    Procedure Construct_Object
9771>>>        Forward Send Construct_Object
9773>>>        
9773>>>        Move Self to ghoApplication
9774>>>        
9774>>>        Property Handle phoVersionInfo
9775>>>        Property Handle phoWorkspace
9776>>>        Property Handle phoCommandLine
9777>>>        Property Handle phoMainPanel       // main panel will set this for us.
9778>>>        Property String psHelpFile         // type of file is determined by peHelpType
9779>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9780>>>        
9780>>>        Property String psCompany "Data Access Worldwide"
9781>>>        Property String psProduct "DataFlex Applications"
9782>>>        Property String psVersion C_DFVersion
9783>>>        Property String psProgram (Module_Name(desktop))
9784>>>        
9784>>>        // set to '' to stop the auto open workspace behavior
9784>>>        Property String psAutoOpenWorkspace 'Config.ws'
9785>>>        
9785>>>        
9785>>>        Property Boolean pbPreserveEnvironment True
9786>>>        
9786>>>        Object oCommandLine is a cCommandLine
9788>>>            Delegate Set phoCommandLine to Self
9790>>>        End_Object
9791>>>        
9791>>>        Object oWorkspace is a cWorkspace
9793>>>            Delegate Set phoWorkspace to Self
9795>>>        End_Object
9796>>>        
9796>>>        Object oVersionInfo is a cVersionInfo
9798>>>            Delegate Set phoVersionInfo to Self
9800>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9801>>>        End_Object
9802>>>        
9802>>>        Set pbUseWindowsFont to True
9803>>>        
9803>>>    End_Procedure
9804>>>    
9804>>>    Procedure Destroy_Object
9806>>>        If (ghoApplication=Self) Begin
9808>>>            Move 0 to ghoApplication
9809>>>        End
9809>>>>
9809>>>        Forward Send Destroy_Object
9811>>>    End_Procedure
9812>>>    
9812>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9812>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9812>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9814>>>        Move bNext to gbKEnterNext
9815>>>    End_Procedure
9816>>>    
9816>>>    Function pbEnterKeyAsTabKey Returns Boolean
9818>>>        Function_Return gbKEnterNext
9819>>>    End_Function
9820>>>    
9820>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9822>>>// not used with webapp
9822>>>        Handle hoRegistry hoCommandBars
9822>>>        Handle hMonitor
9822>>>        Integer iError cxy
9822>>>        tWinWindowPlacement WindowPlacement
9822>>>        tWinWindowPlacement WindowPlacement
9822>>>        String sKey
9822>>>        Boolean bSuccess
9822>>>        String sObjectName
9822>>>        
9822>>>        If (pbPreserveEnvironment(Self)) Begin
9824>>>            Get Create U_cRegistry to hoRegistry
9825>>>            Set pfAccessRights of hoRegistry to KEY_READ
9826>>>            
9826>>>            Get RegistryKeyString to sKey
9827>>>            
9827>>>            If (bProgram = False) Begin
9829>>>                Move (sKey +"\WINDOWS") to sKey
9830>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9831>>>                Move (sKey +"\" +sObjectName) to sKey
9832>>>            End
9832>>>>
9832>>>            Else ;                Move (sKey + "\Preferences") to sKey
9834>>>            
9834>>>            Get OpenKey of hoRegistry sKey to bSuccess
9835>>>            
9835>>>            If bSuccess Begin
9837>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9839>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9840>>>                    If bSuccess Begin
9842>>>                        // Do not restore size if the window is not resizable
9842>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9844>>>                            // restore always works with outer size
9844>>>                            Get GuiWindowSize     of hoContainer to cxy
9845>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9846>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9847>>>                        End
9847>>>>
9847>>>                        
9847>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9847>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9847>>>                        If (bProgram) Begin
9849>>>                            // Test the top left point
9849>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9850>>>                            
9850>>>                            If (hMonitor = 0) Begin
9852>>>                                // test the bottom right point
9852>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9853>>>                            End
9853>>>>
9853>>>                            
9853>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9853>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9853>>>                            If (hMonitor = 0) Begin
9855>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9856>>>                            End
9856>>>>
9856>>>                        End
9856>>>>
9856>>>                        
9856>>>                        // Set the placement
9856>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9857>>>                    End
9857>>>>
9857>>>                End
9857>>>>
9857>>>                If bProgram Begin
9859>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9860>>>                    If not hoCommandBars Begin
9862>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9865>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9868>>>                    End
9868>>>>
9868>>>                End
9868>>>>
9868>>>                
9868>>>                Send CloseKey of hoRegistry
9869>>>            End
9869>>>>
9869>>>            
9869>>>            Send Destroy of hoRegistry
9870>>>        End
9870>>>>
9870>>>    End_Procedure
9871>>>    
9871>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9873>>>// not used with webapp
9873>>>        Handle hoRegistry
9873>>>        Integer iError
9873>>>        tWinWindowPlacement WindowPlacement
9873>>>        tWinWindowPlacement WindowPlacement
9873>>>        String sKey
9873>>>        Boolean bSuccess
9873>>>        Integer eShowCmd
9873>>>        String sObjectName
9873>>>        
9873>>>        If (pbPreserveEnvironment(Self)) Begin
9875>>>            Get Create U_cRegistry to hoRegistry
9876>>>            Get RegistryKeyString to sKey
9877>>>            
9877>>>            If (bProgram = False) Begin
9879>>>                Move (sKey +"\WINDOWS") to sKey
9880>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9881>>>                Move (sKey +"\" +sObjectName) to sKey
9882>>>            End
9882>>>>
9882>>>            Else ;                Move (sKey +"\Preferences") to sKey
9884>>>            
9884>>>            Get CreateKey of hoRegistry sKey to iError
9885>>>            If (iError = 0) Begin
9887>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9888>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9889>>>                If bSuccess Begin
9891>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9891>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9893>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9894>>>                    End
9894>>>>
9894>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9895>>>                End
9895>>>>
9895>>>                
9895>>>                If bProgram Begin
9897>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9898>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9899>>>                End
9899>>>>
9899>>>                
9899>>>                
9899>>>                Send CloseKey of hoRegistry
9900>>>            End
9900>>>>
9900>>>            
9900>>>            Send Destroy of hoRegistry
9901>>>        End
9901>>>>
9901>>>    End_Procedure
9902>>>    
9902>>>    
9902>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9904>>>        Integer ixySize ixSize iySize
9904>>>        Integer ixOffset iyOffset
9904>>>        
9904>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9904>>>        Move (0 - WindowPos.left) to ixOffset
9905>>>        Move (0 - WindowPos.top) to iyOffset
9906>>>        
9906>>>        Move 0 to WindowPos.left
9907>>>        Move 0 to WindowPos.top
9908>>>        
9908>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9909>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9910>>>        
9910>>>        // also make sure that the size of the window is <= the size of the main monitor
9910>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9911>>>        Move (low(ixySize))      to ixSize
9912>>>        Move (hi(ixySize))       to iySize
9913>>>        
9913>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9914>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9915>>>    End_Procedure
9916>>>    
9916>>>    
9916>>>    Function RegistryKeyString Returns String
9918>>>        String sCompany sProduct sVersion sProgram
9918>>>        
9918>>>        Get psCompany to sCompany
9919>>>        Get psProduct to sProduct
9920>>>        Get psVersion to sVersion
9921>>>        Get psProgram to sProgram
9922>>>        
9922>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9925>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9928>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
9931>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
9934>>>        
9934>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
9935>>>    End_Function
9936>>>    
9936>>>    Procedure WriteString String sSubKey String sValueName String sValueData
9938>>>        String sKey
9938>>>        Handle hoRegistry
9938>>>        Integer iError
9938>>>        
9938>>>        Get Create U_cRegistry to hoRegistry
9939>>>        Get RegistryKeyString to sKey
9940>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9943>>>        Get CreateKey of hoRegistry sKey to iError
9944>>>        If (iError = 0) Begin
9946>>>            Send WriteString of hoRegistry sValueName sValueData
9947>>>            Send CloseKey of hoRegistry
9948>>>        End
9948>>>>
9948>>>        
9948>>>        Send Destroy of hoRegistry
9949>>>    End_Procedure
9950>>>    
9950>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
9952>>>        String sKey
9952>>>        Handle hoRegistry
9952>>>        Integer iError
9952>>>        
9952>>>        Get Create U_cRegistry to hoRegistry
9953>>>        Get RegistryKeyString to sKey
9954>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9957>>>        Get CreateKey of hoRegistry sKey to iError
9958>>>        If (iError = 0) Begin
9960>>>            Send WriteInteger of hoRegistry sValueName iValueData
9961>>>            Send CloseKey of hoRegistry
9962>>>        End
9962>>>>
9962>>>        
9962>>>        Send Destroy of hoRegistry
9963>>>    End_Procedure
9964>>>    
9964>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9964>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
9966>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
9967>>>    End_Procedure
9968>>>    
9968>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
9970>>>        String sKey
9970>>>        Handle hoRegistry
9970>>>        Integer iError
9970>>>        
9970>>>        Get Create U_cRegistry to hoRegistry
9971>>>        Get RegistryKeyString to sKey
9972>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9975>>>        Get CreateKey of hoRegistry sKey to iError
9976>>>        If (iError = 0) Begin
9978>>>            Send WriteUInt of hoRegistry sValueName uValueData
9979>>>            Send CloseKey of hoRegistry
9980>>>        End
9980>>>>
9980>>>        
9980>>>        Send Destroy of hoRegistry
9981>>>    End_Procedure
9982>>>
9982>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
9984>>>        String sKey
9984>>>        Handle hoRegistry
9984>>>        Integer iError
9984>>>        
9984>>>        Get Create U_cRegistry to hoRegistry
9985>>>        Get RegistryKeyString to sKey
9986>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
9989>>>        Get CreateKey of hoRegistry sKey to iError
9990>>>        If (iError = 0) Begin
9992>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
9993>>>            Send CloseKey of hoRegistry
9994>>>        End
9994>>>>
9994>>>        
9994>>>        Send Destroy of hoRegistry
9995>>>    End_Procedure
9996>>>    
9996>>>    // returns true if both sub-key and value exists.
9996>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
9998>>>        String sKey
9998>>>        Handle hoRegistry
9998>>>        Boolean bOK
9998>>>        Get Create U_cRegistry to hoRegistry
9999>>>        Get RegistryKeyString to sKey
10000>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10003>>>        Get OpenKey of hoRegistry sKey to bOk
10004>>>        If (bOK) Begin
10006>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
10007>>>            Send CloseKey of hoRegistry
10008>>>        End
10008>>>>
10008>>>        Send Destroy of hoRegistry
10009>>>        Function_Return bOk
10010>>>    End_Function
10011>>>    
10011>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
10013>>>        String sKey sData
10013>>>        Handle hoRegistry
10013>>>        Boolean bOK
10013>>>        
10013>>>        Move sDefault to sData
10014>>>        Get Create U_cRegistry to hoRegistry
10015>>>        Get RegistryKeyString to sKey
10016>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10019>>>        Get OpenKey of hoRegistry sKey to bOk
10020>>>        If (bOK) Begin
10022>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
10025>>>            Send CloseKey of hoRegistry
10026>>>        End
10026>>>>
10026>>>        
10026>>>        Send Destroy of hoRegistry
10027>>>        Function_Return sData
10028>>>    End_Function
10029>>>    
10029>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
10031>>>        String sKey
10031>>>        Integer iData
10031>>>        Handle hoRegistry
10031>>>        Boolean bOK
10031>>>        
10031>>>        Move iDefault to iData
10032>>>        Get Create U_cRegistry to hoRegistry
10033>>>        Get RegistryKeyString to sKey
10034>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10037>>>        Get OpenKey of hoRegistry sKey to bOk
10038>>>        If bOK Begin
10040>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
10043>>>            Send CloseKey of hoRegistry
10044>>>        End
10044>>>>
10044>>>        
10044>>>        Send Destroy of hoRegistry
10045>>>        Function_Return iData
10046>>>    End_Function
10047>>>
10047>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
10047>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
10049>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
10050>>>    End_Function
10051>>>    
10051>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
10053>>>        String sKey
10053>>>        UInteger uData
10053>>>        Handle hoRegistry
10053>>>        Boolean bOK
10053>>>        
10053>>>        Move uDefault to uData
10054>>>        Get Create U_cRegistry to hoRegistry
10055>>>        Get RegistryKeyString to sKey
10056>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10059>>>        Get OpenKey of hoRegistry sKey to bOk
10060>>>        If bOK Begin
10062>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
10065>>>            Send CloseKey of hoRegistry
10066>>>        End
10066>>>>
10066>>>        
10066>>>        Send Destroy of hoRegistry
10067>>>        Function_Return uData
10068>>>    End_Function
10069>>>    
10069>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
10071>>>        String sKey
10071>>>        Handle hoRegistry
10071>>>        Boolean bOK bSuccess
10071>>>        
10071>>>        Get Create U_cRegistry to hoRegistry
10072>>>        Get RegistryKeyString to sKey
10073>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10076>>>        Get OpenKey of hoRegistry sKey to bOk
10077>>>        If bOK Begin
10079>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
10080>>>            Send CloseKey of hoRegistry
10081>>>        End
10081>>>>
10081>>>        
10081>>>        Send Destroy of hoRegistry
10082>>>        Function_Return bSuccess
10083>>>    End_Function
10084>>>    
10084>>>    Procedure DoOpenWorkspace String sWorkspace
10086>>>        // Tries to open in this order:
10086>>>        // 1) if absolute path, use that; otherwise
10086>>>        // 2) try to open in the path of the EXE; otherwise
10086>>>        // 3) load it via the Registered list
10086>>>        
10086>>>        Integer eOpened
10086>>>        String sError sWSFile
10086>>>        Handle hoWorkspace
10086>>>        Boolean bChangingWorkspace
10086>>>        
10086>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10086>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10086>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10086>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10086>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10086>>>        // that there should be no automatic opening of a worskpace.
10086>>>        Set psAutoOpenWorkspace to ""
10087>>>        
10087>>>        Get phoWorkspace to hoWorkspace
10088>>>        
10088>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10089>>>        If (bChangingWorkspace and ghoConnection) Begin
10091>>>            Send AutoDisconnect
10092>>>        End
10092>>>>
10092>>>        
10092>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10093>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10095>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10097>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10098>>>            End
10098>>>>
10098>>>        End
10098>>>>
10098>>>        If (eOpened <> wsWorkspaceOpened) Begin
10100>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10101>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10102>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10103>>>>
10103>>>            Abort
10104>>>>
10104>>>        End
10104>>>>
10104>>>        Else Begin
10105>>>            Send AutoConnect
10106>>>            Send OnWorkspaceOpened
10107>>>        End
10107>>>>
10107>>>    End_Procedure
10108>>>    
10108>>>    Procedure AutoConnect
10110>>>        If (ghoConnection) Begin
10112>>>            Send AutoConnect of ghoConnection
10113>>>        End
10113>>>>
10113>>>    End_Procedure
10114>>>    
10114>>>    Procedure AutoDisconnect
10116>>>        If (ghoConnection) Begin
10118>>>            Send AutoDisconnect of ghoConnection
10119>>>        End
10119>>>>
10119>>>    End_Procedure
10120>>>    
10120>>>    // send after a workspace is successfully opened and connected
10120>>>    Procedure OnWorkspaceOpened
10122>>>    End_Procedure
10123>>>    
10123>>>    Procedure OnCreate
10125>>>        // Event called when the Application object is ready to be used
10125>>>        // to open a Workspace, etc.
10125>>>    End_Procedure
10126>>>    
10126>>>    Procedure End_Construct_Object
10128>>>        String sName
10128>>>        Forward Send End_Construct_Object
10130>>>        Send OnCreate
10131>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10131>>>        Get psAutoOpenWorkspace to sName
10132>>>        If (sName<>"") Begin
10134>>>            Send DoOpenWorkspace sName
10135>>>        End
10135>>>>
10135>>>    End_Procedure
10136>>>    
10136>>>    Function GetApplicationFileName Returns String
10138>>>        // Returns the filename from Windows
10138>>>        Integer iNumChars
10138>>>        WString wFilename
10138>>>                
10138>>>        Move (Repeat(Character(0), 1024)) to wFilename
10139>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10140>>>        
10140>>>        Function_Return (CString(wFilename))
10141>>>    End_Function
10142>>>    
10142>>>    Function GetApplicationPath Returns String
10144>>>        // Returns the path of the Application (no trailing "\")
10144>>>        WString wApplicationFileName 
10144>>>        String sPath
10144>>>        Boolean bRemoved
10144>>>        
10144>>>        Get GetApplicationFileName  to wApplicationFileName
10145>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10146>>>        Move (CString(wApplicationFileName)) to sPath
10147>>>        
10147>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10150>>>        Function_Return sPath
10151>>>    End_Function
10152>>>    
10152>>>    Function GetApplicationName Returns String
10154>>>        // Returns the name of the Application (without its Path or Extension)
10154>>>        String sApplicationFileName 
10154>>>        WString wApplicationName
10154>>>        Boolean bRemoved
10154>>>        Integer iVoid
10154>>>        
10154>>>        Get GetApplicationFileName to sApplicationFileName
10155>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10156>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10157>>>        Function_Return (CString(wApplicationName))
10158>>>    End_Function
10159>>>    
10159>>>    Function DFRootPath Returns String
10161>>>        String sRoot
10161>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10164>>>        // Ensure it does not contain a trailing "\"
10164>>>        If (Right(sRoot,1) = "\") Begin
10166>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10167>>>        End
10167>>>>
10167>>>        Function_Return sRoot
10168>>>    End_Function
10169>>>    
10169>>>    Function DFBinPath Returns String
10171>>>        String sRoot
10171>>>        Get DFRootPath to sRoot
10172>>>        If (sRoot<>"") Begin
10174>>>            Move (sRoot+"\bin") to sRoot
10175>>>        End
10175>>>>
10175>>>        Else Begin
10176>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10176>>>            // bin path must be the same as the application path.
10176>>>            Get GetApplicationPath to sRoot
10177>>>        End
10177>>>>
10177>>>        Function_Return sRoot
10178>>>    End_Function
10179>>>    
10179>>>    // this just directs to the desktop property. If you are using an application object you are
10179>>>    // encouraged to set this here.
10179>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10181>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10182>>>    End_Procedure
10183>>>    
10183>>>    Function pbUseWindowsFont Returns Boolean
10185>>>        Boolean bUseWindowsFont
10185>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10186>>>        Function_Return bUseWindowsFont
10187>>>    End_Function
10188>>>    
10188>>>    // this just directs to the desktop property. If you are using an application object you are
10188>>>    // encouraged to set this here.
10188>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10190>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10191>>>    End_Procedure
10192>>>    
10192>>>    Function pbLegacyDialogRatio Returns Boolean
10194>>>        Boolean bLegacy
10194>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10195>>>        Function_Return bLegacy
10196>>>    End_Function
10197>>>End_Class
10198>>>
10198>>>
10198>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
10198>>>//****************************************************************************
10198>>>// $Module type: Class
10198>>>// $Module name: cDbUpdateHandler
10198>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
10198>>>// Web-site    : http://www.rdctools.com
10198>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
10198>>>//
10198>>>// Purpose     : A framework for doing automated code based updates of a database from within
10198>>>//               a program, when it is started.
10198>>>//
10198>>>// Description : Place _one_ object of this class right after the cApplication object.
10198>>>//               Then inside this object place a series of cDbUpdateVersion objects
10198>>>//               as childs. One child object for each new database update.
10198>>>//
10198>>>//               - OnPreUpdate is a pre-processing event called
10198>>>//               before any database changes are started.
10198>>>//               - OnPostUpdate is a post-processing event called after all
10198>>>//               database changes have taken place.
10198>>>//
10198>>>// Note        : If tables have been opened prior to an object of this class
10198>>>//               (e.g. in the cApplication object), those tables will be closed.
10198>>>//               In that case you need to use the OnPostUpdate hook event to re-open
10198>>>//               tables after the last update has finished.
10198>>>//
10198>>>// Security    : Before an update is attempted; three things are checked to ensure the
10198>>>//               database is not in use. Aka nobody else is running the application.
10198>>>//               - All tables are tested for "Open in Exclusive_Mode"
10198>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
10198>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
10198>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
10198>>>//                 folder and a bit-lock is performed for each start of the application and this
10198>>>//                 user counter is checked before an update is attempted.
10198>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
10198>>>//                            against the database being "in use", there is no such guarantee! The
10198>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
10198>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
10198>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
10198>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
10198>>>//                 automatically be released after the update is completed.
10198>>>//
10198>>>//
10198>>>// Usage       :  Use cDbUpdateHandler.pkg
10198>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
10198>>>//                    // Declare the table that contains a "database version" field.
10198>>>//                    Declare_Datafile Sys
10198>>>//                    // Either one of these syntaxes is fine:
10198>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
10198>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
10198>>>//
10198>>>//                    // Don't forget to increase the pnVersionNumber property for each
10198>>>//                    // cDbUpdateVersion object!
10198>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
10198>>>//                    // with the value of pnVersionNumber after each update has been finished.
10198>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
10198>>>//                        Set pnVersionNumber to 1.1
10198>>>//                        Use VersionUpdate1_1.pkg
10198>>>//                    End_Object
10198>>>//
10198>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
10198>>>//                        Set pnVersionNumber to 1.2
10198>>>//                        Use VersionUpdate1_2.pkg
10198>>>//                    End_Object
10198>>>//
10198>>>//                End_Object
10198>>>//
10198>>>//
10198>>>// $Rev History:
10198>>>//    2016-09-27  Module header created
10198>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
10198>>>//                take place before any tables have been opened, or errors
10198>>>//                could occur if the client database is out of sync with the
10198>>>//                compiled program.
10198>>>//                Added user counting checks + lockout while database is being
10198>>>//                updated.
10198>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
10198>>>//                as it is more in line with the child class cDbUpdateVersion name.
10198>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
10198>>>//****************************************************************************
10198>>>Use VdfBase.pkg
10198>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dferror.pkg)
10198>>>>>Use cWindowsErrorHandler.pkg
Including file: cWindowsErrorHandler.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWindowsErrorHandler.pkg)
10198>>>>>>>Use cBaseErrorHandler.pkg
Including file: cBaseErrorHandler.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cBaseErrorHandler.pkg)
10198>>>>>>>>>Use errornum.inc
10198>>>>>>>>>Use cTrappedErrors.pkg
Including file: cTrappedErrors.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cTrappedErrors.pkg)
10198>>>>>>>>>>>Define MAX_ERROR_NUMBER for 32766
10198>>>>>>>>>>>
10198>>>>>>>>>>>// This array stores the set of trapped errors as toggled ranges starting
10198>>>>>>>>>>>// with the errors that are trapped. The array should always contain 0 and
10198>>>>>>>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10198>>>>>>>>>>>// following items...
10198>>>>>>>>>>>//
10198>>>>>>>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10198>>>>>>>>>>>//
10198>>>>>>>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10198>>>>>>>>>>>// 10 through the rest are trapped.
10198>>>>>>>>>>>//
10198>>>>>>>>>>>Class cTrappedErrors is an array
10199>>>>>>>>>>>    Procedure Construct_Object
10201>>>>>>>>>>>        Forward Send Construct_Object
10203>>>>>>>>>>>        
10203>>>>>>>>>>>        Send initArray
10204>>>>>>>>>>>    End_Procedure
10205>>>>>>>>>>>    
10205>>>>>>>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10205>>>>>>>>>>>    Function findErrorLE Integer targetError Returns Integer
10207>>>>>>>>>>>        
10207>>>>>>>>>>>        Integer lowIndex hiIndex midIndex currError
10207>>>>>>>>>>>        
10207>>>>>>>>>>>        // If error is outside of boudary conditions, use
10207>>>>>>>>>>>        // value of closest valid error# instead.
10207>>>>>>>>>>>        If (targetError <= 0);            Move 1 to targetError
10210>>>>>>>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10214>>>>>>>>>>>        
10214>>>>>>>>>>>        Move 0 to lowIndex
10215>>>>>>>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10216>>>>>>>>>>>        
10216>>>>>>>>>>>        // midIndex will contain the closest error LE to target upon exit.
10216>>>>>>>>>>>        Repeat
10216>>>>>>>>>>>>
10216>>>>>>>>>>>            
10216>>>>>>>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10217>>>>>>>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10218>>>>>>>>>>>            
10218>>>>>>>>>>>            // midIndex is targetIndex if a match occurs
10218>>>>>>>>>>>            If (currError = targetError) ;                Function_Return midIndex
10221>>>>>>>>>>>            
10221>>>>>>>>>>>            // We are either on it or just below it.
10221>>>>>>>>>>>            If ( lowIndex = midIndex ) Begin
10223>>>>>>>>>>>                
10223>>>>>>>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
10226>>>>>>>>>>>                
10226>>>>>>>>>>>                Function_Return midIndex
10227>>>>>>>>>>>                
10227>>>>>>>>>>>            End
10227>>>>>>>>>>>>
10227>>>>>>>>>>>            
10227>>>>>>>>>>>            // No match, so move the boundaries.
10227>>>>>>>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10230>>>>>>>>>>>            Else ;                Move midIndex to lowIndex
10232>>>>>>>>>>>            
10232>>>>>>>>>>>        Until lowIndex gt hiIndex
10234>>>>>>>>>>>        
10234>>>>>>>>>>>        Function_Return midIndex
10235>>>>>>>>>>>        
10235>>>>>>>>>>>    End_Function
10236>>>>>>>>>>>    
10236>>>>>>>>>>>    // Boundaries of the table are assumed to hold error limits.
10236>>>>>>>>>>>    Procedure initArray
10238>>>>>>>>>>>        Send delete_data
10239>>>>>>>>>>>        Set array_value  0 to 0
10240>>>>>>>>>>>        Set array_value  1 to ( MAX_ERROR_NUMBER + 1 )
10241>>>>>>>>>>>    End_Procedure
10242>>>>>>>>>>>    
10242>>>>>>>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10242>>>>>>>>>>>    Function IsTrapped Integer Error# Returns Integer
10244>>>>>>>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10245>>>>>>>>>>>    End_Function
10246>>>>>>>>>>>    
10246>>>>>>>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10246>>>>>>>>>>>    // This routine leaves the array unsorted.
10246>>>>>>>>>>>    Procedure addError Integer Error#
10248>>>>>>>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value  ( item_count( Self ) ) to ( Integer( Error# ) )
10251>>>>>>>>>>>    End_Procedure
10252>>>>>>>>>>>    
10252>>>>>>>>>>>    // Set error to flagged state.
10252>>>>>>>>>>>    Procedure handleError Integer Error# Integer trapFlag
10254>>>>>>>>>>>        
10254>>>>>>>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10254>>>>>>>>>>>        
10254>>>>>>>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
10256>>>>>>>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10257>>>>>>>>>>>>
10257>>>>>>>>>>>            Procedure_Return
10258>>>>>>>>>>>        End
10258>>>>>>>>>>>>
10258>>>>>>>>>>>        
10258>>>>>>>>>>>        Get findErrorLE Error# to prevErrIndex
10259>>>>>>>>>>>        Get isTrapped   Error# to prevErrFlag
10260>>>>>>>>>>>        
10260>>>>>>>>>>>        // if eq, Error already handled in some range.
10260>>>>>>>>>>>        If (PrevErrFlag <> trapFlag) Begin
10262>>>>>>>>>>>            
10262>>>>>>>>>>>            // This is kind of complicated. If we are adding an error,
10262>>>>>>>>>>>            // we have to account for the error already being in the
10262>>>>>>>>>>>            // array as well as rejoining ranges that have been previously
10262>>>>>>>>>>>            // split and splitting ranges when adding a new flag.
10262>>>>>>>>>>>            
10262>>>>>>>>>>>            Get integer_value  ( prevErrIndex + 1 ) to nextErrValue
10263>>>>>>>>>>>            Get integer_value  prevErrIndex         to prevErrValue
10264>>>>>>>>>>>            
10264>>>>>>>>>>>            // Do this first so prevErrIndex stays valid.
10264>>>>>>>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10267>>>>>>>>>>>            Else ;                Send addError ( Error# + 1 )
10269>>>>>>>>>>>            
10269>>>>>>>>>>>            If ( prevErrValue < Error# ) ;                Send addError Error#
10272>>>>>>>>>>>            Else ;                Send delete_item prevErrIndex
10274>>>>>>>>>>>        End
10274>>>>>>>>>>>>
10274>>>>>>>>>>>        Send sort_items UPWARD_DIRECTION
10275>>>>>>>>>>>        
10275>>>>>>>>>>>    End_Procedure
10276>>>>>>>>>>>    
10276>>>>>>>>>>>    // Flag error as trappable
10276>>>>>>>>>>>    Procedure Trap_Error Integer Error#
10278>>>>>>>>>>>        Send handleError Error# 1
10279>>>>>>>>>>>    End_Procedure
10280>>>>>>>>>>>    
10280>>>>>>>>>>>    // Flag error as non-trappable
10280>>>>>>>>>>>    Procedure Ignore_Error Integer Error#
10282>>>>>>>>>>>        Send handleError Error# 0
10283>>>>>>>>>>>    End_Procedure
10284>>>>>>>>>>>    
10284>>>>>>>>>>>    // Flag all errors as trappable
10284>>>>>>>>>>>    Procedure Trap_All
10286>>>>>>>>>>>        Send initArray
10287>>>>>>>>>>>    End_Procedure
10288>>>>>>>>>>>    
10288>>>>>>>>>>>    // Flag all errors as non-trappable
10288>>>>>>>>>>>    Procedure Ignore_All
10290>>>>>>>>>>>        Send delete_data
10291>>>>>>>>>>>        Set array_value 0 to 0
10292>>>>>>>>>>>        Set array_value 1 to 1
10293>>>>>>>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10294>>>>>>>>>>>    End_Procedure
10295>>>>>>>>>>>End_Class
10296>>>>>>>>>>>
10296>>>>>>>>>Use LanguageText.pkg
10296>>>>>>>>>Use VdfBase.pkg
10296>>>>>>>>>
10296>>>>>>>>>// used by error handler and UserError to pull a caption out of the error string
10296>>>>>>>>>Define C_ErrorCaption for "*CAPTION*="
10296>>>>>>>>>
10296>>>>>>>>>Class cBaseErrorHandler is a cObject
10297>>>>>>>>>    Procedure Construct_Object
10299>>>>>>>>>        Forward Send Construct_Object
10301>>>>>>>>>        
10301>>>>>>>>>        Set delegation_mode to no_delegate_or_error
10302>>>>>>>>>        
10302>>>>>>>>>        // This is the caption that appears for unhandled errors dialog box
10302>>>>>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10303>>>>>>>>>        
10303>>>>>>>>>        // This is the caption that appears for standard user errors
10303>>>>>>>>>        Property String psUserErrorCaption C_$Error
10304>>>>>>>>>        
10304>>>>>>>>>        // If set false, this makes the error handler work the old way which
10304>>>>>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10304>>>>>>>>>        Property Boolean pbUnhandledErrorSupport       True
10305>>>>>>>>>        
10305>>>>>>>>>        Property Boolean pbErrorProcessingState False  // Flag which is sent when error is being processed. This stops error recursion.
10306>>>>>>>>>        
10306>>>>>>>>>        Property Integer piCurrentErrorNumber     0
10307>>>>>>>>>        Property Integer piCurrentErrorLine        0
10308>>>>>>>>>        
10308>>>>>>>>>        Property Integer[] paUserErrors       // Collection of sorted error numbers considered to be user errors. (note, this array must remain sorted!)
10309>>>>>>>>>        
10309>>>>>>>>>        
10309>>>>>>>>>        Object oTrappedErrors is a cTrappedErrors
10311>>>>>>>>>        End_Object
10312>>>>>>>>>        
10312>>>>>>>>>        Send DefineStandardUserErrors
10313>>>>>>>>>        
10313>>>>>>>>>        Move Self to Error_Object_Id
10314>>>>>>>>>        Move Self to ghoErrorHandler
10315>>>>>>>>>    End_Procedure
10316>>>>>>>>>    
10316>>>>>>>>>    Procedure DefineStandardUserErrors
10318>>>>>>>>>        Integer[] aUserErrors
10319>>>>>>>>>        
10319>>>>>>>>>        // define the standard user error numbers....
10319>>>>>>>>>        Move 0                                     to aUserErrors[0]
10320>>>>>>>>>        Move DFERR_NUMBER_TOO_LARGE                to aUserErrors[1]
10321>>>>>>>>>        Move DFERR_WINDOW_RANGE                    to aUserErrors[2]
10322>>>>>>>>>        Move DFERR_ENTRY_REQUIRED                  to aUserErrors[3]
10323>>>>>>>>>        Move DFERR_ENTER_A_NUMBER                  to aUserErrors[4]
10324>>>>>>>>>        Move DFERR_BAD_ENTRY                       to aUserErrors[5]
10325>>>>>>>>>        Move DFERR_ENTER_VALID_DATE                to aUserErrors[6]
10326>>>>>>>>>        Move DFERR_NUMERIC_RANGE                   to aUserErrors[7]
10327>>>>>>>>>        Move DFERR_DUPLICATE_REC                   to aUserErrors[8]
10328>>>>>>>>>        Move DFERR_TEXT_FIELD_TOO_LONG             to aUserErrors[9]
10329>>>>>>>>>        Move DFERR_FIND_PRIOR_BEG_OF_FILE          to aUserErrors[10]
10330>>>>>>>>>        Move DFERR_FIND_PAST_END_OF_FILE           to aUserErrors[11]
10331>>>>>>>>>        Move DFERR_NO_REC_TO_DELETE                to aUserErrors[12]
10332>>>>>>>>>        Move DFERR_FIELD_NOT_INDEXED               to aUserErrors[13]
10333>>>>>>>>>        Move DFERR_REC_NUMBER_RANGE                to aUserErrors[14]
10334>>>>>>>>>        Move DFERR_ENTER_VALID_REC_ID              to aUserErrors[15]
10335>>>>>>>>>        Move DFERR_OPERATOR_ERROR                  to aUserErrors[16]
10336>>>>>>>>>        Move DFERR_CANT_CHANGE_KEY_FIELD           to aUserErrors[17]
10337>>>>>>>>>        Move DFERR_NO_DELETE_RELATED_RECORDS_EXIST to aUserErrors[18]
10338>>>>>>>>>        Move DFERR_OPERATION_NOT_ALLOWED           to aUserErrors[19]
10339>>>>>>>>>        Move DFERR_OPERATOR                        to aUserErrors[20]
10340>>>>>>>>>        Move DFERR_XML_HTTP                        to aUserErrors[21]
10341>>>>>>>>>        Move DFERR_CLIENT_SOAP_TRANSFER            to aUserErrors[22]
10342>>>>>>>>>        Move DFERR_CLIENT_SOAP_FAULT               to aUserErrors[23]
10343>>>>>>>>>        Move DFERR_TEXT_TOO_LARGE_FOR_FIELD        to aUserErrors[24]
10344>>>>>>>>>        Move DFERR_WINPRINT                        to aUserErrors[25]
10345>>>>>>>>>        Move DFERR_CRYSTAL_REPORT                  to aUserErrors[26]
10346>>>>>>>>>        Move DFERR_MAPI                            to aUserErrors[27]
10347>>>>>>>>>        Move DFERR_FILE_ACCESS_VIOLATION           to aUserErrors[28]
10348>>>>>>>>>        Move DFERR_DATAFLEX_REPORTS                to aUserErrors[29]
10349>>>>>>>>>        Move DFERR_CANT_REFIND_RECORD              to aUserErrors[30]
10350>>>>>>>>>        // WebApp Errors
10350>>>>>>>>>        Move DFERR_WEBAPP_ACCESS_DENIED            to aUserErrors[31]
10351>>>>>>>>>        // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error number of DDs.
10351>>>>>>>>>        Move 999                                   to aUserErrors[32]
10352>>>>>>>>>        // This is session timeout (we keep the old number 950 for backwards comatibility reasons)
10352>>>>>>>>>        Move DFERR_WEBAPP_SESSION_TIMEOUT          to aUserErrors[33]
10353>>>>>>>>>        // This is session timeout (we keep the old number 951 for backwards comatibility reasons)
10353>>>>>>>>>        Move DFERR_WEBAPP_BAD_SESSION_KEY          to aUserErrors[34]
10354>>>>>>>>>        Move DFERR_WEBAPP_INVALID_URL              to aUserErrors[35]
10355>>>>>>>>>        Move DFERR_WEBAPP_INVALID_URL_REC          to aUserErrors[36]
10356>>>>>>>>>        Move (SortArray(aUserErrors)) to aUserErrors
10357>>>>>>>>>        Set paUserErrors to aUserErrors
10358>>>>>>>>>    End_Procedure
10359>>>>>>>>>    
10359>>>>>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
10361>>>>>>>>>        //  Stub method implemented by subclass
10361>>>>>>>>>    End_Procedure
10362>>>>>>>>>    
10362>>>>>>>>>    // Called by the runtime when an error occurs. Initiates the main error handling. Skips errors
10362>>>>>>>>>    // that are ignored and makes sure to prevent recursion by checking the error processing state.
10362>>>>>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrText
10364>>>>>>>>>        If (pbErrorProcessingState(Self)) ;            Procedure_Return
10367>>>>>>>>>            
10367>>>>>>>>>        If (not(IsTrapped(Self, iErrNum))) ;            Procedure_Return
10370>>>>>>>>>        
10370>>>>>>>>>        Set pbErrorProcessingState to True
10371>>>>>>>>>        Set piCurrentErrorNumber to iErrNum
10372>>>>>>>>>        Set piCurrentErrorLine to iErrLine
10373>>>>>>>>>        
10373>>>>>>>>>        Send HandleError iErrNum iErrLine sErrText
10374>>>>>>>>>        
10374>>>>>>>>>        Set piCurrentErrorNumber to 0
10375>>>>>>>>>        Set piCurrentErrorLine to 0
10376>>>>>>>>>        Move 0 to ghoErrorSource
10377>>>>>>>>>        Set pbErrorProcessingState to False
10378>>>>>>>>>    End_Procedure
10379>>>>>>>>>    
10379>>>>>>>>>    
10379>>>>>>>>>
10379>>>>>>>>>    
10379>>>>>>>>>    // Returns true if this is a user error (i.e. "find past end of file")
10379>>>>>>>>>    Function IsUserError Integer iError Returns Boolean
10381>>>>>>>>>        Integer[] aUserErrors
10382>>>>>>>>>        Get paUserErrors to aUserErrors
10383>>>>>>>>>        Function_Return (BinarySearchArray(iError, aUserErrors) <> -1)
10384>>>>>>>>>    End_Function
10385>>>>>>>>>    
10385>>>>>>>>>        // returns true if this is an unhandled error (i.e., not a user error
10385>>>>>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10387>>>>>>>>>        Integer[] UserErrors
10388>>>>>>>>>        Get paUserErrors to UserErrors
10389>>>>>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10390>>>>>>>>>    End_Function
10391>>>>>>>>>    
10391>>>>>>>>>    Procedure AddUserError Integer iError
10393>>>>>>>>>        // adds a user error to the collection of defined 'user errors'
10393>>>>>>>>>        Integer[] aUserErrors
10394>>>>>>>>>        Get paUserErrors to aUserErrors
10395>>>>>>>>>        
10395>>>>>>>>>        If (BinarySearchArray(iError, aUserErrors) = -1) Begin
10397>>>>>>>>>            Move (InsertInArray(aUserErrors, BinarySearchInsertPos(), iError)) to aUserErrors         // Keep the array sorted. Makes searching fast, adding slower.
10398>>>>>>>>>            Set paUserErrors to aUserErrors
10399>>>>>>>>>        End
10399>>>>>>>>>>
10399>>>>>>>>>    End_Procedure
10400>>>>>>>>>    
10400>>>>>>>>>    Procedure RemoveUserError Integer iError
10402>>>>>>>>>        // Removes the passed error number from the set of user errors.
10402>>>>>>>>>        Integer iIndex
10402>>>>>>>>>        Integer[] aUserErrors
10403>>>>>>>>>        
10403>>>>>>>>>        Get paUserErrors to aUserErrors
10404>>>>>>>>>        Move (BinarySearchArray(iError, aUserErrors)) to iIndex
10405>>>>>>>>>        
10405>>>>>>>>>        If (iIndex <> -1) Begin
10407>>>>>>>>>            Move (RemoveFromArray(aUserErrors, iIndex)) to aUserErrors
10408>>>>>>>>>            Set paUserErrors to aUserErrors
10409>>>>>>>>>        End
10409>>>>>>>>>>
10409>>>>>>>>>    End_Procedure
10410>>>>>>>>>    
10410>>>>>>>>>    Procedure RemoveAllUserErrors
10412>>>>>>>>>        // Clears set of User Errors
10412>>>>>>>>>        Set paUserErrors to (ResizeArray(paUserErrors(Self), 0))
10413>>>>>>>>>    End_Procedure
10414>>>>>>>>>    
10414>>>>>>>>>    // return true if an error number is critical
10414>>>>>>>>>    Function IsCritical Integer iError Returns Boolean
10416>>>>>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(iError)+"."))
10417>>>>>>>>>    End_Function
10418>>>>>>>>>    
10418>>>>>>>>>    Procedure TrapError Integer iError
10420>>>>>>>>>        Send Trap_Error of oTrappedErrors iError
10421>>>>>>>>>    End_Procedure
10422>>>>>>>>>    
10422>>>>>>>>>    Procedure IgnoreError Integer iError
10424>>>>>>>>>        Send Ignore_Error of oTrappedErrors iError
10425>>>>>>>>>    End_Procedure
10426>>>>>>>>>    
10426>>>>>>>>>    Procedure IgnoreAllErrors
10428>>>>>>>>>        Send Ignore_All of oTrappedErrors
10429>>>>>>>>>    End_Procedure
10430>>>>>>>>>    
10430>>>>>>>>>    Procedure TrapAllErrors
10432>>>>>>>>>        Send Trap_All of oTrappedErrors
10433>>>>>>>>>    End_Procedure
10434>>>>>>>>>    
10434>>>>>>>>>    Function IsTrapped Integer iError  Returns Boolean
10436>>>>>>>>>        Function_Return (IsTrapped(oTrappedErrors,iError))
10437>>>>>>>>>    End_Function
10438>>>>>>>>>    
10438>>>>>>>>>    
10438>>>>>>>>>
10438>>>>>>>>>    
10438>>>>>>>>>    // Used to fetch the default error description.
10438>>>>>>>>>    //
10438>>>>>>>>>    // iError   - Error number
10438>>>>>>>>>    // sMessage - Additional error message
10438>>>>>>>>>    // Returns  - Complete error message
10438>>>>>>>>>    Function ErrorDescription Integer iError String sMessage Returns String
10440>>>>>>>>>        String sDescription
10440>>>>>>>>>        Boolean bAvailable
10440>>>>>>>>>        
10440>>>>>>>>>        //  Fetch system error text
10440>>>>>>>>>        Get Error_Text of Desktop iError to sDescription
10441>>>>>>>>>        Get Error_Text_Available of Desktop iError to bAvailable
10442>>>>>>>>>        
10442>>>>>>>>>        //  Trim both messages
10442>>>>>>>>>        Move (Trim(sDescription)) to sDescription
10443>>>>>>>>>        Move (Trim(sMessage)) to sMessage
10444>>>>>>>>>        
10444>>>>>>>>>        //  Append message if needed
10444>>>>>>>>>        If (sMessage <> "") Begin
10446>>>>>>>>>            If (sDescription <> "" and bAvailable) Begin
10448>>>>>>>>>                Move (sDescription + " " + sMessage) to sDescription
10449>>>>>>>>>            End
10449>>>>>>>>>>
10449>>>>>>>>>            Else Begin
10450>>>>>>>>>                Move sMessage to sDescription
10451>>>>>>>>>            End
10451>>>>>>>>>>
10451>>>>>>>>>        End
10451>>>>>>>>>>
10451>>>>>>>>>        
10451>>>>>>>>>        Function_Return sDescription
10452>>>>>>>>>    End_Function
10453>>>>>>>>>    
10453>>>>>>>>>    // Legacy names here for backwards compatibility
10453>>>>>>>>>    Function Error_Description Integer iError String sMessage Returns String
10455>>>>>>>>>        Function_Return (ErrorDescription(Self, iError, sMessage))
10456>>>>>>>>>    End_Function
10457>>>>>>>>>    
10457>>>>>>>>>    
10457>>>>>>>>>    Function Error_processing_state Returns Boolean
10459>>>>>>>>>        Function_Return (pbErrorProcessingState(Self))
10460>>>>>>>>>    End_Function
10461>>>>>>>>>    
10461>>>>>>>>>    Function Current_Error_Number Returns Integer
10463>>>>>>>>>        Function_Return (piCurrentErrorNumber(Self))
10464>>>>>>>>>    End_Function
10465>>>>>>>>>    
10465>>>>>>>>>    Procedure Set Current_Error_Number Integer iErr
10467>>>>>>>>>        Set piCurrentErrorNumber to iErr
10468>>>>>>>>>    End_Procedure
10469>>>>>>>>>    
10469>>>>>>>>>    Function Error_Line_Number Returns Integer
10471>>>>>>>>>        Function_Return (piCurrentErrorLine(Self))
10472>>>>>>>>>    End_Function
10473>>>>>>>>>    
10473>>>>>>>>>    Procedure Set Error_Line_Number Integer iLine
10475>>>>>>>>>        Set piCurrentErrorLine to iLine
10476>>>>>>>>>    End_Procedure
10477>>>>>>>>>    
10477>>>>>>>>>    Procedure Trap_Error Integer iError
10479>>>>>>>>>        Send TrapError iError
10480>>>>>>>>>    End_Procedure
10481>>>>>>>>>    
10481>>>>>>>>>    Procedure Ignore_Error Integer iError
10483>>>>>>>>>        Send IgnoreError iError
10484>>>>>>>>>    End_Procedure
10485>>>>>>>>>    
10485>>>>>>>>>    Procedure Trap_All
10487>>>>>>>>>        Send TrapAllErrors
10488>>>>>>>>>    End_Procedure
10489>>>>>>>>>    
10489>>>>>>>>>    Procedure Ignore_All
10491>>>>>>>>>        Send IgnoreAllErrors
10492>>>>>>>>>    End_Procedure
10493>>>>>>>>>    
10493>>>>>>>>>    Function Is_Critical Integer iError Returns Boolean
10495>>>>>>>>>        Function_Return (IsCritical(Self, iError))
10496>>>>>>>>>    End_Function
10497>>>>>>>>>End_Class
10498>>>>>>>>>
10498>>>>>>>>>Procedure UserError Global String sMessage String sCaption
10500>>>>>>>>>    String sCapt
10500>>>>>>>>>    If (Error_Object_Id=0) Begin
10502>>>>>>>>>        Error DFERR_PROGRAM "No Error Handler"
10503>>>>>>>>>>
10503>>>>>>>>>        Procedure_Return
10504>>>>>>>>>    End
10504>>>>>>>>>>
10504>>>>>>>>>    
10504>>>>>>>>>    // Accept not passing a caption in which case the error handler's
10504>>>>>>>>>    // default caption. It had been the intention to require a caption ("" if none)
10504>>>>>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
10504>>>>>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
10504>>>>>>>>>    If (num_arguments>1) Begin
10506>>>>>>>>>        Move sCaption to sCapt
10507>>>>>>>>>    End
10507>>>>>>>>>>
10507>>>>>>>>>    
10507>>>>>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
10508>>>>>>>>>>
10508>>>>>>>>>End_Procedure
10509>>>>>>>Use Windows.pkg
10509>>>>>>>Use msgbox.pkg
10509>>>>>>>Use GlobalFunctionsProcedures.pkg
10509>>>>>>>
10509>>>>>>>Class cWindowsErrorHandler is a cBaseErrorHandler
10510>>>>>>>    Procedure Construct_Object
10512>>>>>>>        Forward Send Construct_Object
10514>>>>>>>        
10514>>>>>>>        
10514>>>>>>>        
10514>>>>>>>        // shows error numbers with user errors. Only set this true if your
10514>>>>>>>        // application has meaningful numbers that helps the end user. Note that
10514>>>>>>>        // unhandled errors always show numbers.
10514>>>>>>>        // this is ignored if pbUnhandledErrorSupport is false
10514>>>>>>>        Property Boolean pbShowErrorNumber        False
10515>>>>>>>        
10515>>>>>>>        //  This allows us to skip find errors (GT & LT) and to only
10515>>>>>>>        //  ring a bell when these occur.
10515>>>>>>>        //
10515>>>>>>>        Property Boolean pbBellOnFindErrorState True
10516>>>>>>>        
10516>>>>>>>        Property Integer pbVerboseState         True
10517>>>>>>>
10517>>>>>>>    End_Procedure
10518>>>>>>>    
10518>>>>>>>
10518>>>>>>>    
10518>>>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
10520>>>>>>>        String sCaption sCRLF
10520>>>>>>>        Move (Character(13)+Character(10)) to sCRLF
10521>>>>>>>        Get psUnhandledErrorCaption to sCaption
10522>>>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
10523>>>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
10524>>>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
10525>>>>>>>    End_Procedure
10526>>>>>>>    
10526>>>>>>>    // Handle error event, displaying error info to user.
10526>>>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
10528>>>>>>>        Integer iReply iIcon
10528>>>>>>>        String  sDescription sMess
10528>>>>>>>        String  sSource sCaption
10528>>>>>>>        Integer iSrcPos iSrc iTxtLen
10528>>>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
10528>>>>>>>        
10528>>>>>>>        
10528>>>>>>>        // if this is false, this will work old-style -- all errors go through message box
10528>>>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
10529>>>>>>>        
10529>>>>>>>        Get IsCritical iErrNum to bCritical
10530>>>>>>>        Get IsUnhandledError iErrNum to bIsUnhandled
10531>>>>>>>        
10531>>>>>>>        
10531>>>>>>>        //
10531>>>>>>>        //   Changes made so find errors don't report - just beep
10531>>>>>>>        //
10531>>>>>>>        If ( pbBellOnFindErrorState(Self) and ;             (iErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or iErrNum=DFERR_FIND_PAST_END_OF_FILE)) Begin
10533>>>>>>>            Send Bell
10534>>>>>>>        End
10534>>>>>>>>
10534>>>>>>>        Else Begin
10535>>>>>>>            
10535>>>>>>>            // See if source information is provided (Source = module.function). If so remove
10535>>>>>>>            // as detail. Must find last instance of this in string
10535>>>>>>>            Move (pos(C_ErrorContextSourceText,sErrText)) to iSrc
10536>>>>>>>            If (iSrc > 0) Begin
10538>>>>>>>                Move (iSrc-1) to iSrcPos
10539>>>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
10540>>>>>>>                Move sErrText to sSource
10541>>>>>>>                Repeat // this makes sure we find last instance of this
10541>>>>>>>>
10541>>>>>>>                    Move (Remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
10542>>>>>>>                    Move (Pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
10543>>>>>>>                    If (iSrc > 0) ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
10546>>>>>>>                Until (iSrc=0)
10548>>>>>>>                Move (Trim(Left(sErrText,iSrcPos))) to sErrText
10549>>>>>>>                If (Right(sErrText,1) = ',') ;                    Move (Left(sErrText,Length(sErrText) - 1)) to sErrText
10552>>>>>>>            End
10552>>>>>>>>
10552>>>>>>>            
10552>>>>>>>            // the caption normally used for handled user errors
10552>>>>>>>            Get psUserErrorCaption to sCaption
10553>>>>>>>            // if an operator error this may be a Procedure UserError situation where the
10553>>>>>>>            // caption is passed in the error text. If so, get the caption
10553>>>>>>>            If (iErrNum=DFERR_OPERATOR) Begin
10555>>>>>>>                Move (pos(C_ErrorCaption,sErrText)) to iSrc
10556>>>>>>>                If iSrc Begin
10558>>>>>>>                    Move (Length(C_ErrorCaption)) to  iTxtLen
10559>>>>>>>                    Move (Remove(sErrText, 1, iSrc-1 + iTxtLen )) to sCaption
10560>>>>>>>                    Move (Left(sErrText,iSrc-1)) to sErrText
10561>>>>>>>                End
10561>>>>>>>>
10561>>>>>>>            End
10561>>>>>>>>
10561>>>>>>>            
10561>>>>>>>            Get ErrorDescription iErrNum sErrText to sDescription
10562>>>>>>>            
10562>>>>>>>            // if the error source is identified we can get extended error
10562>>>>>>>            // text for our error message
10562>>>>>>>            If (ghoErrorSource > 0) Begin
10564>>>>>>>                Get extended_error_Message of ghoErrorSource to sMess
10565>>>>>>>                If (sMess <> '') ;                    Move (sDescription + "\n\n" + sMess ) to sDescription
10568>>>>>>>            End
10568>>>>>>>>
10568>>>>>>>            
10568>>>>>>>            If (bUnhandledSupport) Begin
10570>>>>>>>                // as of 14.1, this is the preferred way to do errors
10570>>>>>>>                If (bCritical or bIsUnhandled) Begin
10572>>>>>>>                    Move ( sDescription + "\n\n" + C_$Error + ":" * String(iErrNum) ) to sDescription
10573>>>>>>>                    If (sSource <> "") Begin
10575>>>>>>>                        Move (sDescription + "\n" + C_$ErrorSource +" =" * sSource) to sDescription
10576>>>>>>>                    End
10576>>>>>>>>
10576>>>>>>>                End
10576>>>>>>>>
10576>>>>>>>                Else If (pbShowErrorNumber(Self)) Begin
10579>>>>>>>                    // if a user error, we provide a way to see error numbers.
10579>>>>>>>                    Move ( sDescription + "\n\n" + C_$Error + ":" * String(iErrNum) ) to sDescription
10580>>>>>>>                End
10580>>>>>>>>
10580>>>>>>>            End
10580>>>>>>>>
10580>>>>>>>            Else Begin
10581>>>>>>>                // we get here if we want it to work the old (less good) way. This is provided
10581>>>>>>>                // only for backwards compatibility. All errors go through the message box
10581>>>>>>>                Get Verbose_State to bVerbose
10582>>>>>>>                If (bVerbose)  Begin
10584>>>>>>>                    Move ( sDescription + "\n\n" + SFormat(C_$TechnicalDetails, iErrNum, iErrLine) ) to sDescription
10585>>>>>>>                    If (sSource<>"") Begin
10587>>>>>>>                        Move (sDescription + "\n" + C_$ErrorSource +" =" * sSource) to sDescription
10588>>>>>>>                    End
10588>>>>>>>>
10588>>>>>>>                End
10588>>>>>>>>
10588>>>>>>>            End
10588>>>>>>>>
10588>>>>>>>            
10588>>>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
10590>>>>>>>                Send UnhandledErrorDisplay iErrLine sDescription
10591>>>>>>>            End
10591>>>>>>>>
10591>>>>>>>            Else Begin
10592>>>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
10593>>>>>>>                Move (Message_Box(sDescription, sCaption, MB_Ok, iIcon)) to iReply
10594>>>>>>>            End
10594>>>>>>>>
10594>>>>>>>            
10594>>>>>>>            // abort on critical errors
10594>>>>>>>            If bCritical ;                Abort
10597>>>>>>>            
10597>>>>>>>        End
10597>>>>>>>>
10597>>>>>>>        
10597>>>>>>>    End_Procedure
10598>>>>>>>    
10598>>>>>>>    
10598>>>>>>>    
10598>>>>>>>    Function Help_Context Integer Context_Type Returns String
10600>>>>>>>        Function_Return (Current_Error_Number(Self))
10601>>>>>>>    End_Function
10602>>>>>>>    
10602>>>>>>>    
10602>>>>>>>    
10602>>>>>>>    // The following functions are rarely or never used.
10602>>>>>>>    
10602>>>>>>>    // The functions below are used to construct a general help
10602>>>>>>>    // name for errors that are generated by the system.  If processing
10602>>>>>>>    // comes here, then there was no module specific help found.  These
10602>>>>>>>    // functions will provide a more general help name that appears in
10602>>>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
10602>>>>>>>    // places in the help file under this application and module name.
10602>>>>>>>    
10602>>>>>>>    // Returns "ERROR:errornum" to supply error help.
10602>>>>>>>    Function Help_Name Returns String
10604>>>>>>>        Function_Return (Append("ERROR:",lastErr))
10605>>>>>>>    End_Function
10606>>>>>>>    
10606>>>>>>>    Function Application_Name Returns String
10608>>>>>>>        Function_Return 'SYSTEM'
10609>>>>>>>    End_Function
10610>>>>>>>    
10610>>>>>>>    Function Module_Name Returns String
10612>>>>>>>        Function_Return ''
10613>>>>>>>    End_Function
10614>>>>>>>    
10614>>>>>>>    
10614>>>>>>>    // Legacy names here for backwards compatibility
10614>>>>>>>    Function Verbose_State Returns Boolean
10616>>>>>>>        Function_Return (pbVerboseState(Self))
10617>>>>>>>    End_Function
10618>>>>>>>    
10618>>>>>>>    Procedure Set Verbose_State Boolean bVal
10620>>>>>>>        Set pbVerboseState to bVal
10621>>>>>>>    End_Procedure
10622>>>>>>>    
10622>>>>>>>    Procedure Set Bell_on_Find_Error_State Boolean bVal
10624>>>>>>>        Set pbBellOnFindErrorState to bVal
10625>>>>>>>    End_Procedure
10626>>>>>>>    
10626>>>>>>>    Function Bell_on_Find_Error_State Returns Boolean
10628>>>>>>>        Function_Return (pbBellOnFindErrorState(Self))
10629>>>>>>>    End_Function
10630>>>>>>>End_Class
10631>>>>>
10631>>>>>// Legacy classnames
10631>>>>>Class ErrorSystem is a cWindowsErrorHandler
10632>>>>>End_Class
10633>>>>>
10633>>>>>Class Trapped_Errors_Array is a cTrappedErrors
10634>>>>>End_Class
10635>>>>>
10635>>>>>// Replace to make legacy code run that uses old names work
10635>>>>>
10635>>>>>Object oErrorHandler is a cWindowsErrorHandler
10637>>>>>End_Object
10638>>>>>
10638>>>Use seq_chnl.pkg
10638>>>Use Datadict.pkg
Including file: Datadict.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Datadict.pkg)
10638>>>>>Use VDFBase.pkg
10638>>>>>Use LanguageText.pkg // language support VDF pkg replacement strings
10638>>>>>
10638>>>>>Register_Procedure File_Field_Value_Changed
10638>>>>>Register_Procedure File_Field_Mask_Changed
10638>>>>>Register_Procedure File_Field_Label_Changed
10638>>>>>Register_Procedure File_Field_Option_Changed
10638>>>>>Register_Function  Extended_DEO_State Returns Integer
10638>>>>>Register_Function  Entry_Refresh_State Returns Integer
10638>>>>>Register_Procedure Set Entry_Refresh_State Integer iState
10638>>>>>Register_Function  Allow_Foreign_New_Save_State Returns Integer
10638>>>>>Register_Function  Server Returns Integer
10638>>>>>
10638>>>>>Use Data_Set.pkg
Including file: Data_set.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Data_set.pkg)
10638>>>>>>>Use VDFBase.pkg
10638>>>>>>>Use fndmodes.pkg
Including file: fndmodes.pkg    (C:\Program Files\DataFlex 24.0\Pkg\fndmodes.pkg)
10638>>>>>>>>>//
10638>>>>>>>>>// special find modes
10638>>>>>>>>>//
10638>>>>>>>>>Define NEXT_RECORD  for 5 // find-next
10638>>>>>>>>>Define FIRST_RECORD for 6 // find-first
10638>>>>>>>>>Define LAST_RECORD  for 7 // find-last 
10638>>>>>>>Use refmodes.pkg
Including file: refmodes.pkg    (C:\Program Files\DataFlex 24.0\Pkg\refmodes.pkg)
10638>>>>>>>>>//
10638>>>>>>>>>// constants for REFRESH message parameter values
10638>>>>>>>>>//
10638>>>>>>>>>Define MODE_CLEAR             for 1  //notification from origin of clear
10638>>>>>>>>>Define MODE_FIND_OR_CLEAR_SET for 2  //notification from find or clear
10638>>>>>>>>>Define MODE_CLEAR_ALL         for 3  //notification from clear-all
10638>>>>>>>>>Define MODE_DELETE            for 4  //notification after successful delete
10638>>>>>>>>>Define MODE_SAVE              for 5  //notification after successful save
10638>>>>>>>>>
10638>>>>>>>
10638>>>>>>>
10638>>>>>>>//
10638>>>>>>>//Global integer status values
10638>>>>>>>//
10638>>>>>>>Define OPERATION_MODE   for |VI99  //status of data-sets in application
10638>>>>>>>Define OPERATION_ORIGIN for |VI108 //origin of current of data-set operation
10638>>>>>>>
10638>>>>>>>//
10638>>>>>>>//Constants for Operation_Mode global int values
10638>>>>>>>//
10638>>>>>>>Define MODE_WAITING  for 0  //wait-mode
10638>>>>>>>Define MODE_FINDING  for 1  //find-mode
10638>>>>>>>Define MODE_CLEARING for 2  //clear-mode
10638>>>>>>>Define MODE_CREATING for 3  //create-mode
10638>>>>>>>Define MODE_SAVING   for 4  //save-mode
10638>>>>>>>Define MODE_DELETING for 5  //delete-mode
10638>>>>>>>Define MODE_ABORTING for 6  //abort-mode
10638>>>>>>>Define MODE_VALIDATING for 7  //request_validate-mode : added for VDF7
10638>>>>>>>Define MODE_CLEARINGALL for 8 //clear-all mode (added in VDF8)
10638>>>>>>>
10638>>>>>>>//   The Data_Set class is implemented as a subclass of Entry_Client, with
10638>>>>>>>//   a C language handler providing the majority of new behavior.  The
10638>>>>>>>//   Data_Set class is intended to be a grouping agent for data-entry objects
10638>>>>>>>//   and a container for subordinate Data_Sets.
10638>>>>>>>//
10638>>>>>>>Use BaseData_Set.pkg
10638>>>>>>>
10638>>>>>>>// Data_Set class definition, public class layer. (Extra class layer needed
10638>>>>>>>// to augment C-based (Constrain) procedure(s).)
10638>>>>>>>
10638>>>>>>>Class DataSet is a BaseData_Set
10639>>>>>>>    
10639>>>>>>>    
10639>>>>>>>    // maintain old name for the time being to maximize compatability
10639>>>>>>>    // between character mode and windows versions. Developers should be
10639>>>>>>>    // able to move DS classes back and forth without changes.
10639>>>>>>>    Replace_Class_Name Data_Set DataSet
10639>>>>>>>    
10639>>>>>>>    Procedure Construct_Object //Integer Img#
10641>>>>>>>        Forward Send Construct_Object No_Image //Img#
10643>>>>>>>        
10643>>>>>>>        Property Integer Constrain_File 0
10644>>>>>>>        Property Integer Auto_Fill_State False
10645>>>>>>>        Property Integer Change_Disabled_State  False
10646>>>>>>>        // RT sets this inside of Mark_components a part of old entry_client DSO behavior. Now it is never used
10646>>>>>>>        Property Integer Component_State False
10647>>>>>>>        
10647>>>>>>>    End_Procedure
10648>>>>>>>    
10648>>>>>>>    
10648>>>>>>>    //
10648>>>>>>>    // This may be called by legacy DSO and DDO code
10648>>>>>>>    //
10648>>>>>>>    // IMPORTANT NOTE of change for 8.2:
10648>>>>>>>    //         DO NOT call or augment this anymore.
10648>>>>>>>    //
10648>>>>>>>    //         for sending: Find all cases of Field_main_index and change it to File_Field_Index
10648>>>>>>>    //
10648>>>>>>>    //         for augmenting: In DSOs - replace Field_main_index with File_field_index
10648>>>>>>>    //                         In DDOs - replace Field_main_Index with Field_Index and do not pass
10648>>>>>>>    //                                   the file parameter.
10648>>>>>>>    //                                   See DDOs Field_index and File_field_Index for more
10648>>>>>>>    //
10648>>>>>>>    Function Field_Main_Index Integer file Integer Field Returns Integer
10650>>>>>>>        Integer dataType fldNdx retval ordr
10650>>>>>>>        Move -1 to retval      //field has no main index (default)
10651>>>>>>>        If (file <> 0) Begin
10653>>>>>>>//      FIELD_DEF file field to dataType fldNdx
10653>>>>>>>            Get_Attribute DF_FIELD_INDEX of file Field to fldNdx // main index field
10656>>>>>>>            If (fldNdx > 0 or Field = 0) ;                Move fldNdx to retval //field has main index
10659>>>>>>>        End
10659>>>>>>>>
10659>>>>>>>        If (file = main_file(Self)) Begin
10661>>>>>>>            Get ordering to ordr
10662>>>>>>>            If (ordr >= 0) ;                Move ordr to retval  //ordering takes precedence over main index
10665>>>>>>>        End
10665>>>>>>>>
10665>>>>>>>        Function_Return retval
10666>>>>>>>    End_Function
10667>>>>>>>    
10667>>>>>>>    // This allows packages that still use data-sets instead of DDOs to use this
10667>>>>>>>    // message syntax.
10667>>>>>>>    // Note that this will never get here if the DD class is used as
10667>>>>>>>    // it has its own handler for this. It only is called if DSOs are used in which
10667>>>>>>>    // case it calls the old message field_main_index above.
10667>>>>>>>    // DDO based objects will NEVER call this code
10667>>>>>>>    //
10667>>>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
10669>>>>>>>        Function_Return (Field_main_Index(Self,iFile,iField))
10670>>>>>>>    End_Function
10671>>>>>>>    
10671>>>>>>>    
10671>>>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
10673>>>>>>>        
10673>>>>>>>        RowID   riRow
10673>>>>>>>        Integer iIndex
10673>>>>>>>        Handle  hoServer
10673>>>>>>>        Integer iSegments iSeg iSegFld iSegFldMainIndex
10673>>>>>>>        Boolean bChanged bDoCheck bOk
10673>>>>>>>        
10673>>>>>>>        //Get Field_Main_Index iFile iField to iIndex
10673>>>>>>>        Get File_Field_Index iFile iField to iIndex
10674>>>>>>>        If (iIndex<>-1) Begin
10676>>>>>>>            // get prior rowId before it get cleared
10676>>>>>>>            Move (GetRowID(iFile)) to riRow
10677>>>>>>>            //  'hold' buffer to prepare for entry_update
10677>>>>>>>            Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
10680>>>>>>>            If bDoEntryUpdate Begin
10682>>>>>>>                Send Request_Entry_Update iFile 1  //entUpdt all DEOs as required
10683>>>>>>>                
10683>>>>>>>                // If the buffer is cleared (no record and no changed data) then we want
10683>>>>>>>                // to do a constrained_clear which will force the buffer to get cleared
10683>>>>>>>                // according to the rules of the current constraints.
10683>>>>>>>                //Get_field_value iFile 0 to iRec
10683>>>>>>>                //Move (GetRowID(iFile)) to riRow // 12.1 moved above the set file inactive
10683>>>>>>>                
10683>>>>>>>                // If there was an active record to begin with we consider this changed (not cleared)
10683>>>>>>>                If (not(IsNullRowId(riRow))) Begin
10685>>>>>>>                    Move True to bChanged
10686>>>>>>>                End
10686>>>>>>>>
10686>>>>>>>                Else Begin
10687>>>>>>>                    // or, if the record was already changed or the entry_update created a change
10687>>>>>>>                    // we consider this changed
10687>>>>>>>                    Get_Attribute DF_FILE_CHANGED of iFile to bChanged
10690>>>>>>>                End
10690>>>>>>>>
10690>>>>>>>                
10690>>>>>>>                If not bChanged Begin
10692>>>>>>>                    // if buffer is unchanged, do a constrained clear. It is unchanged if there was not
10692>>>>>>>                    // active record, the record was unchanged, and the update didn't change anything.
10692>>>>>>>                    Constrained_Clear eFindMode iFile by iIndex
10695>>>>>>>                End
10695>>>>>>>>
10695>>>>>>>                Else If (eFindMode=GE or eFindMode=LE and iIndex>0) Begin
10698>>>>>>>                    
10698>>>>>>>                    // If mode is GE or LE we need to do some extra processing. We want to clear
10698>>>>>>>                    // all index segemnt fields that occur after this field in the index. This way
10698>>>>>>>                    // dbList searches and find ge searches (f9) will always find the first record
10698>>>>>>>                    // that matches the data in the field being searched. This was if an index like
10698>>>>>>>                    // customer.name x customer.number where you had 10 identical names "john" typing
10698>>>>>>>                    // john will find the first record, because customer.number will get cleared.
10698>>>>>>>                    // Note we can no do this with GT or LT or you'd get stuck in fields
10698>>>>>>>                    
10698>>>>>>>                    // check all fields for index. Once you find the iField field, clear all
10698>>>>>>>                    // fields that follow it. Only do this if the other fields do not use the
10698>>>>>>>                    // same index as its primary index (in which case we assume the data is intentional).
10698>>>>>>>                    // This should handle most cases.
10698>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
10701>>>>>>>                    For iSeg from 1 to iSegments
10707>>>>>>>>
10707>>>>>>>                        Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSeg to iSegFld
10710>>>>>>>                        If not bDoCheck Begin
10712>>>>>>>                            If (iSegFld=iField) ;                                Move True to bDoCheck // marked after we find the find field in the index
10715>>>>>>>                        End
10715>>>>>>>>
10715>>>>>>>                        Else Begin // we get here after we've found the main field segment
10716>>>>>>>                            // if main index if this segment is same as our find index, do nothing
10716>>>>>>>                            Get File_Field_Index iFile iSegFld to iSegFldMainIndex
10717>>>>>>>                            If (iSegFldMainIndex<>iIndex) ;                                Set_Field_Value iFile iSegFld to ''
10722>>>>>>>                        End
10722>>>>>>>>
10722>>>>>>>                    Loop
10723>>>>>>>>
10723>>>>>>>                End
10723>>>>>>>>
10723>>>>>>>                
10723>>>>>>>                Get Which_Data_Set iFile to hoServer
10724>>>>>>>                If (hoServer and iFile=main_file(hoServer)) ;                    Send Attach_Main_File to hoServer
10727>>>>>>>                Else ;                    Attach iFile
10729>>>>>>>            End
10729>>>>>>>>
10729>>>>>>>            
10729>>>>>>>            Move False to Err
10730>>>>>>>            
10730>>>>>>>            If (Is_SuperFind_Required(Self,iFile)) ;                Send Request_SuperFind eFindMode iFile iField
10733>>>>>>>            Else If bDeferred ;                Send Request_Read eFindMode iFile iIndex
10737>>>>>>>            Else ;                Send Request_Find eFindMode iFile iIndex
10739>>>>>>>            
10739>>>>>>>            If (not(Found) and not(err)) Begin
10741>>>>>>>                // refind original record (or leave it cleared if not record)
10741>>>>>>>                Move (FindByRowId(iFile,riRow)) to bOk
10742>>>>>>>                
10742>>>>>>>                If bShowFindErr ;                    Error (If(eFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
10745>>>>>>>                Move False to Found
10746>>>>>>>            End
10746>>>>>>>>
10746>>>>>>>        End
10746>>>>>>>>
10746>>>>>>>        Else ;            If bShowFindErr ;                Error DFERR_FIELD_NOT_INDEXED
10750>>>>>>>    End_Procedure
10751>>>>>>>    
10751>>>>>>>    
10751>>>>>>>    // We only care about should_saves of DEOs and not DSOs when
10751>>>>>>>    // exiting the app. Create a handler for data set class. We still
10751>>>>>>>    // broadcast in case we've got nested deos in the dso (hopefully not).
10751>>>>>>>    //
10751>>>>>>>    Function Exit_Application_Check Returns Integer
10753>>>>>>>        Integer rVal
10753>>>>>>>        Broadcast Get Exit_Application_Check to Rval // check w/ kids
10755>>>>>>>        Function_Return rVal
10756>>>>>>>    End_Function
10757>>>>>>>    
10757>>>>>>>    Procedure Constrain
10759>>>>>>>        Integer iFile
10759>>>>>>>        Send OnConstrain
10760>>>>>>>        Forward Send Constrain
10762>>>>>>>        Get Constrain_File to iFile
10763>>>>>>>        If iFile ;            Constrain (Main_file(Self)) relates to iFile
10766>>>>>>>    End_Procedure
10767>>>>>>>    
10767>>>>>>>    Procedure OnConstrain
10769>>>>>>>    End_Procedure
10770>>>>>>>    
10770>>>>>>>    // Less confusing Message for adding Updating servers
10770>>>>>>>    //
10770>>>>>>>    Procedure Set DDO_Server Handle ObjId
10772>>>>>>>        Send Attach_Server ObjId
10773>>>>>>>    End_Procedure
10774>>>>>>>    
10774>>>>>>>    // This is called when a view takes or retakes the
10774>>>>>>>    // focus. If DD not in use, do nothing.
10774>>>>>>>    //
10774>>>>>>>    Procedure Refind_DD_Records
10776>>>>>>>        If (in_use_state(Self)) ;            Send refind_records
10779>>>>>>>    End_Procedure
10780>>>>>>>    
10780>>>>>>>    // this returns true if the data-set is changed AND there are attached
10780>>>>>>>    // DEO objects. Without this you can get "changes exist" condition reported
10780>>>>>>>    // that the user will have no way of saving.
10780>>>>>>>    //
10780>>>>>>>    Function Data_Set_Should_Save Returns Integer
10782>>>>>>>        Function_Return (Should_Save(Self) and ;            Data_Set_User_interface_count(Self))
10783>>>>>>>    End_Function
10784>>>>>>>    
10784>>>>>>>    // returns 0 indicating that this is not DD enabled. DataDictionary objects will return 1.
10784>>>>>>>    // Add DSOs and DDOs must understand this message
10784>>>>>>>    
10784>>>>>>>    Function Extended_DSO_State Returns Integer
10786>>>>>>>        Function_Return 0
10787>>>>>>>    End_Function
10788>>>>>>>    
10788>>>>>>>    
10788>>>>>>>End_Class
10789>>>>>>>
10789>>>>>>>
10789>>>>>>>
10789>>>>>Use DDValtbl.pkg  // validation table classes
Including file: Ddvaltbl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Ddvaltbl.pkg)
10789>>>>>>>//  Validation Table Support for Extended Data-Sets. Fields may
10789>>>>>>>//  attached to validation tables which can then be used for
10789>>>>>>>//  validation (if Validate_state is true) or list loading.
10789>>>>>>>//  Developers can create their own validation tables as long as they
10789>>>>>>>//  conform to the following external interface:
10789>>>>>>>//
10789>>>>>>>// Properties
10789>>>>>>>//   Static_State       - if list must be rebuilt each validation, load
10789>>>>>>>//   Allow_Blank_state  - If Blank or 0 is a valid response
10789>>>>>>>//   Validate_State     - should table be used for validation
10789>>>>>>>//   Table_Loaded_State - is the validation table initialized?
10789>>>>>>>//
10789>>>>>>>// Methods
10789>>>>>>>//  Get Validate_Value sValue to iVal - if iVal=0, it is legal
10789>>>>>>>//  Send Fill_list                    - fills a static list
10789>>>>>>>//  Send Request_Fill_From_List iObject iMessage
10789>>>>>>>//        This is a callback that will fill an external list by sending
10789>>>>>>>//        the passed message (iMessage) back to the requesting object
10789>>>>>>>//        (iObject). It will send this message for each item in the
10789>>>>>>>//        validation table. It always passes back four params. Those are:
10789>>>>>>>//                     iItem - Item count being passed back
10789>>>>>>>//                     sData - The Database value of the item
10789>>>>>>>//                     sDesc - The Value's description, "" if none
10789>>>>>>>//                     iFile - File number associated with the item (if any)
10789>>>>>>>//                     iRec  - Record associated with the item (if any)
10789>>>>>>>// Developers can create classes of any complexity to support validation
10789>>>>>>>// tables. We have provided the following four classes.
10789>>>>>>>//
10789>>>>>>>//  ValidationTable is an Array
10789>>>>>>>//           Provides simple one dimensional table support. The table must be
10789>>>>>>>//           loaded manually by creating fill_list and sending the message
10789>>>>>>>//           Add_Table_Value (send Add_Table_Value Value). If list is static
10789>>>>>>>//           it is filled once. If non-static it is filled each time it is
10789>>>>>>>//           requested to validate or fill a foreign lis.
10789>>>>>>>//
10789>>>>>>>//  DescriptionValidationTable is a ValidationTable
10789>>>>>>>//           Provides a more complex three dimension array allowing the
10789>>>>>>>//           object to store a data value, description value and a record
10789>>>>>>>//           number. The developer must fill this list using the Add_table_
10789>>>>>>>//           value message passing up to three values (data, desc, record).
10789>>>>>>>//
10789>>>>>>>//  FileValidationTable is a DescriptionValidationTable
10789>>>>>>>//           Provides a data aware table. This can be used to load data from
10789>>>>>>>//           data-files, from data-sets. If you use data-sets you can place
10789>>>>>>>//           constraints within the data-set. You must define the file-number,
10789>>>>>>>//           data-set (if any), the file index, the file's data field, and
10789>>>>>>>//           the file's description field. You can also define an optional
10789>>>>>>>//           "Type". All records are constrained to this type (with or with-
10789>>>>>>>//           data-sets). If is assumed that this file has an optimized finding
10789>>>>>>>//           index.
10789>>>>>>>//
10789>>>>>>>//  CodeValidationTable is a FileValidationTable
10789>>>>>>>//           Used for Code lists. Simply set Type_Value to the "type"
10789>>>>>>>//
10789>>>>>>>Use VDFBase.pkg
10789>>>>>>>
10789>>>>>>>
10789>>>>>>>Class ValidationTable is an Array
10790>>>>>>>    
10790>>>>>>>    Procedure Construct_Object
10792>>>>>>>        Forward Send Construct_Object
10794>>>>>>>        Property Integer Static_State        True
10795>>>>>>>        
10795>>>>>>>        Property Integer Table_Loaded_State  False
10796>>>>>>>        
10796>>>>>>>        Property Integer Validate_State      True
10797>>>>>>>        Property Integer Allow_Blank_State   False
10798>>>>>>>        Property Integer Main_File           0
10799>>>>>>>        Property String  Table_Title         DD_VALIDATION_LIST_TITLE
10800>>>>>>>        
10800>>>>>>>        Property Integer Number_Elements     1
10801>>>>>>>        
10801>>>>>>>        // System maintained. Sub-classes use these
10801>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
10801>>>>>>>        
10801>>>>>>>        Property String  Current_Code            ''
10802>>>>>>>        
10802>>>>>>>        Property String  Current_Description     ''
10803>>>>>>>        
10803>>>>>>>        Property RowID Current_RowId
10804>>>>>>>    End_Procedure
10805>>>>>>>    
10805>>>>>>>    Function Data_Item_Count Returns Integer
10807>>>>>>>        Function_Return (Item_Count(Self))
10808>>>>>>>    End_Function
10809>>>>>>>    
10809>>>>>>>    Function Data_Value Integer iItem Returns String
10811>>>>>>>        Function_Return (Value(Self,iItem))
10812>>>>>>>    End_Function
10813>>>>>>>    
10813>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
10815>>>>>>>        Set Value  iItem to sValue
10816>>>>>>>    End_Procedure
10817>>>>>>>    
10817>>>>>>>    Function Data_Description Integer iItem Returns String
10819>>>>>>>        Function_Return ''
10820>>>>>>>    End_Function
10821>>>>>>>    
10821>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
10823>>>>>>>    End_Procedure
10824>>>>>>>    
10824>>>>>>>    Function Data_RowId Integer iItem Returns RowID
10826>>>>>>>        Function_Return (NullRowId())
10827>>>>>>>    End_Function
10828>>>>>>>    
10828>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
10830>>>>>>>    End_Procedure
10831>>>>>>>    
10831>>>>>>>    
10831>>>>>>>    Procedure Add_Table_Value String sValue
10833>>>>>>>        Set Data_Value  (Data_Item_Count(Self)) to sValue
10834>>>>>>>    End_Procedure
10835>>>>>>>    
10835>>>>>>>    Function Validate_Value String sCode Returns Integer
10837>>>>>>>        Integer iMax
10837>>>>>>>        Integer iCnt
10837>>>>>>>        If (sCode = '');            Function_Return (not(Allow_Blank_State(Self)))
10840>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10842>>>>>>>            Send Delete_Data
10843>>>>>>>            Send Fill_list
10844>>>>>>>            Set Table_Loaded_State to True
10845>>>>>>>        End
10845>>>>>>>>
10845>>>>>>>        Get Data_Item_Count to iMax
10846>>>>>>>        Decrement iMax
10847>>>>>>>        For iCnt from 0 to iMax
10853>>>>>>>>
10853>>>>>>>            If (sCode=Data_Value(Self,iCnt)) Begin
10855>>>>>>>                Set Current_Code        to sCode
10856>>>>>>>                Set Current_Description to (Data_Description(Self,iCnt))
10857>>>>>>>                Set Current_RowId       to (Data_RowId(Self,iCnt))
10858>>>>>>>                Function_Return 0
10859>>>>>>>            End
10859>>>>>>>>
10859>>>>>>>        Loop
10860>>>>>>>>
10860>>>>>>>        Function_Return 1 // 0=OK
10861>>>>>>>    End_Function
10862>>>>>>>    
10862>>>>>>>    Function Find_Code_Description String sCode Returns String
10864>>>>>>>        If (sCode='' or ;            (sCode<>Current_Code(Self) and ;            Validate_Value(Self,sCode) ) );            Function_Return ''
10867>>>>>>>        Function_Return (Current_Description(Self))
10868>>>>>>>    End_Function
10869>>>>>>>    
10869>>>>>>>    
10869>>>>>>>    //  The deveveloper (or a sub-class) must fill this list. It is done
10869>>>>>>>    //  by finding the item and sending the Message:
10869>>>>>>>    //    Send Add_Table_Value sValue {sDescr}
10869>>>>>>>    //
10869>>>>>>>    Procedure Fill_List
10871>>>>>>>        Set Table_Loaded_State to True
10872>>>>>>>    End_Procedure
10873>>>>>>>    
10873>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
10875>>>>>>>        Integer iMax
10875>>>>>>>        Integer iCnt
10875>>>>>>>        Integer iFile
10875>>>>>>>        
10875>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
10878>>>>>>>        
10878>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10880>>>>>>>            Send Delete_Data
10881>>>>>>>            Send Fill_list
10882>>>>>>>            Set Table_Loaded_State to True
10883>>>>>>>        End
10883>>>>>>>>
10883>>>>>>>        Get Main_File to iFile
10884>>>>>>>        Get Data_Item_Count to iMax
10885>>>>>>>        Decrement iMax
10886>>>>>>>        For iCnt from 0 to iMax
10892>>>>>>>>
10892>>>>>>>            Send iMsg to iObj iCnt (Data_Value(Self,iCnt)) ;                (Data_Description(Self,iCnt)) iFile ;                (Data_RowId(Self,iCnt))
10893>>>>>>>        Loop
10894>>>>>>>>
10894>>>>>>>    End_Procedure
10895>>>>>>>    
10895>>>>>>>    
10895>>>>>>>    // returns all data in a two dimension variant array.
10895>>>>>>>    // [i][0] = data
10895>>>>>>>    // [i][1] = description
10895>>>>>>>    // This can be used by Crystal CDO classes (this is why a variant array is used)
10895>>>>>>>    Function TableData Returns Variant[][]
10897>>>>>>>        Variant[][2] vData
10898>>>>>>>        Integer iMax i
10898>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
10900>>>>>>>            Send Delete_Data
10901>>>>>>>            Send Fill_list
10902>>>>>>>            Set Table_Loaded_State to True
10903>>>>>>>        End
10903>>>>>>>>
10903>>>>>>>        Get Data_Item_Count to iMax
10904>>>>>>>        For i from 0 to (iMax-1)
10910>>>>>>>>
10910>>>>>>>            Get Data_Value       i to vData[i][0]
10911>>>>>>>            Get Data_Description i to vData[i][1]
10912>>>>>>>        Loop
10913>>>>>>>>
10913>>>>>>>        Function_Return vData
10914>>>>>>>    End_Function
10915>>>>>>>    
10915>>>>>>>End_Class
10916>>>>>>>
10916>>>>>>>
10916>>>>>>>
10916>>>>>>>Class DescriptionValidationTable is an ValidationTable
10917>>>>>>>    
10917>>>>>>>    Procedure Construct_Object
10919>>>>>>>        Forward Send Construct_Object
10921>>>>>>>        Set Number_Elements to 2
10922>>>>>>>    End_Procedure
10923>>>>>>>    
10923>>>>>>>    Function Data_Item_Count Returns Integer
10925>>>>>>>        Function_Return (item_count(Self)/3)
10926>>>>>>>    End_Function
10927>>>>>>>    
10927>>>>>>>    Function Data_Value Integer iItem Returns String
10929>>>>>>>        Function_Return (Value(Self,iItem*3))
10930>>>>>>>    End_Function
10931>>>>>>>    
10931>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
10933>>>>>>>        Set Value  (iItem*3) to sValue
10934>>>>>>>    End_Procedure
10935>>>>>>>    
10935>>>>>>>    Function Data_Description Integer iItem Returns String
10937>>>>>>>        Function_Return (Value(Self,iItem*3+1))
10938>>>>>>>    End_Function
10939>>>>>>>    
10939>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
10941>>>>>>>        Set Value  (iItem*3+1) to sValue
10942>>>>>>>    End_Procedure
10943>>>>>>>    
10943>>>>>>>    Function Data_RowId Integer iItem Returns RowID
10945>>>>>>>        String sRowId
10945>>>>>>>        Get Value (iItem*3+2) to sRowId
10946>>>>>>>        Function_Return (DeSerializeRowId(sRowId))
10947>>>>>>>    End_Function
10948>>>>>>>    
10948>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
10950>>>>>>>        Set Value  (iItem*3+2) to (SerializeRowId(riValue))
10951>>>>>>>    End_Procedure
10952>>>>>>>    
10952>>>>>>>    Procedure Add_Table_Value String sData String sDescr RowID riRec
10954>>>>>>>        String  sVal
10954>>>>>>>        RowID   riRecVal
10954>>>>>>>        Integer iCnt
10954>>>>>>>        Get Data_Item_Count to iCnt
10955>>>>>>>        Set Data_Value iCnt to sData
10956>>>>>>>        
10956>>>>>>>        // If one param passed use it for both display and database values
10956>>>>>>>        If (num_arguments <= 1);            Move sData  to sVal
10959>>>>>>>        Else ;            Move sDescr to sVal
10961>>>>>>>        Set Data_Description iCnt to sVal
10962>>>>>>>        
10962>>>>>>>        If (num_arguments <= 2) ;            Move (NullRowId()) to riRecVal
10965>>>>>>>        Else ;            Move riRec        to riRecVal
10967>>>>>>>        Set Data_RowId iCnt to riRecVal
10968>>>>>>>    End_Procedure
10969>>>>>>>End_Class
10970>>>>>>>
10970>>>>>>>
10970>>>>>>>Class FileValidationTable is an DescriptionValidationTable
10971>>>>>>>    
10971>>>>>>>    Procedure Construct_Object
10973>>>>>>>        Forward Send Construct_Object
10975>>>>>>>        Property Integer No_Fill_State     False // this is never used and is obsolete. (JJT)
10976>>>>>>>        Property Integer Ordering          1   // Indx1 is a good guess.
10977>>>>>>>        Property String  Type_Value        ''  // default these two to
10978>>>>>>>        Property Integer Type_Field        0   // Undefined (none).
10979>>>>>>>        Property Integer Code_Field        1   // Fld 1=code, 2=descr
10980>>>>>>>        Property Integer Description_Field 2   // are good guesses.
10981>>>>>>>        
10981>>>>>>>        Property Integer Code_Load_Object  0   // or (Code_Loader(Self))
10982>>>>>>>    End_Procedure
10983>>>>>>>    
10983>>>>>>>    Function Table_Loaded_State Returns Integer
10985>>>>>>>        Integer iRVal
10985>>>>>>>        Get No_fill_State to iRVal // if true, table always is loaded
10986>>>>>>>        If not iRval ;            Forward Get table_loaded_State to iRVal
10990>>>>>>>        Function_Return iRval
10991>>>>>>>    End_Function
10992>>>>>>>    
10992>>>>>>>    Function Validate_Value String sCode Returns Integer
10994>>>>>>>        Integer iRVal
10994>>>>>>>        Integer iDSO
10994>>>>>>>        Get Code_Load_Object  to iDSO
10995>>>>>>>        // we use standard validate, if code is blank, OR if
10995>>>>>>>        //   1. if no code DSO or the code DSO exists but is not busy.
10995>>>>>>>        //   2. AND it is not no-fill
10995>>>>>>>        //   3. AND it is static
10995>>>>>>>        // Else we find the record directly
10995>>>>>>>        // Note that the operation mode is busy during request_validate (the
10995>>>>>>>        // ddo does this). WHen operation mode is busy we must not use
10995>>>>>>>        // the code dso (must find manually).
10995>>>>>>>        If (sCode='' or ;            ( (iDSO=0 or Operation_Mode=0)    and ; // if no code DSO or DSO not busy            No_Fill_State(Self)=0 and ;            Static_State(Self) ) ) ;            Forward Get Validate_Value sCode to iRVal
10999>>>>>>>        Else If (sCode<>Current_Code(Self)) ;            Get Find_Value sCode to iRVal
11003>>>>>>>        Function_Return iRVal // OK
11004>>>>>>>    End_Function
11005>>>>>>>    
11005>>>>>>>    Procedure Initialize_File
11007>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
11007>>>>>>>        Get Code_Load_Object  to iDSO
11008>>>>>>>        Get Main_File         to iFile
11009>>>>>>>        Get Code_Field        to iCodeField
11010>>>>>>>        Get Description_Field to iDescField
11011>>>>>>>        Get Ordering          to iIndex
11012>>>>>>>        Get Type_Field        to iTypeField
11013>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Initialize_File to iDSO ;            iFile iIndex iCodeField iDescField ;            iTypeField (Type_Value(Self))
11016>>>>>>>        Else Begin
11017>>>>>>>            Clear iFile
11018>>>>>>>            // if Type exists, seed the type value
11018>>>>>>>            If iTypeField ;                Set_Field_Value iFile iTypeField to (Type_Value(Self))
11023>>>>>>>        End
11023>>>>>>>>
11023>>>>>>>    End_Procedure
11024>>>>>>>    
11024>>>>>>>    Function Find_Value String Code Returns Integer
11026>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
11026>>>>>>>        Get Code_Load_Object  to iDSO
11027>>>>>>>        Get Main_File         to iFile
11028>>>>>>>        Get Ordering          to iIndex
11029>>>>>>>        Get Code_Field        to iCodeField
11030>>>>>>>        Get Description_Field to iDescField
11031>>>>>>>        Get Type_Field        to iTypeField
11032>>>>>>>        Send Initialize_File
11033>>>>>>>        //
11033>>>>>>>        Set_Field_Value iFile iCodeField to Code
11036>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Request_Find to iDSO EQ iFile iIndex
11039>>>>>>>        Else ;            Vfind iFile iIndex EQ
11042>>>>>>>        If not (Found) ;            Function_Return 1
11045>>>>>>>        // Set properties Current_code and Current_Description
11045>>>>>>>        Send Store_Current_Data iFile iCodeField iDescField
11046>>>>>>>        Function_Return 0
11047>>>>>>>    End_Function
11048>>>>>>>    
11048>>>>>>>    // internal
11048>>>>>>>    Procedure Store_Current_Data Integer iFile Integer iCodeField Integer iDescField
11050>>>>>>>        String sVal
11050>>>>>>>        Get_Field_Value iFile iCodeField to sVal
11053>>>>>>>        Set Current_Code to (trim(sVal))
11054>>>>>>>        If iDescField Begin
11056>>>>>>>            Get_Field_Value iFile iDescField to sVal
11059>>>>>>>            Set Current_Description to (trim(sVal))
11060>>>>>>>        End
11060>>>>>>>>
11060>>>>>>>        Set Current_RowId to (GetRowId(iFile))
11061>>>>>>>    End_Procedure
11062>>>>>>>    
11062>>>>>>>    Function Next_Code_Record Returns Boolean
11064>>>>>>>        Integer iFile iCodeField iDescField iIndex
11064>>>>>>>        Integer iTypeField
11064>>>>>>>        String sTypeValue sFoundTypeValue
11064>>>>>>>        Boolean bFound
11064>>>>>>>        Handle hoDSO
11064>>>>>>>        Get Code_Load_Object  to hoDSO
11065>>>>>>>        Get Description_Field to iDescField
11066>>>>>>>        Get Code_Field        to iCodeField
11067>>>>>>>        Get Main_File         to iFile
11068>>>>>>>        
11068>>>>>>>        If hoDSO Begin
11070>>>>>>>            Get Next_Code_record of hoDSO to bFound
11071>>>>>>>        End
11071>>>>>>>>
11071>>>>>>>        Else Begin
11072>>>>>>>            Get Ordering to iIndex
11073>>>>>>>            Vfind iFile iIndex GT
11075>>>>>>>            Move (Found) to bFound
11076>>>>>>>            If bFound Begin
11078>>>>>>>                // if found see if we are at the end of the valid list of types
11078>>>>>>>                Get Type_Field to iTypeField
11079>>>>>>>                Get Type_Value to sTypeValue
11080>>>>>>>                If ((iTypeField<>0) and (sTypeValue<>"")) Begin
11082>>>>>>>                    Get_Field_Value iFile iTypeField to sFoundTypeValue
11085>>>>>>>                    Move (Trim(sTypeValue)=Trim(sFoundTypeValue)) to bFound
11086>>>>>>>                End
11086>>>>>>>>
11086>>>>>>>            End
11086>>>>>>>>
11086>>>>>>>        End
11086>>>>>>>>
11086>>>>>>>        If bFound Begin
11088>>>>>>>            Send Store_Current_Data iFile iCodeField iDescField
11089>>>>>>>        End
11089>>>>>>>>
11089>>>>>>>        Function_Return bFound
11090>>>>>>>    End_Function
11091>>>>>>>    
11091>>>>>>>    Procedure Fill_List
11093>>>>>>>        RowID riId
11093>>>>>>>        Boolean bFound
11093>>>>>>>        String sCode sDesc
11093>>>>>>>        If (Static_State(Self)=0 or No_Fill_State(Self)) ;            Procedure_Return
11096>>>>>>>        //
11096>>>>>>>        Send Delete_Data
11097>>>>>>>        Send Initialize_File
11098>>>>>>>        Get Next_Code_Record to bFound
11099>>>>>>>        While bFound
11103>>>>>>>            Get Current_Code        to sCode
11104>>>>>>>            Get Current_Description to sDesc
11105>>>>>>>            Get Current_RowId       to riId
11106>>>>>>>            Send Add_Table_Value sCode sDesc riId
11107>>>>>>>            Get Next_Code_Record to bFound
11108>>>>>>>        Loop
11109>>>>>>>>
11109>>>>>>>        Set Table_Loaded_State to True
11110>>>>>>>    End_Procedure
11111>>>>>>>    
11111>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
11113>>>>>>>        Integer iItem
11113>>>>>>>        Integer iFile
11113>>>>>>>        RowID   riId
11113>>>>>>>        Boolean bFound
11113>>>>>>>        String sCode sDesc
11113>>>>>>>        
11113>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
11116>>>>>>>        
11116>>>>>>>        If (Static_State(Self) and No_Fill_State(Self)=0 ) ;            Forward Send Request_Fill_From_List iObj iMsg
11120>>>>>>>        Else Begin
11121>>>>>>>            Get Main_File to iFile
11122>>>>>>>            Send Initialize_File
11123>>>>>>>            Get Next_Code_Record to bFound
11124>>>>>>>            While bFound
11128>>>>>>>                Get Current_Code        to sCode
11129>>>>>>>                Get Current_Description to sDesc
11130>>>>>>>                Get Current_RowId       to riId
11131>>>>>>>                Send iMSG to iObj iItem sCode sDesc iFile riId
11132>>>>>>>                Increment iItem
11133>>>>>>>                Get Next_Code_Record to bFound
11134>>>>>>>            Loop
11135>>>>>>>>
11135>>>>>>>        End
11135>>>>>>>>
11135>>>>>>>    End_Procedure
11136>>>>>>>End_Class
11137>>>>>>>
11137>>>>>>>Use CodeLoad.pkg
Including file: codeload.pkg    (C:\Program Files\DataFlex 24.0\Pkg\codeload.pkg)
11137>>>>>>>>>// Interface:
11137>>>>>>>>>//
11137>>>>>>>>>//  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;
11137>>>>>>>>>//                            Integer Desc# Integer Type# String Type
11137>>>>>>>>>//
11137>>>>>>>>>//      This initializes the data-set for finding. You MUST pass all five
11137>>>>>>>>>//      parameters here. They are:
11137>>>>>>>>>//          File#  -  main file to use
11137>>>>>>>>>//         Index#  - Index to use for finding
11137>>>>>>>>>//          Code#  - field number of the code
11137>>>>>>>>>//          Desc#  - field number of the code's description
11137>>>>>>>>>//          Type#  - field number of the constraining Type (0 if none)
11137>>>>>>>>>//           Type  - the constrain type value ('' = allow all records)
11137>>>>>>>>>//
11137>>>>>>>>>//      You MUST send this message before finding records. Alternately,
11137>>>>>>>>>//      you could set the individual properties and send rebuild_constraints
11137>>>>>>>>>//      and CLEAR to initalize the file (see code on how to do this).
11137>>>>>>>>>//
11137>>>>>>>>>//    Get Next_Code_record to ret_Int
11137>>>>>>>>>//
11137>>>>>>>>>//      Returns the next record number. 0 if no more. If record exists it
11137>>>>>>>>>//      sets the value of Current_Code and Crnt_Description.
11137>>>>>>>>>//
11137>>>>>>>>>//    Get Current_Code to Ret_String
11137>>>>>>>>>//    Get Crnt_Description to Ret_String
11137>>>>>>>>>//
11137>>>>>>>>>//      Returns the code and description of the last valid record found
11137>>>>>>>>>//      with the Next_Code_Record Message
11137>>>>>>>>>//
11137>>>>>>>>>//   Sample Usage:  This was created primarily to be used by the
11137>>>>>>>>>//                  radio-entry-form classes. In particular those using
11137>>>>>>>>>//                  the "code" look up file. Look at those packages if
11137>>>>>>>>>//                  you wish to use them yourself.
11137>>>>>>>>>//
11137>>>>>>>>>Use Data_Set.pkg
11137>>>>>>>>>
11137>>>>>>>>>Class Code_Loader_Data_Set is a DataSet
11138>>>>>>>>>    
11138>>>>>>>>>    Procedure Construct_Object Integer Img#
11140>>>>>>>>>        Forward Send Construct_Object Img#
11142>>>>>>>>>        // These should be set by the Initialize_File message
11142>>>>>>>>>        Property String  Type_Value           '' // assume no defaults.
11143>>>>>>>>>        Property Integer Type_Field           0  // These values should be
11144>>>>>>>>>        Property Integer Code_Field           0  // set by initialize_file
11145>>>>>>>>>        Property Integer Description_Field    0  //
11146>>>>>>>>>        
11146>>>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
11146>>>>>>>>>        Property String  Current_Code         ''
11147>>>>>>>>>        Property String  Current_Description  ''
11148>>>>>>>>>    End_Procedure
11149>>>>>>>>>    
11149>>>>>>>>>    // If a Type exists (not a '') and there is a type field and a
11149>>>>>>>>>    // main_file constrain to the type. Else no constraints
11149>>>>>>>>>    Procedure OnConstrain
11151>>>>>>>>>        String sType
11151>>>>>>>>>        Integer iFile iField
11151>>>>>>>>>        Get Type_Value to sType
11152>>>>>>>>>        Get Main_File  to iFile
11153>>>>>>>>>        Get Type_Field to iField
11154>>>>>>>>>        If (sType<>'' and iFile<>0 and iField<>0) ;            Vconstrain iFile iField eq sType
11159>>>>>>>>>    End_Procedure
11160>>>>>>>>>    
11160>>>>>>>>>    //  This initializes the data-set for finding. You MUST pass all five
11160>>>>>>>>>    //  parameters here. They are:
11160>>>>>>>>>    //     File#  -  main file to use
11160>>>>>>>>>    //    Index#  - Index to use for finding
11160>>>>>>>>>    //     Code#  - field number of the code
11160>>>>>>>>>    //     Desc#  - field number of the code's description
11160>>>>>>>>>    //     Type#  - field number of the constraining Type (0 if none)
11160>>>>>>>>>    //      Type  - the constrain type value ('' = allow all records)
11160>>>>>>>>>    //
11160>>>>>>>>>    Procedure Initialize_File Integer File# Integer Index# Integer Code# ;            Integer Desc# Integer Type# String Type
11162>>>>>>>>>        // note: all params are required!
11162>>>>>>>>>        Set Main_File         to File#
11163>>>>>>>>>        Set Ordering          to Index#
11164>>>>>>>>>        Set Code_Field        to Code#
11165>>>>>>>>>        Set Description_Field to Desc#
11166>>>>>>>>>        Set Type_Field        to Type#
11167>>>>>>>>>        Set Type_Value        to Type
11168>>>>>>>>>        //
11168>>>>>>>>>        Send Rebuild_Constraints // set up constraints
11169>>>>>>>>>        Send Clear               // initialize the file
11170>>>>>>>>>    End_Procedure
11171>>>>>>>>>    
11171>>>>>>>>>    //  Find the next record: Return 0 if no record, 1 if record exists
11171>>>>>>>>>    //   if record exists set Current_Code and Current_Description
11171>>>>>>>>>    //
11171>>>>>>>>>    Function Next_Code_Record Returns Boolean
11173>>>>>>>>>        Integer iFile iField
11173>>>>>>>>>        String sValue
11173>>>>>>>>>        Send Request_Find GT (Main_File(Self)) (Ordering(Self))
11174>>>>>>>>>        If not (Found) ;            Function_Return False
11177>>>>>>>>>        // Set properties Current_code and Current_Description
11177>>>>>>>>>        Get Main_File to iFile
11178>>>>>>>>>        
11178>>>>>>>>>        Get Code_Field to iField
11179>>>>>>>>>        Get_Field_Value iFile iField to sValue
11182>>>>>>>>>        Set Current_Code to sValue
11183>>>>>>>>>        
11183>>>>>>>>>        Get Description_Field to iField
11184>>>>>>>>>        Get_Field_Value iFile iField to sValue
11187>>>>>>>>>        Set Current_Description to sValue
11188>>>>>>>>>        Function_Return True
11189>>>>>>>>>    End_Function
11190>>>>>>>>>    
11190>>>>>>>>>End_Class
11191>>>>>>>Use cCodeMaintOpen_Mixin.pkg
Including file: cCodeMaintOpen_Mixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCodeMaintOpen_Mixin.pkg)
11191>>>>>>>>>// Mixin class to support transistion support for CodeType and CodeMast files.
11191>>>>>>>>>// These files used to be in filelist and they used to reside at 207 and 208 and they
11191>>>>>>>>>// were always opened with "open as"
11191>>>>>>>>>// We want these to be in the filelist at 253 and 254. These open methods will attempt to open these files
11191>>>>>>>>>// as such. If these are old files (not in filelist or wrong number) they will get loaded with the old
11191>>>>>>>>>// open as - thus keeping this backwards compatible.
11191>>>>>>>>>// By adding to filelist, we can sort the files and we can open them as other database sources.
11191>>>>>>>>>Use VDFBase.pkg
11191>>>>>>>>>
11191>>>>>>>>>Declare_Datafile CodeType
Including file: CodeType.fd    (C:\Projects\DF20\DbUpdateFramework\DDSrc\CodeType.fd)
11191>>>>>>>>>Declare_Datafile CodeMast
Including file: CodeMast.fd    (C:\Projects\DF20\DbUpdateFramework\DDSrc\CodeMast.fd)
11191>>>>>>>>>Define C_Expected_CodeType_FileNumber for 253  // and the logical name must be CODETYPE
11191>>>>>>>>>Define C_Expected_CodeMast_FileNumber for 254  // and the logical name must be CODEMAST
11191>>>>>>>>>
11191>>>>>>>>>Class cCodeMaintOpen_Mixin is a Mixin
11192>>>>>>>>>    
11192>>>>>>>>>    Procedure OpenCodeMast
11194>>>>>>>>>        String sName
11194>>>>>>>>>        If (Codemast.File_number=C_Expected_CodeMast_FileNumber) Begin
11196>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of Codemast.File_number to sName
11199>>>>>>>>>            If (uppercase(trim(sName))="CODEMAST") Begin
11201>>>>>>>>>                Open CodeMast
11203>>>>>>>>>                Procedure_Return
11204>>>>>>>>>            End
11204>>>>>>>>>>
11204>>>>>>>>>        End
11204>>>>>>>>>>
11204>>>>>>>>>        Open "CodeMast" as Codemast.File_number
11206>>>>>>>>>    End_Procedure
11207>>>>>>>>>    
11207>>>>>>>>>    Procedure OpenCodeType
11209>>>>>>>>>        String sName
11209>>>>>>>>>        If (Codetype.File_number=C_Expected_CodeType_FileNumber) Begin
11211>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of CodeType.File_number to sName
11214>>>>>>>>>            If (uppercase(trim(sName))="CODETYPE") Begin
11216>>>>>>>>>                Open CodeType
11218>>>>>>>>>                Procedure_Return
11219>>>>>>>>>            End
11219>>>>>>>>>>
11219>>>>>>>>>        End
11219>>>>>>>>>>
11219>>>>>>>>>        Open "CodeType" as CodeType.File_number
11221>>>>>>>>>    End_Procedure
11222>>>>>>>>>    
11222>>>>>>>>>End_Class
11223>>>>>>>
11223>>>>>>>//
11223>>>>>>>//  This is the object we need for loading files.
11223>>>>>>>//
11223>>>>>>>Object Code_loader is a Code_loader_Data_Set no_Image
11225>>>>>>>End_Object
11226>>>>>>>
11226>>>>>>>
11226>>>>>>>Class CodeValidationTable is an FileValidationTable
11227>>>>>>>    
11227>>>>>>>    // supports opening of file in reserved filelist area.
11227>>>>>>>    Import_Class_Protocol cCodeMaintOpen_Mixin
11228>>>>>>>    
11228>>>>>>>    Procedure Construct_Object
11230>>>>>>>        Forward Send Construct_Object
11232>>>>>>>        
11232>>>>>>>        Send OpenCodeMast                       // methods supports w/ filelist (new) and without (old)
11233>>>>>>>        
11233>>>>>>>        Set Main_File to CodeMast.File_Number   // name of file is CODEMAST
11234>>>>>>>        Set Ordering to 1                       // Index 1: Types x Code
11235>>>>>>>        Set Type_Field to 1                     // Fld 1: Type
11236>>>>>>>        Set Code_Field to 2                     // Fld 2: Code
11237>>>>>>>        Set Description_Field to 3              // Fld 3: Description
11238>>>>>>>        Set Code_load_Object to (Code_Loader(Self))
11239>>>>>>>    End_Procedure
11240>>>>>>>    
11240>>>>>>>End_Class
11241>>>>>
11241>>>>>// Used to by DDOConstraintFindMeta to return constraint expression info in a friendlier fashion
11241>>>>>Struct tDDOConstraintFindMeta
11241>>>>>    Integer iJumpInSegments
11241>>>>>    Boolean bJumpOut
11241>>>>>    Boolean bPreRelate
11241>>>>>    Boolean bPostRelate
11241>>>>>End_Struct
11241>>>>>
11241>>>>>// used by webapp resynchs
11241>>>>>Struct tDDChangedParentInfo
11241>>>>>    Integer iTable
11241>>>>>    Boolean bSwitched
11241>>>>>End_Struct
11241>>>>>
11241>>>>>// used by webapp resynchs
11241>>>>>Struct tDDChangedInfo
11241>>>>>    Boolean bChanged
11241>>>>>    tDDChangedParentInfo[] ParentChanged
11241>>>>>    tDDChangedParentInfo[] ParentChanged
11241>>>>>End_Struct
11241>>>>>
11241>>>>>Enum_List
11241>>>>>    Define CONST_EXP_JUMPOUT     for 1
11241>>>>>    Define CONST_EXP_PRE_RELATE  for 2
11241>>>>>    Define CONST_EXP_POST_RELATE for 4
11241>>>>>End_Enum_List
11241>>>>>
11241>>>>>// Constraint Find Types
11241>>>>>Enum_List
11241>>>>>    Define CONST_VALUE for 0    // Constrain File.Field eq sValue
11241>>>>>    Define CONST_CHILD          // Constrain File Relates to iOtherFile
11241>>>>>    Define CONST_FIELD          // Constrain File.field eq OtherFile.OtherField
11241>>>>>    Define CONST_EXP            // Constrain File as (Expression) - expression is internal
11241>>>>>    Define CONST_RELATES        // Sames a CONST_CHILD - should never be used
11241>>>>>End_Enum_List
11241>>>>>
11241>>>>>// Constraint Find Modes
11241>>>>>Enum_List
11241>>>>>    Define CONST_LT for 0
11241>>>>>    Define CONST_LE for 1
11241>>>>>    Define CONST_EQ for 2
11241>>>>>    Define CONST_GE for 3
11241>>>>>    Define CONST_GT for 4
11241>>>>>    Define CONST_NE for 5
11241>>>>>    Define CONST_Matches for 6       // a matches not capable of a jump in e.g., "?A*"
11241>>>>>    Define CONST_Contains for 7      // a contains
11241>>>>>    Define CONST_MatchesJumpIn for 9 // a matches which is capable of a jump in e.g., "A*"
11241>>>>>    // note that BETWEEN is actually two constraints a GE and LE
11241>>>>>End_Enum_List
11241>>>>>
11241>>>>>// Struct used to DDOConstraints to return current constraints in an array
11241>>>>>Struct tConstraintDef
11241>>>>>    Integer eType // constraint Find type
11241>>>>>    Integer eMode // constrain file mode
11241>>>>>    Integer iFile
11241>>>>>    Integer iField
11241>>>>>    String sValue
11241>>>>>    Integer iOtherFile
11241>>>>>    Integer iOtherField
11241>>>>>End_Struct
11241>>>>>
11241>>>>>// values passed to OnPre/PostFind to indicate the operation type
11241>>>>>Enum_List
11241>>>>>    Define DDFindRequestFind    // request_find
11241>>>>>    Define DDFindFindByRowRec   // FindByRowId, Find_By_Recnum
11241>>>>>    Define DDFindRequestAssign  // Request_assign
11241>>>>>    Define DDFindClear          // Clear (note Clear_All doesn't do this)
11241>>>>>End_Enum_List
11241>>>>>
11241>>>>>
11241>>>>>// these are private
11241>>>>>Define DD_RememberLast for "_REMEMBER$LAST_"
11241>>>>>Use tDDRemembered.pkg
Including file: tDDRemembered.pkg    (C:\Program Files\DataFlex 24.0\Pkg\tDDRemembered.pkg)
11241>>>>>>>// DDRemember Struct used for DataDictionary Class
11241>>>>>>>
11241>>>>>>>// private
11241>>>>>>>
11241>>>>>>>Struct tDDRemembered
11241>>>>>>>    Integer iField // searches are performed on this segement - it must be first
11241>>>>>>>    String sDefault
11241>>>>>>>    String sLastValue
11241>>>>>>>End_Struct
11241>>>>>>>
11241>>>>>
11241>>>>>// Used to assign a global validation_object. This can be used for
11241>>>>>// automatic prompt object on non-relational validations (checks, validation_
11241>>>>>// tables, etc.)
11241>>>>>Integer DD_Global_Validation_Prompt_Object
11241>>>>>Move 0 to DD_Global_Validation_Prompt_Object
11242>>>>>
11242>>>>>// Used for Dso traversal marking - Private (do not use)
11242>>>>>Integer   DD_Current_Mark_Id
11242>>>>>Move 0 to DD_Current_Mark_Id
11243>>>>>
11243>>>>>// Used to validate DSO structures during Save and deletes
11243>>>>>Enumeration_List
11243>>>>>    Define DD_VALIDATE_STRUCTURE_ALWAYS // Validate each save/delete operation.
11243>>>>>    Define DD_VALIDATE_STRUCTURE_NEVER  // Never validate these operations.
11243>>>>>    Define DD_VALIDATE_STRUCTURE_ONCE   // Validate Once (first save or delete).
11243>>>>>End_Enumeration_List
11243>>>>>
11243>>>>>// Used as a start for error handing in DSOs. Only affects errors that go
11243>>>>>// through operation_not_allowed and Field_Error. Used by Error_Report_Mode
11243>>>>>Enumeration_List
11243>>>>>    Define DD_ERROR_REPORT              // Report Error on screen
11243>>>>>    Define DD_ERROR_NO_REPORT           // Show no Error..
11243>>>>>End_Enumeration_List
11243>>>>>
11243>>>>>Enumeration_List
11243>>>>>    Define DD_Lock_on_All             for  7  // 111
11243>>>>>    Define DD_Lock_on_New_Save_Delete for  5  // 101
11243>>>>>    Define DD_Lock_on_Delete          for  4  // 100
11243>>>>>    Define DD_Lock_on_Save            for  2  // 010
11243>>>>>    Define DD_Lock_on_New_Save        for  1  // 001
11243>>>>>End_Enumeration_List
11243>>>>>
11243>>>>>
11243>>>>>Define DD_DEFAULT_ERROR_NUMBER  for 999
11243>>>>>
11243>>>>>
11243>>>>>
11243>>>>>
11243>>>>>// The next replaces will be used to indicate default item-options
11243>>>>>// instead of a fieldnumber which is normally used.
11243>>>>>
11243>>>>>// these are the DD bits that pertain to DEO Item options.
11243>>>>>Define DD_DEO_MASK for (DD_NOENTER ior DD_SKIPFOUND ior DD_CAPSLOCK ior DD_ZERO_SUPPRESS ior DD_AUTORETURN ior DD_AUTOBACK ior DD_AUTOCLEAR)
11243>>>>>
11243>>>>>
11243>>>>>// Special parameter options that can get passed to Set Field_Options. The
11243>>>>>// purpose is to clear all fields or the remaining passed parameters. Normally,
11243>>>>>// these are not used so it does not matter if their interface is a bit odd.
11243>>>>>Enumeration_List
11243>>>>>    Define DD_CLEAR_FIELD_OPTIONS      for -1
11243>>>>>    Define DD_CLEAR_ALL_FIELD_OPTIONS  for -2
11243>>>>>End_Enumeration_List
11243>>>>>
11243>>>>>// used to keep track of extra server file information.
11243>>>>>Struct tDDServerInformation
11243>>>>>    Integer iParent             // parent file number
11243>>>>>    Boolean bAllowNullParent    // does this DD (child) allow a null parent
11243>>>>>    Integer bParentNoSwitchIfCommitted // does this DD (child) allow switching committed parents
11243>>>>>    Boolean bNoCascadeDelete           // when a child record exists should cascade delete stop the action
11243>>>>>    Boolean bCascadeDeleteNullTheParent // when a child record exists that is null parent allowed, should we delete or null the parent
11243>>>>>End_Struct
11243>>>>>
11243>>>>>Use DDExtFld.pkg // adds extended field/pointer support
Including file: DDExtFld.pkg    (C:\Program Files\DataFlex 24.0\Pkg\DDExtFld.pkg)
11243>>>>>>>// This is used by the DataDictionary class and provides a method for
11243>>>>>>>// windows DDs (for now) to support local buffers for text and binary buffers.
11243>>>>>>>// Field objects are created within the DD by sending the message:
11243>>>>>>>// The DD interface is:
11243>>>>>>>//
11243>>>>>>>//      Get  Field_Object iField to hExtFieldObject
11243>>>>>>>//      Send DefineExtendedField iField
11243>>>>>>>//      Send DefineAllExtendedFields
11243>>>>>>>//      Send ExtendedFieldsUpdate bSave
11243>>>>>>>//      Send ExtendedFieldsRefresh bCleared
11243>>>>>>>//      Set  File_Field_Current_Pointer_Value iFile iField iLen to pValue
11243>>>>>>>//      Set  Field_Current_Pointer_Value iField iLen to pValue
11243>>>>>>>//      Set  File_Field_Pointer_Entry iFile iField iLen bShowErr to pValue
11243>>>>>>>//      Set  Field_Pointer_Entry iField iOpts iLen bShowErr to pValue
11243>>>>>>>//      Get  File_Field_Current_Pointer_Value iFile iField to pData
11243>>>>>>>//      Get  Field_Current_Pointer_Value iField to pData
11243>>>>>>>//
11243>>>>>>>// Once object is identified, the following interface can be used
11243>>>>>>>//      Get FieldPointer of hExtFieldObject to iMemoryPointer
11243>>>>>>>//      Get FieldLength  of hExtFieldObject to iLen
11243>>>>>>>//      Get File_Number  of hExtFieldObject to iFile
11243>>>>>>>//      Get Field_Number of hExtFieldObject to iFile
11243>>>>>>>//      Set Update_Save_State of hExtFieldObject to bState         // be careful!
11243>>>>>>>//      Set Update_Find_State of hExtFieldObject to bState         // be careful
11243>>>>>>>//      Set FieldRefresh_Save_State of hExtFieldObject to bState   // be careful
11243>>>>>>>//
11243>>>>>>>
11243>>>>>>>//
11243>>>>>>>//  DD structure:
11243>>>>>>>//       DD Object           (property Field_objects points to child)
11243>>>>>>>//           FieldObjects    (array of field#s and field objs)
11243>>>>>>>//              FieldObject1 (heap alloc for each field)
11243>>>>>>>//              FieldObjectn
11243>>>>>>>//
11243>>>>>>>
11243>>>>>>>//
11243>>>>>>>// This is used to create a single extended field object.
11243>>>>>>>//
11243>>>>>>>// Interface
11243>>>>>>>//      Get FieldPointer to iMemoryPointer
11243>>>>>>>//      Get FieldLength  to iLen
11243>>>>>>>//      Get File_Number  to iFile
11243>>>>>>>//      Get Field_Number to iFile
11243>>>>>>>//      get/Set Update_Save_State to bState         // be careful!
11243>>>>>>>//      get/Set Update_Find_State to bState         // be careful
11243>>>>>>>//      get/Set FieldRefresh_Save_State to bState   // be careful
11243>>>>>>>//      get/set FieldChangedState
11243>>>>>>>//      send defineField  iFile iField
11243>>>>>>>//      Send FieldUpdate  bSave
11243>>>>>>>//      Send FieldRefresh bCleared bClearFieldChange
11243>>>>>>>//      Set  Field_pEntry iOpts iLen to pValue
11243>>>>>>>//      Set  Field_pValue iLen to pValue
11243>>>>>>>//
11243>>>>>>>Use VDFBase.pkg
11243>>>>>>>
11243>>>>>>>Class FieldObject is a cObject
11244>>>>>>>    
11244>>>>>>>    Procedure Construct_Object
11246>>>>>>>        Forward Send construct_object
11248>>>>>>>        // these are all set by DefineField and should not be changed
11248>>>>>>>        Property Integer File_Number        0
11249>>>>>>>        Property Integer Field_Number       0
11250>>>>>>>        Property Integer FieldLength        0
11251>>>>>>>        
11251>>>>>>>        // maintained by object
11251>>>>>>>        Property UChar[] pFieldArray
11252>>>>>>>        
11252>>>>>>>        // these can be changed, with care, by the developer
11252>>>>>>>        Property Integer Update_Save_State  True
11253>>>>>>>        Property Integer Update_Find_State  False // usually no point for finds
11254>>>>>>>        Property Integer FieldRefresh_State True
11255>>>>>>>        
11255>>>>>>>        // hopefully never used
11255>>>>>>>        Property Pointer pLegacyFieldPointer       0
11256>>>>>>>        
11256>>>>>>>    End_Procedure
11257>>>>>>>    
11257>>>>>>>    Procedure Set FieldChangedState Integer bState
11259>>>>>>>        Integer iField
11259>>>>>>>        Get Field_Number to iField
11260>>>>>>>        Delegate Set Field_Changed_state iField to bState
11262>>>>>>>    End_Procedure
11263>>>>>>>    
11263>>>>>>>    Function FieldChangedState Returns Integer
11265>>>>>>>        Integer iField  bState
11265>>>>>>>        Get Field_Number to iField
11266>>>>>>>        Delegate Get Field_Changed_state iField to bState
11268>>>>>>>        Function_Return bState
11269>>>>>>>    End_Function
11270>>>>>>>    
11270>>>>>>>    // return the field option specified
11270>>>>>>>    Function IsSaveNoPut Returns Boolean
11272>>>>>>>        Integer iField
11272>>>>>>>        Boolean  bState
11272>>>>>>>        Get Field_Number to iField
11273>>>>>>>        Delegate Get FieldSaveNoPut iField to bState
11275>>>>>>>        Function_Return bState
11276>>>>>>>    End_Function
11277>>>>>>>    
11277>>>>>>>    // for object: define file, field, fieldlength and allocate heap memory
11277>>>>>>>    //             and set memory pointer
11277>>>>>>>    Procedure DefineField Integer iFile Integer iField
11279>>>>>>>        Integer iFldLen
11279>>>>>>>        Set File_Number  to iFile
11280>>>>>>>        Set Field_Number to iField
11281>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldLen
11284>>>>>>>        Set FieldLength  to iFldLen
11285>>>>>>>    End_Procedure
11286>>>>>>>    
11286>>>>>>>    // Move from the DD Buffer to the file buffer
11286>>>>>>>    Procedure FieldUpdate Integer bSave
11288>>>>>>>        Integer iFile iField iFieldLen
11288>>>>>>>        UChar[] FieldArray
11289>>>>>>>        Integer iType
11289>>>>>>>        Boolean bNoPut
11289>>>>>>>        
11289>>>>>>>        // if bSave, part of save which means only update if changed
11289>>>>>>>        // if not bsave, part of find. You usually would not update this. You
11289>>>>>>>        // don't index on these types of fields
11289>>>>>>>        If ( (bSave and Update_Save_State(Self) and FieldChangedState(Self)) or ;            (not(bSave) and Update_Find_state(Self) ) ) Begin
11291>>>>>>>            // if save, we must respect DD_NoPut
11291>>>>>>>            If (bSave) Begin
11293>>>>>>>                // we are looking at the DD's field buffer itemoptions for, which
11293>>>>>>>                // should be set appropriately before a save. This setting has any
11293>>>>>>>                // changes made to support dd_commit
11293>>>>>>>                Get IsSaveNoPut to bNoPut
11294>>>>>>>                If bNoPut Begin
11296>>>>>>>                    Procedure_Return
11297>>>>>>>                End
11297>>>>>>>>
11297>>>>>>>            End
11297>>>>>>>>
11297>>>>>>>            Get pFieldArray to FieldArray
11298>>>>>>>            Get File_Number to iFile
11299>>>>>>>            Get Field_Number to iField
11300>>>>>>>            If iFile Begin
11302>>>>>>>                Set_Field_Value iFile iField to FieldArray // LENGTH iFieldLen
11305>>>>>>>            End
11305>>>>>>>>
11305>>>>>>>        End
11305>>>>>>>>
11305>>>>>>>    End_Procedure
11306>>>>>>>    
11306>>>>>>>    // Move from File buffer to local DD Buffer
11306>>>>>>>    // bCleared determines if this is a find or a clear.
11306>>>>>>>    // bClearFieldChange determines if we should clear the FieldChangedState.
11306>>>>>>>    Procedure FieldRefresh Boolean bCleared Boolean bClearFieldChange
11308>>>>>>>        Integer iFile iField
11308>>>>>>>        Integer bOk
11308>>>>>>>        UChar[] FieldArray
11309>>>>>>>        If (FieldRefresh_state(Self)) Begin
11311>>>>>>>            //Get FieldPointer to pField
11311>>>>>>>            Get File_Number to iFile
11312>>>>>>>            Get Field_Number to iField
11313>>>>>>>            // move from file buffer to memory pointed to by pField
11313>>>>>>>            If (iFile) Begin
11315>>>>>>>                If not bCleared Begin
11317>>>>>>>                    Get_Field_Value iFile iField to FieldArray
11320>>>>>>>                End
11320>>>>>>>>
11320>>>>>>>                Set Field_UCValue to FieldArray
11321>>>>>>>            End
11321>>>>>>>>
11321>>>>>>>        End
11321>>>>>>>>
11321>>>>>>>        If bClearFieldChange Begin
11323>>>>>>>            Set FieldChangedstate to False
11324>>>>>>>        End
11324>>>>>>>>
11324>>>>>>>    End_Procedure
11325>>>>>>>    
11325>>>>>>>    Procedure Set Field_pEntry Integer iOpts Integer iLen Integer bShowErr Pointer pValue
11327>>>>>>>        Integer iFile iField iFldLen iMemLen
11327>>>>>>>        Integer bChanged
11327>>>>>>>        UChar[] FieldArray
11328>>>>>>>        
11328>>>>>>>        // currently we do nothing with bShowErr because we don't checkfor errors!
11328>>>>>>>        
11328>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. For now we will
11328>>>>>>>        // let NoPut through, since a user might need it for finding.
11328>>>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
11331>>>>>>>        
11331>>>>>>>        // maybe in the future
11331>>>>>>>        // Force a caplsock if required
11331>>>>>>>        //If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
11331>>>>>>>        
11331>>>>>>>        Get File_Number  to iFile
11332>>>>>>>        Get Field_Number to iField
11333>>>>>>>        If (iFile) Begin
11335>>>>>>>            Get Is_pValueChanged iLen pValue to bChanged
11336>>>>>>>            If ( bChanged or (iOpts iand DD_FORCEPUT) ) Begin
11338>>>>>>>                Set Field_pValue iLen to pValue
11339>>>>>>>            End
11339>>>>>>>>
11339>>>>>>>            
11339>>>>>>>            
11339>>>>>>>            // Set changed state if changed and it is not No_put. This
11339>>>>>>>            // is an improvement on DEOs which would set changed-state for
11339>>>>>>>            // a no-put. This way, finds use the changed value but saves will
11339>>>>>>>            // not trigger a phony data loss
11339>>>>>>>            //If ( bChanged ) ;
11339>>>>>>>            If ( bChanged and not(iOpts iand DD_NOPUT) ) ;                Set FieldChangedState to True
11342>>>>>>>            
11342>>>>>>>            // The following is really highly unlikely!!!
11342>>>>>>>            // perform autofinds if needed. Note that required checking will occur as
11342>>>>>>>            // part of validation.
11342>>>>>>>            // We will only autofind if the field value is changed. This is consistent with
11342>>>>>>>            // DEOs which do not autofind on unchanged values. This provides optimizations
11342>>>>>>>            // when a parent record is already loaded.
11342>>>>>>>            If (bChanged or FieldChangedState(Self)) Begin
11344>>>>>>>                If (iOpts iand DD_AUTOFIND) ;                    Delegate Send File_Field_AutoFind iFile iField EQ
11348>>>>>>>                Else If (iOpts iand DD_AUTOFIND_GE) ;                    Delegate Send File_Field_AutoFind iFile iField GE
11353>>>>>>>            End
11353>>>>>>>>
11353>>>>>>>        End
11353>>>>>>>>
11353>>>>>>>        
11353>>>>>>>    End_Procedure
11354>>>>>>>    
11354>>>>>>>    // convert pointer to UChar[]
11354>>>>>>>    Function PointerToUCharArray Pointer pValue Integer iLen Returns UChar[]
11356>>>>>>>        UChar[] FieldArray
11357>>>>>>>        Boolean bOk
11357>>>>>>>        Move (ResizeArray(FieldArray,iLen)) to FieldArray
11358>>>>>>>        Move (MemCopy(AddressOf(FieldArray),pValue,iLen)) to bOK
11359>>>>>>>        Function_Return FieldArray
11360>>>>>>>    End_Function
11361>>>>>>>    
11361>>>>>>>    // Raw update of pValue
11361>>>>>>>    Procedure Set Field_UCValue UChar[] FieldArray
11363>>>>>>>        Set pFieldArray to FieldArray
11364>>>>>>>        Send DestroyLegacyFieldHeap
11365>>>>>>>    End_Procedure
11366>>>>>>>    
11366>>>>>>>    // Raw update of pValue
11366>>>>>>>    Procedure Set Field_pValue Integer iLen Pointer pValue
11368>>>>>>>        UChar[] FieldArray
11369>>>>>>>        Get PointerToUCharArray pValue iLen to FieldArray
11370>>>>>>>        Set Field_UCValue to FieldArray
11371>>>>>>>    End_Procedure
11372>>>>>>>    
11372>>>>>>>    Function Is_pValueChanged Integer iLen Pointer pValue Returns Boolean
11374>>>>>>>        Boolean bChanged
11374>>>>>>>        UChar[] FieldArray
11375>>>>>>>        Integer iFldLen
11375>>>>>>>        Get pFieldArray to FieldArray
11376>>>>>>>        Move (SizeOfArray(FieldArray)) to iFldLen
11377>>>>>>>        If (iLen <> SizeOfArray(FieldArray)) Begin
11379>>>>>>>            Move True to bChanged
11380>>>>>>>        End
11380>>>>>>>>
11380>>>>>>>        Else If (iLen) Begin // check for empty pointer
11383>>>>>>>            Move (MemCompare(AddressOf(FieldArray),pValue,iLen)) to bChanged
11384>>>>>>>        End
11384>>>>>>>>
11384>>>>>>>        Function_Return bChanged
11385>>>>>>>    End_Function
11386>>>>>>>    
11386>>>>>>>    // returns data as UChar array - best way to access the data
11386>>>>>>>    Function FieldArray Returns UChar[]
11388>>>>>>>        UChar[] FieldArray
11389>>>>>>>        Get pFieldArray to FieldArray
11390>>>>>>>        Function_Return FieldArray
11391>>>>>>>    End_Function
11392>>>>>>>    
11392>>>>>>>    // legacy method. Hopefully this is never called.
11392>>>>>>>    Function FieldPointer Returns Pointer
11394>>>>>>>        Pointer pValue pOldValue
11394>>>>>>>        Integer iLen
11394>>>>>>>        UChar[] FieldArray
11395>>>>>>>        Boolean bOk
11395>>>>>>>        Get pFieldArray to FieldArray
11396>>>>>>>        Move (SizeOfArray(FieldArray)) to iLen
11397>>>>>>>        Move (Alloc(iLen)) to pValue
11398>>>>>>>        Move (MemCopy(pValue,AddressOf(FieldArray),iLen)) to bOk
11399>>>>>>>        Send DestroyLegacyFieldHeap
11400>>>>>>>        Set pLegacyFieldPointer to pValue
11401>>>>>>>        Function_Return pValue
11402>>>>>>>    End_Function
11403>>>>>>>    
11403>>>>>>>    Procedure DestroyLegacyFieldHeap
11405>>>>>>>        Integer bOK
11405>>>>>>>        Pointer pField
11405>>>>>>>        Get pLegacyFieldPointer to pField
11406>>>>>>>        If (pField ) Begin
11408>>>>>>>            Move (Free(pField)) to bOk
11409>>>>>>>            Set pLegacyFieldPointer to 0
11410>>>>>>>        End
11410>>>>>>>>
11410>>>>>>>    End_Procedure
11411>>>>>>>    
11411>>>>>>>    // augment to release heap allocation
11411>>>>>>>    Procedure Destroy_Object
11413>>>>>>>        Send DestroyLegacyFieldHeap
11414>>>>>>>        Forward Send Destroy_object
11416>>>>>>>    End_Procedure
11417>>>>>>>    
11417>>>>>>>End_Class
11418>>>>>>>
11418>>>>>>>// This contains all extended field objects.
11418>>>>>>>// The array contains a list of all objects where item=field#
11418>>>>>>>// and item+1=field object.
11418>>>>>>>//
11418>>>>>>>// Interface is:
11418>>>>>>>//     Get Field_object iField to hFldObj
11418>>>>>>>//     Send DefineFieldObject iField
11418>>>>>>>//     Send ExtendedFieldsUpdate bSave
11418>>>>>>>//     Send ExtendedFieldsRefresh bCleared
11418>>>>>>>//
11418>>>>>>>Class FieldObjects is an Array
11419>>>>>>>    
11419>>>>>>>    // return object Id for iField. 0 if none.
11419>>>>>>>    Function Field_Object Integer iField Returns Integer
11421>>>>>>>        Integer iItm iCnt
11421>>>>>>>        Get Item_Count to iCnt
11422>>>>>>>        Move 0 to iItm
11423>>>>>>>        While iItm lt iCnt
11427>>>>>>>            If (Value(Self,iItm)=iField) ;                Function_Return (Value(Self,iItm+1))
11430>>>>>>>            Increment iItm
11431>>>>>>>            Increment iItm
11432>>>>>>>        Loop
11433>>>>>>>>
11433>>>>>>>        Function_Return 0
11434>>>>>>>    End_Function
11435>>>>>>>    
11435>>>>>>>    // define an extended object for field
11435>>>>>>>    Procedure DefineFieldObject Integer iField
11437>>>>>>>        Integer hFld
11437>>>>>>>        Integer iCnt  iFile
11437>>>>>>>        Boolean bInUse
11437>>>>>>>        Boolean bHasRecord
11437>>>>>>>        Delegate Get Main_File to iFile
11439>>>>>>>        Get Field_Object iField to hFld // this shouldn't exist yet
11440>>>>>>>        If not hFld Begin
11442>>>>>>>            Get Create U_FieldObject to hFld
11443>>>>>>>            Send DefineField to hFld iFile iField
11444>>>>>>>            Get Item_Count to iCnt          // add to array
11445>>>>>>>            Set Value  iCnt to iField   // Pos   = field#
11446>>>>>>>            Set Value  (iCnt+1) to hFld // Pos+1 = field object
11447>>>>>>>            Delegate Get In_Use_State to bInUse
11449>>>>>>>            If bInUse Begin
11451>>>>>>>                Delegate Send Refind_Records
11453>>>>>>>                Delegate Get HasRecord to bHasRecord
11455>>>>>>>                // updating the newly created field with the file buffer contents we don't
11455>>>>>>>                // want to change the field's changed state, which might have been set already.
11455>>>>>>>                Send FieldRefresh of hFld (not(bHasRecord)) False
11456>>>>>>>            End
11456>>>>>>>>
11456>>>>>>>        End
11456>>>>>>>>
11456>>>>>>>    End_Procedure
11457>>>>>>>    
11457>>>>>>>    // update all extended fields. Field buffer <-- DD buffer
11457>>>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
11459>>>>>>>        Integer iItm iCnt
11459>>>>>>>        Get Item_Count to iCnt
11460>>>>>>>        Move 0 to iItm
11461>>>>>>>        While iItm lt iCnt
11465>>>>>>>            Increment iItm
11466>>>>>>>            Send FieldUpdate to (Value(Self,iItm)) bSave
11467>>>>>>>            Increment iItm
11468>>>>>>>        Loop
11469>>>>>>>>
11469>>>>>>>    End_Procedure
11470>>>>>>>    
11470>>>>>>>    // refresh all extended fields. Field buffer --> DD buffer
11470>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
11472>>>>>>>        Integer iItm iCnt
11472>>>>>>>        Get Item_Count to iCnt
11473>>>>>>>        Move 0 to iItm
11474>>>>>>>        While iItm lt iCnt
11478>>>>>>>            Increment iItm
11479>>>>>>>            Send FieldRefresh to (Value(Self,iItm)) bCleared True
11480>>>>>>>            Increment iItm
11481>>>>>>>        Loop
11482>>>>>>>>
11482>>>>>>>    End_Procedure
11483>>>>>>>    
11483>>>>>>>    //
11483>>>>>>>    // these are sent from the child field object. We need to direct them
11483>>>>>>>    // to the DDO (the parent).
11483>>>>>>>    Procedure Set Field_Changed_State Integer iField Integer bState
11485>>>>>>>        Delegate Set Field_Changed_state iField to bState
11487>>>>>>>    End_Procedure
11488>>>>>>>    
11488>>>>>>>    Function Field_Changed_State Integer iField Returns Integer
11490>>>>>>>        Integer bState
11490>>>>>>>        Delegate Get Field_Changed_state iField to bState
11492>>>>>>>        Function_Return bState
11493>>>>>>>    End_Function
11494>>>>>>>    
11494>>>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iMode
11496>>>>>>>        Delegate Send File_field_AutoFind iFile iField iMode
11498>>>>>>>    End_Procedure
11499>>>>>>>    
11499>>>>>>>    Function FieldSaveNoPut Integer iField Returns Boolean
11501>>>>>>>        Boolean bIsCommited bNoPut
11501>>>>>>>        Delegate Get IsCommitted to bIsCommited
11503>>>>>>>        // we don't know if this is foreign or not (DDOs never do by themselves). We
11503>>>>>>>        // will test for regular. This should never be an issue as the DEO itself
11503>>>>>>>        // will be DisplayOnly as needed (we don't have indexed NoEnter=T/Noput=F issues)
11503>>>>>>>        Delegate Get FieldNoPut iField bIsCommited False to bNoPut
11505>>>>>>>        Function_Return bNoPut
11506>>>>>>>    End_Function
11507>>>>>>>    
11507>>>>>>>    Procedure Destroy_Object
11509>>>>>>>        Delegate Set Field_Objects to 0
11511>>>>>>>        Forward Send Destroy_object
11513>>>>>>>    End_Procedure
11514>>>>>>>    
11514>>>>>>>    
11514>>>>>>>End_Class
11515>>>>>// for text and binary. Must support Address Type
11515>>>>>
11515>>>>>
11515>>>>>// we need these from CLI.pkg for DAW drivers. These values must match what is defined
11515>>>>>// in cli.pkg
11515>>>>>Define DF_FILE_SQL_FILTER for 611
11515>>>>>Define DF_FILE_SQL_FILTER_ACTIVE for 624
11515>>>>>Define DF_FILE_SQL_FILTER_EQ for 636
11515>>>>>// same a CLI.pkg DF_FILE_TABLE_NAME but with a different name
11515>>>>>// used to avoid naming conflict. Must match cli.pkg df_file_table_name
11515>>>>>Define DF_FILE_SQL_TABLE_NAME for 609
11515>>>>>
11515>>>>>Define DF_FIELD_SQL_COLUMN_NAME         for 723
11515>>>>>
11515>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE     for 1085
11515>>>>>Define DF_FILE_DATABASE_ID              for 622
11515>>>>>
11515>>>>>// Class helper for SQL/driver assistance.
11515>>>>>// This can only be used within a DataDictionary Class as it expects that
11515>>>>>// certain properties can be Get and Set via delegation.
11515>>>>>Class cDAWSQLDriverHelper is a cObject
11516>>>>>    
11516>>>>>    Function DriverIndex String sDriver Returns Integer
11518>>>>>        String  sCurrentDriver
11518>>>>>        Integer iNumberOfDrivers iDriver iCount
11518>>>>>        Move 0 to iDriver
11519>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
11522>>>>>        For iCount from 1 to iNumberOfDrivers
11528>>>>>>
11528>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
11531>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
11533>>>>>                Function_Return iCount
11534>>>>>            End
11534>>>>>>
11534>>>>>        Loop
11535>>>>>>
11535>>>>>        Function_Return 0
11536>>>>>    End_Function
11537>>>>>    
11537>>>>>    
11537>>>>>    // returns true if this table supports SQL filter interface
11537>>>>>    Function SupportsSQLFilters Returns Boolean
11539>>>>>        String sDriver
11539>>>>>        Integer iFile iDriver iConformance
11539>>>>>        Delegate Get Main_File to iFile
11541>>>>>        Get_Attribute DF_FILE_DRIVER of iFile to sDriver
11544>>>>>        Get DriverIndex sDriver to iDriver
11545>>>>>        If (iDriver) Begin
11547>>>>>            Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
11550>>>>>        End
11550>>>>>>
11550>>>>>        Function_Return (iConformance iand 4)
11551>>>>>    End_Function
11552>>>>>    
11552>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
11552>>>>>    
11552>>>>>    // Escape character to escape LIKE wildcards
11552>>>>>    
11552>>>>>    
11552>>>>>    Function SQLEscapedStr String sSQL Returns String
11554>>>>>        String sEscapedSQL
11554>>>>>        // Replace one single quote by 2 single quotes
11554>>>>>        Move (Replaces("'",sSQL,"''")) to sEscapedSQL
11555>>>>>        Function_Return sEscapedSQL
11556>>>>>    End_Function
11557>>>>>    
11557>>>>>    
11557>>>>>    Function SQLEscapeLikeWildcards String sSQL Returns String
11559>>>>>        
11559>>>>>        // Escape the wildcard characters than can be used in a LIKE
11559>>>>>        If (Pos("%",sSQL)) ;            Move (Replaces("%",sSQL,(SQL_LIKE_ESC + "%"))) to sSQL
11562>>>>>        If (Pos("_",sSQL)) ;            Move (Replaces("_",sSQL,(SQL_LIKE_ESC + "_"))) to sSQL
11565>>>>>        
11565>>>>>        Function_Return sSQL
11566>>>>>    End_Function
11567>>>>>    
11567>>>>>    
11567>>>>>    
11567>>>>>    // Creates an SQL Like Filter for this field and search target
11567>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
11569>>>>>        String sFilter sOrigFilter sField
11569>>>>>        Integer iFile
11569>>>>>        Integer iHasLikeEscape
11569>>>>>        String  sPrefix
11569>>>>>        
11569>>>>>        Delegate Get Main_File to iFile
11571>>>>>        Delegate Get psSQLFilter to sOrigFilter
11573>>>>>        Get SQLStrFieldName iField to sField
11574>>>>>        Get SQLEscapedStr sSearch to sSearch
11575>>>>>        
11575>>>>>        Move (Pos(SQL_LIKE_ESC,sSearch)) to iHasLikeEscape
11576>>>>>        If (not(iHasLikeEscape)) Begin
11578>>>>>            Get SQLEscapeLikeWildcards sSearch to sSearch
11579>>>>>        End
11579>>>>>>
11579>>>>>        
11579>>>>>        // Add the N prefix to properly handle Unicode data
11579>>>>>        Move 'N' to sPrefix
11580>>>>>        Move (sField + " LIKE " + sPrefix + "'%" + sSearch + "%'") to sFilter
11581>>>>>        
11581>>>>>        If (not(iHasLikeEscape)) Begin
11583>>>>>            If (Pos(SQL_LIKE_ESC,sFilter)) Begin
11585>>>>>                Move (sFilter + " ESCAPE '" + SQL_LIKE_ESC + "' "  ) to sFilter
11586>>>>>            End
11586>>>>>>
11586>>>>>        End
11586>>>>>>
11586>>>>>        
11586>>>>>        Function_Return sFilter
11587>>>>>    End_Function
11588>>>>>    
11588>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
11588>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
11590>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
11592>>>>>            Move ( "(" + sOrigFilter + ") AND (" + sFilter + ")") to sFilter
11593>>>>>        End
11593>>>>>>
11593>>>>>        Else If (sFilter="") Begin
11596>>>>>            Move sOrigFilter to sFilter
11597>>>>>        End
11597>>>>>>
11597>>>>>        Function_Return sFilter
11598>>>>>    End_Function
11599>>>>>    
11599>>>>>    // Appends two filters with an or clause. Both or either can be empty.
11599>>>>>    // This may be used in OnConstrain methods when building SQL WHERE clauses in string values.
11599>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
11601>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
11603>>>>>            Move ("(" + sOrigFilter + ") OR (" + sFilter + ")") to sFilter
11604>>>>>        End
11604>>>>>>
11604>>>>>        Else If (sFilter="") Begin
11607>>>>>            Move sOrigFilter to sFilter
11608>>>>>        End
11608>>>>>>
11608>>>>>          Function_Return sFilter 
11609>>>>>    End_Function
11610>>>>>
11610>>>>>
11610>>>>>    Function SQLIdentifierQuote Handle hTable Returns String
11612>>>>>
11612>>>>>        String  sDriver        
11612>>>>>        Integer iDriverIndex
11612>>>>>        Handle  hDatabase
11612>>>>>        String  sIdentifierQuote
11612>>>>>        
11612>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriver
11615>>>>>        
11615>>>>>        Get DriverIndex sDriver to iDriverIndex        
11616>>>>>        If (iDriverIndex) Begin
11618>>>>>            Get_Attribute DF_FILE_DATABASE_ID of hTable to hDatabase            
11621>>>>>            If (hDatabase) Begin
11623>>>>>                Get_Attribute DF_DATABASE_IDENTIFIER_QUOTE of iDriverIndex hDatabase to sIdentifierQuote
11626>>>>>            End
11626>>>>>>
11626>>>>>        End
11626>>>>>>
11626>>>>>        
11626>>>>>        Function_Return sIdentifierQuote
11627>>>>>        
11627>>>>>    End_Function
11628>>>>>
11628>>>>>
11628>>>>>
11628>>>>>    // returns the name of the File and Field suitable for an SQL where statement ("Table"."Column")
11628>>>>>    Function SQLStrFileFieldName Integer iField Returns String
11630>>>>>        String sFile sField
11630>>>>>        Integer iFile
11630>>>>>        String  sIdentifierQuote
11630>>>>>        
11630>>>>>        Get Main_File to iFile
11631>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11634>>>>>        Get_Attribute DF_FIELD_SQL_COLUMN_NAME of iFile iField to sField
11637>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11638>>>>>        
11638>>>>>        Function_Return (sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11639>>>>>    End_Function
11640>>>>>
11640>>>>>    // returns the name of the Field suitable for an SQL where statement ("Column")
11640>>>>>    Function SQLStrFieldName Integer iField Returns String
11642>>>>>        String sField 
11642>>>>>        Integer iFile
11642>>>>>        String sIdentifierQuote
11642>>>>>        Get Main_File to iFile
11643>>>>>        Get_Attribute DF_FIELD_SQL_COLUMN_NAME of iFile iField to sField
11646>>>>>        
11646>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11647>>>>>        
11647>>>>>        Function_Return (sIdentifierQuote + sField + sIdentifierQuote ) 
11648>>>>>
11648>>>>>    End_Function
11649>>>>>
11649>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement ("Schema"."Table"."Column")
11649>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
11651>>>>>        String sFile sField sSchema
11651>>>>>        Integer iFile
11651>>>>>        String sIdentifierQuote
11651>>>>>        
11651>>>>>        Get Main_File to iFile
11652>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11655>>>>>        Get_Attribute DF_FIELD_SQL_COLUMN_NAME of iFile iField to sField
11658>>>>>        Get_Attribute DF_FILE_OWNER of iFile to sSchema
11661>>>>>
11661>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11662>>>>>            
11662>>>>>        If (Trim(sSchema) <> "") ;            Function_Return (sIdentifierQuote + sSchema + sIdentifierQuote + '.' + sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11665>>>>>        Else ;            Function_Return (sIdentifierQuote + sFile + sIdentifierQuote + '.' + sIdentifierQuote + sField + sIdentifierQuote ) 
11667>>>>>            
11667>>>>>            
11667>>>>>            
11667>>>>>    End_Function
11668>>>>>    
11668>>>>>    //  returns the name of a file suitable for a SQL statement
11668>>>>>    Function SQLStrFileName Integer iField Returns String
11670>>>>>        String sFile
11670>>>>>        Integer iFile
11670>>>>>        String sIdentifierQuote
11670>>>>>        
11670>>>>>        Get Main_File to iFile
11671>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
11674>>>>>        
11674>>>>>        Get SQLIdentifierQuote iFile to sIdentifierQuote
11675>>>>>        
11675>>>>>        Function_Return (sIdentifierQuote + sFile + sIdentifierQuote)
11676>>>>>    End_Function
11677>>>>>    
11677>>>>>    // called before an SQL Filter find. Make sure that any global and table attributes are
11677>>>>>    // stored.
11677>>>>>    Procedure StoreDefaultSQLFilters
11679>>>>>        String sOldFilter
11679>>>>>        Boolean bOldFilterActive bOldFilterEQ
11679>>>>>        Integer iMain
11679>>>>>        Get Main_File to iMain
11680>>>>>        Get_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
11683>>>>>        Get_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
11686>>>>>        Get_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
11689>>>>>        Delegate Set psOldFilter to sOldFilter
11691>>>>>        Delegate Set pbOldFilterActive to bOldFilterActive
11693>>>>>        Delegate Set pbOldFilterEq to bOldFilterEQ
11695>>>>>    End_Procedure
11696>>>>>    
11696>>>>>    // called after an SQL find. Must restore the global and table SQL filter attributes
11696>>>>>    Procedure RestoreDefaultSQLFilters
11698>>>>>        String sOldFilter
11698>>>>>        Boolean bOldFilterActive bOldFilterEQ
11698>>>>>        Integer iMain
11698>>>>>        Delegate Get Main_File to iMain
11700>>>>>        Delegate Get psOldFilter to sOldFilter
11702>>>>>        Delegate Get pbOldFilterActive to bOldFilterActive
11704>>>>>        Delegate Get pbOldFilterEq to bOldFilterEQ
11706>>>>>        Set_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
11709>>>>>        Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
11712>>>>>        Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
11715>>>>>    End_Procedure
11716>>>>>    
11716>>>>>    // applies the passed SQL filter. If empty, it should make sure that no filter
11716>>>>>    // is applied. If non-empty it should set the filter active, set the filter string
11716>>>>>    // and make sure this is applied to all finds (including find EQ)
11716>>>>>    Procedure ApplySQLFilterStr String sFilter
11718>>>>>        Integer iMain
11718>>>>>        Delegate Get Main_File to iMain
11720>>>>>        If (sFilter<>"") Begin
11722>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to True
11725>>>>>            Set_Attribute DF_FILE_SQL_FILTER of iMain to sFilter
11728>>>>>            Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to True
11731>>>>>        End
11731>>>>>>
11731>>>>>        Else Begin
11732>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to False
11735>>>>>        End
11735>>>>>>
11735>>>>>    End_Procedure
11736>>>>>    
11736>>>>>End_Class
11737>>>>>
11737>>>>>// Every data_set will have a object based on this class. It will hold
11737>>>>>// the values for the fields, the entry_options and the messages IDs of the
11737>>>>>// iEntry, iExit and iValidate messages for each field.
11737>>>>>// It is assumed that an object of this class will always be used as a
11737>>>>>// child object of a Data_Set object.
11737>>>>>//
11737>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.
11737>>>>>//
11737>>>>>// ITEM-PROPERTY   ASSIGNED-FUNCTION
11737>>>>>//
11737>>>>>// Value           The value of the field. Will be updated whenever the
11737>>>>>//                 value of a field changes due to data-entry or a found
11737>>>>>//                 record.
11737>>>>>// Data_File       Contains the filenumber. Is the same for every item.
11737>>>>>// Data_Field      Contains the fieldnumber for the item. Is equal to the
11737>>>>>//                 items' itemnumber.
11737>>>>>// Item_Options    Used to store the standard item-options of a field.
11737>>>>>// Aux_Value       Used to store the foreign-item-options of a field.
11737>>>>>Class cRecordBuffer is an cDDBuffer
11738>>>>>    
11738>>>>>    // This procedure will be called from the Data_Set when the Main_File is
11738>>>>>    // being set. It will create an item for each field of the file in this
11738>>>>>    // object. Fields of the types DF_OVERLAP, DF_TEXT and DF_BINARY are
11738>>>>>    // currently not added.
11738>>>>>    Procedure Create_Items Integer iFile
11740>>>>>        Integer iField_Count iField
11740>>>>>        
11740>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iField_Count
11743>>>>>        Set Main_File to iFile
11744>>>>>        Send Delete_Data
11745>>>>>        Set Item_Count to (iField_Count+1)
11746>>>>>        For iField from 0 to iField_Count
11752>>>>>>
11752>>>>>            // will skip recnum (field 0) if non-recnum table
11752>>>>>            // will set to skip if binary, text or overlap
11752>>>>>            Set Data_Field iField to iField
11753>>>>>        Loop
11754>>>>>>
11754>>>>>    End_Procedure
11755>>>>>    
11755>>>>>    // when an alias is created, we want to clear any values that will not be applied to
11755>>>>>    // this alias DD such as prompt and zoom objects (which would point to the superclass master)
11755>>>>>    Procedure ReDefineAliasItems Integer iFile
11757>>>>>        Integer i iItems
11757>>>>>        
11757>>>>>        Set Main_File to iFile
11758>>>>>        Get item_count to iItems
11759>>>>>        For i from 0 to (iItems-1)
11765>>>>>>
11765>>>>>            Set Prompt_Object i to 0
11766>>>>>            Set Zoom_Object i to 0
11767>>>>>        Loop
11768>>>>>>
11768>>>>>    End_Procedure
11769>>>>>    
11769>>>>>    
11769>>>>>    // This procedure will be called from the parent Data_Set whenever the
11769>>>>>    // Data_Set changes its Current_Record property, or after a Save, Delete or Clear operation.
11769>>>>>    // We use this event to store the values of the fields in our local record buffer.
11769>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
11771>>>>>        Integer iMain_File
11771>>>>>        Integer iOldState
11771>>>>>        tDDRemembered[] DefaultValues
11771>>>>>        tDDRemembered[] DefaultValues
11772>>>>>        Boolean bRetain bInReSync
11772>>>>>        Integer iFld iFlds iIndex
11772>>>>>        Handle hoDD
11772>>>>>        
11772>>>>>        Get Parent to hoDD
11773>>>>>        Delegate Get Main_File to iMain_File
11775>>>>>        
11775>>>>>        If not (IsNullRowId(riNew)) ;            Send Entry_Display
11778>>>>>        Else Begin            
11779>>>>>            If (OPERATION_ORIGIN) Begin
11781>>>>>                // This gets set by webapp during a resync. During resyncs, you don't want to rely
11781>>>>>                // on the values in the buffers (as they may not be yours), so you cannot do retain of rememberlast.
11781>>>>>                // Fortunately, you don't need to, as this information is not needed during a resync.
11781>>>>>                Get pbInResync of operation_origin to bInResync
11782>>>>>            End
11782>>>>>>
11782>>>>>            
11782>>>>>            // If we have any 17.0 Remember last value items, we must add those items to our array.
11782>>>>>            // Only do this if this is the operation origin or a parent (i.e., skip if a child DDO).
11782>>>>>            // Also skip if a resync. See above
11782>>>>>            If ( not(bInReSync) and ;                ( (Operation_Origin=hoDD) or ;                ( OPERATION_ORIGIN and (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ) Begin
11784>>>>>                Delegate Get pDDDefaults to DefaultValues
11786>>>>>                Move (SizeOfArray(DefaultValues)) to iFlds
11787>>>>>                For iFld from 0 to (iFlds-1)
11793>>>>>>
11793>>>>>                    Move (DefaultValues[iFld].sDefault=DD_RememberLast) to bRetain // if this is a dynamically assigned remember-last
11794>>>>>                    If bRetain Begin
11796>>>>>                        Get Value DefaultValues[iFld].iField to DefaultValues[iFld].sLastValue
11797>>>>>                    End
11797>>>>>>
11797>>>>>                    Else Begin
11798>>>>>                        Move '' to DefaultValues[iFld].sLastValue
11799>>>>>                    End
11799>>>>>>
11799>>>>>                Loop
11800>>>>>>
11800>>>>>                Delegate Set pDDDefaults to DefaultValues
11802>>>>>            End
11802>>>>>>
11802>>>>>            
11802>>>>>            // we must do this to make retains not set changed_state
11802>>>>>            Delegate Get Change_Disabled_State to iOldState
11804>>>>>            Delegate Set Change_Disabled_State to True
11806>>>>>            // If mode is anything other than clear, we do a clear all (clear keeps retains, clear all does not)
11806>>>>>            // Also do clear all if the DDO is foreign.
11806>>>>>            
11806>>>>>            // If bInReSync, we never use retains, as the buffer is not ours yet.
11806>>>>>            // The Entry_Clear, Entry_Clear_All parameter is bIgnoreRetains.
11806>>>>>            // When True, retain and retain_all states are ignored and cleared.
11806>>>>>            If (Operation_Mode=MODE_CLEARING and ;                ( (Operation_Origin=parent(Self)) or ;                (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) Begin
11808>>>>>                    Send Entry_Clear bInReSync
11809>>>>>            End
11809>>>>>>
11809>>>>>            Else Begin
11810>>>>>                Send Entry_Clear_all bInResync
11811>>>>>            End
11811>>>>>>
11811>>>>>            Delegate Set Change_Disabled_State to iOldState
11813>>>>>            Set Changed_State to False
11814>>>>>        End
11814>>>>>>
11814>>>>>    End_Procedure
11815>>>>>    
11815>>>>>    // Make sure to set the Changed_State of the Data_Set to TRUE when a
11815>>>>>    // field value changes and it's not during the Setting of the Defaults.
11815>>>>>    Procedure Set Changed_State Integer iState
11817>>>>>        Integer iNoChange
11817>>>>>        // Server.pkg in dso already knows this property
11817>>>>>        Delegate Get Change_disabled_State to iNoChange
11819>>>>>        If not iNoChange Begin
11821>>>>>            Forward Set Changed_State to iState
11823>>>>>            Delegate Set Changed_State to iState
11825>>>>>        End
11825>>>>>>
11825>>>>>    End_Procedure
11826>>>>>    
11826>>>>>End_Class
11827>>>>>
11827>>>>>
11827>>>>>// Objects of this class will be used to store all kinds of attributes
11827>>>>>// which belong to a field.
11827>>>>>//
11827>>>>>// FA_MIN_VALUE
11827>>>>>// Used to store the mininum value of field.
11827>>>>>//
11827>>>>>// FA_MAX_VALUE
11827>>>>>// Used to store the maximum value of a field.
11827>>>>>//
11827>>>>>// FA_CHECK_VALUE
11827>>>>>// Used to store a string which contains all possible values of a field.
11827>>>>>//
11827>>>>>// FA_CHECKBOX_TRUE
11827>>>>>// Used to store the TRUE value for a checkbox field
11827>>>>>//
11827>>>>>// FA_CHECKBOX_FALSE
11827>>>>>// Used to store the FALSE value of a checkbox field
11827>>>>>//
11827>>>>>// FA_TABLE_OBJECT
11827>>>>>// Stores object Id of a validation table.
11827>>>>>//
11827>>>>>// FA_ERROR_MESSAGE
11827>>>>>// Used to store a error text which will be shown to a user when a fields
11827>>>>>// value violates one of the rules defined for it.
11827>>>>>// This field may contain the special strings @MIN, @MAX and @CHECK. When
11827>>>>>// these are used, these will be replaced by the actual value of MIN_VALUE,
11827>>>>>// MAX_VALUE or CHECK_VALUE.
11827>>>>>//
11827>>>>>
11827>>>>>
11827>>>>>// Validation Types
11827>>>>>Enumeration_List
11827>>>>>    Define FA_VALIDATION_TYPE_NONE
11827>>>>>    Define FA_VALIDATION_TYPE_RANGE
11827>>>>>    Define FA_VALIDATION_TYPE_CHECK
11827>>>>>    Define FA_VALIDATION_TYPE_CHECKBOX
11827>>>>>    Define FA_VALIDATION_TYPE_TABLE
11827>>>>>End_Enumeration_List
11827>>>>>
11827>>>>>
11827>>>>>Class Field_Attributes is a Array
11828>>>>>    
11828>>>>>    Procedure Construct_Object
11830>>>>>        Forward Send Construct_Object
11832>>>>>        // Private: This replaces the use of arrays to get at this value. This
11832>>>>>        // allows us to find specific validation types (like checkboxes) more
11832>>>>>        // quickly than scanning an array
11832>>>>>        Property String Private.Validation_Types     ''
11833>>>>>    End_Procedure
11834>>>>>    
11834>>>>>    // Returns the extended validation type for the passed field.
11834>>>>>    Function Field_Validation_Type Integer iField Returns Integer
11836>>>>>        Integer iType
11836>>>>>        If iField ;            Move (mid(Private.Validation_Types(Self),1,iField)) to iType
11839>>>>>        Else ;            Move FA_VALIDATION_TYPE_NONE to iType
11841>>>>>        Function_Return iType
11842>>>>>    End_Function
11843>>>>>    
11843>>>>>    Procedure Set Field_Validation_Type Integer iField String sType
11845>>>>>        Integer iType
11845>>>>>        String sTypes
11845>>>>>        If iField Begin
11847>>>>>            Get Private.Validation_Types to sTypes
11848>>>>>            Set Private.Validation_Types to (Overstrike(sType, sTypes, iField))
11849>>>>>        End
11849>>>>>>
11849>>>>>    End_Procedure
11850>>>>>    
11850>>>>>    // Set any defaults required by this class when the main file is created.
11850>>>>>    // Create a string which contains all validation types. Set all to
11850>>>>>    // No extended validation type.
11850>>>>>    Procedure Create_Items
11852>>>>>        String  sType
11852>>>>>        Integer iCount
11852>>>>>        Delegate Get Field_Count to iCOunt
11854>>>>>        Move FA_VALIDATION_TYPE_NONE to sType
11855>>>>>        Set Private.Validation_Types to (Repeat(sType,iCount))
11856>>>>>    End_Procedure
11857>>>>>    
11857>>>>>    // Return field number of next field matching the passed validation type.
11857>>>>>    // Pass validation type and last position checked. Return 0 if no match
11857>>>>>    Function Next_Validation_Type String sType Integer iOffset Returns Integer
11859>>>>>        String sTypes
11859>>>>>        Integer iPos
11859>>>>>        Get Private.Validation_Types to sTypes
11860>>>>>        Move (Pos(sType, mid(sTypes,255,iOffset+1))) to iPos
11861>>>>>        If iPos ;            Add iOffset to iPos
11864>>>>>        Function_Return iPos
11865>>>>>    End_Function
11866>>>>>    
11866>>>>>    // This procedure will be called by the Extended_Data_Set to set the
11866>>>>>    // errornumber and message which will be triggered when it needs to.
11866>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
11868>>>>>        Integer iBase
11868>>>>>        Move (iField * FA_COUNT) to iBase
11869>>>>>        Set Value (iBase + FA_ERROR_NUMBER) to iErr
11870>>>>>        Set Value (iBase + FA_ERROR_MESSAGE) to sMsg
11871>>>>>    End_Procedure
11872>>>>>    
11872>>>>>    // Used to retreive the error number and message for a particular field
11872>>>>>    Function Field_Error_Number Integer iField Returns Integer
11874>>>>>        Integer iErr
11874>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_NUMBER)  to iErr
11875>>>>>        Function_Return iErr
11876>>>>>    End_Function
11877>>>>>    
11877>>>>>    Function Field_Error_Message Integer iField Returns String
11879>>>>>        String sValue
11879>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_MESSAGE) to sValue
11880>>>>>        Function_Return sValue
11881>>>>>    End_Function
11882>>>>>    
11882>>>>>    
11882>>>>>    // This function manages the validation of a field against its extended
11882>>>>>    // validations.
11882>>>>>    Function Validate_Field Integer iField Returns Integer
11884>>>>>        Integer iType
11884>>>>>        Integer iResult
11884>>>>>        Get Field_Validation_Type iField to iType
11885>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Get Validate_Field_Range iField to iResult
11888>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Get Validate_Field_Check iField to iResult
11892>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Get Validate_Field_Checkbox iField to iResult
11896>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Validate_Field_Table iField to iResult
11900>>>>>        Function_Return iResult
11901>>>>>    End_Function
11902>>>>>    
11902>>>>>    // All extended validations know how to send callback messages (iMsg) to
11902>>>>>    // the calling object (iObj). This allows external lists to get filled w/
11902>>>>>    // the contents of a range. Used by combo boxes, spinners, etc.
11902>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
11904>>>>>        Integer iType
11904>>>>>        Integer iResult
11904>>>>>        Get Field_Validation_Type iField to iType
11905>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Send Field_Fill_List_Field_Range iField iObj iMsg
11908>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Send Field_Fill_List_Field_Check iField iObj iMsg
11912>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Send Field_Fill_List_Field_Checkbox iField iObj iMsg
11916>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Send Field_Fill_List_Field_Table iField iObj iMsg
11920>>>>>    End_Procedure
11921>>>>>    
11921>>>>>    // Return the id of the validation table if one exists. Otherwise return
11921>>>>>    // a zero.
11921>>>>>    Function Field_Table_Object Integer iField Returns Integer
11923>>>>>        Integer iType
11923>>>>>        Integer iObj
11923>>>>>        Integer iBase
11923>>>>>        Move (iField * FA_COUNT) to iBase
11924>>>>>        Get Field_Validation_Type iField to iType
11925>>>>>        If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Value (iBase + FA_TABLE_OBJECT) to iObj
11928>>>>>        Function_Return iObj
11929>>>>>    End_Function
11930>>>>>    
11930>>>>>    // Procedure to set the range for a field. It will automatically set the
11930>>>>>    // validation type of the field as well.
11930>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
11932>>>>>        Integer iBase
11932>>>>>        Move (iField * FA_COUNT) to iBase
11933>>>>>        Set Value (iBase + FA_MIN_VALUE) to sMin
11934>>>>>        Set Value (iBase + FA_MAX_VALUE) to sMax
11935>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_RANGE
11936>>>>>    End_Procedure
11937>>>>>    
11937>>>>>    // Function to check a fields value agains a given check string.
11937>>>>>    Function Validate_Field_Range Integer iField Returns Integer
11939>>>>>        String  sMin
11939>>>>>        String  sMax
11939>>>>>        String  sValue
11939>>>>>        Integer iField_Type
11939>>>>>        Integer iResult
11939>>>>>        Integer iFile
11939>>>>>        Integer iBase
11939>>>>>        Move (iField * FA_COUNT) to iBase
11940>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
11941>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
11942>>>>>        Delegate Get Field_Current_Value iField to sValue
11944>>>>>        Delegate Get Main_File to iFile
11946>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
11949>>>>>        Move 0 to iResult
11950>>>>>        If (iField_Type=DF_ASCII) ;            Move (sValue < sMin or sValue > sMax) to iResult
11953>>>>>        Else If (iField_Type=DF_BCD) ;            Move (Number(sValue) < Number(sMin) or ;            Number(sValue) > Number(sMax)) to iResult
11957>>>>>        Else If (iField_Type=DF_DATE) ;            Move (Date(sValue) < Date(sMin) or Date(sValue) > Date(sMax)) to iResult
11961>>>>>        Else If (iField_Type=DF_DATETIME) ;            Move (Cast(sValue,DateTime) < Cast(sMin,DateTime) or Cast(sValue,DateTime) > Cast(sMax,DateTime)) to iResult
11965>>>>>        If iResult Begin
11967>>>>>            Delegate Send Field_Error iField DD_INVALID_RANGE sMin sMax
11969>>>>>            Function_Return 1
11970>>>>>        End
11970>>>>>>
11970>>>>>    End_Function
11971>>>>>    
11971>>>>>    // Callback to provide all valid value for this validation.
11971>>>>>    // Just call back with the two range values
11971>>>>>    Procedure Field_Fill_List_Field_Range Integer iField Integer iObj Integer iMsg
11973>>>>>        String  sMin
11973>>>>>        String  sMax
11973>>>>>        Integer iBase
11973>>>>>        Move (iField * FA_COUNT) to iBase
11974>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
11975>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
11976>>>>>        Send iMsg to iObj 0 sMin '' 0 (NullrowId())
11977>>>>>        Send iMsg to iObj 1 sMax '' 0 (NullrowId())
11978>>>>>    End_Procedure
11979>>>>>    
11979>>>>>    // Procedure to set the check for a field. It will automatically set the
11979>>>>>    // validation type of the field as well.
11979>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
11981>>>>>        Integer iBase
11981>>>>>        Move (iField * FA_COUNT) to iBase
11982>>>>>        Set Value (iBase + FA_CHECK_VALUE) to sCheck
11983>>>>>        //Set Value iBase to FA_VALIDATION_TYPE_CHECK
11983>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECK
11984>>>>>    End_Procedure
11985>>>>>    
11985>>>>>    // Function to check a fields value agains a given check string.
11985>>>>>    Function Validate_Field_Check Integer iField Returns Integer
11987>>>>>        String  sCheck
11987>>>>>        String  sValue
11987>>>>>        Integer iBase
11987>>>>>        Integer iPos
11987>>>>>        Integer iLength
11987>>>>>        Integer iResult
11987>>>>>        Integer iFile
11987>>>>>        Move (iField * FA_COUNT) to iBase
11988>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
11989>>>>>        Delegate Get Field_Current_Value iField to sValue
11991>>>>>        Delegate Get Main_File to iFile
11993>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
11996>>>>>        Move (Pad( sValue,iLength)) to sValue
11997>>>>>        // Replace the seperation characters with two of them so the user
11997>>>>>        // can't bypass the check by entering a seperation character.
11997>>>>>        Move (Replaces("|", sValue, "||")) to sValue
11998>>>>>        // Report an error if rules are violated.
11998>>>>>        Move (Pos( sValue, sCheck)) to iPos
11999>>>>>        If not iPos Begin
12001>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECK sCheck
12003>>>>>            Function_Return 1
12004>>>>>        End
12004>>>>>>
12004>>>>>    End_Function
12005>>>>>    
12005>>>>>    // Callback to provide all valid value for this validation.
12005>>>>>    // Call back with all valid check values
12005>>>>>    Procedure Field_Fill_List_Field_Check Integer iField Integer iObj Integer iMsg
12007>>>>>        String  sCheck
12007>>>>>        Integer iBase
12007>>>>>        Integer iPos
12007>>>>>        Integer iItem
12007>>>>>        Move (iField * FA_COUNT) to iBase
12008>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
12009>>>>>        Append sCheck "|"
12010>>>>>        Move (Pos( "|", sCheck)) to iPos
12011>>>>>        While iPos
12015>>>>>            If (iPos > 1) Begin
12017>>>>>                Send iMsg to iObj iItem (Left(sCheck,iPos-1)) '' 0 (NullrowId())
12018>>>>>                Increment iItem
12019>>>>>            End
12019>>>>>>
12019>>>>>            Move (Mid( sCheck, 255, iPos+1))  to sCheck
12020>>>>>            Move (Pos( "|", sCheck)) to iPos
12021>>>>>        Loop
12022>>>>>>
12022>>>>>    End_Procedure
12023>>>>>    
12023>>>>>    // Procedure to set up a checkbox field. We will store the TRUE and FALSE
12023>>>>>    // Values in the extended array.
12023>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
12025>>>>>        Integer iBase
12025>>>>>        Move (iField * FA_COUNT) to iBase
12026>>>>>        Set Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12027>>>>>        Set Value (iBase + FA_CHECKBOX_FALSE) to sFalse
12028>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECKBOX
12029>>>>>    End_Procedure
12030>>>>>    
12030>>>>>    // Return the Value associated with the field and its select-state.
12030>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
12032>>>>>        Integer iBase
12032>>>>>        Integer iType
12032>>>>>        String sValue
12032>>>>>        Move (iField * FA_COUNT) to iBase
12033>>>>>        Get Field_Validation_Type iField to iType
12034>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move iState to sValue
12037>>>>>        Else ;            Get Value (iBase + If(iState,FA_CHECKBOX_TRUE,FA_CHECKBOX_FALSE));            to sValue
12039>>>>>        Function_Return sValue
12040>>>>>    End_Function
12041>>>>>    
12041>>>>>    // Return the select_state based on the passed value and field
12041>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
12043>>>>>        Integer iBase
12043>>>>>        Integer iType
12043>>>>>        String  sTrue
12043>>>>>        Integer iState
12043>>>>>        Integer iFile
12043>>>>>        Integer iField_Type
12043>>>>>        Move (iField * FA_COUNT) to iBase
12044>>>>>        Get Field_Validation_Type iField to iType
12045>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12046>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move (not(sValue=0 or sValue='')) to iState
12049>>>>>        Else Begin
12050>>>>>            Delegate Get Main_File to iFile
12052>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
12055>>>>>            If (iField_Type = DF_BCD) ;                Move (Number(sValue)=Number(sTrue)) to iState
12058>>>>>            Else ; // DF_ASCII                Move (sValue=sTrue) to iState
12060>>>>>        End
12060>>>>>>
12060>>>>>        Function_Return iState
12061>>>>>    End_Function
12062>>>>>    
12062>>>>>    
12062>>>>>    // Check that the buffer value is one of the two checkbox values.
12062>>>>>    Function Validate_Field_Checkbox Integer iField Returns Integer
12064>>>>>        String  sTrue
12064>>>>>        String  sFalse
12064>>>>>        String  sValue
12064>>>>>        Integer iField_Type
12064>>>>>        Integer iResult
12064>>>>>        Integer iFile
12064>>>>>        Integer iBase
12064>>>>>        Move (iField * FA_COUNT) to iBase
12065>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12066>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
12067>>>>>        Delegate Get Field_Current_Value iField to sValue
12069>>>>>        Delegate Get Main_File to iFile
12071>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
12074>>>>>        Move 0 to iResult
12075>>>>>        If (iField_Type = DF_BCD) ;            Move (Number(sValue)=Number(sTrue) or ;            Number(sValue)=Number(sFalse)) to iResult
12078>>>>>        Else ; // DF_ASCII            Move (sValue=sTrue or sValue=sFalse) to iResult
12080>>>>>        If not iResult Begin
12082>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECKBOX sTrue sFalse
12084>>>>>            Function_Return 1
12085>>>>>        End
12085>>>>>>
12085>>>>>    End_Function
12086>>>>>    
12086>>>>>    // Callback to provide all valid value for this validation.
12086>>>>>    // Just call back with the two true and false values
12086>>>>>    Procedure Field_Fill_List_Field_Checkbox Integer iField Integer iObj Integer iMsg
12088>>>>>        String  sTrue
12088>>>>>        String  sFalse
12088>>>>>        Integer iBase
12088>>>>>        Move (iField * FA_COUNT) to iBase
12089>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
12090>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
12091>>>>>        Send iMsg to iObj 0 sTrue '' 0 (NullrowId())
12092>>>>>        Send iMsg to iObj 1 sFalse '' 0 (NullrowId())
12093>>>>>    End_Procedure
12094>>>>>    
12094>>>>>    // The object keeps track of a validation table object. This table object
12094>>>>>    // can be any type of object must at a minimum understand a small message
12094>>>>>    // protocol (see xvaltbl.pkg for info)
12094>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
12096>>>>>        Integer iBase
12096>>>>>        Move (iField * FA_COUNT) to iBase
12097>>>>>        Set Value (iBase + FA_TABLE_OBJECT) to iObj
12098>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_TABLE
12099>>>>>    End_Procedure
12100>>>>>    
12100>>>>>    // This valdates against a validation table if appropriate (if a table
12100>>>>>    // exists and the table's validate_State is T). It validates by passing
12100>>>>>    // the message validate_value to the validation table object
12100>>>>>    Function Validate_Field_Table Integer iField Returns Integer
12102>>>>>        Integer iBase
12102>>>>>        Integer iTableObj
12102>>>>>        String  sValue
12102>>>>>        Integer iResult
12102>>>>>        Move (iField * FA_COUNT) to iBase
12103>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
12104>>>>>        If (iTableObj and Validate_State(iTableObj) ) Begin
12106>>>>>            Delegate Get Field_Current_Value iField to sValue
12108>>>>>            Get Validate_Value of iTableOBj sValue to iResult
12109>>>>>            If iResult ;                Delegate Send Field_Error iField DD_INVALID_VALUE_TABLE
12113>>>>>        End
12113>>>>>>
12113>>>>>        Function_Return iResult
12114>>>>>    End_Function
12115>>>>>    
12115>>>>>    // Callback to provide all valid value for this validation.
12115>>>>>    // Pass the request on to the validation table. This is the most common
12115>>>>>    // use of this.
12115>>>>>    Procedure Field_Fill_List_Field_Table Integer iField Integer iObj Integer iMsg
12117>>>>>        Integer iBase
12117>>>>>        Integer iTableObj
12117>>>>>        Move (iField * FA_COUNT) to iBase
12118>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
12119>>>>>        If iTableObj ;            Send Request_Fill_From_List to iTableObj iObj iMsg
12122>>>>>    End_Procedure
12123>>>>>    
12123>>>>>    // Often extended valditation types can provide automatic prompt
12123>>>>>    // objects. If the extended type supports a prompt object and there is
12123>>>>>    // a global validation_list object, we will use it
12123>>>>>    Function Prompt_Object Integer iField Returns Integer
12125>>>>>        Integer iType
12125>>>>>        Integer iObj
12125>>>>>        Get Field_Validation_Type iField to iType
12126>>>>>        If not (iType=FA_VALIDATION_TYPE_NONE or iType=FA_VALIDATION_TYPE_RANGE) ;            Move DD_Global_Validation_Prompt_Object to iObj
12129>>>>>        Function_Return iObj
12130>>>>>    End_Function
12131>>>>>    
12131>>>>>    
12131>>>>>End_Class
12132>>>>>
12132>>>>>
12132>>>>>
12132>>>>>// use to keep track of file field pairs such as system file file/field
12132>>>>>Struct tDDFileField
12132>>>>>    Integer iFile
12132>>>>>    Integer iField
12132>>>>>End_Struct
12132>>>>>
12132>>>>>Class Field_Mask_Array is an Array
12133>>>>>    
12133>>>>>    Function Array_Name Integer iField Integer iType Returns String
12135>>>>>        String sName
12135>>>>>        Move (iField*FMA_COUNT+iType) to iField
12136>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to sName
12139>>>>>        // sometimes an array value that is undefined returns a 0, we must change this to ''
12139>>>>>        If (sName = '0') ;            Move '' to sName
12142>>>>>        Function_Return sName
12143>>>>>    End_Function
12144>>>>>    
12144>>>>>    
12144>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
12146>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_TYPE) to iType
12147>>>>>    End_Procedure
12148>>>>>    
12148>>>>>    Function Field_Mask_Type Integer iField Returns Integer
12150>>>>>        Integer iType
12150>>>>>        Move (iField*FMA_COUNT+FMA_MASK_TYPE) to iField
12151>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iType
12154>>>>>        Function_Return iType
12155>>>>>    End_Function
12156>>>>>    
12156>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
12158>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iState
12159>>>>>    End_Procedure
12160>>>>>    
12160>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
12162>>>>>        Integer iState
12162>>>>>        Move (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iField
12163>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iState
12166>>>>>        Function_Return iState
12167>>>>>    End_Function
12168>>>>>    
12168>>>>>    Procedure Set Field_Mask Integer iField String sMask
12170>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK) to sMask
12171>>>>>    End_Procedure
12172>>>>>    
12172>>>>>    Function Field_Mask Integer iField Returns String
12174>>>>>        Function_Return (Array_Name(Self,iField,FMA_MASK))
12175>>>>>    End_Function
12176>>>>>    
12176>>>>>    Procedure Set Field_Label_Short Integer iField String sName
12178>>>>>        Set Value (iField*FMA_COUNT+FMA_SHORT_NAME) to sName
12179>>>>>    End_Procedure
12180>>>>>    
12180>>>>>    Function Field_Label_Short Integer iField Returns String
12182>>>>>        Function_Return (Array_Name(Self,iField,FMA_SHORT_NAME))
12183>>>>>    End_Function
12184>>>>>    
12184>>>>>    Procedure Set Field_Label_Long Integer iField String sName
12186>>>>>        Set Value (iField*FMA_COUNT+FMA_LONG_NAME) to sName
12187>>>>>    End_Procedure
12188>>>>>    
12188>>>>>    Function Field_Label_Long Integer iField Returns String
12190>>>>>        Function_Return (Array_Name(Self,iField,FMA_LONG_NAME))
12191>>>>>    End_Function
12192>>>>>    
12192>>>>>    Procedure Set Field_Class_Name Integer iField String sName
12194>>>>>        Set Value (iField*FMA_COUNT+FMA_CLASS_NAME) to sName
12195>>>>>    End_Procedure
12196>>>>>    
12196>>>>>    Function Field_Class_Name Integer iField Returns String
12198>>>>>        Function_Return (Array_Name(Self,iField,FMA_CLASS_NAME))
12199>>>>>    End_Function
12200>>>>>    
12200>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoPrompt
12202>>>>>        Set Value (iField*FMA_COUNT+FMA_WEBPROMPTOBJECT) to hoPrompt
12203>>>>>    End_Procedure
12204>>>>>    
12204>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
12206>>>>>        Function_Return (Array_Name(Self,iField,FMA_WEBPROMPTOBJECT))
12207>>>>>    End_Function
12208>>>>>    
12208>>>>>End_Class
12209>>>>>
12209>>>>>Class DataDictionary is a DataSet
12210>>>>>    
12210>>>>>    Procedure Construct_Object
12212>>>>>        Forward Send Construct_Object
12214>>>>>        
12214>>>>>        Property String  Existing_Key_Value                           ""
12215>>>>>        Property Integer Protect_Key_State                            True
12216>>>>>        
12216>>>>>        Property String  Key_Fields                                   ""
12217>>>>>        
12217>>>>>        // These are added to support the checking of DSO connections
12217>>>>>        // during deletes and saves. Only the first two properties are Public
12217>>>>>        Property Integer Validate_Save_Structure_Mode   DD_Validate_Structure_Once
12218>>>>>        Property Integer Validate_Delete_Structure_Mode DD_Validate_Structure_Once
12219>>>>>        Property Integer Save_Structure_Validated_State              False
12220>>>>>        Property Integer Cascade_Delete_Structure_Validated_State    False
12221>>>>>        Property Integer No_Cascade_Delete_Structure_Validated_State False
12222>>>>>        
12222>>>>>        Property Integer Last_Mark_Sequence_Id                       0
12223>>>>>        
12223>>>>>        // These are added for optimized traversal of
12223>>>>>        // entry-update and validation and maybe more
12223>>>>>        Property String  Visited_Fields          ""
12224>>>>>        Property Integer Visited_State           False
12225>>>>>        // means will be part of a downward delete (cascade deletable). This only has meaning
12225>>>>>        // when cascade_delete_state is True
12225>>>>>        Property Boolean DownDelete_State        False
12226>>>>>        
12226>>>>>        // these are set by the define_auto_increment, which is obsolete and has been replaced
12226>>>>>        // the Set Field_auto_increment method.
12226>>>>>        Property Integer Auto_Increment_Source_File  0
12227>>>>>        Property Integer Auto_Increment_Source_Field 0
12228>>>>>        Property Integer Auto_Increment_Dest_Field   0
12229>>>>>        
12229>>>>>        // used by the set Field_auto_increment method
12229>>>>>        // these are split into two arrays to make searching for the field easier
12229>>>>>        // the arrays should always be synched.
12229>>>>>        Property Integer[] pAutoIncrementFields
12230>>>>>        Property tDDFileField[] pAutoIncrementSysFileFields
12231>>>>>        
12231>>>>>        // Error Reporting Related
12231>>>>>        // If DD_Error_No_Report errors would be supressed (only ERR gets set)
12231>>>>>        Property Integer Error_Report_Mode           DD_Error_Report
12232>>>>>        
12232>>>>>        // During validation, this is the field being validated.
12232>>>>>        Property Integer Current_Validate_Field      0
12233>>>>>        
12233>>>>>        // when errors are redirected locally this maintains the original handler.
12233>>>>>        Property Integer Old_Error_Object_Id         0
12234>>>>>        
12234>>>>>        // Must be provided if local error handler is to be created
12234>>>>>        Property Integer Error_Processing_State      0
12235>>>>>        
12235>>>>>        // These should be changed most carefully and possible only and the
12235>>>>>        // DSO level. These allow you to defeat full field validation which
12235>>>>>        // makes it easier to corrupt data! Validate_DEO_Only_State limits
12235>>>>>        // save validation to DEOs (which is what data-sets have always done).
12235>>>>>        // Validate_foreign_File_State will skip validation under the following
12235>>>>>        // conditions: 1) DSO if for a parent (it did not originate the save).
12235>>>>>        //
12235>>>>>        Property Integer Validate_DEOs_Only_State    False
12236>>>>>        Property Integer Validate_Foreign_File_State True
12237>>>>>        // if set true, a field validation requested started with this
12237>>>>>        // DD will check all fields, even in an error is encountered
12237>>>>>        Property Integer Validate_All_Fields_State   False
12238>>>>>        
12238>>>>>        // If true, all entry updates will occur through the DD. Else
12238>>>>>        // saves occur through the DD and find occur through the DEOs
12238>>>>>        Property Integer EntryUpdateLocalState True // changed from false to true in 17.0
12239>>>>>        
12239>>>>>        // can be used by Refind_records method (remote refind of recs). Obsolete. Use prFindRowId
12239>>>>>        Property Integer Find_Record_Id 0
12240>>>>>        
12240>>>>>        // can be used by Refind_records method (remote refind of recs)
12240>>>>>        Property RowID prFindRowId (NullRowId())
12241>>>>>        // can be used by Refind_records method (remote refind of recs)
12241>>>>>        Property tDDChangedInfo pDDChangedInfo
12242>>>>>        
12242>>>>>        // Private: Id of field_objects container. This is not created until needed
12242>>>>>        Property Integer Field_Objects 0
12243>>>>>        
12243>>>>>        // Public: If set the DDO will never be foreign, allowing
12243>>>>>        // you to create new parents when a child is saved. This would
12243>>>>>        // normally only be set within the DDO and not the class. This would be
12243>>>>>        // used where a child table wants to save the parent (header) when the
12243>>>>>        // first child is saved. It would disable the foreign key and index
12243>>>>>        // find_Req and required settings (as well as any displayonly).
12243>>>>>        Property Integer Allow_Foreign_New_Save_State False
12244>>>>>        
12244>>>>>        Set pbDDAttach to True // set false to get (very) old attach_main_file_behavior
12245>>>>>        Set pbSmartRelate to True // Only relate if parent is attached via a DDO
12246>>>>>        
12246>>>>>        // If this is an alias file, this is the master file it is based on
12246>>>>>        Property Handle piMasterTable 0
12247>>>>>        
12247>>>>>        Property tDDServerInformation[] pServerInformation
12248>>>>>        
12248>>>>>        Property tDDRemembered[] pDDDefaults
12249>>>>>        
12249>>>>>        Property Boolean pbInSuperFind False
12250>>>>>        
12250>>>>>        // Create the local buffer.
12250>>>>>        Object Record_Buffer is a cRecordBuffer
12252>>>>>        End_Object
12253>>>>>        
12253>>>>>        // Create the extended field attributes array.
12253>>>>>        Object Field_Attributes is a Field_Attributes
12255>>>>>        End_Object
12256>>>>>        
12256>>>>>        // Create an array to maintain Status help values for each field
12256>>>>>        Object Statushelp_Array is an array
12258>>>>>        End_Object
12259>>>>>        
12259>>>>>        Object FieldMask_Array is an Field_Mask_array
12261>>>>>        End_Object
12262>>>>>        
12262>>>>>        
12262>>>>>        // keep track of all system/unknown files that must be set to
12262>>>>>        // default for smart file mode to work right.
12262>>>>>        Object System_File_obj is an Array
12264>>>>>        End_Object
12265>>>>>        
12265>>>>>        // used during Request_Validate
12265>>>>>        Property Handle[] pDDsWithFindReqErrors
12266>>>>>        
12266>>>>>        // Apply SQL filters in constrained finds
12266>>>>>        Property Boolean pbUseDDSQLFilters False
12267>>>>>        // If pbUseDDSQLFilters is true, this determines if the table global filter should be applied as well
12267>>>>>        Property Boolean pbApplyGlobalSQLFilters False
12268>>>>>        // Filter which will get applied before each DDO constrained find. If "", no filter is applied
12268>>>>>        Property String psSQLFilter ""
12269>>>>>        
12269>>>>>        // Old values for SQL Filters which are pushed and popped by StoreSQLDefaultFilters and RestoreSQLDefaultFilters
12269>>>>>        Property String psOldFilter ""
12270>>>>>        Property Boolean pbOldFilterActive
12271>>>>>        Property Boolean pbOldFilterEq
12272>>>>>        
12272>>>>>        // used to point to the composite child object that provides the SQL
12272>>>>>        // interfaces for a driver. This can be used with DAW drivers. Other drivers may require
12272>>>>>        // that you sub-class your DD and create a different object based on a custom class
12272>>>>>        Property Handle phoSQLHelper (Create(Self,RefClass(cDAWSQLDriverHelper)))
12273>>>>>        
12273>>>>>        
12273>>>>>        Property Handle pbInResync False
12274>>>>>        
12274>>>>>        Property Integer piPrimaryIndex -1      // Indicates the unique index used by the webapp view state system (-1 defaults to the primary key or recnum for embedded).
12275>>>>>        
12275>>>>>        Set Smart_FileMode_State to True  // extended DSOs should default to true
12276>>>>>        
12276>>>>>        Send Define_Fields // Developer Hook - define all field rules
12277>>>>>    End_Procedure
12278>>>>>    
12278>>>>>    // Returns 1 to indicate that this is a DD class.
12278>>>>>    Function Extended_DSO_State Returns Integer
12280>>>>>        Function_Return 1
12281>>>>>    End_Function
12282>>>>>    
12282>>>>>    
12282>>>>>    // Used to set up all XDS functions and rules. Called by construct_object
12282>>>>>    // and considered a bit more user friendly.
12282>>>>>    Procedure Define_Fields
12284>>>>>    End_Procedure
12285>>>>>    
12285>>>>>    
12285>>>>>    
12285>>>>>    // This message has been augmented to create a local recordbuffer for a
12285>>>>>    // file. We cannot do this earlier because we need the file to count the
12285>>>>>    // number of necessary fields.
12285>>>>>    Procedure Set Main_File Integer iFile
12287>>>>>        Integer iCurrent_File iMaster
12287>>>>>        Get piMasterTable to iMaster
12288>>>>>        If iMaster Begin
12290>>>>>            // is an alias condition
12290>>>>>            Forward Set Main_File to iFile
12292>>>>>            Send ReDefineAliasItems to (Record_Buffer(Self)) iFile
12293>>>>>        End
12293>>>>>>
12293>>>>>        Else If iFile Begin
12296>>>>>            Get Main_File to iCurrent_File
12297>>>>>            If (iCurrent_File and iCurrent_File <> iFile) Begin
12299>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_CANNOT_CHANGE_MAIN_FILE
12300>>>>>                Procedure_Return
12301>>>>>            End
12301>>>>>>
12301>>>>>            Forward Set Main_File to iFile
12303>>>>>            Send Create_Items to (Record_Buffer(Self)) iFile
12304>>>>>            Send Create_Items to (Field_Attributes(Self))
12305>>>>>        End
12305>>>>>>
12305>>>>>    End_Procedure
12306>>>>>    
12306>>>>>    // This procedure will update the Key_Fields property to include or
12306>>>>>    // excluded the fieldnumber passed in the list of fieldnumbers which make
12306>>>>>    // up an keyvalue.
12306>>>>>    Procedure Set Key_Field_State Integer iField Integer iState
12308>>>>>        String  sKeys
12308>>>>>        Set Key_Field_State of Record_Buffer iField to iState
12309>>>>>        Get Key_Fields to sKeys
12310>>>>>        Set Key_Fields to (Overstrike(If(iState, "X", " "), sKeys, iField))
12311>>>>>    End_Procedure
12312>>>>>    
12312>>>>>    // Will return TRUE if the field passed has been defined as a key.
12312>>>>>    Function Key_Field_State Integer iField Returns Integer
12314>>>>>        Integer iState
12314>>>>>        Get Key_Field_State of Record_Buffer iField to iState
12315>>>>>        Function_Return iState
12316>>>>>    End_Function
12317>>>>>    
12317>>>>>    // Returns complete key value.
12317>>>>>    Function Key_Value Returns String
12319>>>>>        String  sKeys
12319>>>>>        String  sKey_Value
12319>>>>>        String  sValue
12319>>>>>        Integer iField
12319>>>>>        Get Key_Fields to sKeys
12320>>>>>        Move "" to sKey_Value
12321>>>>>        Repeat
12321>>>>>>
12321>>>>>            Move (Pos( "X",sKeys)) to iField
12322>>>>>            If iField Begin
12324>>>>>                Get Field_Current_Value iField to sValue
12325>>>>>                Append sKey_Value sValue
12326>>>>>                Move (Overstrike(" ", sKeys, iField)) to sKeys
12327>>>>>            End
12327>>>>>>
12327>>>>>        Until not iField
12329>>>>>        Function_Return sKey_Value
12330>>>>>    End_Function
12331>>>>>    
12331>>>>>    // This procedure will be called whenever the Data_Set changes its
12331>>>>>    // Current_Record property, or after a Save, Delete or Clear operation.
12331>>>>>    // We send this message to the Record_Buffer object to update its values.
12331>>>>>    Procedure New_Current_Record Integer iOld Integer iNew
12333>>>>>        // does nothing, but exists if developer is using this for some purpose. Is called after
12333>>>>>        // OnNewCurrentRecord (if recnum based table)
12333>>>>>    End_Procedure
12334>>>>>    
12334>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
12336>>>>>        Integer iObj
12336>>>>>        Integer iOldst
12336>>>>>        Integer iFoc
12336>>>>>        Integer iIsExt
12336>>>>>        Forward Send OnNewCurrentRecord riOld riNew
12338>>>>>        Move (Record_Buffer(Self)) to iObj
12339>>>>>        If iObj Begin
12341>>>>>            Send OnNewCurrentRecord of iObj riOld riNew
12342>>>>>            // must also refresh all defined extended fields
12342>>>>>            Send ExtendedFieldsRefresh (IsNullRowId(riNew)) // pass bCleared (true if a clear)
12343>>>>>            Get Focus of Desktop to iFoc
12344>>>>>            Get Extended_DEO_State of iFoc to iIsExt     // if focus is deo item
12345>>>>>            If iIsExt Begin                               // disable the state so
12347>>>>>                Get Entry_Refresh_State of iFoc to iOldSt // value will come
12348>>>>>                Set Entry_Refresh_State of iFoc to True   // from Local buffer.
12349>>>>>            End
12349>>>>>>
12349>>>>>            Set Existing_Key_Value to (Key_Value(Self))
12350>>>>>            If iIsExt ;                Set Entry_Refresh_State of iFoc to iOldSt
12353>>>>>            // Only set defaults when the record is new
12353>>>>>            If (IsNullRowId(riNew)) ;                Send Prepare_Default_Values
12356>>>>>        End
12356>>>>>>
12356>>>>>    End_Procedure
12357>>>>>    
12357>>>>>    // Shuts off change mode and sends initialize_default_values which is
12357>>>>>    // a user hook routine.
12357>>>>>    Procedure Prepare_Default_Values
12359>>>>>        Integer iOldState
12359>>>>>        Get Change_disabled_State to iOldState
12360>>>>>        Set Change_disabled_State to True
12361>>>>>        Send Private_Field_Defaults
12362>>>>>        // set defaults if this is the main DDO or the DDO is
12362>>>>>        // flagged as supporting saving new records when foreign (a parent)
12362>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self)) ;            Send Field_Defaults
12365>>>>>        Send AssignDynamicDefaults
12366>>>>>        Set Change_disabled_State to iOldState
12367>>>>>    End_Procedure
12368>>>>>    
12368>>>>>    // Set all checkbox fields to default to False data value.
12368>>>>>    Procedure Private_Field_Defaults
12370>>>>>        Integer iField
12370>>>>>        Repeat
12370>>>>>>
12370>>>>>            Get Next_Validation_Type of (Field_Attributes(Self)) ;                FA_VALIDATION_TYPE_CHECKBOX iField to iField
12371>>>>>            If (iField = 0) ;                Procedure_Return
12374>>>>>            Set Field_Select_State  iField to False
12375>>>>>            Set Field_Changed_State iField to True
12376>>>>>        Loop
12377>>>>>>
12377>>>>>    End_Procedure
12378>>>>>    
12378>>>>>    // Will be called after a clear operation to let the application
12378>>>>>    // programmer set the default values for the record. This should be done
12378>>>>>    // by sending SET Field_Current_Value.
12378>>>>>    Procedure Field_Defaults
12380>>>>>    End_Procedure
12381>>>>>    
12381>>>>>    // Pass type and string value and see if this is valid data for this
12381>>>>>    // type. Currently we check for numbers and dates. Return non-zero
12381>>>>>    // if invalid.
12381>>>>>    Function IsDataInvalid Integer iType String sValue Returns Integer
12383>>>>>        Date    dVal
12383>>>>>        DateTime dtVal
12383>>>>>        Number  nVal
12383>>>>>        Integer bOK
12383>>>>>        Boolean bInvalid
12383>>>>>        
12383>>>>>        Move False to bInvalid
12384>>>>>        If (iType=DF_BCD or iType=DF_DATE or iType=DF_DATETIME) Begin
12386>>>>>            If (iType=DF_DATE) Begin
12388>>>>>                MoveTrapErr sValue to dVal
12389>>>>>                Move (Err) to bInvalid
12390>>>>>            End
12390>>>>>>
12390>>>>>            Else If (iType=DF_DATETIME) Begin
12393>>>>>                MoveTrapErr sValue to dtVal
12394>>>>>                Move (Err) to bInvalid
12395>>>>>//          Move (not(IsDateValid(dtVal))) to bInvalid //jjt-uncomment when working
12395>>>>>            End
12395>>>>>>
12395>>>>>            Else Begin
12396>>>>>                MoveTrapErr sValue to nVal // this may gen an error.
12397>>>>>                Move (Err) to bInvalid
12398>>>>>            End
12398>>>>>>
12398>>>>>            Move False to Err
12399>>>>>        End
12399>>>>>>
12399>>>>>        Function_Return bInvalid
12400>>>>>    End_Function
12401>>>>>    
12401>>>>>    // Return 1 if the passed DEO is part of the DDs list of connected DEOs
12401>>>>>    // First check if server of DEO is this DD. If so, we are owned. If not
12401>>>>>    // we must check the DD's UI DEO list.
12401>>>>>    // The passed object MUST be a valid DEO or an error will occur.
12401>>>>>    Function IsDEOOwned Integer iDEO Returns Integer
12403>>>>>        Integer iMax iCount
12403>>>>>        // if DEOs server is same as current DD it is owned. This is the
12403>>>>>        // fast check
12403>>>>>        If (Server(iDEO)=Self) ;            Function_Return 1
12406>>>>>        // else see if the DEO is in the DD's DEO list
12406>>>>>        Get Data_Set_User_Interface_Count to iMax
12407>>>>>        Decrement iMax
12408>>>>>        For iCount from 0 to iMax
12414>>>>>>
12414>>>>>            If (Data_Set_User_Interface(Self,iCount)=iDEO) ;                Function_Return 1
12417>>>>>        Loop
12418>>>>>>
12418>>>>>        Function_Return 0
12419>>>>>    End_Function
12420>>>>>    
12420>>>>>    // This procedure changes the field value of the given field in the
12420>>>>>    // record-buffer object.
12420>>>>>    // It also sends Field_Value_Changed to notify every the attached DEOs.
12420>>>>>    // This has been optimized so this message is only sent when data is
12420>>>>>    // actually changed.
12420>>>>>    Procedure Set Field_Current_Value Integer iField String sValue
12422>>>>>        Integer iObj
12422>>>>>        String sOldVal
12422>>>>>        Integer iChanged
12422>>>>>        Integer iType
12422>>>>>        Integer iFile
12422>>>>>        Integer iFocObj
12422>>>>>        Integer iCrnt
12422>>>>>        Integer bInvalid
12422>>>>>        Integer iIdentity
12422>>>>>        Address pData
12422>>>>>        Integer iLen
12422>>>>>        
12422>>>>>        Get Main_File to iFile
12423>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12426>>>>>        
12426>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12426>>>>>        // that you will use the underlying fields instead
12426>>>>>        If (iType = DF_OVERLAP) Begin
12428>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12429>>>>>            Procedure_Return
12430>>>>>        End
12430>>>>>>
12430>>>>>        
12430>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
12432>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
12433>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
12434>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
12435>>>>>            // will gen error if ext. field does not exist
12435>>>>>            Set Field_Current_Pointer_Value iField iLen to pData
12436>>>>>            Procedure_Return
12437>>>>>        End
12437>>>>>>
12437>>>>>        
12437>>>>>        
12437>>>>>        // If date or number, force conversion so any error is detected before
12437>>>>>        // the buffer is updated. We don't want the record buffer to contain
12437>>>>>        // invalid data
12437>>>>>        Get IsDataInvalid iType sValue to bInvalid
12438>>>>>        If bInvalid ;         // If an error occurred we have            Procedure_Return  // a bad number or a bad date. Do no more!
12441>>>>>        
12441>>>>>        Move (Record_Buffer(Self)) to iObj
12442>>>>>        Get Value of iObj iField to sOldVal
12443>>>>>        
12443>>>>>        Set Value of iObj iField to sValue
12444>>>>>        
12444>>>>>        // Augmented to handle non DF databases JJT
12444>>>>>        // Some tables may use some field other then recnum for their record identity.
12444>>>>>        // This will be dfrecnum or some other numeric field. When this happens the DD have
12444>>>>>        // to field buffers for the same value. When an update occurs from the DD to the DB buffer
12444>>>>>        // an update can occur twice. If the values are the same, this does not matter. Else the highest
12444>>>>>        // field value will get the update (not recnum). So if someone changes recnum but not its real field
12444>>>>>        // finding may not work right. The DD is updated when a record is found and the API keeps the two values
12444>>>>>        // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
12444>>>>>        // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
12444>>>>>        // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
12444>>>>>        //
12444>>>>>        // if field is recnum and record identity is not 0, we must also update the other field.
12444>>>>>        If (iField=0) Begin
12446>>>>>            Get_Attribute DF_FILE_RECORD_IDENTITY of iFile to iIdentity
12449>>>>>            If (iIdentity>0) ;                Set Value of iObj iIdentity to sValue
12452>>>>>        End
12452>>>>>>
12452>>>>>        
12452>>>>>        // When data-sets are working they should not update the
12452>>>>>        // DEOs.
12452>>>>>        
12452>>>>>        // prior to vdf7, we stopped all operation modes of non-zero. We now allow
12452>>>>>        // validates to pass through and we have a new operation mode for this. This
12452>>>>>        // should be ok, since we already allowed navigation validation through - we just
12452>>>>>        // stopped request_validate validations.
12452>>>>>        If (Operation_Mode=0 or Operation_Mode=MODE_VALIDATING) Begin
12454>>>>>            If (iType=DF_BCD) ;                Move (Number(sValue)<>Number(sOldVal)) to iChanged
12457>>>>>            Else If (iType=DF_DATE) ;                Move (Date(sValue)<>Date(sOldVal)) to iChanged
12461>>>>>            Else If (iType=DF_DATETIME) ;                Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to iChanged
12465>>>>>            Else ;                Move (sValue<>sOldVal) to iChanged
12467>>>>>            // if changed, notify all DEOs of this change
12467>>>>>            If iChanged ;                Send Field_Value_Changed iField sValue
12470>>>>>            Else Begin
12471>>>>>                // If here the set value did not change the contents of the DD.
12471>>>>>                // However, it is possible that the current focus DEO may contain
12471>>>>>                // a different value than the one we are setting. In such a case
12471>>>>>                // we must re-synchronize the DEO. Only the one DEO can be affected
12471>>>>>                // because it is the current focus deo/item that can contain a value
12471>>>>>                // that is not yet updated in the DD. This fixes a bug where the
12471>>>>>                // iexit was setting a value which was different from what was in
12471>>>>>                // the DEO but was the same as the old DD value (iExit is called
12471>>>>>                // before the DD is re-synched with the DEO). This could happen
12471>>>>>                // also by sending this message directly with a different value in
12471>>>>>                // the DEO focus item.
12471>>>>>                Get Focus of Desktop to iFocObj
12472>>>>>                // similar logic to Get Field_Current_Value. We check that the DEO
12472>>>>>                // is extended, that entry_refresh is not disabled and that the
12472>>>>>                // DEO's server is this DD.
12472>>>>>                If ( Extended_DEO_State(iFocObj) and ;                    (Entry_Refresh_State(iFocObj)=0)) Begin
12474>>>>>                    Get Current_item of iFocObj to iCrnt
12475>>>>>                    // If Focus DEO has same file and field and it is not checkbox
12475>>>>>                    // we must set its value. Set local value directly sets the value
12475>>>>>                    // in the DEO item. If we used value we'd get recursion!
12475>>>>>                    If ( Data_File(iFocObj,iCrnt)=iFile and ;                        Data_Field(iFocObj,iCrnt)=iField and ;                        IsDEOOwned(Self,iFocObj) and ;                        Checkbox_item_State(iFocObj,iCrnt)=0 ) ;                        Send File_Field_Value_Changed to iFocObj iFile iField sValue True
12478>>>>>                    //Set Local_Value of iFocObj iCrnt to sValue
12478>>>>>                End
12478>>>>>>
12478>>>>>            End
12478>>>>>>
12478>>>>>        End
12478>>>>>>
12478>>>>>    End_Procedure
12479>>>>>    
12479>>>>>    // Sets Field_Current_Value and Sets Field_Changed_State for passed field.
12479>>>>>    Procedure Set Field_Changed_Value Integer iField String sValue
12481>>>>>        Set Field_Changed_State iField to True
12482>>>>>        Set Field_Current_Value iField to sValue
12483>>>>>    End_Procedure
12484>>>>>    
12484>>>>>    
12484>>>>>    // This should only be set by a DEO that is changing a NoPut value. This should only happen when NoEnter=F
12484>>>>>    // for indexed findable noput deos. With foreign-field noputs we may store the value and update them
12484>>>>>    // for finds but we don't want them for saves. The cDDBuffer class handles this but it needs to
12484>>>>>    // know if this was a DEO NoPut update. DDOs have always allowed you to directly update foreign NoPut
12484>>>>>    // fields when the change did not come from a DEO.
12484>>>>>    Procedure Set Field_NoPutValueChangedByDeo Integer iField Boolean bChange
12486>>>>>        Set Item_ChangedByDeo of Record_Buffer iField to bChange
12487>>>>>    End_Procedure
12488>>>>>    
12488>>>>>    Procedure Set File_Field_NoPutValueChangedByDeo Integer iFile Integer iField Boolean bChange
12490>>>>>        Integer iDSO
12490>>>>>        Get Data_set iFile to iDSO
12491>>>>>        If iDSO Begin
12493>>>>>            Set Field_NoPutValueChangedByDeo of iDSO iField to bChange
12494>>>>>        End
12494>>>>>>
12494>>>>>    End_Procedure
12495>>>>>    
12495>>>>>    // Returns the value from the record buffer for the field of which the
12495>>>>>    // fieldnumber has been passed.
12495>>>>>    // If the file/field requested is the focus file/field the use the DEO's
12495>>>>>    // value.
12495>>>>>    Function Field_Current_Value Integer iField Returns String
12497>>>>>        Integer iType
12497>>>>>        Integer iFile
12497>>>>>        String  sValue
12497>>>>>        Integer iFoc
12497>>>>>        Integer iCrnt
12497>>>>>        Integer iFldSize iVoid
12497>>>>>        UChar[] UCData
12498>>>>>        
12498>>>>>        Get Focus of desktop to iFoc
12499>>>>>        Get Main_File to iFile
12500>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12503>>>>>        
12503>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12503>>>>>        // that you will use the underlying fields instead
12503>>>>>        If (iType=DF_OVERLAP) Begin
12505>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12506>>>>>            Function_Return ''
12507>>>>>        End
12507>>>>>>
12507>>>>>        
12507>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if overlap, text or binary direct to pointer
12509>>>>>            Get Field_Current_UCAValue iField to UCData
12510>>>>>            
12510>>>>>            // we assume a string is passed here. If we return to a string the
12510>>>>>            // pointer message will convert this to a string. Check that max string
12510>>>>>            // length is not larger than Max_Argument_Size has been removed.
12510>>>>>            Move (SizeOfArray(UCData)) to iFldSize
12511>>>>>            Move (UCharArrayToString(UCData)) to sValue
12512>>>>>            // This function has always returned the value as a 0 delimited string.
12512>>>>>            // Therefore trim at first zero. This means that you should not use this method
12512>>>>>            // with Binary types as embedded zeros will cause a truncation.
12512>>>>>            Move (CString(sValue)) to sValue
12513>>>>>            Function_Return sValue
12514>>>>>        End
12514>>>>>>
12514>>>>>        
12514>>>>>        // This was extended to also make sure that the focus's server
12514>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12514>>>>>        // file/field being the right file/field but for a different view.
12514>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12514>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12514>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12514>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12514>>>>>        // DEO field, so the buffer is always correct.
12514>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12516>>>>>            Get Current_item of iFoc to iCrnt
12517>>>>>            If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;                IsDEOOwned(Self,iFoc) and ;                (Checkbox_item_State(iFoc,iCrnt)=0) ) Begin
12519>>>>>                Get Data_Value of iFoc iCrnt to sValue
12520>>>>>            End
12520>>>>>>
12520>>>>>            Else Begin
12521>>>>>                Get Value of (Record_Buffer(Self)) iField to sValue
12522>>>>>            End
12522>>>>>>
12522>>>>>        End
12522>>>>>>
12522>>>>>        Else Begin
12523>>>>>            Get Value of (Record_Buffer(Self)) iField to sValue
12524>>>>>        End
12524>>>>>>
12524>>>>>        
12524>>>>>        // cast value to the proper datatype
12524>>>>>        If (iType=DF_BCD) Begin
12526>>>>>            Function_Return (Number(sValue))
12527>>>>>        End
12527>>>>>>
12527>>>>>        Else If (iType=DF_DATE) Begin
12530>>>>>            Function_Return (Date(sValue))
12531>>>>>        End
12531>>>>>>
12531>>>>>        Else If (iType=DF_DATETIME) Begin
12534>>>>>            Function_Return (Cast(sValue,DateTime))
12535>>>>>        End
12535>>>>>>
12535>>>>>        // else return as string
12535>>>>>        Function_Return sValue
12536>>>>>    End_Function
12537>>>>>    
12537>>>>>    // This sets a default value without setting the DSO's changed_State
12537>>>>>    Procedure Set Field_Default_Value Integer iField String sValue
12539>>>>>        Integer iOldState
12539>>>>>        Get Change_disabled_State to iOldState
12540>>>>>        Set Change_disabled_State to True
12541>>>>>        Set Field_Changed_Value iField to sValue
12542>>>>>        Set Change_disabled_State to iOldState
12543>>>>>    End_Procedure
12544>>>>>    
12544>>>>>    Procedure Set File_Field_default_Value Integer iFile Integer iField String sValue
12546>>>>>        Integer iDSO
12546>>>>>        Get Data_set iFile to iDSO
12547>>>>>        If iDSO ;            Set Field_default_Value of iDSO iField to sValue
12550>>>>>    End_Procedure
12551>>>>>    
12551>>>>>    // Methods to set and get the value of a field. When set all DSOs and
12551>>>>>    // DEOs are notified.
12551>>>>>    Procedure Set File_Field_Current_Value Integer iFile Integer iField String sValue
12553>>>>>        Integer iDSO
12553>>>>>        Get Data_set iFile to iDSO
12554>>>>>        If iDSO ;            Set Field_Current_Value of iDSO iField to sValue
12557>>>>>    End_Procedure
12558>>>>>    
12558>>>>>    Procedure Set File_Field_Changed_Value Integer iFile Integer iField String sValue
12560>>>>>        Integer iDSO
12560>>>>>        Get Data_set iFile to iDSO
12561>>>>>        If iDSO ;            Set Field_Changed_Value of iDSO iField to sValue
12564>>>>>    End_Procedure
12565>>>>>    
12565>>>>>    Function File_Field_Current_Value Integer iFile Integer iField Returns String
12567>>>>>        Integer iDSO
12567>>>>>        String sValue
12567>>>>>        Get Data_set iFile to iDSO
12568>>>>>        If iDSO ;            Get Field_Current_Value of iDSO iField to sValue
12571>>>>>        Function_Return sValue
12572>>>>>    End_Function
12573>>>>>    
12573>>>>>    // This procedure will notify every attached DEO that the value of a
12573>>>>>    // field has been changed. Every DEO needs to update its value to reflect
12573>>>>>    // the new value.
12573>>>>>    Procedure Field_Value_Changed Integer iField String sValue
12575>>>>>        Integer iMax
12575>>>>>        Integer iCount
12575>>>>>        Integer iDEO
12575>>>>>        Integer iMain_File
12575>>>>>        Integer iNoChange
12575>>>>>        Get Change_Disabled_State to iNoChange
12576>>>>>        Get Main_File to iMain_File
12577>>>>>        Get Data_Set_User_Interface_Count to iMax
12578>>>>>        Decrement iMax
12579>>>>>        For iCount from 0 to iMax
12585>>>>>>
12585>>>>>            Get Data_Set_User_Interface iCount to iDEO
12586>>>>>            If (Extended_DEO_State(iDEO) ) Begin
12588>>>>>                Send File_Field_Value_Changed to iDEO iMain_File iField sValue iNoChange
12589>>>>>            End
12589>>>>>>
12589>>>>>        Loop
12590>>>>>>
12590>>>>>    End_Procedure
12591>>>>>    
12591>>>>>    // Gets/Sets Field_Changed_State of the passed field. Will Set Changed_
12591>>>>>    // state if appropriate (if change_disabled_state is false)
12591>>>>>    Function Field_Changed_State Integer iField Returns Integer
12593>>>>>        Function_Return ;            (Item_Changed_State(Record_Buffer(Self), iField))
12594>>>>>    End_Function
12595>>>>>    
12595>>>>>    
12595>>>>>    // Handle NoPut here. If the field is noput set the field_changed_State but do not set the
12595>>>>>    // DD's changed_state. As of 17.0, we changed the rule so that noput DEOs always update the DD.
12595>>>>>    // They set the field_Current_value and they set the field_changed_state. If noput they will
12595>>>>>    // not set changed_state. This now makes windows and web consistent.
12595>>>>>    Procedure Set Field_Changed_State Integer iField Integer iState
12597>>>>>        Boolean bNoPut bOldSt bIsCommitted
12597>>>>>        
12597>>>>>        Get Field_Option iField DD_NOPUT to bNoPut
12598>>>>>        If not bNoPut Begin // if not noput, see if this is a committed and therefore noput
12600>>>>>            Get IsCommitted to bIsCommitted
12601>>>>>            If bIsCommitted Begin
12603>>>>>                Get IsFieldCommitted iField to bNoPut
12604>>>>>            End
12604>>>>>>
12604>>>>>        End
12604>>>>>>
12604>>>>>        
12604>>>>>        If bNoPut Begin
12606>>>>>            Get Change_disabled_State to bOldSt
12607>>>>>            Set Change_disabled_State to True
12608>>>>>        End
12608>>>>>>
12608>>>>>        
12608>>>>>        Set Item_Changed_State of (Record_Buffer(Self)) iField to iState
12609>>>>>        // the cDDBuffer class item_changed_state does not attempt to set
12609>>>>>        // changed_state, so we do it here. This will allow for future
12609>>>>>        // greater flexibilities.
12609>>>>>        If (iState) Begin
12611>>>>>            Set Changed_State of (Record_Buffer(Self)) to True
12612>>>>>        End
12612>>>>>>
12612>>>>>        If bNoPut Begin
12614>>>>>            Set Change_disabled_State to bOldSt
12615>>>>>        End
12615>>>>>>
12615>>>>>        
12615>>>>>    End_Procedure
12616>>>>>    
12616>>>>>    // As above, but passes both file and field
12616>>>>>    Function File_Field_Changed_State Integer iFile Integer iField Returns Integer
12618>>>>>        Integer iDSO
12618>>>>>        Get Data_Set iFile to iDSO
12619>>>>>        If iDSO ;            Function_Return (Field_Changed_State(iDSO, iField))
12622>>>>>    End_Function
12623>>>>>    
12623>>>>>    Procedure Set File_Field_Changed_State Integer iFile Integer iField Integer iState
12625>>>>>        Integer iDSO
12625>>>>>        Get Data_Set iFile to iDSO
12626>>>>>        If iDSO ;            Set Field_Changed_State of iDSO iField to iState
12629>>>>>    End_Procedure
12630>>>>>    
12630>>>>>    // This simulates entering a value into a field from a keyboard. Pass the
12630>>>>>    // Field and DD Options and the value. It is up to you to pass the proper
12630>>>>>    // DD options. This is normally sent by File_Field_Entry and you are
12630>>>>>    // advised to use that message and not this one.
12630>>>>>    Procedure Set Field_Entry Integer iField Integer iOpts Integer bShowErr String sValue
12632>>>>>        Integer iFile
12632>>>>>        Integer iType
12632>>>>>        Integer bChanged
12632>>>>>        Integer bInvalid
12632>>>>>        Integer hObj
12632>>>>>        String sOldVal
12632>>>>>        Address pData
12632>>>>>        Integer iLen
12632>>>>>        
12632>>>>>        Get Main_File to iFile
12633>>>>>        
12633>>>>>        // if No-enter or Displayonly, this shouldn't be changed. We will
12633>>>>>        // let NoPut through, since a user might need it for finding.
12633>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
12636>>>>>        
12636>>>>>        // Force a caplsock if required
12636>>>>>        If (iOpts iand DD_CAPSLOCK) ;            Move (Uppercase(sValue)) to sValue
12639>>>>>        
12639>>>>>        // If date or number, force conversion so any error is detected before
12639>>>>>        // the buffer is updated. We don't want the record buffer to contain
12639>>>>>        // invalid data
12639>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12642>>>>>        
12642>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12642>>>>>        // that you will use the underlying fields instead
12642>>>>>        If (iType = DF_OVERLAP) Begin
12644>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12645>>>>>            Procedure_Return
12646>>>>>        End
12646>>>>>>
12646>>>>>        
12646>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
12648>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
12649>>>>>            Move (SizeOfString(sValue)) to iLen // length to copy
12650>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
12651>>>>>            // will gen error if ext. field does not exist
12651>>>>>            Set Field_Pointer_Entry iField iOpts iLen bShowErr to pData
12652>>>>>            Procedure_Return
12653>>>>>        End
12653>>>>>>
12653>>>>>        
12653>>>>>        Get IsDataInvalid iType sValue to bInvalid
12654>>>>>        If bInvalid Begin     // If an error occurred we have
12656>>>>>            If bShowErr ;                Send Data_set_error iField (If(iType=DF_DATE or iType=DF_DATETIME, DFERR_ENTER_VALID_DATE, DFERR_BAD_ENTRY)) ;                (" ("-sValue-")")
12659>>>>>            Procedure_Return  // a bad number or a bad date. Do no more!
12660>>>>>        End
12660>>>>>>
12660>>>>>        // update the value only if the value is changed.
12660>>>>>        Move (Record_Buffer(Self)) to hObj
12661>>>>>        Get Value of hObj iField to sOldVal
12662>>>>>        If (iType=DF_BCD) ;            Move (Number(sValue)<>Number(sOldVal)) to bChanged
12665>>>>>        Else If (iType=DF_DATE) ;            Move (Date(sValue)<>Date(sOldVal)) to bChanged
12669>>>>>        Else If (iType=DF_DATETIME) ;            Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to bChanged
12673>>>>>        Else ;            Move (sValue<>sOldVal) to bChanged
12675>>>>>        
12675>>>>>        // if changed or force put, update the value.
12675>>>>>        If ( bChanged or (iOpts iand DD_FORCEPUT) ) ;            Set Field_Current_Value iField to sValue
12678>>>>>        
12678>>>>>        // Set changed state if changed. This is an improvement on DEOs which would set changed-state for
12678>>>>>        // a no-put. Set Field_Changed_State will not set Changed_state if it is noput
12678>>>>>        If ( bChanged) Begin
12680>>>>>            Set Field_Changed_State iField to True
12681>>>>>            // if noput (but not noenter) we must tell the DDO that this should not be
12681>>>>>            // updated during a save.
12681>>>>>            If (iOpts iand DD_NOPUT) Begin
12683>>>>>                Set Field_NoPutValueChangedByDeo iField to True
12684>>>>>            End
12684>>>>>>
12684>>>>>        End
12684>>>>>>
12684>>>>>        
12684>>>>>        // perform autofinds if needed. Note that required checking will occur as
12684>>>>>        // part of validation.
12684>>>>>        // We will only autofind if the field value is changed. This is consistent with
12684>>>>>        // DEOs which do not autofind on unchanged values. This provides optimizations
12684>>>>>        // when a parent record is already loaded.
12684>>>>>        If (bChanged or Field_Changed_state(Self,iField)) Begin
12686>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
12686>>>>>            // testing is important and make sure we test for exact bit match. Must first
12686>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
12686>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Send File_Field_AutoFind iFile iField GE
12689>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) ;                Send File_Field_AutoFind iFile iField EQ
12693>>>>>        End
12693>>>>>>
12693>>>>>        
12693>>>>>    End_Procedure
12694>>>>>    
12694>>>>>    // This returns file-field options for a Field_Entry type of environment.
12694>>>>>    // It will strip autofind from main-file DDs but leave foreign field alone.
12694>>>>>    // This is needed for Field_entry. Otherwise adding a field value to an autofind
12694>>>>>    // for save or find causes an autofind to trigger first which either causes the
12694>>>>>    // wrong rec to save or for a double find.
12694>>>>>    Function File_Field_Entry_Options Integer iFile Integer iField Returns Integer
12696>>>>>        Integer iOpts
12696>>>>>        // this will get the appropriate field and foreign field opts
12696>>>>>        Get File_Field_Options iFile iField to iOpts
12697>>>>>        // If the main file (not foreign) we will strip autofind. Autofind should not
12697>>>>>        // be an automatic part of main file entry while it should with foreign fields.
12697>>>>>        If (iFile=Main_File(Self)) Begin
12699>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
12699>>>>>            // testing is important and make sure we test for exact bit match. Must first
12699>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
12699>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Move (iOpts - DD_AUTOFIND_GE) to iOpts
12702>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND)  ;                Move (iOpts - DD_AUTOFIND)    to iOpts
12706>>>>>        End
12706>>>>>>
12706>>>>>        Function_Return iOpts
12707>>>>>    End_Function
12708>>>>>    
12708>>>>>    // This simulates entering a value into a field from a keyboard. The DD
12708>>>>>    // receiving this message determines if it is Main or Foreign (just like
12708>>>>>    // server). It will do an uppercase, will respect No_Enter and DisplayOnly
12708>>>>>    // and will do a autofind if required. It does not do a field validation.
12708>>>>>    Procedure Set File_Field_Entry Integer iFile Integer iField Integer bShowErr String sValue
12710>>>>>        Integer iOpts
12710>>>>>        Integer hDD
12710>>>>>        Get Data_Set iFile to hDD
12711>>>>>        If hDD Begin
12713>>>>>            // this will get the appropriate field and foreign field opts
12713>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
12714>>>>>            Set Field_Entry of hDD iField iOpts bShowErr to sValue
12715>>>>>        End
12715>>>>>>
12715>>>>>    End_Procedure
12716>>>>>    
12716>>>>>    // return object ID of extended field, 0 if none
12716>>>>>    Function Field_Object Integer iField Returns Integer
12718>>>>>        Integer hoFlds hoField
12718>>>>>        Boolean bAutoAssign
12718>>>>>        Get Field_Objects to hoFlds
12719>>>>>        If hoFlds Begin
12721>>>>>            Get Field_Object of hoFlds iField to hoField
12722>>>>>        End
12722>>>>>>
12722>>>>>        If not hoField Begin
12724>>>>>            Send DefineExtendedField iField // will create field_objects and Field_Object as needed
12725>>>>>            Get Field_Objects to hoFlds
12726>>>>>            Get Field_Object of hoFlds iField to hoField
12727>>>>>        End
12727>>>>>>
12727>>>>>        Function_Return hoField
12728>>>>>    End_Function
12729>>>>>    
12729>>>>>    // This is the same as Field_entry except the value is passed via a
12729>>>>>    // pointer. If data-type is extended (text/binary) it will use and an
12729>>>>>    // extended field object to handle this. If date/number/string we will
12729>>>>>    // convert this to a string and use Field_Entry. It is the caller's
12729>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
12729>>>>>    // If an extended Field object is needed and not defined, an error is
12729>>>>>    // returned. If pointer is null, assume empty string passed (this is a
12729>>>>>    // change as of 8.3 - it used to ignore null pointers)
12729>>>>>    Procedure Set Field_Pointer_Entry Integer iField Integer iOpts Integer iLen Integer bShowErr Address pData
12731>>>>>        Integer hFld
12731>>>>>        String  sValue
12731>>>>>        Integer iFile
12731>>>>>        Integer iType
12731>>>>>        
12731>>>>>        Get Main_file to iFile
12732>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12735>>>>>        
12735>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12735>>>>>        // that you will use the underlying fields instead
12735>>>>>        If (iType = DF_OVERLAP) ;            Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_OVERLAP_ERROR
12738>>>>>        Else If (iType=DF_TEXT or iType=DF_BINARY) Begin
12741>>>>>            Get Field_Object iField to hFld // the object that handles this large text
12742>>>>>            If hFld ;                Set Field_pEntry of hFld iOpts iLen bShowErr to pData
12745>>>>>            Else ;                Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_FIELD_NOT_DEFINED
12747>>>>>        End
12747>>>>>>
12747>>>>>        Else Begin
12748>>>>>            // if number,date or string convert the pointer data to
12748>>>>>            // string data and do a normal entry with it.
12748>>>>>            Move (PointerToString(pData)) to sValue
12749>>>>>            Set Field_Entry iField iOpts bShowErr to sValue
12750>>>>>        End
12750>>>>>>
12750>>>>>    End_Procedure
12751>>>>>    
12751>>>>>    // This is the same as File_Field_entry except the value is passed via a
12751>>>>>    // pointer. See Field_Pointer_Entry for more on this
12751>>>>>    Procedure Set File_Field_Pointer_Entry Integer iFile Integer iField Integer iLen Integer bShowErr Address pData
12753>>>>>        Integer iOpts
12753>>>>>        Integer hDD
12753>>>>>        Get Data_Set iFile to hDD
12754>>>>>        If hDD Begin
12756>>>>>            // this will get the appropriate field and foreign field opts
12756>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
12757>>>>>            Set Field_Pointer_Entry of hDD iField iOpts iLen bShowErr to pData
12758>>>>>        End
12758>>>>>>
12758>>>>>    End_Procedure
12759>>>>>    
12759>>>>>    // This is the same as Field_Current_Value except the value is passed via
12759>>>>>    // a pointer. If data-type is extended (text/binary) it will use and an
12759>>>>>    // extended field object to handle this. If date/number/string we will
12759>>>>>    // convert this to a string and use Field_Entry. It is the caller's
12759>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
12759>>>>>    // If an extended Field object is needed and not defined, an error is
12759>>>>>    // returned. If pointer is null, assume empty string passed (this is a
12759>>>>>    // change as of 8.3 - it used to ignore null pointers)
12759>>>>>    Procedure Set Field_Current_Pointer_Value Integer iField Integer iLen Address pData
12761>>>>>        Integer hFld
12761>>>>>        String  sValue
12761>>>>>        Integer iFile iType iCrnt
12761>>>>>        Handle iFocObj
12761>>>>>        Boolean bChanged
12761>>>>>        
12761>>>>>        Get Main_file to iFile
12762>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12765>>>>>        
12765>>>>>        // Overlap fields are not supported directly in DDs. It is expected
12765>>>>>        // that you will use the underlying fields instead
12765>>>>>        If (iType = DF_OVERLAP) Begin
12767>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
12768>>>>>            Procedure_Return
12769>>>>>        End
12769>>>>>>
12769>>>>>        
12769>>>>>        If (iType<>DF_TEXT and iType<>DF_BINARY) Begin
12771>>>>>            // if number,date or string convert the pointer data to
12771>>>>>            // string data and do a normal entry with it.
12771>>>>>            Move (PointerToString(pData)) to sValue  // create string from pointer data
12772>>>>>            Set Field_Current_Value iField to sValue
12773>>>>>            Procedure_Return
12774>>>>>        End
12774>>>>>>
12774>>>>>        
12774>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12775>>>>>        If not hFld Begin
12777>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12778>>>>>            Procedure_Return
12779>>>>>        End
12779>>>>>>
12779>>>>>        
12779>>>>>        Get Is_pValueChanged of hFld iLen pData to bChanged
12780>>>>>        If bChanged Begin
12782>>>>>            Set Field_pValue of hFld iLen to pData
12783>>>>>            Send Field_Pointer_Value_Changed iField pData
12784>>>>>        End
12784>>>>>>
12784>>>>>        Else Begin
12785>>>>>            // If here the set value did not change the contents of the DD.
12785>>>>>            // However, it is possible that the current focus DEO may contain
12785>>>>>            // a different value than the one we are setting. In such a case
12785>>>>>            // we must re-synchronize the DEO. Only the one DEO can be affected
12785>>>>>            // because it is the current focus deo/item that can contain a value
12785>>>>>            // that is not yet updated in the DD. This fixes a bug where the
12785>>>>>            // iexit was setting a value which was different from what was in
12785>>>>>            // the DEO but was the same as the old DD value (iExit is called
12785>>>>>            // before the DD is re-synched with the DEO). This could happen
12785>>>>>            // also by sending this message directly with a different value in
12785>>>>>            // the DEO focus item.
12785>>>>>            Get Focus of Desktop to iFocObj
12786>>>>>            // similar logic to Get Field_Pointer_Current_Value. We check that the DEO
12786>>>>>            // is extended, that entry_refresh is not disabled and that the
12786>>>>>            // DEO's server is this DD.
12786>>>>>            If ( Extended_DEO_State(iFocObj) and (Entry_Refresh_State(iFocObj)=0)) Begin
12788>>>>>                // If Focus DEO has same file and field and it is not checkbox
12788>>>>>                // we must set its value. Set local value directly sets the value
12788>>>>>                // in the DEO item. If we used value we'd get recursion!
12788>>>>>                Get Current_item of iFocObj to iCrnt
12789>>>>>                If ( Data_File(iFocObj,iCrnt)=iFile and ;                    Data_Field(iFocObj,iCrnt)=iField and ;                    IsDEOOwned(Self,iFocObj) ) Begin
12791>>>>>                    Send File_Field_Pointer_Value_Changed to iFocObj iFile iField pData True
12792>>>>>                End
12792>>>>>>
12792>>>>>            End
12792>>>>>>
12792>>>>>        End
12792>>>>>>
12792>>>>>    End_Procedure
12793>>>>>    
12793>>>>>    // This is never called but it needed for the compiler. Required for apps DDs that don't compile in a DEO interface
12793>>>>>    Procedure File_Field_Pointer_Value_Changed Integer iFile Integer iField Address pValue Integer iChangeDisabled
12795>>>>>    End_Procedure
12796>>>>>    
12796>>>>>    Procedure Field_Pointer_Value_Changed Integer iField Address pValue
12798>>>>>        Integer iMax
12798>>>>>        Integer iCount
12798>>>>>        Integer iDEO
12798>>>>>        Integer iMain_File
12798>>>>>        Integer iNoChange
12798>>>>>        Get Change_Disabled_State to iNoChange
12799>>>>>        Get Main_File to iMain_File
12800>>>>>        Get Data_Set_User_Interface_Count to iMax
12801>>>>>        Decrement iMax
12802>>>>>        For iCount from 0 to iMax
12808>>>>>>
12808>>>>>            Get Data_Set_User_Interface iCount to iDEO
12809>>>>>            If (Extended_DEO_State(iDEO) ) Begin
12811>>>>>                Send File_Field_Pointer_Value_Changed to iDEO iMain_File iField pValue iNoChange
12812>>>>>            End
12812>>>>>>
12812>>>>>        Loop
12813>>>>>>
12813>>>>>    End_Procedure
12814>>>>>    
12814>>>>>    // This is the same as File_Field_Current_Value except the value is passed
12814>>>>>    // via a pointer. See Field_current_Pointer_Value for more on this
12814>>>>>    Procedure Set File_Field_Current_Pointer_Value Integer iFile Integer iField Integer iLen Address pData
12816>>>>>        Integer hDD
12816>>>>>        Get Data_Set iFile to hDD
12817>>>>>        If hDD ;            Set Field_Current_Pointer_Value of hDD iField iLen to pData
12820>>>>>    End_Procedure
12821>>>>>    
12821>>>>>    // This returns the data pointer to the extended field. At this point
12821>>>>>    // this is the data. Be careful if you change the data, be even more
12821>>>>>    // careful if you change the pointer (don't do it!!!!)
12821>>>>>    Function Field_Current_Pointer_Value Integer iField Returns Address
12823>>>>>        Integer hFld
12823>>>>>        Handle iFoc
12823>>>>>        
12823>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12824>>>>>        If not hFld Begin
12826>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12827>>>>>            Function_Return 0
12828>>>>>        End
12828>>>>>>
12828>>>>>        
12828>>>>>        
12828>>>>>        // This was extended to also make sure that the focus's server
12828>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12828>>>>>        // file/field being the right file/field but for a different view.
12828>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12828>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12828>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12828>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12828>>>>>        // DEO field, so the buffer is always correct.
12828>>>>>        Get Focus of Desktop to iFoc
12829>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12831>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
12833>>>>>                Send Update_Focus_Field
12834>>>>>            End
12834>>>>>>
12834>>>>>        End
12834>>>>>>
12834>>>>>        
12834>>>>>        Function_Return (FieldPointer(hFld))
12835>>>>>    End_Function
12836>>>>>    
12836>>>>>    
12836>>>>>    Function Field_Current_UCAValue Integer iField Returns UChar[]
12838>>>>>        Integer hFld
12838>>>>>        Handle iFoc
12838>>>>>        UChar[] Data
12839>>>>>        
12839>>>>>        Get Field_Object iField to hFld // the object that handles this large text
12840>>>>>        If not hFld Begin
12842>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
12843>>>>>            Function_Return 0
12844>>>>>        End
12844>>>>>>
12844>>>>>        
12844>>>>>        
12844>>>>>        // This was extended to also make sure that the focus's server
12844>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
12844>>>>>        // file/field being the right file/field but for a different view.
12844>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
12844>>>>>        // ddos have the information they need from the deos. During a refresh we don't
12844>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
12844>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
12844>>>>>        // DEO field, so the buffer is always correct.
12844>>>>>        Get Focus of Desktop to iFoc
12845>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
12847>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
12849>>>>>                Send Update_Focus_Field
12850>>>>>            End
12850>>>>>>
12850>>>>>        End
12850>>>>>>
12850>>>>>        Get FieldArray of hFld to Data
12851>>>>>        Function_Return Data
12852>>>>>    End_Function
12853>>>>>    
12853>>>>>    Function File_Field_Current_Pointer_Value Integer iFile Integer iField Returns Address
12855>>>>>        Address pValue
12855>>>>>        Integer hDD
12855>>>>>        Get Data_Set iFile to hDD
12856>>>>>        If hDD Begin
12858>>>>>            Get Field_Current_Pointer_Value of hDD iField to pValue // return pointer to first byte of
12859>>>>>            Function_Return pValue                                  // data
12860>>>>>        End
12860>>>>>>
12860>>>>>    End_Function
12861>>>>>    
12861>>>>>    Procedure Set Field_Current_UCAValue Integer iField UChar[] Data
12863>>>>>        Set Field_Current_Pointer_Value iField (SizeOfArray(Data)) to (AddressOf(Data))
12864>>>>>    End_Procedure
12865>>>>>    
12865>>>>>    Procedure Set File_Field_Current_UCAValue Integer iFile Integer iField UChar[] Data
12867>>>>>        Integer hDD
12867>>>>>        Get Data_Set iFile to hDD
12868>>>>>        If hDD Begin
12870>>>>>            Set Field_Current_UCAValue of hDD iField to Data
12871>>>>>        End
12871>>>>>>
12871>>>>>    End_Procedure
12872>>>>>    
12872>>>>>    Function File_Field_Current_UCAValue Integer iFile Integer iField Returns UChar[]
12874>>>>>        UChar[] UCValue
12875>>>>>        Handle hDD
12875>>>>>        Get Data_Set iFile to hDD
12876>>>>>        If hDD Begin
12878>>>>>            Get Field_Current_UCAValue of hDD iField to UCValue // return pointer to first byte of
12879>>>>>            Function_Return UCValue                              // data
12880>>>>>        End
12880>>>>>>
12880>>>>>    End_Function
12881>>>>>    
12881>>>>>    // Create an extended field object for the passed field. .
12881>>>>>    // If field already exists, do nothing. This should only be used with
12881>>>>>    // text and binary fields.
12881>>>>>    Procedure DefineExtendedField Integer iField
12883>>>>>        Integer hFlds
12883>>>>>        Get Field_Objects to hFlds // this may not be created yet.
12884>>>>>        If not hFlds Begin         // if not created, create extended-fields wrapper
12886>>>>>            Object ExtendedFieldObjects is a FieldObjects
12888>>>>>                Move Self to hFlds
12889>>>>>            End_Object
12890>>>>>            Set Field_Objects to hFlds
12891>>>>>        End
12891>>>>>>
12891>>>>>        Send DefineFieldObject to hFlds iField
12892>>>>>    End_Procedure
12893>>>>>    
12893>>>>>    // create extended DD fields for all text and binary files
12893>>>>>    Procedure DefineAllExtendedFields
12895>>>>>        Integer iCount iType iField iFile
12895>>>>>        Get Main_file to iFile
12896>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iCount
12899>>>>>        For iField from 1 to iCount
12905>>>>>>
12905>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iType
12908>>>>>            If (iType=DF_TEXT or iType=DF_BINARY) ; // if text or binary                Send DefineExtendedField iField
12911>>>>>        Loop
12912>>>>>>
12912>>>>>    End_Procedure
12913>>>>>    
12913>>>>>    // Update Extended fields to FileBuffer.  DD-Fields ---> FileBuffer
12913>>>>>    // Private
12913>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
12915>>>>>        Integer hFlds
12915>>>>>        Get Field_Objects to hFlds
12916>>>>>        If hFlds ;            Send ExtendedFieldsUpdate to hFlds bSave
12919>>>>>    End_Procedure
12920>>>>>    
12920>>>>>    // Refresh Extended field from FileBuffer.  DD-Fields <--- FileBuffer
12920>>>>>    // Private
12920>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
12922>>>>>        Integer hFlds
12922>>>>>        Get Field_Objects to hFlds
12923>>>>>        If hFlds ;            Send ExtendedFieldsRefresh to hFlds bCleared
12926>>>>>    End_Procedure
12927>>>>>    
12927>>>>>    // This procedure can be used to set the Item_Options of a field. This can
12927>>>>>    // be passed any number of arguments.
12927>>>>>    // Support the following special first parameters:
12927>>>>>    //      DD_CLEAR_FIELD_OPTIONS     - clear all following passed otpions
12927>>>>>    //      DD_CLEAR_ALL_FIELD_OPTIONS - clear all options
12927>>>>>    Procedure Set Field_Options Integer iField Integer iArg1 // plus unknown arguments
12929>>>>>        Integer iObj
12929>>>>>        Integer iOptions
12929>>>>>        Integer iOption
12929>>>>>        Integer iArg
12929>>>>>        Integer iClear
12929>>>>>        Integer iType
12929>>>>>        Move (Record_Buffer(Self)) to iObj
12930>>>>>        Get Item_Options of iObj iField to iOptions
12931>>>>>        //
12931>>>>>        For iArg from 2 to Num_Arguments
12937>>>>>>
12937>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
12938>>>>>            
12938>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
12941>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
12945>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
12949>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
12951>>>>>        Loop
12952>>>>>>
12952>>>>>        //
12952>>>>>        //Get_Attribute DF_FIELD_TYPE of (Main_File(self)) iField to iType
12952>>>>>        //If (iType=DF_TEXT or iType=DF_BINARY) ;            // if text of binary
12952>>>>>        //    Move (iOptions iOR DD_DISPLAYONLY) to iOptions // make sure DO is set
12952>>>>>        
12952>>>>>        Set Item_Options of iObj iField to iOptions
12953>>>>>    End_Procedure
12954>>>>>    
12954>>>>>    // This function returns all the item_options which have been set for
12954>>>>>    // a field. The value from the Record_Buffer object will be binary or'ed
12954>>>>>    // with constand Default_Item_Options and the DD_AUTOCLEAR constants when
12954>>>>>    // the Autoclear_State of the field has been set.
12954>>>>>    // Keep in mind that Autoclear is *not* kept in the Item_Options
12954>>>>>    // property.
12954>>>>>    Function Field_Options Integer iField Returns Integer
12956>>>>>        Function_Return (Item_Options(Record_Buffer(Self), iField))
12957>>>>>    End_Function
12958>>>>>    
12958>>>>>    Function Field_Option Integer iField Integer iOption Returns Integer
12960>>>>>        Integer iOptions
12960>>>>>        Integer iState
12960>>>>>        Get Item_Options of (Record_Buffer(Self)) iField to iOptions
12961>>>>>        // All bits must match for it to be True (e.g., displayonly requires noput & noenter)
12961>>>>>        Move ((iOptions iand iOption)=iOption) to iState
12962>>>>>        Function_Return iState
12963>>>>>    End_Function
12964>>>>>    
12964>>>>>    
12964>>>>>    Procedure Set Foreign_Field_Options Integer iField Integer iArg1 // Integer iOption
12966>>>>>        Integer iObj
12966>>>>>        Integer iOptions
12966>>>>>        Integer iOption
12966>>>>>        Integer iArg
12966>>>>>        Integer iClear
12966>>>>>        
12966>>>>>        
12966>>>>>        Move (Record_Buffer(Self)) to iObj
12967>>>>>        Get Aux_Value of iObj iField to iOptions
12968>>>>>        //
12968>>>>>        For iArg from 2 to Num_Arguments
12974>>>>>>
12974>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
12975>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
12978>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
12982>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
12986>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
12988>>>>>        Loop
12989>>>>>>
12989>>>>>        //
12989>>>>>        Set Aux_Value of iObj iField to iOptions
12990>>>>>    End_Procedure
12991>>>>>    
12991>>>>>    Function Foreign_Field_Options Integer iField Returns Integer
12993>>>>>        Integer iOpts
12993>>>>>        Get ForeignFieldOptions of Record_Buffer iField to iOpts
12994>>>>>        Function_Return iOpts
12995>>>>>    End_Function
12996>>>>>    
12996>>>>>    Procedure Set Foreign_Field_Option Integer iField Integer iOption Integer bSet
12998>>>>>        If bSet Begin
13000>>>>>            Set Foreign_Field_Options iField to iOption
13001>>>>>        End
13001>>>>>>
13001>>>>>        Else Begin
13002>>>>>            Set Foreign_Field_Options iField to DD_CLEAR_FIELD_OPTIONS iOption
13003>>>>>        End
13003>>>>>>
13003>>>>>    End_Procedure
13004>>>>>    
13004>>>>>    Function Foreign_Field_Option Integer iField Integer iOption Returns Integer
13006>>>>>        Integer iOptions
13006>>>>>        Integer iState
13006>>>>>        Get Foreign_Field_Options iField to iOptions
13007>>>>>        Move ((iOptions iand iOption)=iOption) to iState
13008>>>>>        Function_Return iState
13009>>>>>    End_Function
13010>>>>>    
13010>>>>>    // This procedure is being used by DEOs when they need to copy the item-
13010>>>>>    // options from the Data_Set. When the filenumber being passed is not
13010>>>>>    // equal to the Main_File of this Data_Set, then the Foreign_Field_Options
13010>>>>>    // will be applied.
13010>>>>>    Function File_Field_Options Integer iFile Integer iField Returns Integer
13012>>>>>        Integer iDSO
13012>>>>>        Integer iMain_File
13012>>>>>        Integer iOpts
13012>>>>>        Integer iRB
13012>>>>>        Integer iType
13012>>>>>        Get Main_File to iMain_File
13013>>>>>        If (iFile <> iMain_File) ;            Get Data_Set iFile to iDSO
13016>>>>>        Else ;            Move Self to iDSO
13018>>>>>        If iDSO Begin
13020>>>>>            Get Field_Options of iDSO iField to iOpts
13021>>>>>            // we consider the item to be foreign if the DDO main file is different than the one
13021>>>>>            // passed and we do not allow foreign (parent) new records to be saved.
13021>>>>>            If (iFile<>iMain_File and Allow_Foreign_New_Save_State(iDSO)=0) ; // Add Foreign_Field_Options                Move (iOpts ior Foreign_Field_Options(iDSO, iField)) to iOpts
13024>>>>>            Function_Return iOpts
13025>>>>>        End
13025>>>>>>
13025>>>>>    End_Function
13026>>>>>    
13026>>>>>    
13026>>>>>    // Procedure to set the message to be sent on item entry.
13026>>>>>    Procedure Set Field_Entry_msg Integer iField Integer iMsg
13028>>>>>        Set Item_Entry_MSG of (Record_Buffer(Self)) iField to iMsg
13029>>>>>    End_Procedure
13030>>>>>    
13030>>>>>    // Function to return the message to be sent on item entry.
13030>>>>>    Function Field_Entry_msg Integer iField Returns Integer
13032>>>>>        Function_Return (Item_Entry_MSG(Record_Buffer(Self), iField))
13033>>>>>    End_Function
13034>>>>>    
13034>>>>>    
13034>>>>>    // Procedure to send the message to be sent on item exit.
13034>>>>>    Procedure Set Field_Exit_msg Integer iField Integer iMsg
13036>>>>>        Set Item_Exit_MSG of (Record_Buffer(Self)) iField to iMsg
13037>>>>>    End_Procedure
13038>>>>>    
13038>>>>>    // Function to return the message to be set on item exit.
13038>>>>>    Function Field_Exit_msg Integer iField Returns Integer
13040>>>>>        Function_Return (Item_Exit_MSG(Record_Buffer(Self), iField))
13041>>>>>    End_Function
13042>>>>>    
13042>>>>>    // Procedure to set the message to be sent on item validation.
13042>>>>>    Procedure Set Field_Validate_msg Integer iField Integer iMsg
13044>>>>>        Set Item_Validate_MSG of (Record_Buffer(Self)) iField to iMsg
13045>>>>>    End_Procedure
13046>>>>>    
13046>>>>>    // Function to return the message to be set on item validation.
13046>>>>>    Function Field_Validate_msg Integer iField Returns Integer
13048>>>>>        Function_Return (Item_Validate_MSG(Record_Buffer(Self), iField))
13049>>>>>    End_Function
13050>>>>>    
13050>>>>>    
13050>>>>>    // Used to Get/Set the Prompt_Object for a Field.
13050>>>>>    Procedure Set Field_Prompt_Object Integer iField Integer iObj
13052>>>>>        Set Prompt_Object of (Record_Buffer(Self)) iField to iObj
13053>>>>>    End_Procedure
13054>>>>>    
13054>>>>>    Function Field_Prompt_Object Integer iField Returns Integer
13056>>>>>        Integer iObj
13056>>>>>        Get Prompt_Object of (Record_Buffer(Self)) iField to iObj
13057>>>>>        If (iObj = 0) ;            Get Prompt_Object of (Field_Attributes(Self)) iField to iObj
13060>>>>>        Function_Return iObj
13061>>>>>    End_Function
13062>>>>>    
13062>>>>>    Procedure Set Field_Zoom_Object Integer iField Integer iObj
13064>>>>>        Set Zoom_Object of (Record_Buffer(Self)) iField to iObj
13065>>>>>    End_Procedure
13066>>>>>    
13066>>>>>    Function Field_Zoom_Object Integer iField Returns Integer
13068>>>>>        Function_Return (Zoom_Object(Record_Buffer(Self), iField))
13069>>>>>    End_Function
13070>>>>>    
13070>>>>>    
13070>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoObj
13072>>>>>        Set Field_WebPrompt_Object of FieldMask_Array iField to hoObj
13073>>>>>    End_Procedure
13074>>>>>    
13074>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
13076>>>>>        Handle hoPrompt
13076>>>>>        Get Field_WebPrompt_Object of FieldMask_Array iField to hoPrompt
13077>>>>>        Function_Return hoPrompt
13078>>>>>    End_Function
13079>>>>>    
13079>>>>>    
13079>>>>>    // Used to Get/Set the Prompt_Object for a Field.
13079>>>>>    Function File_Field_Prompt_Object Integer iFile Integer iField Returns Integer
13081>>>>>        Integer iObj
13081>>>>>        Get File_Field_Property iFile iField GET_Field_Prompt_Object to iObj
13082>>>>>        Function_Return iObj
13083>>>>>    End_Function
13084>>>>>    
13084>>>>>    Function File_Field_Zoom_Object Integer iFile Integer iField Returns Integer
13086>>>>>        Integer iObj
13086>>>>>        Get File_Field_Property iFile iField GET_Field_Zoom_Object to iObj
13087>>>>>        Function_Return iObj
13088>>>>>    End_Function
13089>>>>>    
13089>>>>>    Function File_Field_WebPrompt_Object Integer iFile Integer iField Returns Handle
13091>>>>>        Handle hoPrompt
13091>>>>>        Get File_Field_Property iFile iField GET_Field_WebPrompt_Object to hoPrompt
13092>>>>>        Function_Return hoPrompt
13093>>>>>    End_Function
13094>>>>>    
13094>>>>>    // Return the extended validation type for this field.
13094>>>>>    Function Field_Validation_Type Integer iField Returns Integer
13096>>>>>        Integer iType
13096>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField ;            to iType
13097>>>>>        Function_Return iType
13098>>>>>    End_Function
13099>>>>>    
13099>>>>>    // Procedure to define a valid value range for a field.
13099>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
13101>>>>>        Set Field_Value_Range of (Field_Attributes(Self)) iField ;            to sMin sMax
13102>>>>>    End_Procedure
13103>>>>>    
13103>>>>>    
13103>>>>>    // Procedure to define a validate table for a field.
13103>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
13105>>>>>        Set Field_Value_Table of (Field_Attributes(Self)) iField ;            to iObj
13106>>>>>    End_Procedure
13107>>>>>    
13107>>>>>    // This provides a callback to the calling object (iObj) by passing this
13107>>>>>    // object the message iMsg for each item in the table. Note this works for
13107>>>>>    // all extended validation types (range, check, etc.)
13107>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
13109>>>>>        Send Field_Fill_list to (Field_Attributes(Self)) ;            iField iObj iMsg
13110>>>>>    End_Procedure
13111>>>>>    
13111>>>>>    Procedure File_Field_Fill_List Integer iFile Integer iField ;            Integer iObj Integer iMsg
13113>>>>>        Integer iDSO
13113>>>>>        Get Data_set iFile to iDSO
13114>>>>>        If iDSO ;            Send Field_Fill_list to iDSO iField iObj iMsg
13117>>>>>    End_Procedure
13118>>>>>    
13118>>>>>    // Returns the ID if any of the validation table for this object.
13118>>>>>    Function Field_Table_Object Integer iField Returns Integer
13120>>>>>        Integer iRval
13120>>>>>        Get Field_Table_Object of (Field_Attributes(Self)) iField to iRVal
13121>>>>>        Function_Return iRVal
13122>>>>>    End_Function
13123>>>>>    
13123>>>>>    Function File_Field_Table_Object Integer iFile Integer iField Returns Integer
13125>>>>>        Integer iDSO
13125>>>>>        Get Data_set iFile to iDSO
13126>>>>>        If iDSO ;            Function_Return (Field_Table_Object(iDSO,iField))
13129>>>>>    End_Function
13130>>>>>    
13130>>>>>    // Returns code description value for the passed string for the
13130>>>>>    // passed validation table object. Normally use field_value_description
13130>>>>>    Function Validation_Table_Description Integer iObj String sVal Returns String
13132>>>>>        String sDesc
13132>>>>>        If iObj ;            Get Find_Code_Description of iObj sVal to sDesc
13135>>>>>        Function_Return sDesc
13136>>>>>    End_Function
13137>>>>>    
13137>>>>>    // Returns the description value for the field's code value. This only
13137>>>>>    // works if you have a validation table - else it returns the field value
13137>>>>>    Function Field_Current_Description Integer iField Returns String
13139>>>>>        String sDesc
13139>>>>>        String sVal
13139>>>>>        Integer iObj
13139>>>>>        Get Field_Current_Value iField to sVal
13140>>>>>        Get Field_Table_Object iField to iObj
13141>>>>>        If iObj Begin
13143>>>>>            Get Validation_Table_Description iObj sVal to sDesc
13144>>>>>            If (sDesc="") ;                Move sVal to sDesc // if desc is blank, use value
13147>>>>>        End
13147>>>>>>
13147>>>>>        Else ;            Move sVal to sDesc
13149>>>>>        Function_Return sDesc
13150>>>>>    End_Function
13151>>>>>    
13151>>>>>    Function File_Field_Current_Description Integer iFile Integer iField Returns String
13153>>>>>        Integer iDSO
13153>>>>>        Get Data_set iFile to iDSO
13154>>>>>        If iDSO ;            Function_Return (Field_Current_Description(iDSO,iField))
13157>>>>>    End_Function
13158>>>>>    
13158>>>>>    // Required Messaging to Support Checkbox items in DEOs
13158>>>>>    //  Defines a field as a two item field and defines True and False values
13158>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
13160>>>>>        Set Field_CheckBox_Values of (Field_Attributes(Self)) iField ;            to sTrue sFalse
13161>>>>>    End_Procedure
13162>>>>>    
13162>>>>>    //    Returns a field's select_State based on the pased value
13162>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
13164>>>>>        Function_Return (Field_Value_Select_State(Field_Attributes(Self),iField,sValue))
13165>>>>>    End_Function
13166>>>>>    
13166>>>>>    //    Returns a field's select_State based on the DD buffer contents
13166>>>>>    Function Field_Select_State Integer iField Returns Integer
13168>>>>>        String sValue
13168>>>>>        Get Field_Current_Value iField to sValue
13169>>>>>        Function_Return (Field_Value_Select_State(Self,iField,sValue))
13170>>>>>    End_Function
13171>>>>>    
13171>>>>>    //   Returns a file/field' select_State based on contents of DD buffer
13171>>>>>    Function File_Field_Select_State Integer iFile Integer iField Returns Integer
13173>>>>>        Integer iDSO
13173>>>>>        Get Data_set iFile to iDSO
13174>>>>>        If iDSO ;            Function_Return (Field_Select_State(iDSO,iField))
13177>>>>>    End_Function
13178>>>>>    
13178>>>>>    //   Returns a file/field' select_State based on passed value
13178>>>>>    Function File_Field_Value_Select_State Integer iFile Integer iField ;            String sValue Returns Integer
13180>>>>>        Integer iDSO
13180>>>>>        Get Data_set iFile to iDSO
13181>>>>>        If iDSO ;            Function_Return (Field_Value_Select_State(iDSO,iField,sValue))
13184>>>>>    End_Function
13185>>>>>    
13185>>>>>    // get the actual database value that corresponds to the boolean value
13185>>>>>    // passed.
13185>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
13187>>>>>        Function_Return (Field_Checkbox_Value(Field_Attributes(Self),iField,iState))
13188>>>>>    End_Function
13189>>>>>    
13189>>>>>    Function File_Field_CheckBox_Value Integer iFile Integer iField Integer iState Returns String
13191>>>>>        Integer iDSO
13191>>>>>        Get Data_set iFile to iDSO
13192>>>>>        If iDSO ;            Function_Return (Field_Checkbox_Value(iDSO,iField,iState))
13195>>>>>    End_Function
13196>>>>>    
13196>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
13196>>>>>    Procedure Set Field_Select_State Integer iField Integer iState
13198>>>>>        String sValue
13198>>>>>        Get Field_Checkbox_Value iField iState to sValue
13199>>>>>        Set Field_Current_Value iField to sValue
13200>>>>>    End_Procedure
13201>>>>>    
13201>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
13201>>>>>    // if needed (set Field_Current_Value does this). First finds proper file
13201>>>>>    // DSO
13201>>>>>    Procedure Set File_Field_Select_State Integer iFile Integer iField Integer iState
13203>>>>>        Integer iDSO
13203>>>>>        Get Data_set iFile to iDSO
13204>>>>>        If iDSO ;            Set Field_Select_State of iDSO iField to iState
13207>>>>>    End_Procedure
13208>>>>>    
13208>>>>>    // Procedure to define a check string for a field.
13208>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
13210>>>>>        Set Field_Value_Check of (Field_Attributes(Self)) iField ;            to sCheck
13211>>>>>    End_Procedure
13212>>>>>    
13212>>>>>    // This function will be called indirectly by DEOs when an item is being
13212>>>>>    // entered, exited or needs validation. The first argument holds the
13212>>>>>    // fieldnumber for the field and the second holds the id of the message
13212>>>>>    // which can be send to retrieve the message which needs to be send for
13212>>>>>    // this Field/Event combination. The value of the second argument can be
13212>>>>>    // GET_Field_Entry_MSG, GET_Field_Exit_MSG or GET_Field_Validate_MSG.
13212>>>>>    Function Exec_Field_Message Integer iField Integer iMsg_ID Returns Integer
13214>>>>>        Integer iMsg
13214>>>>>        Integer iResult
13214>>>>>        String  sValue
13214>>>>>        Get iMsg_ID iField to iMsg
13215>>>>>        If iMsg Begin
13217>>>>>            Get Field_Current_Value iField to sValue
13218>>>>>            Get iMsg iField sValue to iResult
13219>>>>>        End
13219>>>>>>
13219>>>>>        Function_Return iResult
13220>>>>>    End_Function
13221>>>>>    
13221>>>>>    
13221>>>>>    // This function will be called from within DEOs when an item is being
13221>>>>>    // entered, exited or needs validation. The first argument holds the
13221>>>>>    // file number, the second argument holds the field and the third
13221>>>>>    // holds the id of the message  which can be send to retrieve the message
13221>>>>>    // which needs to be send for this File/Field/Event combination.
13221>>>>>    // The value of the second argument can be  GET_Field_Entry_MSG,
13221>>>>>    // GET_Field_Exit_MSG or GET_Field_Validate_MSG.
13221>>>>>    // This will redirect to the proper data-set object.
13221>>>>>    Function Exec_File_Field_Message Integer iFile Integer iField Integer iMsg_ID Returns Integer
13223>>>>>        Integer iDSO
13223>>>>>        Integer iResult
13223>>>>>        Get Data_set iFile to iDSO
13224>>>>>        If iDSO ;            Get Exec_Field_Message of iDSO iField iMsg_ID to iResult
13227>>>>>        Function_Return iResult
13228>>>>>    End_Function
13229>>>>>    
13229>>>>>    // Find the data-set whose main_file is the same as File#. The message
13229>>>>>    // Which_data_set includes updating parent files, we will throw those out.
13229>>>>>    // This has been augmented to search down the DDO tree if we do not find
13229>>>>>    // the DD with our quick C Which_Data_set search
13229>>>>>    Function Data_Set Integer iFile Returns Integer
13231>>>>>        Integer iTmp
13231>>>>>        Integer iDSO
13231>>>>>        Get Main_File to iTmp
13232>>>>>        If (iTmp = iFile) ;            Function_Return Self
13235>>>>>        Get Which_Data_Set iFile to iDSO
13236>>>>>        If iDSO Begin
13238>>>>>            // check that DS's main-file is the File (and not a parent file)
13238>>>>>            Get Main_File of iDSO to iTmp
13239>>>>>            If (iTmp = iFile) ;                Function_Return iDSO
13242>>>>>        End
13242>>>>>>
13242>>>>>        
13242>>>>>        // This really should have succeeded by now. If not we need to do a
13242>>>>>        // downward sweep looking for DD. This will be a slower process since it
13242>>>>>        // involves flex level DDO structure traversal. We should very rarely ever
13242>>>>>        // get to this point. If we do, it takes longer!
13242>>>>>        
13242>>>>>        // Unlike other traversals we will mark and check in a single
13242>>>>>        // step.
13242>>>>>        // This Mark_Id creates a sequence Id for this clear. This way
13242>>>>>        // DSOs only get cleared one time during this process.
13242>>>>>        Send IncrementCurrentMarkId
13243>>>>>        Get Private.Data_set iFile to iDSO // this does the recursive downward search
13244>>>>>        Function_Return iDSO
13245>>>>>    End_Function
13246>>>>>    
13246>>>>>    Function Private.Data_Set Integer iFile Returns Integer
13248>>>>>        Integer iMax
13248>>>>>        Integer iDSO hDD
13248>>>>>        Integer iCount
13248>>>>>        
13248>>>>>        If (iFile=Main_file(Self)) ;            Function_Return Self
13251>>>>>        
13251>>>>>        // We are only looking at sequence ID.
13251>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
13252>>>>>        
13252>>>>>        // recurse Down first, since we already tried upward direction.
13252>>>>>        Get Data_Set_Client_Count to iMax
13253>>>>>        Decrement iMax
13254>>>>>        For iCount from 0 to iMax
13260>>>>>>
13260>>>>>            Get Data_Set_Client iCount to iDSO
13261>>>>>            // If already cleared during this sequence...do nothing
13261>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
13263>>>>>                Get Private.Data_Set of iDSO iFile to hDD
13264>>>>>                If hDD ;                    Function_Return hDD // when found...get out
13267>>>>>            End
13267>>>>>>
13267>>>>>        Loop
13268>>>>>>
13268>>>>>        // recurse up server list next. We do this 2nd because it is
13268>>>>>        // the less likely path for success.
13268>>>>>        Get Data_Set_Server_Count to iMax
13269>>>>>        Decrement iMax
13270>>>>>        For iCount from 0 to iMax
13276>>>>>>
13276>>>>>            Get Data_Set_Server iCount to iDSO
13277>>>>>            // If already cleared during this sequence...do nothing
13277>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
13279>>>>>                Get Private.Data_Set of iDSO iFile to hDD
13280>>>>>                If hDD ;                    Function_Return hDD // when found...get out
13283>>>>>            End
13283>>>>>>
13283>>>>>        Loop
13284>>>>>>
13284>>>>>        Function_Return 0 // if here, our traversal has failed.
13285>>>>>    End_Function
13286>>>>>    
13286>>>>>    // These methods can be used to set/get a field property in a flexible
13286>>>>>    // way. The first two argument are the file- and fieldnumber followed by
13286>>>>>    // the ID of the message that should be send. The last argument should
13286>>>>>    // be the value to set or the variable to store the value in.
13286>>>>>    Procedure Set File_Field_Property Integer iFile Integer iField Integer iMsg String sValue
13288>>>>>        Integer iDSO
13288>>>>>        Get Data_Set iFile to iDSO
13289>>>>>        If iDSO Begin
13291>>>>>            Set iMsg of iDSO iField to sValue
13292>>>>>            Procedure_Return sValue
13293>>>>>        End
13293>>>>>>
13293>>>>>    End_Procedure
13294>>>>>    
13294>>>>>    Function File_Field_Property Integer iFile Integer iField Integer iMsg Returns Integer
13296>>>>>        Integer iDSO
13296>>>>>        String  sValue
13296>>>>>        Get Data_Set iFile to iDSO
13297>>>>>        If iDSO Begin
13299>>>>>            Get iMsg of iDSO iField to sValue
13300>>>>>            Function_Return sValue
13301>>>>>        End
13301>>>>>>
13301>>>>>    End_Function
13302>>>>>    
13302>>>>>    // This procedure will return the number of fields in the object
13302>>>>>    Function Field_Count Returns Integer
13304>>>>>        Function_Return (Item_Count(Record_Buffer(Self)) - 1)
13305>>>>>    End_Function
13306>>>>>    
13306>>>>>    // This procedure will clear all flags in the visited_fields string so
13306>>>>>    // that all field will be validated on the next requests.
13306>>>>>    Procedure Clear_Visited_Fields
13308>>>>>        // this clears field visitation marks
13308>>>>>        Set Visited_Fields to (Repeat(" ", Field_Count(Self)))
13309>>>>>    End_Procedure
13310>>>>>    
13310>>>>>    // Private.Initialize_Visited
13310>>>>>    // This procedure will be called when validations (and perhaps other
13310>>>>>    // events) is requested. It clears the visited marks and then proceeds
13310>>>>>    // to clear the marks up the server tree.
13310>>>>>    // This is passed two parameters: Up_and_down, If true upward and downward
13310>>>>>    // initialize. If Clear_Fields also clear the field string
13310>>>>>    Procedure Private.Initialize_Visited Integer Up_and_Down Integer Clear_Fields
13312>>>>>        Integer iMax
13312>>>>>        Integer iDSO
13312>>>>>        Integer iCount
13312>>>>>        
13312>>>>>        // recurse up server list first. Only recurse up
13312>>>>>        Get Data_Set_Server_Count to iMax
13313>>>>>        Decrement iMax
13314>>>>>        For iCount from 0 to iMax
13320>>>>>>
13320>>>>>            Get Data_Set_Server iCount to iDSO
13321>>>>>            // If already cleared during this sequence...do nothing
13321>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                Send Private.Initialize_Visited to iDSO False Clear_Fields
13324>>>>>        Loop
13325>>>>>>
13325>>>>>        
13325>>>>>        If Clear_Fields ;            Send Clear_Visited_Fields // clear all markers in this object
13328>>>>>        // this clears the visited mark for the entire object
13328>>>>>        Set Visited_State to False
13329>>>>>        Set DownDelete_State to False
13330>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
13331>>>>>        
13331>>>>>        // If Up_and_Down recurse Down server list
13331>>>>>        If Up_and_Down Begin
13333>>>>>            Get Data_Set_Client_Count to iMax
13334>>>>>            Decrement iMax // **EK** This line was missing
13335>>>>>            For iCount from 0 to iMax
13341>>>>>>
13341>>>>>                Get Data_Set_Client iCount to iDSO
13342>>>>>                // If already cleared during this sequence...do nothing
13342>>>>>                If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                    Send Private.Initialize_Visited to iDSO True Clear_Fields
13345>>>>>            Loop
13346>>>>>>
13346>>>>>        End
13346>>>>>>
13346>>>>>    End_Procedure
13347>>>>>    
13347>>>>>    
13347>>>>>    // Clears Visited marks and (maybe) field visited marks in all required
13347>>>>>    // DSOs. If Up_and_Down is TRUE DSOs are marked up and Down (delete style)
13347>>>>>    // propagation. If False, DSOs are marked up (save style). This does not
13347>>>>>    // have a mode to mark ALL DSOs in a structure. (Not needed so far).
13347>>>>>    // If Clear_Fields is T the field string marker is also cleared.
13347>>>>>    // The method of using the global integer DD_Current_Mark_ID is an opt-
13347>>>>>    // imizer. This is private - do not tamper with it!
13347>>>>>    // Note that Intialize_Visited does not always Clear all DDOs in the structure. When
13347>>>>>    // Up_and_Down is true, it is marking all DDOs that will participate in a cascade delete
13347>>>>>    // which may not be all DDOs in the structure. If you want to initialize all DDOs use InitializeAllVisited
13347>>>>>    Procedure Initialize_Visited Integer Up_and_Down Integer Clear_Fields
13349>>>>>        Send IncrementCurrentMarkId
13350>>>>>        Send Private.Initialize_Visited Up_and_Down Clear_Fields
13351>>>>>    End_Procedure
13352>>>>>    
13352>>>>>    Procedure InitializeAllVisited2
13354>>>>>        Integer iMax iCount
13354>>>>>        Handle hoDSO
13354>>>>>        
13354>>>>>        Set Visited_State to False
13355>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id // marks this as visited
13356>>>>>        
13356>>>>>        // recurse up server list.
13356>>>>>        Get Data_Set_Server_Count to iMax
13357>>>>>        For iCount from 0 to (iMax-1)
13363>>>>>>
13363>>>>>            Get Data_Set_Server iCount to hoDSO
13364>>>>>            // If already cleared during this sequence...do nothing
13364>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 of hoDSO
13367>>>>>        Loop
13368>>>>>>
13368>>>>>        
13368>>>>>        // recurse down client list.
13368>>>>>        Get Data_Set_Client_Count to iMax
13369>>>>>        For iCount from 0 to (iMax-1)
13375>>>>>>
13375>>>>>            Get Data_Set_Client iCount to hoDSO
13376>>>>>            // If already cleared during this sequence...do nothing
13376>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 to hoDSO
13379>>>>>        Loop
13380>>>>>>
13380>>>>>    End_Procedure
13381>>>>>    
13381>>>>>    // clears visited flag for *all* ddos in the structure.
13381>>>>>    Procedure InitializeAllVisited
13383>>>>>        Send IncrementCurrentMarkId
13384>>>>>        Send InitializeAllVisited2
13385>>>>>    End_Procedure
13386>>>>>    
13386>>>>>    
13386>>>>>    // Internal recursive message to check file connections. Called from
13386>>>>>    // Valid_connections only. Private message
13386>>>>>    Function Private.Valid_Structure Integer Up_And_Down Returns Integer
13388>>>>>        Integer iRval iCount iMax
13388>>>>>        Handle iDSO iPDSO
13388>>>>>        Integer iPMax iPCount iPMain
13388>>>>>        Boolean bUpDown bNull bCascadeNull bDown
13388>>>>>        
13388>>>>>        // Check Current Connections
13388>>>>>        Get Valid_Servers to iRval           // always check servers
13389>>>>>        If (iRval=0 and Up_and_Down) ;       // check Clients if required            Get Valid_Clients to iRval
13392>>>>>        Set Visited_State to True
13393>>>>>        
13393>>>>>        // Ask Server data-sets to check their server connections
13393>>>>>        If not iRval Begin // check up
13395>>>>>            Get Data_Set_Server_Count to iMax
13396>>>>>            Decrement iMax
13397>>>>>            For iCount from 0 to iMax
13403>>>>>>
13403>>>>>                Get Data_Set_Server iCount to iDSO
13404>>>>>                If not (Visited_state(iDSO)) ;                    Get Private.Valid_Structure of iDSO False to iRVal
13407>>>>>            Until iRval
13409>>>>>        End
13409>>>>>>
13409>>>>>        
13409>>>>>        // If required, Ask Clients to check their server and client connections
13409>>>>>        //
13409>>>>>        If (iRval=0 and Up_and_Down) Begin // check down
13411>>>>>            Get Data_Set_Client_Count to iMax
13412>>>>>            Decrement iMax
13413>>>>>            For iCount from 0 to iMax
13419>>>>>>
13419>>>>>                Get Data_Set_Client iCount to iDSO
13420>>>>>                If not (Visited_state(iDSO)) Begin
13422>>>>>                    Get Data_Set_Server_Count of iDSO to iPMax
13423>>>>>                    // test if all deletable parents for a non parent null allowed/cascade delete null
13423>>>>>                    For iPCount from 0 to (iPMax-1)
13429>>>>>>
13429>>>>>                        Get Data_Set_Server of iDSO iPCount to iPDSO
13430>>>>>                        Get DownDelete_State of iPDSO to bDown
13431>>>>>                        If (bDown) Begin
13433>>>>>                            Get Main_File of iPDSO to iPMain
13434>>>>>                            Get IsNullParentAllowed of iDSO iPMain to bNull
13435>>>>>                            Get IsCascadeDeleteNull of iDSO iPMain to bCascadeNull
13436>>>>>                            Move (not(bNull) or not(bCascadeNull)) to bUpDown
13437>>>>>                        End
13437>>>>>>
13437>>>>>                    Until bUpDown
13439>>>>>                    Get Private.Valid_Structure of iDSO bUpDown to iRVal
13440>>>>>                End
13440>>>>>>
13440>>>>>            Until iRval
13442>>>>>        End
13442>>>>>>
13442>>>>>        
13442>>>>>        Function_Return iRVal
13443>>>>>        
13443>>>>>    End_Function
13444>>>>>    
13444>>>>>    // Validate data-set updating connections against required connections
13444>>>>>    // Pass: Up_and_down=T if we should check Server and Client connections
13444>>>>>    //                  =F is we only check servers
13444>>>>>    // Ret: 0 if ok, Missing File# if not ok.
13444>>>>>    // Up_And_Down should be true when testing for cascade delete structures and
13444>>>>>    // false when testing for save / delete-no-cascade structures
13444>>>>>    Function Valid_Structure Integer Up_And_Down Returns Integer
13446>>>>>        Send Initialize_Visited Up_and_Down False // False=don't clear field marks
13447>>>>>        If (Up_And_Down) Begin
13449>>>>>            Send MarkDDOsForCascadeDelete
13450>>>>>        End
13450>>>>>>
13450>>>>>        Function_Return (Private.Valid_Structure(Self,Up_and_Down))
13451>>>>>    End_Function
13452>>>>>    
13452>>>>>    // mark all DDOs which are part of this deletes cascade delete tree
13452>>>>>    // mark this and all clients as Downward deletable. This includes
13452>>>>>    // cacscade delete and cascade set to null (not for cascade_delete_state=F)
13452>>>>>    Procedure MarkDDOsForCascadeDelete
13454>>>>>        Integer iMax  iCount
13454>>>>>        Boolean bDown
13454>>>>>        Handle hoDDO
13454>>>>>        Set DownDelete_State to True
13455>>>>>        Get Data_Set_Client_Count to iMax
13456>>>>>        For iCount from 0 to (iMax-1)
13462>>>>>>
13462>>>>>            Get Data_Set_Client iCount to hoDDO
13463>>>>>            Get DownDelete_State of hoDDO to bDown
13464>>>>>            If not bDown Begin // circular DDO test - never do this
13466>>>>>                Send MarkDDOsForCascadeDelete of hoDDO
13467>>>>>            End
13467>>>>>>
13467>>>>>        Loop
13468>>>>>>
13468>>>>>    End_Procedure
13469>>>>>    
13469>>>>>    
13469>>>>>    // This function will execute the validation message for each field within
13469>>>>>    // this object. If DoAllFG is true all items are validated. If false
13469>>>>>    // only unvisited items are checked.
13469>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
13469>>>>>    // do something with the possible cascade of errors
13469>>>>>    // if the err returns DFERR_ENTER_VALID_REC_ID we will not continue
13469>>>>>    // the validation (the other fields will be bad). This works best if the
13469>>>>>    // findreq appears as one of the first fields in the file (which is almost
13469>>>>>    // always the case
13469>>>>>    Function Validate_Fields Integer DoAllFg Integer bNoStop Returns Integer
13471>>>>>        Integer iRetval
13471>>>>>        Integer iMax
13471>>>>>        Integer iCount
13471>>>>>        Integer iFile
13471>>>>>        Integer iErr
13471>>>>>        String  sVS
13471>>>>>        Get Visited_Fields to sVS
13472>>>>>        Get Field_Count to iMax
13473>>>>>        Get Main_File to iFile
13474>>>>>        For iCount from 1 to iMax
13480>>>>>>
13480>>>>>            If (DoAllFG or Mid(sVS, 1, iCount)=" ") Begin
13482>>>>>                Get Validate_Field iCount to iErr
13483>>>>>                If iErr Begin
13485>>>>>                    Move iErr to iRetVal
13486>>>>>                    // error occurred. If not no-stop or the error is
13486>>>>>                    // a findreq error - we are done.
13486>>>>>                    If (not(bNoStop) or iRetVal=DFERR_ENTER_VALID_REC_ID) ;                        Function_Return iRetVal
13489>>>>>                End
13489>>>>>>
13489>>>>>            End
13489>>>>>>
13489>>>>>        Loop
13490>>>>>>
13490>>>>>        Function_Return iRetval
13491>>>>>    End_Function
13492>>>>>    
13492>>>>>    // 17.0 - added support for null-parents. If null parents allowed, req lets it through
13492>>>>>    Function Validate_Required Integer iField Returns Integer
13494>>>>>        Boolean bNull bErr
13494>>>>>        
13494>>>>>        Move (trim(Field_Current_Value(Self,iField))='') to bErr
13495>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTRY_REQUIRED ""
13498>>>>>        Function_Return bErr
13499>>>>>    End_Function
13500>>>>>    
13500>>>>>    // return true if we should skip validation for this field. This can happen with Null allowed parents.
13500>>>>>    // if this is foreign, new and has no changes and is null allowed we will skip.
13500>>>>>    Function SkipValidate Integer iField Returns Boolean
13502>>>>>        Boolean bSkip bFieldChanged bEmpty
13502>>>>>        String sValue
13502>>>>>        
13502>>>>>        If (OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(changed_state(Self))) Begin
13504>>>>>            // We must also check field_changed_state and only skip if this is not changed.
13504>>>>>            Get Field_Changed_State iField to bFieldChanged
13505>>>>>            // Retain and remember may set field_changed_state to true even when empty. If this field is changed
13505>>>>>            // but its value is empty we assume it is a candidate for Null checking, so we will set field-changed to false
13505>>>>>            If bFieldChanged Begin
13507>>>>>                Get Field_Current_Value iField to sValue
13508>>>>>                Get IsEmptyField iField sValue to bEmpty
13509>>>>>                If bEmpty Begin
13511>>>>>                    Move False to bFieldChanged
13512>>>>>                End
13512>>>>>>
13512>>>>>            End
13512>>>>>>
13512>>>>>            If (not(bFieldChanged)) Begin
13514>>>>>                // we must find the child that points to this DD, starting with operation_origin. If a child
13514>>>>>                // is found, it will be in array position 1 (0 is self, 1 is child)
13514>>>>>                Get IsNullParentOrAncestor to bSkip
13515>>>>>            End
13515>>>>>>
13515>>>>>        End
13515>>>>>>
13515>>>>>        Function_Return bSkip
13516>>>>>    End_Function
13517>>>>>    
13517>>>>>    
13517>>>>>    // This will tell us if this DD can be treated as either a null parent
13517>>>>>    // or an ancestor of a null parent. This should only be called for a DD
13517>>>>>    // that is a candidate for this meaning that it does not have a change.
13517>>>>>    // We will test if its child allows this parent to be null or if this
13517>>>>>    // is in the path of an allowed null parent. We assume that parents of
13517>>>>>    // null parents will also be null. This is used to test if validations are
13517>>>>>    // needed.
13517>>>>>    Function IsNullParentOrAncestor Returns Boolean
13519>>>>>        Handle[] hoDDs
13520>>>>>        Integer i iSize iMain
13520>>>>>        Boolean bNullAllowed
13520>>>>>        // gets an array where 0 is self, 1 is parent, 2 is grandparent, and the
13520>>>>>        // last item is the operation_origin.
13520>>>>>        Send DDOServerPath of operation_origin Self (&hoDDs)
13521>>>>>        Move (SizeOfArray(hoDDs)) to iSize
13522>>>>>        If (iSize) Begin
13524>>>>>            // see if the immediate child allows this to be null.
13524>>>>>            Get Main_File to iMain
13525>>>>>            Get IsNullParentAllowed of hoDDs[1] iMain to bNullAllowed
13526>>>>>            
13526>>>>>            // if null not allowed, see if this is an ancestor to a null allowed
13526>>>>>            // parent where all DDs in this path are unchanged. For example:
13526>>>>>            // G.DD <- P.DD <- C.DD where we C.DD allows P.DD to be null and we
13526>>>>>            // want to test if G.DD needs validation
13526>>>>>            Move 1 to i
13527>>>>>            While (not(bNullAllowed) and (i+1<iSize) and not(changed_state(hoDDs[i])) )
13531>>>>>                Get Main_File of hoDDs[i] to iMain
13532>>>>>                Get IsNullParentAllowed of hoDDs[i+1] iMain to bNullAllowed
13533>>>>>                Increment i
13534>>>>>            Loop
13535>>>>>>
13535>>>>>            
13535>>>>>        End
13535>>>>>>
13535>>>>>        Function_Return bNullAllowed
13536>>>>>    End_Function
13537>>>>>    
13537>>>>>    
13537>>>>>    Function Validate_FindReq Integer iField Returns Integer
13539>>>>>        Integer bErr iOpts
13539>>>>>        // if no current record, we have not found the required record.
13539>>>>>        Move (not(HasRecord(Self))) to bErr
13540>>>>>        // We also need to check if the field is changed. If the field is changed and this
13540>>>>>        // is an autofind field, this indicates that an autofind was attempted and failed. We
13540>>>>>        // can't jut rely on current_record because a failed autofind restores the old current
13540>>>>>        // record. For this to work, DEOs must set the DD field's changed_state to true on
13540>>>>>        // no-put fields (dd_deomx.pkg was changed to do this).
13540>>>>>        If (not(bErr) and field_changed_state(Self,iField)) Begin
13542>>>>>            Get Field_Options iField to iOpts
13543>>>>>            Move ( ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) or ;                ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ) ;                to bErr
13544>>>>>        End
13544>>>>>>
13544>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTER_VALID_REC_ID ""
13547>>>>>        Function_Return bErr
13548>>>>>    End_Function
13549>>>>>    
13549>>>>>    // This function will be called to validate a field.
13549>>>>>    // mark field currently being validated
13549>>>>>    // Altered to Check DD options (required, findreq)
13549>>>>>    Function Validate_Field Integer iField Returns Integer
13551>>>>>        Integer iResult
13551>>>>>        Integer iMsg
13551>>>>>        Integer iObj
13551>>>>>        String  sValue
13551>>>>>        Integer iFile
13551>>>>>        Integer iOpts iMain
13551>>>>>        Boolean bSkipValidate
13551>>>>>        Handle[] hoDDs
13552>>>>>        
13552>>>>>        Set Current_Validate_Field to iField
13553>>>>>        
13553>>>>>        // test if we should skip validation on this field
13553>>>>>        Get SkipValidate iField to bSkipValidate
13554>>>>>        
13554>>>>>        If (not(bSkipValidate)) Begin
13556>>>>>            
13556>>>>>            Move (Record_Buffer(Self)) to iObj
13557>>>>>            Get Main_File to iFile
13558>>>>>            
13558>>>>>            // Check for DD option failures: required, find_required
13558>>>>>            // "File_field" gets regular and foreign fields as needed
13558>>>>>            //Get File_Field_Options iFile iField to iOpts
13558>>>>>            Get Field_Options iField to iOpts  // get reg options
13559>>>>>            // if this is not the DDO that started the validation, we will assume that
13559>>>>>            // this is foreign. Operation_origin is set in Request_Validate
13559>>>>>            // If foreign (as defined above) and we do not allow new saves when
13559>>>>>            // foreign, we will consider this to be foreign and add foreign options
13559>>>>>            If (Operation_Origin<>Self and ;                Allow_Foreign_New_Save_State(Self)=0)  ;                Move (iOpts ior Foreign_Field_Options(Self, iField)) to iOpts
13562>>>>>            
13562>>>>>            
13562>>>>>            // Check for FindReq first. If it fails, set iResult to DFERR_ENTER_VALID_REC_ID so
13562>>>>>            // the calling function knows that a findreq failed. Always do this validation first
13562>>>>>            If (iOpts iand DD_FINDREQ) ;                Get Validate_FindReq  iField to iResult
13565>>>>>            If iResult Begin
13567>>>>>                Send AddDDHasFindReqError
13568>>>>>                Move DFERR_ENTER_VALID_REC_ID to iResult
13569>>>>>            End
13569>>>>>>
13569>>>>>            Else Begin
13570>>>>>                
13570>>>>>                If (iOpts iand DD_REQUIRED) ;                    Get Validate_Required iField to iResult
13573>>>>>                
13573>>>>>                If (iResult=0) Begin
13575>>>>>                    // First execute the user defined validation message
13575>>>>>                    Get Item_Validate_MSG of iObj iField to iMsg
13576>>>>>                    If iMsg Begin
13578>>>>>                        Get Field_Current_Value iField to sValue
13579>>>>>                        Get iMsg iField sValue to iResult
13580>>>>>                    End
13580>>>>>>
13580>>>>>                End
13580>>>>>>
13580>>>>>                
13580>>>>>                // Check for keys
13580>>>>>                If (iResult=0 and Key_Field_State(Self, iField)) ;                    Get Validate_Key_Field iField to iResult
13583>>>>>                
13583>>>>>                // Do extended validations
13583>>>>>                If (iResult=0) ;                    Get Validate_Field of (Field_Attributes(Self)) iField to iResult
13586>>>>>            End
13586>>>>>>
13586>>>>>        End
13586>>>>>>
13586>>>>>        
13586>>>>>        Set Current_Validate_Field to 0
13587>>>>>        // Mark this field being validated
13587>>>>>        Get Visited_Fields to sValue
13588>>>>>        Set Visited_Fields to (Overstrike("X", sValue, iField))
13589>>>>>        
13589>>>>>        Function_Return iResult
13590>>>>>        
13590>>>>>    End_Function
13591>>>>>    
13591>>>>>    
13591>>>>>    // This function will be called to validate a field.
13591>>>>>    Function File_Field_Validate_Field Integer iFile Integer iField Returns Integer
13593>>>>>        Integer iDSO
13593>>>>>        Integer iResult
13593>>>>>        Integer hOldOrigin
13593>>>>>        Get Data_Set iFile to iDSO
13594>>>>>        If not iDSO ;            Function_Return 0
13597>>>>>        
13597>>>>>        // This function is only called by the DEOs.
13597>>>>>        // It is possible for validate_item when called as part of
13597>>>>>        // request_validate to get called more than once
13597>>>>>        // when a field is foreign (it is attached to both its DDO and the
13597>>>>>        // child-main ddo). This makes sure the validation is only called once.
13597>>>>>        // (vdf7 change: previously we set OpMode to Mode_Saving and checked that, now we have
13597>>>>>        // a mode just for request_validate).
13597>>>>>        If (Operation_Mode=MODE_VALIDATING and ;         // if from request_validate            Mid(Visited_Fields(iDSO), 1, iField)="X" ) ; // and already marked            Function_Return 0                         // skip it
13600>>>>>        
13600>>>>>        Move Operation_origin to hOldOrigin
13601>>>>>        
13601>>>>>        // if from request_validate operation_origin will be set and should not
13601>>>>>        // be reset here.
13601>>>>>        If (OPERATION_ORIGIN=0) Begin
13603>>>>>            Move Self to Operation_Origin
13604>>>>>        End
13604>>>>>>
13604>>>>>        
13604>>>>>        Get Validate_Field of iDSO iField to iResult
13605>>>>>        Move hOldOrigin to Operation_Origin
13606>>>>>        Function_Return iResult
13607>>>>>    End_Function
13608>>>>>    
13608>>>>>    // This function will be called to check if a key has been changed.
13608>>>>>    Function Validate_Key_Field Integer iField Returns Integer
13610>>>>>        String  sOld_Value
13610>>>>>        String  sNew_Value
13610>>>>>        String  sKeys
13610>>>>>        Integer iState
13610>>>>>        Boolean bMultiKeys
13610>>>>>        Get Protect_Key_State to iState
13611>>>>>        If iState Begin
13613>>>>>            Get Key_Value to sNew_Value
13614>>>>>            // Only check existing records.
13614>>>>>            If (HasRecord(Self)) Begin
13616>>>>>                Get Existing_Key_Value to sOld_Value
13617>>>>>                If (sNew_Value <> sOld_Value) Begin
13619>>>>>                    // we have an error. If there is only one key field we know
13619>>>>>                    // where the field is and we can report that field. If we have
13619>>>>>                    // multiple key fields, we don't really know where the offending key change
13619>>>>>                    // is, so we will not report a field.
13619>>>>>                    Get Key_Fields to sKeys
13620>>>>>                    Move (Pos("X",sKeys)<>RightPos("X",sKeys)) to bMultiKeys
13621>>>>>                    Send Data_set_Error (If(bMultiKeys, -1, iField)) 0 DD_TEXT_NO_KEY_CHANGE_ALLOWED
13622>>>>>                    Function_Return 1
13623>>>>>                End
13623>>>>>>
13623>>>>>            End
13623>>>>>>
13623>>>>>        End
13623>>>>>>
13623>>>>>    End_Function
13624>>>>>    
13624>>>>>    
13624>>>>>    // During request_validate process tell us if this DD has had a find_request error. This
13624>>>>>    // is handled by the DD that originated the request_validate. Very private
13624>>>>>    Function DDHasFindReqError Returns Boolean
13626>>>>>        Handle[] DDsWithFindReqErrors
13627>>>>>        Integer iIndex
13627>>>>>        If (OPERATION_ORIGIN) Begin
13629>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13630>>>>>            Move (SearchArray(Self,DDsWithFindReqErrors)) to iIndex
13631>>>>>            Function_Return (iIndex<>-1)
13632>>>>>        End
13632>>>>>>
13632>>>>>    End_Function
13633>>>>>    
13633>>>>>    // During a request_validate a find_request error has occurred. Add this DD
13633>>>>>    // to list of DDs that have this error. This is handled by the DD that
13633>>>>>    // originated the request_validate.  Very private
13633>>>>>    Procedure AddDDHasFindReqError
13635>>>>>        Handle[] DDsWithFindReqErrors
13636>>>>>        If (OPERATION_ORIGIN) Begin
13638>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13639>>>>>            Move Self to DDsWithFindReqErrors[SizeOfArray(DDsWithFindReqErrors)]
13640>>>>>            Set pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
13641>>>>>        End
13641>>>>>>
13641>>>>>    End_Procedure
13642>>>>>    
13642>>>>>    // This function will execute the validation message for each field of the
13642>>>>>    // data set and all of its parents in parent first order.
13642>>>>>    // Pass: DoALLFg bNoStop
13642>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
13642>>>>>    // do something with the possible cascade of errors
13642>>>>>    Function Validate_Data_Sets Integer DoAllFg Integer bNoStop Returns Integer
13644>>>>>        Integer iDSO
13644>>>>>        Integer iRetval
13644>>>>>        Integer iCount
13644>>>>>        Integer iMax
13644>>>>>        Integer bErr
13644>>>>>        Boolean bDDHasFindReqError
13644>>>>>        // ShowLn "Validate_Data_Sets in Data_Set in " (Name(self))
13644>>>>>        // Validate if not foreign, or foreign new saves allowed, or
13644>>>>>        // foreign validation is supported (it normally is)
13644>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self) or ;            Validate_Foreign_File_State(Self)) Begin
13646>>>>>            
13646>>>>>            If (bNoStop) Begin
13648>>>>>                // if do all, it is possible that this DD as a find-req error. If so there is no
13648>>>>>                // need to look for more errors in this DD or its parents. This makes the do all checking
13648>>>>>                // a little more intelligent and doesn't return a bunch of errors when it is not needed
13648>>>>>                Get DDHasFindReqError to bDDHasFindReqError
13649>>>>>            End
13649>>>>>>
13649>>>>>            
13649>>>>>            If (not(bDDHasFindReqError)) Begin
13651>>>>>                Get Data_Set_Server_Count to iMax
13652>>>>>                Decrement iMax
13653>>>>>                For iCount from 0 to iMax
13659>>>>>>
13659>>>>>                    Get Data_Set_Server iCount to iDSO
13660>>>>>                    If not (Visited_state(iDSO)) Begin
13662>>>>>                        Get Validate_Data_Sets of iDSO DoAllFg bNoStop to bErr
13663>>>>>                        If bErr Begin
13665>>>>>                            Move bErr to iRetVal
13666>>>>>                            If bNoStop ;                                Move 0 to bErr
13669>>>>>                        End
13669>>>>>>
13669>>>>>                    End
13669>>>>>>
13669>>>>>                Until bErr
13671>>>>>                If not bErr Begin
13673>>>>>                    Get Validate_Fields DoAllFg bNoStop to bErr
13674>>>>>                    If bErr ;                        Move bErr to iRetVal
13677>>>>>                End
13677>>>>>>
13677>>>>>            End
13677>>>>>>
13677>>>>>        End
13677>>>>>>
13677>>>>>        Set Visited_State to True
13678>>>>>        Function_Return iRetval
13679>>>>>    End_Function
13680>>>>>    
13680>>>>>    // This tests the DDO and all "up" DDOs to see if a switched parent / commit test even needs to be
13680>>>>>    // tested. This is called by the top ValidateSwitchedCommittedParents to see if a switch parent test
13680>>>>>    // even needs to be applied before it has to refinds records.
13680>>>>>    // Return true is there is nothing to test (i.e., the shortcut worked).
13680>>>>>    Function IsCommittedRecursiveUpParentChangeAllowed Returns Boolean
13682>>>>>        Boolean bAllowed bCommitted bVisited bHasRecord
13682>>>>>        Integer iServers iSrvr iParent
13682>>>>>        Handle hoSrvr
13682>>>>>        
13682>>>>>        
13682>>>>>        // optimization. We only test committed parents if one parent does not allow changing committed records.
13682>>>>>        // This avoids extra finds and relates when not needed
13682>>>>>        Set Visited_State to True
13683>>>>>        Get Data_Set_Server_Count to iServers
13684>>>>>        Get IsCommitted to bCommitted
13685>>>>>        Move 0 to iSrvr
13686>>>>>        Move True to bAllowed
13687>>>>>        While (iSrvr<iServers and bAllowed)
13691>>>>>            Get Data_Set_Server iSrvr to hoSrvr
13692>>>>>            Get Main_File of hoSrvr to iParent
13693>>>>>            // if committed and parent change not allowed, we are done
13693>>>>>            If (bCommitted) Begin
13695>>>>>                Get IsCommittedParentChangeAllowed iParent to bAllowed
13696>>>>>            End
13696>>>>>>
13696>>>>>            // if still allowed, check all parents
13696>>>>>            If (bAllowed) Begin
13698>>>>>                Get Visited_State of hoSrvr to bVisited
13699>>>>>                If not bVisited Begin
13701>>>>>                    Get IsCommittedRecursiveUpParentChangeAllowed of hoSrvr to bAllowed
13702>>>>>                End
13702>>>>>>
13702>>>>>            End
13702>>>>>>
13702>>>>>            Increment iSrvr
13703>>>>>        Loop
13704>>>>>>
13704>>>>>        Function_Return bAllowed
13705>>>>>    End_Function
13706>>>>>    
13706>>>>>    
13706>>>>>    // special validate-save check for changed committed parent. If the record is committed
13706>>>>>    // and it has a switched parent and this is not allowed, we have an error. This should rarely happen because the
13706>>>>>    // DEOs should guard aginst this. This is a recursive routine that requires special attention the first time through.
13706>>>>>    // When called from the we must refind the original record and all original parents. This way we can compare these parent
13706>>>>>    // rowids to the DD row id (if different, they've changed). At the end we must restore the DD records. Because this takes time
13706>>>>>    // we only even do this if this is committed and there is a chance that there are changed parents
13706>>>>>    
13706>>>>>    Function ValidateSwitchedCommittedParents Boolean bTop Returns Boolean
13708>>>>>        Integer iServers iSrvr iMain iParent iPMain
13708>>>>>        Handle hoSrvr
13708>>>>>        RowID riCrnt riParent riPCrnt
13708>>>>>        Boolean bChanged bCommitted bAllowed bErr bParentChanged bVisited
13708>>>>>        Boolean bHasRecord bPHasRecord bFound
13708>>>>>        
13708>>>>>        
13708>>>>>        // Shortcut optimization. This tests for any committed DDO with a parent that doesn't allow a switch
13708>>>>>        // return true if there is any reason to actually test any DDO up the tree for a parent change
13708>>>>>        If bTop Begin
13710>>>>>            // init visited nodes, these will be tested and set in IsCommittedRecursiveUpParentChangeAllowed
13710>>>>>            Send Initialize_Visited False False //false=up only, true=clear fields
13711>>>>>            Get IsCommittedRecursiveUpParentChangeAllowed to bAllowed
13712>>>>>            If bAllowed Begin
13714>>>>>                Function_Return False // if all are allowed, we have nothing to test - its ok
13715>>>>>            End
13715>>>>>>
13715>>>>>        End
13715>>>>>>
13715>>>>>        
13715>>>>>        Get Main_File to iMain
13716>>>>>        Get CurrentRowId to riCrnt
13717>>>>>        Get Data_Set_Server_Count to iServers
13718>>>>>        Get HasRecord to bHasRecord
13719>>>>>        
13719>>>>>        If (bHasRecord and (bTop or not(IsSameRowID(GetRowID(iMain),riCrnt))) ) Begin
13721>>>>>            // this refinds the main record and, most importantly, relates all original parents on up
13721>>>>>            // We now have the original parents which we can test to see if they are changed.
13721>>>>>            Get ReadByRowIdEx iMain riCrnt to bFound
13722>>>>>            If not bFound Begin
13724>>>>>                Error DFERR_CANT_REFIND_RECORD
13725>>>>>>
13725>>>>>                Function_Return True
13726>>>>>            End
13726>>>>>>
13726>>>>>        End
13726>>>>>>
13726>>>>>        
13726>>>>>        If (bTop) Begin
13728>>>>>            // If at start, init visited nodes, these will be tested and set during recursive calls to this function
13728>>>>>            Send Initialize_Visited False False // false=up only, true=clear fields
13729>>>>>        End
13729>>>>>>
13729>>>>>        
13729>>>>>        Set Visited_State to True
13730>>>>>        Get IsCommitted to bCommitted
13731>>>>>        If bCommitted Begin
13733>>>>>            // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
13733>>>>>            // First see any any of the parents are changed.
13733>>>>>            Get Parent_Changed_State to bChanged
13734>>>>>            If bChanged Begin
13736>>>>>                // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
13736>>>>>                Move 0 to iSrvr
13737>>>>>                While (iSrvr<iServers and not(bErr))
13741>>>>>                    Get Data_Set_Server iSrvr to hoSrvr
13742>>>>>                    Get Main_File of hoSrvr to iParent
13743>>>>>                    Get CurrentRowId of hoSrvr to riParent
13744>>>>>                    Move (not(IsSameRowID(GetRowID(iParent),riParent))) to bParentChanged // is parent changed?
13745>>>>>                    If bParentChanged Begin
13747>>>>>                        Get IsCommittedParentChangeAllowed iParent to bAllowed // is changing committed parent allowed?
13748>>>>>                        If not bAllowed Begin
13750>>>>>                            Move True to bErr
13751>>>>>                            If bErr Begin
13753>>>>>                                Send Data_Set_Error of hoSrvr -1 0 DD_CANNOT_SWITCH_PARENT
13754>>>>>                            End
13754>>>>>>
13754>>>>>                        End
13754>>>>>>
13754>>>>>                    End
13754>>>>>>
13754>>>>>                    Increment iSrvr
13755>>>>>                Loop
13756>>>>>>
13756>>>>>            End
13756>>>>>>
13756>>>>>        End
13756>>>>>>
13756>>>>>        
13756>>>>>        // no error in immediate we must continue this check up the parent tree.
13756>>>>>        Move 0 to iSrvr
13757>>>>>        While (iSrvr<iServers and not(bErr))
13761>>>>>            Get Data_Set_Server iSrvr to hoSrvr
13762>>>>>            Get Visited_State of hoSrvr to bVisited
13763>>>>>            If (not(bVisited)) Begin
13765>>>>>                
13765>>>>>                // if new record, we need to refind parent records from here since you cannot
13765>>>>>                // have done a find/relate on a new record.
13765>>>>>                If (not(bHasRecord)) Begin
13767>>>>>                    Get HasRecord of hoSrvr to bPHasRecord
13768>>>>>                    If (bPHasRecord) Begin
13770>>>>>                        Get Main_File of hoSrvr to iPMain
13771>>>>>                        Get CurrentRowId of hoSrvr to riPCrnt
13772>>>>>                        If (not(IsNullRowID(riPCrnt))) Begin
13774>>>>>                            Get ReadByRowIdEx of hoSrvr iPMain riPCrnt to bFound
13775>>>>>                            If not bFound Begin
13777>>>>>                                Error DFERR_CANT_REFIND_RECORD
13778>>>>>>
13778>>>>>                                Function_Return True
13779>>>>>                            End
13779>>>>>>
13779>>>>>                        End
13779>>>>>>
13779>>>>>                    End
13779>>>>>>
13779>>>>>                End
13779>>>>>>
13779>>>>>                
13779>>>>>                Get ValidateSwitchedCommittedParents of hoSrvr False to bErr // call recursively up the parent tree
13780>>>>>            End
13780>>>>>>
13780>>>>>            Increment iSrvr
13781>>>>>        Loop
13782>>>>>>
13782>>>>>        
13782>>>>>        If bTop Begin // if back to the top, make sure our buffers are correct.
13784>>>>>            Send Refind_Records
13785>>>>>        End
13785>>>>>>
13785>>>>>        
13785>>>>>        Function_Return bErr
13786>>>>>    End_Function
13787>>>>>    
13787>>>>>    Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
13789>>>>>        
13789>>>>>        Handle hoBuff hoDSO
13789>>>>>        Boolean bCommit bIsFind bVisited bIsForeign
13789>>>>>        Integer iMax iCount iItems iOpts iChanges
13789>>>>>        
13789>>>>>        
13789>>>>>        Move record_buffer to hoBuff
13790>>>>>        Move (OPERATION_MODE<>MODE_SAVING) to bIsFind
13791>>>>>        
13791>>>>>        // first recurse to all parent ddos
13791>>>>>        Get Data_Set_Server_Count to iMax
13792>>>>>        Decrement iMax
13793>>>>>        For iCount from 0 to iMax
13799>>>>>>
13799>>>>>            Get Data_Set_Server iCount to hoDSO
13800>>>>>            Get Visited_State of hoDSO to bVisited
13801>>>>>            If not (bVisited) Begin
13803>>>>>                Send Entry_Update_Data_Sets to hoDSO iFile iAll
13804>>>>>            End
13804>>>>>>
13804>>>>>        Loop
13805>>>>>>
13805>>>>>        
13805>>>>>        // if find, we only do this if the main file is the same as the find file
13805>>>>>        If (not(bIsFind) or iFile=Main_File(Self)) Begin
13807>>>>>            If (not(bIsFind)) Begin
13809>>>>>                // if a save, we care if it is committed.
13809>>>>>                Get IsCommitted to bCommit
13810>>>>>            End
13810>>>>>>
13810>>>>>            
13810>>>>>            // pass if Find (True) or save (False). We only care about commit on saves
13810>>>>>            // The setting of bIsForeign is an approximation. Foreign is really a DEO and and not
13810>>>>>            // a DD concept - in fact, at this point we don't really know. For example, a save in a header/dtl
13810>>>>>            // detail DEO (ordrdtl grid)has header DEOs that are not really foreign. This test errs on the side
13810>>>>>            // of assuming it's foreign. This would cause problems with incorrect parent NoPuts except we also
13810>>>>>            // set a flag, Field_NoPutValueChangedByDeo, when a field is changed via a NoPut DEO. The DD will still update
13810>>>>>            // foreign NoPuts unless this field flag is set.
13810>>>>>            Move (OPERATION_ORIGIN<>Self and Allow_Foreign_New_Save_State(Self)=0) to bIsForeign
13811>>>>>            Send Entry_Update of hoBuff bIsFind (If(bCommit,1,0) + If(bIsForeign,2,0))
13812>>>>>            
13812>>>>>            // also move data from extended dd fields to buffer
13812>>>>>            Send ExtendedFieldsUpdate (not(bIsFind))
13813>>>>>        End
13813>>>>>>
13813>>>>>        Set Visited_State to True
13814>>>>>        
13814>>>>>    End_Procedure
13815>>>>>    
13815>>>>>    // is this field NoPut based passed Commit and Foreign flags.
13815>>>>>    Function FieldNoPut Integer iField Boolean bIsCommited Boolean bIsForeign Returns Boolean
13817>>>>>        Boolean bNoPut
13817>>>>>        // this uses runtime logic - the same use for moving DD Buffer to Field Buffer
13817>>>>>        Get IsFieldDDNoPut of Record_Buffer iField (If(bIsCommited,1,0) + If(bIsForeign,2,0)) to bNoPut
13818>>>>>        Function_Return bNoPut
13819>>>>>    End_Function
13820>>>>>    
13820>>>>>    
13820>>>>>    // Check that Server data-sets exist for all required server file numbers
13820>>>>>    Function Valid_Servers Returns Integer
13822>>>>>        Integer iRval
13822>>>>>        Integer iCount
13822>>>>>        Integer iMax
13822>>>>>        Integer iDSO
13822>>>>>        Integer iPos
13822>>>>>        Integer iFile
13822>>>>>        String  sFiles
13822>>>>>        
13822>>>>>        // First assemble a string of all server file#s in ','##',' format
13822>>>>>        Move ',' to sFiles
13823>>>>>        Get Data_Set_Server_Count to iMax
13824>>>>>        Decrement iMax
13825>>>>>        For iCount from 0 to iMax
13831>>>>>>
13831>>>>>            Get Data_Set_Server iCount to iDSO
13832>>>>>            Move ( sFiles + String(Main_file(iDSO)) + ",") to sFiles
13833>>>>>        Loop
13834>>>>>>
13834>>>>>        
13834>>>>>        // Make sure each required File exists
13834>>>>>        Get Server_File_Count to iMax
13835>>>>>        Decrement iMax
13836>>>>>        For iCount from 0 to iMax
13842>>>>>>
13842>>>>>            Get Server_File iCount to iFile
13843>>>>>            Move (Pos ( ','+String(iFile)+',' , sFiles)) to iPos
13844>>>>>            If (iPos = 0) ;                Move iFile to iRVal
13847>>>>>        Until iRval
13849>>>>>        Function_Return iRVal
13850>>>>>    End_Function
13851>>>>>    
13851>>>>>    
13851>>>>>    // Check that Client data-sets exist for all required Client file numbers
13851>>>>>    Function Valid_Clients Returns Integer
13853>>>>>        Integer iRval
13853>>>>>        Integer iCount
13853>>>>>        Integer iMax
13853>>>>>        Integer iDSO
13853>>>>>        Integer iPos
13853>>>>>        Integer iFile
13853>>>>>        String  sFiles
13853>>>>>        
13853>>>>>        // First assemble a string of all Client file#s in ','##',' format
13853>>>>>        Move ',' to sFiles
13854>>>>>        Get Data_Set_Client_Count to iMax
13855>>>>>        Decrement iMax
13856>>>>>        For iCount from 0 to iMax
13862>>>>>>
13862>>>>>            Get Data_Set_Client iCount to iDSO
13863>>>>>            Move ( sFiles + String(Main_file(iDSO))+",") to sFiles
13864>>>>>        Loop
13865>>>>>>
13865>>>>>        
13865>>>>>        // Make sure each required File exists
13865>>>>>        Get Client_File_Count to iMax
13866>>>>>        Decrement iMax
13867>>>>>        For iCount from 0 to iMax
13873>>>>>>
13873>>>>>            Get Client_File iCount to iFile
13874>>>>>            Move (Pos( ','+String(iFile)+',', sFiles)) to iPos
13875>>>>>            If (iPos = 0) ;                Move iFile to iRVal
13878>>>>>        Until iRval
13880>>>>>        Function_Return iRVal
13881>>>>>    End_Function
13882>>>>>    
13882>>>>>    
13882>>>>>    // Validates save updating connections. If error returns file# that is
13882>>>>>    // expected and missing. If no error Set Validated_Save_connectio_State
13882>>>>>    // indicating that the connection validation has occurred and is ok
13882>>>>>    Function Validate_Save_Structure Integer ForceFg Returns Integer
13884>>>>>        Integer iRval
13884>>>>>        Integer iMode
13884>>>>>        If not ForceFg Begin
13886>>>>>            Get Validate_Save_Structure_Mode to iMode
13887>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and ;                Save_Structure_Validated_state(Self)=0 ) ) ;                to ForceFg
13888>>>>>        End
13888>>>>>>
13888>>>>>        If ForceFg Begin
13890>>>>>            Get Valid_Structure False to iRval
13891>>>>>            If (iRVal = 0) ;                Set Save_Structure_Validated_State to True
13894>>>>>        End
13894>>>>>>
13894>>>>>        Function_Return iRVal
13895>>>>>    End_Function
13896>>>>>    
13896>>>>>    // Validates Delete Structure. If cascade_state is true this must check
13896>>>>>    // up and down the tree. If no cascade_state just check up the tree.  If
13896>>>>>    // Ok, set Validated_Delete_no_Cascade_Connection_State and and or
13896>>>>>    // Validated_Delete_Cascade_Connection_State
13896>>>>>    // Pass: ForceFg - if TRUE force the validation.
13896>>>>>    Function Validate_Delete_Structure Integer ForceFg Returns Integer
13898>>>>>        Integer iCascade
13898>>>>>        Integer iMode
13898>>>>>        Integer iSt
13898>>>>>        Integer iRval
13898>>>>>        Get Cascade_delete_State to iCascade
13899>>>>>        If not ForceFg Begin
13901>>>>>            Get Validate_Delete_Structure_Mode to iMode
13902>>>>>            If (iMode=DD_VALIDATE_STRUCTURE_ONCE and iCascade );                Get Cascade_Delete_Structure_Validated_state to iSt
13905>>>>>            Else ;                Get No_Cascade_Delete_Structure_Validated_state to iSt
13907>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and iSt=0) ) to ForceFg
13908>>>>>        End
13908>>>>>>
13908>>>>>        
13908>>>>>        If ForceFg Begin
13910>>>>>            Get Valid_Structure iCascade to iRval
13911>>>>>            If (iRval = 0) Begin
13913>>>>>                Set No_Cascade_Delete_Structure_Validated_State to True
13914>>>>>                If iCascade ;                    Set Cascade_Delete_Structure_Validated_State to True
13917>>>>>            End
13917>>>>>>
13917>>>>>        End
13917>>>>>>
13917>>>>>        Function_Return iRval
13918>>>>>    End_Function
13919>>>>>    
13919>>>>>    
13919>>>>>    // This procedure will be called whenever the Data_Set wants its DEOs to
13919>>>>>    // write their values to the record buffer. The value of OPERATION_MODE
13919>>>>>    // determines if this is for finding an record or before saving a record.
13919>>>>>    // We use this event to tell our Record_Buffer to update the
13919>>>>>    // global record buffer.
13919>>>>>    // Modified to visit all server DSOs
13919>>>>>    // Note that this is only sent to the DSO starting the operation.
13919>>>>>    // We must manually send this to all server data-sets ourselves
13919>>>>>    // Note that during a DSO save this will get passed iFile=0 and iAll=3
13919>>>>>    // Changed to Support EntryUpdateLocalState (private)
13919>>>>>    // as of 17.0, EntryUpdateLocalState is True which means that entry_updates
13919>>>>>    // for finds now through the DD Buffer (saves always did).
13919>>>>>    Procedure Request_Entry_Update Integer iFile Integer iAll
13921>>>>>        If ((Operation_Mode=MODE_SAVING and iAll=3) or (EntryUpdateLocalState(Self)) ) Begin //3=dso save
13923>>>>>            If (OPERATION_MODE=MODE_WAITING) Begin
13925>>>>>                // we will only not be in an operation if we are doing a find with EntryUpdateLocalState
13925>>>>>                // set to true. In such a case make this a finding. I am not this is actually needed
13925>>>>>                Send Update_Focus_Field_For_Operation MODE_FINDING
13926>>>>>            End
13926>>>>>>
13926>>>>>            Else Begin
13927>>>>>                // if here we already have an operation_mode so there is no need to do anything special
13927>>>>>                Send Update_Focus_Field // Make sure buffer has latest focus item changes
13928>>>>>            End
13928>>>>>>
13928>>>>>            Send Initialize_Visited False False // Clear up, do not clear fields
13929>>>>>            Send Entry_Update_Data_Sets iFile iAll
13930>>>>>        End
13930>>>>>>
13930>>>>>        Forward Send Request_Entry_Update iFile iAll
13932>>>>>    End_Procedure
13933>>>>>    
13933>>>>>    
13933>>>>>    
13933>>>>>    // Forces the focus field to get update its value with the data-set.
13933>>>>>    // This insures that the DSO and DEO contain the same values.
13933>>>>>    Procedure Update_Focus_Field
13935>>>>>        Integer iFocObj
13935>>>>>        Get Focus of desktop to iFocObj
13936>>>>>        If (Extended_DEO_State(iFocObj)) ;            Send Update_Focus_Field to iFocObj
13939>>>>>    End_Procedure
13940>>>>>    
13940>>>>>    // very internal. Used to set Operation_mode and Operation_origin before the
13940>>>>>    // update. A developer can use this in the DEO to know what state the update is in.
13940>>>>>    // This was created because a DEO value change will trigger an OnChange event and you
13940>>>>>    // can look at this and know that this is part of a DD operation.
13940>>>>>    // This is *only* called by the DD operations in this class and the change is made for as
13940>>>>>    // small of a period as possible.
13940>>>>>    Procedure Update_Focus_Field_For_Operation Integer iOperationMode
13942>>>>>        Integer iOldMode iOldOrigin
13942>>>>>        
13942>>>>>        Move OPERATION_MODE to iOldMode
13943>>>>>        Move OPERATION_ORIGIN to iOldOrigin
13944>>>>>        Move iOperationMode to OPERATION_MODE
13945>>>>>        Move Self to OPERATION_ORIGIN
13946>>>>>        Send Update_Focus_Field
13947>>>>>        Move iOldMode to OPERATION_MODE
13948>>>>>        Move iOldOrigin to OPERATION_ORIGIN
13949>>>>>    End_Procedure
13950>>>>>    
13950>>>>>    
13950>>>>>    // Augment to validate all field values that do not get
13950>>>>>    // validated as part of the item validation process. The advantage
13950>>>>>    // of item validation (over only field validation) is that an error
13950>>>>>    // returns you to the offending item.
13950>>>>>    Function Request_Validate Returns Integer
13952>>>>>        Integer iRetval iOldOrigin iOldMode iRetVal2
13952>>>>>        Handle[] DDsWithFindReqErrors
13953>>>>>        
13953>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13955>>>>>            Send Update_Focus_Field_For_Operation MODE_VALIDATING // added 12.1/15.1
13956>>>>>        End
13956>>>>>>
13956>>>>>        Move Operation_Origin to iOldOrigin
13957>>>>>        Move Self to Operation_Origin
13958>>>>>        Move Operation_Mode to iOldMode
13959>>>>>        // clear all find req DD markers at the origin of the validate request. When request validates occur
13959>>>>>        // they will get added to this array and can be tested to see of such an error has occurred.
13959>>>>>        Set pDDsWithFindReqErrors to DDsWithFindReqErrors
13960>>>>>        // Prior to VDF7, we set this to Mode_Saving. We now have a special mode just for request_validate.
13960>>>>>        // We do this because:
13960>>>>>        //   1) because it is useful (more detail never hurts) and
13960>>>>>        //   2) we will allow set_field_current_value to update when mode_validation is set
13960>>>>>        Move MODE_VALIDATING to Operation_Mode
13961>>>>>        Send Initialize_Visited False True //false=up only, true=clear fields
13962>>>>>        Forward Get Request_Validate to iRetval // normal deo validate
13964>>>>>        // If DEO validation failed, do not validate other fields unless Validate_All_Fields is set
13964>>>>>        If ( (iRetval=0 or (Validate_All_Fields_State(Self))) and Validate_DEOs_Only_State(Self)=0) Begin
13966>>>>>            Get Validate_Data_Sets False (Validate_All_Fields_State(Self)) to iRetval2
13967>>>>>            Move (iRetval or iRetVal2) to iRetval
13968>>>>>        End
13968>>>>>>
13968>>>>>        
13968>>>>>        If (iRetval=0) Begin
13970>>>>>            Get ValidateSwitchedCommittedParents True to iRetval
13971>>>>>        End
13971>>>>>>
13971>>>>>        
13971>>>>>        Move iOldMode   to Operation_Mode
13972>>>>>        Move iOldOrigin to Operation_Origin
13973>>>>>        Function_Return iRetval
13974>>>>>    End_Function
13975>>>>>    
13975>>>>>    Function Request_Validate_All Returns Integer
13977>>>>>        Integer bOld iRetVal
13977>>>>>        Get Validate_All_Fields_State to bOld
13978>>>>>        Set Validate_All_Fields_State to True
13979>>>>>        Get request_validate to iretVal
13980>>>>>        Set Validate_All_Fields_State to bOld
13981>>>>>        Function_Return iRetval
13982>>>>>    End_Function
13983>>>>>    
13983>>>>>    
13983>>>>>    
13983>>>>>    // Like Item_find except entry-update is forced through the DD, not DEO
13983>>>>>    Procedure File_Field_Find Integer iFindMode Integer iFile Integer iField ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
13985>>>>>        Integer bOld
13985>>>>>        Get EntryUpdateLocalState to bOld
13986>>>>>        Set EntryUpdateLocalState to True
13987>>>>>        Send Item_Find iFindMode iFile iField bEntUpdt bShowErr bDfrd
13988>>>>>        Set EntryUpdateLocalState to bOld
13989>>>>>    End_Procedure
13990>>>>>    
13990>>>>>    // Autofind for requestd file, field and mode.
13990>>>>>    //    If mode not passed, EQ is assummed
13990>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iFindMode
13992>>>>>        Integer eMode
13992>>>>>        If iFile  Begin
13994>>>>>            // if no 3rd argument, default to autofind
13994>>>>>            Move (If(Num_Arguments<3,EQ,iFindMode)) to eMode
13995>>>>>            Send File_Field_Find eMode iFile iField True False False
13996>>>>>        End
13996>>>>>>
13996>>>>>    End_Procedure
13997>>>>>    
13997>>>>>    // Autofind in default mode (does not set changed states). Can be used
13997>>>>>    // within Clear and Clear_all to autofind parents. Parent values can be
13997>>>>>    // maintained using retainAll option
13997>>>>>    Procedure File_Field_Default_AutoFind Integer iFile Integer iField
13999>>>>>        Integer iOldState
13999>>>>>        Handle  hoDD
13999>>>>>        Get Data_set iFile to hoDD
14000>>>>>        If hoDD Begin
14002>>>>>            Get Change_disabled_State of hoDD to iOldState
14003>>>>>            Set Change_disabled_State of hoDD to True
14004>>>>>            Send File_Field_AutoFind  of hoDD iFile iField EQ
14005>>>>>            Set Change_disabled_State of hoDD to iOldState
14006>>>>>            Set changed_state to False
14007>>>>>        End
14007>>>>>>
14007>>>>>    End_Procedure
14008>>>>>    
14008>>>>>    // File_Index_find
14008>>>>>    // Like item_find except you pass the index you want to find with and
14008>>>>>    // ent-update occurs through DDO buffers not deo buffers.
14008>>>>>    // This is currently private and is only used by web-applications
14008>>>>>    Procedure File_Index_Find Integer iFindMode Integer iFile Integer iIndex ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
14010>>>>>        Integer bOld
14010>>>>>        RowID riRec
14010>>>>>        Integer wasChanged hDD iOldStat
14010>>>>>        Boolean bOk
14010>>>>>        
14010>>>>>        Get Data_Set iFile to hDD
14011>>>>>        If (hDD=0) Begin
14013>>>>>            Error DFERR_PROGRAM C_$CannotFindDD
14014>>>>>>
14014>>>>>            Procedure_Return
14015>>>>>        End
14015>>>>>>
14015>>>>>        
14015>>>>>        Get EntryUpdateLocalState to bOld
14016>>>>>        Set EntryUpdateLocalState to True
14017>>>>>        
14017>>>>>        //  'hold' buffer to prepare for entry_update
14017>>>>>        Move (getRowId(iFile)) to riRec
14018>>>>>        Get_Attribute DF_FILE_STATUS of iFile to iOldStat
14021>>>>>        Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
14024>>>>>        
14024>>>>>        If bEntUpdt Begin
14026>>>>>            Send Request_Entry_Update to hDD iFile 1  //entUpdt all DEOs as required
14027>>>>>            
14027>>>>>            //
14027>>>>>            // we really only need to know if any segment of the index changed
14027>>>>>            // but since we don't have field-changed flags, we look at the
14027>>>>>            // whole recbuf - this is consistent with 2.3b and 3.0 non-dataset
14027>>>>>            // behavior.
14027>>>>>            //
14027>>>>>            Move (iOldStat<>DF_FILE_INACTIVE) to wasChanged
14028>>>>>            If not wasChanged ;                Get_Attribute DF_FILE_CHANGED of iFile to wasChanged
14033>>>>>            If not wasChanged ;                Constrained_Clear iFindMode iFile by iIndex
14038>>>>>            
14038>>>>>        End
14038>>>>>>
14038>>>>>        Move False to Err
14039>>>>>        If bDfrd ;            Send Request_Read iFindMode iFile iIndex
14042>>>>>        Else ;            Send Request_Find iFindMode iFile iIndex
14044>>>>>        If (not(Found) and  not(err)) Begin
14046>>>>>            // refind original record (or leave it cleared if not record)
14046>>>>>            Move (FindByRowId(iFile,riRec)) to bOk
14047>>>>>            
14047>>>>>            If bShowErr ;                Error (If(iFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
14050>>>>>            Move False to Err
14051>>>>>        End
14051>>>>>>
14051>>>>>        Set EntryUpdateLocalState to bOld
14052>>>>>    End_Procedure
14053>>>>>    
14053>>>>>    // This does a refind of all records based on the contents of the
14053>>>>>    // refine_record_id property.
14053>>>>>    // This would be used after clearing the DDs and loading the local rencum
14053>>>>>    // buffer with recnums. This can be used by remote DEOs (BPOs).
14053>>>>>    //
14053>>>>>    // Find all existing records. This must be done in bottom-up, breadth
14053>>>>>    // first order. i.e., Start with the passed DD, find it and then find for
14053>>>>>    // parents. Only find if the record is non-zero and it is different than
14053>>>>>    // the current_record.
14053>>>>>    // This order will allow us to support changed parents.
14053>>>>>    // Don't use this if you do not understand what it does.
14053>>>>>    // Private.Find_Records is a helper. We will keep this private because
14053>>>>>    // it is rather specialized and only used by WebApp.
14053>>>>>    Procedure Find_Records
14055>>>>>        Send Initialize_Visited False False // Clear up, do not clear fields
14056>>>>>        Send Private.Find_Records           // refind all records in upward sweep
14057>>>>>    End_Procedure
14058>>>>>    
14058>>>>>    
14058>>>>>    Procedure Private.Find_Records
14060>>>>>        Integer hPrnt
14060>>>>>        Integer iMax
14060>>>>>        Integer iCount
14060>>>>>        RowID riRec
14060>>>>>        Integer iRec iMain
14060>>>>>        // works with both recId and rowId. Only one should ever be set.
14060>>>>>        // find(clear) record, if needed
14060>>>>>        Get Main_File to iMain
14061>>>>>        // assume that either prFindRowId or Find_record_id has a value - never both
14061>>>>>        // also assume Find_record_id only has values when you are using a recnum table
14061>>>>>        Get prFindRowId to riRec
14062>>>>>        If not (IsNullRowId(riRec)) Begin
14064>>>>>            If not (IsSameRowId(riRec, CurrentRowId(Self) ) ) Begin
14066>>>>>                Send FindByRowId iMain riRec // find an Relate all parents
14067>>>>>            End
14067>>>>>>
14067>>>>>            Set prFindRowId to (NullRowId())  // reset refind rec back to zero.
14068>>>>>        End
14068>>>>>>
14068>>>>>        Else Begin
14069>>>>>            // if this has a recnum, it better be a recnum table or an error will occur.
14069>>>>>            // This is not being tested for a recnum table on purpose. If someone is setting Find_record_id
14069>>>>>            // on a non-recnum table, they doing something wrong. An Error will be a good thing.
14069>>>>>            Get Find_Record_Id to iRec
14070>>>>>            If iRec Begin
14072>>>>>                If (iRec<>Current_record(Self)) Begin
14074>>>>>                    Send Find_By_Recnum iMain iRec // find an Relate all parents
14075>>>>>                End
14075>>>>>>
14075>>>>>                Set Find_record_id to 0 // reset refind rec back to zero.
14076>>>>>            End
14076>>>>>>
14076>>>>>        End
14076>>>>>>
14076>>>>>        Set Visited_State to True
14077>>>>>        
14077>>>>>        // recurse and do the same to all parent files
14077>>>>>        // in almost all cases, there will be no new finding here since the relate has
14077>>>>>        // found the records. If the record is different than the relate, we have
14077>>>>>        // a switched parent state (should_save will be set appropriately).
14077>>>>>        Get Data_Set_Server_Count to iMax
14078>>>>>        Decrement iMax
14079>>>>>        For iCount from 0 to iMax
14085>>>>>>
14085>>>>>            Get Data_Set_Server iCount to hPrnt
14086>>>>>            If not (Visited_state(hPrnt)) ;                Send Private.Find_Records to hPrnt
14089>>>>>        Loop
14090>>>>>>
14090>>>>>    End_Procedure
14091>>>>>    
14091>>>>>    // This Mark_Id creates a sequence Id for this clear. This way
14091>>>>>    // DDOs only get cleared one time during this process.
14091>>>>>    Procedure IncrementCurrentMarkId
14093>>>>>        If (DD_Current_Mark_ID>65536) Begin
14095>>>>>            Move 0 to DD_Current_Mark_id
14096>>>>>        End
14096>>>>>>
14096>>>>>        Increment DD_Current_Mark_id
14097>>>>>    End_Procedure
14098>>>>>    
14098>>>>>    
14098>>>>>    // private use by new webapp framework as of 18.2.
14098>>>>>    // pass bStart as True if this is the start of the resynch.
14098>>>>>    Function ReSyncRecords Boolean bStart Returns Handle
14100>>>>>        RowID riRowId riCrnt
14100>>>>>        Boolean bOk bOldReSync bVisited
14100>>>>>        Handle hoOtherDDO hoBadDDO hoBadPrntDDO
14100>>>>>        Integer iMax iCount iMain
14100>>>>>
14100>>>>>        If bStart Begin
14102>>>>>            Send InitializeAllVisited
14103>>>>>        End
14103>>>>>>
14103>>>>>        
14103>>>>>        // we want depth first traversal. Make sure children are handled before parents
14103>>>>>        // Recursively traverse Children, Find by RowId, Recursively traverse Parents
14103>>>>>        // Use visited_state logic to avoid multiple visits caused by diamond DDO strutures
14103>>>>>        
14103>>>>>        //mark first so we don't visit this coming back up.
14103>>>>>        Set Visited_State to True
14104>>>>>        
14104>>>>>        // traverse downward first
14104>>>>>        Get Data_Set_Client_Count to iMax
14105>>>>>        For iCount from 0 to (iMax-1)
14111>>>>>>
14111>>>>>            Get Data_Set_Client iCount to hoOtherDDO
14112>>>>>            Get Visited_State of hoOtherDDO to bVisited
14113>>>>>            If not bVisited Begin
14115>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
14116>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
14118>>>>>                    Move hoBadPrntDDO to hoBadDDO
14119>>>>>                End
14119>>>>>>
14119>>>>>            End
14119>>>>>>
14119>>>>>        Loop
14120>>>>>>
14120>>>>>        
14120>>>>>        // Find record for DD. It might already be correct if child has already
14120>>>>>        // related it in. If not correct after a relate, this has been switched by this
14120>>>>>        // user or switched by another user, in which case it will be swtitched back
14120>>>>>        // (DDOs have always worked this way).
14120>>>>>        Get prFindRowId to riRowId
14121>>>>>        Get Main_File to iMain
14122>>>>>        Get CurrentRowId to riCrnt
14123>>>>>        If ( not(IsSameRowId(riRowID, riCrnt)) ) Begin
14125>>>>>            Get pbInReSync to bOldReSync
14126>>>>>            Set pbInReSync to True
14127>>>>>            
14127>>>>>            If (IsNullRowId(riRowID)) Begin
14129>>>>>                Send Clear
14130>>>>>            End
14130>>>>>>
14130>>>>>            Else Begin
14131>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
14132>>>>>                If not bOk Begin
14134>>>>>                    Move Self to hoBadDDO
14135>>>>>                End
14135>>>>>>
14135>>>>>            End
14135>>>>>>
14135>>>>>            Set pbInReSync to bOldReSync
14136>>>>>        End
14136>>>>>>
14136>>>>>        
14136>>>>>        // finally traverse to parents
14136>>>>>        Get Data_Set_Server_Count to iMax
14137>>>>>        For iCount from 0 to (iMax-1)
14143>>>>>>
14143>>>>>            Get Data_Set_Server iCount to hoOtherDDO
14144>>>>>            Get Visited_State of hoOtherDDO to bVisited
14145>>>>>            If not bVisited Begin
14147>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
14148>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
14150>>>>>                    Move hoBadPrntDDO to hoBadDDO
14151>>>>>                End
14151>>>>>>
14151>>>>>            End
14151>>>>>>
14151>>>>>        Loop
14152>>>>>>
14152>>>>>        
14152>>>>>        If bStart Begin
14154>>>>>            Send InitializeAllVisited
14155>>>>>            Send ResetChangedStates
14156>>>>>        End
14156>>>>>>
14156>>>>>        
14156>>>>>        Function_Return hoBadDDO
14157>>>>>    End_Function
14158>>>>>    
14158>>>>>
14158>>>>>    Procedure ResetChangedStates
14160>>>>>        Boolean bVisited
14160>>>>>        Handle hoOtherDDO
14160>>>>>        Integer iMax iCount
14160>>>>>        tDDChangedInfo DDChangedInfo
14160>>>>>        tDDChangedInfo DDChangedInfo
14160>>>>>                
14160>>>>>        // we want depth first traversal.
14160>>>>>        //mark first so we don't visit this coming back up.
14160>>>>>        Set Visited_State to True
14161>>>>>        
14161>>>>>        // traverse downward first
14161>>>>>        Get Data_Set_Client_Count to iMax
14162>>>>>        For iCount from 0 to (iMax-1)
14168>>>>>>
14168>>>>>            Get Data_Set_Client iCount to hoOtherDDO
14169>>>>>            Get Visited_State of hoOtherDDO to bVisited
14170>>>>>            If not bVisited Begin
14172>>>>>                Send ResetChangedStates of hoOtherDDO
14173>>>>>            End
14173>>>>>>
14173>>>>>        Loop
14174>>>>>>
14174>>>>>        
14174>>>>>        // Set changed states for this DDO
14174>>>>>        Get pDDChangedInfo to DDChangedInfo
14175>>>>>        Set Changed_State to False // clears changed_state and parent_changed_states            
14176>>>>>        Set Changed_State to DDChangedInfo.bChanged            
14177>>>>>        For iCount from 0 to (SizeOfArray(DDChangedInfo.ParentChanged)-1)
14183>>>>>>
14183>>>>>            Send SetParentDDOSwitched DDChangedInfo.ParentChanged[iCount].iTable DDChangedInfo.ParentChanged[iCount].bSwitched
14184>>>>>        Loop
14185>>>>>>
14185>>>>>        
14185>>>>>        // finally traverse to parents
14185>>>>>        Get Data_Set_Server_Count to iMax
14186>>>>>        For iCount from 0 to (iMax-1)
14192>>>>>>
14192>>>>>            Get Data_Set_Server iCount to hoOtherDDO
14193>>>>>            Get Visited_State of hoOtherDDO to bVisited
14194>>>>>            If not bVisited Begin
14196>>>>>                Send ResetChangedStates of hoOtherDDO
14197>>>>>            End
14197>>>>>>
14197>>>>>        Loop
14198>>>>>>
14198>>>>>        
14198>>>>>    End_Procedure
14199>>>>>
14199>>>>>    // private use by new webapp framework (pre 18.2)
14199>>>>>    Function ReSyncRecord Returns Boolean
14201>>>>>        RowID riRowId
14201>>>>>        Boolean bOk bOldReSync
14201>>>>>        Handle hPrnt
14201>>>>>        Integer iMax iCount iMain
14201>>>>>        
14201>>>>>        Get pbInReSync to bOldReSync
14202>>>>>        
14202>>>>>        Get prFindRowId to riRowId
14203>>>>>        Get Main_File to iMain
14204>>>>>        If not (IsSameRowId(riRowID, CurrentRowId(Self) ) ) Begin
14206>>>>>            If (IsNullRowId(riRowID)) Begin
14208>>>>>                Set pbInReSync to True
14209>>>>>                Send Clear
14210>>>>>                Set pbInReSync to bOldReSync
14211>>>>>            End
14211>>>>>>
14211>>>>>            Else Begin
14212>>>>>                Set pbInReSync to True
14213>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
14214>>>>>                Set pbInReSync to bOldReSync
14215>>>>>                If not bOk Begin
14217>>>>>                    Function_Return False
14218>>>>>                End
14218>>>>>>
14218>>>>>            End
14218>>>>>>
14218>>>>>            
14218>>>>>            // check that the relate found all the parent records we expect.
14218>>>>>            // This should be correct unless a parent has been switched. Constrained
14218>>>>>            // parents, by definition, should already be correct. See **Note** below
14218>>>>>            Get Data_Set_Server_Count to iMax
14219>>>>>            For iCount from 0 to (iMax-1)
14225>>>>>>
14225>>>>>                Get Data_Set_Server iCount to hPrnt
14226>>>>>                If (Constrain_File(Self)<>Main_File(hPrnt) and ;                    not (IsSameRowID(prFindRowId(hPrnt),CurrentRowId(hPrnt)))) Begin
14228>>>>>                    // the parent is either wrong or not processed yet. Either way
14228>>>>>                    // make it right.
14228>>>>>                    Get ReSyncRecord of hPrnt to bOk
14229>>>>>                    If not bOk Begin
14231>>>>>                        Function_Return False
14232>>>>>                    End
14232>>>>>>
14232>>>>>                End
14232>>>>>>
14232>>>>>            Loop
14233>>>>>>
14233>>>>>        End
14233>>>>>>
14233>>>>>        
14233>>>>>        Function_Return True
14234>>>>>    End_Function
14235>>>>>    
14235>>>>>    // **Note** - dealing with changed parents and diamonds during a resync.
14235>>>>>    // If there is not a relates-to contraint between DD and child it is possible
14235>>>>>    // that the child find's relate will change the just found parent DD.
14235>>>>>    // Assuming this is not a structure bug, it means the parent is changed parent and that
14235>>>>>    // change must occur after the child record has been found and related. Therefore we add
14235>>>>>    // check after each child find to see if an parent is incorrect. If it is, either it is a
14235>>>>>    // switched parent or we haven't processed it yet. If the record is fine it
14235>>>>>    // just does nothing. For example (where *=relates-to):
14235>>>>>    //     W
14235>>>>>    //   */  \*
14235>>>>>    //   X    Y
14235>>>>>    //    \  /*
14235>>>>>    //     Z
14235>>>>>    // Assume you found a Z and changed its parent X.
14235>>>>>    // The refind order can be: WXZY or WYZX
14235>>>>>    // If WXZY the refound parent will be lost because Z will relate after the X
14235>>>>>    // find and replace it with the original parent. To control this we add this check
14235>>>>>    // after child Z has done its work. We only need to do this when child DDOs exist
14235>>>>>    // that are not constrained. This can change the order that DDOs are resynced but it
14235>>>>>    // should not matter.
14235>>>>>    
14235>>>>>    
14235>>>>>    
14235>>>>>    // Private use by new webapp framework
14235>>>>>    Procedure ReSyncClearAll
14237>>>>>        Boolean bOldReSync
14237>>>>>        Get pbInReSync to bOldReSync
14238>>>>>        // we need this to stop RememberLast and retains. We don't want those during a resyc clear
14238>>>>>        Set pbInReSync to True
14239>>>>>        Send Clear_All
14240>>>>>        Set pbInReSync to bOldReSync
14241>>>>>    End_Procedure
14242>>>>>    
14242>>>>>    // returns table name for error display. By default it returns the logical name
14242>>>>>    // can be augmented to return other information
14242>>>>>    Function ErrorMessageTableName Integer iTable Returns String
14244>>>>>        String sTable
14244>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTable
14247>>>>>        Function_Return sTable
14248>>>>>    End_Function
14249>>>>>    
14249>>>>>    
14249>>>>>    // Augmented to test updating connections.
14249>>>>>    // If error report it.
14249>>>>>    Procedure Request_Save
14251>>>>>        Integer iRval
14251>>>>>        String sTable
14251>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14253>>>>>            Send Update_Focus_Field_For_Operation MODE_SAVING // added in 12.1/15.1
14254>>>>>            Get Validate_Save_Structure False to iRval
14255>>>>>            If iRval Begin
14257>>>>>                Get ErrorMessageTableName iRval to sTable
14258>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
14259>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_INVALID_SAVE_STRUCTURE sTable
14260>>>>>                Procedure_Return
14261>>>>>            End
14261>>>>>>
14261>>>>>        End
14261>>>>>>
14261>>>>>        Forward Send Request_Save
14263>>>>>    End_Procedure
14264>>>>>    
14264>>>>>    // Augmented to test updating connections.
14264>>>>>    // If error report it.
14264>>>>>    Procedure Request_Delete
14266>>>>>        Integer iRval
14266>>>>>        String sTable
14266>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14268>>>>>            Send Update_Focus_Field_For_Operation MODE_DELETING // added to 12.1/15.1
14269>>>>>            Get Validate_Delete_Structure False to iRval
14270>>>>>            If iRval Begin
14272>>>>>                Get ErrorMessageTableName iRval to sTable
14273>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
14274>>>>>                Send data_Set_Error -1 DFERR_PROGRAM DD_INVALID_DELETE_STRUCTURE sTable
14275>>>>>                Procedure_Return
14276>>>>>            End
14276>>>>>>
14276>>>>>        End
14276>>>>>>
14276>>>>>        Forward Send Request_Delete
14278>>>>>    End_Procedure
14279>>>>>    
14279>>>>>    // Set status-line help for the passed field. This could have been named
14279>>>>>    // Set Field_Status_Help but this keeps this message interface consistent
14279>>>>>    // with the rest of DF for windows.
14279>>>>>    Procedure Set Status_Help Integer iField String sVal
14281>>>>>        Set Value of (StatusHelp_Array(Self)) iField to sVal
14282>>>>>    End_Procedure
14283>>>>>    
14283>>>>>    // Get status-line help for the passed field. This could have been named
14283>>>>>    // Get Field_Status_Help but this keeps this message interface consistent
14283>>>>>    // with the rest of DF for windows.
14283>>>>>    Function Status_Help Integer iField Returns String
14285>>>>>        String sHelp
14285>>>>>        Integer iObj
14285>>>>>        Move (StatusHelp_Array(Self)) to iObj
14286>>>>>        If (Item_Count(iObj)>iField) Begin
14288>>>>>            Get value of iObj iField to sHelp
14289>>>>>            If (sHelp = '0') ;                Move '' to shelp
14292>>>>>        End
14292>>>>>>
14292>>>>>        Function_Return shelp
14293>>>>>    End_Function
14294>>>>>    
14294>>>>>    // Get status-line help for the passed file and field. This is called
14294>>>>>    // by DEOs (or any other object) that needs help for a particular file
14294>>>>>    // and field.
14294>>>>>    Function File_Field_Status_Help Integer iFile Integer iField Returns String
14296>>>>>        Integer iDSO
14296>>>>>        String sValue
14296>>>>>        Get Data_set iFile to iDSO
14297>>>>>        If iDSO ;            Get Status_Help of iDSO iField to sValue
14300>>>>>        Function_Return sValue
14301>>>>>    End_Function
14302>>>>>    
14302>>>>>    // Allows user to set a mask type. Legal value is any of the current mask
14302>>>>>    // window types. 0 Means undefined.
14302>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
14304>>>>>        Set Field_Mask_Type of (FieldMask_Array(Self)) iField to iType
14305>>>>>    End_Procedure
14306>>>>>    
14306>>>>>    Function Field_Mask_Type Integer iField Returns Integer
14308>>>>>        Function_Return (Field_Mask_Type(FieldMask_Array(Self),iField))
14309>>>>>    End_Function
14310>>>>>    
14310>>>>>    Function File_Field_Mask_Type Integer iFile Integer iField Returns Integer
14312>>>>>        Integer iDSO
14312>>>>>        Get Data_set iFile to iDSO
14313>>>>>        If iDSO ;            Function_Return (Field_Mask_Type(iDSO,iField))
14316>>>>>    End_Function
14317>>>>>    
14317>>>>>    // If TRUE the value returned by DEO will contain mask characters.
14317>>>>>    // Currently not supported.
14317>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
14319>>>>>        Set Field_Mask_Value_State of (FieldMask_Array(Self)) iField to iState
14320>>>>>    End_Procedure
14321>>>>>    
14321>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
14323>>>>>        Function_Return (Field_Mask_Value_State(FieldMask_Array(Self),iField))
14324>>>>>    End_Function
14325>>>>>    
14325>>>>>    Function File_Field_Mask_Value_State Integer iFile Integer iField Returns Integer
14327>>>>>        Integer iDSO
14327>>>>>        Get Data_set iFile to iDSO
14328>>>>>        If iDSO ;            Function_Return (Field_Mask_Value_State(iDSO,iField))
14331>>>>>    End_Function
14332>>>>>    
14332>>>>>    // Allows user to set a mask strinng. Legal value is any of the current
14332>>>>>    // masks. Note an empty string with a valid mask type implies that the
14332>>>>>    // system should figure it out by itself.
14332>>>>>    Procedure Set Field_Mask Integer iField String sMask
14334>>>>>        Set Field_Mask of (FieldMask_Array(Self)) iField to sMask
14335>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Mask_Changed iField sMask
14338>>>>>    End_Procedure
14339>>>>>    
14339>>>>>    Function Field_Mask Integer iField Returns String
14341>>>>>        Function_Return (Field_Mask(FieldMask_Array(Self),iField))
14342>>>>>    End_Function
14343>>>>>    
14343>>>>>    Function File_Field_Mask Integer iFile Integer iField Returns String
14345>>>>>        Integer iDSO
14345>>>>>        String sValue
14345>>>>>        Get Data_set iFile to iDSO
14346>>>>>        If iDSO ;            Get Field_Mask of iDSO iField to sValue
14349>>>>>        Function_Return sValue
14350>>>>>    End_Function
14351>>>>>    
14351>>>>>    // Short for field. This is normally used by grid headers.
14351>>>>>    Procedure Set Field_Label_Short Integer iField String sName
14353>>>>>        Set Field_Label_Short of (FieldMask_Array(Self)) iField to sName
14354>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 0 sName
14357>>>>>    End_Procedure
14358>>>>>    
14358>>>>>    Function Field_Label_Short Integer iField Returns String
14360>>>>>        Function_Return (Field_Label_Short(FieldMask_Array(Self),iField))
14361>>>>>    End_Function
14362>>>>>    
14362>>>>>    Function File_Field_Label_Short Integer iFile Integer iField Returns String
14364>>>>>        Integer iDSO
14364>>>>>        String sValue
14364>>>>>        Get Data_set iFile to iDSO
14365>>>>>        If iDSO ;            Get Field_Label_Short of iDSO iField to sValue
14368>>>>>        Function_Return sValue
14369>>>>>    End_Function
14370>>>>>    
14370>>>>>    // Full Name for field. This is normally used by form labels
14370>>>>>    Procedure Set Field_Label_Long Integer iField String sName
14372>>>>>        Set Field_Label_Long of (FieldMask_Array(Self)) iField to sName
14373>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 1 sName
14376>>>>>    End_Procedure
14377>>>>>    
14377>>>>>    Function Field_Label_Long Integer iField Returns String
14379>>>>>        Function_Return (Field_Label_Long(FieldMask_Array(Self),iField))
14380>>>>>    End_Function
14381>>>>>    
14381>>>>>    Function File_Field_Label_Long Integer iFile Integer iField Returns String
14383>>>>>        Integer iDSO
14383>>>>>        String sValue
14383>>>>>        Get Data_set iFile to iDSO
14384>>>>>        If iDSO ;            Get Field_Label_Long of iDSO iField to sValue
14387>>>>>        Function_Return sValue
14388>>>>>    End_Function
14389>>>>>    
14389>>>>>    // This is not really a DD attribute (it is in the API) but it is
14389>>>>>    // appropriate to be accessed from the DD
14389>>>>>    Function Field_Label_Tag Integer iField Returns String
14391>>>>>        String sName
14391>>>>>        Integer iFile
14391>>>>>        Get Main_File to iFile
14392>>>>>        If iFile ;            Get_Attribute DF_FIELD_NAME of iFile iField to sName
14397>>>>>        Function_Return sName
14398>>>>>    End_Function
14399>>>>>    
14399>>>>>    Function SmartCase String sName Returns String
14401>>>>>        Integer iPos iNewPos
14401>>>>>        String sRight
14401>>>>>        Move (Replaces("_",lowercase(sName)," ")) to sName
14402>>>>>        Move (Trim (Replaces(".",sName," "))) to sName
14403>>>>>        Move 1 to iPos
14404>>>>>        Repeat
14404>>>>>>
14404>>>>>            Move (mid(sName,255,iPos+1)) to sRight
14405>>>>>            Move (left(sName,iPos-1) + Uppercase(mid(sName,1,iPos)) + sRight) to sName
14406>>>>>            Move (Pos( " ", sRight)) to iNewPos
14407>>>>>            If (iNewPos = 0) ;                Break
14410>>>>>            Add (iNewPos+1) to iPos
14411>>>>>        Loop
14412>>>>>>
14412>>>>>        Function_Return sName
14413>>>>>    End_Function
14414>>>>>    
14414>>>>>    Enumeration_List
14414>>>>>        Define DD_LABEL_SHORT
14414>>>>>        Define DD_LABEL_LONG
14414>>>>>        Define DD_LABEL_TAG
14414>>>>>    End_Enumeration_List
14414>>>>>    
14414>>>>>    // Handy function to get the label for a field. Three "types" are
14414>>>>>    // supported:
14414>>>>>    // DD_LABEL_SHORT  use short, if none use long, if none use smart tag
14414>>>>>    // DD_LABEL_LONG   use long, if none use smart tag
14414>>>>>    // DD_LABEL_TAG    use smart tag
14414>>>>>    // If you want an explicit field name use oneof the other messages.
14414>>>>>    Function Field_Label Integer iField Integer iType Returns String
14416>>>>>        Integer iServer
14416>>>>>        String sValue
14416>>>>>        If (iType = DD_LABEL_SHORT) ;  // 0 = Short            Get Field_Label_Short iField to sValue
14419>>>>>        If (iType = DD_LABEL_LONG or (iType=DD_LABEL_SHORT and sValue='')) ;            Get Field_Label_Long iField to sValue
14422>>>>>        If (iType = DD_LABEL_TAG or sValue="") Begin
14424>>>>>            Get Field_Label_Tag iField to sValue
14425>>>>>            Get SmartCase sValue to sValue
14426>>>>>        End
14426>>>>>>
14426>>>>>        Function_Return sValue
14427>>>>>    End_Function
14428>>>>>    
14428>>>>>    Function File_Field_Label Integer iFile Integer iField Integer iType Returns String
14430>>>>>        Integer iDSO
14430>>>>>        String sValue
14430>>>>>        Get Data_set iFile to iDSO
14431>>>>>        If iDSO ;            Get Field_Label of iDSO iField iType to sValue
14434>>>>>        Function_Return sValue
14435>>>>>    End_Function
14436>>>>>    
14436>>>>>    // Normally this will not be used by a running program. However, it
14436>>>>>    // could be possible to create classes dynamically at runtime, in which
14436>>>>>    // case these messages could be useful. No File_Field is provided. If the
14436>>>>>    // person knows enough to create dynamic classes they can find the DD.
14436>>>>>    Procedure Set Field_Class_Name Integer iField String sName
14438>>>>>        Set Field_Class_Name of (FieldMask_Array(Self)) iField to sName
14439>>>>>    End_Procedure
14440>>>>>    
14440>>>>>    Function Field_Class_Name Integer iField Returns String
14442>>>>>        Function_Return (Field_Class_Name(FieldMask_Array(Self),iField))
14443>>>>>    End_Function
14444>>>>>    
14444>>>>>    // This procedure should be used to set a specific error number and
14444>>>>>    // message for a particular field. This can be used with the Field_error
14444>>>>>    // message to generate this error during a validation.
14444>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
14446>>>>>        Set Field_Error of (Field_Attributes(Self)) iField to iErr sMsg
14447>>>>>    End_Procedure
14448>>>>>    
14448>>>>>    // Used to retreive the error number and message for a particular field
14448>>>>>    Function Field_Error_Number Integer iField Returns Integer
14450>>>>>        Function_Return (Field_Error_Number(Field_Attributes(Self),iField))
14451>>>>>    End_Function
14452>>>>>    
14452>>>>>    Function Field_Error_Message Integer iField Returns String
14454>>>>>        Function_Return (Field_Error_Message(Field_Attributes(Self),iField))
14455>>>>>    End_Function
14456>>>>>    
14456>>>>>    // This procedure is used to declare an error on a standard field
14456>>>>>    // validation violation like Range or Check.
14456>>>>>    // Can pass 1 to 4 params:
14456>>>>>    // iField -                  Standard usage. Generates field as defined
14456>>>>>    //                           for this field. If field=-1, General error
14456>>>>>    // iField SDefault           If no field error mess (or field=-1) use
14456>>>>>    //                           the default message
14456>>>>>    // iField sDefault sParam1 {sParam2} Replace occurances of @PARAM1 and
14456>>>>>    //                           @PARAM2 in text with these values
14456>>>>>    Procedure Field_Error Integer iField String sDefault ;            String sParam1 String sParam2
14458>>>>>        Integer iErr
14458>>>>>        String  sMess
14458>>>>>        If (iField >= 0) Begin
14460>>>>>            Get Field_Error_Number  iField to iErr
14461>>>>>            Get Field_Error_Message iField to sMess
14462>>>>>        End
14462>>>>>>
14462>>>>>        If (sMess="" and Num_Arguments>1) ;            Move sDefault to sMess
14465>>>>>        If (Num_Arguments = 4) ;            Send Data_Set_Error iField iErr sMess sParam1 sParam2
14468>>>>>        Else If (Num_Arguments = 3) ;            Send Data_Set_Error iField iErr sMess sParam1
14472>>>>>        Else ;            Send Data_Set_Error iField iErr sMess
14474>>>>>    End_Procedure
14475>>>>>    
14475>>>>>    // Procedure Data_Set_Error
14475>>>>>    // This procedure is used to declare a data-set error. Pass error number
14475>>>>>    // and optional error message text.
14475>>>>>    // If iErr is 0, use the default error number.
14475>>>>>    // sParam1 and sParam2 are optional. If passed they are used as text
14475>>>>>    // replacements for @PARAM1 and @PARAM2.
14475>>>>>    // We pass iField (even though we don't use it) so that augmentations
14475>>>>>    // could support error logging down to a field level. If a non-field error
14475>>>>>    // is required the developer should pass negative values (e.g., -1)
14475>>>>>    // This will redirect errors locally if not already redirected
14475>>>>>    //
14475>>>>>    // Altered to additionally support %1 %2 replacements as well as
14475>>>>>    // replacements for @PARAM1 and @PARAM2. (vdf8.2)
14475>>>>>    Procedure Data_set_error Integer iField Integer iErr String sMess ;            String sParam1 String sParam2
14477>>>>>        Integer iOldField
14477>>>>>        Get Current_validate_field to iOldField
14478>>>>>        If (iField <> 0) ;            Set Current_Validate_field to iField
14481>>>>>        
14481>>>>>        If (iErr = 0) ; // if no error is passes, used a default error            Move DD_DEFAULT_ERROR_NUMBER to iErr
14484>>>>>        
14484>>>>>        If (sMess > "") Begin
14486>>>>>            
14486>>>>>            // Support message replacements.. Up to two values
14486>>>>>            // altered to support @Param1/2 and %1 %2 messages
14486>>>>>            If (Num_Arguments>3) Begin
14488>>>>>                Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
14489>>>>>                If (Num_Arguments>4) Begin
14491>>>>>                    Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
14492>>>>>                    Move (SFormat(sMess,sParam1,sParam2)) to sMess
14493>>>>>                End
14493>>>>>>
14493>>>>>                Else Begin
14494>>>>>                    Move (SFormat(sMess,sParam1)) to sMess
14495>>>>>                End
14495>>>>>>
14495>>>>>            End
14495>>>>>>
14495>>>>>            Move Self to ghoErrorSource
14496>>>>>            Error iErr sMess
14497>>>>>>
14497>>>>>            Move 0 to ghoErrorSource
14498>>>>>        End
14498>>>>>>
14498>>>>>        Else ;            Send Operation_Not_Allowed iErr
14500>>>>>        Set Current_validate_field to iOldField
14501>>>>>        Move True to Err // make sure Err is still set
14502>>>>>    End_Procedure
14503>>>>>    
14503>>>>>    // Augment to support Error_Report_Mode. Allows errors without error mess
14503>>>>>    // This will redirect errors locally if not already redirected
14503>>>>>    Procedure Operation_Not_Allowed Integer iErr
14505>>>>>        Integer bOK
14505>>>>>        Move Self to ghoErrorSource
14506>>>>>        Forward Send Operation_Not_Allowed iErr
14508>>>>>        Move 0 to ghoErrorSource
14509>>>>>    End_Procedure
14510>>>>>    
14510>>>>>    // Local error handler. When errors are redirected to the DD this proce-
14510>>>>>    // dure handles the errors. If error_report_mode is NO-report it sets
14510>>>>>    // the err indicator and returns. Else it redirects the error to the
14510>>>>>    // main error handler first moving its ID to ghoErrorSource. This way the
14510>>>>>    // handler knows who sent this message and will get additional error info
14510>>>>>    // by calling Get Extended_error_message
14510>>>>>    Procedure Error_Report Integer iError Integer iLine String ErrMsg
14512>>>>>        Integer hoErrId
14512>>>>>        Integer bRedirect
14512>>>>>        If (Error_Processing_State(Self)) ;  // this prevents recursion            Procedure_Return
14515>>>>>        Set Error_Processing_State to True
14516>>>>>        
14516>>>>>        // if no report mode, just set the err indicator to true.
14516>>>>>        If (Error_Report_Mode(Self)=DD_ERROR_NO_REPORT) ;            Move True to Err
14519>>>>>        Else Begin
14520>>>>>            Get Old_error_object_id to hoErrId  // the original error handler
14521>>>>>            If hoErrId Begin
14523>>>>>                Move (ghoErrorSource=0) to bRedirect
14524>>>>>                If bRedirect ;                    Move Self to ghoErrorSource // error handler can use this
14527>>>>>                Move hoErrID to Error_object_id
14528>>>>>                Send Error_Report to hoErrId iError iLine ErrMsg
14529>>>>>                Move Self to Error_object_id
14530>>>>>                If bRedirect ;                    Move 0 to ghoErrorSource
14533>>>>>            End
14533>>>>>>
14533>>>>>            Else ;                Send error_report of desktop iError iLine ErrMsg
14535>>>>>            //else forward send error_report iError iLine ErrMsg
14535>>>>>        End
14535>>>>>>
14535>>>>>        Set Error_Processing_State to False
14536>>>>>    End_Procedure
14537>>>>>    
14537>>>>>    // This is called (by the system error handler) to get additional informa-
14537>>>>>    // tion about the error. Returns a multi line string with each line
14537>>>>>    // separated by a "\n". Return the file number, name, and if possible
14537>>>>>    // the field number and name.
14537>>>>>    Function Extended_Error_Message Returns String
14539>>>>>        String sExtMess
14539>>>>>        String sFile
14539>>>>>        Integer iFile iField
14539>>>>>        Get main_file to iFile
14540>>>>>        Get Current_Validate_Field to iField
14541>>>>>        Get ErrorMessageTableName iFile to sFile
14542>>>>>        Move (DD_FILE_TEXT* String(iFile) * "-" * sFile) to sExtMess
14543>>>>>        If (iField > 0) ;            Append sExtMess "\n" ;            (DD_FIELD_TEXT* String(iField) * "-" * Field_Label(Self,iField,DD_LABEL_LONG))
14547>>>>>        Set Current_Validate_Field to 0
14548>>>>>        Function_Return sExtMess
14549>>>>>    End_Function
14550>>>>>    
14550>>>>>    Function Extended_Error_File Returns Integer
14552>>>>>        Function_Return (Main_File(Self))
14553>>>>>    End_Function
14554>>>>>    
14554>>>>>    Function Extended_Error_Field Returns Integer
14556>>>>>        Function_Return (Current_Validate_Field(Self))
14557>>>>>    End_Function
14558>>>>>    
14558>>>>>    
14558>>>>>    // The following messages are used to control smart file mode exception
14558>>>>>    // handling. The message "Send Add_system_File file# Fg" allows you to
14558>>>>>    // add system files (or any other files not known to the dso structure)
14558>>>>>    // within define_fields. This allows you to not have to augment the msg
14558>>>>>    // reset_filemodes_for_lock. The only truly public messages here are
14558>>>>>    // Add_system_file and Remove_system_File (which s/b rarely used).
14558>>>>>    
14558>>>>>    // Adds a system file for smart_file_mode handling. A second optional
14558>>>>>    // parameter may be passed to determine of the sys file should only be
14558>>>>>    // locked during a new save (and not during a delete or a save of an
14558>>>>>    // existing record). It is expected that this will be the only public
14558>>>>>    // message used to control smart filemode. All of the remaining sys file
14558>>>>>    // messages are considered advanced.
14558>>>>>    Procedure Add_System_File Integer iFile Integer iLock_Mode
14560>>>>>        Integer iobj iCnt iMode
14560>>>>>        If (Num_arguments = 1) ;            Move DD_Lock_on_All to iMode
14563>>>>>        Else ;            Move iLock_Mode     to iMode
14565>>>>>        Move (system_file_obj(Self)) to iObj
14566>>>>>        Get Item_Count  of iObj to iCnt
14567>>>>>        Set Array_Value of iObj iCnt to iFile
14568>>>>>        Increment iCnt
14569>>>>>        Set Array_Value of iObj iCnt to iMode
14570>>>>>    End_Procedure
14571>>>>>    
14571>>>>>    // Return number of system files
14571>>>>>    Function System_File_Count Returns Integer
14573>>>>>        Function_Return (Item_Count(System_File_Obj(Self))/2)
14574>>>>>    End_Function
14575>>>>>    
14575>>>>>    // Returns system file number for passed item.
14575>>>>>    Function System_File_Number Integer iItem Returns Integer
14577>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2))
14578>>>>>    End_Function
14579>>>>>    
14579>>>>>    // Returns system flag to determine if file is only used during a new
14579>>>>>    // save (and not during an exiting save or a delete).
14579>>>>>    Function System_File_Lock_Mode Integer iItem Returns Integer
14581>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2+1))
14582>>>>>    End_Function
14583>>>>>    
14583>>>>>    // Removes a system_file for smart_file_Mode handling. This remvoes the
14583>>>>>    // first occurance of the file (S/b the only occurance). We assume that
14583>>>>>    // this will be rarely used.
14583>>>>>    Procedure Remove_System_File Integer iFile
14585>>>>>        Integer iobj iCnt iItmCnt
14585>>>>>        Get System_file_Count to iItmCnt
14586>>>>>        Decrement iItmCnt
14587>>>>>        For iCnt from 0 to iItmCnt
14593>>>>>>
14593>>>>>            If (System_File_Number(Self,iCnt)=iFile) Begin
14595>>>>>                Move (system_file_obj(Self)) to iObj
14596>>>>>                Move (iCnt*2) to iCnt
14597>>>>>                Send Delete_Item to iObj iCnt
14598>>>>>                Send Delete_Item to iObj iCnt
14599>>>>>                Procedure_Return
14600>>>>>            End
14600>>>>>>
14600>>>>>        Loop
14601>>>>>>
14601>>>>>    End_Procedure
14602>>>>>    
14602>>>>>    // These set messages, add_client_file, add_server_file and add_system_file
14602>>>>>    // were added to more easily support visual DD class modeling. They do the
14602>>>>>    // same thing the Send counterpart messages do
14602>>>>>    
14602>>>>>    Procedure Set Add_Client_File Integer iFile
14604>>>>>        Send Add_Client_File iFile
14605>>>>>    End_Procedure
14606>>>>>    
14606>>>>>    Procedure Set Add_Server_File Integer iFile
14608>>>>>        Send Add_Server_File iFile
14609>>>>>    End_Procedure
14610>>>>>    
14610>>>>>    Procedure Set Add_System_File Integer iFile Integer iLock_Mode
14612>>>>>        // allow no arguments because the old message allowed this
14612>>>>>        If (Num_arguments=1) Begin
14614>>>>>            Send Add_System_File iFile
14615>>>>>        End
14615>>>>>>
14615>>>>>        Else Begin
14616>>>>>            Send Add_System_File iFile iLock_Mode
14617>>>>>        End
14617>>>>>>
14617>>>>>    End_Procedure
14618>>>>>    
14618>>>>>    // The Set Field_Auto_Increment method replaces the need to use the Define_Auto_Incrmement
14618>>>>>    // command. This models more easily and it supports multiple auto-increment fields
14618>>>>>    Procedure Set Field_Auto_Increment Integer iField Integer iSysFile Integer iSysField
14620>>>>>        Integer[] AutoIncFields
14621>>>>>        tDDFileField[] SysFileFields
14621>>>>>        tDDFileField[] SysFileFields
14622>>>>>        Integer iIndex
14622>>>>>        
14622>>>>>        If (iField=0 or (iSysFile<>0 and iSysField=0)) Begin
14624>>>>>            Error DFERR_PROGRAM "Auto-increment source or destination field is 0"
14625>>>>>>
14625>>>>>            Procedure_Return
14626>>>>>        End
14626>>>>>>
14626>>>>>        // setting the sysfile to 0 is valid. It can be used to clear an existing sysfile
14626>>>>>        If (iSysFile=0) Begin
14628>>>>>            Move 0 to iSysField
14629>>>>>        End
14629>>>>>>
14629>>>>>        Get pAutoIncrementFields to AutoIncFields
14630>>>>>        Get pAutoIncrementSysFileFields to SysFileFields
14631>>>>>        // the destination field array is a list of fields that have auto-incr info. There
14631>>>>>        // can only be zero or one entry per field arranged in no defined order.
14631>>>>>        // see if field is already defined. If not add this to the end.
14631>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
14632>>>>>        If (iIndex=-1) Begin
14634>>>>>            Move (SizeOfArray(SysFileFields)) to iIndex
14635>>>>>        End
14635>>>>>>
14635>>>>>        Move iField    to AutoIncFields[iIndex]
14636>>>>>        Move iSysFile  to SysFileFields[iIndex].iFile
14637>>>>>        Move iSysField to SysFileFields[iIndex].iField
14638>>>>>        Set pAutoIncrementFields to AutoIncFields
14639>>>>>        Set pAutoIncrementSysFileFields to SysFileFields
14640>>>>>    End_Procedure
14641>>>>>    
14641>>>>>    // Get auto-increment system file/field value for a field. There really should be no
14641>>>>>    // reason to ever need this. Field is returned byref
14641>>>>>    Function Field_Auto_Increment Integer iField Integer ByRef iSysField Returns Integer
14643>>>>>        Integer iSysFile
14643>>>>>        Integer[] AutoIncFields
14644>>>>>        tDDFileField[] SysFileFields
14644>>>>>        tDDFileField[] SysFileFields
14645>>>>>        Integer iIndex
14645>>>>>        
14645>>>>>        Get pAutoIncrementFields to AutoIncFields
14646>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
14647>>>>>        If (iIndex>-1) Begin
14649>>>>>            Get pAutoIncrementSysFileFields to SysFileFields
14650>>>>>            Move SysFileFields[iIndex].iFile to iSysFile
14651>>>>>            Move SysFileFields[iIndex].iField to iSysField
14652>>>>>        End
14652>>>>>>
14652>>>>>        Else Begin
14653>>>>>            Move 0 to iSysFile
14654>>>>>            Move 0 to iSysField
14655>>>>>        End
14655>>>>>>
14655>>>>>        Function_Return iSysFile
14656>>>>>    End_Function
14657>>>>>    
14657>>>>>    
14657>>>>>    // Augmented to set any system files defined via the Add_System_file
14657>>>>>    // message. This allows us to hide this procedure for the vast majority
14657>>>>>    // of cases.
14657>>>>>    Procedure Reset_Filemodes_For_Lock
14659>>>>>        Boolean bNewRec
14659>>>>>        Integer  iItmCnt iCnt iMode iFile
14659>>>>>        Integer iMain iMaster iOpts
14659>>>>>        Handle hoDD
14659>>>>>        
14659>>>>>        Forward Send Reset_Filemodes_for_lock
14661>>>>>        
14661>>>>>        Get System_File_Count to iItmCnt
14662>>>>>        If iItmCnt Begin
14664>>>>>            Move (not(HasRecord(Self))) to bNewRec
14665>>>>>            Decrement iItmCnt
14666>>>>>            For iCnt from 0 to iItmCnt
14672>>>>>>
14672>>>>>                Get System_File_Number         iCnt to iFile
14673>>>>>                Get System_File_Lock_Mode iCnt to iMode
14674>>>>>                If ( (iMode=DD_Lock_on_All) or ;                    (Operation_Mode=MODE_DELETING and (iMode iand DD_Lock_on_Delete) ) or ;                    (Operation_Mode=MODE_SAVING and ( (iMode iand DD_Lock_on_Save) or ;                    ( (iMode iand DD_Lock_on_New_Save) and bNewRec) ) ) ) Begin
14676>>>>>                    Set_Attribute DF_FILE_MODE of iFile to DF_FILEMODE_DEFAULT
14679>>>>>                End
14679>>>>>>
14679>>>>>            Loop
14680>>>>>>
14680>>>>>        End
14680>>>>>>
14680>>>>>        
14680>>>>>        // augment to support DD magnaged alias tables.
14680>>>>>        // If an alias, set the alias to the proper alias no locks only if
14680>>>>>        // the master file is actually part of this DDO structure. This allows you
14680>>>>>        // to use alias files without the master being present (or even open). This will work without needing
14680>>>>>        // to set the Master|Alias DF_FILE_ALIAS attributes. If the file is master and part of the DDO structure
14680>>>>>        // it will already have its No_locks attribute cleared. If not part of the DD, its not needed.
14680>>>>>        //
14680>>>>>        Get MasterForAlias to iMaster
14681>>>>>        If iMaster Begin
14683>>>>>            Get Main_File to iMain
14684>>>>>            Get Data_Set iMaster to hoDD // is the master in the DD structure
14685>>>>>            If hoDD Begin
14687>>>>>                Get_Attribute DF_FILE_MODE of iMain to iOpts
14690>>>>>                Set_Attribute DF_FILE_MODE of iMain to (iOpts ior DF_FILEMODE_NO_LOCKS)
14693>>>>>                // note this will be reset to what it was when the transaction ends
14693>>>>>            End
14693>>>>>>
14693>>>>>        End
14693>>>>>>
14693>>>>>        
14693>>>>>    End_Procedure
14694>>>>>    
14694>>>>>    // Augmented to handle auto-increment fields if defined. The value from
14694>>>>>    // the auto-incre sys file is incremented, saved and moved to the new
14694>>>>>    // record. As of 17.0 this is no longer in Creating, which is called after
14694>>>>>    // AutoIncrement.
14694>>>>>    Procedure AutoIncrement
14696>>>>>        Integer iSrcFile iSrcField i iAutoFields
14696>>>>>        Integer iDestFile iDestField
14696>>>>>        Number nNum
14696>>>>>        Integer[] AutoIncFields
14697>>>>>        tDDFileField[] AutoIncSysFileFields
14697>>>>>        tDDFileField[] AutoIncSysFileFields
14698>>>>>        Handle hoOwner
14698>>>>>        
14698>>>>>        Forward Send AutoIncrement
14700>>>>>        
14700>>>>>        // this supports the older Define_Auto_Increment logic. Only one is supported
14700>>>>>        // this is exists for backwards compatibility
14700>>>>>        Get Auto_Increment_Source_File to iSrcFile
14701>>>>>        If iSrcFile Begin // do we have auto increment?
14703>>>>>            Get Auto_Increment_Source_Field  to iSrcField
14704>>>>>            Get Auto_Increment_Dest_Field    to iDestField
14705>>>>>            If (iSrcField and iDestField) Begin  // just in case of error
14707>>>>>                Get Main_file to iDestFile
14708>>>>>                Get_Field_Value iSrcFile iSrcField to nNum
14711>>>>>                Move (nNum+1) to nNum
14712>>>>>                Set_Field_Value iSrcFile  iSrcField  to nNum
14715>>>>>                Set_Field_Value iDestFile iDestField to nNum
14718>>>>>                // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
14718>>>>>                // if the DD is not a parent file, it is a sysfile and we must save it
14718>>>>>                Get Which_Data_Set iSrcFile to hoOwner
14719>>>>>                If not hoOwner Begin
14721>>>>>                    SaveRecord iSrcFile
14722>>>>>                End
14722>>>>>>
14722>>>>>            End
14722>>>>>>
14722>>>>>        End
14722>>>>>>
14722>>>>>        // this supports the newer set syntax which support multiple fields. It is expected that you will
14722>>>>>        // use one syntax of the other, not both. If you use the old syntax, you cannot use the new one
14722>>>>>        Else Begin
14723>>>>>            Get pAutoIncrementFields to AutoIncFields
14724>>>>>            Move (SizeOfArray(AutoIncFields)) to iAutoFields
14725>>>>>            If (iAutoFields>0) Begin
14727>>>>>                Get pAutoIncrementSysFileFields to AutoIncSysFileFields
14728>>>>>                Get Main_file to iDestFile
14729>>>>>                For i from 0 to (iAutoFields-1)
14735>>>>>>
14735>>>>>                    // it is legal to set the sysfile to 0, this means it has been cleared and is not used
14735>>>>>                    If (AutoIncSysFileFields[i].iFile>0) Begin
14737>>>>>                        // we assume both the fields are valid and that they've already been tested when added
14737>>>>>                        Get_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
14740>>>>>                        Move (nNum+1) to nNum
14741>>>>>                        Set_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
14744>>>>>                        Set_Field_Value iDestFile AutoIncFields[i] to nNum
14747>>>>>                        // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
14747>>>>>                        // if the DD is not a parent file, it is a sysfile and we must save it
14747>>>>>                        Get Which_Data_Set AutoIncSysFileFields[i].iFile to hoOwner
14748>>>>>                        If not hoOwner Begin
14750>>>>>                            SaveRecord AutoIncSysFileFields[i].iFile
14751>>>>>                        End
14751>>>>>>
14751>>>>>                    End
14751>>>>>>
14751>>>>>                Loop
14752>>>>>>
14752>>>>>            End
14752>>>>>>
14752>>>>>        End
14752>>>>>>
14752>>>>>        
14752>>>>>    End_Procedure
14753>>>>>    
14753>>>>>    // Augmented to fix a bug in the data-set C code. When a record is saved
14753>>>>>    // as part of a delete operation OnNewCurrentRecord is not called. It
14753>>>>>    // should be. We will do this in flex code for now.
14753>>>>>    Procedure Save_Main_File
14755>>>>>        RowID riRec
14755>>>>>        Integer iRec iMain
14755>>>>>        Boolean bRecnumTable bChanged
14755>>>>>        
14755>>>>>        Get Main_File to iMain
14756>>>>>        Get_Attribute DF_FILE_CHANGED of iMain to bChanged
14759>>>>>        If bChanged Begin
14761>>>>>            Send OnSaveRecord // OnSaveRecord sent if there is something to save
14762>>>>>        End
14762>>>>>>
14762>>>>>        
14762>>>>>        Forward Send Save_Main_File
14764>>>>>        
14764>>>>>        If (Operation_Mode = MODE_DELETING) Begin  // during a delete the crnt
14766>>>>>            Get CurrentRowId to riRec             // rec of parents do not change
14767>>>>>            Send OnNewCurrentRecord riRec riRec  // so old and new are the same.
14768>>>>>            // for backwards compatibility reasons, we also send new_current_record if appropriate
14768>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of iMain to bRecnumTable
14771>>>>>            If (bRecnumTable) Begin
14773>>>>>                Get_Field_Value iMain 0 to iRec
14776>>>>>                Send New_Current_Record iRec iRec
14777>>>>>            End
14777>>>>>>
14777>>>>>        End
14777>>>>>>
14777>>>>>    End_Procedure
14778>>>>>    
14778>>>>>    // Augmented to not clear if a system-file. The auto-latching of views
14778>>>>>    // may cause a sys file DD to get cleared. This corrects this. This really
14778>>>>>    // belongs in Data_set (C) but we will not risk this for now.
14778>>>>>    Procedure Clear_Main_File
14780>>>>>        Integer iFile iIsSys
14780>>>>>        Get Main_File to iFile
14781>>>>>        If iFile Begin
14783>>>>>            Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to iIsSys
14786>>>>>            If iIsSys ;                Procedure_Return
14789>>>>>        End
14789>>>>>>
14789>>>>>        Forward Send Clear_main_file
14791>>>>>    End_Procedure
14792>>>>>    
14792>>>>>    // Executes a request_find on the mainfile. This is easier that having to
14792>>>>>    // pass file number all the time. Useful for batch operations.
14792>>>>>    // If Index is 0, use find_by_recnum (it handles a recnum of 0 better)
14792>>>>>    Procedure Find Integer iMode Integer iIndex
14794>>>>>        Integer iFile
14794>>>>>        Integer iRec
14794>>>>>        Get Main_file to iFile
14795>>>>>        If (iIndex<>0 or iMode<>EQ) ;            Send request_find iMode iFile iIndex
14798>>>>>        Else Begin
14799>>>>>            // this would never happen with row ID
14799>>>>>            Get_Field_Value iFile 0 to iRec // get recnum value
14802>>>>>            Send find_by_recnum iFile iRec
14803>>>>>        End
14803>>>>>>
14803>>>>>    End_Procedure
14804>>>>>    
14804>>>>>    // So many people make the mistake of using requeset_clear and request_
14804>>>>>    // clear_all that will support these are alteratives to clear and
14804>>>>>    // clear_all. The preferred messages remain Clear and Clear_all.
14804>>>>>    // This would not work if you nested DEOs within DSOs (no-one does).
14804>>>>>    Procedure Request_Clear
14806>>>>>        Send Clear
14807>>>>>    End_Procedure
14808>>>>>    
14808>>>>>    Procedure Request_Clear_All
14810>>>>>        Send Clear_All
14811>>>>>    End_Procedure
14812>>>>>    
14812>>>>>    // we want changed_state to always go through the
14812>>>>>    // Record_buffer object. From there it is sent to
14812>>>>>    // here. So if state or RB does not match we must
14812>>>>>    // send to the RB object...it will delegate to here
14812>>>>>    
14812>>>>>    Procedure Set Changed_State Integer bState
14814>>>>>        Integer hRB
14814>>>>>        Move (record_buffer(Self)) to hRB
14815>>>>>        If (hRB and changed_state(hRB)<>bState) ;            Set changed_state of hRB to bState
14818>>>>>        Else ;            Forward Set changed_state to bState
14821>>>>>    End_Procedure
14822>>>>>    
14822>>>>>    // this lets us use the new attach logic
14822>>>>>    
14822>>>>>    // This is a smarter attach than the normal attach command. It only attaches data from a parent
14822>>>>>    // if 1) the DDO parent is connected to the structure and 2) if there is a record to attach. It will
14822>>>>>    // not attach empty records into a child. This should make the finding (and saving) more sensible when
14822>>>>>    // partial DD structures are used. For example, often a report does not all of the parent DDOs - however if
14822>>>>>    // they are not provided, finding can get messed up because blank data is being moved into the child before a
14822>>>>>    // find. This has been a problem since 3.0. This should just make it go away.
14822>>>>>    // as of 17.0, we get the related field info through the local DSO if needed
14822>>>>>    
14822>>>>>    // as if 18.1 this is only called when there is an attachable relationship. This gives us a chance to do any
14822>>>>>    // customizations and to cancel the attach. We've left this to the flex level so we can fine tune attaches.
14822>>>>>    Function ShouldFieldAttach Integer iField Handle hoRelDD Returns Boolean
14824>>>>>        Boolean bDoAttach bChanged
14824>>>>>        Integer iFile iStat iRelFile iType
14824>>>>>        String sValue
14824>>>>>        
14824>>>>>        Get Main_File to iFile
14825>>>>>        Get Main_File of hoRelDD to iRelFile
14826>>>>>        
14826>>>>>        // before we attach check if Find mode and relfile is new and unchanged..if so skip.
14826>>>>>        // If operation_mode is 0, this is probably a Find (item_find sends attach_main_file for some reason).
14826>>>>>        Move True to bDoAttach
14827>>>>>        If (Operation_mode=MODE_FINDING or OPERATION_MODE=0) Begin
14829>>>>>            // we can test the file status to see if we have a record or not. If we have a record, we attach
14829>>>>>            Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
14832>>>>>            If (iStat=DF_FILE_INACTIVE) Begin
14834>>>>>                // if no record, we need to look for changes. We can't just look at the file's changed state because the DD
14834>>>>>                // may have set defaults, which have been moved to the buffer. We should be able to check the DD's changed state
14834>>>>>                // because this is not set with default values. When doing a find entry_update this should be ok. If this were
14834>>>>>                // a save, this would cause problems (but this is not a save). Prior to 17.0 this was not an issue with windows
14834>>>>>                // applications because find entry_updates were done at the DEO level (unlike web applications).
14834>>>>>                Get Changed_State of hoRelDD to bChanged
14835>>>>>                Move bChanged to bDoAttach
14836>>>>>                
14836>>>>>                // special Triumph workaround for Item_Find with blank inner segment. They were counting on the item_find attach_main_file
14836>>>>>                // which would slip through the "no-attach on find when parent is empty optimization". This was needed to force a string segment
14836>>>>>                // that was "" to get filled with spaces from the parent field. The child field was set to "" because of a constrained_clear
14836>>>>>                // in Item_find. This workaround is as narrow as possible. If an item_find attach_main_file (operation_mode=0) and this is
14836>>>>>                // an empty parent (bOk was just set to False), and the field is DF_Ascii and the child value is empty (no trailing spaces)
14836>>>>>                // then force an attach. Since the parent should be "", we can just Set_Field_value to "", which fills the field buffer.
14836>>>>>                // There is no real logic as to why this is being done other than to make it work like it used to with the least
14836>>>>>                // amount of side-effects.
14836>>>>>                If (not(bDoAttach) and OPERATION_MODE=0) Begin
14838>>>>>                    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
14841>>>>>                    If (iType=DF_ASCII) Begin
14843>>>>>                        Get_Field_Value iFile iField to sValue
14846>>>>>                        // if no spaces, this probably was cleared via constrained_clear in Item_Find. We should update
14846>>>>>                        If (Ascii(Left(sValue,1))=0) Begin
14848>>>>>                            Set_Field_Value iFile iField to ""
14851>>>>>                        End
14851>>>>>>
14851>>>>>                    End
14851>>>>>>
14851>>>>>                End
14851>>>>>>
14851>>>>>                
14851>>>>>            End
14851>>>>>>
14851>>>>>        End
14851>>>>>>
14851>>>>>        Function_Return bDoAttach
14852>>>>>    End_Function
14853>>>>>    
14853>>>>>    // Notify all DEOs that a mask has changed.
14853>>>>>    //        this message is sent by set Field_Mask
14853>>>>>    Procedure Field_Mask_Changed Integer iField String sMask
14855>>>>>        Integer i iDEOs iDEO
14855>>>>>        Integer iMain_File
14855>>>>>        Get Main_File to iMain_File
14856>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14857>>>>>        Decrement iDEOs
14858>>>>>        For i from 0 to iDEOs
14864>>>>>>
14864>>>>>            Get Data_Set_User_Interface i to iDEO
14865>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Mask_Changed to iDEO ;                iMain_File iField sMask
14868>>>>>        Loop
14869>>>>>>
14869>>>>>    End_Procedure
14870>>>>>    
14870>>>>>    // Notify all DEOs that a label has changed.
14870>>>>>    //   This message is sent by Set Field_Label_long & Field_Label_Short
14870>>>>>    Procedure Field_label_Changed Integer iField Boolean bLong String sLabel
14872>>>>>        Integer i iDEOs iDEO
14872>>>>>        Integer iMain_File
14872>>>>>        Get Main_File to iMain_File
14873>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14874>>>>>        Decrement iDEOs
14875>>>>>        For i from 0 to iDEOs
14881>>>>>>
14881>>>>>            Get Data_Set_User_Interface i to iDEO
14882>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Label_Changed to iDEO ;                iMain_File iField bLong sLabel
14885>>>>>        Loop
14886>>>>>>
14886>>>>>    End_Procedure
14887>>>>>    
14887>>>>>    // Notify all DEOs that a field option has changed.
14887>>>>>    //   This message is sent by Set Field_Option
14887>>>>>    Procedure Field_Option_Changed Integer iField Integer iOptions Boolean bClear
14889>>>>>        Integer i iDEOs iDEO
14889>>>>>        Integer iMain_File
14889>>>>>        Get Main_File to iMain_File
14890>>>>>        Get Data_Set_User_Interface_Count to iDEOs
14891>>>>>        Decrement iDEOs
14892>>>>>        For i from 0 to iDEOs
14898>>>>>>
14898>>>>>            Get Data_Set_User_Interface i to iDEO
14899>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Option_Changed of iDEO ;                iMain_File iField iOptions bClear
14902>>>>>        Loop
14903>>>>>>
14903>>>>>    End_Procedure
14904>>>>>    
14904>>>>>    
14904>>>>>    //   Set, clear or toggle a field option
14904>>>>>    //   Multiple options can be passed as an expression
14904>>>>>    //   (e.g. Set Field_option 2 (dd_Retain IOR dd_NoEnter).
14904>>>>>    //   Unlike set Field_options this notifies DEOs of changes
14904>>>>>    // supports setting and clearing. e.g.:
14904>>>>>    //    Set Field_Option Field Customer.Name DD_NoEnter to True
14904>>>>>    // This new syntax is now the recommended syntax but the older syntax without
14904>>>>>    // the last parameter is supported (where true is the default). The old syntax is
14904>>>>>    // only supported for compatibility. This means that Field_Option_Clear should
14904>>>>>    // also be replaced with Field_Option
14904>>>>>    Procedure Set Field_Option Integer iField Integer iOption Boolean bSet
14906>>>>>        Boolean bSetTrue
14906>>>>>        Move (If(num_arguments>2, bSet, True)) to bSetTrue // support for old deprecated syntax
14907>>>>>        If bSetTrue Begin
14909>>>>>            Set Field_options iField to iOption
14910>>>>>        End
14910>>>>>>
14910>>>>>        Else Begin
14911>>>>>            Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOption
14912>>>>>        End
14912>>>>>>
14912>>>>>        If (Data_Set_User_Interface_Count(Self)) Begin
14914>>>>>            Send Field_Option_Changed iField iOption (not(bSetTrue))
14915>>>>>        End
14915>>>>>>
14915>>>>>    End_Procedure
14916>>>>>    
14916>>>>>    Procedure Set File_Field_Option Integer iFile Integer iField Integer iOption Boolean bSet
14918>>>>>        Handle hoDD
14918>>>>>        Boolean bSetTrue
14918>>>>>        Move (If(num_arguments>3, bSet, True)) to bSetTrue // support for old deprecated syntax
14919>>>>>        Get Data_set iFile to hoDD
14920>>>>>        If hoDD Begin
14922>>>>>            Set Field_Option of hoDD iField iOption to bSetTrue
14923>>>>>        End
14923>>>>>>
14923>>>>>        
14923>>>>>    End_Procedure
14924>>>>>    
14924>>>>>    Procedure Set Field_Option_Clear Integer iField Integer iOptions
14926>>>>>        Set Field_Option iField iOptions to False
14927>>>>>    End_Procedure
14928>>>>>    
14928>>>>>    Procedure Set File_Field_Option_Clear Integer iFile Integer iField Integer iOptions
14930>>>>>        Set File_Field_Option iFile iField iOptions to False
14931>>>>>    End_Procedure
14932>>>>>    
14932>>>>>    Procedure Set Field_Option_Toggle Integer iField Integer iOption
14934>>>>>        Integer iOldOption
14934>>>>>        Get Field_Options iField to iOldOption
14935>>>>>        // if old and new have overlapping bits, we assume clear
14935>>>>>        Set Field_Option iField iOption to ((iOldOption iand iOption)=0)
14936>>>>>    End_Procedure
14937>>>>>    
14937>>>>>    Procedure Set File_Field_Option_Toggle Integer iFile Integer iField Integer iOption
14939>>>>>        Handle hoDD
14939>>>>>        Get Data_set iFile to hoDD
14940>>>>>        If hoDD ;            Set Field_Option_Toggle of hoDD iField to iOption
14943>>>>>    End_Procedure
14944>>>>>    
14944>>>>>    // This returns the main index for a field. This replaces the DSO message Field_Main_index which
14944>>>>>    // should no longer be used by DDOs. The old message has the problem that the DDO or DSO using
14944>>>>>    // this message may not be the owner of the field. So augmenting the owner DDO did not insure that
14944>>>>>    // all requests for this index would go through it. Now you can augment Field_Index and always
14944>>>>>    // be sure that any DDO requesting an index for a file (via file_field_index) will always go to
14944>>>>>    // the owner object.
14944>>>>>    Function Field_Index Integer iField Returns Integer
14946>>>>>        Integer iFile iIndex iOrder
14946>>>>>        // ordering takes precendence
14946>>>>>        Get ordering to iOrder
14947>>>>>        If (iOrder>=0);            Move iOrder to iIndex  //ordering takes precedence over main index
14950>>>>>        Else Begin
14951>>>>>            Get Main_file to iFile
14952>>>>>            Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex // main index field
14955>>>>>            If (iIndex=0 and iField>0) ; // If field is not recnum and there is no index, the                Move -1 to iIndex        // field has no main index
14958>>>>>        End
14958>>>>>>
14958>>>>>        Function_Return iIndex
14959>>>>>    End_Function
14960>>>>>    
14960>>>>>    // In all cases, this message should be sent instead of Field_Main_Index. If
14960>>>>>    // augmentation was used in Field_Main_Index, use Field_Index to insure the owner object
14960>>>>>    // is called.
14960>>>>>    
14960>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
14962>>>>>        Integer iIndex
14962>>>>>        Handle hoDD
14962>>>>>        Get Data_set iFile to hoDD
14963>>>>>        If (hoDD) ;            Get Field_Index of hoDD iField to iIndex
14966>>>>>        Else ;            Move -1 to iIndex
14968>>>>>        Function_Return iIndex
14969>>>>>    End_Function
14970>>>>>    
14970>>>>>    // 12/1 change: Make sure all of the major DD operations update the DD with the value in
14970>>>>>    // the focus field. After the actual find, save, clar or delete, the DD buffer contains information that
14970>>>>>    // is not yet reflected in the DEOs (before refresh is called) we want to make sure that we
14970>>>>>    // don't try to get data from the DEO. Get Field_Current_Value now checks if operation_mode is
14970>>>>>    // non-zero. If it is, it always gets from the DD buffer.
14970>>>>>    
14970>>>>>    Procedure Clear
14972>>>>>        Boolean bOpOk
14972>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14973>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14975>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARING
14976>>>>>        End
14976>>>>>>
14976>>>>>        If (bOpOk) Begin
14978>>>>>            Send OnPreFind DDFindClear
14979>>>>>        End
14979>>>>>>
14979>>>>>        Forward Send Clear
14981>>>>>        If (bOpOk) Begin
14983>>>>>            Send DefaultParentAutofinds
14984>>>>>            Send OnPostFind DDFindClear True
14985>>>>>        End
14985>>>>>>
14985>>>>>    End_Procedure
14986>>>>>    
14986>>>>>    Procedure Clear_All
14988>>>>>        Boolean bOpOk
14988>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
14989>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
14991>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARINGALL
14992>>>>>        End
14992>>>>>>
14992>>>>>        Forward Send clear_all
14994>>>>>        If (bOpOk) Begin
14996>>>>>            Send DefaultParentAutofinds
14997>>>>>        End
14997>>>>>>
14997>>>>>    End_Procedure
14998>>>>>    
14998>>>>>    Procedure Request_Assign Integer iFile
15000>>>>>        Handle hoDD
15000>>>>>        Boolean bFound
15000>>>>>        Boolean bOpOk
15000>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15001>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
15003>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
15004>>>>>        End
15004>>>>>>
15004>>>>>        
15004>>>>>        If (bOpOk) Begin
15006>>>>>            If (num_arguments=0 or iFile=0) Begin
15008>>>>>                Move Self to hoDD
15009>>>>>            End
15009>>>>>>
15009>>>>>            Else Begin
15010>>>>>                Get Data_Set iFile to hoDD
15011>>>>>            End
15011>>>>>>
15011>>>>>            If hoDD Begin
15013>>>>>                Send OnPreFind of hoDD DDFindRequestAssign
15014>>>>>            End
15014>>>>>>
15014>>>>>        End
15014>>>>>>
15014>>>>>        
15014>>>>>        If (num_arguments=0) Begin
15016>>>>>            Forward Send Request_Assign
15018>>>>>        End
15018>>>>>>
15018>>>>>        Else Begin
15019>>>>>            Forward Send Request_Assign iFile
15021>>>>>        End
15021>>>>>>
15021>>>>>        
15021>>>>>        If (bOpOk) Begin
15023>>>>>            If (hoDD) Begin
15025>>>>>                Move (Found) to bFound
15026>>>>>                Send OnPostFind of hoDD DDFindRequestAssign bFound
15027>>>>>                Move bFound to Found
15028>>>>>            End
15028>>>>>>
15028>>>>>        End
15028>>>>>>
15028>>>>>    End_Procedure
15029>>>>>    
15029>>>>>    
15029>>>>>    Procedure Find_By_Recnum Integer iFile Integer iRecord
15031>>>>>        Handle hoDD
15031>>>>>        Boolean bFound
15031>>>>>        Boolean bOpOk
15031>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15032>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15033>>>>>        
15033>>>>>        If (bOpOk) Begin
15035>>>>>            Get Data_Set iFile to hoDD
15036>>>>>            If hoDD Begin
15038>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15039>>>>>            End
15039>>>>>>
15039>>>>>        End
15039>>>>>>
15039>>>>>        
15039>>>>>        Forward Send Find_By_Recnum iFile iRecord
15041>>>>>        
15041>>>>>        If (bOpOk) Begin
15043>>>>>            If (hoDD) Begin
15045>>>>>                Move (Found) to bFound
15046>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15047>>>>>                Move bFound to Found
15048>>>>>            End
15048>>>>>>
15048>>>>>        End
15048>>>>>>
15048>>>>>    End_Procedure
15049>>>>>    
15049>>>>>    Procedure FindByRowId Integer iFile RowID riRowId
15051>>>>>        Handle hoDD
15051>>>>>        Boolean bFound
15051>>>>>        Boolean bOpOk
15051>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15052>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15053>>>>>        
15053>>>>>        If (bOpOk) Begin
15055>>>>>            Get Data_Set iFile to hoDD
15056>>>>>            If hoDD Begin
15058>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15059>>>>>            End
15059>>>>>>
15059>>>>>        End
15059>>>>>>
15059>>>>>        
15059>>>>>        Forward Send FindByRowId iFile riRowId
15061>>>>>        
15061>>>>>        If (bOpOk) Begin
15063>>>>>            If (hoDD) Begin
15065>>>>>                Move (Found) to bFound
15066>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15067>>>>>                Move bFound to Found
15068>>>>>            End
15068>>>>>>
15068>>>>>        End
15068>>>>>>
15068>>>>>    End_Procedure
15069>>>>>    
15069>>>>>    Function FindByRowIdEx Integer iFile RowID riRowId Returns Boolean
15071>>>>>        Handle hoDD
15071>>>>>        Boolean bFound bSuccess
15071>>>>>        Boolean bOpOk
15071>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15072>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15073>>>>>        
15073>>>>>        If (bOpOk) Begin
15075>>>>>            Get Data_Set iFile to hoDD
15076>>>>>            If hoDD Begin
15078>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15079>>>>>            End
15079>>>>>>
15079>>>>>        End
15079>>>>>>
15079>>>>>        
15079>>>>>        Forward Get FindByRowIdEx iFile riRowId to bSuccess
15081>>>>>        
15081>>>>>        If (bOpOk) Begin
15083>>>>>            If (hoDD) Begin
15085>>>>>                Move (Found) to bFound
15086>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15087>>>>>                Move bFound to Found
15088>>>>>            End
15088>>>>>>
15088>>>>>        End
15088>>>>>>
15088>>>>>        Function_Return bSuccess
15089>>>>>    End_Function
15090>>>>>    
15090>>>>>    Function FindByRowIdExNoAutoFill Integer iFile RowID riRowId Returns Boolean
15092>>>>>        Handle hoDD
15092>>>>>        Boolean bFound bSuccess
15092>>>>>        Boolean bOpOk
15092>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15093>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
15094>>>>>        
15094>>>>>        If (bOpOk) Begin
15096>>>>>            Get Data_Set iFile to hoDD
15097>>>>>            If hoDD Begin
15099>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
15100>>>>>            End
15100>>>>>>
15100>>>>>        End
15100>>>>>>
15100>>>>>        
15100>>>>>        Forward Get FindByRowIdExNoAutoFill iFile riRowId to bSuccess
15102>>>>>        
15102>>>>>        If (bOpOk) Begin
15104>>>>>            If (hoDD) Begin
15106>>>>>                Move (Found) to bFound
15107>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
15108>>>>>                Move bFound to Found
15109>>>>>            End
15109>>>>>>
15109>>>>>        End
15109>>>>>>
15109>>>>>        Function_Return bSuccess
15110>>>>>    End_Function
15111>>>>>    
15111>>>>>    
15111>>>>>    Procedure Request_Find Integer eFindMode Integer iFile Integer iIndex
15113>>>>>        Handle hoDD
15113>>>>>        Boolean bFound
15113>>>>>        Boolean bOpOk
15113>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
15114>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
15116>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
15117>>>>>        End
15117>>>>>>
15117>>>>>        
15117>>>>>        If (bOpOk) Begin
15119>>>>>            Get Data_Set iFile to hoDD
15120>>>>>            If hoDD Begin
15122>>>>>                Send OnPreFind of hoDD DDFindRequestFind
15123>>>>>            End
15123>>>>>>
15123>>>>>        End
15123>>>>>>
15123>>>>>        
15123>>>>>        Forward Send Request_Find eFindMode iFile iIndex
15125>>>>>        
15125>>>>>        If (bOpOk) Begin
15127>>>>>            If (hoDD) Begin
15129>>>>>                Move (Found) to bFound
15130>>>>>                Send OnPostFind of hoDD DDFindRequestFind bFound
15131>>>>>                Move bFound to Found
15132>>>>>            End
15132>>>>>>
15132>>>>>        End
15132>>>>>>
15132>>>>>    End_Procedure
15133>>>>>    
15133>>>>>    Procedure OnPreFind Integer eMessage
15135>>>>>    End_Procedure
15136>>>>>    
15136>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
15138>>>>>    End_Procedure
15139>>>>>    
15139>>>>>    
15139>>>>>    
15139>>>>>    Procedure Request_Superfind Integer eFindMode Integer iFile Integer iField
15141>>>>>        Boolean bInSuperFind
15141>>>>>        // we need to set pbInSuperFind so Entry_update in the DEOs will know that
15141>>>>>        // they should perform an entry_update. Superfind entry_updates have never gone through
15141>>>>>        // the DD's field buffer.
15141>>>>>        Get pbInSuperFind to bInSuperFind
15142>>>>>        Set pbInSuperFind to True
15143>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
15145>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
15146>>>>>        End
15146>>>>>>
15146>>>>>        Forward Send Request_Superfind eFindMode iFile iField
15148>>>>>        Set pbInSuperFind to bInSuperFind
15149>>>>>    End_Procedure
15150>>>>>    
15150>>>>>    // Augmented to return true if a non-constrained parent DD has a change. This way
15150>>>>>    // Should_Save_row only filters changes in a consrained parent.
15150>>>>>    
15150>>>>>    Function Should_Save_Row Returns Boolean
15152>>>>>        Boolean bShouldSaveRow bShouldSave bRelatesToConstraint
15152>>>>>        Integer iServers iServer iServerFile
15152>>>>>        Handle hoServerDD
15152>>>>>        Forward Get Should_Save_Row to bShouldSaveRow // will be true if this DD is changed or has a changed parent.
15154>>>>>        Get Should_Save to bShouldSave // will be true if there is a change anywhere up the entire save structure
15155>>>>>        If (not(bShouldSaveRow) and bShouldSave) Begin
15157>>>>>            // If here we have a changed in an server but not the this DD. We need a further refinement. If the server
15157>>>>>            // change is in a constrained server, we don't consider this a change because you can switch rows without losing
15157>>>>>            // data (with RT changes made for 17.0).
15157>>>>>            Get Data_Set_Server_Count to iServers
15158>>>>>            For iServer from 0 to (iServers-1)
15164>>>>>>
15164>>>>>                Get Data_Set_Server iServer to hoServerDD
15165>>>>>                Get Should_Save of hoServerDD to bShouldSave
15166>>>>>                If bShouldSave Begin
15168>>>>>                    Get Main_File of hoServerDD to iServerFile
15169>>>>>                    Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
15170>>>>>                    If not bRelatesToConstraint Begin
15172>>>>>                        Function_Return True
15173>>>>>                    End
15173>>>>>>
15173>>>>>                End
15173>>>>>>
15173>>>>>            Loop
15174>>>>>>
15174>>>>>        End
15174>>>>>>
15174>>>>>        Function_Return bShouldSaveRow
15175>>>>>    End_Function
15176>>>>>    
15176>>>>>    // returns true if any relates-to constraining server needs a save. Normally there will be
15176>>>>>    // one or zero related-to parents. If Should_Save_Row returns false it is possible that there
15176>>>>>    // is a change up the relates-to constrained branch. If so, this will return True. This can be
15176>>>>>    // used to better determine the changed status of your DDO sructure
15176>>>>>    Function ShouldSaveConstrainedToServer Returns Boolean
15178>>>>>        Boolean bShouldSave bRelatesToConstraint
15178>>>>>        Integer iServers iServer iServerFile
15178>>>>>        Handle hoServerDD
15178>>>>>        Get Data_Set_Server_Count to iServers
15179>>>>>        For iServer from 0 to (iServers-1)
15185>>>>>>
15185>>>>>            Get Data_Set_Server iServer to hoServerDD
15186>>>>>            Get Main_File of hoServerDD to iServerFile
15187>>>>>            Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
15188>>>>>            If bRelatesToConstraint Begin
15190>>>>>                Get Should_Save of hoServerDD to bShouldSave
15191>>>>>                If bShouldSave Begin
15193>>>>>                    Function_Return True
15194>>>>>                End
15194>>>>>>
15194>>>>>            End
15194>>>>>>
15194>>>>>        Loop
15195>>>>>>
15195>>>>>        Function_Return False
15196>>>>>    End_Function
15197>>>>>    
15197>>>>>    Function FindServerInformationElement Integer iFile Returns Integer
15199>>>>>        tDDServerInformation[] ServerInformation
15199>>>>>        tDDServerInformation[] ServerInformation
15200>>>>>        tDDServerInformation ServerSearch
15200>>>>>        tDDServerInformation ServerSearch
15200>>>>>        Integer iIndex
15200>>>>>        Move iFile to ServerSearch.iParent
15201>>>>>        Get pServerInformation to ServerInformation
15202>>>>>        Function_Return (SearchArray(ServerSearch,ServerInformation))
15203>>>>>    End_Function
15204>>>>>    
15204>>>>>    Procedure AddServerData Integer iFile Integer eParam Boolean bValue
15206>>>>>        tDDServerInformation[] ServerInformation
15206>>>>>        tDDServerInformation[] ServerInformation
15207>>>>>        Integer iIndex
15207>>>>>        Handle hoDDO
15207>>>>>        
15207>>>>>        Get pServerInformation to ServerInformation
15208>>>>>        Get FindServerInformationElement iFile to iIndex
15209>>>>>        If (iIndex=-1) Begin
15211>>>>>            Move (SizeOfArray(ServerInformation)) to iIndex
15212>>>>>            Move iFile to ServerInformation[iIndex].iParent
15213>>>>>            // defaults must always be false!
15213>>>>>            Move False to ServerInformation[iIndex].bParentNoSwitchIfCommitted
15214>>>>>            Move False to ServerInformation[iIndex].bAllowNullParent
15215>>>>>            Move False to ServerInformation[iIndex].bNoCascadeDelete
15216>>>>>            Move False to ServerInformation[iIndex].bCascadeDeleteNullTheParent
15217>>>>>        End
15217>>>>>>
15217>>>>>        
15217>>>>>        If (eParam=0) Begin
15219>>>>>            If (bValue<>ServerInformation[iIndex].bAllowNullParent) Begin
15221>>>>>                Move bValue to ServerInformation[iIndex].bAllowNullParent
15222>>>>>                Send AdjustDeleteValidateStructure iFile
15223>>>>>            End
15223>>>>>>
15223>>>>>        End
15223>>>>>>
15223>>>>>        Else If (eParam=1) Begin
15226>>>>>            Move bValue to ServerInformation[iIndex].bParentNoSwitchIfCommitted
15227>>>>>        End
15227>>>>>>
15227>>>>>        Else If (eParam=2) Begin
15230>>>>>            Move bValue to ServerInformation[iIndex].bNoCascadeDelete
15231>>>>>        End
15231>>>>>>
15231>>>>>        Else Begin // (3)
15232>>>>>            If (bValue<>ServerInformation[iIndex].bCascadeDeleteNullTheParent) Begin
15234>>>>>                Move bValue to ServerInformation[iIndex].bCascadeDeleteNullTheParent
15235>>>>>                Send AdjustDeleteValidateStructure iFile
15236>>>>>            End
15236>>>>>>
15236>>>>>        End
15236>>>>>>
15236>>>>>        Set pServerInformation to ServerInformation
15237>>>>>    End_Procedure
15238>>>>>    
15238>>>>>    Function GetServerData Integer iFile Integer eParam Returns Boolean
15240>>>>>        Boolean bValue
15240>>>>>        tDDServerInformation[] ServerInformation
15240>>>>>        tDDServerInformation[] ServerInformation
15241>>>>>        Integer iIndex
15241>>>>>        Get pServerInformation to ServerInformation
15242>>>>>        Get FindServerInformationElement iFile to iIndex
15243>>>>>        // when not found in array, we want to make sure that we return false. Therefore
15243>>>>>        // false should always be the default.
15243>>>>>        If (iIndex<>-1) Begin
15245>>>>>            If (eParam=0) Begin
15247>>>>>                Move ServerInformation[iIndex].bAllowNullParent to bValue
15248>>>>>            End
15248>>>>>>
15248>>>>>            Else If (eParam=1) Begin
15251>>>>>                Move ServerInformation[iIndex].bParentNoSwitchIfCommitted to bValue
15252>>>>>            End
15252>>>>>>
15252>>>>>            Else If (eParam=2) Begin
15255>>>>>                Move ServerInformation[iIndex].bNoCascadeDelete to bValue
15256>>>>>            End
15256>>>>>>
15256>>>>>            Else Begin
15257>>>>>                Move ServerInformation[iIndex].bCascadeDeleteNullTheParent to bValue
15258>>>>>            End
15258>>>>>>
15258>>>>>        End
15258>>>>>>
15258>>>>>        Function_Return bValue
15259>>>>>    End_Function
15260>>>>>    
15260>>>>>    Procedure AdjustDeleteValidateStructure2
15262>>>>>        Integer iCount i
15262>>>>>        Handle hoDDO
15262>>>>>        Boolean bVisited
15262>>>>>        Set Visited_State to True
15263>>>>>        Set Cascade_Delete_Structure_Validated_State to False
15264>>>>>        Get Data_Set_Server_Count to iCount
15265>>>>>        For i from 0 to (iCount-1)
15271>>>>>>
15271>>>>>            Get Data_Set_Server i to hoDDO
15272>>>>>            Get Visited_State of hoDDO to bVisited
15273>>>>>            If (not(bVisited)) Begin
15275>>>>>                Send AdjustDeleteValidateStructure2 of hoDDO
15276>>>>>            End
15276>>>>>>
15276>>>>>        Loop
15277>>>>>>
15277>>>>>    End_Procedure
15278>>>>>    
15278>>>>>    // This is called in the unlikely case that NullParent/CascadeNull are set dynamically. It
15278>>>>>    // tells the parent DDO to recheck its validate-delete structure and it tells all ancestors of
15278>>>>>    // this parent to do the same. If called while DDOs are being created (via a class setting) there
15278>>>>>    // will not be a connected parent for iFile, which is fine.
15278>>>>>    Procedure AdjustDeleteValidateStructure Integer iFile
15280>>>>>        Handle hoDDO
15280>>>>>        Get Which_Data_Set iFile to hoDDO
15281>>>>>        If hoDDO Begin
15283>>>>>            Send Initialize_Visited of hoDDO False False
15284>>>>>            Send AdjustDeleteValidateStructure2 of hoDDO
15285>>>>>        End
15285>>>>>>
15285>>>>>    End_Procedure
15286>>>>>    
15286>>>>>    // Used to add a null parent to the list of parents that allow this
15286>>>>>    Procedure Set ParentNullAllowed Integer iParent Boolean bAllowed
15288>>>>>        Send AddServerData iParent 0 bAllowed
15289>>>>>    End_Procedure
15290>>>>>    
15290>>>>>    // returns true if null parent allowed for this parent file
15290>>>>>    Function ParentNullAllowed Integer iParent Returns Boolean
15292>>>>>        Boolean bValue
15292>>>>>        Get GetServerData iParent 0 to bValue
15293>>>>>        Function_Return bValue
15294>>>>>    End_Function
15295>>>>>    
15295>>>>>    // returns true if null parent allowed for this parent file. This is the function
15295>>>>>    // that can be used for augmentation. This is the methid that is called by the runtime
15295>>>>>    // to determine if a null parent is allowed
15295>>>>>    Function IsNullParentAllowed Integer iServer Returns Boolean
15297>>>>>        Boolean bAllowed
15297>>>>>        Get ParentNullAllowed iServer to bAllowed
15298>>>>>        Function_Return bAllowed
15299>>>>>    End_Function
15300>>>>>    
15300>>>>>    Procedure Set ParentNoSwitchIfCommitted Integer iParent Boolean bAllowed
15302>>>>>        Send AddServerData iParent 1 bAllowed
15303>>>>>    End_Procedure
15304>>>>>    
15304>>>>>    Function ParentNoSwitchIfCommitted Integer iParent Returns Boolean
15306>>>>>        Boolean bValue
15306>>>>>        Get GetServerData iParent 1 to bValue
15307>>>>>        Function_Return bValue
15308>>>>>    End_Function
15309>>>>>    
15309>>>>>    
15309>>>>>    Procedure Set CascadeDeleteAllowed Integer iParent Boolean bAllowed
15311>>>>>        Send AddServerData iParent 2 (not(bAllowed))
15312>>>>>    End_Procedure
15313>>>>>    
15313>>>>>    Function CascadeDeleteAllowed Integer iParent Returns Boolean
15315>>>>>        Boolean bValue
15315>>>>>        Get GetServerData iParent 2 to bValue // note that False=allowed
15316>>>>>        Function_Return (not(bValue))
15317>>>>>    End_Function
15318>>>>>    
15318>>>>>    Function IsCascadeDeleteAllowed Integer iServer Returns Boolean
15320>>>>>        Boolean bAllowed
15320>>>>>        Get CascadeDeleteAllowed iServer to bAllowed
15321>>>>>        Function_Return bAllowed
15322>>>>>    End_Function
15323>>>>>    
15323>>>>>    Procedure Set CascadeDeleteNull Integer iParent Boolean bAllowed
15325>>>>>        Send AddServerData iParent 3 bAllowed
15326>>>>>    End_Procedure
15327>>>>>    
15327>>>>>    Function CascadeDeleteNull Integer iParent Returns Boolean
15329>>>>>        Boolean bValue
15329>>>>>        Get GetServerData iParent 3 to bValue
15330>>>>>        Function_Return bValue
15331>>>>>    End_Function
15332>>>>>    
15332>>>>>    Function IsCascadeDeleteNull Integer iServer Returns Boolean
15334>>>>>        Boolean bAllowed
15334>>>>>        Get CascadeDeleteNull iServer to bAllowed
15335>>>>>        Function_Return bAllowed
15336>>>>>    End_Function
15337>>>>>    
15337>>>>>    // return an array with the server path from this DD to passed top. The top will be
15337>>>>>    // in 0 and its child in 1, grand-child in 2, etc. If empty, no path was found. To start
15337>>>>>    // this process the byref hoDDs array MUST be empty
15337>>>>>    Procedure DDOServerPath Handle hoTop Handle[] ByRef hoDDs
15339>>>>>        Handle hoServer
15339>>>>>        Integer iServers iServer
15339>>>>>        If (hoTop=Self) Begin
15341>>>>>            Move Self to hoDDs[SizeOfArray(hoDDs)]
15342>>>>>            Procedure_Return
15343>>>>>        End
15343>>>>>>
15343>>>>>        Get Data_Set_Server_Count to iServers
15344>>>>>        For iServer from 0 to (iServers-1)
15350>>>>>>
15350>>>>>            Get Data_Set_Server iServer to hoServer
15351>>>>>            Send DDOServerPath of hoServer hoTop (&hoDDs)
15352>>>>>            If (SizeOfArray(hoDDs)) Begin
15354>>>>>                Move Self to hoDDs[SizeOfArray(hoDDs)]
15355>>>>>                Procedure_Return
15356>>>>>            End
15356>>>>>>
15356>>>>>        Loop
15357>>>>>>
15357>>>>>    End_Procedure
15358>>>>>    
15358>>>>>    // returns True if the value passed can be considered empty for this field.
15358>>>>>    Function IsEmptyField Integer iField String sValue Returns Boolean
15360>>>>>        Integer iFile iDataType iValidationType
15360>>>>>        Number nNum
15360>>>>>        Boolean bInvalid bChecked
15360>>>>>        Get Main_File to iFile
15361>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iDataType
15364>>>>>        Get IsDataInvalid iDataType sValue to bInvalid
15365>>>>>        If bInvalid Begin
15367>>>>>            Function_Return True
15368>>>>>        End
15368>>>>>>
15368>>>>>        
15368>>>>>        // DDs set checkbox fields to the False value as default. We must test its select_state
15368>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField to iValidationType
15369>>>>>        If (iValidationType=FA_VALIDATION_TYPE_CHECKBOX) Begin
15371>>>>>            Get Field_Select_State iField to bChecked
15372>>>>>            If not bChecked Begin
15374>>>>>                Function_Return True
15375>>>>>            End
15375>>>>>>
15375>>>>>        End
15375>>>>>>
15375>>>>>        
15375>>>>>        If ((iDataType=DF_BCD or iDataType=DF_DATE) and (Number(sValue)=0)) Begin
15377>>>>>            Move "" to sValue
15378>>>>>        End
15378>>>>>>
15378>>>>>        Else If (iDataType=DF_DATETIME and IsNullDateTime(cast(sValue,DateTime))) Begin
15381>>>>>            Move "" to sValue
15382>>>>>        End
15382>>>>>>
15382>>>>>        Function_Return (sValue="")
15383>>>>>    End_Function
15384>>>>>    
15384>>>>>    
15384>>>>>    // is the record committed
15384>>>>>    Function IsCommitted Returns Boolean
15386>>>>>        Boolean bHasRecord
15386>>>>>        Get HasRecord to bHasRecord
15387>>>>>        Function_Return bHasRecord
15388>>>>>    End_Function
15389>>>>>    
15389>>>>>    // is the field committed. It assumes the record is already committed
15389>>>>>    Function IsFieldCommitted Integer iField Returns Boolean
15391>>>>>        Boolean bIsCommitted
15391>>>>>        Get Field_Option iField DD_COMMIT to bIsCommitted
15392>>>>>        Function_Return bIsCommitted
15393>>>>>    End_Function
15394>>>>>    
15394>>>>>    // is a parent change allowed for this parent server.
15394>>>>>    Function IsCommittedParentChangeAllowed Integer iServer Returns Boolean
15396>>>>>        Boolean bNoSwitch
15396>>>>>        Get ParentNoSwitchIfCommitted iServer to bNoSwitch
15397>>>>>        Function_Return (not(bNoSwitch))
15398>>>>>    End_Function
15399>>>>>    
15399>>>>>    // Are we allowed to find with this file when it is used as a parent?
15399>>>>>    // Check all child DDOs and see if any are committed and do not allow switching parents when committed.
15399>>>>>    //  The rules for each child are switching is ok If:
15399>>>>>    // 1. the child is not committed,
15399>>>>>    // 2. it has a relates-to constraint (Find will change child which is ok)
15399>>>>>    // 3. if IsCommittedParentChangeAllowed allowed.
15399>>>>>    //
15399>>>>>    Function AllowParentFind Returns Boolean
15401>>>>>        Integer iClients iClient iMain
15401>>>>>        Handle hoChild
15401>>>>>        Boolean bIsCommitted
15401>>>>>        Get Data_Set_Client_Count to iClients
15402>>>>>        For iClient from 0 to (iClients-1)
15408>>>>>>
15408>>>>>            Get Data_Set_Client iClient to hoChild
15409>>>>>            Get IsCommitted of hoChild to bIsCommitted
15410>>>>>            If bIsCommitted Begin
15412>>>>>                Get Main_File to iMain
15413>>>>>                Get IsRelatesToConstrained of hoChild iMain to bIsCommitted
15414>>>>>                If not bIsCommitted Begin
15416>>>>>                    Get IsCommittedParentChangeAllowed of hoChild iMain to bIsCommitted
15417>>>>>                    If (not(bIsCommitted)) Begin
15419>>>>>                        Function_Return False
15420>>>>>                    End
15420>>>>>>
15420>>>>>                End
15420>>>>>>
15420>>>>>            End
15420>>>>>>
15420>>>>>        Loop
15421>>>>>>
15421>>>>>        Function_Return True
15422>>>>>    End_Function
15423>>>>>    
15423>>>>>    // aumgented to do nothing if there is no index (instead of annoying error message) and
15423>>>>>    // to do nothing if a find is not allowed because it is a no switch parent of a committed child.
15423>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
15425>>>>>        
15425>>>>>        Integer iIndex iMain
15425>>>>>        Handle  hoOwner
15425>>>>>        Boolean bOk
15425>>>>>        
15425>>>>>        Get File_Field_Index iFile iField to iIndex
15426>>>>>        If (iIndex=-1)  Begin
15428>>>>>            Procedure_Return
15429>>>>>        End
15429>>>>>>
15429>>>>>        Get Main_File to iMain
15430>>>>>        If (iMain<>iFile) Begin
15432>>>>>            Get Which_Data_Set iFile to hoOwner
15433>>>>>            If hoOwner Begin
15435>>>>>                Get AllowParentFind of hoOwner to bOk
15436>>>>>                If not bOk Begin
15438>>>>>                    Procedure_Return
15439>>>>>                End
15439>>>>>>
15439>>>>>            End
15439>>>>>>
15439>>>>>        End
15439>>>>>>
15439>>>>>        
15439>>>>>        If not bDeferred Begin
15441>>>>>            Send Refind_Records // make sure the buffers are correct before the find
15442>>>>>        End
15442>>>>>>
15442>>>>>        
15442>>>>>        Forward Send Item_Find eFindMode iFile iField bDoEntryUpdate bShowFindErr bDeferred
15444>>>>>    End_Procedure
15445>>>>>    
15445>>>>>    
15445>>>>>    Function Field_CommitNoEnterOnIndex Integer iField Returns Boolean
15447>>>>>        Function_Return False
15448>>>>>    End_Function
15449>>>>>    
15449>>>>>    // Return the committed options for this field based on the committed status or this record,
15449>>>>>    // the committed status of the field and whether, if committed, it should be noput or noput+noenter
15449>>>>>    Function File_Field_Committed_Options Integer iFile Integer iField Returns Integer
15451>>>>>        Boolean bIsCommitted bNoEnter
15451>>>>>        Integer iNewOpts iIndex
15451>>>>>        Handle hoOwner
15451>>>>>        
15451>>>>>        Get Which_Data_Set iFile to hoOwner
15452>>>>>        If not hoOwner ;            Function_Return 0
15455>>>>>        
15455>>>>>        Get File_Field_Index iFile iField to iIndex
15456>>>>>        Get IsCommitted of hoOwner to bIsCommitted
15457>>>>>        If bIsCommitted Begin
15459>>>>>            Get IsFieldCommitted of hoOwner iField to bIsCommitted
15460>>>>>            If bIsCommitted Begin
15462>>>>>                Move True to bNoEnter
15463>>>>>                If (iIndex<>-1) Begin
15465>>>>>                    Get Field_CommitNoEnterOnIndex iField to bNoEnter
15466>>>>>                End
15466>>>>>>
15466>>>>>                // if committed, it is noput and, if non-indexed, also noenter
15466>>>>>                Move (If(bNoEnter,DD_DISPLAYONLY,DD_NOPUT)) to iNewOpts
15467>>>>>            End
15467>>>>>>
15467>>>>>        End
15467>>>>>>
15467>>>>>        // if a finding parent field, we want to know if you are allowed to switch parents as we will assume
15467>>>>>        // that this field is used for finding.
15467>>>>>        If (hoOwner<>Self and iIndex>-1) Begin
15469>>>>>            Get AllowParentFind of hoOwner to bIsCommitted
15470>>>>>            If not bIsCommitted Begin
15472>>>>>                Move DD_DISPLAYONLY to iNewOpts
15473>>>>>            End
15473>>>>>>
15473>>>>>        End
15473>>>>>>
15473>>>>>        
15473>>>>>        Function_Return iNewOpts
15474>>>>>    End_Function
15475>>>>>    
15475>>>>>    // Returns the current field-field options based on regular options, foreign field status
15475>>>>>    // plus committed record status
15475>>>>>    Function File_Field_DynamicEntryOptions Integer iFile Integer iField Returns Integer
15477>>>>>        Integer iCOpts iFOpts
15477>>>>>        If (iFile=0) Begin
15479>>>>>            Function_Return 0
15480>>>>>        End
15480>>>>>>
15480>>>>>        Get File_Field_Options iFile iField to iFOpts            // regular options (handles regular and foreign)
15481>>>>>        Get File_Field_Committed_Options iFile iField to iCOpts  // possible NoPut, NoEnter additions
15482>>>>>        Function_Return (iFOpts ior iCOpts)
15483>>>>>    End_Function
15484>>>>>    
15484>>>>>    Function DDRememberedFieldIndex Integer iField Returns Integer
15486>>>>>        tDDRemembered[] DefaultValues
15486>>>>>        tDDRemembered[] DefaultValues
15487>>>>>        tDDRemembered SearchItem
15487>>>>>        tDDRemembered SearchItem
15487>>>>>        Integer iIndex
15487>>>>>        Get pDDDefaults to DefaultValues
15488>>>>>        Move iField to SearchItem.iField
15489>>>>>        Move (SearchArray(SearchItem,DefaultValues)) to iIndex
15490>>>>>        Function_Return iIndex
15491>>>>>    End_Function
15492>>>>>    
15492>>>>>    // Interface used to set or clear a dynamic default (remembered) value for a DD field. If the
15492>>>>>    // value passed is empty ("" or as empty as defined by the data-type) it is cleared. If the value
15492>>>>>    // is DD_RememberLast, it will use the last value before a clear as the default, else it uses the
15492>>>>>    // passed value as the default
15492>>>>>    Procedure Set Field_RememberedValue Integer iField String sValue
15494>>>>>        tDDRemembered[] DefaultValues
15494>>>>>        tDDRemembered[] DefaultValues
15495>>>>>        Integer iIndex
15495>>>>>        Boolean bNull
15495>>>>>        Get DDRememberedFieldIndex iField to iIndex
15496>>>>>        Get pDDDefaults to DefaultValues
15497>>>>>        If (sValue<>DD_RememberLast) Begin // if it is rememberlast, we know it is not null
15499>>>>>            Get IsEmptyField iField sValue to bNull
15500>>>>>        End
15500>>>>>>
15500>>>>>        If (not(bNull)) Begin
15502>>>>>            If (iIndex=-1) Begin
15504>>>>>                Move (SizeOfArray(DefaultValues)) to iIndex
15505>>>>>                Move iField to DefaultValues[iIndex].iField
15506>>>>>            End
15506>>>>>>
15506>>>>>            Move sValue to DefaultValues[iIndex].sDefault
15507>>>>>            Set pDDDefaults to DefaultValues
15508>>>>>        End
15508>>>>>>
15508>>>>>        Else If  (iIndex<>-1) Begin
15511>>>>>            Set pDDDefaults to (RemoveFromArray(DefaultValues,iIndex))
15512>>>>>        End
15512>>>>>>
15512>>>>>    End_Procedure
15513>>>>>    
15513>>>>>    // get the remembered value as per rules above
15513>>>>>    Function Field_RememberedValue Integer iField Returns String
15515>>>>>        tDDRemembered[] DefaultValues
15515>>>>>        tDDRemembered[] DefaultValues
15516>>>>>        Integer iIndex
15516>>>>>        Get DDRememberedFieldIndex iField to iIndex
15517>>>>>        If (iIndex<>-1) Begin
15519>>>>>            Get pDDDefaults to DefaultValues
15520>>>>>            Function_Return DefaultValues[iIndex].sDefault
15521>>>>>        End
15521>>>>>>
15521>>>>>        Function_Return ''
15522>>>>>    End_Function
15523>>>>>    
15523>>>>>    Procedure AssignDynamicDefaults
15525>>>>>        Integer iField iFields iFile
15525>>>>>        tDDRemembered[] DefaultValues
15525>>>>>        tDDRemembered[] DefaultValues
15526>>>>>        Boolean bMain
15526>>>>>        String sValue
15526>>>>>        
15526>>>>>        Get Main_File to iFile
15527>>>>>        Get pDDDefaults to DefaultValues
15528>>>>>        Move (SizeOfArray(DefaultValues)) to iFields
15529>>>>>        For iField from 0 to (iFields-1)
15535>>>>>>
15535>>>>>            If ( DefaultValues[iField].sDefault<>"") Begin
15537>>>>>                If (DefaultValues[iField].sDefault=DD_RememberLast) Begin
15539>>>>>                    Move DefaultValues[iField].sLastValue to sValue
15540>>>>>                End
15540>>>>>>
15540>>>>>                Else Begin
15541>>>>>                    Move DefaultValues[iField].sDefault to sValue
15542>>>>>                End
15542>>>>>>
15542>>>>>                Set Field_Changed_Value DefaultValues[iField].iField to sValue
15543>>>>>            End
15543>>>>>>
15543>>>>>        Loop
15544>>>>>>
15544>>>>>    End_Procedure
15545>>>>>    
15545>>>>>    // Clears all remembered defaults for this DD.
15545>>>>>    Procedure ClearRememberedDefaults
15547>>>>>        tDDRemembered[] DefaultValues
15547>>>>>        tDDRemembered[] DefaultValues
15548>>>>>        Set pDDDefaults to DefaultValues
15549>>>>>    End_Procedure
15550>>>>>    
15550>>>>>    Procedure PrivateClearAllRememberedDefaults
15552>>>>>        Integer iCount iMax
15552>>>>>        Handle hoDD
15552>>>>>        Boolean bVisisted
15552>>>>>        
15552>>>>>        Set Visited_State to True
15553>>>>>        
15553>>>>>        Get Data_Set_Server_Count to iMax
15554>>>>>        Decrement iMax
15555>>>>>        For iCount from 0 to iMax
15561>>>>>>
15561>>>>>            Get Data_Set_Server iCount to hoDD
15562>>>>>            Get Visited_State of hoDD to bVisisted
15563>>>>>            If not (bVisisted) Begin
15565>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
15566>>>>>            End
15566>>>>>>
15566>>>>>        Loop
15567>>>>>>
15567>>>>>        
15567>>>>>        Send ClearRememberedDefaults
15568>>>>>        
15568>>>>>        Get Data_Set_Client_Count to iMax
15569>>>>>        Decrement iMax
15570>>>>>        For iCount from 0 to iMax
15576>>>>>>
15576>>>>>            Get Data_Set_Client iCount to hoDD
15577>>>>>            Get Visited_State of hoDD to bVisisted
15578>>>>>            If not (bVisisted) Begin
15580>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
15581>>>>>            End
15581>>>>>>
15581>>>>>        Loop
15582>>>>>>
15582>>>>>        
15582>>>>>    End_Procedure
15583>>>>>    
15583>>>>>    // Clears all remembered defaults for all DDs in this structure.
15583>>>>>    Procedure ClearAllRememberedDefaults
15585>>>>>        Send InitializeAllVisited
15586>>>>>        Send PrivateClearAllRememberedDefaults
15587>>>>>    End_Procedure
15588>>>>>    
15588>>>>>    // This is called after a clear or clear all is sent to this DD. It does autofinds as needed
15588>>>>>    // for any parent DDs. It does this if the parent is not a relates to contraining parent, if
15588>>>>>    // a field has an index, it has a changed value and it is autofind or autofind_ge.
15588>>>>>    Procedure DefaultParentAutofinds
15590>>>>>        Integer i iServers iField iFields iFile iIndex iOpts
15590>>>>>        Boolean bDoAutoFind bRelates bIsEmptyField
15590>>>>>        String sValue
15590>>>>>        Handle hoServer
15590>>>>>        Get Data_Set_Server_Count to iServers
15591>>>>>        For i from 0 to (iServers-1)
15597>>>>>>
15597>>>>>            Get Data_Set_Server i to hoServer
15598>>>>>            Get Main_File of hoServer to iFile
15599>>>>>            Get IsRelatesToConstrained iFile to bRelates
15600>>>>>            // never autofind on a relates-to constraining parent
15600>>>>>            If not (bRelates) Begin
15602>>>>>                
15602>>>>>                Get Field_Count of hoServer to iFields
15603>>>>>                Move False to bDoAutoFind
15604>>>>>                Move 1 to iField
15605>>>>>                While (not(bDoAutoFind) and (iField<=iFields))
15609>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
15612>>>>>                    If (iIndex>0) Begin
15614>>>>>                        Get Field_Changed_State of hoServer iField to bDoAutoFind
15615>>>>>                        If bDoAutoFind Begin
15617>>>>>                            Get Field_Current_Value of hoServer iField to sValue
15618>>>>>                            Get IsEmptyField of hoServer iField sValue to bIsEmptyField
15619>>>>>                            Move (not(bIsEmptyField)) to bDoAutoFind
15620>>>>>                            If bDoAutoFind Begin
15622>>>>>                                Get File_Field_Options iFile iField to iOpts
15623>>>>>                                // if this is a retain or retainall we don't do this because we want
15623>>>>>                                // to maintain backwards compatibility
15623>>>>>                                Move ( (iOpts iand DD_AUTOFIND or iOpts iand DD_AUTOFIND_GE) and ;                                    not( iOpts iand DD_RETAIN or iOpts iand DD_RETAINALL) ) to bDoAutoFind
15624>>>>>                                If bDoAutoFind Begin
15626>>>>>                                    Send File_Field_Default_AutoFind iFile iField
15627>>>>>                                    Set Changed_State to False // clears parent changed state
15628>>>>>                                End
15628>>>>>>
15628>>>>>                            End
15628>>>>>>
15628>>>>>                        End
15628>>>>>>
15628>>>>>                    End
15628>>>>>>
15628>>>>>                    Increment iField
15629>>>>>                Loop
15630>>>>>>
15630>>>>>                
15630>>>>>                // Only check for grandparent autofinds if this parent did not do a an autofind
15630>>>>>                // Doing an autofind on an autofind parent's parent is just too confusing
15630>>>>>                If not bDoAutoFind Begin
15632>>>>>                    Send DefaultParentAutofinds of hoServer
15633>>>>>                End
15633>>>>>>
15633>>>>>            End
15633>>>>>>
15633>>>>>        Loop
15634>>>>>>
15634>>>>>    End_Procedure
15635>>>>>    
15635>>>>>    // Set this DD to be an alias, passing the file number of the alias
15635>>>>>    // This can only be called once per instance and the Main_File must already have been set
15635>>>>>    // most likely in a superclass.
15635>>>>>    // This sets Main_File to the alias, stores the original master file (accessed via MasterForAlias).
15635>>>>>    // It also clears all existing relatonships. Normally we expect the alias class to set
15635>>>>>    // sets pbUseDDRelates and pbNoCascadeDeleteStrict to true. We don't do that automatically so that
15635>>>>>    // the Studio's property panel will show the correct values. When an alias is defined using the
15635>>>>>    // studio it will set these two properties.
15635>>>>>    // This means you must set any required relationships yourself
15635>>>>>    Procedure Set Alias_File Integer iTable
15637>>>>>        Integer iMain iMaster iFieldsM iFieldsA
15637>>>>>        Get Main_File to iMain
15638>>>>>        Get MasterForAlias to iMaster
15639>>>>>        
15639>>>>>        If (iTable=0 and iMaster) Begin
15641>>>>>            Error DFERR_PROGRAM "Cannot unset alias table"
15642>>>>>>
15642>>>>>            Procedure_Return
15643>>>>>        End
15643>>>>>>
15643>>>>>        If (iTable=iMain) Begin
15645>>>>>            Error DFERR_PROGRAM "Cannot set alias table to self"
15646>>>>>>
15646>>>>>            Procedure_Return
15647>>>>>        End
15647>>>>>>
15647>>>>>        If (iMaster) Begin
15649>>>>>            Error DFERR_PROGRAM "Cannot redefine alias table"
15650>>>>>>
15650>>>>>            Procedure_Return
15651>>>>>        End
15651>>>>>>
15651>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iMain to iFieldsM
15654>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iFieldsA
15657>>>>>        If (iFieldsA<>iFieldsM) Begin
15659>>>>>            Error DFERR_PROGRAM "Alias and Master file are not based on the same table"
15660>>>>>>
15660>>>>>            Procedure_Return
15661>>>>>        End
15661>>>>>>
15661>>>>>        
15661>>>>>        Set piMasterTable to iMain
15662>>>>>        Set Main_File to iTable
15663>>>>>        Send DefineAsAlias
15664>>>>>    End_Procedure
15665>>>>>    
15665>>>>>    Procedure DefineAsAlias
15667>>>>>        Integer i iFile
15667>>>>>        
15667>>>>>        // We expect he developer to set these properties to True
15667>>>>>        //Set pbUseDDRelates to True
15667>>>>>        //Set pbNoCascadeDeleteStrict to True
15667>>>>>        
15667>>>>>        Send ClearDDRelates
15668>>>>>        Get Client_File_Count to i
15669>>>>>        While i
15673>>>>>            Decrement i
15674>>>>>            Get Client_File i to iFile
15675>>>>>            Send Remove_Client_File iFile
15676>>>>>        Loop
15677>>>>>>
15677>>>>>        Get Server_File_Count to i
15678>>>>>        While i
15682>>>>>            Decrement i
15683>>>>>            Get Server_File i to iFile
15684>>>>>            Send Remove_Server_File iFile
15685>>>>>        Loop
15686>>>>>>
15686>>>>>    End_Procedure
15687>>>>>    
15687>>>>>    Function MasterForAlias Returns Integer
15689>>>>>        Integer iMaster
15689>>>>>        Get piMasterTable to iMaster
15690>>>>>        Function_Return iMaster
15691>>>>>    End_Function
15692>>>>>    
15692>>>>>    Function IsAlias Returns Boolean
15694>>>>>        Integer iMaster
15694>>>>>        Get piMasterTable to iMaster
15695>>>>>        Function_Return (iMaster<>0)
15696>>>>>    End_Function
15697>>>>>    
15697>>>>>    
15697>>>>>    Procedure OnSaveRecord
15699>>>>>    End_Procedure
15700>>>>>    
15700>>>>>    Procedure StoreDefaultSQLFilters
15702>>>>>        Handle hoSQLHelper
15702>>>>>        Get phoSQLHelper to hoSQLHelper
15703>>>>>        Send StoreDefaultSQLFilters of hoSQLHelper
15704>>>>>    End_Procedure
15705>>>>>    
15705>>>>>    Procedure RestoreDefaultSQLFilters
15707>>>>>        Handle hoSQLHelper
15707>>>>>        Get phoSQLHelper to hoSQLHelper
15708>>>>>        Send RestoreDefaultSQLFilters of hoSQLHelper
15709>>>>>    End_Procedure
15710>>>>>    
15710>>>>>    Procedure ApplySQLFilterStr String sFilter
15712>>>>>        Handle hoSQLHelper
15712>>>>>        Get phoSQLHelper to hoSQLHelper
15713>>>>>        Send ApplySQLFilterStr of hoSQLHelper sFilter
15714>>>>>    End_Procedure
15715>>>>>    
15715>>>>>    Procedure ApplySQLFilter
15717>>>>>        String sNewFilter sOldFilter
15717>>>>>        Boolean bApplyGlobalSQLFilters bOldFilterActive
15717>>>>>        Get psSQLFilter to sNewFilter
15718>>>>>        // if we have am active  table filter we can either ignore it or and it to the where clause
15718>>>>>        // pbApplyGlobalSQLFilters determines what to do.
15718>>>>>        Get pbApplyGlobalSQLFilters to bApplyGlobalSQLFilters
15719>>>>>        Get pbOldFilterActive to bOldFilterActive
15720>>>>>        If (bApplyGlobalSQLFilters and bOldFilterActive) Begin
15722>>>>>            Get psOldFilter to sOldFilter
15723>>>>>            Get SQLStrAppend sOldFilter sNewFilter to sNewFilter
15724>>>>>        End
15724>>>>>>
15724>>>>>        Send ApplySQLFilterStr sNewFilter
15725>>>>>    End_Procedure
15726>>>>>    
15726>>>>>    Procedure Data_Set_PreFind
15728>>>>>        Boolean bUseDDSQLFilters
15728>>>>>        String sOldDDFilter
15728>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
15729>>>>>        If bUseDDSQLFilters Begin
15731>>>>>            
15731>>>>>            Send StoreDefaultSQLFilters
15732>>>>>            
15732>>>>>            // this can get called during cascade deletes. In such a case we will
15732>>>>>            // never explicitly not apply an SQL filters because it could violate relational integrity
15732>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
15734>>>>>                Get psSQLFilter to sOldDDFilter
15735>>>>>                Set psSQLFilter to "" // make sure there is no filter applied
15736>>>>>            End
15736>>>>>>
15736>>>>>            
15736>>>>>            Send ApplySQLFilter
15737>>>>>            
15737>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
15739>>>>>                Set psSQLFilter to sOldDDFilter
15740>>>>>            End
15740>>>>>>
15740>>>>>        End
15740>>>>>>
15740>>>>>    End_Procedure
15741>>>>>    
15741>>>>>    Procedure Data_Set_PostFind
15743>>>>>        Boolean bUseDDSQLFilters
15743>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
15744>>>>>        If bUseDDSQLFilters Begin
15746>>>>>            Send RestoreDefaultSQLFilters
15747>>>>>        End
15747>>>>>>
15747>>>>>    End_Procedure
15748>>>>>    
15748>>>>>    
15748>>>>>    // returns active constraints in atConstraintDef array.
15748>>>>>    // Should be called after constraints are built
15748>>>>>    // typically right after Rebuild_Constraints
15748>>>>>    
15748>>>>>    Function DDOConstraints Returns tConstraintDef[]
15750>>>>>        tConstraintDef[] Constraints
15750>>>>>        tConstraintDef[] Constraints
15751>>>>>        Integer i iCount i1
15751>>>>>        Get DATA_SET_CONSTRAINT_COUNT to iCount
15752>>>>>        For i from 0 to (iCount-1)
15758>>>>>>
15758>>>>>            Get DATA_SET_CONSTRAINT_INFO i 0 to i1 // type / mode
15759>>>>>            Move (Hi(i1)) to  Constraints[i].eType
15760>>>>>            Move (Low(i1)) to  Constraints[i].eMode
15761>>>>>            Get DATA_SET_CONSTRAINT_INFO i 1 to i1 // file / field
15762>>>>>            Move (Hi(i1)) to  Constraints[i].iFile
15763>>>>>            Move (Low(i1)) to  Constraints[i].iField
15764>>>>>            Get DATA_SET_CONSTRAINT_INFO i 2 to i1 // other file /field
15765>>>>>            Move (Hi(i1)) to  Constraints[i].iOtherFile
15766>>>>>            Move (Low(i1)) to  Constraints[i].iOtherField
15767>>>>>            Get DATA_SET_CONSTRAINT_INFO_Value i  to Constraints[i].sValue
15768>>>>>        Loop
15769>>>>>>
15769>>>>>        Function_Return Constraints
15770>>>>>    End_Function
15771>>>>>    
15771>>>>>    // returns constraint finding information about the current find. This tells us what kinds
15771>>>>>    // of constraint find "expressions" are used. This will actually do a cosntrained find
15771>>>>>    // initialization much like Establish_Find_Direction, which means it can change the values in
15771>>>>>    // the file buffer to assist with a jump-in.
15771>>>>>    Function DDOConstraintFindMeta Integer eMode Integer iOrder Returns tDDOConstraintFindMeta
15773>>>>>        tDDOConstraintFindMeta FindMeta
15773>>>>>        tDDOConstraintFindMeta FindMeta
15773>>>>>        Integer i
15773>>>>>        Get Data_Set_Constraint_Exps eMode iOrder to i
15774>>>>>        Move (Hi(i)) to FindMeta.iJumpInSegments
15775>>>>>        Move (i iand CONST_EXP_JUMPOUT) to FindMeta.bJumpOut
15776>>>>>        Move (i iand CONST_EXP_PRE_RELATE) to FindMeta.bPreRelate
15777>>>>>        Move (i iand CONST_EXP_POST_RELATE) to FindMeta.bPostRelate
15778>>>>>        Function_Return FindMeta
15779>>>>>    End_Function
15780>>>>>    
15780>>>>>    // this tells you if the current find or read requires a relate to evaluate the DF constraint.
15780>>>>>    // If false you could use this to set no_relate_state to false for the find/read process and then
15780>>>>>    // restore it when complete. Be careful using this.
15780>>>>>    Function DDOConstraintNeedsRelate Integer iOrder Returns Boolean
15782>>>>>        tDDOConstraintFindMeta FindMeta
15782>>>>>        tDDOConstraintFindMeta FindMeta
15782>>>>>        Get DDOConstraintFindMeta (GE) iOrder to FindMeta
15783>>>>>        Function_Return FindMeta.bPostRelate
15784>>>>>    End_Function
15785>>>>>    
15785>>>>>    // returns true if this table supports SQL filter interface
15785>>>>>    Function SupportsSQLFilters Returns Boolean
15787>>>>>        Boolean bSupports
15787>>>>>        Handle hoSQLHelper
15787>>>>>        Get phoSQLHelper to hoSQLHelper
15788>>>>>        Get SupportsSQLFilters of hoSQLHelper to bSupports
15789>>>>>        Function_Return bSupports
15790>>>>>    End_Function
15791>>>>>    
15791>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
15791>>>>>    
15791>>>>>    // Creates an SQL Like Filter for this field and search target
15791>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
15793>>>>>        String sFilter
15793>>>>>        Handle hoSQLHelper
15793>>>>>        Get phoSQLHelper to hoSQLHelper
15794>>>>>        Get SQLStrLike of hoSQLHelper iField sSearch to sFilter
15795>>>>>        Function_Return sFilter
15796>>>>>    End_Function
15797>>>>>    
15797>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15797>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
15799>>>>>        Handle hoSQLHelper
15799>>>>>        Get phoSQLHelper to hoSQLHelper
15800>>>>>        Get SQLStrAppend of hoSQLHelper sOrigFilter sFilter to sFilter
15801>>>>>        Function_Return sFilter
15802>>>>>    End_Function
15803>>>>>    
15803>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
15803>>>>>    Function SQLStrAppendOr String sOrigFilter String sFilter Returns String
15805>>>>>        Handle hoSQLHelper
15805>>>>>        Get phoSQLHelper to hoSQLHelper
15806>>>>>        Get SQLStrAppendOr of hoSQLHelper sOrigFilter sFilter to sFilter
15807>>>>>        Function_Return sFilter
15808>>>>>    End_Function
15809>>>>>
15809>>>>>    // returns the name of the File and Field suitable for an SQL where statement
15809>>>>>    Function SQLStrFileFieldName Integer iField Returns String
15811>>>>>        String sName
15811>>>>>        Handle hoSQLHelper
15811>>>>>        Get phoSQLHelper to hoSQLHelper
15812>>>>>        Get SQLStrFileFieldName of hoSQLHelper iField to sName
15813>>>>>        Function_Return sName
15814>>>>>    End_Function
15815>>>>>
15815>>>>>    // returns the name of the Field suitable for an SQL where statement
15815>>>>>    Function SQLStrFieldName Integer iField Returns String
15817>>>>>        String sName
15817>>>>>        Handle hoSQLHelper
15817>>>>>        Get phoSQLHelper to hoSQLHelper
15818>>>>>        Get SQLStrFieldName of hoSQLHelper iField to sName
15819>>>>>        Function_Return sName
15820>>>>>    End_Function
15821>>>>>
15821>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement
15821>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
15823>>>>>        String sName
15823>>>>>        Handle hoSQLHelper
15823>>>>>        Get phoSQLHelper to hoSQLHelper
15824>>>>>        Get SQLStrSchemaFileFieldName of hoSQLHelper iField to sName
15825>>>>>        Function_Return sName
15826>>>>>    End_Function
15827>>>>>    
15827>>>>>    //  returns the name of a file suitable for a SQL statement
15827>>>>>    Function SQLStrFileName Integer iField Returns String
15829>>>>>        String sName
15829>>>>>        Handle hoSQLHelper
15829>>>>>        Get phoSQLHelper to hoSQLHelper
15830>>>>>        Get SQLStrFileName of hoSQLHelper iField to sName
15831>>>>>        Function_Return sName
15832>>>>>    End_Function
15833>>>>>    
15833>>>>>    // creates escaped SQL string by replacing single quote with two single quotes
15833>>>>>    Function SQLEscapedStr String sSQL Returns String
15835>>>>>        Handle hoSQLHelper
15835>>>>>        Get phoSQLHelper to hoSQLHelper
15836>>>>>        Get SQLEscapedStr of hoSQLHelper sSQL to sSQL
15837>>>>>        Function_Return sSQL
15838>>>>>    End_Function
15839>>>>>    
15839>>>>>    // Returns:
15839>>>>>    //       The record id string based on piPrimaryIndex.
15839>>>>>    Function PrimaryRecordId Returns String
15841>>>>>        Integer iIndex iFile iSegments iSegment iField
15841>>>>>        String sVal sId
15841>>>>>        
15841>>>>>        Get Main_File to iFile
15842>>>>>        Get piPrimaryIndex to iIndex
15843>>>>>        
15843>>>>>        If (iIndex < 0) Begin
15845>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
15848>>>>>        End
15848>>>>>>
15848>>>>>        
15848>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
15851>>>>>        For iSegment from 1 to iSegments
15857>>>>>>
15857>>>>>            Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
15860>>>>>            
15860>>>>>            Get_Field_Value iFile iField to sVal
15863>>>>>            Move (Trim(sVal)) to sVal
15864>>>>>            
15864>>>>>            //  Encode join sign for multi segment indexes
15864>>>>>            If (iSegments > 1) Begin
15866>>>>>                Move (Replaces("_", sVal, "~5F~")) to sVal
15867>>>>>            End
15867>>>>>>
15867>>>>>            
15867>>>>>            If (iSegment = 1) Begin
15869>>>>>                Move sVal to sId
15870>>>>>            End
15870>>>>>>
15870>>>>>            Else Begin
15871>>>>>                Move (sId + "_" + sVal) to sId
15872>>>>>            End
15872>>>>>>
15872>>>>>            
15872>>>>>        Loop
15873>>>>>>
15873>>>>>        
15873>>>>>        Function_Return sId
15874>>>>>    End_Function
15875>>>>>    
15875>>>>>    
15875>>>>>    // Finds a record on the global buffer based on the record id.
15875>>>>>    //
15875>>>>>    // Params:
15875>>>>>    //       sRecordId   Record id generated by PrimaryRecordId.
15875>>>>>    Function FindByPrimaryRecordId String sRecordId Returns Boolean
15877>>>>>        Integer iIndex iFile iSegments iSegment iField
15877>>>>>        String[] aValues
15878>>>>>        String sVal
15878>>>>>        Boolean bTrapped
15878>>>>>        
15878>>>>>        Get Main_File to iFile
15879>>>>>        Get piPrimaryIndex to iIndex
15880>>>>>        
15880>>>>>        If (iIndex < 0) Begin
15882>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
15885>>>>>        End
15885>>>>>>
15885>>>>>        
15885>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
15888>>>>>        
15888>>>>>        If (iSegments > 1) Begin
15890>>>>>            Move (StrSplitToArray(sRecordId, "_")) to aValues
15891>>>>>        End
15891>>>>>>
15891>>>>>        Else Begin
15892>>>>>            Move sRecordId to aValues[0]
15893>>>>>        End
15893>>>>>>
15893>>>>>        
15893>>>>>        If (iSegments = SizeOfArray(aValues)) Begin
15895>>>>>            Clear iFile
15896>>>>>            
15896>>>>>            Send Ignore_Error of Error_Object_Id 56
15897>>>>>            Send Ignore_Error of Error_Object_Id 11
15898>>>>>            
15898>>>>>            For iSegment from 1 to iSegments
15904>>>>>>
15904>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
15907>>>>>                
15907>>>>>                Move aValues[iSegment - 1] to sVal
15908>>>>>                If (iSegments > 1) Begin
15910>>>>>                    Move (Replaces("~5F~", sVal, "_")) to sVal
15911>>>>>                End
15911>>>>>>
15911>>>>>                
15911>>>>>                Set_Field_Value iFile iField to sVal
15914>>>>>            Loop
15915>>>>>>
15915>>>>>            Send Trap_Error of Error_Object_Id 56
15916>>>>>            Send Trap_Error of Error_Object_Id 11
15917>>>>>            
15917>>>>>            Vfind iFile iIndex EQ
15919>>>>>            
15919>>>>>            Function_Return (Found)
15920>>>>>        End
15920>>>>>>
15920>>>>>        
15920>>>>>        Function_Return False
15921>>>>>    End_Function
15922>>>>>    
15922>>>>>    // Converts a RecordId to a RowId by finding it on the global buffer.
15922>>>>>    //
15922>>>>>    // Params:
15922>>>>>    //       sRecordId   Record id based on piPrimaryIndex.
15922>>>>>    //       rRowId      (ByRef) Will be filled with the rowid.
15922>>>>>    // Returns:
15922>>>>>    //       True if the record id was valid.
15922>>>>>    Function RecordIdToRowId String sRecordId RowID ByRef rRowId Returns Boolean
15924>>>>>        Boolean bFound
15924>>>>>        
15924>>>>>        Get FindByPrimaryRecordId sRecordId to bFound
15925>>>>>        If (bFound) Begin
15927>>>>>            Move (GetRowID(Main_File(Self))) to rRowId
15928>>>>>        End
15928>>>>>>
15928>>>>>        Else Begin
15929>>>>>            Move (NullRowID()) to rRowId
15930>>>>>        End
15930>>>>>>
15930>>>>>        
15930>>>>>        Function_Return bFound
15931>>>>>    End_Function
15932>>>>>    
15932>>>>>    // Converts a RowId into a record ID. Note that it performs a find on the global buffer.
15932>>>>>    //
15932>>>>>    // Params:
15932>>>>>    //       riRowId     RowID.
15932>>>>>    // Returns:
15932>>>>>    //       Record id based on piPrimaryIndex.
15932>>>>>    Function RowIdToRecordId RowID riRowId Returns String
15934>>>>>        Boolean bFound
15934>>>>>        String sRecId
15934>>>>>        
15934>>>>>        If (not(IsNullRowID(riRowId))) Begin
15936>>>>>            Move (FindByRowID(Main_File(Self), riRowId)) to bFound
15937>>>>>            
15937>>>>>            If (bFound) Begin
15939>>>>>                Get PrimaryRecordId to sRecId
15940>>>>>            End
15940>>>>>>
15940>>>>>        End
15940>>>>>>
15940>>>>>        
15940>>>>>        Function_Return sRecId
15941>>>>>    End_Function
15942>>>>>End_Class
15943>>>>>
15943>>>>>// This message will be send as a notification message from an
15943>>>>>// Extended_Data_Set whenever a fieldvalue has been changed.
15943>>>>>// It has been defined FOR cUIObject or Desktop  here so that attached
15943>>>>>// DEO which do not know anything about Extended_Data_Sets don't get
15943>>>>>// frustrated.
15943>>>>>// All focusable objects and DEOs must understand this. This should be
15943>>>>>// changed at some point in the future.
15943>>>>>Function Extended_DEO_State for cUIObject Returns Integer
15945>>>>>End_Function
15946>>>>>
15946>>>>>
15946>>>>>// this command is now obsolete. use Set Field_auto_increment
15946>>>>>
15946>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
15946>>>>>// *** The Database Update Framework Include file for Languages ***
15946>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
15946>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
15946>>>>>//
15946>>>>>Use LanguageText.Pkg
15946>>>>>
15946>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
15946>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
15946>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
15946>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
15946>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
15946>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
15946>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
15946>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
15946>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
15946>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
15946>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
15946>>>>>    Define CS_DUF_CopyingData               for "Copying data"
15946>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
15946>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
15946>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
15946>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
15946>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
15946>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
15946>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
15946>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
15946>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
15946>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
15946>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
15946>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
15946>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
15946>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
15946>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
15946>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
15946>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
15946>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
15946>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
15946>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
15946>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
15946>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
15946>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
15946>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
15946>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>>>
15946>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
15946>>>>>// StatPnl.pkg - creates the standard status_panel object.
15946>>>>>//
15946>>>>>//
15946>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
15946>>>>>// invoke the standard status panel. The standard has always been that the package name
15946>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
15946>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
15946>>>>>// prior revisions has been replace with status panel that is part of the application.
15946>>>>>// This should work much better and faster than the old sentinel based solution.
15946>>>>>// While the way this operates has changed, the interface has not and therefore this should work
15946>>>>>// with most applications.
15946>>>>>//
15946>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
15946>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
15946>>>>>// a cleaner more robust interface.
15946>>>>>//
15946>>>>>//
15946>>>>>// Compatibility Note:
15946>>>>>//
15946>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
15946>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
15946>>>>>//
15946>>>>>// If for some reason you application will not work using this as a replacement for the old status
15946>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
15946>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
15946>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
15946>>>>>//
15946>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
15946>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
15946>>>>>//
15946>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
15946>>>>>// can still access the new object via the ghoStatusPanel handle.
15946>>>>>//
15946>>>>>//
15946>>>>>// Creating your own Status Panel objects
15946>>>>>//
15946>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
15946>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
15946>>>>>// with a different file and object name and direct your status panel request to the new object.
15946>>>>>//
15946>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
15946>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
15946>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
15946>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
15946>>>>>// e.g.
15946>>>>>//       Procedure UpdateStatusBar
15946>>>>>//           Send DoAdvance of oProgressBar
15946>>>>>//           Send ProcessEvents
15946>>>>>//       End_Procedure
15946>>>>>//
15946>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
15946>>>>>// messages this will be done for you.
15946>>>>>//
15946>>>>>// the standard Interface for status panels are:
15946>>>>>//
15946>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
15946>>>>>// Send Start_StatusPanel      - start the status panel
15946>>>>>// Send Stop_StatusPanel       - stop the status panel
15946>>>>>// Send Update_StatusPanel     - update the status panel's action area
15946>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
15946>>>>>//
15946>>>>>// Get/Set Caption_Text - updates the caption bar
15946>>>>>// Get/Set Title_Text   - updates the title area
15946>>>>>// Get/Set Message_Text - updates the Message area
15946>>>>>// Get/Set Action_Text  - updates the action area
15946>>>>>// Get/Set Button_Text  - updates the button area
15946>>>>>//
15946>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
15946>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
15946>>>>>//
15946>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
15946>>>>>Use cProcessStatusPanel.pkg
Including file: cProcessStatusPanel.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProcessStatusPanel.pkg)
15946>>>>>>>// cProcessStatusPanel.pkg
15946>>>>>>>//
15946>>>>>>>// Class used to create StatusPanels.
15946>>>>>>>//
15946>>>>>>>// This class does not provide any of the inner objects that make up a status panel. Instead an
15946>>>>>>>// interface is provided that is used to update the various areas of status panel. At this level,
15946>>>>>>>// those areas (title area, message area, action area, button area) are logical. You create the
15946>>>>>>>// physical objects at the object level and then bind these objects to the interface.
15946>>>>>>>// Take a look at StatPnl.pkg to see how this is used.
15946>>>>>>>//
15946>>>>>>>// the standard Interface for status panels are:
15946>>>>>>>//
15946>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
15946>>>>>>>// Send Start_StatusPanel      - start the status panel
15946>>>>>>>// Send Stop_StatusPanel       - stop the status panel
15946>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
15946>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
15946>>>>>>>//
15946>>>>>>>// Get/Set Caption_Text - updates the caption bar
15946>>>>>>>// Get/Set Title_Text   - updates the title area
15946>>>>>>>// Get/Set Message_Text - updates the Message area
15946>>>>>>>// Get/Set Action_Text  - updates the action area
15946>>>>>>>// Get/Set Button_Text  - updates the button area
15946>>>>>>>//
15946>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
15946>>>>>>>// Send EnableCancelButton - code must be provided in the cancel button object to enable/disable cancel button
15946>>>>>>>//
15946>>>>>>>
15946>>>>>>>Use cStatusPanel.pkg
Including file: cStatusPanel.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cStatusPanel.pkg)
15946>>>>>>>>>// This is an abstract class that can be used to create status panels. The interface at this level
15946>>>>>>>>>// is very simple. You can start, stop, request a cancel and allow the object to paint.
15946>>>>>>>>>//
15946>>>>>>>>>// Look at cProcessStatusPanel.pkg to see how this is used.
15946>>>>>>>>>
15946>>>>>>>>>Use Windows.pkg
15946>>>>>>>>>
15946>>>>>>>>>
15946>>>>>>>>>
15946>>>>>>>>>
15946>>>>>>>>>Class cStatusPanel is a FloatingPanel
15947>>>>>>>>>    
15947>>>>>>>>>    Procedure Construct_Object
15949>>>>>>>>>        Forward Send Construct_object
15951>>>>>>>>>        
15951>>>>>>>>>        Property Boolean pbCancel False
15952>>>>>>>>>        
15952>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True // kills sysmenu as long as there is no icon
15953>>>>>>>>>        Set Icon to '' // this must be cleared so there will be no icon
15954>>>>>>>>>        Set locate_mode to CENTER_ON_PANEL
15955>>>>>>>>>        Set Border_Style  to Border_Dialog
15956>>>>>>>>>        // should be scoped so it will not try to change the focus if there is no focusable button inside
15956>>>>>>>>>        Set Scope_State to True
15957>>>>>>>>>        
15957>>>>>>>>>        On_Key KEXIT_APPLICATION Send Close_Panel
15958>>>>>>>>>    End_Procedure
15959>>>>>>>>>    
15959>>>>>>>>>    // this is private and required. Never send this.
15959>>>>>>>>>    Procedure Deactivate_Group
15961>>>>>>>>>        If (Active_State(Self)) Begin
15963>>>>>>>>>            Send SuspendGUI of Desktop False
15964>>>>>>>>>        End
15964>>>>>>>>>>
15964>>>>>>>>>        Forward Send Deactivate_Group
15966>>>>>>>>>    End_Procedure
15967>>>>>>>>>    
15967>>>>>>>>>    // Send this message to stop the panel
15967>>>>>>>>>    Procedure Deactivate
15969>>>>>>>>>        If (Active_State(Self)) Begin
15971>>>>>>>>>            Send SuspendGUI of Desktop False
15972>>>>>>>>>        End
15972>>>>>>>>>>
15972>>>>>>>>>        Forward Send Deactivate
15974>>>>>>>>>    End_Procedure
15975>>>>>>>>>    
15975>>>>>>>>>    // Send this message to start the panel
15975>>>>>>>>>    Procedure Activate
15977>>>>>>>>>        If not (Active_State(Self)) Begin
15979>>>>>>>>>            Set pbCancel to False
15980>>>>>>>>>            Send SuspendGUI of Desktop True
15981>>>>>>>>>        End
15981>>>>>>>>>>
15981>>>>>>>>>        Forward Send Activate
15983>>>>>>>>>    End_Procedure
15984>>>>>>>>>    
15984>>>>>>>>>    // This allows the panel to paint when used in a tight loop, which is what status panels are
15984>>>>>>>>>    // used for. Any time you update the panel or wish to check for a cancel, you should call this.
15984>>>>>>>>>    Procedure ProcessEvents
15986>>>>>>>>>        If (Active_State(Self)) Begin
15988>>>>>>>>>            Send PumpMsgQueue of Desktop
15989>>>>>>>>>        End
15989>>>>>>>>>>
15989>>>>>>>>>    End_Procedure
15990>>>>>>>>>    
15990>>>>>>>>>    // note close panel does not actually close the panel. It just sets pbCancel to True, informing the
15990>>>>>>>>>    // process using this that it wants to close. It is then up the process close the panel.
15990>>>>>>>>>    Procedure Close_Panel
15992>>>>>>>>>        Set pbCancel to True
15993>>>>>>>>>    End_Procedure
15994>>>>>>>>>    
15994>>>>>>>>>End_Class
15995>>>>>>>
15995>>>>>>>
15995>>>>>>>
15995>>>>>>>Class cProcessStatusPanel is a cStatusPanel
15996>>>>>>>    
15996>>>>>>>    Procedure Construct_Object
15998>>>>>>>        Forward Send Construct_object
16000>>>>>>>        // determines if panel can be canceled
16000>>>>>>>        Property Boolean Allow_Cancel_State True
16001>>>>>>>    End_Procedure
16002>>>>>>>    
16002>>>>>>>    // Any of the properties that change the text of a status panel must also send
16002>>>>>>>    // ProcessEvents which allows the panel to process painting messages. The ProcessEvents
16002>>>>>>>    // is essential when using status panels within a tight loop
16002>>>>>>>    
16002>>>>>>>    Procedure Set Caption_text String sText
16004>>>>>>>        Set Label to sText
16005>>>>>>>        Send ProcessEvents
16006>>>>>>>    End_Procedure
16007>>>>>>>    
16007>>>>>>>    Function Caption_Text Returns String
16009>>>>>>>        Function_Return (Label(Self))
16010>>>>>>>    End_Function
16011>>>>>>>    
16011>>>>>>>    Procedure Set Message_Text String sText
16013>>>>>>>        Send ProcessEvents
16014>>>>>>>    End_Procedure
16015>>>>>>>    
16015>>>>>>>    Function Message_Text Returns String
16017>>>>>>>    End_Function
16018>>>>>>>    
16018>>>>>>>    Procedure Set Action_Text String sText
16020>>>>>>>        Send ProcessEvents
16021>>>>>>>    End_Procedure
16022>>>>>>>    
16022>>>>>>>    Function Action_Text Returns String
16024>>>>>>>    End_Function
16025>>>>>>>    
16025>>>>>>>    Procedure Set Button_Text String sText
16027>>>>>>>        Send ProcessEvents
16028>>>>>>>    End_Procedure
16029>>>>>>>    
16029>>>>>>>    Function Button_Text Returns String
16031>>>>>>>    End_Function
16032>>>>>>>    
16032>>>>>>>    Procedure Set Title_Text String sText
16034>>>>>>>        Send ProcessEvents
16035>>>>>>>    End_Procedure
16036>>>>>>>    
16036>>>>>>>    Function Title_Text Returns String
16038>>>>>>>    End_Function
16039>>>>>>>    
16039>>>>>>>    // initializes values for caption, title & message
16039>>>>>>>    Procedure Initialize_StatusPanel String sCaption String sTitle String sMessage
16041>>>>>>>        Set Caption_text to sCaption
16042>>>>>>>        Set Title_Text   to sTitle
16043>>>>>>>        Set Message_Text to sMessage
16044>>>>>>>    End_Procedure
16045>>>>>>>    
16045>>>>>>>    // update the status panel's action area
16045>>>>>>>    Procedure Update_StatusPanel String sAction
16047>>>>>>>        Set Action_Text to sAction
16048>>>>>>>    End_Procedure
16049>>>>>>>    
16049>>>>>>>    // stop the status panel
16049>>>>>>>    Procedure Close_Panel
16051>>>>>>>        If (Allow_cancel_state(Self)) Begin
16053>>>>>>>            Forward Send Close_Panel
16055>>>>>>>        End
16055>>>>>>>>
16055>>>>>>>    End_Procedure
16056>>>>>>>    
16056>>>>>>>    // Code must be provided in the cancel button object to enable/disable cancel button
16056>>>>>>>    Procedure EnableCancelButton Boolean bEnable
16058>>>>>>>    End_Procedure
16059>>>>>>>    
16059>>>>>>>    // check for cancel (if cancel or pbCancel is set, close the panel)
16059>>>>>>>    Function Check_StatusPanel Returns Integer
16061>>>>>>>        Boolean bCancel
16061>>>>>>>        If (Active_state(Self)) Begin
16063>>>>>>>            Send ProcessEvents
16064>>>>>>>            Get pbCancel to bCancel
16065>>>>>>>            If bCancel Begin
16067>>>>>>>                Send Stop_StatusPanel // the old status panel removed this when canceled.
16068>>>>>>>            End
16068>>>>>>>>
16068>>>>>>>        End
16068>>>>>>>>
16068>>>>>>>        Function_Return (If(bCancel, MSG_CANCEL, 0)) // the old check status panel returns msg_cancel
16069>>>>>>>    End_Function
16070>>>>>>>    
16070>>>>>>>    // start the status panel
16070>>>>>>>    Procedure Start_StatusPanel
16072>>>>>>>        If not (Active_state(Self)) Begin
16074>>>>>>>            Send EnableCancelButton (Allow_cancel_state(Self))
16075>>>>>>>            Send Activate
16076>>>>>>>        End
16076>>>>>>>>
16076>>>>>>>    End_Procedure
16077>>>>>>>    
16077>>>>>>>    // stop the status panel
16077>>>>>>>    Procedure Stop_StatusPanel
16079>>>>>>>        If (Active_state(Self)) Begin
16081>>>>>>>            Send Deactivate
16082>>>>>>>        End
16082>>>>>>>>
16082>>>>>>>    End_Procedure
16083>>>>>>>    
16083>>>>>>>End_Class
16084>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
16084>>>>>>>Use windows.pkg
16084>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
16084>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
16084>>>>>>>>>Use FlexCom20.pkg
Including file: FlexCOM20.pkg    (C:\Program Files\DataFlex 24.0\Pkg\FlexCOM20.pkg)
16084>>>>>>>>>>>// Full Flexcom support for automation (cComAutomationObject),
16084>>>>>>>>>>>// activeX (cComActiveXControl and document objects (cComDocumentObject)
16084>>>>>>>>>>>Use FlexCOM20_Base.pkg // defines basic flexcom symbols and class cComAutomationObject
Including file: FlexCOM20_Base.pkg    (C:\Program Files\DataFlex 24.0\Pkg\FlexCOM20_Base.pkg)
16084>>>>>>>>>>>>>// Flexcom support for automation (cComAutomationObject).
16084>>>>>>>>>>>>>// If you want activeX and document objects use FlexCom20.pkg
16084>>>>>>>>>>>>>Use VdfBase.pkg
16084>>>>>>>>>>>>>Use ComTypes.pkg
Including file: ComTypes.pkg    (C:\Program Files\DataFlex 24.0\Pkg\ComTypes.pkg)
16084>>>>>>>>>>>>>>>Use Variant.pkg
16084>>>>>>>>>>>>>>>
16084>>>>>>>>>>>>>>>
16084>>>>>>>>>>>>>
16084>>>>>>>>>>>>>
16084>>>>>>>>>>>>>
16084>>>>>>>>>>>>>//Enumerations for the peAutoCreate property
16084>>>>>>>>>>>>>//acNoAutoCreate - Do not automatically instantiate the COM object upon VDF object creation.
16084>>>>>>>>>>>>>//You must manually instantiate the COM object using CreateComObject. This is the default
16084>>>>>>>>>>>>>//for cComAutomation.
16084>>>>>>>>>>>>>Define acNoAutoCreate for 0
16084>>>>>>>>>>>>>//acAutoCreate - Automatically instantiate the COM object upon VDF object creation.
16084>>>>>>>>>>>>>//You won't need to manually instantiate the COM object. This is the default
16084>>>>>>>>>>>>>//for cComActiveXControl
16084>>>>>>>>>>>>>Define acAutoCreate for 1
16084>>>>>>>>>>>>>//acDeferredAutoCreate - Automatically instantiate the COM object during Page_Object,
16084>>>>>>>>>>>>>//and automatically destroy the COM object during Page_Delete. Use this setting only
16084>>>>>>>>>>>>>//if acAutoCreate causes problems.
16084>>>>>>>>>>>>>Define acDeferredAutoCreate for 2
16084>>>>>>>>>>>>>
16084>>>>>>>>>>>>>Class cComAutomationObject is a DFComAutomationObject
16085>>>>>>>>>>>>>    Procedure Construct_Object
16087>>>>>>>>>>>>>        Forward Send Construct_Object
16089>>>>>>>>>>>>>        Send RegisterComEvents
16090>>>>>>>>>>>>>    End_Procedure
16091>>>>>>>>>>>>>    
16091>>>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
16091>>>>>>>>>>>>>    Procedure RegisterComEvents
16093>>>>>>>>>>>>>    End_Procedure
16094>>>>>>>>>>>>>    
16094>>>>>>>>>>>>>    // Attach the DF object to com automation object via progId.
16094>>>>>>>>>>>>>    // returns: Boolean bSuccess if Ok, If not ok, pcComObject is set to null
16094>>>>>>>>>>>>>    Function AttachActiveObject Returns Boolean
16096>>>>>>>>>>>>>        String sProgId
16096>>>>>>>>>>>>>        Variant vComObject
16096>>>>>>>>>>>>>        Boolean bSuccess
16096>>>>>>>>>>>>>        Get psProgID to sProgId
16097>>>>>>>>>>>>>        Get ComActiveObject sProgId to vComObject
16098>>>>>>>>>>>>>        Set pvComObject to vComObject
16099>>>>>>>>>>>>>        Move (not(IsNullComObject(vComObject))) to bSuccess // success of variant is not null
16100>>>>>>>>>>>>>        Function_Return bSuccess
16101>>>>>>>>>>>>>    End_Function
16102>>>>>>>>>>>>>    
16102>>>>>>>>>>>>>    // returns true if the control is created.
16102>>>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
16104>>>>>>>>>>>>>        Variant vComObject
16104>>>>>>>>>>>>>        Get pvComObject to vComObject
16105>>>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16106>>>>>>>>>>>>>    End_Function
16107>>>>>>>>>>>>>    
16107>>>>>>>>>>>>>End_Class
16108>>>>>>>>>>>>>
16108>>>>>>>>>>>>>
16108>>>>>>>>>>>
16108>>>>>>>>>>>Use Windows.pkg
16108>>>>>>>>>>>
16108>>>>>>>>>>>Class cComDocumentObject is a DFComDocumentObject
16109>>>>>>>>>>>
16109>>>>>>>>>>>
16109>>>>>>>>>>>    Procedure Construct_Object
16111>>>>>>>>>>>        Forward Send Construct_Object
16113>>>>>>>>>>>        Send RegisterComEvents
16114>>>>>>>>>>>        Send Define_Standard_Object_Mixin
16115>>>>>>>>>>>        Send Define_Shadow_Mixin
16116>>>>>>>>>>>    End_Procedure
16117>>>>>>>>>>>
16117>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
16118>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
16119>>>>>>>>>>>
16119>>>>>>>>>>>    
16119>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
16119>>>>>>>>>>>    Procedure RegisterComEvents
16121>>>>>>>>>>>    End_Procedure
16122>>>>>>>>>>>    
16122>>>>>>>>>>>    // returns true if the control is created.
16122>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
16124>>>>>>>>>>>        Variant vComObject
16124>>>>>>>>>>>        Get pvComObject to vComObject
16125>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16126>>>>>>>>>>>    End_Function
16127>>>>>>>>>>>
16127>>>>>>>>>>>
16127>>>>>>>>>>>End_Class
16128>>>>>>>>>>>
16128>>>>>>>>>>>Class cComActiveXControl is a DFComActiveXControl
16129>>>>>>>>>>>
16129>>>>>>>>>>>    Procedure Construct_Object
16131>>>>>>>>>>>        Forward Send Construct_Object
16133>>>>>>>>>>>        Send RegisterComEvents
16134>>>>>>>>>>>
16134>>>>>>>>>>>
16134>>>>>>>>>>>        Send Define_Standard_Object_Mixin
16135>>>>>>>>>>>        Send Define_Single_Item_Navigate_Mixin
16136>>>>>>>>>>>        Send Define_Dflabel_Mixin
16137>>>>>>>>>>>
16137>>>>>>>>>>>        // internal: set true object is notified that the OCX value has changed.
16137>>>>>>>>>>>        Property Boolean pbPrivateControlChanging False
16138>>>>>>>>>>>        // Class sets this true when making a local (externally triggered) change. This is
16138>>>>>>>>>>>        // set when a Set Value change is made to prevent recursion
16138>>>>>>>>>>>        Property Boolean pbPrivateControlRefresh False
16139>>>>>>>>>>>        
16139>>>>>>>>>>>        // added to eumlate a single item form support
16139>>>>>>>>>>>        Property Boolean pbPrivateItem_Changed_State False
16140>>>>>>>>>>>        
16140>>>>>>>>>>>        // This keeps track of value, even when control is not created
16140>>>>>>>>>>>        Property String psPrivateValue ''
16141>>>>>>>>>>>        
16141>>>>>>>>>>>        // If set true, then the control will attempt to bind the value property in the object to the
16141>>>>>>>>>>>        // comValue in the control. It will try to keep these values in synch at all times. This allows a
16141>>>>>>>>>>>        // control to be used as a Form style value control. the default is true. Even when true if the
16141>>>>>>>>>>>        // get/set ComValue methods are not set up to do anything, this will do nothing.
16141>>>>>>>>>>>        Property Boolean pbBindValue True
16142>>>>>>>>>>>        
16142>>>>>>>>>>>    End_Procedure
16143>>>>>>>>>>>    
16143>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
16143>>>>>>>>>>>    Procedure RegisterComEvents
16145>>>>>>>>>>>    End_Procedure
16146>>>>>>>>>>>
16146>>>>>>>>>>>    
16146>>>>>>>>>>>    // returns true if the control is created.
16146>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
16148>>>>>>>>>>>        Variant vComObject
16148>>>>>>>>>>>        Get pvComObject to vComObject
16149>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
16150>>>>>>>>>>>    End_Function
16151>>>>>>>>>>>    
16151>>>>>>>>>>>
16151>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
16152>>>>>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
16153>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
16154>>>>>>>>>>>
16154>>>>>>>>>>>    // added to eumlate a single item form support
16154>>>>>>>>>>>    Function Item_Count Returns Integer
16156>>>>>>>>>>>        Function_Return 1
16157>>>>>>>>>>>    End_Function
16158>>>>>>>>>>>    
16158>>>>>>>>>>>    // added to eumlate a single item form support
16158>>>>>>>>>>>    Procedure Set Item_Changed_State Integer iItem Integer iState
16160>>>>>>>>>>>        Set pbPrivateItem_changed_state to iState
16161>>>>>>>>>>>        If (iState and changed_state(Self)=False) ;            Set changed_state to True
16164>>>>>>>>>>>    End_Procedure
16165>>>>>>>>>>>    
16165>>>>>>>>>>>    Function Item_Changed_State Integer iItem Returns Integer
16167>>>>>>>>>>>        Function_Return (pbPrivateItem_changed_state(Self))
16168>>>>>>>>>>>    End_Function
16169>>>>>>>>>>>    
16169>>>>>>>>>>>    
16169>>>>>>>>>>>    // augment to set the label's appearance
16169>>>>>>>>>>>    Procedure Shadow_Display
16171>>>>>>>>>>>        Forward Send Shadow_display
16173>>>>>>>>>>>        Send Label_Shadow_Display
16174>>>>>>>>>>>    End_Procedure
16175>>>>>>>>>>>    
16175>>>>>>>>>>>    // Created to simulate get/Set value.
16175>>>>>>>>>>>    Procedure Set Value Integer iItem String sVal
16177>>>>>>>>>>>        If not (pbPrivateControlChanging(Self)) ;            Send OnRefreshControl sVal
16180>>>>>>>>>>>        Set psPrivateValue to sVal
16181>>>>>>>>>>>        Send OnChange
16182>>>>>>>>>>>        //Set changed_state to True
16182>>>>>>>>>>>        Set item_changed_state 0 to True
16183>>>>>>>>>>>    End_Procedure
16184>>>>>>>>>>>    
16184>>>>>>>>>>>    Function Value Integer iItem Returns String
16186>>>>>>>>>>>        Function_Return (psPrivateValue(Self))
16187>>>>>>>>>>>        //function_return (Controlvalue(self))
16187>>>>>>>>>>>    End_Function
16188>>>>>>>>>>>    
16188>>>>>>>>>>>    Procedure OnChange
16190>>>>>>>>>>>    End_Procedure
16191>>>>>>>>>>>    
16191>>>>>>>>>>>    
16191>>>>>>>>>>>    // It is expected that the sub-class will provide functionality
16191>>>>>>>>>>>    // for these messages. This gets and sets the value of the actual
16191>>>>>>>>>>>    // window control. These should only be used to synchronize the window
16191>>>>>>>>>>>    // control and the DF side. Do not use for any other purpose.
16191>>>>>>>>>>>    Procedure Set ControlValue String sVal
16193>>>>>>>>>>>    End_Procedure
16194>>>>>>>>>>>    
16194>>>>>>>>>>>    Function ControlValue Returns String
16196>>>>>>>>>>>    End_Function
16197>>>>>>>>>>>    
16197>>>>>>>>>>>    Procedure OnCreate
16199>>>>>>>>>>>        // if we are binding value to comValue, do so upon creation
16199>>>>>>>>>>>        If (pbBindValue(Self)) ;            Set ControlValue to (Value(Self))
16202>>>>>>>>>>>        Forward Send OnCreate
16204>>>>>>>>>>>    End_Procedure
16205>>>>>>>>>>>    
16205>>>>>>>>>>>    // Notification that the control is about to be activated in place. The COM component is
16205>>>>>>>>>>>    // created but OnCreate is not yet fired (this happens after the InPlaceActivate).
16205>>>>>>>>>>>    Procedure OnBeforeInPlaceActivate
16207>>>>>>>>>>>        Forward Send OnBeforeInPlaceActivate
16209>>>>>>>>>>>    End_Procedure
16210>>>>>>>>>>>    
16210>>>>>>>>>>>    // Notification that the control's value has been changed
16210>>>>>>>>>>>    // externally by the program (via set value). Use to synchronize
16210>>>>>>>>>>>    // OCX control value.
16210>>>>>>>>>>>    Procedure OnRefreshControl String sVal
16212>>>>>>>>>>>        Boolean bOld
16212>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlChanging(Self)=0 and IsComObjectCreated(Self)) Begin
16214>>>>>>>>>>>            Get pbPrivateControlRefresh to bOld
16215>>>>>>>>>>>            Set pbPrivateControlRefresh to True
16216>>>>>>>>>>>            Set ControlValue to sval
16217>>>>>>>>>>>            Set pbPrivateControlRefresh to bOld
16218>>>>>>>>>>>        End
16218>>>>>>>>>>>>
16218>>>>>>>>>>>    End_Procedure
16219>>>>>>>>>>>    
16219>>>>>>>>>>>    // notification that the control has changed its value. Used to
16219>>>>>>>>>>>    // synchronize the object with the change.
16219>>>>>>>>>>>    Procedure OnControlValueChanged
16221>>>>>>>>>>>        String sVal
16221>>>>>>>>>>>        Boolean bOld
16221>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlRefresh(Self)=0) Begin
16223>>>>>>>>>>>            Get pbPrivateControlChanging to bOld
16224>>>>>>>>>>>            Set pbPrivateControlChanging to True
16225>>>>>>>>>>>            Get ControlValue to sVal
16226>>>>>>>>>>>            Set Value to sVal
16227>>>>>>>>>>>            Set Item_Changed_State 0 to True
16228>>>>>>>>>>>            Set pbPrivateControlChanging to bOld
16229>>>>>>>>>>>        End
16229>>>>>>>>>>>>
16229>>>>>>>>>>>    End_Procedure
16230>>>>>>>>>>>    
16230>>>>>>>>>>>    Procedure Delete_Data
16232>>>>>>>>>>>        Forward Send Delete_Data
16234>>>>>>>>>>>        Set Value to ''
16235>>>>>>>>>>>        Set Changed_state to False
16236>>>>>>>>>>>        Set Item_changed_state 0 to False
16237>>>>>>>>>>>    End_Procedure
16238>>>>>>>>>>>
16238>>>>>>>>>>>
16238>>>>>>>>>>>End_Class
16239>>>>>>>>>>>
16239>>>>>>>>>>>
16239>>>>>>>>>
16239>>>>>>>>>// Changes to Imported package
16239>>>>>>>>>//     OLEXTPxx to XTPxx
16239>>>>>>>>>//     OLExtpxx to xtpxx
16239>>>>>>>>>//     OLESkinFramework to SkinFramework
16239>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
16239>>>>>>>>>//     cCom classes to cCJ
16239>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
16239>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
16239>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
16239>>>>>>>>>//     Use statements as noted below (classes moved to these files)
16239>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
16239>>>>>>>>>
16239>>>>>>>>>// These have been extracted from this class and moved into seperate packages
16239>>>>>>>>>// because other Codejock classes use these.
16239>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
Including file: cCJColorManager.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJColorManager.pkg)
16239>>>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.CommandBars.Unicode.x64.v20.0.0.ocx
16239>>>>>>>>>>>Use FlexCom20.pkg
16239>>>>>>>>>>>
16239>>>>>>>>>>>Define XTPColorManagerColor for Integer
16239>>>>>>>>>>>    Define STDCOLOR_BACKGROUND for 1
16239>>>>>>>>>>>    Define STDCOLOR_ACTIVECAPTION for 2
16239>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTION for 3
16239>>>>>>>>>>>    Define STDCOLOR_MENU for 4
16239>>>>>>>>>>>    Define STDCOLOR_WINDOW for 5
16239>>>>>>>>>>>    Define STDCOLOR_WINDOWFRAME for 6
16239>>>>>>>>>>>    Define STDCOLOR_MENUTEXT for 7
16239>>>>>>>>>>>    Define STDCOLOR_WINDOWTEXT for 8
16239>>>>>>>>>>>    Define STDCOLOR_CAPTIONTEXT for 9
16239>>>>>>>>>>>    Define STDCOLOR_ACTIVEBORDER for 10
16239>>>>>>>>>>>    Define STDCOLOR_INACTIVEBORDER for 11
16239>>>>>>>>>>>    Define STDCOLOR_APPWORKSPACE for 12
16239>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHT for 13
16239>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHTTEXT for 14
16239>>>>>>>>>>>    Define STDCOLOR_BTNFACE for 15
16239>>>>>>>>>>>    Define STDCOLOR_BTNSHADOW for 16
16239>>>>>>>>>>>    Define STDCOLOR_GRAYTEXT for 17
16239>>>>>>>>>>>    Define STDCOLOR_BTNTEXT for 18
16239>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTIONTEXT for 19
16239>>>>>>>>>>>    Define STDCOLOR_BTNHIGHLIGHT for 20
16239>>>>>>>>>>>    Define STDCOLOR_3DDKSHADOW for 21
16239>>>>>>>>>>>    Define STDCOLOR_3DLIGHT for 22
16239>>>>>>>>>>>    Define STDCOLOR_INFOTEXT for 23
16239>>>>>>>>>>>    Define STDCOLOR_INFOBK for 24
16239>>>>>>>>>>>    Define STDCOLOR_HOTLIGHT for 26
16239>>>>>>>>>>>    Define STDCOLOR_GRADIENTACTIVECAPTION for 27
16239>>>>>>>>>>>    Define STDCOLOR_GRADIENTINACTIVECAPTION for 28
16239>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_FACE for 30
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT for 31
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_BORDER for 32
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED for 33
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED for 36
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED_BORDER for 37
16239>>>>>>>>>>>    Define XPCOLOR_ICONSHADDOW for 34
16239>>>>>>>>>>>    Define XPCOLOR_GRAYTEXT for 35
16239>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_GRIPPER for 38
16239>>>>>>>>>>>    Define XPCOLOR_SEPARATOR for 39
16239>>>>>>>>>>>    Define XPCOLOR_DISABLED for 40
16239>>>>>>>>>>>    Define XPCOLOR_MENUBAR_FACE for 41
16239>>>>>>>>>>>    Define XPCOLOR_MENUBAR_EXPANDED for 42
16239>>>>>>>>>>>    Define XPCOLOR_MENUBAR_BORDER for 43
16239>>>>>>>>>>>    Define XPCOLOR_MENUBAR_TEXT for 44
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_TEXT for 45
16239>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_TEXT for 46
16239>>>>>>>>>>>    Define XPCOLOR_PUSHED_TEXT for 47
16239>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_BACK for 48
16239>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_TEXT for 49
16239>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED_BORDER for 50
16239>>>>>>>>>>>    Define XPCOLOR_3DFACE for 51
16239>>>>>>>>>>>    Define XPCOLOR_3DSHADOW for 52
16239>>>>>>>>>>>    Define XPCOLOR_FRAME for 54
16239>>>>>>>>>>>    Define XPCOLOR_SPLITTER_FACE for 55
16239>>>>>>>>>>>    Define XPCOLOR_LABEL for 56
16239>>>>>>>>>>>    Define XPCOLOR_STATICFRAME for 57
16239>>>>>>>>>>>
16239>>>>>>>>>>>Define XTPCurrentSystemTheme for Integer
16239>>>>>>>>>>>    // No known theme in use
16239>>>>>>>>>>>    Define xtpSystemThemeUnknown for 0
16239>>>>>>>>>>>    // Blue theme in use
16239>>>>>>>>>>>    Define xtpSystemThemeBlue for 1
16239>>>>>>>>>>>    // Olive theme in use
16239>>>>>>>>>>>    Define xtpSystemThemeOlive for 2
16239>>>>>>>>>>>    // Silver theme in use
16239>>>>>>>>>>>    Define xtpSystemThemeSilver for 3
16239>>>>>>>>>>>    // Silver theme in use
16239>>>>>>>>>>>    Define xtpSystemThemeRoyale for 4
16239>>>>>>>>>>>    // Silver theme in use
16239>>>>>>>>>>>    Define xtpSystemThemeAero for 5
16239>>>>>>>>>>>    // Use OS theme.
16239>>>>>>>>>>>    Define xtpSystemThemeAuto for 6
16239>>>>>>>>>>>
16239>>>>>>>>>>>
16239>>>>>>>>>>>// CLSID: {C0DE2200-DE43-4B56-BCEB-E14B825CF245}
16239>>>>>>>>>>>Class cCJIColorManager is a Mixin
16240>>>>>>>>>>>
16240>>>>>>>>>>>    Function ComSystemTheme Returns XTPCurrentSystemTheme
16242>>>>>>>>>>>        XTPCurrentSystemTheme retVal
16242>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to retVal
16243>>>>>>>>>>>        Function_Return retVal
16244>>>>>>>>>>>    End_Function
16245>>>>>>>>>>>
16245>>>>>>>>>>>    Procedure Set ComSystemTheme XTPCurrentSystemTheme value
16247>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to value
16248>>>>>>>>>>>    End_Procedure
16249>>>>>>>>>>>
16249>>>>>>>>>>>    Function ComEnableLunaBlueForRoyaleTheme Returns Boolean
16251>>>>>>>>>>>        Boolean retVal
16251>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to retVal
16252>>>>>>>>>>>        Function_Return retVal
16253>>>>>>>>>>>    End_Function
16254>>>>>>>>>>>
16254>>>>>>>>>>>    Procedure Set ComEnableLunaBlueForRoyaleTheme Boolean value
16256>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to value
16257>>>>>>>>>>>    End_Procedure
16258>>>>>>>>>>>
16258>>>>>>>>>>>    Function ComColor XTPColorManagerColor llIndex Returns OLE_COLOR
16260>>>>>>>>>>>        Handle hDispatchDriver
16260>>>>>>>>>>>        OLE_COLOR retVal
16260>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16261>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16262>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16263>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_I4 to retVal
16264>>>>>>>>>>>        Function_Return retVal
16265>>>>>>>>>>>    End_Function
16266>>>>>>>>>>>
16266>>>>>>>>>>>    Procedure ComSetColor XTPColorManagerColor llIndex OLE_COLOR llColor
16268>>>>>>>>>>>        Handle hDispatchDriver
16268>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16269>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16270>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16271>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llColor
16272>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
16273>>>>>>>>>>>    End_Procedure
16274>>>>>>>>>>>
16274>>>>>>>>>>>    Function ComGetCurrentSystemTheme Returns XTPCurrentSystemTheme
16276>>>>>>>>>>>        Handle hDispatchDriver
16276>>>>>>>>>>>        XTPCurrentSystemTheme retVal
16276>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16277>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
16278>>>>>>>>>>>        Function_Return retVal
16279>>>>>>>>>>>    End_Function
16280>>>>>>>>>>>End_Class
16281>>>>>>>>>>>
16281>>>>>>>>>>>// CoClass
16281>>>>>>>>>>>// CLSID: {C0DE2200-F3FE-46E7-BB64-DB033F439F8B}
16281>>>>>>>>>>>Class cCJColorManager is a cComAutomationObject
16282>>>>>>>>>>>    Import_Class_Protocol cCJIColorManager
16283>>>>>>>>>>>
16283>>>>>>>>>>>    Procedure Construct_Object
16285>>>>>>>>>>>        Forward Send Construct_Object
16287>>>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
16288>>>>>>>>>>>    End_Procedure
16289>>>>>>>>>>>End_Class
16290>>>>>>>>>>>
16290>>>>>>>>>
16290>>>>>>>>>
16290>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
16290>>>>>>>>>    Define xtpSkinApplyMetrics for 1
16290>>>>>>>>>    Define xtpSkinApplyFrame for 2
16290>>>>>>>>>    Define xtpSkinApplyColors for 4
16290>>>>>>>>>    Define xtpSkinApplyMenus for 8
16290>>>>>>>>>
16290>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
16290>>>>>>>>>// Dispatch interface for SkinFramework Control
16290>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
16291>>>>>>>>>
16291>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
16293>>>>>>>>>        SkinFrameworkApplyOptions retVal
16293>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
16294>>>>>>>>>        Function_Return retVal
16295>>>>>>>>>    End_Function
16296>>>>>>>>>
16296>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
16298>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
16299>>>>>>>>>    End_Procedure
16300>>>>>>>>>
16300>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
16302>>>>>>>>>        Boolean retVal
16302>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
16303>>>>>>>>>        Function_Return retVal
16304>>>>>>>>>    End_Function
16305>>>>>>>>>
16305>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
16307>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
16308>>>>>>>>>    End_Procedure
16309>>>>>>>>>
16309>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
16311>>>>>>>>>        Boolean retVal
16311>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
16312>>>>>>>>>        Function_Return retVal
16313>>>>>>>>>    End_Function
16314>>>>>>>>>
16314>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
16316>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
16317>>>>>>>>>    End_Procedure
16318>>>>>>>>>
16318>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
16320>>>>>>>>>        Handle hDispatchDriver
16320>>>>>>>>>        Boolean retVal
16320>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16321>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16322>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
16323>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
16324>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
16325>>>>>>>>>        Function_Return retVal
16326>>>>>>>>>    End_Function
16327>>>>>>>>>
16327>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
16329>>>>>>>>>        Handle hDispatchDriver
16329>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16330>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16331>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16332>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
16333>>>>>>>>>    End_Procedure
16334>>>>>>>>>
16334>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
16336>>>>>>>>>        Handle hDispatchDriver
16336>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16337>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16338>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16339>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
16340>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
16341>>>>>>>>>    End_Procedure
16342>>>>>>>>>
16342>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
16344>>>>>>>>>        Handle hDispatchDriver
16344>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16345>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16346>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16347>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
16348>>>>>>>>>    End_Procedure
16349>>>>>>>>>
16349>>>>>>>>>    Procedure ComRemoveAllWindows
16351>>>>>>>>>        Handle hDispatchDriver
16351>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16352>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
16353>>>>>>>>>    End_Procedure
16354>>>>>>>>>
16354>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
16356>>>>>>>>>        Handle hDispatchDriver
16356>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16357>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16358>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
16359>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
16360>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
16361>>>>>>>>>    End_Procedure
16362>>>>>>>>>
16362>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
16364>>>>>>>>>        Handle hDispatchDriver
16364>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16365>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16366>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
16367>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
16368>>>>>>>>>    End_Procedure
16369>>>>>>>>>
16369>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
16371>>>>>>>>>        Handle hDispatchDriver
16371>>>>>>>>>        Variant retVal
16371>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16372>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16373>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
16374>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
16375>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
16376>>>>>>>>>        Function_Return retVal
16377>>>>>>>>>    End_Function
16378>>>>>>>>>
16378>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
16380>>>>>>>>>        Handle hDispatchDriver
16380>>>>>>>>>        Variant retVal
16380>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16381>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16382>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
16383>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
16384>>>>>>>>>        Function_Return retVal
16385>>>>>>>>>    End_Function
16386>>>>>>>>>
16386>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
16388>>>>>>>>>        Handle hDispatchDriver
16388>>>>>>>>>        OLE_COLOR retVal
16388>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16389>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16390>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16391>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
16392>>>>>>>>>        Function_Return retVal
16393>>>>>>>>>    End_Function
16394>>>>>>>>>
16394>>>>>>>>>    Procedure ComExcludeModule String llModuleName
16396>>>>>>>>>        Handle hDispatchDriver
16396>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16397>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16398>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
16399>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
16400>>>>>>>>>    End_Procedure
16401>>>>>>>>>
16401>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
16403>>>>>>>>>        Handle hDispatchDriver
16403>>>>>>>>>        Variant retVal
16403>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16404>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16405>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
16406>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
16407>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
16408>>>>>>>>>        Function_Return retVal
16409>>>>>>>>>    End_Function
16410>>>>>>>>>
16410>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
16412>>>>>>>>>        Handle hDispatchDriver
16412>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16413>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
16414>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
16415>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
16416>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
16417>>>>>>>>>    End_Procedure
16418>>>>>>>>>
16418>>>>>>>>>    Procedure ComAboutBox
16420>>>>>>>>>        Handle hDispatchDriver
16420>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16421>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
16422>>>>>>>>>    End_Procedure
16423>>>>>>>>>End_Class
16424>>>>>>>>>
16424>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
16424>>>>>>>>>// Event interface for SkinFramework Control
16424>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
16425>>>>>>>>>
16425>>>>>>>>>    Procedure RegisterComEvents
16427>>>>>>>>>    End_Procedure
16428>>>>>>>>>End_Class
16429>>>>>>>>>
16429>>>>>>>>>// CoClass
16429>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
16429>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
16429>>>>>>>>>// SkinFramework Control
16429>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
16430>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
16431>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
16432>>>>>>>>>
16432>>>>>>>>>    Procedure Construct_Object
16434>>>>>>>>>        Forward Send Construct_Object
16436>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
16437>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
16438>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
16439>>>>>>>>>        Set peAutoCreate to acAutoCreate
16440>>>>>>>>>    End_Procedure
16441>>>>>>>>>End_Class
16442>>>>>>>>>
16442>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
16442>>>>>>>>>// SkinFramework Global Settings
16442>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
16443>>>>>>>>>
16443>>>>>>>>>    Function ComLicense Returns String
16445>>>>>>>>>        String retVal
16445>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
16446>>>>>>>>>        Function_Return retVal
16447>>>>>>>>>    End_Function
16448>>>>>>>>>
16448>>>>>>>>>    Procedure Set ComLicense String value
16450>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
16451>>>>>>>>>    End_Procedure
16452>>>>>>>>>
16452>>>>>>>>>    Function ComTitle Returns String
16454>>>>>>>>>        String retVal
16454>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
16455>>>>>>>>>        Function_Return retVal
16456>>>>>>>>>    End_Function
16457>>>>>>>>>
16457>>>>>>>>>    Procedure Set ComTitle String value
16459>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
16460>>>>>>>>>    End_Procedure
16461>>>>>>>>>
16461>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
16461>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
16463>>>>>>>>>        Boolean retVal
16463>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
16464>>>>>>>>>        Function_Return retVal
16465>>>>>>>>>    End_Function
16466>>>>>>>>>
16466>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
16466>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
16468>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
16469>>>>>>>>>    End_Procedure
16470>>>>>>>>>
16470>>>>>>>>>    Function ComVersion Returns String
16472>>>>>>>>>        Handle hDispatchDriver
16472>>>>>>>>>        String retVal
16472>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16473>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
16474>>>>>>>>>        Function_Return retVal
16475>>>>>>>>>    End_Function
16476>>>>>>>>>
16476>>>>>>>>>    Function ComUnicode Returns Boolean
16478>>>>>>>>>        Handle hDispatchDriver
16478>>>>>>>>>        Boolean retVal
16478>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16479>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
16480>>>>>>>>>        Function_Return retVal
16481>>>>>>>>>    End_Function
16482>>>>>>>>>
16482>>>>>>>>>    Function ComOcxPath Returns String
16484>>>>>>>>>        Handle hDispatchDriver
16484>>>>>>>>>        String retVal
16484>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16485>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
16486>>>>>>>>>        Function_Return retVal
16487>>>>>>>>>    End_Function
16488>>>>>>>>>End_Class
16489>>>>>>>>>
16489>>>>>>>>>// CoClass
16489>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
16489>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
16489>>>>>>>>>// SkinFramework Global Settings
16489>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
16490>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
16491>>>>>>>>>
16491>>>>>>>>>    Procedure Construct_Object
16493>>>>>>>>>        Forward Send Construct_Object
16495>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
16496>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
16497>>>>>>>>>    End_Procedure
16498>>>>>>>>>End_Class
16499>>>>>>>>>
16499>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
16499>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
16500>>>>>>>>>
16500>>>>>>>>>    Function ComColorScheme Returns String
16502>>>>>>>>>        String retVal
16502>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
16503>>>>>>>>>        Function_Return retVal
16504>>>>>>>>>    End_Function
16505>>>>>>>>>
16505>>>>>>>>>    Procedure Set ComColorScheme String value
16507>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
16508>>>>>>>>>    End_Procedure
16509>>>>>>>>>
16509>>>>>>>>>    Function ComFontSize Returns String
16511>>>>>>>>>        String retVal
16511>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
16512>>>>>>>>>        Function_Return retVal
16513>>>>>>>>>    End_Function
16514>>>>>>>>>
16514>>>>>>>>>    Procedure Set ComFontSize String value
16516>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
16517>>>>>>>>>    End_Procedure
16518>>>>>>>>>
16518>>>>>>>>>    Function ComIniFileName Returns String
16520>>>>>>>>>        String retVal
16520>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
16521>>>>>>>>>        Function_Return retVal
16522>>>>>>>>>    End_Function
16523>>>>>>>>>
16523>>>>>>>>>    Procedure Set ComIniFileName String value
16525>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
16526>>>>>>>>>    End_Procedure
16527>>>>>>>>>End_Class
16528>>>>>>>>>
16528>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
16528>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
16529>>>>>>>>>
16529>>>>>>>>>    Function ComName Returns String
16531>>>>>>>>>        String retVal
16531>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
16532>>>>>>>>>        Function_Return retVal
16533>>>>>>>>>    End_Function
16534>>>>>>>>>
16534>>>>>>>>>    Procedure Set ComName String value
16536>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
16537>>>>>>>>>    End_Procedure
16538>>>>>>>>>
16538>>>>>>>>>    Function ComPath Returns String
16540>>>>>>>>>        String retVal
16540>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
16541>>>>>>>>>        Function_Return retVal
16542>>>>>>>>>    End_Function
16543>>>>>>>>>
16543>>>>>>>>>    Procedure Set ComPath String value
16545>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
16546>>>>>>>>>    End_Procedure
16547>>>>>>>>>
16547>>>>>>>>>    Function ComCount Returns Integer
16549>>>>>>>>>        Handle hDispatchDriver
16549>>>>>>>>>        Integer retVal
16549>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16550>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
16551>>>>>>>>>        Function_Return retVal
16552>>>>>>>>>    End_Function
16553>>>>>>>>>
16553>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
16555>>>>>>>>>        Handle hDispatchDriver
16555>>>>>>>>>        Variant retVal
16555>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16556>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16557>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16558>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
16559>>>>>>>>>        Function_Return retVal
16560>>>>>>>>>    End_Function
16561>>>>>>>>>
16561>>>>>>>>>    Function Com_NewEnum Returns Variant
16563>>>>>>>>>        Handle hDispatchDriver
16563>>>>>>>>>        Variant retVal
16563>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16564>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
16565>>>>>>>>>        Function_Return retVal
16566>>>>>>>>>    End_Function
16567>>>>>>>>>End_Class
16568>>>>>>>>>
16568>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
16568>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
16569>>>>>>>>>
16569>>>>>>>>>    Function ComCount Returns Integer
16571>>>>>>>>>        Handle hDispatchDriver
16571>>>>>>>>>        Integer retVal
16571>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16572>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
16573>>>>>>>>>        Function_Return retVal
16574>>>>>>>>>    End_Function
16575>>>>>>>>>
16575>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
16577>>>>>>>>>        Handle hDispatchDriver
16577>>>>>>>>>        Variant retVal
16577>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16578>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16579>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16580>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
16581>>>>>>>>>        Function_Return retVal
16582>>>>>>>>>    End_Function
16583>>>>>>>>>
16583>>>>>>>>>    Function Com_NewEnum Returns Variant
16585>>>>>>>>>        Handle hDispatchDriver
16585>>>>>>>>>        Variant retVal
16585>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16586>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
16587>>>>>>>>>        Function_Return retVal
16588>>>>>>>>>    End_Function
16589>>>>>>>>>End_Class
16590>>>>>>>>>
16590>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
16590>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
16591>>>>>>>>>
16591>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
16593>>>>>>>>>        Handle hDispatchDriver
16593>>>>>>>>>        OLE_COLOR retVal
16593>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
16594>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
16595>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
16596>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
16597>>>>>>>>>        Function_Return retVal
16598>>>>>>>>>    End_Function
16599>>>>>>>>>End_Class
16600>>>>>>>Use cApplication.pkg
16600>>>>>>>
16600>>>>>>>Struct tSkinInformation
16600>>>>>>>    String sName     // description of the skin
16600>>>>>>>    String sSkinfile // file path. Can be relative or full
16600>>>>>>>    String sSkinIni  // section name
16600>>>>>>>End_Struct
16600>>>>>>>
16600>>>>>>>
16600>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
16601>>>>>>>    
16601>>>>>>>    Procedure Construct_Object
16603>>>>>>>        Forward Send Construct_Object
16605>>>>>>>        
16605>>>>>>>        Property String psSkinFile ""
16606>>>>>>>        Property String psSkinIni ""
16607>>>>>>>        Property Boolean pbLoadPreference False
16608>>>>>>>        
16608>>>>>>>        Set peAutoCreate to acAutoCreate
16609>>>>>>>        
16609>>>>>>>        Move Self to ghoSkinFramework
16610>>>>>>>    End_Procedure
16611>>>>>>>    
16611>>>>>>>    // return the default skin path, which is the programs directory.
16611>>>>>>>    // This requires an application object.
16611>>>>>>>    // If you want to different skin path, override this.
16611>>>>>>>    Function SkinPath Returns String
16613>>>>>>>        String sPath sPaths
16613>>>>>>>        Handle hoWorkspace
16613>>>>>>>        If ghoApplication Begin
16615>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
16616>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
16617>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
16618>>>>>>>        End
16618>>>>>>>>
16618>>>>>>>        Else Begin
16619>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16620>>>>>>>>
16620>>>>>>>        End
16620>>>>>>>>
16620>>>>>>>        Function_Return sPath
16621>>>>>>>    End_Function
16622>>>>>>>    
16622>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
16622>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
16622>>>>>>>    Function SkinQFile Returns String
16624>>>>>>>        String sFile sPath sSep
16624>>>>>>>        Boolean bQualified
16624>>>>>>>        Get psSkinFile to sFile
16625>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
16627>>>>>>>            Get SkinPath to sPath
16628>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
16629>>>>>>>            Move (sPath - sSep - sFile) to sFile
16630>>>>>>>        End
16630>>>>>>>>
16630>>>>>>>        Function_Return sFile
16631>>>>>>>    End_Function
16632>>>>>>>    
16632>>>>>>>    // defines the default VDF window class mapping.
16632>>>>>>>    Procedure OnAddVDFWindowClasses
16634>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
16635>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
16636>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
16637>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
16638>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
16639>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
16640>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
16641>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
16642>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
16643>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
16644>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
16645>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
16646>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
16647>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
16648>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
16649>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
16650>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
16651>>>>>>>        // External class
16651>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
16652>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
16653>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
16654>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
16655>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
16656>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
16657>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
16658>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
16659>>>>>>>    End_Procedure
16660>>>>>>>    
16660>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
16660>>>>>>>    Procedure OnAddCustomWindowClasses
16662>>>>>>>    End_Procedure
16663>>>>>>>    
16663>>>>>>>    // called when object is created during end_construct_object.
16663>>>>>>>    Procedure OnCreate
16665>>>>>>>        Integer iOpts
16665>>>>>>>        Boolean bUseWindowsFont
16665>>>>>>>        Forward Send OnCreate
16667>>>>>>>        
16667>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
16667>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
16667>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
16668>>>>>>>        If bUseWindowsFont Begin
16670>>>>>>>            Get ComApplyOptions to iOpts
16671>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
16672>>>>>>>        End
16672>>>>>>>>
16672>>>>>>>        
16672>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
16672>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
16672>>>>>>>        // and this was the suggested workaround.
16672>>>>>>>        Set ComAutoApplyNewThreads to False
16673>>>>>>>        
16673>>>>>>>        Send OnAddVDFWindowClasses
16674>>>>>>>        Send OnAddCustomWindowClasses
16675>>>>>>>        
16675>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
16675>>>>>>>        If (pbLoadPreference(Self)) Begin
16677>>>>>>>            Send LoadSkinPreference
16678>>>>>>>        End
16678>>>>>>>>
16678>>>>>>>        // if a skin file name exists, we apply the skin.
16678>>>>>>>        If (psSkinFile(Self)<>"") Begin
16680>>>>>>>            Send ApplySkin
16681>>>>>>>        End
16681>>>>>>>>
16681>>>>>>>    End_Procedure
16682>>>>>>>    
16682>>>>>>>    // called by framework as part of application exit.
16682>>>>>>>    Procedure Broadcast_Notify_Exit_Application
16684>>>>>>>        Send Notify_Exit_Application
16685>>>>>>>    End_Procedure
16686>>>>>>>    
16686>>>>>>>    Procedure Notify_Exit_Application
16688>>>>>>>        If (pbLoadPreference(Self)) Begin
16690>>>>>>>            Send SaveSkinPreference
16691>>>>>>>        End
16691>>>>>>>>
16691>>>>>>>    End_Procedure
16692>>>>>>>    
16692>>>>>>>    Procedure NotifyPreApplySkin
16694>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
16696>>>>>>>    End_Procedure
16697>>>>>>>    
16697>>>>>>>    Procedure NotifyPostApplySkin
16699>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
16701>>>>>>>    End_Procedure
16702>>>>>>>    
16702>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
16702>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
16702>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
16704>>>>>>>        tSkinInformation[] Skins
16704>>>>>>>        tSkinInformation[] Skins
16705>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
16705>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
16705>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
16705>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
16705>>>>>>>        Integer iPos iDfltLen
16705>>>>>>>        Boolean bUseRelativePath
16705>>>>>>>        
16705>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
16706>>>>>>>        
16706>>>>>>>        Get SkinPath to sDefaultPath
16707>>>>>>>        If (sPath="") Begin
16709>>>>>>>            Move sDefaultPath to sPath
16710>>>>>>>        End
16710>>>>>>>>
16710>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
16711>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
16712>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
16713>>>>>>>        
16713>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
16714>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
16716>>>>>>>            
16716>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
16717>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
16718>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
16719>>>>>>>            
16719>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
16720>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
16721>>>>>>>            
16721>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
16727>>>>>>>>
16727>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
16728>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
16729>>>>>>>                
16729>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
16730>>>>>>>                
16730>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
16736>>>>>>>>
16736>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
16737>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
16738>>>>>>>                    
16738>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
16739>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
16740>>>>>>>                    If bUseRelativePath Begin
16742>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
16743>>>>>>>                        If iPos Begin
16745>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
16746>>>>>>>                            While (Left(sSkinFile,1)=sSep)
16750>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
16751>>>>>>>                            Loop
16752>>>>>>>>
16752>>>>>>>                        End
16752>>>>>>>>
16752>>>>>>>                    End
16752>>>>>>>>
16752>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
16753>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
16754>>>>>>>                    
16754>>>>>>>                    Increment iArrayItem
16755>>>>>>>                Loop
16756>>>>>>>>
16756>>>>>>>            Loop
16757>>>>>>>>
16757>>>>>>>            
16757>>>>>>>            Send Destroy of hSkinDescriptions
16758>>>>>>>            Send Destroy of hSkinDescription
16759>>>>>>>            Send Destroy of hSkinIniFile
16760>>>>>>>            
16760>>>>>>>        End
16760>>>>>>>>
16760>>>>>>>        Function_Return Skins
16761>>>>>>>    End_Function
16762>>>>>>>    
16762>>>>>>>    // Save the skin preference. This requires an application object.
16762>>>>>>>    // Only do this if the application object allows it.
16762>>>>>>>    // This is called during startup if pbLoadPreference is True
16762>>>>>>>    // Suitable for override
16762>>>>>>>    Procedure SaveSkinPreference
16764>>>>>>>        String sSkin sIni
16764>>>>>>>        If ghoApplication Begin
16766>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
16768>>>>>>>                Get psSkinFile to sSkin
16769>>>>>>>                Get psSkinIni to sIni
16770>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
16771>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
16772>>>>>>>            End
16772>>>>>>>>
16772>>>>>>>        End
16772>>>>>>>>
16772>>>>>>>        Else Begin
16773>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16774>>>>>>>>
16774>>>>>>>        End
16774>>>>>>>>
16774>>>>>>>    End_Procedure
16775>>>>>>>    
16775>>>>>>>    // Load the skin preference. This requires an application object.
16775>>>>>>>    // Only do this if the application object allows it.
16775>>>>>>>    // This is called during startup if pbLoadPreference is True
16775>>>>>>>    // Suitable for override
16775>>>>>>>    Procedure LoadSkinPreference
16777>>>>>>>        String sSkin sIni
16777>>>>>>>        Boolean bExists
16777>>>>>>>        If ghoApplication Begin
16779>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
16781>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
16782>>>>>>>                If bExists Begin
16784>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
16785>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
16786>>>>>>>                    Set psSkinFile to sSkin
16787>>>>>>>                    Set psSkinIni to sIni
16788>>>>>>>                End
16788>>>>>>>>
16788>>>>>>>            End
16788>>>>>>>>
16788>>>>>>>        End
16788>>>>>>>>
16788>>>>>>>        Else Begin
16789>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
16790>>>>>>>>
16790>>>>>>>        End
16790>>>>>>>>
16790>>>>>>>    End_Procedure
16791>>>>>>>    
16791>>>>>>>    // Can be called to apply the current skin.
16791>>>>>>>    Procedure ApplySkin
16793>>>>>>>        Boolean bOk
16793>>>>>>>        String sSkin sIni
16793>>>>>>>        If (IsComObjectCreated(Self)) Begin
16795>>>>>>>            Get SkinQFile to sSkin
16796>>>>>>>            Get psSkinIni to sIni
16797>>>>>>>            
16797>>>>>>>            Send NotifyPreApplySkin
16798>>>>>>>            // when skins are used we don't want to use built in Visual Styles
16798>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
16799>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
16800>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
16802>>>>>>>                // if not ok, no skin was appied. Enable visual styles
16802>>>>>>>                Send EnableVisualStyles of Desktop True
16803>>>>>>>            End
16803>>>>>>>>
16803>>>>>>>            Send NotifyPostApplySkin
16804>>>>>>>        End
16804>>>>>>>>
16804>>>>>>>    End_Procedure
16805>>>>>>>    
16805>>>>>>>    
16805>>>>>>>End_Class
16806>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
16806>>>>>>>Use Windows.pkg
16806>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
16806>>>>>>>>>Use Windows.pkg
16806>>>>>>>>>
16806>>>>>>>>>// Key State Masks for Mouse Messages
16806>>>>>>>>>
16806>>>>>>>>>Define MK_LBUTTON  for |CI$0001
16806>>>>>>>>>Define MK_RBUTTON  for |CI$0002
16806>>>>>>>>>Define MK_SHIFT    for |CI$0004
16806>>>>>>>>>Define MK_CONTROL  for |CI$0008
16806>>>>>>>>>Define MK_MBUTTON  for |CI$0010
16806>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
16806>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
16806>>>>>>>>>
16806>>>>>>>>>Enum_List // Mouse Key Flags
16806>>>>>>>>>    Define mkLeft    for MK_LBUTTON
16806>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
16806>>>>>>>>>    Define mkRight   for MK_RBUTTON
16806>>>>>>>>>    Define mkX1      for MK_XBUTTON1
16806>>>>>>>>>    Define mkX2      for MK_XBUTTON2
16806>>>>>>>>>    Define mkShift   for MK_SHIFT
16806>>>>>>>>>    Define mkControl for MK_CONTROL
16806>>>>>>>>>End_Enum_List
16806>>>>>>>>>
16806>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
16806>>>>>>>>>    Define mbLeft
16806>>>>>>>>>    Define mbMiddle
16806>>>>>>>>>    Define mbRight
16806>>>>>>>>>    Define mbX1
16806>>>>>>>>>    Define mbX2
16806>>>>>>>>>End_Enum_List
16806>>>>>>>>>
16806>>>>>>>>>Class cWinControl is a DfBaseControl
16807>>>>>>>>>    Procedure Construct_Object
16809>>>>>>>>>        Forward Send Construct_Object
16811>>>>>>>>>        Property Integer private_pbEnabled True
16812>>>>>>>>>        Property Integer private_pbVisible True
16813>>>>>>>>>    End_Procedure
16814>>>>>>>>>    
16814>>>>>>>>>    Procedure End_Construct_Object
16816>>>>>>>>>        Forward Send End_Construct_Object
16818>>>>>>>>>        
16818>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
16819>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
16820>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
16821>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
16822>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
16823>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
16824>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
16825>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
16826>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
16827>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
16828>>>>>>>>>    End_Procedure
16829>>>>>>>>>    
16829>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
16831>>>>>>>>>        //Intentionally cancelled
16831>>>>>>>>>    End_Procedure
16832>>>>>>>>>    
16832>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
16834>>>>>>>>>        //Intentionally cancelled
16834>>>>>>>>>    End_Procedure
16835>>>>>>>>>    
16835>>>>>>>>>    Procedure DoRecreateWindow
16837>>>>>>>>>        // Recreates the window
16837>>>>>>>>>        If (Window_Handle(Self)) Begin
16839>>>>>>>>>            // attempt to do this without disturbing the focus tree.
16839>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
16840>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
16841>>>>>>>>>        End
16841>>>>>>>>>>
16841>>>>>>>>>    End_Procedure
16842>>>>>>>>>    
16842>>>>>>>>>    Procedure DoUpdateWindow
16844>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
16844>>>>>>>>>        Handle hWnd
16844>>>>>>>>>        
16844>>>>>>>>>        Get Window_Handle to hWnd
16845>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
16848>>>>>>>>>    End_Procedure
16849>>>>>>>>>    
16849>>>>>>>>>    Procedure Page Integer iState
16851>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
16852>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
16853>>>>>>>>>        Forward Send Page iState
16855>>>>>>>>>    End_Procedure
16856>>>>>>>>>    
16856>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
16858>>>>>>>>>        Integer x y eButton
16858>>>>>>>>>        
16858>>>>>>>>>        Move (Hi(lParam))  to y
16859>>>>>>>>>        Move (Low(lParam)) to x
16860>>>>>>>>>        
16860>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
16861>>>>>>>>>    End_Procedure
16862>>>>>>>>>    
16862>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
16864>>>>>>>>>        Integer x y eButton
16864>>>>>>>>>        
16864>>>>>>>>>        Move (Hi(lParam))  to y
16865>>>>>>>>>        Move (Low(lParam)) to x
16866>>>>>>>>>        
16866>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
16867>>>>>>>>>    End_Procedure
16868>>>>>>>>>    
16868>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
16870>>>>>>>>>        Integer x y eButton
16870>>>>>>>>>        
16870>>>>>>>>>        Move (Hi(lParam))  to y
16871>>>>>>>>>        Move (Low(lParam)) to x
16872>>>>>>>>>        
16872>>>>>>>>>        Send OnMouseUp mbRight x y wParam
16873>>>>>>>>>    End_Procedure
16874>>>>>>>>>    
16874>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
16876>>>>>>>>>        Integer x y eButton fKeys
16876>>>>>>>>>        
16876>>>>>>>>>        Move (Hi(lParam))  to y
16877>>>>>>>>>        Move (Low(lParam)) to x
16878>>>>>>>>>        
16878>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
16879>>>>>>>>>    End_Procedure
16880>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
16882>>>>>>>>>        Integer x y eButton
16882>>>>>>>>>        
16882>>>>>>>>>        Move (Hi(lParam))  to y
16883>>>>>>>>>        Move (Low(lParam)) to x
16884>>>>>>>>>        
16884>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
16885>>>>>>>>>    End_Procedure
16886>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
16888>>>>>>>>>        Integer x y eButton
16888>>>>>>>>>        
16888>>>>>>>>>        Move (Hi(lParam))  to y
16889>>>>>>>>>        Move (Low(lParam)) to x
16890>>>>>>>>>        
16890>>>>>>>>>        Send OnMouseDown mbRight x y wParam
16891>>>>>>>>>    End_Procedure
16892>>>>>>>>>    
16892>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
16894>>>>>>>>>        Integer x y eButton
16894>>>>>>>>>        
16894>>>>>>>>>        Move (Hi(lParam))  to y
16895>>>>>>>>>        Move (Low(lParam)) to x
16896>>>>>>>>>        
16896>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
16897>>>>>>>>>    End_Procedure
16898>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
16900>>>>>>>>>        Integer x y eButton
16900>>>>>>>>>        
16900>>>>>>>>>        Move (Hi(lParam))  to y
16901>>>>>>>>>        Move (Low(lParam)) to x
16902>>>>>>>>>        
16902>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
16903>>>>>>>>>    End_Procedure
16904>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
16906>>>>>>>>>        Integer x y eButton
16906>>>>>>>>>        
16906>>>>>>>>>        Move (Hi(lParam))  to y
16907>>>>>>>>>        Move (Low(lParam)) to x
16908>>>>>>>>>        
16908>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
16909>>>>>>>>>    End_Procedure
16910>>>>>>>>>    
16910>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
16912>>>>>>>>>        Integer x y eButton
16912>>>>>>>>>        
16912>>>>>>>>>        Move (Hi(lParam))  to y
16913>>>>>>>>>        Move (Low(lParam)) to x
16914>>>>>>>>>        
16914>>>>>>>>>        Send OnMouseMove x y wParam
16915>>>>>>>>>    End_Procedure
16916>>>>>>>>>    
16916>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
16918>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16918>>>>>>>>>        //String sButton
16918>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16918>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16918>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16918>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16918>>>>>>>>>        
16918>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16918>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16918>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16918>>>>>>>>>    End_Procedure
16919>>>>>>>>>    
16919>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
16921>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16921>>>>>>>>>        //String sButton
16921>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16921>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16921>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16921>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16921>>>>>>>>>        
16921>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16921>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16921>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16921>>>>>>>>>    End_Procedure
16922>>>>>>>>>    
16922>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
16924>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16924>>>>>>>>>        //String sButton
16924>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16924>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16924>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16924>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16924>>>>>>>>>        
16924>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
16924>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
16924>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16924>>>>>>>>>    End_Procedure
16925>>>>>>>>>    
16925>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
16927>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
16927>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
16927>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
16927>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
16927>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
16927>>>>>>>>>        
16927>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
16927>>>>>>>>>    End_Procedure
16928>>>>>>>>>    
16928>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
16930>>>>>>>>>        Handle hWnd
16930>>>>>>>>>        
16930>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
16932>>>>>>>>>            Set private_pbEnabled to bEnabled
16933>>>>>>>>>            Get Window_Handle to hWnd
16934>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
16937>>>>>>>>>        End
16937>>>>>>>>>>
16937>>>>>>>>>    End_Procedure
16938>>>>>>>>>    Function pbEnabled Returns Boolean
16940>>>>>>>>>        Function_Return (private_pbEnabled(Self))
16941>>>>>>>>>    End_Function
16942>>>>>>>>>    
16942>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
16944>>>>>>>>>        Handle  hWnd
16944>>>>>>>>>        Integer iVoid
16944>>>>>>>>>        
16944>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
16946>>>>>>>>>            Set private_pbVisible to bVisible
16947>>>>>>>>>            Get Window_Handle to hWnd
16948>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
16951>>>>>>>>>        End
16951>>>>>>>>>>
16951>>>>>>>>>    End_Procedure
16952>>>>>>>>>    Function pbVisible Returns Boolean
16954>>>>>>>>>        Function_Return (private_pbVisible(Self))
16955>>>>>>>>>    End_Function
16956>>>>>>>>>    
16956>>>>>>>>>End_Class
16957>>>>>>>Use CommCtrl.pkg
16957>>>>>>>
16957>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
16957>>>>>>>Class cProgressBar is a cWinControl
16958>>>>>>>    
16958>>>>>>>    Procedure Construct_Object
16960>>>>>>>        Forward Send Construct_Object
16962>>>>>>>        Property Integer private_piMinimum
16963>>>>>>>        Property Integer private_piMaximum   100
16964>>>>>>>        Property Integer private_piAdvanceBy 10
16965>>>>>>>        Property Integer private_piPosition
16966>>>>>>>        Property Integer private_pbVertical  False
16967>>>>>>>        Property Integer private_pbSmooth    False
16968>>>>>>>        Property Integer private_piBackColor clDefault
16969>>>>>>>        Property Integer private_piBarColor  clDefault
16970>>>>>>>        
16970>>>>>>>        Send Define_ToolTip_Support_Mixin
16971>>>>>>>        
16971>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
16972>>>>>>>        Set Focus_Mode to NonFocusable
16973>>>>>>>        Set Skip_State to True
16974>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
16975>>>>>>>    End_Procedure
16976>>>>>>>    
16976>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
16977>>>>>>>    
16977>>>>>>>    Procedure Set piMinimum Integer iMin
16979>>>>>>>        Integer iMax
16979>>>>>>>        
16979>>>>>>>        Set private_piMinimum to iMin
16980>>>>>>>        Get private_piMaximum to iMax
16981>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
16982>>>>>>>    End_Procedure
16983>>>>>>>    Function piMinimum Returns Integer
16985>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
16988>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
16990>>>>>>>    End_Function
16991>>>>>>>    
16991>>>>>>>    Procedure Set piMaximum Integer iMax
16993>>>>>>>        Integer iMin
16993>>>>>>>        
16993>>>>>>>        Set private_piMaximum to iMax
16994>>>>>>>        Get private_piMinimum to iMin
16995>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
16996>>>>>>>    End_Procedure
16997>>>>>>>    Function piMaximum Returns Integer
16999>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
17002>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
17004>>>>>>>    End_Function
17005>>>>>>>    
17005>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
17007>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
17008>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
17009>>>>>>>    End_Procedure
17010>>>>>>>    Function piAdvanceBy Returns Integer
17012>>>>>>>        Function_Return (private_piAdvanceBy(Self))
17013>>>>>>>    End_Function
17014>>>>>>>    
17014>>>>>>>    Procedure Set piPosition Integer iPos
17016>>>>>>>        Set private_piPosition to iPos
17017>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
17018>>>>>>>    End_Procedure
17019>>>>>>>    
17019>>>>>>>    Function piPosition Returns Integer
17021>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
17024>>>>>>>        Else;            Function_Return (private_piPosition(Self))
17026>>>>>>>    End_Function
17027>>>>>>>    
17027>>>>>>>    Procedure Set pbVertical Boolean bVertical
17029>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
17031>>>>>>>            Set private_pbVertical to bVertical
17032>>>>>>>            Send DoRecreateWindow
17033>>>>>>>        End
17033>>>>>>>>
17033>>>>>>>    End_Procedure
17034>>>>>>>    
17034>>>>>>>    Function pbVertical Returns Boolean
17036>>>>>>>        Function_Return (private_pbVertical(Self))
17037>>>>>>>    End_Function
17038>>>>>>>    
17038>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
17040>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
17042>>>>>>>            Set private_pbSmooth to bSmooth
17043>>>>>>>            Send DoRecreateWindow
17044>>>>>>>        End
17044>>>>>>>>
17044>>>>>>>    End_Procedure
17045>>>>>>>    Function pbSmooth Returns Boolean
17047>>>>>>>        Function_Return (private_pbSmooth(Self))
17048>>>>>>>    End_Function
17049>>>>>>>    
17049>>>>>>>    Procedure Set piBackColor Integer rgbColor
17051>>>>>>>        Set private_piBackColor to rgbColor
17052>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
17053>>>>>>>    End_Procedure
17054>>>>>>>    Function piBackColor Returns Integer
17056>>>>>>>        Function_Return (private_piBackColor(Self))
17057>>>>>>>    End_Function
17058>>>>>>>    
17058>>>>>>>    Procedure Set piBarColor Integer rgbColor
17060>>>>>>>        Set private_piBarColor to rgbColor
17061>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
17062>>>>>>>    End_Procedure
17063>>>>>>>    Function piBarColor Returns Integer
17065>>>>>>>        Function_Return (private_piBarColor(Self))
17066>>>>>>>    End_Function
17067>>>>>>>    
17067>>>>>>>    Procedure DoAdvance
17069>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
17070>>>>>>>    End_Procedure
17071>>>>>>>    
17071>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
17073>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
17074>>>>>>>    End_Procedure
17075>>>>>>>    
17075>>>>>>>    Procedure private_DoInitWindow
17077>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
17078>>>>>>>        Set piBackColor to (private_piBackColor(Self))
17079>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
17080>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
17081>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
17082>>>>>>>        Set piPosition  to (private_piPosition(Self))
17083>>>>>>>    End_Procedure
17084>>>>>>>    
17084>>>>>>>    Procedure Page_Object Integer iState
17086>>>>>>>        Handle hWnd
17086>>>>>>>        
17086>>>>>>>        Get Window_Handle to hWnd
17087>>>>>>>        If (hWnd=0 and iState) Begin
17089>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
17090>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
17091>>>>>>>            Forward Send Page_Object True
17093>>>>>>>        End
17093>>>>>>>>
17093>>>>>>>        Else ;            Forward Send Page_Object iState
17096>>>>>>>        
17096>>>>>>>        // Handle tooltip support....
17096>>>>>>>        If (iState = 0) Begin
17098>>>>>>>            Send RequestDeleteToolTip
17099>>>>>>>        End
17099>>>>>>>>
17099>>>>>>>        Else Begin
17100>>>>>>>            Send RequestAddToolTip
17101>>>>>>>        End
17101>>>>>>>>
17101>>>>>>>    End_Procedure
17102>>>>>>>    
17102>>>>>>>    Procedure Page Integer iState
17104>>>>>>>        Forward Send Page iState
17106>>>>>>>        If (iState =1);            Send private_DoInitWindow
17109>>>>>>>    End_Procedure
17110>>>>>>>    
17110>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
17110>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
17110>>>>>>>    // is implemented in a mixin class.
17110>>>>>>>    Procedure RequestAddToolTip
17112>>>>>>>        Send AddToolTip
17113>>>>>>>    End_Procedure
17114>>>>>>>    
17114>>>>>>>    
17114>>>>>>>    // Called by Page_Object. Handles tooltip removal.
17114>>>>>>>    Procedure RequestDeleteToolTip
17116>>>>>>>        Send DeleteToolTip
17117>>>>>>>    End_Procedure
17118>>>>>>>End_Class
17119>>>>>Use Windows.pkg
17119>>>>>Use DUFLanguageConstants.inc
17119>>>>>Use Statpnl.pkg
Including file: Statpnl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Statpnl.pkg)
17119>>>>>>>// creates the standard status_panel object.
17119>>>>>>>//
17119>>>>>>>// This is the default Status Panel object used by any of the DataFlex classes that
17119>>>>>>>// invoke the standard status panel. The standard has always been that the package name
17119>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
17119>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
17119>>>>>>>// prior revisions has been replace with status panel that is part of the application.
17119>>>>>>>// This should work much better and faster than the old sentinel based solution.
17119>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
17119>>>>>>>// with most applications.
17119>>>>>>>//
17119>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
17119>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
17119>>>>>>>// a cleaner more robust interface.
17119>>>>>>>//
17119>>>>>>>//
17119>>>>>>>// Compatibility Note:
17119>>>>>>>//
17119>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
17119>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
17119>>>>>>>//
17119>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
17119>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
17119>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
17119>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
17119>>>>>>>//
17119>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
17119>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
17119>>>>>>>//
17119>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
17119>>>>>>>// can still access the new object via the ghoStatusPanel handle.
17119>>>>>>>//
17119>>>>>>>//
17119>>>>>>>// Creating your own Status Panel objects
17119>>>>>>>//
17119>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
17119>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
17119>>>>>>>// with a different file and object name and direct your status panel request to the new object.
17119>>>>>>>//
17119>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
17119>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
17119>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
17119>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
17119>>>>>>>// e.g.
17119>>>>>>>//       Procedure UpdateStatusBar
17119>>>>>>>//           Send DoAdvance of oProgressBar
17119>>>>>>>//           Send ProcessEvents
17119>>>>>>>//       End_Procedure
17119>>>>>>>//
17119>>>>>>>// Of course, if you use the standard interfaces in status bar and your forward send these
17119>>>>>>>// messages this will be done for you.
17119>>>>>>>//
17119>>>>>>>// the standard Interface for status panels are:
17119>>>>>>>//
17119>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
17119>>>>>>>// Send Start_StatusPanel      - start the status panel
17119>>>>>>>// Send Stop_StatusPanel       - stop the status panel
17119>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
17119>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
17119>>>>>>>//
17119>>>>>>>// Get/Set Caption_Text - updates the caption bar
17119>>>>>>>// Get/Set Title_Text   - updates the title area
17119>>>>>>>// Get/Set Message_Text - updates the Message area
17119>>>>>>>// Get/Set Action_Text  - updates the action area
17119>>>>>>>// Get/Set Button_Text  - updates the button area
17119>>>>>>>//
17119>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
17119>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
17119>>>>>>>//
17119>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
17119>>>>>>>
17119>>>>>>>Use cProcessStatusPanel.pkg
17119>>>>>>>
17119>>>>>>>
17119>>>>>>>Global_Variable Handle ghoStatusPanel // will contain the ID of the global StatusPanel object
17119>>>>>>>
17119>>>>>>>
17119>>>>>>>Object Status_Panel is a cProcessStatusPanel
17121>>>>>>>    
17121>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout your applicaton to access this object
17122>>>>>>>    
17122>>>>>>>    Set Size to 80 166
17123>>>>>>>    
17123>>>>>>>    Object oTitleTxt is a TextBox
17125>>>>>>>        Set location to 10 10
17126>>>>>>>        Set Auto_Size_State to False
17127>>>>>>>        Set size to 20 150
17128>>>>>>>        Set Justification_Mode to JMode_Center
17129>>>>>>>    End_Object
17130>>>>>>>    
17130>>>>>>>    Object oMessageTxt is a TextBox
17132>>>>>>>        Set location to 25 10
17133>>>>>>>        Set Auto_Size_State to False
17134>>>>>>>        Set size to 20 150
17135>>>>>>>    End_Object
17136>>>>>>>    
17136>>>>>>>    Object oActionTxt is a TextBox
17138>>>>>>>        Set location to 45 10
17139>>>>>>>    End_Object
17140>>>>>>>    
17140>>>>>>>    Object oStopButton is a Button
17142>>>>>>>        Set Location to 60 58
17143>>>>>>>        Set Label to C_$Cancel
17144>>>>>>>        
17144>>>>>>>        Procedure OnClick
17147>>>>>>>            Send Close_panel
17148>>>>>>>        End_Procedure
17149>>>>>>>        
17149>>>>>>>    End_Object
17150>>>>>>>    
17150>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
17150>>>>>>>    // objects defined within this instance of the status panel.
17150>>>>>>>    
17150>>>>>>>    // note: all of the messages that change text should be forwarded
17150>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
17150>>>>>>>    
17150>>>>>>>    Procedure Set Message_Text String sText
17153>>>>>>>        Set Label of oMessageTxt to sText
17154>>>>>>>        Forward Set Message_Text to sText
17156>>>>>>>    End_Procedure
17157>>>>>>>    
17157>>>>>>>    Function Message_Text Returns String
17160>>>>>>>        Function_Return (Label(oMessageTxt))
17161>>>>>>>    End_Function
17162>>>>>>>    
17162>>>>>>>    Procedure Set Action_Text String sText
17165>>>>>>>        Set Label of oActionTxt to sText
17166>>>>>>>        Forward Set Action_Text to sText
17168>>>>>>>    End_Procedure
17169>>>>>>>    
17169>>>>>>>    Function Action_Text Returns String
17172>>>>>>>        Function_Return (Label(oActionTxt))
17173>>>>>>>    End_Function
17174>>>>>>>    
17174>>>>>>>    Procedure Set Button_Text String sText
17177>>>>>>>        Set Label of oStopButton to sText
17178>>>>>>>        Forward Set Button_Text to sText
17180>>>>>>>    End_Procedure
17181>>>>>>>    
17181>>>>>>>    Function Button_Text Returns String
17184>>>>>>>        Function_Return (Label(oStopButton))
17185>>>>>>>    End_Function
17186>>>>>>>    
17186>>>>>>>    Procedure Set Title_Text String sText
17189>>>>>>>        Set Label of oTitleTxt to sText
17190>>>>>>>        Forward Set Title_Text to sText
17192>>>>>>>    End_Procedure
17193>>>>>>>    
17193>>>>>>>    Function Title_Text Returns String
17196>>>>>>>        Function_Return (Label(oTitleTxt))
17197>>>>>>>    End_Function
17198>>>>>>>    
17198>>>>>>>    // gets called when status panel is activated passing whether a button
17198>>>>>>>    // should appear
17198>>>>>>>    Procedure EnableCancelButton Boolean bEnable
17201>>>>>>>        Set Enabled_State of oStopButton to bEnable
17202>>>>>>>    End_Procedure
17203>>>>>>>    
17203>>>>>>>End_Object
17204>>>>>>>
17204>>>>>
17204>>>>>
17204>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
17204>>>>>
17204>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
17204>>>>>
17204>>>>>Object Status_Panel is a cProcessStatusPanel
17206>>>>>    Set Size to 152 222
17207>>>>>    Set Border_Style to Border_Dialog
17208>>>>>    Set Icon to "Default.ico"
17209>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
17210>>>>>
17210>>>>>    Property Boolean Cancel_Button_Visible_State True
17212>>>>>
17212>>>>>    Procedure Activate
17215>>>>>        Integer iSizeBefore
17215>>>>>        Get GuiSize to iSizeBefore
17216>>>>>        Forward Send Activate
17218>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
17219>>>>>    End_Procedure
17220>>>>>
17220>>>>>    Procedure End_Construct_Object
17223>>>>>        Forward Send End_Construct_Object
17225>>>>>        Set Label of oTitleTxt      to ""
17226>>>>>        Set Label of oTableNameTxt  to ""
17227>>>>>        Set Label of oMessageTxt    to ""
17228>>>>>        Set Label of oActionTxt     to ""
17229>>>>>    End_Procedure
17230>>>>>
17230>>>>>    Object oTitleTxt is a TextBox
17232>>>>>        Set Location to 5 21
17233>>>>>        Set Size to 8 179
17234>>>>>        Set Auto_Size_State to False
17235>>>>>        Set Justification_Mode  to jMode_Center
17236>>>>>        Set Label to "This is the Title Text"
17237>>>>>    End_Object
17238>>>>>
17238>>>>>    Object oTableNameTxt is a TextBox
17240>>>>>        Set Size to 19 204
17241>>>>>        Set Location to 18 9
17242>>>>>        Set Auto_Size_State to False
17243>>>>>        Set Justification_Mode to JMode_Left
17244>>>>>        Set Label to "This is the TableName Text"
17245>>>>>    End_Object
17246>>>>>
17246>>>>>    Object oMessageTxt is a TextBox
17248>>>>>        Set Location to 39 9
17249>>>>>        Set Size to 19 204
17250>>>>>        Set Auto_Size_State to False
17251>>>>>        Set Justification_Mode to JMode_Left
17252>>>>>        Set Label to "This is the Message text"
17253>>>>>    End_Object
17254>>>>>
17254>>>>>    Object oActionTxt is a TextBox
17256>>>>>        Set Size to 16 204
17257>>>>>        Set Location to 60 9
17258>>>>>        Set Auto_Size_State to False
17259>>>>>        Set Justification_Mode to JMode_Left
17260>>>>>        Set Label to "This is the Action Text"
17261>>>>>    End_Object
17262>>>>>
17262>>>>>    Object oStopButton is a Button
17264>>>>>        Set Location to 123 82
17265>>>>>        Set Label to C_$Cancel
17266>>>>>
17266>>>>>        Procedure OnClick 
17269>>>>>            Integer iRetval
17269>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
17270>>>>>            If (iRetval = MBR_Yes) Begin
17272>>>>>                Send Exit_Application
17273>>>>>            End
17273>>>>>>
17273>>>>>        End_Procedure
17274>>>>>
17274>>>>>    End_Object
17275>>>>>
17275>>>>>    Object oPercentage_tb is a TextBox
17277>>>>>        Set Location to 74 196
17278>>>>>        Set Size to 10 25
17279>>>>>//        Set Label to "% Done"
17279>>>>>    End_Object
17280>>>>>
17280>>>>>    Object oCopyRight is a TextBox
17282>>>>>        Set Location to 140 21
17283>>>>>        Set Size to 9 197
17284>>>>>        Set FontPointHeight to 8
17285>>>>>        Set Auto_Size_State to False
17286>>>>>        Set Justification_Mode  to jMode_Center
17287>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
17288>>>>>    End_Object
17289>>>>>
17289>>>>>    Object oProgressBar is a cProgressBar
17291>>>>>        Set Size to 10 179
17292>>>>>        Set Location to 83 22
17293>>>>>        Set pbVisible to True // default
17294>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
17295>>>>>    End_Object
17296>>>>>
17296>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
17299>>>>>        Set pbVisible of ghoProgressBar to bVisible
17300>>>>>    End_Procedure
17301>>>>>
17301>>>>>    Function Progress_Bar_Visible_State Returns Boolean
17304>>>>>        Boolean bVisible
17304>>>>>        Get pbVisible of ghoProgressBar to bVisible
17305>>>>>        Function_Return (bVisible)
17306>>>>>    End_Function
17307>>>>>
17307>>>>>    Object oProgressBarOverall is a cProgressBar
17309>>>>>        Set Size to 10 179
17310>>>>>        Set Location to 107 22
17311>>>>>        Set pbVisible to True // default
17312>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
17313>>>>>    End_Object
17314>>>>>
17314>>>>>    Object oOverallProgress_tb is a TextBox
17316>>>>>        Set Size to 10 65
17317>>>>>        Set Location to 95 24
17318>>>>>        Set Label to "Overall Progress"
17319>>>>>    End_Object
17320>>>>>
17320>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
17323>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
17324>>>>>    End_Procedure
17325>>>>>
17325>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
17328>>>>>        Boolean bVisible
17328>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
17329>>>>>        Function_Return (bVisible)
17330>>>>>    End_Function
17331>>>>>
17331>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
17331>>>>>    // objects defined within this instance of the status panel.
17331>>>>>
17331>>>>>    // note: all of the messages that change text should be forwarded
17331>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
17331>>>>>
17331>>>>>    Procedure Set Message_Text String sText
17334>>>>>        Set Label of oMessageTxt to sText
17335>>>>>        Forward Set Message_Text to sText
17337>>>>>    End_Procedure
17338>>>>>
17338>>>>>    Function Message_Text Returns String
17341>>>>>        Function_Return (Label(oMessageTxt))
17342>>>>>    End_Function
17343>>>>>
17343>>>>>    Procedure Set Action_Text String sText
17346>>>>>        Set Label of oActionTxt to sText
17347>>>>>        Forward Set Action_Text to sText
17349>>>>>    End_Procedure
17350>>>>>
17350>>>>>    Function Action_Text Returns String
17353>>>>>        Function_Return (Label(oActionTxt))
17354>>>>>    End_Function
17355>>>>>
17355>>>>>    Procedure Set Button_Text String sText
17358>>>>>        Set Label of oStopButton to sText
17359>>>>>        Forward Set Button_Text to sText
17361>>>>>    End_Procedure
17362>>>>>
17362>>>>>    Function Button_Text Returns String
17365>>>>>        Function_Return (Label(oStopButton))
17366>>>>>    End_Function
17367>>>>>
17367>>>>>    Procedure Set Title_Text String sText
17370>>>>>        Set Label of oTitleTxt to sText
17371>>>>>        Forward Set Title_Text to sText
17373>>>>>    End_Procedure
17374>>>>>
17374>>>>>    Function Title_Text Returns String
17377>>>>>        Function_Return (Label(oTitleTxt))
17378>>>>>    End_Function
17379>>>>>
17379>>>>>    Procedure Set TableName_Text String sText
17382>>>>>        Set Label of oTableNameTxt to sText
17383>>>>>    End_Procedure
17384>>>>>
17384>>>>>    Function TableName_Text Returns String
17387>>>>>        Function_Return (Label(oTableNameTxt))
17388>>>>>    End_Function
17389>>>>>
17389>>>>>    Procedure Set License_Text String sText
17392>>>>>//        Set Label of oLicense_txt to sText
17392>>>>>    End_Procedure
17393>>>>>
17393>>>>>    // gets called when status panel is activated passing whether a button
17393>>>>>    // should appear
17393>>>>>    Procedure EnableCancelButton Boolean bEnable
17396>>>>>        Boolean bVisible
17396>>>>>        Get Cancel_Button_Visible_State to bVisible
17397>>>>>        If (bEnable = False) Begin
17399>>>>>            Set Visible_State of oStopButton to bVisible
17400>>>>>        End
17400>>>>>>
17400>>>>>        Set Enabled_State of oStopButton to bEnable
17401>>>>>    End_Procedure
17402>>>>>
17402>>>>>    Procedure Reset_StatusPanel
17405>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
17406>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
17407>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
17408>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
17409>>>>>    End_Procedure
17410>>>>>
17410>>>>>//    Object oProgressBar is a cProgressBar
17410>>>>>//        Move Self to ghoProgressBar
17410>>>>>//        Set Location to 1 25
17410>>>>>//        Set Size to 9 173
17410>>>>>//        Set piMinimum        to 0
17410>>>>>//        Set piMaximum        to 2000
17410>>>>>//        Set piAdvanceBy      to 100
17410>>>>>//        Set pbSmooth to True
17410>>>>>//
17410>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
17410>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
17410>>>>>//        // color will show correctly.
17410>>>>>//        Procedure Page Integer iPageObject
17410>>>>>//            Handle hWin
17410>>>>>//            Forward Send Page iPageObject
17410>>>>>//            If (ghoSkinFramework <> 0) Begin
17410>>>>>//                Get Window_Handle to hWin
17410>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
17410>>>>>//            End
17410>>>>>//        End_Procedure
17410>>>>>//    End_Object
17410>>>>>
17410>>>>>End_Object
17411>>>>>
17411>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
17411>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
17411>>>>>//
17411>>>>>Use VdfBase.pkg
17411>>>>>Use cApplication.pkg
17411>>>>>Use seq_chnl.pkg
17411>>>>>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.pkg)
17411>>>>>>>// This code is part of VDF GUIdance
17411>>>>>>>// Visit us @ http://www.vdf-guidance.com
17411>>>>>>>// e-Mail us @ info@vdf-guidance.com
17411>>>>>>>// VDF GUIdance is a mutual project of
17411>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
17411>>>>>>>// Wil van Antwerpen  - Antwise Solutions
17411>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
17411>>>>>>>//
17411>>>>>>>//
17411>>>>>>>// *** Windows 32bit file handling wrapper class ***
17411>>>>>>>//
17411>>>>>>>
17411>>>>>>>
17411>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
Including file: File_dlg.pkg    (C:\Program Files\DataFlex 24.0\Pkg\File_dlg.pkg)
17411>>>>>>>>>Use Windows.pkg
17411>>>>>>>>>Use GlobalFunctionsProcedures.pkg
17411>>>>>>>>>
17411>>>>>>>>>
17411>>>>>>>>>// Unicode support, wide version of GetOpenFileName - Gets called directly from Show_Dialog.
17411>>>>>>>>>External_Function GetOpenFileNameW "GetOpenFileNameW" Comdlg32.DLL Pointer OpenStruct Returns Integer
17412>>>>>>>>>
17412>>>>>>>>>// Unicode support, wide version of GetSaveFileName
17412>>>>>>>>>External_Function GetSaveFileNameW "GetSaveFileNameW" Comdlg32.DLL Pointer OpenStruct Returns Integer
17413>>>>>>>>>
17413>>>>>>>>>Struct TOpenFileName
17413>>>>>>>>>    DWord    lStructSize          // length, in bytes, of the structure.
17413>>>>>>>>>    Integer  iMissingAlignment1
17413>>>>>>>>>    Handle   hwndOwner            // Handle to the window that owns the dialog box.
17413>>>>>>>>>    Handle   hInstance            // handle to a memory object containing a dialog box template.
17413>>>>>>>>>    Pointer  lpstrFilter          // pointer to a buffer containing pairs of null-terminated filter strings.
17413>>>>>>>>>    Pointer  lpstrCustomFilter    // Pointer to a static buffer that contains a pair of null-terminated filter strings for preserving the filter pattern chosen by the user.
17413>>>>>>>>>    DWord    nMaxCustFilter       // size, in chars, of the buffer identified by lpstrCustomFilter.
17413>>>>>>>>>    DWord    nFilterIndex         // index of the currently selected filter
17413>>>>>>>>>    Pointer  lpstrFile            // Pointer to a buffer that contains the file name(s)
17413>>>>>>>>>    DWord    nMaxFile             // Size, in CHARs, of the buffer pointed to by lpstrFile.
17413>>>>>>>>>    Integer  iMissingAlignment2
17413>>>>>>>>>    Pointer  lpstrFileTitle       // Pointer to a buffer that receives the file name and extension
17413>>>>>>>>>    DWord    nMaxFileTitle        // size, in CHARs, of the buffer pointed to by lpstrFileTitle
17413>>>>>>>>>    Integer  iMissingAlignment3
17413>>>>>>>>>    Pointer  lpstrInitialDir      // Pointer to a NULL terminated string that can specify the initial directory.
17413>>>>>>>>>    Pointer  lpstrTitle           // Pointer to a string to be placed in the title bar of the dialog box.
17413>>>>>>>>>    DWord    ofnFlags             // set of bit flags you can use to initialize the dialog box.
17413>>>>>>>>>    Short    nFileOffset          // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name in the string pointed to by lpstrFile.
17413>>>>>>>>>    Short    nFileExtension       // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name extension in the string pointed to by lpstrFile.
17413>>>>>>>>>    Pointer  lpstrDefExt          // Pointer to a buffer that contains the default extension.
17413>>>>>>>>>    Longptr  lCustData            // Specifies application-defined data that the system passes to the hook procedure identified by the lpfnHook member.
17413>>>>>>>>>    Pointer  lpfnHook             // Pointer to a hook procedure.
17413>>>>>>>>>    Pointer  lpTemplateName       // Pointer to a null-terminated string that names a dialog template resource in the module identified by the hInstance member.
17413>>>>>>>>>    Pointer  lpvReserved          // Reserved
17413>>>>>>>>>    DWord    dwReserved           // Reserved
17413>>>>>>>>>    DWord    FlagsEx              // A set of bit flags you can use to initialize the dialog box.
17413>>>>>>>>>End_Struct
17413>>>>>>>>>
17413>>>>>>>>>Define OFN_READONLY               for |CI$000001
17413>>>>>>>>>Define OFN_OVERWRITEPROMPT        for |CI$000002
17413>>>>>>>>>Define OFN_HIDEREADONLY           for |CI$000004
17413>>>>>>>>>Define OFN_NOCHANGEDIR            for |CI$000008
17413>>>>>>>>>Define OFN_NOVALIDATE             for |CI$000100
17413>>>>>>>>>Define OFN_ALLOWMULTISELECT       for |CI$000200
17413>>>>>>>>>Define OFN_EXTENSIONDIFFERENT     for |CI$000400
17413>>>>>>>>>Define OFN_PATHMUSTEXIST          for |CI$000800
17413>>>>>>>>>Define OFN_FILEMUSTEXIST          for |CI$001000
17413>>>>>>>>>Define OFN_CREATEPROMPT           for |CI$002000
17413>>>>>>>>>Define OFN_SHAREAWARE             for |CI$004000
17413>>>>>>>>>Define OFN_NOREADONLYRETURN       for |CI$008000
17413>>>>>>>>>Define OFN_NOTESTFILECREATE       for |CI$010000
17413>>>>>>>>>Define OFN_EXPLORER               for |CI$080000     // new look commdlg
17413>>>>>>>>>
17413>>>>>>>>>Class AbstractFileDialog is a cObject
17414>>>>>>>>>    
17414>>>>>>>>>    Procedure Construct_Object
17416>>>>>>>>>        Forward Send Construct_Object
17418>>>>>>>>>        
17418>>>>>>>>>        Property String  Filter_String
17419>>>>>>>>>        Property String  Initial_Folder
17420>>>>>>>>>        Property String  File_Name
17421>>>>>>>>>        Property String  File_Title
17422>>>>>>>>>        Property String  Dialog_Caption
17423>>>>>>>>>        Property Integer Filter_Index          1
17424>>>>>>>>>        Property Integer HideReadOnly_State    False
17425>>>>>>>>>        Property Integer TickReadOnly_State    False
17426>>>>>>>>>        Property Integer AllowReadOnly_State   True
17427>>>>>>>>>        Property Integer FileMustExist_State   True
17428>>>>>>>>>        Property Integer PathMustExist_State   True
17429>>>>>>>>>        Property Integer CreatePrompt_State    True
17430>>>>>>>>>        Property Integer ShowFileTitle_State   False
17431>>>>>>>>>        Property Integer OverwritePrompt_State False
17432>>>>>>>>>        Property Integer NoChangeDir_State     False
17433>>>>>>>>>        
17433>>>>>>>>>        Property Boolean Private_MultiSelect_State False
17434>>>>>>>>>        
17434>>>>>>>>>        Property String[] Private_Selected_Files
17435>>>>>>>>>        
17435>>>>>>>>>        Property Integer PrivateExternal_msg
17436>>>>>>>>>        
17436>>>>>>>>>        //Set Focus_Mode To No_Activate
17436>>>>>>>>>    End_Procedure
17437>>>>>>>>>    
17437>>>>>>>>>    Function OwnerHandle Returns Handle
17439>>>>>>>>>        Handle hWnd
17439>>>>>>>>>        Handle hoObj
17439>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
17440>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
17441>>>>>>>>>        Function_Return hWnd
17442>>>>>>>>>    End_Function
17443>>>>>>>>>    
17443>>>>>>>>>    
17443>>>>>>>>>    Function Show_Dialog Returns Integer // bool
17445>>>>>>>>>        Handle hWnd
17445>>>>>>>>>        Integer bOK iFilter iFlags bHideRO bTickRO bFileExist bPathExist iMsg
17445>>>>>>>>>        Integer icInitDir bCreatePrompt bOverwritePrompt bAllowReadOnly
17445>>>>>>>>>        Integer iPos iCount
17445>>>>>>>>>        Integer bNoChangeDir
17445>>>>>>>>>        Pointer lpsFileTitle lpsFileName lpsFilter lpsInitDir
17445>>>>>>>>>        Pointer lpsTitle lpsDefExt
17445>>>>>>>>>        WString sFileName sFileTitle sFilter sInitDir sTitle sDefExt
17445>>>>>>>>>        Pointer lpOpenFileData
17445>>>>>>>>>        Boolean bMultiSelect
17445>>>>>>>>>        String[] sFiles
17446>>>>>>>>>        TOpenFileName OpenFileData
17446>>>>>>>>>        TOpenFileName OpenFileData
17446>>>>>>>>>        
17446>>>>>>>>>        //Delegate Get Container_Handle To hWnd
17446>>>>>>>>>        Get OwnerHandle to hWnd
17447>>>>>>>>>        
17447>>>>>>>>>        If (ShowFileTitle_State(Self)) Begin
17449>>>>>>>>>            Get File_Title to sFileName
17450>>>>>>>>>        End
17450>>>>>>>>>>
17450>>>>>>>>>        
17450>>>>>>>>>        Get private_MultiSelect_State to bMultiSelect
17451>>>>>>>>>        
17451>>>>>>>>>        Get Initial_Folder        to sInitDir
17452>>>>>>>>>        Get Dialog_Caption        to sTitle
17453>>>>>>>>>        Get Filter_String         to sFilter
17454>>>>>>>>>        Get HideReadOnly_State    to bHideRO
17455>>>>>>>>>        Get TickReadOnly_State    to bTickRO
17456>>>>>>>>>        Get FileMustExist_State   to bFileExist
17457>>>>>>>>>        Get PathMustExist_State   to bPathExist
17458>>>>>>>>>        Get CreatePrompt_State    to bCreatePrompt
17459>>>>>>>>>        Get OverwritePrompt_State to bOverwritePrompt
17460>>>>>>>>>        Get AllowReadOnly_State   to bAllowReadOnly
17461>>>>>>>>>        Get NoChangeDir_State     to bNoChangeDir
17462>>>>>>>>>        Get Filter_Index          to iFilter
17463>>>>>>>>>        
17463>>>>>>>>>        Move (sFilter + Character(0) + Character(0)) to sFilter
17464>>>>>>>>>        Move (Replaces('|', sFilter, Character(0))) to sFilter
17465>>>>>>>>>        
17465>>>>>>>>>        Append sInitDir   (character(0))
17466>>>>>>>>>        Append sFileTitle (Repeat(character(0),32000))
17467>>>>>>>>>        Append sFileName  (Repeat(character(0),32000))
17468>>>>>>>>>        Append sTitle     (Repeat(character(0),255))
17469>>>>>>>>>        Append sDefExt    (character(0))
17470>>>>>>>>>        
17470>>>>>>>>>        Move (AddressOf(sInitDir))   to lpsInitDir
17471>>>>>>>>>        Move (AddressOf(sFileName))  to lpsFileName
17472>>>>>>>>>        Move (AddressOf(sFileTitle)) to lpsFileTitle
17473>>>>>>>>>        Move (AddressOf(sTitle))     to lpsTitle
17474>>>>>>>>>        Move (AddressOf(sDefExt))    to lpsDefExt
17475>>>>>>>>>        Move (AddressOf(sFilter))    to lpsFilter
17476>>>>>>>>>        
17476>>>>>>>>>        
17476>>>>>>>>>        If (bMultiSelect) Begin
17478>>>>>>>>>            Move (OFN_EXPLORER + OFN_ALLOWMULTISELECT) to iFlags  // Multi-select!
17479>>>>>>>>>        End
17479>>>>>>>>>>
17479>>>>>>>>>        
17479>>>>>>>>>        If bFileExist ;            Move (iFlags + OFN_FILEMUSTEXIST)    to iFlags
17482>>>>>>>>>        If bPathExist ;            Move (iFlags + OFN_PATHMUSTEXIST)    to iFlags
17485>>>>>>>>>        If bHideRO ;            Move (iFlags + OFN_HIDEREADONLY)     to iFlags
17488>>>>>>>>>        If bTickRO ;            Move (iFlags + OFN_READONLY)         to iFlags
17491>>>>>>>>>        If bCreatePrompt ;            Move (iFlags + OFN_CREATEPROMPT)     to iFlags
17494>>>>>>>>>        If bOverwritePrompt ;            Move (iFlags + OFN_OVERWRITEPROMPT)  to iFlags
17497>>>>>>>>>        If not bAllowReadOnly ;            Move (iFlags + OFN_NOREADONLYRETURN) to iFlags
17500>>>>>>>>>        If bNoChangeDir ;            Move (iFlags + OFN_NOCHANGEDIR)      to iFlags
17503>>>>>>>>>        
17503>>>>>>>>>        Move (SizeOfType(TOpenFileName)) to OpenFileData.lStructSize
17504>>>>>>>>>        Move hWnd         to OpenFileData.hWndOwner
17505>>>>>>>>>        Move iFilter      to OpenFileData.nFilterIndex
17506>>>>>>>>>        Move lpsFileName  to OpenFileData.lpstrFile
17507>>>>>>>>>        
17507>>>>>>>>>        If (sInitDir <> '') Begin
17509>>>>>>>>>            Move lpsInitDir    to OpenFileData.lpstrInitialDir
17510>>>>>>>>>        End
17510>>>>>>>>>>
17510>>>>>>>>>        
17510>>>>>>>>>        If (sTitle <> '') Begin
17512>>>>>>>>>            Move lpsTitle      to OpenFileData.lpstrTitle
17513>>>>>>>>>        End
17513>>>>>>>>>>
17513>>>>>>>>>        
17513>>>>>>>>>        Move 32000             to OpenFileData.nMaxFileTitle
17514>>>>>>>>>        Move 32000             to OpenFileData.nMaxFile
17515>>>>>>>>>        Move lpsFileTitle      to OpenFileData.lpstrFileTitle
17516>>>>>>>>>        Move iFlags            to OpenFileData.ofnFlags
17517>>>>>>>>>        Move lpsFilter         to OpenFileData.lpstrFilter
17518>>>>>>>>>        Move lpsDefExt         to OpenFileData.lpstrDefExt
17519>>>>>>>>>        
17519>>>>>>>>>        Move (AddressOf(OpenFileData)) to lpOpenFileData
17520>>>>>>>>>        
17520>>>>>>>>>        Get PrivateExternal_msg to iMsg
17521>>>>>>>>>        If (iMsg = Get_GetOpenFileNameW) ;            Move (GetOpenFileNameW (lpOpenFileData)) to bOK
17524>>>>>>>>>        If (iMsg = Get_GetSaveFileNameW) ;            Move (GetSaveFileNameW (lpOpenFileData)) to bOK
17527>>>>>>>>>        
17527>>>>>>>>>        If bOK Begin
17529>>>>>>>>>            Move OpenFileData.ofnFlags     to iFlags
17530>>>>>>>>>            Move OpenFileData.nFilterIndex to iFilter
17531>>>>>>>>>            Move OpenFileData.nFileOffset  to icInitDir
17532>>>>>>>>>            
17532>>>>>>>>>            Move (CString(Left(sFileName, icInitDir))) to sInitDir    // Trim trailing null
17533>>>>>>>>>            Set Initial_Folder     to sInitDir
17534>>>>>>>>>            
17534>>>>>>>>>            Set TickReadOnly_State to (iFlags iand OFN_READONLY)
17535>>>>>>>>>            Set Filter_Index       to iFilter
17536>>>>>>>>>
17536>>>>>>>>>            Set File_Name          to (CString( sFileName ))
17537>>>>>>>>>            Set File_Title         to (CString( sFileTitle ))
17538>>>>>>>>>            
17538>>>>>>>>>            If (bMultiSelect) Begin
17540>>>>>>>>>                // If this is a multi-files dialog then parse out the array of selected files....
17540>>>>>>>>>                If (Right(sInitDir, 1) = "\") ;                    Move (Left(sInitDir, Length(sInitDir)-1)) to sInitDir     // Trim trailing :\". This is only there if 1 file was selected!
17543>>>>>>>>>                
17543>>>>>>>>>                // Get the null delimited string of file names into the sFiles array....
17543>>>>>>>>>                Move 0 to iCount
17544>>>>>>>>>                Move (Right(sFileName, Length(sFileName) - icInitDir)) to sFileName    // Strip the path info (we already have it)
17545>>>>>>>>>                
17545>>>>>>>>>                Repeat
17545>>>>>>>>>>
17545>>>>>>>>>                    // Get the next filename....
17545>>>>>>>>>                    Move (Pos(Character(0), sFileName)) to iPos   // Filenames are null delimeted
17546>>>>>>>>>                    
17546>>>>>>>>>                    If (iPos > 1) Begin
17548>>>>>>>>>                        Move (sInitDir + "\" + CString(Left(sFileName, iPos))) to sFiles[iCount]
17549>>>>>>>>>                        Move (Right(sFileName, Length(sFileName) - iPos)) to sFileName
17550>>>>>>>>>                        Increment iCount
17551>>>>>>>>>                    End
17551>>>>>>>>>>
17551>>>>>>>>>                Until (iPos <= 1)
17553>>>>>>>>>            End
17553>>>>>>>>>>
17553>>>>>>>>>            Else Begin
17554>>>>>>>>>                Move (CString(sFileName)) to sFiles[0]
17555>>>>>>>>>            End
17555>>>>>>>>>>
17555>>>>>>>>>            
17555>>>>>>>>>            Set private_Selected_Files to sFiles
17556>>>>>>>>>        End
17556>>>>>>>>>>
17556>>>>>>>>>        Function_Return (bOK)
17557>>>>>>>>>    End_Function
17558>>>>>>>>>End_Class
17559>>>>>>>>>
17559>>>>>>>>>Class OpenDialog is an AbstractFileDialog
17560>>>>>>>>>    Procedure Construct_Object
17562>>>>>>>>>        Forward Send Construct_Object
17564>>>>>>>>>        Set PrivateExternal_msg to get_GetOpenFileNameW
17565>>>>>>>>>    End_Procedure
17566>>>>>>>>>    
17566>>>>>>>>>    Procedure Set MultiSelect_State Boolean bState
17568>>>>>>>>>        Set private_MultiSelect_State to bState
17569>>>>>>>>>    End_Procedure
17570>>>>>>>>>    
17570>>>>>>>>>    Function MultiSelect_State Returns Boolean
17572>>>>>>>>>        Boolean bState
17572>>>>>>>>>        Get private_MultiSelect_State to bState
17573>>>>>>>>>        Function_Return bState
17574>>>>>>>>>    End_Function
17575>>>>>>>>>    
17575>>>>>>>>>    Function Selected_Files Returns String[]
17577>>>>>>>>>        String[] sFiles
17578>>>>>>>>>        Get private_Selected_Files to sFiles
17579>>>>>>>>>        Function_Return sFiles
17580>>>>>>>>>    End_Function
17581>>>>>>>>>End_Class
17582>>>>>>>>>
17582>>>>>>>>>Class SaveAsDialog is an AbstractFileDialog
17583>>>>>>>>>    Procedure Construct_Object
17585>>>>>>>>>        Forward Send Construct_Object
17587>>>>>>>>>        Set FileMustExist_State   to False
17588>>>>>>>>>        Set CreatePrompt_State    to False
17589>>>>>>>>>        Set ShowFileTitle_State   to True
17590>>>>>>>>>        Set OverwritePrompt_State to True
17591>>>>>>>>>        Set HideReadOnly_State    to True
17592>>>>>>>>>        Set PrivateExternal_msg to get_GetSaveFileNameW
17593>>>>>>>>>    End_Procedure
17594>>>>>>>>>End_Class
17595>>>>>>>>>
17595>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
17595>>>>>>>>>//***************************************************************************
17595>>>>>>>>>//*
17595>>>>>>>>>//* Class:        cvSaveAsDialog
17595>>>>>>>>>//* Package Name: cvFileDialogs.pkg
17595>>>>>>>>>//*
17595>>>>>>>>>//***************************************************************************
17595>>>>>>>>>
17595>>>>>>>>>Use File_dlg.pkg
17595>>>>>>>>>
17595>>>>>>>>>// *WvA: 13-01-1999 Created
17595>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
17595>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
17595>>>>>>>>>// file_name.
17595>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
17596>>>>>>>>>
17596>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
17598>>>>>>>>>        Forward Send Construct_Object iImage_Id
17600>>>>>>>>>        Set HideReadOnly_State to True
17601>>>>>>>>>    End_Procedure
17602>>>>>>>>>
17602>>>>>>>>>    Function SelectedFileName Returns String
17604>>>>>>>>>        String sFileName
17604>>>>>>>>>        Move "" to sFileName
17605>>>>>>>>>        If (Show_Dialog(Self)) Begin
17607>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
17608>>>>>>>>>        End
17608>>>>>>>>>>
17608>>>>>>>>>        Function_Return sFileName
17609>>>>>>>>>    End_Function
17610>>>>>>>>>End_Class
17611>>>>>>>>>
17611>>>>>>>>>// *WvA: 13-01-1999 Created
17611>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
17611>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
17611>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
17611>>>>>>>>>//                   file-open dialog
17611>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
17613>>>>>>>>>    String sSelectedFile
17613>>>>>>>>>    Integer hoOpenFileDialog
17613>>>>>>>>>
17613>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
17615>>>>>>>>>
17615>>>>>>>>>        Set Dialog_Caption    to sCaptionText
17616>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
17617>>>>>>>>>        Set Initial_Folder    to sInitialFolder
17618>>>>>>>>>
17618>>>>>>>>>        Move Self       to hoOpenFileDialog
17619>>>>>>>>>    End_Object
17620>>>>>>>>>
17620>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
17621>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
17622>>>>>>>>>    Function_Return sSelectedFile
17623>>>>>>>>>End_Function
17624>>>>>>>>>
17624>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
17625>>>>>>>>>
17625>>>>>>>>>    Procedure Construct_Object
17627>>>>>>>>>        Forward Send Construct_Object
17629>>>>>>>>>        Set HideReadOnly_State to True
17630>>>>>>>>>    End_Procedure
17631>>>>>>>>>
17631>>>>>>>>>    Function SelectedFileName Returns String
17633>>>>>>>>>        String sFileName
17633>>>>>>>>>        Move "" to sFileName
17634>>>>>>>>>        If (Show_Dialog(Self)) Begin
17636>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
17637>>>>>>>>>        End
17637>>>>>>>>>>
17637>>>>>>>>>        Function_Return sFileName
17638>>>>>>>>>    End_Function
17639>>>>>>>>>
17639>>>>>>>>>End_Class
17640>>>>>>>>>
17640>>>>>>>>>// Added optional default filename as suggested by Nils
17640>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
17642>>>>>>>>>    String sSelectedFile
17642>>>>>>>>>    Integer hoDialog
17642>>>>>>>>>
17642>>>>>>>>>    Move "" to sSelectedFile
17643>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
17644>>>>>>>>>    If (hoDialog) Begin
17646>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
17646>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
17647>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
17648>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
17649>>>>>>>>>        If (Num_Arguments = 4) Begin
17651>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
17652>>>>>>>>>        End
17652>>>>>>>>>>
17652>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
17653>>>>>>>>>        Send Destroy of hoDialog
17654>>>>>>>>>    End
17654>>>>>>>>>>
17654>>>>>>>>>    Function_Return sSelectedFile
17655>>>>>>>>>End_Function
17656>>>>>>>Use Seq_chnl.pkg
17656>>>>>>>
17656>>>>>>>Use windows.pkg
17656>>>>>>>Use Dll.pkg
17656>>>>>>>
17656>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
17656>>>>>>>>>// This code is part of VDF GUIdance
17656>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
17656>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
17656>>>>>>>>>// VDF GUIdance is a mutual project of
17656>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
17656>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
17656>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
17656>>>>>>>>>//
17656>>>>>>>>>//
17656>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
17656>>>>>>>>>// Unicode variant
17656>>>>>>>>>
17656>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
17656>>>>>>>>>>>//TH-Header
17656>>>>>>>>>>>//*****************************************************************************************
17656>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
17656>>>>>>>>>>>// All rights reserved.
17656>>>>>>>>>>>//
17656>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
17656>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
17656>>>>>>>>>>>// $Authors     : Wil van Antwerpen
17656>>>>>>>>>>>// $Created     : 19.02.2004  19:25
17656>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
17656>>>>>>>>>>>//
17656>>>>>>>>>>>// Contents:
17656>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
17656>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
17656>>>>>>>>>>>//*****************************************************************************************
17656>>>>>>>>>>>//TH-RevisionStart
17656>>>>>>>>>>>//TH-RevisionEnd
17656>>>>>>>>>>>
17656>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
17656>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
17656>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>>Define vMax_Path     For |CI260
17656>>>>>>>>>>>Define vMinChar      For |CI$80
17656>>>>>>>>>>>Define vMaxChar      For |CI$7F
17656>>>>>>>>>>>Define vMinShort     For |CI$8000
17656>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
17656>>>>>>>>>>>Define vMinLong      For |CI$80000000
17656>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
17656>>>>>>>>>>>Define vMaxByte      For |CI$FF
17656>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
17656>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>>// For FindFirstFile
17656>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
17656>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
17656>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
17656>>>>>>>>>>>
17656>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
17656>>>>>>>>>>>// the API-call ShellExecute is used.
17656>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
17656>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
17656>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
17656>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
17656>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
17656>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
17656>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
17656>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
17656>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
17656>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
17656>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
17656>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
17656>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
17656>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>>// C-Structure
17656>>>>>>>>>>>//typedef struct _browseinfo {
17656>>>>>>>>>>>//    HWND hwndOwner;
17656>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
17656>>>>>>>>>>>//    LPSTR pszDisplayName;
17656>>>>>>>>>>>//    LPCSTR lpszTitle;
17656>>>>>>>>>>>//    UINT ulFlags;
17656>>>>>>>>>>>//    BFFCALLBACK lpfn;
17656>>>>>>>>>>>//    LPARAM lParam;
17656>>>>>>>>>>>//    int iImage;
17656>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
17656>>>>>>>>>>>
17656>>>>>>>>>>>//declare C structure struct_browseinfo
17656>>>>>>>>>>>//as documented in MSDN under Windows Shell API
17656>>>>>>>>>>>Struct tvBrowseInfo
17656>>>>>>>>>>>  Handle    hWndOwner
17656>>>>>>>>>>>  Pointer   pIDLRoot
17656>>>>>>>>>>>  Pointer   pszDisplayName
17656>>>>>>>>>>>  Pointer   lpszTitle
17656>>>>>>>>>>>  DWord     ulFlags
17656>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
17656>>>>>>>>>>>  Pointer   lpfnCallback
17656>>>>>>>>>>>  LongPtr   lParam
17656>>>>>>>>>>>  DWord     iImage
17656>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
17656>>>>>>>>>>>End_Struct // tvBrowseInfo
17656>>>>>>>>>>>
17656>>>>>>>>>>>// Browsing for directory.
17656>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
17656>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
17656>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
17656>>>>>>>>>>>                                            // The callback function can set the status text by
17656>>>>>>>>>>>                                            // sending messages to the dialog box.
17656>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
17656>>>>>>>>>>>
17656>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
17656>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
17656>>>>>>>>>>>
17656>>>>>>>>>>>// message from browser
17656>>>>>>>>>>>//Define BFFM_INITIALIZED        1
17656>>>>>>>>>>>//Define BFFM_SELCHANGED         2
17656>>>>>>>>>>>
17656>>>>>>>>>>>// messages to browser
17656>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
17656>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
17656>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
17656>>>>>>>>>>>
17656>>>>>>>>>>>
17656>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
17657>>>>>>>>>>>
17657>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
17658>>>>>>>>>>>
17658>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
17659>>>>>>>>>>>
17659>>>>>>>>>>>
17659>>>>>>>>>>>
17659>>>>>>>>>>>
17659>>>>>>>>>>>Struct tvSecurity_attributes
17659>>>>>>>>>>>  DWord   nLength
17659>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
17659>>>>>>>>>>>  Pointer lpDescriptor
17659>>>>>>>>>>>  Integer bInheritHandle
17659>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
17659>>>>>>>>>>>End_Struct // tvSecurity_attributes
17659>>>>>>>>>>>
17659>>>>>>>>>>>//nLength:
17659>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
17659>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
17659>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
17659>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
17659>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
17659>>>>>>>>>>>//
17659>>>>>>>>>>>//lpSecurityDescriptor:
17659>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
17659>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
17659>>>>>>>>>>>// descriptor of the calling process.
17659>>>>>>>>>>>//
17659>>>>>>>>>>>//bInheritHandle:
17659>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
17659>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
17659>>>>>>>>>>>
17659>>>>>>>>>>>
17659>>>>>>>>>>>// BOOL CreateDirectory(
17659>>>>>>>>>>>//    LPCTSTR lpPathName,
17659>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
17659>>>>>>>>>>>//   );
17659>>>>>>>>>>>//
17659>>>>>>>>>>>// lpPathName
17659>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
17659>>>>>>>>>>>//  to be created.
17659>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
17659>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
17659>>>>>>>>>>>// lpSecurityAttributes
17659>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
17659>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
17659>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
17659>>>>>>>>>>>// Returns:
17659>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
17659>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
17659>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
17660>>>>>>>>>>>
17660>>>>>>>>>>>
17660>>>>>>>>>>>// lpPathName
17660>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
17660>>>>>>>>>>>//  to be removed.
17660>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
17660>>>>>>>>>>>// Returns:
17660>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
17660>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
17660>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
17661>>>>>>>>>>>
17661>>>>>>>>>>>
17661>>>>>>>>>>>
17661>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
17661>>>>>>>>>>>// executable file or a document file.
17661>>>>>>>>>>>//
17661>>>>>>>>>>>// Operation can be one of the following:
17661>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
17661>>>>>>>>>>>//            The file can be an executable file or a document file.
17661>>>>>>>>>>>//            The file can be a folder to open.
17661>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
17661>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
17661>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
17661>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
17661>>>>>>>>>>>//
17661>>>>>>>>>>>// Return Values:
17661>>>>>>>>>>>//
17661>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
17661>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
17661>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
17661>>>>>>>>>>>//
17661>>>>>>>>>>>// The following table lists these error values:
17661>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
17661>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
17661>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
17661>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
17661>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
17661>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
17661>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
17661>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
17661>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
17661>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
17661>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
17661>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
17661>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
17661>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
17661>>>>>>>>>>>
17661>>>>>>>>>>>
17661>>>>>>>>>>>
17661>>>>>>>>>>>// Code to open the program that is associated with the selected file.
17661>>>>>>>>>>>//
17661>>>>>>>>>>>// External function call used in Procedure DoStartDocument
17661>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
17662>>>>>>>>>>>
17662>>>>>>>>>>>
17662>>>>>>>>>>>
17662>>>>>>>>>>>
17662>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
17662>>>>>>>>>>>Define vFO_COPY                For |CI$0002
17662>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
17662>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
17662>>>>>>>>>>>
17662>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
17662>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
17662>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
17662>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
17662>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
17662>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
17662>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
17662>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
17662>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
17662>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
17662>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
17662>>>>>>>>>>>
17662>>>>>>>>>>>Struct tvShFileOpStruct
17662>>>>>>>>>>>  Handle   hWnd
17662>>>>>>>>>>>  UInteger wFunc
17662>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
17662>>>>>>>>>>>  Pointer  pFrom
17662>>>>>>>>>>>  Pointer  pTo
17662>>>>>>>>>>>  Short    fFlags
17662>>>>>>>>>>>  Integer  fAnyOperationsAborted
17662>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
17662>>>>>>>>>>>  Pointer  hNameMappings
17662>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
17662>>>>>>>>>>>End_Struct // tvShFileOpStruct
17662>>>>>>>>>>>
17662>>>>>>>>>>>// hwnd
17662>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
17662>>>>>>>>>>>
17662>>>>>>>>>>>// wFunc
17662>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
17662>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
17662>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
17662>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
17662>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
17662>>>>>>>>>>>
17662>>>>>>>>>>>// pFrom
17662>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
17662>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
17662>>>>>>>>>>>
17662>>>>>>>>>>>// pTo
17662>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
17662>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
17662>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
17662>>>>>>>>>>>//   double null-terminated.
17662>>>>>>>>>>>
17662>>>>>>>>>>>// fAnyOperationsAborted
17662>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
17662>>>>>>>>>>>//   were completed or FALSE otherwise.
17662>>>>>>>>>>>
17662>>>>>>>>>>>
17662>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
17662>>>>>>>>>>>// This can be a file or a folder.
17662>>>>>>>>>>>// With thanks to Andrew S Kaplan
17662>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
17663>>>>>>>>>>>
17663>>>>>>>>>>>
17663>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
17663>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
17664>>>>>>>>>>>
17664>>>>>>>>>>>
17664>>>>>>>>>>>
17664>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17664>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
17664>>>>>>>>>>>//   Pointer lpPathName ;
17664>>>>>>>>>>>//   Pointer lpPrefixString ;
17664>>>>>>>>>>>//   Integer uUnique ;
17664>>>>>>>>>>>//   Pointer lpTempFileName ;
17664>>>>>>>>>>>//   Returns Integer
17664>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
17664>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
17665>>>>>>>>>>>
17665>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
17666>>>>>>>>>>>
17666>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
17667>>>>>>>>>>>
17667>>>>>>>>>>>// from:
17667>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
17667>>>>>>>>>>>//
17667>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
17667>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
17667>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
17667>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
17667>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
17667>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
17667>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
17667>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
17667>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
17667>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
17667>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
17667>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
17667>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
17667>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
17667>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
17667>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
17667>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
17667>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
17667>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
17667>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
17667>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
17667>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
17667>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
17667>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
17667>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
17667>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
17667>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
17667>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
17667>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
17667>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
17667>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
17667>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
17667>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
17667>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
17667>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
17667>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
17667>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
17667>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
17667>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
17667>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
17667>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
17667>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
17667>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
17667>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
17667>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
17667>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
17667>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
17667>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
17667>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
17667>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
17667>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
17667>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
17667>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
17667>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
17667>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
17667>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
17667>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
17667>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
17667>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
17667>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
17667>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
17667>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
17667>>>>>>>>>>>
17667>>>>>>>>>>>
17667>>>>>>>>>>>//HRESULT SHGetFolderPath(
17667>>>>>>>>>>>//    HWND hwndOwner,
17667>>>>>>>>>>>//    int nFolder,
17667>>>>>>>>>>>//    HANDLE hToken,
17667>>>>>>>>>>>//    DWORD dwFlags,
17667>>>>>>>>>>>//    LPTSTR pszPath
17667>>>>>>>>>>>//);
17667>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
17667>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
17667>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
17667>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
17667>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
17667>>>>>>>>>>>//
17667>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
17668>>>>>>>>>>>
17668>>>>>>>>>>>
17668>>>>>>>>>>>
17668>>>>>>>>>>>Struct tvWin32FindData
17668>>>>>>>>>>> Dword            dwFileAttributes
17668>>>>>>>>>>> Dword            ftCreationLowDateTime
17668>>>>>>>>>>> Dword            ftCreationHighDateTime
17668>>>>>>>>>>> dword            ftLastAccessLowDateTime
17668>>>>>>>>>>> Dword            ftLastAccessHighDateTime
17668>>>>>>>>>>> Dword            ftLastWriteLowDateTime
17668>>>>>>>>>>> Dword            ftLastWriteHighDateTime
17668>>>>>>>>>>> Dword            nFileSizeHigh
17668>>>>>>>>>>> Dword            nFileSizeLow
17668>>>>>>>>>>> Dword            dwReserved0
17668>>>>>>>>>>> Dword            dwReserved1
17668>>>>>>>>>>> Short[vMax_Path] cFileName
17668>>>>>>>>>>> Short[14]        cAlternateFileName
17668>>>>>>>>>>>End_Struct
17668>>>>>>>>>>>
17668>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17668>>>>>>>>>>>// lpFileName      : address of name of file to search for
17668>>>>>>>>>>>// lpFindFileData  : address of returned information
17668>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
17669>>>>>>>>>>>
17669>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17669>>>>>>>>>>>// hFindFile       : handle of search
17669>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
17669>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
17670>>>>>>>>>>>
17670>>>>>>>>>>>
17670>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17670>>>>>>>>>>>//  hFindFile      : file search handle
17670>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
17671>>>>>>>>>>>
17671>>>>>>>>>>>
17671>>>>>>>>>>>
17671>>>>>>>>>>>Struct tvFileTime
17671>>>>>>>>>>>  DWord dwLowDateTime
17671>>>>>>>>>>>  DWord dwHighDateTime
17671>>>>>>>>>>>End_Struct
17671>>>>>>>>>>>
17671>>>>>>>>>>>
17671>>>>>>>>>>>Struct tvSystemTime
17671>>>>>>>>>>>  UShort wYear
17671>>>>>>>>>>>  UShort wMonth
17671>>>>>>>>>>>  UShort wDayOfWeek
17671>>>>>>>>>>>  UShort wDay
17671>>>>>>>>>>>  UShort wHour
17671>>>>>>>>>>>  UShort wMinute
17671>>>>>>>>>>>  UShort wSecond
17671>>>>>>>>>>>  UShort wMilliSeconds
17671>>>>>>>>>>>End_Struct
17671>>>>>>>>>>>
17671>>>>>>>>>>>
17671>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17671>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
17671>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
17671>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
17672>>>>>>>>>>>
17672>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17672>>>>>>>>>>>// This function formats the time in a picture-string passed
17672>>>>>>>>>>>//
17672>>>>>>>>>>>// Picture      Meaning
17672>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
17672>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
17672>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
17672>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
17672>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
17672>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
17672>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
17672>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
17672>>>>>>>>>>>//    t         One character time marker string, such as A or P
17672>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
17672>>>>>>>>>>>//
17672>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
17672>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
17672>>>>>>>>>>>
17672>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
17673>>>>>>>>>>>
17673>>>>>>>>>>>
17673>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
17673>>>>>>>>>>>// This function formats the date in a picture-string passed
17673>>>>>>>>>>>//
17673>>>>>>>>>>>// Picture      Meaning
17673>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
17673>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
17673>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
17673>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
17673>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
17673>>>>>>>>>>>//              value associated with the specified locale.
17673>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
17673>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
17673>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
17673>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
17673>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
17673>>>>>>>>>>>//              associated with the specified locale.
17673>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
17673>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
17673>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
17673>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
17673>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
17673>>>>>>>>>>>//              does not have an associated era or period string.
17673>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
17673>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
17673>>>>>>>>>>>
17673>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
17674>>>>>>>>>>>
17674>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
17674>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
17674>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
17674>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
17674>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
17674>>>>>>>>>>>
17674>>>>>>>>>>>//  Date Flags for GetDateFormatW.
17674>>>>>>>>>>>//
17674>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
17674>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
17674>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
17674>>>>>>>>>>>
17674>>>>>>>>>>>
17674>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
17675>>>>>>>>>>>
17675>>>>>>>>>>>
17675>>>>>>>>>>>// **WvA: 20-02-2004
17675>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
17675>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
17675>>>>>>>>>>>// incorrectly into an unsigned integer.
17675>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
17675>>>>>>>>>>>// It does smell a bit fishy though
17675>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
17675>>>>>>>>>>>
17675>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
17675>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
17675>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
17675>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
17675>>>>>>>>>>>
17675>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
17675>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
17675>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
17675>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
17675>>>>>>>>>>>
17675>>>>>>>>>>>
17675>>>>>>>>>>> // Courtesy Of Steve Walter,
17675>>>>>>>>>>> // USA Software, Inc
17675>>>>>>>>>>> // Format a disk
17675>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
17675>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
17676>>>>>>>>>>>
17676>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
17676>>>>>>>>>>>
17676>>>>>>>>>>>// SHCreateDirectoryEx
17676>>>>>>>>>>>
17676>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
17676>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
17676>>>>>>>>>>>//
17676>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
17676>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
17676>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
17676>>>>>>>>>>>//
17676>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
17676>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
17676>>>>>>>>>>>//        ERROR_CANCELLED.
17676>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
17676>>>>>>>>>>>
17676>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
17676>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
17676>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
17676>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
17676>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
17676>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
17676>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
17676>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
17676>>>>>>>>>>>
17676>>>>>>>>>>>//        int SHCreateDirectoryEx(
17676>>>>>>>>>>>//            HWND hwnd,
17676>>>>>>>>>>>//            LPCTSTR pszPath,
17676>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
17676>>>>>>>>>>>//        );
17676>>>>>>>>>>>
17676>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
17677>>>>>>>>>>>
17677>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
17678>>>>>>>>>
17678>>>>>>>>>
17678>>>>>>>>>
17678>>>>>>>>>// Does the directory exist? - No = false, Yes = True
17678>>>>>>>>>// This also works with UNC path encoding and wildcards
17678>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
17680>>>>>>>>>    Boolean bFolderExists
17680>>>>>>>>>    Boolean bStop
17680>>>>>>>>>    String  sFolder sTmp
17680>>>>>>>>>    Integer iCh
17680>>>>>>>>>
17680>>>>>>>>>    If (sFolderName = "") Begin
17682>>>>>>>>>        Function_Return False
17683>>>>>>>>>    End
17683>>>>>>>>>>
17683>>>>>>>>>
17683>>>>>>>>>    Move True  to bFolderExists
17684>>>>>>>>>    Move False to bStop
17685>>>>>>>>>    Move "dir:" to sFolder
17686>>>>>>>>>    Append sFolder sFolderName
17687>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
17688>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
17690>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
17691>>>>>>>>>>
17691>>>>>>>>>        Function_Return False
17692>>>>>>>>>    End
17692>>>>>>>>>>
17692>>>>>>>>>    Direct_Input channel iCh sFolder
17694>>>>>>>>>    Repeat
17694>>>>>>>>>>
17694>>>>>>>>>        Readln channel iCh sTmp
17696>>>>>>>>>        Move (SeqEof) to bStop
17697>>>>>>>>>        If (Trim(sTmp)="") Begin
17699>>>>>>>>>            Move False to bFolderExists
17700>>>>>>>>>        End
17700>>>>>>>>>>
17700>>>>>>>>>        Else Begin
17701>>>>>>>>>            Move True to bFolderExists
17702>>>>>>>>>            Move True to bStop
17703>>>>>>>>>        End
17703>>>>>>>>>>
17703>>>>>>>>>    Until (bStop)
17705>>>>>>>>>    Close_Input channel iCh
17707>>>>>>>>>    Send Seq_Release_Channel iCh
17708>>>>>>>>>    Function_Return bFolderExists
17709>>>>>>>>>End_Function
17710>>>>>>>>>
17710>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
17710>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
17712>>>>>>>>>    String  sPath
17712>>>>>>>>>    WString sFolder sTitle
17712>>>>>>>>>    Pointer lpItemIdList
17712>>>>>>>>>    Integer iFolderSelected iRetval
17712>>>>>>>>>    tvBrowseInfo BrowseInfo
17712>>>>>>>>>    tvBrowseInfo BrowseInfo
17712>>>>>>>>>
17712>>>>>>>>>    Move "" to sPath
17713>>>>>>>>>    If (sDialogTitle<>"") Begin
17715>>>>>>>>>        Move sDialogTitle to sTitle
17716>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
17716>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
17716>>>>>>>>>        // These chars are correctly shown if no toansi is used.
17716>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
17716>>>>>>>>>        // selected it will always be valid.
17716>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
17717>>>>>>>>>    End
17717>>>>>>>>>>
17717>>>>>>>>>
17717>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
17718>>>>>>>>>
17718>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
17718>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
17718>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
17719>>>>>>>>>
17719>>>>>>>>>    // null 128 chars into var (make space)
17719>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17720>>>>>>>>>
17720>>>>>>>>>    // select folder
17720>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
17721>>>>>>>>>    // get selected folder name
17721>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
17722>>>>>>>>>
17722>>>>>>>>>    // release memory resources that are used by the ItemIdList
17722>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
17723>>>>>>>>>
17723>>>>>>>>>    If (iFolderSelected<>0) Begin
17725>>>>>>>>>        Move (CString(sFolder)) to sPath
17726>>>>>>>>>    End
17726>>>>>>>>>>
17726>>>>>>>>>    Function_Return  sPath
17727>>>>>>>>>End_Function
17728>>>>>>>>>
17728>>>>>>>>>// returns 0 if the folder is created.
17728>>>>>>>>>//         1 if the API-call returned an error.
17728>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
17730>>>>>>>>>    Integer  iRetval bFolderCreated
17730>>>>>>>>>    WString  sFolder
17730>>>>>>>>>    tvSecurity_attributes SA
17730>>>>>>>>>    tvSecurity_attributes SA
17730>>>>>>>>>
17730>>>>>>>>>    Move False to bFolderCreated
17731>>>>>>>>>    If (sNewFolder <> "") Begin
17733>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
17734>>>>>>>>>        Move  0                                  to SA.lpDescriptor
17735>>>>>>>>>        Move  1                                  to SA.bInheritHandle
17736>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
17737>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
17738>>>>>>>>>    End
17738>>>>>>>>>>
17738>>>>>>>>>
17738>>>>>>>>>    If (bFolderCreated=false) Begin
17740>>>>>>>>>        Move 1 to iRetVal
17741>>>>>>>>>    End
17741>>>>>>>>>>
17741>>>>>>>>>    Function_Return iRetVal
17742>>>>>>>>>End_Function
17743>>>>>>>>>
17743>>>>>>>>>// **WvA: 03-02-2002 Function created.
17743>>>>>>>>>// With this function one can remove a directory.
17743>>>>>>>>>// returns 0 if the folder is removed.
17743>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
17743>>>>>>>>>//         2 if the folder did not exist
17743>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
17743>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
17745>>>>>>>>>    Boolean bRemoved
17745>>>>>>>>>    WString sPath
17745>>>>>>>>>    Integer iRetval
17745>>>>>>>>>
17745>>>>>>>>>    Move 0     to iRetVal
17746>>>>>>>>>    Move False to bRemoved
17747>>>>>>>>>    Move (Trim(sFolder)) to sFolder
17748>>>>>>>>>    If (sFolder="") Begin
17750>>>>>>>>>        Move 3 to iRetVal
17751>>>>>>>>>    End
17751>>>>>>>>>>
17751>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
17753>>>>>>>>>        Move 2 to iRetVal
17754>>>>>>>>>    End
17754>>>>>>>>>>
17754>>>>>>>>>    If (iRetVal=0) Begin
17756>>>>>>>>>        // null MAX_PATH chars into var (make space)
17756>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
17757>>>>>>>>>        //
17757>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
17758>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
17759>>>>>>>>>    End
17759>>>>>>>>>>
17759>>>>>>>>>
17759>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
17761>>>>>>>>>        Move 1 to iRetVal
17762>>>>>>>>>    End
17762>>>>>>>>>>
17762>>>>>>>>>    Function_Return iRetVal
17763>>>>>>>>>End_Function
17764>>>>>>>>>
17764>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
17764>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
17764>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
17764>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
17766>>>>>>>>>    Handle  hInstance hWnd
17766>>>>>>>>>    // remove any leading/trailing spaces in the string
17766>>>>>>>>>    Move (Trim(sDocument)) to sDocument
17767>>>>>>>>>    Move (Trim(sPath))     to sPath
17768>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
17768>>>>>>>>>    Append sOperation   (Character(0))
17769>>>>>>>>>    Append sDocument    (Character(0))
17770>>>>>>>>>    Append sParameters  (Character(0))
17771>>>>>>>>>    Append sPath        (Character(0))
17772>>>>>>>>>
17772>>>>>>>>>    Get Window_Handle to hWnd
17773>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
17774>>>>>>>>>    If (hInstance <= 32) Begin
17776>>>>>>>>>        Send vDDE_Error_Handler hInstance
17777>>>>>>>>>    End
17777>>>>>>>>>>
17777>>>>>>>>>End_Procedure
17778>>>>>>>>>
17778>>>>>>>>>Class cShellFileOperations is a Array
17779>>>>>>>>>
17779>>>>>>>>>    Procedure Construct_Object
17781>>>>>>>>>        Forward Send Construct_Object
17783>>>>>>>>>        Property Integer piDeleteFlags        0
17784>>>>>>>>>        Property Integer piCopyFlags          0
17785>>>>>>>>>        Property Integer piMoveFlags          0
17786>>>>>>>>>        Property Integer piRenameFlags        0
17787>>>>>>>>>
17787>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
17788>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
17789>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
17790>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
17791>>>>>>>>>    End_Procedure
17792>>>>>>>>>
17792>>>>>>>>>    // This function uses the shell API to perform a file operation on the
17792>>>>>>>>>    // files supplied.
17792>>>>>>>>>    //
17792>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
17794>>>>>>>>>        Integer  iRetVal
17794>>>>>>>>>        Integer  iUserAbort
17794>>>>>>>>>        WString  wsSource wsDestination
17794>>>>>>>>>        tvShFileOpStruct FOS
17794>>>>>>>>>        tvShFileOpStruct FOS
17794>>>>>>>>>
17794>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
17795>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
17796>>>>>>>>>
17796>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
17798>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
17799>>>>>>>>>        End
17799>>>>>>>>>>
17799>>>>>>>>>
17799>>>>>>>>>        Move eOperation            to FOS.wFunc
17800>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
17801>>>>>>>>>        Move iFlags                to FOS.fFlags
17802>>>>>>>>>
17802>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
17803>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
17804>>>>>>>>>        If (iUserAbort <> 0) Begin
17806>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
17807>>>>>>>>>        End
17807>>>>>>>>>>
17807>>>>>>>>>        Function_Return (iRetVal)
17808>>>>>>>>>    End_Function
17809>>>>>>>>>
17809>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
17811>>>>>>>>>        Integer  iRetVal
17811>>>>>>>>>        Integer  iFlags
17811>>>>>>>>>
17811>>>>>>>>>        Get piDeleteFlags to iFlags
17812>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
17813>>>>>>>>>        Function_Return iRetVal
17814>>>>>>>>>    End_Function
17815>>>>>>>>>
17815>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
17817>>>>>>>>>        Integer  iRetVal
17817>>>>>>>>>        Integer  iFlags
17817>>>>>>>>>
17817>>>>>>>>>        Get piCopyFlags to iFlags
17818>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
17819>>>>>>>>>        Function_Return iRetVal
17820>>>>>>>>>    End_Function
17821>>>>>>>>>
17821>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
17823>>>>>>>>>        Integer  iRetVal
17823>>>>>>>>>        Integer  iFlags
17823>>>>>>>>>
17823>>>>>>>>>        Get piMoveFlags to iFlags
17824>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
17825>>>>>>>>>        Function_Return iRetVal
17826>>>>>>>>>    End_Function
17827>>>>>>>>>
17827>>>>>>>>>    // Rename a file or folder
17827>>>>>>>>>    // Returns a nonzero value if the operation failed.
17827>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
17829>>>>>>>>>        Integer  iRetVal
17829>>>>>>>>>        Integer  iFlags
17829>>>>>>>>>
17829>>>>>>>>>        Get piRenameFlags to iFlags
17830>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
17831>>>>>>>>>        Function_Return iRetVal
17832>>>>>>>>>    End_Function
17833>>>>>>>>>
17833>>>>>>>>>
17833>>>>>>>>>    //Example:
17833>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
17833>>>>>>>>>    //                                          mode.
17833>>>>>>>>>
17833>>>>>>>>>End_Class
17834>>>>>>>>>
17834>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
17836>>>>>>>>>End_Object
17837>>>>>>>>>
17837>>>>>>>>>// Restore to the old way of working with the shell file operations.
17837>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
17837>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
17837>>>>>>>>>Procedure vWin32fhCompatibilityMode
17839>>>>>>>>>    Integer hoSFO
17839>>>>>>>>>    Integer iFlags
17839>>>>>>>>>
17839>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
17840>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
17841>>>>>>>>>
17841>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
17842>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
17843>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
17844>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
17845>>>>>>>>>End_Procedure
17846>>>>>>>>>
17846>>>>>>>>>// Delete a file or folder
17846>>>>>>>>>// Returns a nonzero value if the operation failed.
17846>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
17848>>>>>>>>>    Integer  iRetVal
17848>>>>>>>>>
17848>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
17849>>>>>>>>>    Function_Return iRetVal
17850>>>>>>>>>End_Function
17851>>>>>>>>>
17851>>>>>>>>>// Copy a file or folder
17851>>>>>>>>>// Returns a nonzero value if the operation failed.
17851>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
17853>>>>>>>>>    Integer  iRetVal
17853>>>>>>>>>
17853>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17854>>>>>>>>>    Function_Return iRetVal
17855>>>>>>>>>End_Function
17856>>>>>>>>>
17856>>>>>>>>>// Move a file or folder
17856>>>>>>>>>// Returns a nonzero value if the operation failed.
17856>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
17858>>>>>>>>>    Integer  iRetVal
17858>>>>>>>>>
17858>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17859>>>>>>>>>    Function_Return iRetVal
17860>>>>>>>>>End_Function
17861>>>>>>>>>
17861>>>>>>>>>// Rename a file or folder
17861>>>>>>>>>// Returns a nonzero value if the operation failed.
17861>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
17863>>>>>>>>>    Integer  iRetVal
17863>>>>>>>>>
17863>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
17864>>>>>>>>>    Function_Return iRetVal
17865>>>>>>>>>End_Function
17866>>>>>>>>>
17866>>>>>>>>>Function vGetWindowsDirectory Returns String
17868>>>>>>>>>    WString wDirectory
17868>>>>>>>>>    Integer iRetVal
17868>>>>>>>>>
17868>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
17869>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
17870>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
17872>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
17873>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
17874>>>>>>>>>    End
17874>>>>>>>>>>
17874>>>>>>>>>    Function_Return (CString(wDirectory))
17875>>>>>>>>>End_Function
17876>>>>>>>>>
17876>>>>>>>>>Function vGetTempPath Returns String
17878>>>>>>>>>    Integer iRetVal
17878>>>>>>>>>    WString wTempPath
17878>>>>>>>>>
17878>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
17879>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
17880>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
17882>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
17883>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
17884>>>>>>>>>    End
17884>>>>>>>>>>
17884>>>>>>>>>    Function_Return (CString(wTempPath))
17885>>>>>>>>>End_Function
17886>>>>>>>>>
17886>>>>>>>>>// Courtesy of Marco Kuipers
17886>>>>>>>>>Function vMakeTempFile Returns String
17888>>>>>>>>>    Integer iRetval
17888>>>>>>>>>    String  sTempPath
17888>>>>>>>>>    String  sTempFileName
17888>>>>>>>>>    String  sPrefixString
17888>>>>>>>>>    WString wsTempFileName
17888>>>>>>>>>
17888>>>>>>>>>    Get vGetTempPath to sTempPath
17889>>>>>>>>>    If (sTempPath = "") Begin
17891>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
17892>>>>>>>>>        If (sTempPath<>"") Begin
17894>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
17895>>>>>>>>>        End
17895>>>>>>>>>>
17895>>>>>>>>>    End
17895>>>>>>>>>>
17895>>>>>>>>>
17895>>>>>>>>>    If (sTempPath = "") Begin
17897>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
17897>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
17897>>>>>>>>>        Get_Current_Directory to sTempPath
17898>>>>>>>>>    End
17898>>>>>>>>>>
17898>>>>>>>>>
17898>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
17899>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
17901>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
17902>>>>>>>>>>
17902>>>>>>>>>    End
17902>>>>>>>>>>
17902>>>>>>>>>
17902>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
17903>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
17904>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
17905>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
17907>>>>>>>>>    //Get ShowLastError to iRetval
17907>>>>>>>>>        Move "" to sTempFileName
17908>>>>>>>>>    End
17908>>>>>>>>>>
17908>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
17909>>>>>>>>>    Function_Return sTempFileName
17910>>>>>>>>>End_Function
17911>>>>>>>>>
17911>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
17911>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
17911>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
17911>>>>>>>>>// does not take care of that.
17911>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
17913>>>>>>>>>    Integer iRetVal
17913>>>>>>>>>    String  sTempFileName
17913>>>>>>>>>    WString wTempFileName
17913>>>>>>>>>
17913>>>>>>>>>    Move (sPath+Character(0))   to sPath
17914>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
17915>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
17916>>>>>>>>>
17916>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
17917>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
17918>>>>>>>>>    Function_Return sTempFileName
17919>>>>>>>>>End_Function
17920>>>>>>>>>
17920>>>>>>>>>//
17920>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
17920>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
17920>>>>>>>>>//
17920>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
17922>>>>>>>>>    Integer iVoid
17922>>>>>>>>>    Handle  hWnd
17922>>>>>>>>>    String  sFolder
17922>>>>>>>>>    WString wFolder
17922>>>>>>>>>
17922>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
17923>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
17924>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
17925>>>>>>>>>    Move (CString(wFolder)) to sFolder
17926>>>>>>>>>    Function_Return sFolder
17927>>>>>>>>>End_Function
17928>>>>>>>>>
17928>>>>>>>>>// Courtesy Of Vincent Oorsprong
17928>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
17930>>>>>>>>>    String  sFileDateTime
17930>>>>>>>>>    WString wFormattedTime wFormattedDate
17930>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
17930>>>>>>>>>    tvFileTime   FileTime
17930>>>>>>>>>    tvFileTime   FileTime
17930>>>>>>>>>    tvSystemTime SystemTime
17930>>>>>>>>>    tvSystemTime SystemTime
17930>>>>>>>>>
17930>>>>>>>>>    Move "" to sFileDateTime
17931>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
17932>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
17933>>>>>>>>>
17933>>>>>>>>>    Move 0 to SystemTime.wYear
17934>>>>>>>>>
17934>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
17935>>>>>>>>>    If (iSuccess = 1) Begin
17937>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
17938>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
17939>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
17940>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
17941>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
17942>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
17943>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
17944>>>>>>>>>    End
17944>>>>>>>>>>
17944>>>>>>>>>    Function_Return sFileDateTime
17945>>>>>>>>>End_Function
17946>>>>>>>>>
17946>>>>>>>>>// **WvA:
17946>>>>>>>>>// A windows replacement for the standard function FileExists.
17946>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
17946>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
17946>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
17946>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
17946>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
17948>>>>>>>>>    String  sDirSep
17948>>>>>>>>>    Handle  hFindFile
17948>>>>>>>>>    Integer iVoid
17948>>>>>>>>>    tvWin32FindData FindData
17948>>>>>>>>>    tvWin32FindData FindData
17948>>>>>>>>>
17948>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
17949>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
17950>>>>>>>>>
17950>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
17952>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
17952>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
17953>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
17957>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
17958>>>>>>>>>        Loop
17959>>>>>>>>>>
17959>>>>>>>>>
17959>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17960>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
17961>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
17962>>>>>>>>>    End
17962>>>>>>>>>>
17962>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
17963>>>>>>>>>End_Function
17964>>>>>>>>>
17964>>>>>>>>>
17964>>>>>>>>>//
17964>>>>>>>>>// Returns the amount of files in the folder (if it exists)
17964>>>>>>>>>// Returns -1 if folder doesn't exist.
17964>>>>>>>>>// The files "." and ".." are not counted.
17964>>>>>>>>>//
17964>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
17966>>>>>>>>>    Boolean bFound
17966>>>>>>>>>    Handle  hFindFile
17966>>>>>>>>>    Integer iCount  iVoid
17966>>>>>>>>>    Integer iSuccess
17966>>>>>>>>>    String  sFileName
17966>>>>>>>>>    tvWin32FindData FindData
17966>>>>>>>>>    tvWin32FindData FindData
17966>>>>>>>>>
17966>>>>>>>>>    Move -1 to iCount
17967>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
17968>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
17969>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
17970>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
17971>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
17972>>>>>>>>>    If (bFound) Begin
17974>>>>>>>>>        Move 0 to iCount
17975>>>>>>>>>    End
17975>>>>>>>>>>
17975>>>>>>>>>    While (bFound)
17979>>>>>>>>>        Increment iCount
17980>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
17981>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
17983>>>>>>>>>            Decrement iCount
17984>>>>>>>>>        End
17984>>>>>>>>>>
17984>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
17985>>>>>>>>>        Move (iSuccess<>0) to bFound
17986>>>>>>>>>    Loop
17987>>>>>>>>>>
17987>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
17988>>>>>>>>>    Function_Return iCount
17989>>>>>>>>>End_Function
17990>>>>>>>>>
17990>>>>>>>>>// Create the folder, including intermediate directories.
17990>>>>>>>>>// Don't panic if the folder already exists.
17990>>>>>>>>>// Michael Mullan June 2009.
17990>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
17992>>>>>>>>>    String  sFolder
17992>>>>>>>>>    Integer iRetval iFolderCreated
17992>>>>>>>>>    tvSecurity_attributes SA
17992>>>>>>>>>    tvSecurity_attributes SA
17992>>>>>>>>>
17992>>>>>>>>>    Move 0 to iFolderCreated
17993>>>>>>>>>
17993>>>>>>>>>    // null MAX_PATH chars into var (make space)
17993>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
17994>>>>>>>>>    If (sNewFolder <> "") Begin
17996>>>>>>>>>
17996>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
17997>>>>>>>>>        Move  0  to SA.lpDescriptor
17998>>>>>>>>>        Move  1  to SA.bInheritHandle
17999>>>>>>>>>
17999>>>>>>>>>        //
17999>>>>>>>>>        Move (sNewFolder+"") to sFolder
18000>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
18001>>>>>>>>>    End
18001>>>>>>>>>>
18001>>>>>>>>>
18001>>>>>>>>>    If (iFolderCreated <> 0) Begin
18003>>>>>>>>>        Move 1 to iRetVal
18004>>>>>>>>>        Case Begin
18004>>>>>>>>>            Case (iFolderCreated = 161)
18006>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
18007>>>>>>>>>>
18007>>>>>>>>>                Case Break
18008>>>>>>>>>            Case (iFolderCreated = 206)
18011>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
18012>>>>>>>>>>
18012>>>>>>>>>                Case Break
18013>>>>>>>>>            Case (iFolderCreated = 3)
18016>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
18017>>>>>>>>>>
18017>>>>>>>>>                Case Break
18018>>>>>>>>>            Case (iFolderCreated = 80)
18021>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
18022>>>>>>>>>                Case Break
18023>>>>>>>>>            Case (iFolderCreated = 183)
18026>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
18027>>>>>>>>>                Case Break
18028>>>>>>>>>            Case (iFolderCreated = 1223)
18031>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
18032>>>>>>>>>>
18032>>>>>>>>>                Case Break
18033>>>>>>>>>            Case Else
18033>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
18034>>>>>>>>>>
18034>>>>>>>>>        Case End
18034>>>>>>>>>    End
18034>>>>>>>>>>
18034>>>>>>>>>    Function_Return iRetVal
18035>>>>>>>>>End_Function
18036>>>>>>>>>
18036>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
18038>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
18038>>>>>>>>>    Integer iFileSize iVoid
18038>>>>>>>>>    Handle  hFindFile
18038>>>>>>>>>    tvWin32FindData FindData
18038>>>>>>>>>    tvWin32FindData FindData
18038>>>>>>>>>
18038>>>>>>>>>    Move (sFileName+"") to sFileName
18039>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
18040>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
18041>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
18043>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
18044>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
18045>>>>>>>>>    End
18045>>>>>>>>>>
18045>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
18046>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
18047>>>>>>>>>
18047>>>>>>>>>    Function_Return iFileSize
18048>>>>>>>>>End_Function
18049>>>>>>>>>
18049>>>>>>>>>//
18049>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
18049>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
18049>>>>>>>>>//
18049>>>>>>>>>//=============================================================================
18049>>>>>>>>>// Verifies that a path is a valid directory.
18049>>>>>>>>>//
18049>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
18049>>>>>>>>>//
18049>>>>>>>>>// Parameters:
18049>>>>>>>>>//      sPath - Address of the path to verify.
18049>>>>>>>>>//=============================================================================
18049>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
18051>>>>>>>>>    Integer iResult
18051>>>>>>>>>    Boolean bRetVal
18051>>>>>>>>>
18051>>>>>>>>>    Move false to bRetVal
18052>>>>>>>>>    Move (sPath - Character (0)) to sPath
18053>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
18054>>>>>>>>>    If (iResult<>0) Begin
18056>>>>>>>>>        Move True to bRetVal
18057>>>>>>>>>    End
18057>>>>>>>>>>
18057>>>>>>>>>
18057>>>>>>>>>    Function_Return bRetVal
18058>>>>>>>>>End_Function
18059>>>>>>>>>
18059>>>>>>>
18059>>>>>>>//
18059>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
18059>>>>>>>// If sStopChar has no occurences in the string an empty string is
18059>>>>>>>// returned.
18059>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
18061>>>>>>>    String  sRetVal
18061>>>>>>>    String  sChar
18061>>>>>>>    Integer iLength
18061>>>>>>>    Integer iPos
18061>>>>>>>    Boolean bStopChar
18061>>>>>>>    Move "" to sRetval
18062>>>>>>>    Move (Length(sFrom)) to iLength
18063>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
18065>>>>>>>        Move iLength   to iPos
18066>>>>>>>        Move (False)   to bStopChar
18067>>>>>>>        While Not bStopChar
18071>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
18072>>>>>>>            Decrement iPos
18073>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
18075>>>>>>>                Move (True) to bStopChar
18076>>>>>>>            End
18076>>>>>>>>
18076>>>>>>>            Else Begin
18077>>>>>>>                Move (sChar+sRetVal) to sRetVal
18078>>>>>>>            End
18078>>>>>>>>
18078>>>>>>>        Loop
18079>>>>>>>>
18079>>>>>>>    End
18079>>>>>>>>
18079>>>>>>>    Function_Return sRetVal
18080>>>>>>>End_Function
18081>>>>>>>
18081>>>>>>>// Pre:  sFileName contains the complete path of the file.
18081>>>>>>>// Post: returns the complete path of the file.
18081>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
18081>>>>>>>Function ParseFolderName Global String sFileName Returns String
18083>>>>>>>    String sFile
18083>>>>>>>    String sFolderName
18083>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
18083>>>>>>>
18083>>>>>>>    Move "" to sFolderName
18084>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
18085>>>>>>>    If sDirSep In sFileName Begin
18087>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
18088>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
18089>>>>>>>    End
18089>>>>>>>>
18089>>>>>>>    Else If ":" In sFileName Begin
18092>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
18093>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
18094>>>>>>>    End
18094>>>>>>>>
18094>>>>>>>    Function_Return sFolderName
18095>>>>>>>End_Function
18096>>>>>>>
18096>>>>>>>// Pre:  sFileName contains the complete path of the file.
18096>>>>>>>// post: The returned filename has it's path removed, but will have a extension
18096>>>>>>>Function ParseFileName Global String sFileName Returns String
18098>>>>>>>    String sFolderName
18098>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
18098>>>>>>>
18098>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
18099>>>>>>>    Get ParseFolderName sFileName to sFolderName
18100>>>>>>>    If (sFolderName <> "") Begin
18102>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
18103>>>>>>>    End
18103>>>>>>>>
18103>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
18104>>>>>>>    Function_Return sFilename
18105>>>>>>>End_Function
18106>>>>>>>
18106>>>>>>>// Pre:  sFileName may contain the complete path of the file.
18106>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
18106>>>>>>>//       return "bak" as the extension and not "gif"
18106>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
18106>>>>>>>//       such as "html" or "java"
18106>>>>>>>Function ParseFileExtension Global String sFileName Returns String
18108>>>>>>>    String  sFileExtension
18108>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
18109>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
18110>>>>>>>    Function_Return sFileExtension
18111>>>>>>>End_Function
18112>>>>>>>
18112>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
18112>>>>>>>
18112>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
18114>>>>>>>    String sMessage
18114>>>>>>>    Case Begin
18114>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
18116>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
18117>>>>>>>            Case Break
18118>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
18121>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
18122>>>>>>>            Case Break
18123>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
18126>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
18127>>>>>>>            Case Break
18128>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
18131>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
18132>>>>>>>            Case Break
18133>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
18136>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
18137>>>>>>>            Case Break
18138>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
18141>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
18142>>>>>>>            Case Break
18143>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
18146>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
18147>>>>>>>            Case Break
18148>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
18151>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
18152>>>>>>>            Case Break
18153>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
18156>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
18157>>>>>>>            Case Break
18158>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
18161>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
18162>>>>>>>            Case Break
18163>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
18166>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
18167>>>>>>>            Case Break
18168>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
18171>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
18172>>>>>>>            Case Break
18173>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
18176>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
18177>>>>>>>            Case Break
18178>>>>>>>        Case Else
18178>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
18179>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
18180>>>>>>>            Case Break
18181>>>>>>>    Case End
18181>>>>>>>    Function_Return sMessage
18182>>>>>>>End_Function
18183>>>>>>>
18183>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
18185>>>>>>>    String sMessage
18185>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
18186>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
18187>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
18188>>>>>>>End_Procedure
18189>>>>>>>
18189>>>>>>>
18189>>>>>>>// This function informs the user that he entered a yet unknown folder and
18189>>>>>>>// asks if he/she wants to create the folder (Yes/No)
18189>>>>>>>// Choice: "Yes" - this creates the folder
18189>>>>>>>//                 if successful, the function returns false
18189>>>>>>>//                 else it will be true.
18189>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
18189>>>>>>>//                 For example: to stop a save
18189>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
18189>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
18189>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
18191>>>>>>>    Integer bIsNotValid
18191>>>>>>>    Integer iUsers_Choice
18191>>>>>>>    String  sMessage
18191>>>>>>>
18191>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
18193>>>>>>>        Move "The folder '" to sMessage
18194>>>>>>>        Append sMessage sFolderName
18195>>>>>>>        Append sMessage "' does not yet exist,\n"
18196>>>>>>>        Append sMessage "Do you want to create it now?"
18197>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
18198>>>>>>>        Case Begin
18198>>>>>>>            Case (iUsers_Choice = MBR_Yes)
18200>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
18201>>>>>>>                If bIsNotValid Begin
18203>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
18204>>>>>>>                    Append sMessage sFolderName "'.\n\n"
18206>>>>>>>                    Send Info_Box sMessage "Info"
18207>>>>>>>                End
18207>>>>>>>>
18207>>>>>>>                Case Break
18208>>>>>>>            Case (iUsers_Choice = MBR_No)
18211>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
18212>>>>>>>                Case Break
18213>>>>>>>        Case End
18213>>>>>>>    End
18213>>>>>>>>
18213>>>>>>>    Function_Return bIsNotValid
18214>>>>>>>End_Function
18215>>>>>>>
18215>>>>>>>// **WvA
18215>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
18215>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
18215>>>>>>>// The folder may contain a drive letter or UNC encoding.
18215>>>>>>>Function vFolderFormat Global String sFolderName Returns String
18217>>>>>>>    String sDirSep
18217>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
18218>>>>>>>    Move (Trim(sFolderName)) to sFolderName
18219>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
18221>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
18222>>>>>>>    End
18222>>>>>>>>
18222>>>>>>>    Function_Return sFolderName
18223>>>>>>>End_Function
18224>>>>>>>
18224>>>>>>>//
18224>>>>>>>// Gets the parent path of the currently supplied path
18224>>>>>>>// Returns "" when we are at the root folder.
18224>>>>>>>//
18224>>>>>>>Function vParentPath Global String sPath Returns String
18226>>>>>>>    String sStrip sDirSep
18226>>>>>>>
18226>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
18227>>>>>>>    Move (Trim(sPath)) to sPath
18228>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
18230>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
18231>>>>>>>    End
18231>>>>>>>>
18231>>>>>>>    If (Pos(sDirSep, sPath)) Begin
18233>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
18234>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
18235>>>>>>>    End
18235>>>>>>>>
18235>>>>>>>    Else Begin
18236>>>>>>>        Move "" to sPath
18237>>>>>>>    End
18237>>>>>>>>
18237>>>>>>>    Function_Return sPath
18238>>>>>>>End_Function
18239>>>>>Use DUFLanguageConstants.inc
18239>>>>>
18239>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
18239>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
18239>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
18239>>>>>
18239>>>>>Struct tDUFIntFile
18239>>>>>    Integer iID
18239>>>>>    String sIntFileName
18239>>>>>    String sIntLineText
18239>>>>>End_Struct
18239>>>>>
18239>>>>>Struct tDbVersionInfo
18239>>>>>    Number nVersionNumber
18239>>>>>    Handle hObject
18239>>>>>End_Struct
18239>>>>>
18239>>>>>Struct tDbUpdateError
18239>>>>>    Number nUpdateVersion
18239>>>>>    Integer iError
18239>>>>>    String  sOrgErrorText
18239>>>>>    String  sErrorText
18239>>>>>    Integer iErrorLine
18239>>>>>    Boolean bError  
18239>>>>>    Handle  hTable 
18239>>>>>    String  sTableRootName
18239>>>>>    Integer iField
18239>>>>>    Boolean bShortFormat
18239>>>>>End_Struct
18239>>>>>
18239>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
18239>>>>>//  DF_FILE_IS_MASTER if master
18239>>>>>//  DF_FILE_IS_ALIAS if alias
18239>>>>>Struct tDbUpdateHandlerMasterAlias
18239>>>>>    Handle hTable
18239>>>>>    Integer iMode
18239>>>>>End_Struct
18239>>>>>
18239>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
18239>>>>>Enumeration_List
18239>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
18239>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
18239>>>>>End_Enumeration_List
18239>>>>>
18239>>>>>    Define DATAFLEX_ID for "DATAFLEX"
18239>>>>>
18239>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
18239>>>>>// communicate with the object from anywhere in a program.
18239>>>>>    Global_Variable Handle ghoDbUpdateHandler
18239>>>>>    Move 0 to ghoDbUpdateHandler
18240>>>>>
18240>>>>>// NOTE: If the DbVersion table should _not_ be used and you
18240>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
18240>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
18240>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
18240>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
18240>>>>>//    Declare_Datafile DbVersion
18240>>>>>//#ENDIF
18240>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
18240>>>>>//****************************************************************************
18240>>>>>// $Module type: Class
18240>>>>>// $Module name: cDbUpdateLogFile
18240>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18240>>>>>// Web-site    : http://www.rdctools.com
18240>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
18240>>>>>//
18240>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
18240>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
18240>>>>>//               that this class is to change; each developer can decide if the errors instead
18240>>>>>//               should be saved to a database table, or something entirely different.
18240>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
18240>>>>>//
18240>>>>>// $Rev History:
18240>>>>>//    2016-10-05  Module header created
18240>>>>>//****************************************************************************
18240>>>>>Use UI
18240>>>>>Use vWin32fh.pkg
18240>>>>>
18240>>>>>
18240>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
18240>>>>>
18240>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
18240>>>>>
18240>>>>>Class cDbUpdateLogFile is a cObject
18241>>>>>
18241>>>>>    Procedure Construct_Object
18243>>>>>        Forward Send Construct_Object
18245>>>>>
18245>>>>>        // Error handling:
18245>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
18246>>>>>        Property Integer piChannel -1
18247>>>>>
18247>>>>>        // This property is set by the cDbUpdateHandler object,
18247>>>>>        // when the update process starts.
18247>>>>>        Property DateTime pdtUpdateStart
18248>>>>>
18248>>>>>        // Gets set to False if the log contains data
18248>>>>>        Property Boolean pbEmptyLogFile True
18249>>>>>
18249>>>>>        // Gets set to True after the error log header text
18249>>>>>        // has been written.
18249>>>>>        Property Boolean pbHeaderWritten False
18250>>>>>
18250>>>>>        // If all activities should be logged- not just errors.
18250>>>>>        Property Boolean pbVerboseState False
18251>>>>>
18251>>>>>        // File name for the error log where all errors
18251>>>>>        // after a run is written to (appended).
18251>>>>>        // It is saved in the Data folder.
18251>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
18252>>>>>        // If this property is set to "" in object code, the
18252>>>>>        // "shell" command parameter will be used to let Windows decide
18252>>>>>        // with which program to open the logfile.
18252>>>>>        Property String psEditorProgram ""
18253>>>>>
18253>>>>>        Property Boolean pbUseDataTableLog False
18254>>>>>
18254>>>>>        // If true an error will be written to file immediately when
18254>>>>>        // it occurs. This can be handy if a large update generates a lots
18254>>>>>        // of errors and the application crasches before finished, thus
18254>>>>>        // the errors will not be written.
18254>>>>>        Property Boolean pbQuickWrite True
18255>>>>>    End_Procedure
18256>>>>>
18256>>>>>    Procedure End_Construct_Object
18258>>>>>        Forward Send End_Construct_Object
18260>>>>>
18260>>>>>    End_Procedure
18261>>>>>
18261>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
18263>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
18263>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
18265>>>>>        Boolean bShortFormat
18265>>>>>        Integer iSize
18265>>>>>        Handle hCurrentTable
18265>>>>>        Integer iCurrentField           
18265>>>>>        String sOrgErrorText sTableRootName
18265>>>>>        
18265>>>>>        Move False to bShortFormat
18266>>>>>        If (num_arguments > 5) Begin
18268>>>>>            Move bShortFormatIn to bShortFormat
18269>>>>>        End
18269>>>>>>
18269>>>>>        // Only do once.
18269>>>>>        If (pbHeaderWritten(Self) = False) Begin
18271>>>>>            Send WriteHeaderData
18272>>>>>            Set pbHeaderWritten to True
18273>>>>>        End
18273>>>>>>
18273>>>>>
18273>>>>>        Get Private.phCurrentTable to hCurrentTable  
18274>>>>>        Get Private.piCurrentField to iCurrentField  
18275>>>>>        If (iError > 0) Begin
18277>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
18280>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
18281>>>>>        End
18281>>>>>>
18281>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
18282>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
18283>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
18284>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
18285>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
18286>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
18287>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
18288>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
18289>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
18290>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
18291>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
18292>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
18293>>>>>
18293>>>>>        If (bError = False) Begin
18295>>>>>            Move False to DbUpdateErrorArray[iSize].bError
18296>>>>>        End
18296>>>>>>
18296>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
18297>>>>>
18297>>>>>        If (pbUseDataTableLog(Self) = True) Begin
18299>>>>>            If (pbQuickWrite(Self) = True) Begin
18301>>>>>                Send OnWriteRow_DataTable
18302>>>>>                // If we are writing error for error flush the
18302>>>>>                // error array when latest error has been written.
18302>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
18303>>>>>            End
18303>>>>>>
18303>>>>>            Procedure_Return
18304>>>>>        End
18304>>>>>>
18304>>>>>        Else Begin
18305>>>>>            If (pbQuickWrite(Self) = True) Begin
18307>>>>>                Send WriteErrorLog
18308>>>>>                // Flush the error log array
18308>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
18309>>>>>            End
18309>>>>>>
18309>>>>>        End
18309>>>>>>
18309>>>>>    End_Procedure   
18310>>>>>    
18310>>>>>    Function FetchErrorDescription Integer iError Returns String
18312>>>>>        String sErrorText         
18312>>>>>        Move "" to sErrorText
18313>>>>>        If (iError > 0) Begin
18315>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
18316>>>>>        End
18316>>>>>>
18316>>>>>        Function_Return sErrorText
18317>>>>>    End_Function
18318>>>>>
18318>>>>>    // Hook procedure for writing header text prior starting the update work to
18318>>>>>    // a database table. This does nothing by default.
18318>>>>>    // Don't forget to Open your "error log table" first (!) as all
18318>>>>>    // tables have been closed at this stage. Put anything
18318>>>>>    // you want to indicate that the update process is just started.
18318>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
18320>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
18322>>>>>    End_Procedure
18323>>>>>
18323>>>>>    Procedure OnWriteRow_DataTable
18325>>>>>        tDbUpdateError[] DbUpdateErrorArray
18325>>>>>        tDbUpdateError[] DbUpdateErrorArray
18326>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
18327>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
18329>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
18331>>>>>        End
18331>>>>>>
18331>>>>>    End_Procedure
18332>>>>>
18332>>>>>    Function psLogTextFileWithPath Returns String
18334>>>>>        String sPath sFileName sFullFileName
18334>>>>>        
18334>>>>>        Get psDataPathFirstPart to sPath
18335>>>>>        Get psLogTextFile to sFileName
18336>>>>>        Move (sPath + sFileName) to sFullFileName
18337>>>>>        Function_Return sFullFileName
18338>>>>>    End_Function                     
18339>>>>>    
18339>>>>>    Procedure WriteHeaderData
18341>>>>>        String sFileName
18341>>>>>        Integer iCh iSize
18341>>>>>        Boolean bQuickWrite
18341>>>>>        DateTime dtUpdateStart
18341>>>>>
18341>>>>>        Move (CurrentDateTime()) to dtUpdateStart
18342>>>>>        If (pbUseDataTableLog(Self) = True) Begin
18344>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
18345>>>>>            Procedure_Return
18346>>>>>        End
18346>>>>>>
18346>>>>>
18346>>>>>        Get piChannel to iCh
18347>>>>>        If (iCh < 0) Begin
18349>>>>>            Get Seq_New_Channel to iCh
18350>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
18352>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
18353>>>>>>
18353>>>>>                Procedure_Return
18354>>>>>            End
18354>>>>>>
18354>>>>>            Set piChannel to iCh
18355>>>>>        End
18355>>>>>>
18355>>>>>
18355>>>>>        Get psLogTextFileWithPath to sFileName
18356>>>>>        Get vWin32_APIFileSize sFileName to iSize
18357>>>>>        Get pbQuickWrite to bQuickWrite
18358>>>>>        
18358>>>>>        If (bQuickWrite = True) Begin
18360>>>>>            Append_Output channel iCh sFileName
18362>>>>>                If (bQuickWrite = True) Begin
18364>>>>>                    If (iSize = 0) Begin
18366>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
18369>>>>>                        Set pbEmptyLogFile to False
18370>>>>>                    End
18370>>>>>>
18370>>>>>                    Writeln channel iCh
18372>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
18375>>>>>                End
18375>>>>>>
18375>>>>>            Close_Output channel iCh
18377>>>>>        End
18377>>>>>>
18377>>>>>    End_Procedure
18378>>>>>
18378>>>>>    // Returns the first datapath found in the psDataPath property.
18378>>>>>    // The returned path always ends with a "\"
18378>>>>>    Function psDataPathFirstPart Returns String
18380>>>>>        String sDataPath
18380>>>>>        Integer iCount
18380>>>>>
18380>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
18381>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
18382>>>>>        If (iCount > 1) Begin
18384>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
18385>>>>>        End
18385>>>>>>
18385>>>>>        If (sDataPath <> "") Begin
18387>>>>>            Get vFolderFormat sDataPath to sDataPath
18388>>>>>        End
18388>>>>>>
18388>>>>>
18388>>>>>        Function_Return sDataPath
18389>>>>>    End_Function
18390>>>>>
18390>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
18390>>>>>    Procedure WriteErrorLog
18392>>>>>        tDbUpdateError[] aDbUpdateErrorArray
18392>>>>>        tDbUpdateError[] aDbUpdateErrorArray
18393>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
18393>>>>>        Integer iCount iSize iCh iError iErrorLine iField
18393>>>>>        Boolean bUseDataTable bQuickWrite
18393>>>>>        DateTime dtUpdateStart dtUpdateEnd
18393>>>>>        TimeSpan tsElapsed
18393>>>>>        Number nVersion                                  
18393>>>>>        Handle hTable
18393>>>>>
18393>>>>>        If (pbHeaderWritten(Self) = False) Begin
18395>>>>>            Send WriteHeaderData
18396>>>>>            Set pbHeaderWritten to True
18397>>>>>        End
18397>>>>>>
18397>>>>>
18397>>>>>        Get pbUseDataTableLog to bUseDataTable
18398>>>>>        If (bUseDataTable = True) Begin
18400>>>>>            Send OnWriteRow_DataTable
18401>>>>>            Procedure_Return
18402>>>>>        End
18402>>>>>>
18402>>>>>
18402>>>>>        Get piChannel to iCh
18403>>>>>        If (iCh < 0) Begin
18405>>>>>            Get Seq_New_Channel to iCh
18406>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
18408>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
18409>>>>>>
18409>>>>>                Procedure_Return
18410>>>>>            End
18410>>>>>>
18410>>>>>            Set piChannel to iCh
18411>>>>>        End
18411>>>>>>
18411>>>>>
18411>>>>>        Get psLogTextFileWithPath to sFileName
18412>>>>>
18412>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
18413>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
18414>>>>>        Decrement iSize
18415>>>>>
18415>>>>>        Get pdtUpdateStart to dtUpdateStart
18416>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
18418>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
18419>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
18420>>>>>        End
18420>>>>>>
18420>>>>>        Get pbQuickWrite to bQuickWrite
18421>>>>>
18421>>>>>        Append_Output channel iCh sFileName
18423>>>>>        If (bQuickWrite = True and iSize < 0) Begin
18425>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
18428>>>>>        End
18428>>>>>>
18428>>>>>        Else If (bQuickWrite = False) Begin
18431>>>>>            Writeln channel iCh
18433>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
18436>>>>>        End   
18436>>>>>>
18436>>>>>        If (iSize >= 0) Begin
18438>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
18440>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
18443>>>>>            End
18443>>>>>>
18443>>>>>        End
18443>>>>>>
18443>>>>>
18443>>>>>        For iCount from 0 to iSize  
18449>>>>>>
18449>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
18450>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
18451>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
18452>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
18453>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
18454>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
18455>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
18456>>>>>            
18456>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
18457>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
18459>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
18460>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
18461>>>>>            End
18461>>>>>>
18461>>>>>            Else Begin
18462>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
18463>>>>>                Move (sVersion + "   " + sErrorText) to sText
18464>>>>>            End
18464>>>>>>
18464>>>>>            Writeln channel iCh sText
18467>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
18469>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
18470>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
18471>>>>>                Writeln channel iCh sOrgErrorText
18474>>>>>            End
18474>>>>>>
18474>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
18476>>>>>                Writeln channel iCh
18478>>>>>            End
18478>>>>>>
18478>>>>>        Loop
18479>>>>>>
18479>>>>>        Close_Output channel iCh
18481>>>>>
18481>>>>>        Send Seq_Release_Channel iCh
18482>>>>>        Set piChannel to -1
18483>>>>>
18483>>>>>    End_Procedure
18484>>>>>
18484>>>>>    // The character to pad is optional. If nothing, spaces are used.
18484>>>>>    // Example:
18484>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
18484>>>>>    //  or:
18484>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
18484>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
18484>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
18486>>>>>        String sChar
18486>>>>>
18486>>>>>        If (Num_Arguments >= 3) Begin
18488>>>>>            Move sOptChar to sChar
18489>>>>>        End
18489>>>>>>
18489>>>>>        Else Begin
18490>>>>>            Move " " to sChar
18491>>>>>        End
18491>>>>>>
18491>>>>>
18491>>>>>        While (Length(sString) < iLength)
18495>>>>>            Move (sChar + sString) to sString
18496>>>>>        Loop
18497>>>>>>
18497>>>>>
18497>>>>>        Function_Return sString
18498>>>>>    End_Function
18499>>>>>
18499>>>>>    Procedure ShowErrorLog
18501>>>>>        String sPath sFileName sEditorProgram
18501>>>>>        Boolean bExists
18501>>>>>
18501>>>>>        Get psLogTextFileWithPath to sFileName
18502>>>>>        Get vFilePathExists sFileName to bExists
18503>>>>>        If (bExists = True) Begin
18505>>>>>            Get psEditorProgram to sEditorProgram
18506>>>>>            If (sEditorProgram <> "") Begin
18508>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
18509>>>>>            End
18509>>>>>>
18509>>>>>            Else Begin
18510>>>>>                Runprogram Shell Background sFileName
18511>>>>>            End
18511>>>>>>
18511>>>>>        End
18511>>>>>>
18511>>>>>        Else Begin
18512>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
18513>>>>>        End
18513>>>>>>
18513>>>>>    End_Procedure
18514>>>>>
18514>>>>>End_Class
18515>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
18515>>>>>//****************************************************************************
18515>>>>>// $Module type: Class
18515>>>>>// $Module name: cDbUpdateVersion
18515>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18515>>>>>// Web-site    : http://www.rdctools.com
18515>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
18515>>>>>//
18515>>>>>// Description : Child class to cDbUpdateHandler.
18515>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
18515>>>>>//               Set the pnVersionNumber to a version number.
18515>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
18515>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
18515>>>>>//               Place your code in the "OnUpdate" event that alters the database.
18515>>>>>//
18515>>>>>// $Rev History:
18515>>>>>//    2016-09-27  Module header created
18515>>>>>//****************************************************************************
18515>>>>>Use UI
18515>>>>>Use DUFLanguageConstants.inc
18515>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
18515>>>>>>>//****************************************************************************
18515>>>>>>>// $Module type: Class
18515>>>>>>>// $Module name: cDbUpdateFunctionLibrary
18515>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18515>>>>>>>// Web-site    : http://www.rdctools.com
18515>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
18515>>>>>>>//
18515>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
18515>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
18515>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
18515>>>>>>>//               with the help of Sql-scripts.
18515>>>>>>>//
18515>>>>>>>// $Rev History:
18515>>>>>>>//    2014-09-05  Module header created
18515>>>>>>>//
18515>>>>>>>//****************************************************************************
18515>>>>>>>//
18515>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
18515>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
18515>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
18515>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
18515>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
18515>>>>>>>//
18515>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
18515>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
18515>>>>>>>
18515>>>>>>>
18515>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
18515>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
18515>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
18515>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
18515>>>>>>>//
18515>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
18515>>>>>>>>>//****************************************************************************
18515>>>>>>>>>// $Module type: Class
18515>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
18515>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
18515>>>>>>>>>// Web-site    : http://www.rdctools.com
18515>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
18515>>>>>>>>>//
18515>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
18515>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
18515>>>>>>>>>//
18515>>>>>>>>>// $Rev History:
18515>>>>>>>>>//    2023-11-06  Module header created
18515>>>>>>>>>//
18515>>>>>>>>>//****************************************************************************
18515>>>>>>>>>Use cApplication.pkg
18515>>>>>>>>>Use seq_chnl.pkg
18515>>>>>>>>>Use GlobalFunctionsProcedures.pkg
18515>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
18515>>>>>>>>>Use Dfcursor.pkg
Including file: Dfcursor.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfcursor.pkg)
18515>>>>>>>>>>>//  create a desktop object named Cursor_control that understands
18515>>>>>>>>>>>//   Send Cursor_Wait to (cursor_Control(self))
18515>>>>>>>>>>>//            creates hourclass cursor
18515>>>>>>>>>>>//   Send Cursor_ready to (cursor_Control(self))
18515>>>>>>>>>>>//            restores regular cursor
18515>>>>>>>>>>>//
18515>>>>>>>>>>>Use Cursor.pkg
Including file: Cursor.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Cursor.pkg)
18515>>>>>>>>>>>>>Use Windows.pkg
18515>>>>>>>>>>>>>Use WinUser.pkg
18515>>>>>>>>>>>>>
18515>>>>>>>>>>>>>// Standard Cursor IDs
18515>>>>>>>>>>>>>
18515>>>>>>>>>>>>>
18515>>>>>>>>>>>>>
18515>>>>>>>>>>>>>
18515>>>>>>>>>>>>>
18515>>>>>>>>>>>>>Class CursorShape is a DFBaseToolPanel //BasicPanel
18516>>>>>>>>>>>>>    
18516>>>>>>>>>>>>>    Procedure Construct_Object
18518>>>>>>>>>>>>>        Forward Send Construct_Object
18520>>>>>>>>>>>>>        
18520>>>>>>>>>>>>>        Property Handle ClassCursorHandle 0
18521>>>>>>>>>>>>>        Set Visible_State to False
18522>>>>>>>>>>>>>        Set Size to 1 1
18523>>>>>>>>>>>>>    End_Procedure
18524>>>>>>>>>>>>>    
18524>>>>>>>>>>>>>    Procedure Set Cursor Integer CursorType
18526>>>>>>>>>>>>>        Handle CursorID hWnd
18526>>>>>>>>>>>>>        Longptr retval lpCursorType
18526>>>>>>>>>>>>>        Get Window_Handle to hWnd
18527>>>>>>>>>>>>>        If (CursorType = 0) Begin
18529>>>>>>>>>>>>>            Send Release_Mouse_Capture
18530>>>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, ClassCursorHandle(Self))) to retval
18531>>>>>>>>>>>>>            Set ClassCursorHandle to 0
18532>>>>>>>>>>>>>            Send Page_Object False
18533>>>>>>>>>>>>>        End
18533>>>>>>>>>>>>>>
18533>>>>>>>>>>>>>        Else Begin
18534>>>>>>>>>>>>>            Send Page_Object True
18535>>>>>>>>>>>>>            Get Window_Handle to hWnd
18536>>>>>>>>>>>>>            If (ClassCursorHandle(Self) = 0) ;                Set ClassCursorHandle to (GetClassLongPtr(hWnd, GCL_HCURSOR))
18539>>>>>>>>>>>>>            
18539>>>>>>>>>>>>>            Move CursorType to lpCursorType    // Move to Longptr type to avoid conversion from integer to pointer in the next line
18540>>>>>>>>>>>>>            Move (LoadCursorW(0,lpCursorType)) to CursorID
18541>>>>>>>>>>>>>            
18541>>>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, CursorID )) to retval
18542>>>>>>>>>>>>>            Move (SetCursor(CursorID)) to retval
18543>>>>>>>>>>>>>            Send Set_Mouse_Capture
18544>>>>>>>>>>>>>        End
18544>>>>>>>>>>>>>>
18544>>>>>>>>>>>>>    End_Procedure
18545>>>>>>>>>>>>>    
18545>>>>>>>>>>>>>    Procedure Mouse_Up
18547>>>>>>>>>>>>>        Handle retval
18547>>>>>>>>>>>>>        Send Set_Mouse_Capture
18548>>>>>>>>>>>>>        Move (SetCursor(GetClassLongPtr(Window_Handle(Self), GCL_HCURSOR))) to retval
18549>>>>>>>>>>>>>    End_Procedure
18550>>>>>>>>>>>>>    
18550>>>>>>>>>>>>>    Procedure Cursor_Wait
18552>>>>>>>>>>>>>        Set cursor to IDC_WAIT
18553>>>>>>>>>>>>>    End_Procedure
18554>>>>>>>>>>>>>    
18554>>>>>>>>>>>>>    Procedure Cursor_Ready
18556>>>>>>>>>>>>>        Set cursor to 0
18557>>>>>>>>>>>>>    End_Procedure
18558>>>>>>>>>>>>>    
18558>>>>>>>>>>>>>    
18558>>>>>>>>>>>>>End_Class
18559>>>>>>>>>>>
18559>>>>>>>>>>>Object Cursor_Control is a CursorShape
18561>>>>>>>>>>>End_Object
18562>>>>>>>>>>>
18562>>>>>>>>>Use DUFStatusPanel.pkg
18562>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
18562>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
18562>>>>>>>>>>>//
18562>>>>>>>>>>>// We need to create a mixin class for the library.
18562>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
18562>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
18562>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
18562>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
18562>>>>>>>>>>>//
18562>>>>>>>>>>>Use VdfBase.pkg
18562>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
18562>>>>>>>>>>>>>Use Unicode.Pkg
18562>>>>>>>>>>>>>
18562>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
18563>>>>>>>>>>>>>
18563>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
18564>>>>>>>>>>>>>
18564>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
18565>>>>>>>>>>>>>
18565>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
18566>>>>>>>>>>>>>
18566>>>>>>>>>>>>>
18566>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
18566>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
18568>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
18568>>>>>>>>>>>>>    Integer iRetval iOffset iChar
18568>>>>>>>>>>>>>    String sUUID
18568>>>>>>>>>>>>>    
18568>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
18569>>>>>>>>>>>>>    
18569>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
18570>>>>>>>>>>>>>    
18570>>>>>>>>>>>>>    If (iRetval = 0) Begin
18572>>>>>>>>>>>>>        Move 0 to pUUIDStr
18573>>>>>>>>>>>>>        
18573>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
18574>>>>>>>>>>>>>        If (iRetval = 0) Begin
18576>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
18577>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
18578>>>>>>>>>>>>>            
18578>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
18579>>>>>>>>>>>>>        End
18579>>>>>>>>>>>>>>
18579>>>>>>>>>>>>>    End
18579>>>>>>>>>>>>>>
18579>>>>>>>>>>>>>    
18579>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
18580>>>>>>>>>>>>>    
18580>>>>>>>>>>>>>    Function_Return sUUID
18581>>>>>>>>>>>>>End_Function
18582>>>>>>>>>>>>>
18582>>>>>>>>>>>>>
18582>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
18582>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
18584>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
18584>>>>>>>>>>>>>    Integer iRetval iOffset iChar
18584>>>>>>>>>>>>>    String sUUID
18584>>>>>>>>>>>>>    
18584>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
18585>>>>>>>>>>>>>    
18585>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
18586>>>>>>>>>>>>>    
18586>>>>>>>>>>>>>    If (iRetval = 0) Begin
18588>>>>>>>>>>>>>        Move 0 to pUUIDStr
18589>>>>>>>>>>>>>        
18589>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
18590>>>>>>>>>>>>>        If (iRetval = 0) Begin
18592>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
18593>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
18594>>>>>>>>>>>>>            
18594>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
18595>>>>>>>>>>>>>        End
18595>>>>>>>>>>>>>>
18595>>>>>>>>>>>>>    End
18595>>>>>>>>>>>>>>
18595>>>>>>>>>>>>>    
18595>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
18596>>>>>>>>>>>>>    
18596>>>>>>>>>>>>>    Function_Return sUUID
18597>>>>>>>>>>>>>End_Function
18598>>>>>>>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cli.pkg)
18598>>>>>>>>>>>>>//                                                              
18598>>>>>>>>>>>>>//   CLI specific functionality. There are several connectivity kits     
18598>>>>>>>>>>>>>//   based on  SQL/92 CLI. Those are:                                    
18598>>>>>>>>>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
18598>>>>>>>>>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
18598>>>>>>>>>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
18598>>>>>>>>>>>>>//                                                                       
18598>>>>>>>>>>>>>//   This package defines the common functionality for all CLI based     
18598>>>>>>>>>>>>>//   drivers.                                                            
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
18598>>>>>>>>>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
18598>>>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
18598>>>>>>>>>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
18598>>>>>>>>>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
18598>>>>>>>>>>>>>Define DF_FILE_TABLE_NAME               for 609
18598>>>>>>>>>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
18598>>>>>>>>>>>>>Define DF_FILE_SQL_FILTER               for 611
18598>>>>>>>>>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
18598>>>>>>>>>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
18598>>>>>>>>>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
18598>>>>>>>>>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
18598>>>>>>>>>>>>>Define DF_FILE_DATABASE_ID              for 622
18598>>>>>>>>>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
18598>>>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
18598>>>>>>>>>>>>>Define DF_FILE_BLOCK_SIZE               for 628
18598>>>>>>>>>>>>>Define DF_FILE_JIT_BINDING              for 630
18598>>>>>>>>>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
18598>>>>>>>>>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
18598>>>>>>>>>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
18598>>>>>>>>>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
18598>>>>>>>>>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_FIELD_STORE_TIME              for 702
18598>>>>>>>>>>>>>Define DF_FIELD_TIME                    for 703
18598>>>>>>>>>>>>>Define DF_FIELD_IS_NULL                 for 704
18598>>>>>>>>>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
18598>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
18598>>>>>>>>>>>>>Define DF_FIELD_FETCH_STATE             for 708
18598>>>>>>>>>>>>>Define DF_FIELD_READ_ONLY               for 710
18598>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
18598>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
18598>>>>>>>>>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
18598>>>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN           for 716
18598>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
18598>>>>>>>>>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
18598>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
18598>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
18598>>>>>>>>>>>>>Define DF_FIELD_IS_IDENTITY             for 722
18598>>>>>>>>>>>>>Define DF_FIELD_SQL_COLUMN_NAME         for 723
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_INDEX_NAME                    for 801
18598>>>>>>>>>>>>>Define DF_INDEX_UNIQUE                  for 802
18598>>>>>>>>>>>>>Define DF_INDEX_ON_BACKEND              for 804
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_INDEX_CLUSTERED               for 806
18598>>>>>>>>>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
18598>>>>>>>>>>>>>Define DF_INDEX_SQL_TYPE                for 810
18598>>>>>>>>>>>>>Define DF_INDEX_NUMBER                  for 812
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
18598>>>>>>>>>>>>>Define DF_DATABASE_ID                            for 1002
18598>>>>>>>>>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
18598>>>>>>>>>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
18598>>>>>>>>>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
18598>>>>>>>>>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
18598>>>>>>>>>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
18598>>>>>>>>>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
18598>>>>>>>>>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
18598>>>>>>>>>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
18598>>>>>>>>>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
18598>>>>>>>>>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
18598>>>>>>>>>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
18598>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
18598>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
18598>>>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
18598>>>>>>>>>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
18598>>>>>>>>>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
18598>>>>>>>>>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
18598>>>>>>>>>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
18598>>>>>>>>>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
18598>>>>>>>>>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
18598>>>>>>>>>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
18598>>>>>>>>>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
18598>>>>>>>>>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
18598>>>>>>>>>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
18598>>>>>>>>>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
18598>>>>>>>>>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
18598>>>>>>>>>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
18598>>>>>>>>>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
18598>>>>>>>>>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
18598>>>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
18598>>>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
18598>>>>>>>>>>>>>Define DF_DATABASE_TRIM_VARCHAR_VALUES           for 1084
18598>>>>>>>>>>>>>Define DF_DATABASE_IDENTIFIER_QUOTE              for 1085
18598>>>>>>>>>>>>>Define DF_DATABASE_ODBC_DRIVER_NAME              for 1087
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
18598>>>>>>>>>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
18598>>>>>>>>>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
18598>>>>>>>>>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
18598>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
18598>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
18598>>>>>>>>>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
18598>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
18598>>>>>>>>>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
18598>>>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
18598>>>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
18598>>>>>>>>>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
18598>>>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
18598>>>>>>>>>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
18598>>>>>>>>>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
18598>>>>>>>>>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
18598>>>>>>>>>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
18598>>>>>>>>>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
18598>>>>>>>>>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
18598>>>>>>>>>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
18598>>>>>>>>>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
18598>>>>>>>>>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
18598>>>>>>>>>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
18598>>>>>>>>>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
18598>>>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
18598>>>>>>>>>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
18598>>>>>>>>>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
18598>>>>>>>>>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
18598>>>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
18598>>>>>>>>>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
18598>>>>>>>>>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
18598>>>>>>>>>>>>>Define DF_DRIVER_TRIM_VARCHAR_VALUES             for 1184
18598>>>>>>>>>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_DRIVER_NAME    for 1187 
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
18598>>>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Replacement for logical column number that indicates all columns
18598>>>>>>>>>>>>>Define DF_ALL_COLUMNS for -1
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
18598>>>>>>>>>>>>>Define RIM_NONE            for 0
18598>>>>>>>>>>>>>Define RIM_IDENTITY_COLUMN for 1
18598>>>>>>>>>>>>>Define RIM_DISPENSER_TABLE for 2
18598>>>>>>>>>>>>>Define RIM_EXTERNAL        for 3
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible DF_FIELD_READ_ONLY values
18598>>>>>>>>>>>>>Define RO_NO            for 0
18598>>>>>>>>>>>>>Define RO_IGNORECHANGE  for 1
18598>>>>>>>>>>>>>Define RO_ACCEPTCHANGE  for 2
18598>>>>>>>>>>>>>Define RO_ERRORONCHANGE for 3
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
18598>>>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNICODE     for 11
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible SQL Column type values
18598>>>>>>>>>>>>>//      SQL Server specific types defined in mssqldrv.pkg
18598>>>>>>>>>>>>>//      DB2 specific typesm defined in db2_drv.pkg
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define SQL_UNKNOWN_TYPE   for    0
18598>>>>>>>>>>>>>Define SQL_CHAR           for    1
18598>>>>>>>>>>>>>Define SQL_NUMERIC        for    2
18598>>>>>>>>>>>>>Define SQL_DECIMAL        for    3
18598>>>>>>>>>>>>>Define SQL_INTEGER        for    4
18598>>>>>>>>>>>>>Define SQL_SMALLINT       for    5
18598>>>>>>>>>>>>>Define SQL_FLOAT          for    6
18598>>>>>>>>>>>>>Define SQL_REAL           for    7
18598>>>>>>>>>>>>>Define SQL_DOUBLE         for    8
18598>>>>>>>>>>>>>Define SQL_DATETIME       for    9
18598>>>>>>>>>>>>>Define SQL_VARCHAR        for   12
18598>>>>>>>>>>>>>Define SQL_TYPE_DATE      for   91
18598>>>>>>>>>>>>>Define SQL_TYPE_TIME      for   92
18598>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>Define SQL_DATE           for    9
18598>>>>>>>>>>>>>Define SQL_INTERVAL       for   10
18598>>>>>>>>>>>>>Define SQL_TIME           for   10
18598>>>>>>>>>>>>>Define SQL_TIMESTAMP      for   11
18598>>>>>>>>>>>>>Define SQL_LONGVARCHAR    for  (-1)
18598>>>>>>>>>>>>>Define SQL_BINARY         for  (-2)
18598>>>>>>>>>>>>>Define SQL_VARBINARY      for  (-3)
18598>>>>>>>>>>>>>Define SQL_LONGVARBINARY  for  (-4)
18598>>>>>>>>>>>>>Define SQL_BIGINT         for  (-5)
18598>>>>>>>>>>>>>Define SQL_TINYINT        for  (-6)
18598>>>>>>>>>>>>>Define SQL_BIT            for  (-7)
18598>>>>>>>>>>>>>Define SQL_WCHAR          for  (-8)
18598>>>>>>>>>>>>>Define SQL_WVARCHAR       for  (-9)
18598>>>>>>>>>>>>>Define SQL_WLONGVARCHAR   for (-10)
18598>>>>>>>>>>>>>Define SQL_GUID           for (-11)
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible DF_INDEX_SQL_TYPE values
18598>>>>>>>>>>>>>Define DF_INDEX_CLIENT      for  1
18598>>>>>>>>>>>>>Define DF_INDEX_SERVER      for  2
18598>>>>>>>>>>>>>Define DF_INDEX_SERVER_ONLY for  3
18598>>>>>>>>>>>>>Define DF_INDEX_TEMPORARY   for  4
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
18598>>>>>>>>>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
18598>>>>>>>>>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
18598>>>>>>>>>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Driver level attributes
18598>>>>>>>>>>>>>Define DRVR_TOKEN_BASE                       for 1000
18598>>>>>>>>>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
18598>>>>>>>>>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
18598>>>>>>>>>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
18598>>>>>>>>>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
18598>>>>>>>>>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
18598>>>>>>>>>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
18598>>>>>>>>>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
18598>>>>>>>>>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
18598>>>>>>>>>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
18598>>>>>>>>>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
18598>>>>>>>>>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
18598>>>>>>>>>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
18598>>>>>>>>>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
18598>>>>>>>>>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
18598>>>>>>>>>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
18598>>>>>>>>>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
18598>>>>>>>>>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
18598>>>>>>>>>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
18598>>>>>>>>>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Error Number constants
18598>>>>>>>>>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
18598>>>>>>>>>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
18598>>>>>>>>>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
18598>>>>>>>>>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
18598>>>>>>>>>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
18598>>>>>>>>>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
18598>>>>>>>>>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
18598>>>>>>>>>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
18598>>>>>>>>>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
18598>>>>>>>>>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
18598>>>>>>>>>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
18598>>>>>>>>>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
18598>>>>>>>>>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
18598>>>>>>>>>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
18598>>>>>>>>>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
18598>>>>>>>>>>>>>Define CLIERR_SQL_ERROR                           for 12304
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
18598>>>>>>>>>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
18598>>>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
18598>>>>>>>>>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
18598>>>>>>>>>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
18598>>>>>>>>>>>>>Define CLIERR_FIELDREADONLY                       for 12315
18598>>>>>>>>>>>>>Define CLIERR_DBPROPERROR                         for 12316
18598>>>>>>>>>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
18598>>>>>>>>>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
18598>>>>>>>>>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
18598>>>>>>>>>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
18598>>>>>>>>>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
18598>>>>>>>>>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
18598>>>>>>>>>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
18598>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
18598>>>>>>>>>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
18598>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
18598>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
18598>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
18598>>>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
18598>>>>>>>>>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
18598>>>>>>>>>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
18598>>>>>>>>>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
18598>>>>>>>>>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
18598>>>>>>>>>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
18598>>>>>>>>>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
18598>>>>>>>>>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
18598>>>>>>>>>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
18598>>>>>>>>>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
18598>>>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
18598>>>>>>>>>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
18598>>>>>>>>>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
18598>>>>>>>>>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
18598>>>>>>>>>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
18598>>>>>>>>>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
18598>>>>>>>>>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Call driver Function identifiers
18598>>>>>>>>>>>>>Define CLI_CONSTRAINT             for 10000
18598>>>>>>>>>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
18598>>>>>>>>>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
18598>>>>>>>>>>>>>Define CLI_BROWSECONNECT          for 10003
18598>>>>>>>>>>>>>Define CLI_DATASOURCES            for 10004
18598>>>>>>>>>>>>>Define CLI_CKREVISION             for 10005
18598>>>>>>>>>>>>>Define CLI_INITDATASOURCES        for 10006
18598>>>>>>>>>>>>>Define CLI_ENUMERATE_TABLES       for 10007
18598>>>>>>>>>>>>>Define CLI_TABLENAME              for 10008
18598>>>>>>>>>>>>>Define CLI_TABLESCHEMA            for 10009
18598>>>>>>>>>>>>>Define CLI_TABLETYPE              for 10010
18598>>>>>>>>>>>>>Define CLI_TABLECOMMENT           for 10011
18598>>>>>>>>>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
18598>>>>>>>>>>>>>Define CLI_COLUMNNAME             for 10013
18598>>>>>>>>>>>>>Define CLI_DUMPSTATUS             for 10014
18598>>>>>>>>>>>>>Define CLI_READCONFIGURATION      for 10015
18598>>>>>>>>>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
18598>>>>>>>>>>>>>Define CLI_GETDBATTRIBUTE         for 10017
18598>>>>>>>>>>>>>Define CLI_GETREGNAME             for 10018
18598>>>>>>>>>>>>>Define CLI_GETSERIALNUM           for 10019
18598>>>>>>>>>>>>>Define CLI_GETMAXUSERS            for 10020
18598>>>>>>>>>>>>>Define CLI_BCP                    for 10021
18598>>>>>>>>>>>>>Define CLI_DROPINDICES            for 10022
18598>>>>>>>>>>>>>Define CLI_CREATEINDICES          for 10023
18598>>>>>>>>>>>>>Define CLI_REDIRECTCONNECTION     for 10024
18598>>>>>>>>>>>>>Define CLI_CREATECONNECTIONID     for 10025
18598>>>>>>>>>>>>>Define CLI_DELETECONNECTIONID     for 10026
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Init data source types
18598>>>>>>>>>>>>>Define SQL_FETCH_ALL     for  2
18598>>>>>>>>>>>>>Define SQL_FETCH_USER    for 31
18598>>>>>>>>>>>>>Define SQL_FETCH_SYSTEM  for 32
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Dummy strings used in the commands
18598>>>>>>>>>>>>>String  CLI$StrDummy 255
18598>>>>>>>>>>>>>Integer CLI$IntDummy
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>//   Setup a constraint for a file.                                    
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// Set or get an attribute at driver level. These attributes, when set,
18598>>>>>>>>>>>>>// will be set for the remainder of the session or until set again. To 
18598>>>>>>>>>>>>>// permanently set driver level attributes change the driver           
18598>>>>>>>>>>>>>// configuration file.                                                 
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>// An instance of this class can be used as a broker object to
18598>>>>>>>>>>>>>// call several CLI releated methods.                         
18598>>>>>>>>>>>>>
18598>>>>>>>>>>>>>//Class cCLIHandler is a cObject
18598>>>>>>>>>>>>>Class cCLIHandler is an Array
18599>>>>>>>>>>>>>    
18599>>>>>>>>>>>>>    Procedure Construct_Object 
18601>>>>>>>>>>>>>        Forward Send Construct_object 
18603>>>>>>>>>>>>>        
18603>>>>>>>>>>>>>        Property String  psDriverID        ""
18604>>>>>>>>>>>>>    End_Procedure
18605>>>>>>>>>>>>>    
18605>>>>>>>>>>>>>    
18605>>>>>>>>>>>>>    
18605>>>>>>>>>>>>>    // The revsion of a CLI Connectivity Kit
18605>>>>>>>>>>>>>    Function CKRevision Returns String
18607>>>>>>>>>>>>>        String  sDriverID
18607>>>>>>>>>>>>>        String  sRevision
18607>>>>>>>>>>>>>        String  sVoid
18607>>>>>>>>>>>>>        Integer iRetval
18607>>>>>>>>>>>>>        
18607>>>>>>>>>>>>>        Get psDriverID to sDriverID
18608>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18610>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRevision
18611>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
18616>>>>>>>>>>>>>        End
18616>>>>>>>>>>>>>>
18616>>>>>>>>>>>>>        
18616>>>>>>>>>>>>>        Function_Return sRevision
18617>>>>>>>>>>>>>    End_Function
18618>>>>>>>>>>>>>    
18618>>>>>>>>>>>>>    
18618>>>>>>>>>>>>>    
18618>>>>>>>>>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
18618>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
18618>>>>>>>>>>>>>    //
18618>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
18620>>>>>>>>>>>>>        Integer iPartRev
18620>>>>>>>>>>>>>        Integer iCurrentPart
18620>>>>>>>>>>>>>        Integer iSeparatorPos
18620>>>>>>>>>>>>>        
18620>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
18623>>>>>>>>>>>>>        
18623>>>>>>>>>>>>>        Move 0 to iCurrentPart
18624>>>>>>>>>>>>>        Repeat
18624>>>>>>>>>>>>>>
18624>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
18625>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
18627>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
18628>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
18629>>>>>>>>>>>>>                Increment iCurrentPart
18630>>>>>>>>>>>>>            End
18630>>>>>>>>>>>>>>
18630>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
18633>>>>>>>>>>>>>                Move sRevision to iPartRev
18634>>>>>>>>>>>>>                Move "" to sRevision
18635>>>>>>>>>>>>>                Increment iCurrentPart
18636>>>>>>>>>>>>>            End
18636>>>>>>>>>>>>>>
18636>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
18638>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
18640>>>>>>>>>>>>>        
18640>>>>>>>>>>>>>        Function_Return iPartRev
18641>>>>>>>>>>>>>    End_Function
18642>>>>>>>>>>>>>    
18642>>>>>>>>>>>>>    
18642>>>>>>>>>>>>>    
18642>>>>>>>>>>>>>    // Returns the major revision of the CK
18642>>>>>>>>>>>>>    //
18642>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
18644>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
18645>>>>>>>>>>>>>    End_Function
18646>>>>>>>>>>>>>    
18646>>>>>>>>>>>>>    
18646>>>>>>>>>>>>>    
18646>>>>>>>>>>>>>    // Returns the minor revision of the CK
18646>>>>>>>>>>>>>    //
18646>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
18648>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
18649>>>>>>>>>>>>>    End_Function
18650>>>>>>>>>>>>>    
18650>>>>>>>>>>>>>    
18650>>>>>>>>>>>>>    
18650>>>>>>>>>>>>>    // Returns the release revision of the CK
18650>>>>>>>>>>>>>    //
18650>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
18652>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
18653>>>>>>>>>>>>>    End_Function
18654>>>>>>>>>>>>>    
18654>>>>>>>>>>>>>    
18654>>>>>>>>>>>>>    
18654>>>>>>>>>>>>>    // Returns the major revision of the CK
18654>>>>>>>>>>>>>    //
18654>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
18656>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
18657>>>>>>>>>>>>>    End_Function
18658>>>>>>>>>>>>>    
18658>>>>>>>>>>>>>    
18658>>>>>>>>>>>>>    
18658>>>>>>>>>>>>>    // Determines if the CK conforms to a passed minimal revsion.
18658>>>>>>>>>>>>>    //
18658>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
18660>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
18663>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
18666>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
18669>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
18672>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
18675>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
18679>>>>>>>>>>>>>            End
18679>>>>>>>>>>>>>>
18679>>>>>>>>>>>>>        End
18679>>>>>>>>>>>>>>
18679>>>>>>>>>>>>>        
18679>>>>>>>>>>>>>        Function_Return (False)
18680>>>>>>>>>>>>>    End_Function
18681>>>>>>>>>>>>>    
18681>>>>>>>>>>>>>    
18681>>>>>>>>>>>>>    
18681>>>>>>>>>>>>>    // Returns the Connectiivty Kit registration name.
18681>>>>>>>>>>>>>    //
18681>>>>>>>>>>>>>    Function RegistrationName Returns String
18683>>>>>>>>>>>>>        String  sRegistration
18683>>>>>>>>>>>>>        String  sDRiverId
18683>>>>>>>>>>>>>        String  sVoid
18683>>>>>>>>>>>>>        Integer iRetval
18683>>>>>>>>>>>>>        
18683>>>>>>>>>>>>>        Get psDriverID to sDriverID
18684>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18686>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRegistration
18687>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
18692>>>>>>>>>>>>>        End
18692>>>>>>>>>>>>>>
18692>>>>>>>>>>>>>        
18692>>>>>>>>>>>>>        Function_Return sRegistration
18693>>>>>>>>>>>>>    End_Function
18694>>>>>>>>>>>>>    
18694>>>>>>>>>>>>>    // Returns the Connectiivty Kit serial number.
18694>>>>>>>>>>>>>    //
18694>>>>>>>>>>>>>    Function SerialNumber Returns Integer
18696>>>>>>>>>>>>>        String  sDRiverId
18696>>>>>>>>>>>>>        String  sVoid
18696>>>>>>>>>>>>>        Integer iRetval
18696>>>>>>>>>>>>>        
18696>>>>>>>>>>>>>        Get psDriverID to sDriverID
18697>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18699>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
18704>>>>>>>>>>>>>        End
18704>>>>>>>>>>>>>>
18704>>>>>>>>>>>>>        
18704>>>>>>>>>>>>>        Function_Return iRetval
18705>>>>>>>>>>>>>    End_Function
18706>>>>>>>>>>>>>    
18706>>>>>>>>>>>>>    
18706>>>>>>>>>>>>>    // Returns the Connectiivty Kit maximum number of users.
18706>>>>>>>>>>>>>    //
18706>>>>>>>>>>>>>    Function MaxUsers Returns Integer
18708>>>>>>>>>>>>>        String  sDRiverId
18708>>>>>>>>>>>>>        String  sVoid
18708>>>>>>>>>>>>>        Integer iRetval
18708>>>>>>>>>>>>>        
18708>>>>>>>>>>>>>        Get psDriverID to sDriverID
18709>>>>>>>>>>>>>        If (sDRiverID <> "") Begin
18711>>>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
18716>>>>>>>>>>>>>        End
18716>>>>>>>>>>>>>>
18716>>>>>>>>>>>>>        
18716>>>>>>>>>>>>>        Function_Return iRetval
18717>>>>>>>>>>>>>    End_Function
18718>>>>>>>>>>>>>    
18718>>>>>>>>>>>>>    
18718>>>>>>>>>>>>>    
18718>>>>>>>>>>>>>    // Dump the current status of the drver in the passed disk file.
18718>>>>>>>>>>>>>    //
18718>>>>>>>>>>>>>    Procedure DumpStatus String sFileName
18720>>>>>>>>>>>>>        String  sVoid
18720>>>>>>>>>>>>>        String  sDriverID
18720>>>>>>>>>>>>>        Integer iVoid
18720>>>>>>>>>>>>>        
18720>>>>>>>>>>>>>        Get psDriverID to sDriverID
18721>>>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
18728>>>>>>>>>>>>>    End_Procedure
18729>>>>>>>>>>>>>    
18729>>>>>>>>>>>>>    
18729>>>>>>>>>>>>>    
18729>>>>>>>>>>>>>    // Reset all driver level configurable attributes to the
18729>>>>>>>>>>>>>    // default value and then reread the configuration.
18729>>>>>>>>>>>>>    //
18729>>>>>>>>>>>>>    Procedure ReadConfiguration
18731>>>>>>>>>>>>>        String  sVoid
18731>>>>>>>>>>>>>        String  sDriverID
18731>>>>>>>>>>>>>        Integer iVoid
18731>>>>>>>>>>>>>        
18731>>>>>>>>>>>>>        Get psDriverID to sDriverID
18732>>>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
18739>>>>>>>>>>>>>    End_Procedure
18740>>>>>>>>>>>>>    
18740>>>>>>>>>>>>>    
18740>>>>>>>>>>>>>    
18740>>>>>>>>>>>>>    // Convert a text to the corresponding
18740>>>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
18740>>>>>>>>>>>>>    //
18740>>>>>>>>>>>>>    Function TextToRIMValue String sText Returns Integer
18742>>>>>>>>>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
18745>>>>>>>>>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
18749>>>>>>>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
18753>>>>>>>>>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
18757>>>>>>>>>>>>>    End_Function
18758>>>>>>>>>>>>>    
18758>>>>>>>>>>>>>    
18758>>>>>>>>>>>>>    
18758>>>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
18758>>>>>>>>>>>>>    // corresponding text.
18758>>>>>>>>>>>>>    //
18758>>>>>>>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
18760>>>>>>>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
18763>>>>>>>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
18767>>>>>>>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
18771>>>>>>>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
18775>>>>>>>>>>>>>    End_Function
18776>>>>>>>>>>>>>    
18776>>>>>>>>>>>>>    
18776>>>>>>>>>>>>>    
18776>>>>>>>>>>>>>    // Convert a text to the corresponding
18776>>>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
18776>>>>>>>>>>>>>    //
18776>>>>>>>>>>>>>    Function TextToROValue String sText Returns Integer
18778>>>>>>>>>>>>>        If (sText = "No") ;            Function_Return RO_NO
18781>>>>>>>>>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
18785>>>>>>>>>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
18789>>>>>>>>>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
18793>>>>>>>>>>>>>    End_Function
18794>>>>>>>>>>>>>    
18794>>>>>>>>>>>>>    
18794>>>>>>>>>>>>>    
18794>>>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
18794>>>>>>>>>>>>>    // corresponding text.
18794>>>>>>>>>>>>>    //
18794>>>>>>>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
18796>>>>>>>>>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
18799>>>>>>>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
18803>>>>>>>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
18807>>>>>>>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
18811>>>>>>>>>>>>>    End_Function
18812>>>>>>>>>>>>>    
18812>>>>>>>>>>>>>    
18812>>>>>>>>>>>>>    
18812>>>>>>>>>>>>>    // Return the text f the last error geneated by the driver.
18812>>>>>>>>>>>>>    //
18812>>>>>>>>>>>>>    Function LastDriverError Returns String
18814>>>>>>>>>>>>>        String  sDriverID
18814>>>>>>>>>>>>>        String  sLastError
18814>>>>>>>>>>>>>        String  sLastErrorLength
18814>>>>>>>>>>>>>        Integer iLastErrorLength
18814>>>>>>>>>>>>>        Integer iVoid
18814>>>>>>>>>>>>>        
18814>>>>>>>>>>>>>        // Initialize
18814>>>>>>>>>>>>>        Move "" to sLastError
18815>>>>>>>>>>>>>        
18815>>>>>>>>>>>>>        Get psDriverID to sDriverID
18816>>>>>>>>>>>>>        If (sDriverID <> "") Begin
18818>>>>>>>>>>>>>            // Get the text of the last error
18818>>>>>>>>>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
18819>>>>>>>>>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
18824>>>>>>>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
18825>>>>>>>>>>>>>            
18825>>>>>>>>>>>>>            If (iLastErrorLength > 0) Begin
18827>>>>>>>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
18828>>>>>>>>>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
18833>>>>>>>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
18834>>>>>>>>>>>>>            End
18834>>>>>>>>>>>>>>
18834>>>>>>>>>>>>>        End
18834>>>>>>>>>>>>>>
18834>>>>>>>>>>>>>        
18834>>>>>>>>>>>>>        Function_Return sLastError
18835>>>>>>>>>>>>>    End_Function
18836>>>>>>>>>>>>>    
18836>>>>>>>>>>>>>    
18836>>>>>>>>>>>>>    
18836>>>>>>>>>>>>>    // Enumerate the tables in a database
18836>>>>>>>>>>>>>    //
18836>>>>>>>>>>>>>    Function EnumerateTables String sLogin Returns Integer
18838>>>>>>>>>>>>>        String  sDriver
18838>>>>>>>>>>>>>        String  sVoid
18838>>>>>>>>>>>>>        Integer iNumTables
18838>>>>>>>>>>>>>        Integer iVoid
18838>>>>>>>>>>>>>        
18838>>>>>>>>>>>>>        Get psDriverID to sDriver
18839>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
18846>>>>>>>>>>>>>        
18846>>>>>>>>>>>>>        Function_Return iNumTables
18847>>>>>>>>>>>>>    End_Function
18848>>>>>>>>>>>>>    
18848>>>>>>>>>>>>>    
18848>>>>>>>>>>>>>    
18848>>>>>>>>>>>>>    // Returns the name of the table enumerated at the given position
18848>>>>>>>>>>>>>    //
18848>>>>>>>>>>>>>    Function TableName Integer iIndex Returns String
18850>>>>>>>>>>>>>        String  sDriver
18850>>>>>>>>>>>>>        String  sTableName
18850>>>>>>>>>>>>>        String  sVoid
18850>>>>>>>>>>>>>        Integer iVoid
18850>>>>>>>>>>>>>        
18850>>>>>>>>>>>>>        Get psDriverID to sDriver
18851>>>>>>>>>>>>>        If (sDriver <> "") Begin
18853>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sTableName
18854>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
18859>>>>>>>>>>>>>        End
18859>>>>>>>>>>>>>>
18859>>>>>>>>>>>>>        
18859>>>>>>>>>>>>>        Function_Return sTableName
18860>>>>>>>>>>>>>    End_Function
18861>>>>>>>>>>>>>    
18861>>>>>>>>>>>>>    
18861>>>>>>>>>>>>>    
18861>>>>>>>>>>>>>    // Returns the name of the schema of the table enumerated at the given position
18861>>>>>>>>>>>>>    //
18861>>>>>>>>>>>>>    Function SchemaName Integer iIndex Returns String
18863>>>>>>>>>>>>>        String  sDriver
18863>>>>>>>>>>>>>        String  sSchemaName
18863>>>>>>>>>>>>>        String  sVoid
18863>>>>>>>>>>>>>        Integer iVoid
18863>>>>>>>>>>>>>        
18863>>>>>>>>>>>>>        Get psDriverID to sDriver
18864>>>>>>>>>>>>>        If (sDriver <> "") Begin
18866>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sSchemaName
18867>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
18872>>>>>>>>>>>>>        End
18872>>>>>>>>>>>>>>
18872>>>>>>>>>>>>>        
18872>>>>>>>>>>>>>        Function_Return sSchemaName
18873>>>>>>>>>>>>>    End_Function
18874>>>>>>>>>>>>>    
18874>>>>>>>>>>>>>    // Returns the type of the table enumerated at the given position.
18874>>>>>>>>>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
18874>>>>>>>>>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
18874>>>>>>>>>>>>>    Function TableType Integer iIndex Returns String
18876>>>>>>>>>>>>>        String  sDriver
18876>>>>>>>>>>>>>        String  sTableType
18876>>>>>>>>>>>>>        String  sVoid
18876>>>>>>>>>>>>>        Integer iVoid
18876>>>>>>>>>>>>>        
18876>>>>>>>>>>>>>        Get psDriverID to sDriver
18877>>>>>>>>>>>>>        If (sDriver <> "") Begin
18879>>>>>>>>>>>>>            Move (Repeat(" ", 25)) to sTableType
18880>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
18885>>>>>>>>>>>>>        End
18885>>>>>>>>>>>>>>
18885>>>>>>>>>>>>>        
18885>>>>>>>>>>>>>        Function_Return sTableType
18886>>>>>>>>>>>>>    End_Function
18887>>>>>>>>>>>>>    
18887>>>>>>>>>>>>>    
18887>>>>>>>>>>>>>    // Returns the comment of the table enumerated at the given position
18887>>>>>>>>>>>>>    //
18887>>>>>>>>>>>>>    Function TableComment Integer iIndex Returns String
18889>>>>>>>>>>>>>        String  sDriver
18889>>>>>>>>>>>>>        String  sTableComment
18889>>>>>>>>>>>>>        String  sVoid
18889>>>>>>>>>>>>>        Integer iVoid
18889>>>>>>>>>>>>>        
18889>>>>>>>>>>>>>        Get psDriverID to sDriver
18890>>>>>>>>>>>>>        If (sDriver <> "") Begin
18892>>>>>>>>>>>>>            Move (Repeat(" ", 1024)) to sTableComment
18893>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
18898>>>>>>>>>>>>>        End
18898>>>>>>>>>>>>>>
18898>>>>>>>>>>>>>        
18898>>>>>>>>>>>>>        Function_Return sTableComment
18899>>>>>>>>>>>>>    End_Function
18900>>>>>>>>>>>>>    
18900>>>>>>>>>>>>>    // Enumerate the columns in a table
18900>>>>>>>>>>>>>    //
18900>>>>>>>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
18902>>>>>>>>>>>>>        String  sDriver
18902>>>>>>>>>>>>>        Integer iNumColumns
18902>>>>>>>>>>>>>        Integer iVoid
18902>>>>>>>>>>>>>        
18902>>>>>>>>>>>>>        Get psDriverID to sDriver
18903>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
18910>>>>>>>>>>>>>        
18910>>>>>>>>>>>>>        Function_Return iNumColumns
18911>>>>>>>>>>>>>    End_Function
18912>>>>>>>>>>>>>    
18912>>>>>>>>>>>>>    
18912>>>>>>>>>>>>>    
18912>>>>>>>>>>>>>    // Returns the name of the column enumerated at the given position
18912>>>>>>>>>>>>>    //
18912>>>>>>>>>>>>>    Function ColumnName Integer iIndex Returns String
18914>>>>>>>>>>>>>        String  sDriver
18914>>>>>>>>>>>>>        String  sColumnName
18914>>>>>>>>>>>>>        String  sVoid
18914>>>>>>>>>>>>>        Integer iVoid
18914>>>>>>>>>>>>>        
18914>>>>>>>>>>>>>        Get psDriverID to sDriver
18915>>>>>>>>>>>>>        If (sDriver <> "") Begin
18917>>>>>>>>>>>>>            Move (Repeat(" ", 255)) to sColumnName
18918>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
18923>>>>>>>>>>>>>        End
18923>>>>>>>>>>>>>>
18923>>>>>>>>>>>>>        
18923>>>>>>>>>>>>>        Function_Return sColumnName
18924>>>>>>>>>>>>>    End_Function
18925>>>>>>>>>>>>>    
18925>>>>>>>>>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
18925>>>>>>>>>>>>>    //
18925>>>>>>>>>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
18927>>>>>>>>>>>>>        
18927>>>>>>>>>>>>>        Integer iDriverIndex
18927>>>>>>>>>>>>>        
18927>>>>>>>>>>>>>        String sSQLDate
18927>>>>>>>>>>>>>        Integer iOrgDateFmt
18927>>>>>>>>>>>>>        Integer iOrgDateSep
18927>>>>>>>>>>>>>        
18927>>>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18927>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18930>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18933>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18936>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18939>>>>>>>>>>>>>        
18939>>>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
18941>>>>>>>>>>>>>            // Return the dummy zero date
18941>>>>>>>>>>>>>            Get DriverIndex sDriver to iDriverIndex
18942>>>>>>>>>>>>>            If (iDriverIndex <> 0) Begin
18944>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
18947>>>>>>>>>>>>>            End
18947>>>>>>>>>>>>>>
18947>>>>>>>>>>>>>            Else Begin
18948>>>>>>>>>>>>>                Move '0001-01-01' to sSQLDate
18949>>>>>>>>>>>>>            End
18949>>>>>>>>>>>>>>
18949>>>>>>>>>>>>>        End
18949>>>>>>>>>>>>>>
18949>>>>>>>>>>>>>        Else Begin
18950>>>>>>>>>>>>>            Move dDFDate to sSQLDate
18951>>>>>>>>>>>>>        End
18951>>>>>>>>>>>>>>
18951>>>>>>>>>>>>>        
18951>>>>>>>>>>>>>        // Change date format back to original
18951>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18954>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18957>>>>>>>>>>>>>        
18957>>>>>>>>>>>>>        Function_Return sSQLDate
18958>>>>>>>>>>>>>    End_Function
18959>>>>>>>>>>>>>    
18959>>>>>>>>>>>>>    
18959>>>>>>>>>>>>>    
18959>>>>>>>>>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
18959>>>>>>>>>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
18961>>>>>>>>>>>>>        
18961>>>>>>>>>>>>>        Integer iDriverIndex
18961>>>>>>>>>>>>>        
18961>>>>>>>>>>>>>        Date dDFDate
18961>>>>>>>>>>>>>        String sDummyDateValue
18961>>>>>>>>>>>>>        Integer iOrgDateFmt
18961>>>>>>>>>>>>>        Integer iOrgDateSep
18961>>>>>>>>>>>>>        
18961>>>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18961>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18964>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18967>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18970>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18973>>>>>>>>>>>>>        
18973>>>>>>>>>>>>>        // We only need to convert if the date is the dummy zero date value
18973>>>>>>>>>>>>>        Get DriverIndex sDriver to iDriverIndex
18974>>>>>>>>>>>>>        If (iDriverIndex <> 0) Begin
18976>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
18979>>>>>>>>>>>>>        End
18979>>>>>>>>>>>>>>
18979>>>>>>>>>>>>>        Else Begin
18980>>>>>>>>>>>>>            Move '0001-01-01' to sDummyDateValue
18981>>>>>>>>>>>>>        End
18981>>>>>>>>>>>>>>
18981>>>>>>>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
18984>>>>>>>>>>>>>        Else ;            Move sSQLDate to dDFDate
18986>>>>>>>>>>>>>        
18986>>>>>>>>>>>>>        // Change date format back to original
18986>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18989>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18992>>>>>>>>>>>>>        
18992>>>>>>>>>>>>>        Function_Return dDFDate
18993>>>>>>>>>>>>>    End_Function
18994>>>>>>>>>>>>>    
18994>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
18996>>>>>>>>>>>>>        
18996>>>>>>>>>>>>>        String  sCurrentDriver
18996>>>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
18996>>>>>>>>>>>>>        
18996>>>>>>>>>>>>>        Move 0 to iDriver
18997>>>>>>>>>>>>>        
18997>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
19000>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
19006>>>>>>>>>>>>>>
19006>>>>>>>>>>>>>            
19006>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
19009>>>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
19011>>>>>>>>>>>>>                Move iCount to iDriver
19012>>>>>>>>>>>>>            End
19012>>>>>>>>>>>>>>
19012>>>>>>>>>>>>>        Loop
19013>>>>>>>>>>>>>>
19013>>>>>>>>>>>>>        
19013>>>>>>>>>>>>>        Function_Return iDriver
19014>>>>>>>>>>>>>        
19014>>>>>>>>>>>>>    End_Function
19015>>>>>>>>>>>>>    
19015>>>>>>>>>>>>>    
19015>>>>>>>>>>>>>    // Redirect an exisitng connection. The existing connection
19015>>>>>>>>>>>>>    // will point to another database but all tables will stay
19015>>>>>>>>>>>>>    // open!
19015>>>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
19017>>>>>>>>>>>>>        String  sDriver
19017>>>>>>>>>>>>>        String  sVoid
19017>>>>>>>>>>>>>        Integer iResult
19017>>>>>>>>>>>>>        Integer iVoid
19017>>>>>>>>>>>>>        
19017>>>>>>>>>>>>>        Get psDriverID to sDriver
19018>>>>>>>>>>>>>        If (sDriver <> "") Begin
19020>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
19025>>>>>>>>>>>>>        End
19025>>>>>>>>>>>>>>
19025>>>>>>>>>>>>>        Function_Return iResult
19026>>>>>>>>>>>>>    End_Function
19027>>>>>>>>>>>>>    
19027>>>>>>>>>>>>>    // Redirect a connection of a connection ID
19027>>>>>>>>>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
19027>>>>>>>>>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
19027>>>>>>>>>>>>>    //
19027>>>>>>>>>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
19027>>>>>>>>>>>>>    // to the new connection (Server/Database specified in sConnectString)
19027>>>>>>>>>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
19027>>>>>>>>>>>>>    //
19027>>>>>>>>>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
19027>>>>>>>>>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
19027>>>>>>>>>>>>>    //
19027>>>>>>>>>>>>>    // Returns:
19027>>>>>>>>>>>>>    //     0 when the redirection was successful.
19027>>>>>>>>>>>>>    //     1 if the connection ID does not exist or can not be found.
19027>>>>>>>>>>>>>    //     2 login into the new connection failed.
19027>>>>>>>>>>>>>    //
19027>>>>>>>>>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
19029>>>>>>>>>>>>>        String  sDriver
19029>>>>>>>>>>>>>        String  sVoid
19029>>>>>>>>>>>>>        Integer iResult
19029>>>>>>>>>>>>>        
19029>>>>>>>>>>>>>        Integer iOption
19029>>>>>>>>>>>>>        
19029>>>>>>>>>>>>>        // iOption
19029>>>>>>>>>>>>>        // 0 = RedirectConnection
19029>>>>>>>>>>>>>        // 1 = RedirectIdConnectString
19029>>>>>>>>>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
19029>>>>>>>>>>>>>        If (bKeepLoggedIn) Begin
19031>>>>>>>>>>>>>            Move 2 to iOption
19032>>>>>>>>>>>>>        End
19032>>>>>>>>>>>>>>
19032>>>>>>>>>>>>>        Else Begin
19033>>>>>>>>>>>>>            Move 1 to iOption
19034>>>>>>>>>>>>>        End
19034>>>>>>>>>>>>>>
19034>>>>>>>>>>>>>        
19034>>>>>>>>>>>>>        Get psDriverID to sDriver
19035>>>>>>>>>>>>>        If (sDriver <> "") Begin
19037>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
19042>>>>>>>>>>>>>        End
19042>>>>>>>>>>>>>>
19042>>>>>>>>>>>>>        Function_Return iResult
19043>>>>>>>>>>>>>    End_Function
19044>>>>>>>>>>>>>    
19044>>>>>>>>>>>>>    
19044>>>>>>>>>>>>>    // Create a DataFlex side connection id that can be used later on.
19044>>>>>>>>>>>>>    //
19044>>>>>>>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
19046>>>>>>>>>>>>>        String  sDriver
19046>>>>>>>>>>>>>        Integer iResult
19046>>>>>>>>>>>>>        Integer iOptions
19046>>>>>>>>>>>>>        
19046>>>>>>>>>>>>>        Get psDriverID to sDriver
19047>>>>>>>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
19050>>>>>>>>>>>>>        Else ;            Move iOpt to iOptions
19052>>>>>>>>>>>>>        If (sDriver <> "") Begin
19054>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
19059>>>>>>>>>>>>>        End
19059>>>>>>>>>>>>>>
19059>>>>>>>>>>>>>        Function_Return iResult
19060>>>>>>>>>>>>>    End_Function
19061>>>>>>>>>>>>>    
19061>>>>>>>>>>>>>    
19061>>>>>>>>>>>>>    
19061>>>>>>>>>>>>>    // Delete a DataFlex side connection id.
19061>>>>>>>>>>>>>    //
19061>>>>>>>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
19063>>>>>>>>>>>>>        String  sDriver
19063>>>>>>>>>>>>>        Integer iResult
19063>>>>>>>>>>>>>        String sVoid
19063>>>>>>>>>>>>>        
19063>>>>>>>>>>>>>        Get psDriverID to sDriver
19064>>>>>>>>>>>>>        If (sDriver <> "") Begin
19066>>>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
19071>>>>>>>>>>>>>        End
19071>>>>>>>>>>>>>>
19071>>>>>>>>>>>>>        Function_Return iResult
19072>>>>>>>>>>>>>    End_Function
19073>>>>>>>>>>>>>    
19073>>>>>>>>>>>>>End_Class
19074>>>>>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files\DataFlex 24.0\Pkg\sql.pkg)
19074>>>>>>>>>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
19074>>>>>>>>>>>>>// Connectivty Kits.                                              
19074>>>>>>>>>>>>>Use CLI.pkg
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Global storage for results
19074>>>>>>>>>>>>>Integer SQLResult
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Embedded SQL function constants
19074>>>>>>>>>>>>>Define FUNC_SQLCONNECT             for 1000000
19074>>>>>>>>>>>>>Define FUNC_SQLFILECONNECT         for 1000001
19074>>>>>>>>>>>>>Define FUNC_SQLDISCONNECT          for 1000002
19074>>>>>>>>>>>>>Define FUNC_SQLOPEN                for 1000003
19074>>>>>>>>>>>>>Define FUNC_SQLCLOSE               for 1000004
19074>>>>>>>>>>>>>Define FUNC_SQLPREPARE             for 1000005
19074>>>>>>>>>>>>>Define FUNC_SQLEXECUTE             for 1000006
19074>>>>>>>>>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
19074>>>>>>>>>>>>>Define FUNC_SQLFETCH               for 1000008
19074>>>>>>>>>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
19074>>>>>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
19074>>>>>>>>>>>>>Define FUNC_SQLBINDFILE            for 1000011
19074>>>>>>>>>>>>>Define FUNC_SQLGETDATA             for 1000012
19074>>>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
19074>>>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
19074>>>>>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
19074>>>>>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
19074>>>>>>>>>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
19074>>>>>>>>>>>>>Define FUNC_SQLSETPROCARG          for 1000018
19074>>>>>>>>>>>>>Define FUNC_SQLCALL                for 1000019
19074>>>>>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
19074>>>>>>>>>>>>>Define FUNC_SQLGETPROCARG          for 1000021
19074>>>>>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
19074>>>>>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
19074>>>>>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
19074>>>>>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
19074>>>>>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
19074>>>>>>>>>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
19074>>>>>>>>>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Embedded SQL statement attribute constants
19074>>>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
19074>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
19074>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
19074>>>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
19074>>>>>>>>>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
19074>>>>>>>>>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
19074>>>>>>>>>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
19074>>>>>>>>>>>>>Define SQL_CURSOR_DYNAMIC           for 2
19074>>>>>>>>>>>>>Define SQL_CURSOR_STATIC            for 3
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Embedded SQL column attribute constants
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
19074>>>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Types used for conversion with ConvertToXml
19074>>>>>>>>>>>>>Define esqlTime      for 8
19074>>>>>>>>>>>>>Define esqlDatetime  for 9
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
19074>>>>>>>>>>>>>Integer giLastSQLhdbc
19074>>>>>>>>>>>>>Integer giLastSQLhstmt
19074>>>>>>>>>>>>>
19074>>>>>>>>>>>>>Move -1 to giLastSQLhdbc
19075>>>>>>>>>>>>>Move -1 to giLastSQLhstmt
19076>>>>>>>>>>>>>
19076>>>>>>>>>>>>>Struct tSQLColumn
19076>>>>>>>>>>>>>    Integer iSQLType
19076>>>>>>>>>>>>>    Integer iSQLSize
19076>>>>>>>>>>>>>    Integer iSQLPrecision
19076>>>>>>>>>>>>>    Integer iVariableDataType
19076>>>>>>>>>>>>>End_Struct
19076>>>>>>>>>>>>>
19076>>>>>>>>>>>>>// Statement object for embedded sql                           
19076>>>>>>>>>>>>>//   An object is created for each statement. These will be children    
19076>>>>>>>>>>>>>//   of cSQLConnection objects which manage the create and destruction  
19076>>>>>>>>>>>>>//   of these.                                                          
19076>>>>>>>>>>>>>
19076>>>>>>>>>>>>>Class cSQLStatement is a cObject
19077>>>>>>>>>>>>>    
19077>>>>>>>>>>>>>    Procedure Construct_object
19079>>>>>>>>>>>>>        Forward Send Construct_object
19081>>>>>>>>>>>>>        
19081>>>>>>>>>>>>>        Property Handle  phCLIStatementHandle   0
19082>>>>>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
19083>>>>>>>>>>>>>        Property String  psDriverID             ""
19084>>>>>>>>>>>>>        
19084>>>>>>>>>>>>>        Property Integer piLastColumn      0
19085>>>>>>>>>>>>>        Property Integer piLastArgument    0
19086>>>>>>>>>>>>>        Property Integer piBindFile        0
19087>>>>>>>>>>>>>        
19087>>>>>>>>>>>>>        Property Integer piColumnCount     0
19088>>>>>>>>>>>>>        
19088>>>>>>>>>>>>>        // True if there is at least 1 column with a variable length data type
19088>>>>>>>>>>>>>        Property Integer piHasVariableDataType  0
19089>>>>>>>>>>>>>        
19089>>>>>>>>>>>>>        // Max size of buffer for variable length data. Default 16000
19089>>>>>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000
19090>>>>>>>>>>>>>        
19090>>>>>>>>>>>>>        // Allocated buffer for SQLGetData.
19090>>>>>>>>>>>>>        Property WString psVariableBuffer  ""
19091>>>>>>>>>>>>>        
19091>>>>>>>>>>>>>        // Allocated size of psVariableBuffer
19091>>>>>>>>>>>>>        Property Integer piVariableBufferLength 0
19092>>>>>>>>>>>>>        
19092>>>>>>>>>>>>>        // Stores column properties of a result set.
19092>>>>>>>>>>>>>        Property tSQLColumn[] paSQLColumns
19093>>>>>>>>>>>>>        
19093>>>>>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
19093>>>>>>>>>>>>>        //   0    = Fetch returned no data.
19093>>>>>>>>>>>>>        //   <> 0 = Row fetched
19093>>>>>>>>>>>>>        Property Integer piFetchResult     0
19094>>>>>>>>>>>>>        
19094>>>>>>>>>>>>>        
19094>>>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
19095>>>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
19096>>>>>>>>>>>>>        
19096>>>>>>>>>>>>>    End_Procedure
19097>>>>>>>>>>>>>    
19097>>>>>>>>>>>>>    // Store basic information about the statement.
19097>>>>>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
19099>>>>>>>>>>>>>        
19099>>>>>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
19100>>>>>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
19101>>>>>>>>>>>>>        Set psDriverID             to sDrvrId
19102>>>>>>>>>>>>>        
19102>>>>>>>>>>>>>    End_Procedure
19103>>>>>>>>>>>>>    
19103>>>>>>>>>>>>>    
19103>>>>>>>>>>>>>    // Destroy the cSQLStatement object
19103>>>>>>>>>>>>>    Procedure DestroySQLStatement
19105>>>>>>>>>>>>>        Send Destroy
19106>>>>>>>>>>>>>    End_Procedure
19107>>>>>>>>>>>>>    
19107>>>>>>>>>>>>>    // Handle an error that has occurred while checking properties.
19107>>>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
19109>>>>>>>>>>>>>        Integer iErrHandle
19109>>>>>>>>>>>>>        Integer iErrNum
19109>>>>>>>>>>>>>        String  sLocationInfo
19109>>>>>>>>>>>>>        
19109>>>>>>>>>>>>>        // Get the DataFlex statement identifier
19109>>>>>>>>>>>>>        Move Self to iErrHandle
19110>>>>>>>>>>>>>        
19110>>>>>>>>>>>>>        // Determine error number
19110>>>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
19113>>>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
19117>>>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
19121>>>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
19123>>>>>>>>>>>>>        
19123>>>>>>>>>>>>>        // Create location ifnormation
19123>>>>>>>>>>>>>        Move "[" to sLocationInfo
19124>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
19126>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
19127>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
19128>>>>>>>>>>>>>        End
19128>>>>>>>>>>>>>>
19128>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
19129>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
19130>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
19131>>>>>>>>>>>>>        
19131>>>>>>>>>>>>>        // Generate the error
19131>>>>>>>>>>>>>        Error iErrNum sLocationInfo
19132>>>>>>>>>>>>>>
19132>>>>>>>>>>>>>    End_Procedure
19133>>>>>>>>>>>>>    
19133>>>>>>>>>>>>>    // Handle general error not related to the properties
19133>>>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
19135>>>>>>>>>>>>>        Integer iErrHandle
19135>>>>>>>>>>>>>        String  sLocationInfo
19135>>>>>>>>>>>>>        
19135>>>>>>>>>>>>>        // Get the DataFlex statement identifier
19135>>>>>>>>>>>>>        Move Self to iErrHandle
19136>>>>>>>>>>>>>        
19136>>>>>>>>>>>>>        // Create location information
19136>>>>>>>>>>>>>        Move "[" to sLocationInfo
19137>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
19139>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
19140>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
19141>>>>>>>>>>>>>        End
19141>>>>>>>>>>>>>>
19141>>>>>>>>>>>>>        If (sErrtext <> "") Begin
19143>>>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
19144>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
19145>>>>>>>>>>>>>        End
19145>>>>>>>>>>>>>>
19145>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
19146>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
19147>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
19148>>>>>>>>>>>>>        
19148>>>>>>>>>>>>>        // Generate the error
19148>>>>>>>>>>>>>        Error iErrNum sLocationInfo
19149>>>>>>>>>>>>>>
19149>>>>>>>>>>>>>    End_Procedure
19150>>>>>>>>>>>>>    
19150>>>>>>>>>>>>>    // Handle an illegal attribute error
19150>>>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
19152>>>>>>>>>>>>>        Integer bReport
19152>>>>>>>>>>>>>        
19152>>>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
19155>>>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
19158>>>>>>>>>>>>>    End_Procedure
19159>>>>>>>>>>>>>    
19159>>>>>>>>>>>>>    // Check if a column number is legal
19159>>>>>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
19161>>>>>>>>>>>>>        Integer bLegal
19161>>>>>>>>>>>>>        Integer iNumColumns
19161>>>>>>>>>>>>>        
19161>>>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19162>>>>>>>>>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
19165>>>>>>>>>>>>>        Else ;            Move DFFALSE to bLegal
19167>>>>>>>>>>>>>        
19167>>>>>>>>>>>>>        Function_Return bLegal
19168>>>>>>>>>>>>>    End_Function
19169>>>>>>>>>>>>>    
19169>>>>>>>>>>>>>    
19169>>>>>>>>>>>>>    
19169>>>>>>>>>>>>>    // Close a statement and free all alllocated resources
19169>>>>>>>>>>>>>    Procedure SQLClose
19171>>>>>>>>>>>>>        Integer ihdbc
19171>>>>>>>>>>>>>        Integer ihstmt
19171>>>>>>>>>>>>>        Integer iVoid
19171>>>>>>>>>>>>>        String  sDrvrId
19171>>>>>>>>>>>>>        String  sEmpty
19171>>>>>>>>>>>>>        
19171>>>>>>>>>>>>>        // Initialize
19171>>>>>>>>>>>>>        Move "" to sEmpty
19172>>>>>>>>>>>>>        
19172>>>>>>>>>>>>>        // Get the cli handles
19172>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19173>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19174>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19175>>>>>>>>>>>>>        
19175>>>>>>>>>>>>>        // Free the CLI handle
19175>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19177>>>>>>>>>>>>>            // Call the driver function to close
19177>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
19182>>>>>>>>>>>>>            
19182>>>>>>>>>>>>>            Move -1 to giLastSQLhstmt
19183>>>>>>>>>>>>>            // Free the DataFlex handle
19183>>>>>>>>>>>>>            Send DestroySQLStatement
19184>>>>>>>>>>>>>        End
19184>>>>>>>>>>>>>>
19184>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
19186>>>>>>>>>>>>>    End_Procedure
19187>>>>>>>>>>>>>    
19187>>>>>>>>>>>>>    // Prepare a statement for execution
19187>>>>>>>>>>>>>    Procedure SQLPrepare String sStatement
19189>>>>>>>>>>>>>        Integer ihdbc
19189>>>>>>>>>>>>>        Integer ihstmt
19189>>>>>>>>>>>>>        Integer iVoid
19189>>>>>>>>>>>>>        String  sDrvrId
19189>>>>>>>>>>>>>        
19189>>>>>>>>>>>>>        // Get the cli handles
19189>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19190>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19191>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19192>>>>>>>>>>>>>        
19192>>>>>>>>>>>>>        // Prepare
19192>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19194>>>>>>>>>>>>>            // Call the driver function to prepare
19194>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
19199>>>>>>>>>>>>>            Set piLastArgument to 0
19200>>>>>>>>>>>>>
19200>>>>>>>>>>>>>        End
19200>>>>>>>>>>>>>>
19200>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
19202>>>>>>>>>>>>>    End_Procedure
19203>>>>>>>>>>>>>    
19203>>>>>>>>>>>>>    Procedure SQLGetStatementAttributes
19205>>>>>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
19205>>>>>>>>>>>>>        String sMaxValue
19205>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19205>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19206>>>>>>>>>>>>>        
19206>>>>>>>>>>>>>        Integer iSqlType
19206>>>>>>>>>>>>>        Integer iSQLSize
19206>>>>>>>>>>>>>        Integer iSQLprecision
19206>>>>>>>>>>>>>        Integer iVariableDataType
19206>>>>>>>>>>>>>        
19206>>>>>>>>>>>>>        String  sDrvrId
19206>>>>>>>>>>>>>        
19206>>>>>>>>>>>>>        Integer iHasVariableDataType
19206>>>>>>>>>>>>>        
19206>>>>>>>>>>>>>        Move 0 to iHasVariableDataType
19207>>>>>>>>>>>>>        
19207>>>>>>>>>>>>>        
19207>>>>>>>>>>>>>        // Get the cli handles
19207>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19208>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19209>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19210>>>>>>>>>>>>>        
19210>>>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19211>>>>>>>>>>>>>        
19211>>>>>>>>>>>>>        Set piColumnCount to iNumColumns
19212>>>>>>>>>>>>>        
19212>>>>>>>>>>>>>        // Fill columns array
19212>>>>>>>>>>>>>        For iCol from 1 to iNumColumns
19218>>>>>>>>>>>>>>
19218>>>>>>>>>>>>>            Move 0 to iVariableDataType
19219>>>>>>>>>>>>>            
19219>>>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
19220>>>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
19221>>>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
19222>>>>>>>>>>>>>            
19222>>>>>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
19224>>>>>>>>>>>>>                // text type
19224>>>>>>>>>>>>>                Move 1 to iVariableDataType
19225>>>>>>>>>>>>>            End
19225>>>>>>>>>>>>>>
19225>>>>>>>>>>>>>            Else Begin
19226>>>>>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
19228>>>>>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
19228>>>>>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
19230>>>>>>>>>>>>>                        
19230>>>>>>>>>>>>>                        Move 1 to iVariableDataType
19231>>>>>>>>>>>>>                    End
19231>>>>>>>>>>>>>>
19231>>>>>>>>>>>>>                End
19231>>>>>>>>>>>>>>
19231>>>>>>>>>>>>>            End
19231>>>>>>>>>>>>>>
19231>>>>>>>>>>>>>            
19231>>>>>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
19232>>>>>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
19233>>>>>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
19234>>>>>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
19235>>>>>>>>>>>>>            
19235>>>>>>>>>>>>>            If (not(iVariableDataType)) Begin
19237>>>>>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
19239>>>>>>>>>>>>>                    Move iSQLSize to iMaxSize
19240>>>>>>>>>>>>>                End
19240>>>>>>>>>>>>>>
19240>>>>>>>>>>>>>            End
19240>>>>>>>>>>>>>>
19240>>>>>>>>>>>>>            Else Begin
19241>>>>>>>>>>>>>                Move 1 to iHasVariableDataType
19242>>>>>>>>>>>>>            End
19242>>>>>>>>>>>>>>
19242>>>>>>>>>>>>>            
19242>>>>>>>>>>>>>        Loop
19243>>>>>>>>>>>>>>
19243>>>>>>>>>>>>>        
19243>>>>>>>>>>>>>        Set paSQLColumns   to aSQLColumns
19244>>>>>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
19245>>>>>>>>>>>>>        
19245>>>>>>>>>>>>>    End_Procedure
19246>>>>>>>>>>>>>    
19246>>>>>>>>>>>>>    // Execute a prepared statement
19246>>>>>>>>>>>>>    Procedure SQLExecute
19248>>>>>>>>>>>>>        Integer ihdbc
19248>>>>>>>>>>>>>        Integer ihstmt
19248>>>>>>>>>>>>>        Integer iVoid
19248>>>>>>>>>>>>>        String  sDrvrId
19248>>>>>>>>>>>>>        String  sEmpty
19248>>>>>>>>>>>>>        
19248>>>>>>>>>>>>>        // Initialize
19248>>>>>>>>>>>>>        Move "" to sEmpty
19249>>>>>>>>>>>>>        
19249>>>>>>>>>>>>>        // Get the cli handles
19249>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19250>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19251>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19252>>>>>>>>>>>>>        
19252>>>>>>>>>>>>>        // Execute
19252>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19254>>>>>>>>>>>>>            // Call the driver function to execute
19254>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
19259>>>>>>>>>>>>>            Send SQLGetStatementAttributes
19260>>>>>>>>>>>>>            Set piLastArgument to 0
19261>>>>>>>>>>>>>        End
19261>>>>>>>>>>>>>>
19261>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
19263>>>>>>>>>>>>>    End_Procedure
19264>>>>>>>>>>>>>    
19264>>>>>>>>>>>>>    
19264>>>>>>>>>>>>>    
19264>>>>>>>>>>>>>    // Prepare and execute a statement
19264>>>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
19266>>>>>>>>>>>>>        Integer ihdbc
19266>>>>>>>>>>>>>        Integer ihstmt
19266>>>>>>>>>>>>>        Integer iVoid
19266>>>>>>>>>>>>>        String  sDrvrId
19266>>>>>>>>>>>>>        
19266>>>>>>>>>>>>>        // Get the cli handles
19266>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19267>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19268>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19269>>>>>>>>>>>>>        
19269>>>>>>>>>>>>>        // ExecDirect
19269>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19271>>>>>>>>>>>>>            // Call the driver function to execdirect
19271>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
19276>>>>>>>>>>>>>            Send SQLGetStatementAttributes
19277>>>>>>>>>>>>>        End
19277>>>>>>>>>>>>>>
19277>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
19279>>>>>>>>>>>>>    End_Procedure
19280>>>>>>>>>>>>>    
19280>>>>>>>>>>>>>    // Fetch the next row
19280>>>>>>>>>>>>>    // Returns  : 0   = No more data
19280>>>>>>>>>>>>>    //<>0 = Success
19280>>>>>>>>>>>>>    Function SQLFetch Returns Integer
19282>>>>>>>>>>>>>        Integer ihdbc
19282>>>>>>>>>>>>>        Integer ihstmt
19282>>>>>>>>>>>>>        Integer iResult
19282>>>>>>>>>>>>>        String  sDrvrId
19282>>>>>>>>>>>>>        String  sEmpty
19282>>>>>>>>>>>>>        
19282>>>>>>>>>>>>>        // Initialize
19282>>>>>>>>>>>>>        Move "" to sEmpty
19283>>>>>>>>>>>>>        Move 0  to iResult
19284>>>>>>>>>>>>>        
19284>>>>>>>>>>>>>        // Get the cli handles
19284>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19285>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19286>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19287>>>>>>>>>>>>>        
19287>>>>>>>>>>>>>        // Fetch
19287>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19289>>>>>>>>>>>>>            Move False to Err
19290>>>>>>>>>>>>>            
19290>>>>>>>>>>>>>            // Call the driver function to fetch
19290>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19295>>>>>>>>>>>>>            
19295>>>>>>>>>>>>>            // If something went wrong, adjust the result
19295>>>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
19298>>>>>>>>>>>>>            
19298>>>>>>>>>>>>>            Set piLastcolumn to 0
19299>>>>>>>>>>>>>        End
19299>>>>>>>>>>>>>>
19299>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
19301>>>>>>>>>>>>>        
19301>>>>>>>>>>>>>        Function_Return iResult
19302>>>>>>>>>>>>>    End_Function
19303>>>>>>>>>>>>>    
19303>>>>>>>>>>>>>    // Fetch the next row and return an array with all column values
19303>>>>>>>>>>>>>    // Returns  : Array of strings with all column values
19303>>>>>>>>>>>>>    // Sets piFetchResult property
19303>>>>>>>>>>>>>    //   0    = No more data
19303>>>>>>>>>>>>>    //   <> 0 = Success
19303>>>>>>>>>>>>>    Function SQLFetchRowValues Returns String[]
19305>>>>>>>>>>>>>        
19305>>>>>>>>>>>>>        String[] asValues
19306>>>>>>>>>>>>>        
19306>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19306>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19307>>>>>>>>>>>>>        
19307>>>>>>>>>>>>>        Integer ihdbc
19307>>>>>>>>>>>>>        Integer ihstmt
19307>>>>>>>>>>>>>        Integer iResult iVoid
19307>>>>>>>>>>>>>        Integer iColCount iCol
19307>>>>>>>>>>>>>        String  sDrvrId
19307>>>>>>>>>>>>>        String  sEmpty
19307>>>>>>>>>>>>>        Longptr pResultWStr
19307>>>>>>>>>>>>>        WString wVariableResult
19307>>>>>>>>>>>>>        Integer iHasVariableDataType
19307>>>>>>>>>>>>>        Integer iLen
19307>>>>>>>>>>>>>        Integer iVariableBufferLength
19307>>>>>>>>>>>>>        
19307>>>>>>>>>>>>>        // Initialize
19307>>>>>>>>>>>>>        Move "" to sEmpty
19308>>>>>>>>>>>>>        Move 0  to iResult
19309>>>>>>>>>>>>>        
19309>>>>>>>>>>>>>        // Get the cli handles
19309>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19310>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19311>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19312>>>>>>>>>>>>>        
19312>>>>>>>>>>>>>        Get paSQLColumns to aSQLColumns
19313>>>>>>>>>>>>>        Get piColumnCount to iColCount
19314>>>>>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
19315>>>>>>>>>>>>>        
19315>>>>>>>>>>>>>        If (iHasVariableDataType) Begin
19317>>>>>>>>>>>>>            
19317>>>>>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
19318>>>>>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
19319>>>>>>>>>>>>>            
19319>>>>>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
19321>>>>>>>>>>>>>                // Allocate
19321>>>>>>>>>>>>>                Move (Repeat(' ', iLen)) to wVariableResult
19322>>>>>>>>>>>>>                
19322>>>>>>>>>>>>>                Set piVariableBufferLength to iLen
19323>>>>>>>>>>>>>                Set psVariableBuffer       to wVariableResult
19324>>>>>>>>>>>>>                
19324>>>>>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength
19325>>>>>>>>>>>>>            End
19325>>>>>>>>>>>>>>
19325>>>>>>>>>>>>>        End
19325>>>>>>>>>>>>>>
19325>>>>>>>>>>>>>        
19325>>>>>>>>>>>>>        // Fetch
19325>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19327>>>>>>>>>>>>>            Move (False) to Err
19328>>>>>>>>>>>>>            
19328>>>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19328>>>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
19328>>>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
19328>>>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19330>>>>>>>>>>>>>                // Setup function arguments
19330>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
19335>>>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
19336>>>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
19337>>>>>>>>>>>>>            End
19337>>>>>>>>>>>>>>
19337>>>>>>>>>>>>>            
19337>>>>>>>>>>>>>            // Call the driver function to fetch
19337>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
19342>>>>>>>>>>>>>            
19342>>>>>>>>>>>>>            // If something went wrong, adjust the result
19342>>>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
19345>>>>>>>>>>>>>            
19345>>>>>>>>>>>>>            If (iResult) Begin
19347>>>>>>>>>>>>>                For iCol from 1 to iColCount
19353>>>>>>>>>>>>>>
19353>>>>>>>>>>>>>                    
19353>>>>>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
19355>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sEmpty sEmpty iCol ;                            Result pResultWStr
19360>>>>>>>>>>>>>                            
19360>>>>>>>>>>>>>                        If (pResultWStr) Begin
19362>>>>>>>>>>>>>                            Move (CString(PointerToWString(pResultWStr))) to asValues[iCol - 1]
19363>>>>>>>>>>>>>                        End
19363>>>>>>>>>>>>>>
19363>>>>>>>>>>>>>                        Else Begin
19364>>>>>>>>>>>>>                            Move "" to asValues[iCol - 1]
19365>>>>>>>>>>>>>                        End
19365>>>>>>>>>>>>>>
19365>>>>>>>>>>>>>                        
19365>>>>>>>>>>>>>                    End
19365>>>>>>>>>>>>>>
19365>>>>>>>>>>>>>                    Else Begin
19366>>>>>>>>>>>>>                        Get psVariableBuffer       to wVariableResult
19367>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing iCol iVariableBufferLength (AddressOf(wVariableResult));                            Result iVoid
19372>>>>>>>>>>>>>                        
19372>>>>>>>>>>>>>                        Move (CString(wVariableResult)) to asValues[iCol - 1]
19373>>>>>>>>>>>>>                    End
19373>>>>>>>>>>>>>>
19373>>>>>>>>>>>>>                    
19373>>>>>>>>>>>>>                Loop
19374>>>>>>>>>>>>>>
19374>>>>>>>>>>>>>            End
19374>>>>>>>>>>>>>>
19374>>>>>>>>>>>>>        End
19374>>>>>>>>>>>>>>
19374>>>>>>>>>>>>>        Else Begin
19375>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
19376>>>>>>>>>>>>>        End
19376>>>>>>>>>>>>>>
19376>>>>>>>>>>>>>        
19376>>>>>>>>>>>>>        Set piFetchResult to iResult
19377>>>>>>>>>>>>>        
19377>>>>>>>>>>>>>        Function_Return asValues
19378>>>>>>>>>>>>>        
19378>>>>>>>>>>>>>    End_Function
19379>>>>>>>>>>>>>    
19379>>>>>>>>>>>>>    // Fetch a complete result set.
19379>>>>>>>>>>>>>    // Returns  : 2-dimensional array of strings with result set
19379>>>>>>>>>>>>>    // Sets piFetchResult property
19379>>>>>>>>>>>>>    //   0    = No more data
19379>>>>>>>>>>>>>    //   <> 0 = Success
19379>>>>>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][]
19381>>>>>>>>>>>>>        
19381>>>>>>>>>>>>>        String[][] asValues
19382>>>>>>>>>>>>>        
19382>>>>>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
19382>>>>>>>>>>>>>        String sDrvrId sEmpty sMax
19382>>>>>>>>>>>>>        Longptr pResultWStr
19382>>>>>>>>>>>>>        WString wResult
19382>>>>>>>>>>>>>        
19382>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19382>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19383>>>>>>>>>>>>>        WString  wVariableResult
19383>>>>>>>>>>>>>        Integer iHasVariableDataType
19383>>>>>>>>>>>>>        Integer iLen
19383>>>>>>>>>>>>>        Integer iVariableBufferLength
19383>>>>>>>>>>>>>        
19383>>>>>>>>>>>>>        // Initialize
19383>>>>>>>>>>>>>        Move "" to sEmpty
19384>>>>>>>>>>>>>        Move 0  to iResult
19385>>>>>>>>>>>>>        
19385>>>>>>>>>>>>>        // Get the cli handles
19385>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19386>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19387>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19388>>>>>>>>>>>>>        
19388>>>>>>>>>>>>>        // Fetch
19388>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19390>>>>>>>>>>>>>            Move False to Err
19391>>>>>>>>>>>>>            
19391>>>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19391>>>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
19391>>>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
19391>>>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19393>>>>>>>>>>>>>                // Setup function arguments
19393>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
19398>>>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
19399>>>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
19400>>>>>>>>>>>>>            End
19400>>>>>>>>>>>>>>
19400>>>>>>>>>>>>>            
19400>>>>>>>>>>>>>            Get piColumnCount to iColCount
19401>>>>>>>>>>>>>            If (iColCount) Begin
19403>>>>>>>>>>>>>                Get paSQLColumns to aSQLColumns
19404>>>>>>>>>>>>>                Get piHasVariableDataType to iHasVariableDataType
19405>>>>>>>>>>>>>                If (iHasVariableDataType) Begin
19407>>>>>>>>>>>>>                    Get piVariableBufferLength      to iVariableBufferLength
19408>>>>>>>>>>>>>                    Get piMaxVariableBufferLength   to iLen
19409>>>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
19411>>>>>>>>>>>>>                        // Allocate
19411>>>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to wVariableResult
19412>>>>>>>>>>>>>                        
19412>>>>>>>>>>>>>                        Set piVariableBufferLength to iLen
19413>>>>>>>>>>>>>                        Set psVariableBuffer       to wVariableResult
19414>>>>>>>>>>>>>                        
19414>>>>>>>>>>>>>                        Get piVariableBufferLength to iVariableBufferLength
19415>>>>>>>>>>>>>                    End
19415>>>>>>>>>>>>>>
19415>>>>>>>>>>>>>                    Else Begin
19416>>>>>>>>>>>>>                        Set psVariableBuffer       to wVariableResult
19417>>>>>>>>>>>>>                    End
19417>>>>>>>>>>>>>>
19417>>>>>>>>>>>>>                End
19417>>>>>>>>>>>>>>
19417>>>>>>>>>>>>>                
19417>>>>>>>>>>>>>                // Call the driver function to fetch
19417>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19422>>>>>>>>>>>>>                If (Err) ;                    Move 0 to iResult
19425>>>>>>>>>>>>>                
19425>>>>>>>>>>>>>                While (iResult <> 0)
19429>>>>>>>>>>>>>                    
19429>>>>>>>>>>>>>                    For iCol from 1 to (iColCount)
19435>>>>>>>>>>>>>>
19435>>>>>>>>>>>>>                        
19435>>>>>>>>>>>>>                        If (not(aSQLColumns[iCol].iVariableDataType)) Begin
19437>>>>>>>>>>>>>                            
19437>>>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback 0 ;                                Passing sEmpty sEmpty iCol ;                                Result pResultWStr
19442>>>>>>>>>>>>>                            
19442>>>>>>>>>>>>>                            If (pResultWStr) Begin
19444>>>>>>>>>>>>>                                Move (CString(PointerToWString(pResultWStr))) to asValues[iRow][iCol - 1]
19445>>>>>>>>>>>>>                            End
19445>>>>>>>>>>>>>>
19445>>>>>>>>>>>>>                            Else Begin
19446>>>>>>>>>>>>>                                Move "" to asValues[iRow][iCol - 1]
19447>>>>>>>>>>>>>                            End
19447>>>>>>>>>>>>>>
19447>>>>>>>>>>>>>                        End
19447>>>>>>>>>>>>>>
19447>>>>>>>>>>>>>                        Else Begin
19448>>>>>>>>>>>>>                            //Variable data
19448>>>>>>>>>>>>>                            Move wVariableResult to wResult
19449>>>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback 0 ;                                Passing iCol iVariableBufferLength (AddressOf(wResult)) ;                                Result iVoid
19454>>>>>>>>>>>>>                            
19454>>>>>>>>>>>>>                            Move (CString(wResult)) to asValues[iRow][iCol - 1]
19455>>>>>>>>>>>>>                        End
19455>>>>>>>>>>>>>>
19455>>>>>>>>>>>>>                    Loop
19456>>>>>>>>>>>>>>
19456>>>>>>>>>>>>>                    
19456>>>>>>>>>>>>>                    Increment iRow
19457>>>>>>>>>>>>>                    
19457>>>>>>>>>>>>>                    // Call the driver function to fetch
19457>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
19462>>>>>>>>>>>>>                    If (Err) ;                        Move 0 to iResult
19465>>>>>>>>>>>>>                    
19465>>>>>>>>>>>>>                Loop
19466>>>>>>>>>>>>>>
19466>>>>>>>>>>>>>            End
19466>>>>>>>>>>>>>>
19466>>>>>>>>>>>>>        End
19466>>>>>>>>>>>>>>
19466>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
19468>>>>>>>>>>>>>        
19468>>>>>>>>>>>>>        Set piFetchResult to iResult
19469>>>>>>>>>>>>>        
19469>>>>>>>>>>>>>        Function_Return asValues
19470>>>>>>>>>>>>>    End_Function
19471>>>>>>>>>>>>>    
19471>>>>>>>>>>>>>    // Get the next column
19471>>>>>>>>>>>>>    Function SQLNextColumn Returns String
19473>>>>>>>>>>>>>        Integer iCol
19473>>>>>>>>>>>>>        String  sResult
19473>>>>>>>>>>>>>        
19473>>>>>>>>>>>>>        Get piLastColumn to iCol
19474>>>>>>>>>>>>>        Increment iCol
19475>>>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
19476>>>>>>>>>>>>>        Set piLastColumn to iCol
19477>>>>>>>>>>>>>        
19477>>>>>>>>>>>>>        Function_Return sResult
19478>>>>>>>>>>>>>    End_Function
19479>>>>>>>>>>>>>    
19479>>>>>>>>>>>>>    
19479>>>>>>>>>>>>>    // Returns the native type of a column
19479>>>>>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
19481>>>>>>>>>>>>>        Integer ihdbc
19481>>>>>>>>>>>>>        Integer ihstmt
19481>>>>>>>>>>>>>        String  sDrvrId
19481>>>>>>>>>>>>>        Integer iSQLType
19481>>>>>>>>>>>>>        Integer iColumns
19481>>>>>>>>>>>>>        
19481>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19481>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19482>>>>>>>>>>>>>        
19482>>>>>>>>>>>>>        // Get the cli handles
19482>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19483>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19484>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19485>>>>>>>>>>>>>        
19485>>>>>>>>>>>>>        // Get the value
19485>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19487>>>>>>>>>>>>>            
19487>>>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19488>>>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19489>>>>>>>>>>>>>            
19489>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19491>>>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
19492>>>>>>>>>>>>>            End
19492>>>>>>>>>>>>>>
19492>>>>>>>>>>>>>            Else Begin
19493>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
19494>>>>>>>>>>>>>            End
19494>>>>>>>>>>>>>>
19494>>>>>>>>>>>>>        End
19494>>>>>>>>>>>>>>
19494>>>>>>>>>>>>>        Else Begin
19495>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
19496>>>>>>>>>>>>>        End
19496>>>>>>>>>>>>>>
19496>>>>>>>>>>>>>        
19496>>>>>>>>>>>>>        Function_Return iSQLType
19497>>>>>>>>>>>>>    End_Function
19498>>>>>>>>>>>>>    
19498>>>>>>>>>>>>>    // Returns the size (max length) of a column
19498>>>>>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
19500>>>>>>>>>>>>>        Integer ihdbc
19500>>>>>>>>>>>>>        Integer ihstmt
19500>>>>>>>>>>>>>        String  sDrvrId
19500>>>>>>>>>>>>>        Integer iSQLSize
19500>>>>>>>>>>>>>        Integer iColumns
19500>>>>>>>>>>>>>        
19500>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19500>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19501>>>>>>>>>>>>>        
19501>>>>>>>>>>>>>        // Get the cli handles
19501>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19502>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19503>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19504>>>>>>>>>>>>>        
19504>>>>>>>>>>>>>        // Get the value
19504>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19506>>>>>>>>>>>>>            
19506>>>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19507>>>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19508>>>>>>>>>>>>>            
19508>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19510>>>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
19511>>>>>>>>>>>>>            End
19511>>>>>>>>>>>>>>
19511>>>>>>>>>>>>>            Else Begin
19512>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
19513>>>>>>>>>>>>>            End
19513>>>>>>>>>>>>>>
19513>>>>>>>>>>>>>        End
19513>>>>>>>>>>>>>>
19513>>>>>>>>>>>>>        Else Begin
19514>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
19515>>>>>>>>>>>>>        End
19515>>>>>>>>>>>>>>
19515>>>>>>>>>>>>>        
19515>>>>>>>>>>>>>        Function_Return iSQLSize
19516>>>>>>>>>>>>>    End_Function
19517>>>>>>>>>>>>>    
19517>>>>>>>>>>>>>    //  Returns 1 for variable length datatypes.
19517>>>>>>>>>>>>>    //  For example SQL Server varchar(max) or text type
19517>>>>>>>>>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
19517>>>>>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
19519>>>>>>>>>>>>>        Integer ihdbc
19519>>>>>>>>>>>>>        Integer ihstmt
19519>>>>>>>>>>>>>        String  sDrvrId
19519>>>>>>>>>>>>>        Integer iVariableDataType
19519>>>>>>>>>>>>>        Integer iColumns
19519>>>>>>>>>>>>>        
19519>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19519>>>>>>>>>>>>>        tSQLColumn[] aSQLColumns
19520>>>>>>>>>>>>>        
19520>>>>>>>>>>>>>        // Get the cli handles
19520>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19521>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19522>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19523>>>>>>>>>>>>>        
19523>>>>>>>>>>>>>        // Get the value
19523>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19525>>>>>>>>>>>>>            
19525>>>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
19526>>>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
19527>>>>>>>>>>>>>            
19527>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
19529>>>>>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
19530>>>>>>>>>>>>>            End
19530>>>>>>>>>>>>>>
19530>>>>>>>>>>>>>            Else Begin
19531>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
19532>>>>>>>>>>>>>            End
19532>>>>>>>>>>>>>>
19532>>>>>>>>>>>>>        End
19532>>>>>>>>>>>>>>
19532>>>>>>>>>>>>>        Else Begin
19533>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
19534>>>>>>>>>>>>>        End
19534>>>>>>>>>>>>>>
19534>>>>>>>>>>>>>        
19534>>>>>>>>>>>>>        Function_Return iVariableDataType
19535>>>>>>>>>>>>>    End_Function
19536>>>>>>>>>>>>>    
19536>>>>>>>>>>>>>    
19536>>>>>>>>>>>>>    // Return the value of a column in a fetched row of a given
19536>>>>>>>>>>>>>    // statement.
19536>>>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
19538>>>>>>>>>>>>>        Integer ihdbc
19538>>>>>>>>>>>>>        Integer ihstmt
19538>>>>>>>>>>>>>        String  sDrvrId sResult
19538>>>>>>>>>>>>>        Longptr pResultWStr
19538>>>>>>>>>>>>>        
19538>>>>>>>>>>>>>        Integer iVoid
19538>>>>>>>>>>>>>        Integer iColSize
19538>>>>>>>>>>>>>        Integer iColPrecision
19538>>>>>>>>>>>>>        String  sEmpty
19538>>>>>>>>>>>>>        Integer bLegalColumn
19538>>>>>>>>>>>>>        
19538>>>>>>>>>>>>>        // Initialize
19538>>>>>>>>>>>>>        Move "" to sResult
19539>>>>>>>>>>>>>        
19539>>>>>>>>>>>>>        // Get the cli handles
19539>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19540>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19541>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19542>>>>>>>>>>>>>        
19542>>>>>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19542>>>>>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
19542>>>>>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
19542>>>>>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19544>>>>>>>>>>>>>            // Setup function arguments
19544>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
19549>>>>>>>>>>>>>            Move ihstmt to giLastSQLhstmt
19550>>>>>>>>>>>>>            Move ihdbc to giLastSQLhdbc
19551>>>>>>>>>>>>>        End
19551>>>>>>>>>>>>>>
19551>>>>>>>>>>>>>        
19551>>>>>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19553>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result pResultWStr
19558>>>>>>>>>>>>>            
19558>>>>>>>>>>>>>            If (pResultWStr) Begin
19560>>>>>>>>>>>>>                Move (PointerToWString(pResultWStr)) to sResult
19561>>>>>>>>>>>>>            End
19561>>>>>>>>>>>>>>
19561>>>>>>>>>>>>>            Else Begin
19562>>>>>>>>>>>>>                Move "" to sResult
19563>>>>>>>>>>>>>            End
19563>>>>>>>>>>>>>>
19563>>>>>>>>>>>>>        End
19563>>>>>>>>>>>>>>
19563>>>>>>>>>>>>>        Else Begin
19564>>>>>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
19565>>>>>>>>>>>>>        End
19565>>>>>>>>>>>>>>
19565>>>>>>>>>>>>>        
19565>>>>>>>>>>>>>        Function_Return sResult
19566>>>>>>>>>>>>>        
19566>>>>>>>>>>>>>    End_Function
19567>>>>>>>>>>>>>    
19567>>>>>>>>>>>>>    // Add a file to the files used to place the statement result in.
19567>>>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
19569>>>>>>>>>>>>>        Integer ihdbc
19569>>>>>>>>>>>>>        Integer ihstmt
19569>>>>>>>>>>>>>        Integer iVoid
19569>>>>>>>>>>>>>        String  sDrvrId
19569>>>>>>>>>>>>>        String  sFileType
19569>>>>>>>>>>>>>        Integer bIsOpen
19569>>>>>>>>>>>>>        
19569>>>>>>>>>>>>>        // Get the cli handles
19569>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19570>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19571>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19572>>>>>>>>>>>>>        
19572>>>>>>>>>>>>>        // If a file number is not passed see if we can use the statement's
19572>>>>>>>>>>>>>        // default file number which is usually set with SetFileConnection
19572>>>>>>>>>>>>>        If (iFileNum = 0) Begin
19574>>>>>>>>>>>>>            Get piBindFile to iFileNum
19575>>>>>>>>>>>>>            If (iFileNum = 0) Begin
19577>>>>>>>>>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
19577>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
19578>>>>>>>>>>>>>                
19578>>>>>>>>>>>>>                Move 0 to SQLResult
19579>>>>>>>>>>>>>                Procedure_Return
19580>>>>>>>>>>>>>            End
19580>>>>>>>>>>>>>>
19580>>>>>>>>>>>>>        End
19580>>>>>>>>>>>>>>
19580>>>>>>>>>>>>>        
19580>>>>>>>>>>>>>        // Bind the file
19580>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19582>>>>>>>>>>>>>            // Chek if the file is open
19582>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
19585>>>>>>>>>>>>>            If (bIsOpen) Begin
19587>>>>>>>>>>>>>                // Check if the file has the correct type
19587>>>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
19590>>>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
19592>>>>>>>>>>>>>                    // Call the driver function to add a file to a statement
19592>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
19597>>>>>>>>>>>>>                End
19597>>>>>>>>>>>>>>
19597>>>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
19599>>>>>>>>>>>>>            End
19599>>>>>>>>>>>>>>
19599>>>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
19601>>>>>>>>>>>>>        End
19601>>>>>>>>>>>>>>
19601>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
19603>>>>>>>>>>>>>    End_Procedure
19604>>>>>>>>>>>>>    
19604>>>>>>>>>>>>>    
19604>>>>>>>>>>>>>    
19604>>>>>>>>>>>>>    // Get data of a column.                                  
19604>>>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
19606>>>>>>>>>>>>>        Integer ihdbc
19606>>>>>>>>>>>>>        Integer ihstmt
19606>>>>>>>>>>>>>        Integer iVoid
19606>>>>>>>>>>>>>        Integer iColSize
19606>>>>>>>>>>>>>        Integer iResult
19606>>>>>>>>>>>>>        String  sDrvrId
19606>>>>>>>>>>>>>        WString wResult
19606>>>>>>>>>>>>>        String  sEmpty
19606>>>>>>>>>>>>>        Integer bLegalColumn
19606>>>>>>>>>>>>>        
19606>>>>>>>>>>>>>        Integer iVariableBufferLength
19606>>>>>>>>>>>>>        
19606>>>>>>>>>>>>>        // Initialize
19606>>>>>>>>>>>>>        Move "" to sEmpty
19607>>>>>>>>>>>>>        Move 0 to iResult
19608>>>>>>>>>>>>>        
19608>>>>>>>>>>>>>        // Get the cli handles
19608>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19609>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19610>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19611>>>>>>>>>>>>>        
19611>>>>>>>>>>>>>        // Get the data
19611>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19613>>>>>>>>>>>>>            // Check if the column exists
19613>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19615>>>>>>>>>>>>>                If (iLen = 0) Begin
19617>>>>>>>>>>>>>                    Get SQLColumnValue iCol to wResult
19618>>>>>>>>>>>>>                End
19618>>>>>>>>>>>>>>
19618>>>>>>>>>>>>>                Else Begin
19619>>>>>>>>>>>>>                    // Add 1 for string terminator
19619>>>>>>>>>>>>>                    Move (iLen + 1) to iLen
19620>>>>>>>>>>>>>                    
19620>>>>>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
19621>>>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
19623>>>>>>>>>>>>>                        // Allocate
19623>>>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to wResult
19624>>>>>>>>>>>>>                        
19624>>>>>>>>>>>>>                        Set piVariableBufferLength to iLen
19625>>>>>>>>>>>>>                        Set psVariableBuffer       to wResult
19626>>>>>>>>>>>>>                    End
19626>>>>>>>>>>>>>>
19626>>>>>>>>>>>>>                    Else Begin
19627>>>>>>>>>>>>>                        Get psVariableBuffer       to wResult
19628>>>>>>>>>>>>>                    End
19628>>>>>>>>>>>>>>
19628>>>>>>>>>>>>>                    
19628>>>>>>>>>>>>>                    
19628>>>>>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19628>>>>>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
19628>>>>>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
19628>>>>>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19630>>>>>>>>>>>>>                        // Setup function arguments
19630>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
19635>>>>>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
19636>>>>>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
19637>>>>>>>>>>>>>                    End
19637>>>>>>>>>>>>>>
19637>>>>>>>>>>>>>                    
19637>>>>>>>>>>>>>                    Move False to Err
19638>>>>>>>>>>>>>                    // Call the driver function to get the data
19638>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing iCol iLen (AddressOf(wResult)) ;                        Result iResult
19643>>>>>>>>>>>>>                    
19643>>>>>>>>>>>>>                    // If something went wrong, adjust the result
19643>>>>>>>>>>>>>                    If (Err) Begin
19645>>>>>>>>>>>>>                        Move 0 to iResult
19646>>>>>>>>>>>>>                    End
19646>>>>>>>>>>>>>>
19646>>>>>>>>>>>>>                    
19646>>>>>>>>>>>>>                    // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
19646>>>>>>>>>>>>>                    If (iResult = -4) Begin
19648>>>>>>>>>>>>>                        Move (SizeOfWString(wResult)) to iResult
19649>>>>>>>>>>>>>                    End
19649>>>>>>>>>>>>>>
19649>>>>>>>>>>>>>                End
19649>>>>>>>>>>>>>>
19649>>>>>>>>>>>>>            End
19649>>>>>>>>>>>>>>
19649>>>>>>>>>>>>>            Else Begin
19650>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
19651>>>>>>>>>>>>>            End
19651>>>>>>>>>>>>>>
19651>>>>>>>>>>>>>        End
19651>>>>>>>>>>>>>>
19651>>>>>>>>>>>>>        Else Begin
19652>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
19653>>>>>>>>>>>>>        End
19653>>>>>>>>>>>>>>
19653>>>>>>>>>>>>>        
19653>>>>>>>>>>>>>        // Fill global result
19653>>>>>>>>>>>>>        If (iResult > 0) Begin
19655>>>>>>>>>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
19656>>>>>>>>>>>>>        End
19656>>>>>>>>>>>>>>
19656>>>>>>>>>>>>>        Else Begin
19657>>>>>>>>>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
19658>>>>>>>>>>>>>        End
19658>>>>>>>>>>>>>>
19658>>>>>>>>>>>>>        
19658>>>>>>>>>>>>>        Function_Return (CString(wResult))
19659>>>>>>>>>>>>>    End_Function
19660>>>>>>>>>>>>>
19660>>>>>>>>>>>>>    // SQLGetDataToUChar (SQLGetData returning uchar array)
19660>>>>>>>>>>>>>    // Use for binary data and for character data containing Unicode non-bmp characters
19660>>>>>>>>>>>>>    Function SQLGetDataToUChar Integer iCol Integer iLen Returns UChar[]
19662>>>>>>>>>>>>>        Integer ihdbc
19662>>>>>>>>>>>>>        Integer ihstmt
19662>>>>>>>>>>>>>        Integer iVoid
19662>>>>>>>>>>>>>        Integer iColSize
19662>>>>>>>>>>>>>        Integer iResult
19662>>>>>>>>>>>>>        String  sDrvrId
19662>>>>>>>>>>>>>        UChar[] uaResult
19663>>>>>>>>>>>>>        
19663>>>>>>>>>>>>>        Integer iSQLType
19663>>>>>>>>>>>>>        Integer iBinaryType
19663>>>>>>>>>>>>>        Integer iLenArray
19663>>>>>>>>>>>>>        Integer iResizeSize
19663>>>>>>>>>>>>>        
19663>>>>>>>>>>>>>        Move 0 to iResult
19664>>>>>>>>>>>>>        
19664>>>>>>>>>>>>>        // Get the cli handles
19664>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19665>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19666>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19667>>>>>>>>>>>>>        
19667>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19669>>>>>>>>>>>>>            // Check if the column exists
19669>>>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
19671>>>>>>>>>>>>>                            
19671>>>>>>>>>>>>>                Get SQLColumnType iCol to iSQLType
19672>>>>>>>>>>>>>                If ( (iSQLType = SQL_BINARY) or (iSQLType = SQL_VARBINARY) or (iSQLType = SQL_LONGVARBINARY) ) Begin
19674>>>>>>>>>>>>>                    Move 1 to iBinaryType
19675>>>>>>>>>>>>>                End
19675>>>>>>>>>>>>>>
19675>>>>>>>>>>>>>                Else Begin
19676>>>>>>>>>>>>>                    Move 0 to iBinaryType 
19677>>>>>>>>>>>>>                End
19677>>>>>>>>>>>>>>
19677>>>>>>>>>>>>>    
19677>>>>>>>>>>>>>                If (iBinaryType) Begin
19679>>>>>>>>>>>>>                    Move (ResizeArray(uaResult,iLen)) to uaResult
19680>>>>>>>>>>>>>                End
19680>>>>>>>>>>>>>>
19680>>>>>>>>>>>>>                Else Begin
19681>>>>>>>>>>>>>                    // Character type
19681>>>>>>>>>>>>>                    // returned as wstring (2 bytes per character)
19681>>>>>>>>>>>>>                    // Add 1 for string terminator
19681>>>>>>>>>>>>>                    Move (iLen + 1) to iLen
19682>>>>>>>>>>>>>                    Move (iLen * 2) to iLenArray // wstring 2 bytes per char
19683>>>>>>>>>>>>>                    Move (ResizeArray(uaResult,iLenArray)) to uaResult
19684>>>>>>>>>>>>>                End
19684>>>>>>>>>>>>>>
19684>>>>>>>>>>>>>
19684>>>>>>>>>>>>>                // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
19684>>>>>>>>>>>>>                // in the next FUNC_SQLCOLUMNVALUE call.
19684>>>>>>>>>>>>>                If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
19686>>>>>>>>>>>>>                    // Setup function arguments
19686>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback 0 ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
19691>>>>>>>>>>>>>                    Move ihstmt to giLastSQLhstmt
19692>>>>>>>>>>>>>                    Move ihdbc to giLastSQLhdbc
19693>>>>>>>>>>>>>                End
19693>>>>>>>>>>>>>>
19693>>>>>>>>>>>>>                
19693>>>>>>>>>>>>>                Move False to Err
19694>>>>>>>>>>>>>                
19694>>>>>>>>>>>>>                // Call the driver function to get the data
19694>>>>>>>>>>>>>                // iResult will be the length of the data in bytes 
19694>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                    Callback Self ;                    Passing iCol iLen (AddressOf(uaResult[0])) ;                    Result iResult
19699>>>>>>>>>>>>>                
19699>>>>>>>>>>>>>                // If something went wrong, adjust the result
19699>>>>>>>>>>>>>                If (Err) Begin
19701>>>>>>>>>>>>>                    Move 0 to iResult
19702>>>>>>>>>>>>>                End
19702>>>>>>>>>>>>>>
19702>>>>>>>>>>>>>                
19702>>>>>>>>>>>>>                // SQL_NO_TOTAL (-4) Not all data retrieved. Unknown how much is left. 
19702>>>>>>>>>>>>>                If (iResult = -4) Begin
19704>>>>>>>>>>>>>                    Move (SizeOfArray(uaResult)) to iResult
19705>>>>>>>>>>>>>                End
19705>>>>>>>>>>>>>>
19705>>>>>>>>>>>>>                
19705>>>>>>>>>>>>>                If (iBinaryType) Begin
19707>>>>>>>>>>>>>                    If (iResult < iLen) Begin
19709>>>>>>>>>>>>>                        Move (ResizeArray(uaResult,iResult)) to uaResult
19710>>>>>>>>>>>>>                    End
19710>>>>>>>>>>>>>>
19710>>>>>>>>>>>>>                End
19710>>>>>>>>>>>>>>
19710>>>>>>>>>>>>>                Else Begin
19711>>>>>>>>>>>>>                    // Character data
19711>>>>>>>>>>>>>                    //   iResult has length of data in bytes (without zero terminator)
19711>>>>>>>>>>>>>                    //   uaResult will have data + zero terminator
19711>>>>>>>>>>>>>                    If (iResult < (iLenArray - 2) ) Begin
19713>>>>>>>>>>>>>                        // Received less than requested, strip off trailing zeroes.
19713>>>>>>>>>>>>>                        Move iResult to iResizeSize
19714>>>>>>>>>>>>>                    End
19714>>>>>>>>>>>>>>
19714>>>>>>>>>>>>>                    Else Begin
19715>>>>>>>>>>>>>                        // Strip off zero terminator
19715>>>>>>>>>>>>>                        Move (iLenArray - 2) to iResizeSize
19716>>>>>>>>>>>>>                    End
19716>>>>>>>>>>>>>>
19716>>>>>>>>>>>>>                    
19716>>>>>>>>>>>>>                    Move (ResizeArray(uaResult,iResizeSize)) to uaResult
19717>>>>>>>>>>>>>                    
19717>>>>>>>>>>>>>                End
19717>>>>>>>>>>>>>>
19717>>>>>>>>>>>>>            End
19717>>>>>>>>>>>>>>
19717>>>>>>>>>>>>>            Else Begin
19718>>>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
19719>>>>>>>>>>>>>            End
19719>>>>>>>>>>>>>>
19719>>>>>>>>>>>>>        End
19719>>>>>>>>>>>>>>
19719>>>>>>>>>>>>>        Else Begin
19720>>>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
19721>>>>>>>>>>>>>        End
19721>>>>>>>>>>>>>>
19721>>>>>>>>>>>>>        
19721>>>>>>>>>>>>>        // Fill global result
19721>>>>>>>>>>>>>        If (iResult > 0) Begin
19723>>>>>>>>>>>>>            Move 1 to SQLResult // SQLResult == 1 : Something was found
19724>>>>>>>>>>>>>        End
19724>>>>>>>>>>>>>>
19724>>>>>>>>>>>>>        Else Begin
19725>>>>>>>>>>>>>           Move 0 to SQLResult // SQLResult == 0 : no (more) data found
19726>>>>>>>>>>>>>        End
19726>>>>>>>>>>>>>>
19726>>>>>>>>>>>>>        
19726>>>>>>>>>>>>>        Function_Return uaResult
19727>>>>>>>>>>>>>
19727>>>>>>>>>>>>>    End_Function
19728>>>>>>>>>>>>>    
19728>>>>>>>>>>>>>    
19728>>>>>>>>>>>>>    // Map a column name to a number, if the name id not found no
19728>>>>>>>>>>>>>    // error is generated the returned number will be 0 (zero) in
19728>>>>>>>>>>>>>    // that case
19728>>>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
19730>>>>>>>>>>>>>        Integer ihdbc
19730>>>>>>>>>>>>>        Integer ihstmt
19730>>>>>>>>>>>>>        Integer iNumColumns
19730>>>>>>>>>>>>>        Integer iColCount
19730>>>>>>>>>>>>>        Integer iColNum
19730>>>>>>>>>>>>>        String  sDrvrId
19730>>>>>>>>>>>>>        String  sCurColName
19730>>>>>>>>>>>>>        
19730>>>>>>>>>>>>>        // Get the cli handles
19730>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19731>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19732>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19733>>>>>>>>>>>>>        
19733>>>>>>>>>>>>>        // Get the number by looping through the column names
19733>>>>>>>>>>>>>        Move 0 to iColNum
19734>>>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
19735>>>>>>>>>>>>>        For iColCount from 1 to iNumColumns
19741>>>>>>>>>>>>>>
19741>>>>>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
19742>>>>>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
19745>>>>>>>>>>>>>            
19745>>>>>>>>>>>>>            If (iColNum) ;                Break
19748>>>>>>>>>>>>>        Loop
19749>>>>>>>>>>>>>>
19749>>>>>>>>>>>>>        
19749>>>>>>>>>>>>>        Function_Return iColNum
19750>>>>>>>>>>>>>    End_Function
19751>>>>>>>>>>>>>    
19751>>>>>>>>>>>>>    
19751>>>>>>>>>>>>>    // SQLStmtAttribute
19751>>>>>>>>>>>>>    // Moved to SQLGetStatementAttribute. 
19751>>>>>>>>>>>>>    // This function is still here for backward compatibility.
19751>>>>>>>>>>>>>
19751>>>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
19753>>>>>>>>>>>>>        String  sResult
19753>>>>>>>>>>>>>
19753>>>>>>>>>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
19754>>>>>>>>>>>>>        
19754>>>>>>>>>>>>>        Function_Return sResult
19755>>>>>>>>>>>>>    End_Function
19756>>>>>>>>>>>>>
19756>>>>>>>>>>>>> 
19756>>>>>>>>>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
19758>>>>>>>>>>>>>        Integer ihdbc
19758>>>>>>>>>>>>>        Integer ihstmt
19758>>>>>>>>>>>>>        String  sResult
19758>>>>>>>>>>>>>        String  sDrvrId
19758>>>>>>>>>>>>>        
19758>>>>>>>>>>>>>        // Initialize
19758>>>>>>>>>>>>>        Move "" to sResult
19759>>>>>>>>>>>>>        
19759>>>>>>>>>>>>>        // Get the cli handles
19759>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19760>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19761>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19762>>>>>>>>>>>>>        
19762>>>>>>>>>>>>>        // Get the attribute
19762>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
19765>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
19767>>>>>>>>>>>>>        
19767>>>>>>>>>>>>>        Function_Return sResult
19768>>>>>>>>>>>>>    End_Function
19769>>>>>>>>>>>>>
19769>>>>>>>>>>>>>    
19769>>>>>>>>>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
19771>>>>>>>>>>>>>
19771>>>>>>>>>>>>>        Integer ihdbc
19771>>>>>>>>>>>>>        Integer ihstmt
19771>>>>>>>>>>>>>        String  sDrvrId
19771>>>>>>>>>>>>>        
19771>>>>>>>>>>>>>        Integer iLen
19771>>>>>>>>>>>>>        Integer bLegalAttrib
19771>>>>>>>>>>>>>        Integer iVoid
19771>>>>>>>>>>>>>        Integer iAttribValue
19771>>>>>>>>>>>>>
19771>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19772>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19773>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19774>>>>>>>>>>>>>        
19774>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19776>>>>>>>>>>>>>            Case Begin
19776>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
19778>>>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
19779>>>>>>>>>>>>>                    Break
19780>>>>>>>>>>>>>                    
19780>>>>>>>>>>>>>                Case Else
19780>>>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
19781>>>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
19782>>>>>>>>>>>>>            Case End
19782>>>>>>>>>>>>>
19782>>>>>>>>>>>>>            If (bLegalAttrib) Begin
19784>>>>>>>>>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
19786>>>>>>>>>>>>>                    
19786>>>>>>>>>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
19787>>>>>>>>>>>>>                    Case Begin
19787>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
19789>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
19792>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
19795>>>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
19798>>>>>>>>>>>>>                            Break
19799>>>>>>>>>>>>>                            
19799>>>>>>>>>>>>>                        Case Else
19799>>>>>>>>>>>>>                            Move DFFALSE to bLegalAttrib
19800>>>>>>>>>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
19801>>>>>>>>>>>>>
19801>>>>>>>>>>>>>                    Case End
19801>>>>>>>>>>>>>                End
19801>>>>>>>>>>>>>>
19801>>>>>>>>>>>>>            End
19801>>>>>>>>>>>>>>
19801>>>>>>>>>>>>>
19801>>>>>>>>>>>>>            
19801>>>>>>>>>>>>>            If (bLegalAttrib) Begin
19803>>>>>>>>>>>>>                
19803>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
19808>>>>>>>>>>>>>                
19808>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
19813>>>>>>>>>>>>>            End
19813>>>>>>>>>>>>>>
19813>>>>>>>>>>>>>        End
19813>>>>>>>>>>>>>>
19813>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
19815>>>>>>>>>>>>>        
19815>>>>>>>>>>>>>        
19815>>>>>>>>>>>>>        
19815>>>>>>>>>>>>>    End_Procedure
19816>>>>>>>>>>>>>    
19816>>>>>>>>>>>>>    
19816>>>>>>>>>>>>>    
19816>>>>>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
19818>>>>>>>>>>>>>        String  sResult
19818>>>>>>>>>>>>>        Integer iLen
19818>>>>>>>>>>>>>        Integer bLegalAttrib
19818>>>>>>>>>>>>>        
19818>>>>>>>>>>>>>        // Initialize
19818>>>>>>>>>>>>>        Move ""     to sResult
19819>>>>>>>>>>>>>        
19819>>>>>>>>>>>>>        // Get the attribute
19819>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19821>>>>>>>>>>>>>            Case Begin
19821>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
19823>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
19826>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
19829>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
19832>>>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
19835>>>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
19836>>>>>>>>>>>>>                    Break
19837>>>>>>>>>>>>>                    
19837>>>>>>>>>>>>>                Case Else
19837>>>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
19838>>>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
19839>>>>>>>>>>>>>            Case End
19839>>>>>>>>>>>>>            
19839>>>>>>>>>>>>>            If (bLegalAttrib) Begin
19841>>>>>>>>>>>>>                // Setup function arguments
19841>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
19846>>>>>>>>>>>>>            End
19846>>>>>>>>>>>>>>
19846>>>>>>>>>>>>>        End
19846>>>>>>>>>>>>>>
19846>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
19848>>>>>>>>>>>>>        
19848>>>>>>>>>>>>>        Function_Return sResult
19849>>>>>>>>>>>>>    End_Function
19850>>>>>>>>>>>>>    
19850>>>>>>>>>>>>>    
19850>>>>>>>>>>>>>    
19850>>>>>>>>>>>>>    // Get a column's attribute
19850>>>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
19852>>>>>>>>>>>>>        Integer ihdbc
19852>>>>>>>>>>>>>        Integer ihstmt
19852>>>>>>>>>>>>>        String  sResult
19852>>>>>>>>>>>>>        String  sDrvrId
19852>>>>>>>>>>>>>        
19852>>>>>>>>>>>>>        // Initialize
19852>>>>>>>>>>>>>        Move "" to sResult
19853>>>>>>>>>>>>>        
19853>>>>>>>>>>>>>        // Get the cli handles
19853>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19854>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19855>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19856>>>>>>>>>>>>>        
19856>>>>>>>>>>>>>        // Get the attribute
19856>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
19859>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
19861>>>>>>>>>>>>>        
19861>>>>>>>>>>>>>        Function_Return sResult
19862>>>>>>>>>>>>>    End_Function
19863>>>>>>>>>>>>>    
19863>>>>>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
19865>>>>>>>>>>>>>        String  sResult
19865>>>>>>>>>>>>>        String  sEmpty
19865>>>>>>>>>>>>>        Integer bIsStringAttribute
19865>>>>>>>>>>>>>        Integer iLen
19865>>>>>>>>>>>>>        Integer iVoid
19865>>>>>>>>>>>>>        Integer bLegalAttrib
19865>>>>>>>>>>>>>        Integer bLegalColumn
19865>>>>>>>>>>>>>        
19865>>>>>>>>>>>>>        // Initialize
19865>>>>>>>>>>>>>        Move "" to sResult
19866>>>>>>>>>>>>>        Move "" to sEmpty
19867>>>>>>>>>>>>>        Move 0  to iLen
19868>>>>>>>>>>>>>        
19868>>>>>>>>>>>>>        // Get the attribute
19868>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19870>>>>>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
19871>>>>>>>>>>>>>            If (bLegalColumn) Begin
19873>>>>>>>>>>>>>                // Determine the atributes type
19873>>>>>>>>>>>>>                Case Begin
19873>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
19875>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
19878>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
19881>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
19884>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
19887>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
19890>>>>>>>>>>>>>                        Move DFFALSE to bIsStringAttribute
19891>>>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
19892>>>>>>>>>>>>>                        Break
19893>>>>>>>>>>>>>                        
19893>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
19896>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
19899>>>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
19902>>>>>>>>>>>>>                        Move DFTRUE to bIsStringAttribute
19903>>>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
19904>>>>>>>>>>>>>                        Break
19905>>>>>>>>>>>>>                        
19905>>>>>>>>>>>>>                    Case Else
19905>>>>>>>>>>>>>                        Move DFFALSE to bLegalAttrib
19906>>>>>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
19907>>>>>>>>>>>>>                Case End
19907>>>>>>>>>>>>>                
19907>>>>>>>>>>>>>                If (bLegalAttrib) Begin
19909>>>>>>>>>>>>>                    // Setup function arguments
19909>>>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
19914>>>>>>>>>>>>>                    
19914>>>>>>>>>>>>>                    If (bIsStringAttribute) Begin
19916>>>>>>>>>>>>>                        // Call the driver function to get the data length
19916>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
19921>>>>>>>>>>>>>                        
19921>>>>>>>>>>>>>                        If (iLen) Begin
19923>>>>>>>>>>>>>                            // Allocate
19923>>>>>>>>>>>>>                            Move (Repeat(' ', iLen)) to sResult
19924>>>>>>>>>>>>>                            
19924>>>>>>>>>>>>>                            // Call the driver function to get the name
19924>>>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
19929>>>>>>>>>>>>>                        End
19929>>>>>>>>>>>>>>
19929>>>>>>>>>>>>>                    End
19929>>>>>>>>>>>>>>
19929>>>>>>>>>>>>>                    Else Begin
19930>>>>>>>>>>>>>                        // get the attribute
19930>>>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
19935>>>>>>>>>>>>>                    End
19935>>>>>>>>>>>>>>
19935>>>>>>>>>>>>>                End
19935>>>>>>>>>>>>>>
19935>>>>>>>>>>>>>            End
19935>>>>>>>>>>>>>>
19935>>>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
19937>>>>>>>>>>>>>        End
19937>>>>>>>>>>>>>>
19937>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
19939>>>>>>>>>>>>>        
19939>>>>>>>>>>>>>        Function_Return sResult
19940>>>>>>>>>>>>>    End_Function
19941>>>>>>>>>>>>>    
19941>>>>>>>>>>>>>    
19941>>>>>>>>>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
19941>>>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
19943>>>>>>>>>>>>>        Integer ihdbc
19943>>>>>>>>>>>>>        Integer ihstmt
19943>>>>>>>>>>>>>        String  sDrvrId
19943>>>>>>>>>>>>>        Integer iVoid
19943>>>>>>>>>>>>>        String  sSchema
19943>>>>>>>>>>>>>        String  sEmpty
19943>>>>>>>>>>>>>        
19943>>>>>>>>>>>>>        // Initialize
19943>>>>>>>>>>>>>        Move "" to sEmpty
19944>>>>>>>>>>>>>        
19944>>>>>>>>>>>>>        // Get the cli handles
19944>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19945>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19946>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19947>>>>>>>>>>>>>        
19947>>>>>>>>>>>>>        // Call the procedure
19947>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19949>>>>>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
19952>>>>>>>>>>>>>            Else ;                Move "" to sSchema
19954>>>>>>>>>>>>>            
19954>>>>>>>>>>>>>            If (sSchema <> "") Begin
19956>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
19961>>>>>>>>>>>>>            End
19961>>>>>>>>>>>>>>
19961>>>>>>>>>>>>>            
19961>>>>>>>>>>>>>            // Call the procedure
19961>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
19966>>>>>>>>>>>>>            
19966>>>>>>>>>>>>>            Set piLastArgument to 0
19967>>>>>>>>>>>>>        End
19967>>>>>>>>>>>>>>
19967>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
19969>>>>>>>>>>>>>    End_Procedure
19970>>>>>>>>>>>>>    
19970>>>>>>>>>>>>>    // Pass the next argument
19970>>>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
19972>>>>>>>>>>>>>        Integer iArgnum
19972>>>>>>>>>>>>>        
19972>>>>>>>>>>>>>        Get piLastArgument to iArgnum
19973>>>>>>>>>>>>>        Increment iArgnum
19974>>>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
19975>>>>>>>>>>>>>        Set piLastArgument to iArgnum
19976>>>>>>>>>>>>>    End_Procedure
19977>>>>>>>>>>>>>    
19977>>>>>>>>>>>>>    
19977>>>>>>>>>>>>>    
19977>>>>>>>>>>>>>    // Set the next argument
19977>>>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
19979>>>>>>>>>>>>>        Integer ihdbc
19979>>>>>>>>>>>>>        Integer ihstmt
19979>>>>>>>>>>>>>        String  sDrvrId
19979>>>>>>>>>>>>>        Integer iVoid
19979>>>>>>>>>>>>>        String  sEmpty
19979>>>>>>>>>>>>>        
19979>>>>>>>>>>>>>        // Initialize
19979>>>>>>>>>>>>>        Move "" to sEmpty
19980>>>>>>>>>>>>>        
19980>>>>>>>>>>>>>        // Get the cli handles
19980>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
19981>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
19982>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
19983>>>>>>>>>>>>>        
19983>>>>>>>>>>>>>        // Call the procedure
19983>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
19985>>>>>>>>>>>>>            // Pass the information
19985>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
19990>>>>>>>>>>>>>            
19990>>>>>>>>>>>>>            // Pass the argument
19990>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
19995>>>>>>>>>>>>>        End
19995>>>>>>>>>>>>>>
19995>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
19997>>>>>>>>>>>>>    End_Procedure
19998>>>>>>>>>>>>>    
19998>>>>>>>>>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
20000>>>>>>>>>>>>>        Integer iParamNum 
20000>>>>>>>>>>>>>        Integer iType
20000>>>>>>>>>>>>>        
20000>>>>>>>>>>>>>        If (num_arguments < 2) Begin
20002>>>>>>>>>>>>>            Move typeString to iType
20003>>>>>>>>>>>>>        End
20003>>>>>>>>>>>>>>
20003>>>>>>>>>>>>>        Else Begin
20004>>>>>>>>>>>>>            Move iParamType to iType
20005>>>>>>>>>>>>>        End
20005>>>>>>>>>>>>>>
20005>>>>>>>>>>>>>        
20005>>>>>>>>>>>>>        Get piLastArgument to iParamNum
20006>>>>>>>>>>>>>        Increment iParamNum
20007>>>>>>>>>>>>>        Send SQLSetParameter iParamNum sParamValue iType
20008>>>>>>>>>>>>>        Set piLastArgument to iParamNum
20009>>>>>>>>>>>>>    End_Procedure
20010>>>>>>>>>>>>>
20010>>>>>>>>>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
20012>>>>>>>>>>>>>        
20012>>>>>>>>>>>>>        Integer ihdbc
20012>>>>>>>>>>>>>        Integer ihstmt
20012>>>>>>>>>>>>>        String  sDrvrId
20012>>>>>>>>>>>>>        Integer iVoid
20012>>>>>>>>>>>>>        String  sEmpty
20012>>>>>>>>>>>>>        Integer iType
20012>>>>>>>>>>>>>        
20012>>>>>>>>>>>>>        If (num_arguments < 3) Begin
20014>>>>>>>>>>>>>            Move typeString to iType
20015>>>>>>>>>>>>>        End
20015>>>>>>>>>>>>>>
20015>>>>>>>>>>>>>        Else Begin
20016>>>>>>>>>>>>>            Move iParamType to iType
20017>>>>>>>>>>>>>        End
20017>>>>>>>>>>>>>>
20017>>>>>>>>>>>>>        
20017>>>>>>>>>>>>>        Case Begin
20017>>>>>>>>>>>>>            Case (iType = typeDate )    
20019>>>>>>>>>>>>>
20019>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20021>>>>>>>>>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
20022>>>>>>>>>>>>>                End
20022>>>>>>>>>>>>>>
20022>>>>>>>>>>>>>                
20022>>>>>>>>>>>>>                Break
20023>>>>>>>>>>>>>
20023>>>>>>>>>>>>>            Case (iType = typeDatetime )    
20026>>>>>>>>>>>>>
20026>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20028>>>>>>>>>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
20029>>>>>>>>>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
20030>>>>>>>>>>>>>                End
20030>>>>>>>>>>>>>>
20030>>>>>>>>>>>>>
20030>>>>>>>>>>>>>                Break
20031>>>>>>>>>>>>>
20031>>>>>>>>>>>>>            Case (iType = typeNumber )    
20034>>>>>>>>>>>>>
20034>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20036>>>>>>>>>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
20037>>>>>>>>>>>>>                End
20037>>>>>>>>>>>>>>
20037>>>>>>>>>>>>>                
20037>>>>>>>>>>>>>                Break
20038>>>>>>>>>>>>>            
20038>>>>>>>>>>>>>            Case (iType = typeTime )    
20041>>>>>>>>>>>>>
20041>>>>>>>>>>>>>                If (sParamValue <> "") Begin
20043>>>>>>>>>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
20044>>>>>>>>>>>>>                End
20044>>>>>>>>>>>>>>
20044>>>>>>>>>>>>>                
20044>>>>>>>>>>>>>                Break
20045>>>>>>>>>>>>>                
20045>>>>>>>>>>>>>            Case Else
20045>>>>>>>>>>>>>                    // sParamValue is a string type or a type that must be passed as a string
20045>>>>>>>>>>>>>                    Break
20046>>>>>>>>>>>>>                
20046>>>>>>>>>>>>>        Case End
20046>>>>>>>>>>>>>        
20046>>>>>>>>>>>>>        
20046>>>>>>>>>>>>>        // Initialize
20046>>>>>>>>>>>>>        Move "" to sEmpty
20047>>>>>>>>>>>>>        
20047>>>>>>>>>>>>>        // Get the cli handles
20047>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20048>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20049>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20050>>>>>>>>>>>>>        
20050>>>>>>>>>>>>>        // Call the procedure
20050>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20052>>>>>>>>>>>>>            // Pass the information
20052>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
20057>>>>>>>>>>>>>            
20057>>>>>>>>>>>>>            // Pass the argument
20057>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
20062>>>>>>>>>>>>>        End
20062>>>>>>>>>>>>>>
20062>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
20064>>>>>>>>>>>>>    End_Procedure
20065>>>>>>>>>>>>>    
20065>>>>>>>>>>>>>    
20065>>>>>>>>>>>>>    // Call a stored procedure
20065>>>>>>>>>>>>>    Procedure SQLCall
20067>>>>>>>>>>>>>        Integer ihdbc
20067>>>>>>>>>>>>>        Integer ihstmt
20067>>>>>>>>>>>>>        String  sDrvrId
20067>>>>>>>>>>>>>        Integer iVoid
20067>>>>>>>>>>>>>        String  sEmpty
20067>>>>>>>>>>>>>        
20067>>>>>>>>>>>>>        // Initialize
20067>>>>>>>>>>>>>        Move "" to sEmpty
20068>>>>>>>>>>>>>        
20068>>>>>>>>>>>>>        // Get the cli handles
20068>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20069>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20070>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20071>>>>>>>>>>>>>        
20071>>>>>>>>>>>>>        // Call the procedure
20071>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20073>>>>>>>>>>>>>            // Call the procedure
20073>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
20078>>>>>>>>>>>>>            
20078>>>>>>>>>>>>>            Send SQLGetStatementAttributes
20079>>>>>>>>>>>>>            Set piLastArgument to 0
20080>>>>>>>>>>>>>        End
20080>>>>>>>>>>>>>>
20080>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
20082>>>>>>>>>>>>>    End_Procedure
20083>>>>>>>>>>>>>    
20083>>>>>>>>>>>>>    
20083>>>>>>>>>>>>>    // Get the next argument
20083>>>>>>>>>>>>>    Function SQLGetNextArgument Returns String
20085>>>>>>>>>>>>>        Integer iArgnum
20085>>>>>>>>>>>>>        String  sResult
20085>>>>>>>>>>>>>        
20085>>>>>>>>>>>>>        Get piLastArgument to iArgnum
20086>>>>>>>>>>>>>        Increment iArgnum
20087>>>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
20088>>>>>>>>>>>>>        Set piLastArgument to iArgnum
20089>>>>>>>>>>>>>        
20089>>>>>>>>>>>>>        Function_Return sResult
20090>>>>>>>>>>>>>    End_Function
20091>>>>>>>>>>>>>    
20091>>>>>>>>>>>>>    
20091>>>>>>>>>>>>>    
20091>>>>>>>>>>>>>    // Get the specified argument from a procedure
20091>>>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
20093>>>>>>>>>>>>>        Integer ihdbc
20093>>>>>>>>>>>>>        Integer ihstmt
20093>>>>>>>>>>>>>        String  sDrvrId
20093>>>>>>>>>>>>>        Integer iVoid
20093>>>>>>>>>>>>>        String  sEmpty
20093>>>>>>>>>>>>>        String  sArgument
20093>>>>>>>>>>>>>        Integer iLen
20093>>>>>>>>>>>>>        
20093>>>>>>>>>>>>>        // Initialize
20093>>>>>>>>>>>>>        Move "" to sEmpty
20094>>>>>>>>>>>>>        Move "" to sArgument
20095>>>>>>>>>>>>>        
20095>>>>>>>>>>>>>        // Get the cli handles
20095>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20096>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20097>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20098>>>>>>>>>>>>>        
20098>>>>>>>>>>>>>        // Call the procedure
20098>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20100>>>>>>>>>>>>>            // Pass the information
20100>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
20105>>>>>>>>>>>>>            
20105>>>>>>>>>>>>>            // Get the length
20105>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
20110>>>>>>>>>>>>>            
20110>>>>>>>>>>>>>            If (iLen) Begin
20112>>>>>>>>>>>>>                // Allocate
20112>>>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sArgument
20113>>>>>>>>>>>>>                
20113>>>>>>>>>>>>>                // Pass the argument
20113>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
20118>>>>>>>>>>>>>            End
20118>>>>>>>>>>>>>>
20118>>>>>>>>>>>>>        End
20118>>>>>>>>>>>>>>
20118>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
20120>>>>>>>>>>>>>        
20120>>>>>>>>>>>>>        Function_Return sArgument
20121>>>>>>>>>>>>>    End_Function
20122>>>>>>>>>>>>>    
20122>>>>>>>>>>>>>    
20122>>>>>>>>>>>>>    // Get the return value of a stored function
20122>>>>>>>>>>>>>    Function SQLReturnValue Returns String
20124>>>>>>>>>>>>>        Integer ihdbc
20124>>>>>>>>>>>>>        Integer ihstmt
20124>>>>>>>>>>>>>        String  sDrvrId
20124>>>>>>>>>>>>>        Integer iVoid
20124>>>>>>>>>>>>>        String  sEmpty
20124>>>>>>>>>>>>>        String  sRetval
20124>>>>>>>>>>>>>        Integer iLen
20124>>>>>>>>>>>>>        
20124>>>>>>>>>>>>>        // Initialize
20124>>>>>>>>>>>>>        Move "" to sEmpty
20125>>>>>>>>>>>>>        Move "" to sRetval
20126>>>>>>>>>>>>>        
20126>>>>>>>>>>>>>        // Get the cli handles
20126>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20127>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20128>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20129>>>>>>>>>>>>>        
20129>>>>>>>>>>>>>        // Call the procedure
20129>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20131>>>>>>>>>>>>>            // Get the length
20131>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
20136>>>>>>>>>>>>>            
20136>>>>>>>>>>>>>            If (iLen) Begin
20138>>>>>>>>>>>>>                // Allocate
20138>>>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sRetval
20139>>>>>>>>>>>>>                
20139>>>>>>>>>>>>>                // Pass the argument
20139>>>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
20144>>>>>>>>>>>>>            End
20144>>>>>>>>>>>>>>
20144>>>>>>>>>>>>>        End
20144>>>>>>>>>>>>>>
20144>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
20146>>>>>>>>>>>>>        
20146>>>>>>>>>>>>>        Function_Return sRetval
20147>>>>>>>>>>>>>    End_Function
20148>>>>>>>>>>>>>    
20148>>>>>>>>>>>>>    
20148>>>>>>>>>>>>>    // Switch to the next set
20148>>>>>>>>>>>>>    // Returns : 0   = No more result sets
20148>>>>>>>>>>>>>    //     <>0 = Switched to next set
20148>>>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
20150>>>>>>>>>>>>>        Integer ihdbc
20150>>>>>>>>>>>>>        Integer ihstmt
20150>>>>>>>>>>>>>        String  sDrvrId
20150>>>>>>>>>>>>>        Integer iResult
20150>>>>>>>>>>>>>        String  sEmpty
20150>>>>>>>>>>>>>        
20150>>>>>>>>>>>>>        // Initialize
20150>>>>>>>>>>>>>        Move "" to sEmpty
20151>>>>>>>>>>>>>        Move 0  to iResult
20152>>>>>>>>>>>>>        
20152>>>>>>>>>>>>>        // Get the cli handles
20152>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20153>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20154>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20155>>>>>>>>>>>>>        
20155>>>>>>>>>>>>>        // Call the procedure
20155>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20157>>>>>>>>>>>>>            // Get the length
20157>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
20162>>>>>>>>>>>>>            
20162>>>>>>>>>>>>>            Send SQLGetStatementAttributes
20163>>>>>>>>>>>>>            Set piLastArgument to 0
20164>>>>>>>>>>>>>        End
20164>>>>>>>>>>>>>>
20164>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
20166>>>>>>>>>>>>>        
20166>>>>>>>>>>>>>        Function_Return iResult
20167>>>>>>>>>>>>>    End_Function
20168>>>>>>>>>>>>>    
20168>>>>>>>>>>>>>    
20168>>>>>>>>>>>>>    // Setup a file that will be acivated after a succesfull
20168>>>>>>>>>>>>>    //fetch on the statement
20168>>>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
20170>>>>>>>>>>>>>        Integer ihdbc
20170>>>>>>>>>>>>>        Integer ihstmt
20170>>>>>>>>>>>>>        String  sDrvrId
20170>>>>>>>>>>>>>        Integer iResult
20170>>>>>>>>>>>>>        Integer bIsOpen
20170>>>>>>>>>>>>>        Integer iVoid
20170>>>>>>>>>>>>>        String  sFileType
20170>>>>>>>>>>>>>        
20170>>>>>>>>>>>>>        // Check if file is open
20170>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
20173>>>>>>>>>>>>>        If (bIsOpen) Begin
20175>>>>>>>>>>>>>            // Get the cli handles
20175>>>>>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
20176>>>>>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
20177>>>>>>>>>>>>>            Get psDriverId            to sDrvrId
20178>>>>>>>>>>>>>            
20178>>>>>>>>>>>>>            // Call the procedure
20178>>>>>>>>>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20180>>>>>>>>>>>>>                // Check if the file has the correct type
20180>>>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
20183>>>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
20185>>>>>>>>>>>>>                    // Setup the buffer
20185>>>>>>>>>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
20190>>>>>>>>>>>>>                End
20190>>>>>>>>>>>>>>
20190>>>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
20192>>>>>>>>>>>>>            End
20192>>>>>>>>>>>>>>
20192>>>>>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
20194>>>>>>>>>>>>>        End
20194>>>>>>>>>>>>>>
20194>>>>>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
20196>>>>>>>>>>>>>    End_Procedure
20197>>>>>>>>>>>>>    
20197>>>>>>>>>>>>>    
20197>>>>>>>>>>>>>    
20197>>>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
20199>>>>>>>>>>>>>        Integer ihdbc
20199>>>>>>>>>>>>>        Integer ihstmt
20199>>>>>>>>>>>>>        String  sDrvrId
20199>>>>>>>>>>>>>        String  sMessage
20199>>>>>>>>>>>>>        Integer iVoid
20199>>>>>>>>>>>>>        
20199>>>>>>>>>>>>>        // Initialize
20199>>>>>>>>>>>>>        Move "" to sMessage
20200>>>>>>>>>>>>>        
20200>>>>>>>>>>>>>        // Get the cli handles
20200>>>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
20201>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20202>>>>>>>>>>>>>        Get psDriverId            to sDrvrId
20203>>>>>>>>>>>>>        
20203>>>>>>>>>>>>>        // Call the procedure
20203>>>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
20205>>>>>>>>>>>>>            // Setup function arguments
20205>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
20210>>>>>>>>>>>>>            
20210>>>>>>>>>>>>>            Move (Repeat(' ', 1024)) to sMessage
20211>>>>>>>>>>>>>            // Get the length
20211>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
20216>>>>>>>>>>>>>        End
20216>>>>>>>>>>>>>>
20216>>>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
20218>>>>>>>>>>>>>        
20218>>>>>>>>>>>>>        Function_Return sMessage
20219>>>>>>>>>>>>>    End_Function
20220>>>>>>>>>>>>>    
20220>>>>>>>>>>>>>    
20220>>>>>>>>>>>>>    
20220>>>>>>>>>>>>>    // Remove the component identifier from a diagnostic message
20220>>>>>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
20222>>>>>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
20226>>>>>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
20227>>>>>>>>>>>>>        Loop
20228>>>>>>>>>>>>>>
20228>>>>>>>>>>>>>        
20228>>>>>>>>>>>>>        Function_Return sDiagMessage
20229>>>>>>>>>>>>>    End_Function
20230>>>>>>>>>>>>>    
20230>>>>>>>>>>>>>    
20230>>>>>>>>>>>>>    
20230>>>>>>>>>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
20230>>>>>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
20232>>>>>>>>>>>>>        
20232>>>>>>>>>>>>>        Integer iType
20232>>>>>>>>>>>>>        String  sSQLDate
20232>>>>>>>>>>>>>        Integer iOrgDateFmt
20232>>>>>>>>>>>>>        Integer iOrgDateSep
20232>>>>>>>>>>>>>        
20232>>>>>>>>>>>>>        String sDriverId
20232>>>>>>>>>>>>>        String sDummyZeroDate
20232>>>>>>>>>>>>>        String sDummyZeroDateMssqlDatetime
20232>>>>>>>>>>>>>        
20232>>>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
20232>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
20235>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20238>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
20241>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
20244>>>>>>>>>>>>>        
20244>>>>>>>>>>>>>        // We only need to convert if the date is 0
20244>>>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
20246>>>>>>>>>>>>>            
20246>>>>>>>>>>>>>            If (num_arguments < 2) Begin
20248>>>>>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
20249>>>>>>>>>>>>>            End
20249>>>>>>>>>>>>>>
20249>>>>>>>>>>>>>            Else Begin
20250>>>>>>>>>>>>>                Move iSQLType to iType
20251>>>>>>>>>>>>>            End
20251>>>>>>>>>>>>>>
20251>>>>>>>>>>>>>            
20251>>>>>>>>>>>>>            
20251>>>>>>>>>>>>>            Get psDriverID to sDriverId
20252>>>>>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
20253>>>>>>>>>>>>>            
20253>>>>>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
20255>>>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20256>>>>>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
20257>>>>>>>>>>>>>            End
20257>>>>>>>>>>>>>>
20257>>>>>>>>>>>>>            Else Begin
20258>>>>>>>>>>>>>                Move sDummyZeroDate to sSQLDate
20259>>>>>>>>>>>>>            End
20259>>>>>>>>>>>>>>
20259>>>>>>>>>>>>>            
20259>>>>>>>>>>>>>        End
20259>>>>>>>>>>>>>>
20259>>>>>>>>>>>>>        Else Begin
20260>>>>>>>>>>>>>            Move dDFDate to sSQLDate
20261>>>>>>>>>>>>>        End
20261>>>>>>>>>>>>>>
20261>>>>>>>>>>>>>        
20261>>>>>>>>>>>>>        // Change date format back to original
20261>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
20264>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20267>>>>>>>>>>>>>        
20267>>>>>>>>>>>>>        Function_Return sSQLDate
20268>>>>>>>>>>>>>    End_Function
20269>>>>>>>>>>>>>    
20269>>>>>>>>>>>>>    
20269>>>>>>>>>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
20269>>>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
20271>>>>>>>>>>>>>        
20271>>>>>>>>>>>>>        Integer iType
20271>>>>>>>>>>>>>        Date    dDFDate
20271>>>>>>>>>>>>>        Integer iOrgDateFmt
20271>>>>>>>>>>>>>        Integer iOrgDateSep
20271>>>>>>>>>>>>>        
20271>>>>>>>>>>>>>        String  sDriverId
20271>>>>>>>>>>>>>        String  sDummyZeroDate
20271>>>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
20271>>>>>>>>>>>>>        
20271>>>>>>>>>>>>>        Get psDriverID to sDriverId
20272>>>>>>>>>>>>>        
20272>>>>>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
20273>>>>>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20274>>>>>>>>>>>>>        
20274>>>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
20277>>>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20280>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
20283>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
20286>>>>>>>>>>>>>        
20286>>>>>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
20287>>>>>>>>>>>>>        
20287>>>>>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
20289>>>>>>>>>>>>>            Move 0 to dDFDate
20290>>>>>>>>>>>>>        End
20290>>>>>>>>>>>>>>
20290>>>>>>>>>>>>>        Else Begin
20291>>>>>>>>>>>>>            Move sSQLDate to dDFDate
20292>>>>>>>>>>>>>        End
20292>>>>>>>>>>>>>>
20292>>>>>>>>>>>>>        
20292>>>>>>>>>>>>>        // Change date format back to original
20292>>>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
20295>>>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
20298>>>>>>>>>>>>>        
20298>>>>>>>>>>>>>        Function_Return dDFDate
20299>>>>>>>>>>>>>    End_Function
20300>>>>>>>>>>>>>    
20300>>>>>>>>>>>>>End_Class
20301>>>>>>>>>>>>>
20301>>>>>>>>>>>>>
20301>>>>>>>>>>>>>// Connection object for embedded SQL                          
20301>>>>>>>>>>>>>// This provides the ability to create a connection for a driver.     
20301>>>>>>>>>>>>>// It will contain child statement objects                            
20301>>>>>>>>>>>>>
20301>>>>>>>>>>>>>Class cSQLConnection is a cObject
20302>>>>>>>>>>>>>    
20302>>>>>>>>>>>>>    Procedure Construct_object
20304>>>>>>>>>>>>>        Forward Send Construct_object
20306>>>>>>>>>>>>>        
20306>>>>>>>>>>>>>        Property Integer phCLIConnectionHandle       0
20307>>>>>>>>>>>>>        
20307>>>>>>>>>>>>>        Property String  psDriverID        ""
20308>>>>>>>>>>>>>        Property Integer piBindFile        0
20309>>>>>>>>>>>>>        
20309>>>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
20310>>>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
20311>>>>>>>>>>>>>        
20311>>>>>>>>>>>>>    End_Procedure
20312>>>>>>>>>>>>>    
20312>>>>>>>>>>>>>    
20312>>>>>>>>>>>>>    
20312>>>>>>>>>>>>>    // Store basic information about the connection
20312>>>>>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
20314>>>>>>>>>>>>>        
20314>>>>>>>>>>>>>        String sDummyZeroDate
20314>>>>>>>>>>>>>        Integer iDriverIndex
20314>>>>>>>>>>>>>        
20314>>>>>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
20315>>>>>>>>>>>>>        Set psDriverID            to sDrvrId
20316>>>>>>>>>>>>>        
20316>>>>>>>>>>>>>        Case Begin
20316>>>>>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
20318>>>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
20319>>>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
20320>>>>>>>>>>>>>                Break
20321>>>>>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
20324>>>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
20325>>>>>>>>>>>>>                Break
20326>>>>>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
20329>>>>>>>>>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
20330>>>>>>>>>>>>>                If (iDriverIndex <> 0) Begin
20332>>>>>>>>>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
20335>>>>>>>>>>>>>                End
20335>>>>>>>>>>>>>>
20335>>>>>>>>>>>>>                Else Begin
20336>>>>>>>>>>>>>                    Move '0001-01-01' to sDummyZeroDate
20337>>>>>>>>>>>>>                End
20337>>>>>>>>>>>>>>
20337>>>>>>>>>>>>>
20337>>>>>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
20338>>>>>>>>>>>>>                Break
20339>>>>>>>>>>>>>                
20339>>>>>>>>>>>>>        Case End
20339>>>>>>>>>>>>>        
20339>>>>>>>>>>>>>    End_Procedure
20340>>>>>>>>>>>>>    
20340>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
20342>>>>>>>>>>>>>        
20342>>>>>>>>>>>>>        String  sCurrentDriver
20342>>>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
20342>>>>>>>>>>>>>        
20342>>>>>>>>>>>>>        Move 0 to iDriver
20343>>>>>>>>>>>>>        
20343>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
20346>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
20352>>>>>>>>>>>>>>
20352>>>>>>>>>>>>>            
20352>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
20355>>>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
20357>>>>>>>>>>>>>                Move iCount to iDriver
20358>>>>>>>>>>>>>            End
20358>>>>>>>>>>>>>>
20358>>>>>>>>>>>>>        Loop
20359>>>>>>>>>>>>>>
20359>>>>>>>>>>>>>        
20359>>>>>>>>>>>>>        Function_Return iDriver
20360>>>>>>>>>>>>>        
20360>>>>>>>>>>>>>    End_Function
20361>>>>>>>>>>>>>
20361>>>>>>>>>>>>>    
20361>>>>>>>>>>>>>    // Destroy the SQLConnection object
20361>>>>>>>>>>>>>    Procedure DestroySQLConnection
20363>>>>>>>>>>>>>        Send Destroy
20364>>>>>>>>>>>>>    End_Procedure
20365>>>>>>>>>>>>>    
20365>>>>>>>>>>>>>    
20365>>>>>>>>>>>>>    // Connect to a database server
20365>>>>>>>>>>>>>    // Returns : 1 Succesfully connected
20365>>>>>>>>>>>>>    //           0 Not connected
20365>>>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
20367>>>>>>>>>>>>>        Integer ihdbc
20367>>>>>>>>>>>>>        String  sEmpty
20367>>>>>>>>>>>>>        
20367>>>>>>>>>>>>>        // Initialize
20367>>>>>>>>>>>>>        Move "" to sEmpty
20368>>>>>>>>>>>>>        Move 0  to ihdbc
20369>>>>>>>>>>>>>        
20369>>>>>>>>>>>>>        Move False to Err
20370>>>>>>>>>>>>>        
20370>>>>>>>>>>>>>        // Call the driver function to connect
20370>>>>>>>>>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
20375>>>>>>>>>>>>>        
20375>>>>>>>>>>>>>        // If there was an error, make result invalid
20375>>>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
20378>>>>>>>>>>>>>        
20378>>>>>>>>>>>>>        // Check result and store it
20378>>>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
20381>>>>>>>>>>>>>        
20381>>>>>>>>>>>>>        // Return success status
20381>>>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20382>>>>>>>>>>>>>    End_Function
20383>>>>>>>>>>>>>    
20383>>>>>>>>>>>>>    
20383>>>>>>>>>>>>>    // Use a connection of an already open file
20383>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
20385>>>>>>>>>>>>>        Integer ihdbc
20385>>>>>>>>>>>>>        Integer bIsOpen
20385>>>>>>>>>>>>>        String  sDrvrId
20385>>>>>>>>>>>>>        String  sEmpty
20385>>>>>>>>>>>>>        
20385>>>>>>>>>>>>>        // Initialize
20385>>>>>>>>>>>>>        Move "" to sEmpty
20386>>>>>>>>>>>>>        Move 0  to ihdbc
20387>>>>>>>>>>>>>        
20387>>>>>>>>>>>>>        // Check if file is open
20387>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
20390>>>>>>>>>>>>>        If (bIsOpen) Begin
20392>>>>>>>>>>>>>            // Fill the driver id, assume longest is 255 characters
20392>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDrvrId
20393>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
20396>>>>>>>>>>>>>            
20396>>>>>>>>>>>>>            Move False to Err
20397>>>>>>>>>>>>>            
20397>>>>>>>>>>>>>            // Call the driver function to connect
20397>>>>>>>>>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
20402>>>>>>>>>>>>>            
20402>>>>>>>>>>>>>            // If there was an error, make result invalid
20402>>>>>>>>>>>>>            If (Err) ;                Move 0 to ihdbc
20405>>>>>>>>>>>>>            
20405>>>>>>>>>>>>>            // Check result and store it
20405>>>>>>>>>>>>>            If (ihdbc <> 0) Begin
20407>>>>>>>>>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
20407>>>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
20410>>>>>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
20411>>>>>>>>>>>>>                
20411>>>>>>>>>>>>>                // Set filenum so it can be used for fetching
20411>>>>>>>>>>>>>                Set piBindFile to iFileNum
20412>>>>>>>>>>>>>            End
20412>>>>>>>>>>>>>>
20412>>>>>>>>>>>>>        End
20412>>>>>>>>>>>>>>
20412>>>>>>>>>>>>>        
20412>>>>>>>>>>>>>        // Return success status
20412>>>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20413>>>>>>>>>>>>>    End_Function
20414>>>>>>>>>>>>>    
20414>>>>>>>>>>>>>    
20414>>>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
20414>>>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
20414>>>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
20414>>>>>>>>>>>>>    // The connectstring must be an exact match, but can be case insensitive
20414>>>>>>>>>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
20414>>>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
20414>>>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
20414>>>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
20416>>>>>>>>>>>>>        Integer ihdbc
20416>>>>>>>>>>>>>        String  sEmpty
20416>>>>>>>>>>>>>        Integer iFileNum
20416>>>>>>>>>>>>>        
20416>>>>>>>>>>>>>        // Initialize
20416>>>>>>>>>>>>>        Move "" to sEmpty
20417>>>>>>>>>>>>>        Move 0  to ihdbc
20418>>>>>>>>>>>>>        
20418>>>>>>>>>>>>>        Move False to Err
20419>>>>>>>>>>>>>        
20419>>>>>>>>>>>>>        // Call the driver function
20419>>>>>>>>>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
20419>>>>>>>>>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
20419>>>>>>>>>>>>>        Move 0 to iFileNum
20420>>>>>>>>>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
20425>>>>>>>>>>>>>        
20425>>>>>>>>>>>>>        // If there was an error, make result invalid
20425>>>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
20428>>>>>>>>>>>>>        
20428>>>>>>>>>>>>>        // Check result and store it
20428>>>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
20431>>>>>>>>>>>>>        
20431>>>>>>>>>>>>>        // Return success status
20431>>>>>>>>>>>>>        Function_Return (ihdbc <> 0)
20432>>>>>>>>>>>>>    End_Function
20433>>>>>>>>>>>>>    
20433>>>>>>>>>>>>>    
20433>>>>>>>>>>>>>    // Disconnect from an embedded SQL server and free allocated
20433>>>>>>>>>>>>>    // resources
20433>>>>>>>>>>>>>    Procedure SQLDisconnect
20435>>>>>>>>>>>>>        Integer ihdbc
20435>>>>>>>>>>>>>        Integer iVoid
20435>>>>>>>>>>>>>        String  sDrvrId
20435>>>>>>>>>>>>>        String  sEmpty
20435>>>>>>>>>>>>>        
20435>>>>>>>>>>>>>        // Initialize
20435>>>>>>>>>>>>>        Move "" to sEmpty
20436>>>>>>>>>>>>>        
20436>>>>>>>>>>>>>        // Get the cli handle
20436>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20437>>>>>>>>>>>>>        Get psDriverId to sDrvrId
20438>>>>>>>>>>>>>        
20438>>>>>>>>>>>>>        // Free the CLI handle
20438>>>>>>>>>>>>>        If (ihdbc <> 0) Begin
20440>>>>>>>>>>>>>            // Call the driver function to disconnect
20440>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
20445>>>>>>>>>>>>>            
20445>>>>>>>>>>>>>            Move -1 to giLastSQLhdbc
20446>>>>>>>>>>>>>            
20446>>>>>>>>>>>>>            // Free the DataFlex handle
20446>>>>>>>>>>>>>            Send DestroySQLConnection
20447>>>>>>>>>>>>>        End
20447>>>>>>>>>>>>>>
20447>>>>>>>>>>>>>    End_Procedure
20448>>>>>>>>>>>>>    
20448>>>>>>>>>>>>>    // Create a cSQLStatement object
20448>>>>>>>>>>>>>    Function CreateSQLStatement Returns Handle
20450>>>>>>>>>>>>>        
20450>>>>>>>>>>>>>        Handle hoSQLStatement
20450>>>>>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
20451>>>>>>>>>>>>>        
20451>>>>>>>>>>>>>        // If the connection has a default Bind File, assign it to the
20451>>>>>>>>>>>>>        // statement object. The default is set when you open a file with a
20451>>>>>>>>>>>>>        // SetFileConnection command.
20451>>>>>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
20452>>>>>>>>>>>>>        
20452>>>>>>>>>>>>>        Function_Return hoSQLStatement
20453>>>>>>>>>>>>>    End_Function
20454>>>>>>>>>>>>>    
20454>>>>>>>>>>>>>    
20454>>>>>>>>>>>>>    // Open a statement for use
20454>>>>>>>>>>>>>    Function SQLOpen Returns Handle
20456>>>>>>>>>>>>>        Handle  hoSQLStatement
20456>>>>>>>>>>>>>        Integer ihdbc
20456>>>>>>>>>>>>>        Integer ihstmt
20456>>>>>>>>>>>>>        Integer iVoid
20456>>>>>>>>>>>>>        String  sDrvrId
20456>>>>>>>>>>>>>        String  sEmpty
20456>>>>>>>>>>>>>        String  sDummyZeroDate
20456>>>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
20456>>>>>>>>>>>>>        
20456>>>>>>>>>>>>>        // Initialize
20456>>>>>>>>>>>>>        Move "" to sEmpty
20457>>>>>>>>>>>>>        
20457>>>>>>>>>>>>>        // Get the cli handle to the connection
20457>>>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
20458>>>>>>>>>>>>>        Get psDriverId  to sDrvrId
20459>>>>>>>>>>>>>        
20459>>>>>>>>>>>>>        // Allocate a new handle and populate it
20459>>>>>>>>>>>>>        If (ihdbc <> 0) Begin
20461>>>>>>>>>>>>>            // Create a new cSQLStatement object
20461>>>>>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
20462>>>>>>>>>>>>>            
20462>>>>>>>>>>>>>            // Call the driver function to allocate a cli statement handle
20462>>>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
20467>>>>>>>>>>>>>            
20467>>>>>>>>>>>>>            // If unsuccessful destroy hoSQLStatement
20467>>>>>>>>>>>>>            If (ihstmt = 0) Begin
20469>>>>>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
20470>>>>>>>>>>>>>                Move 0 to hoSQLStatement
20471>>>>>>>>>>>>>            End
20471>>>>>>>>>>>>>>
20471>>>>>>>>>>>>>            Else Begin
20472>>>>>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
20473>>>>>>>>>>>>>                
20473>>>>>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
20473>>>>>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
20474>>>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
20475>>>>>>>>>>>>>                
20475>>>>>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
20476>>>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
20477>>>>>>>>>>>>>                
20477>>>>>>>>>>>>>            End
20477>>>>>>>>>>>>>>
20477>>>>>>>>>>>>>        End
20477>>>>>>>>>>>>>>
20477>>>>>>>>>>>>>        
20477>>>>>>>>>>>>>        Function_Return hoSQLStatement
20478>>>>>>>>>>>>>    End_Function
20479>>>>>>>>>>>>>    
20479>>>>>>>>>>>>>End_Class
20480>>>>>>>>>>>>>
20480>>>>>>>>>>>>>// Manager for embedded SQL handles.                           
20480>>>>>>>>>>>>>// We want to be able to use multiple drivers and multiple            
20480>>>>>>>>>>>>>// connections within a driver and multiple statements within a       
20480>>>>>>>>>>>>>// connection. To allow this we have placed our own handle logic on   
20480>>>>>>>>>>>>>// top of the driver handle logic. This way we can handle the         
20480>>>>>>>>>>>>>// situation where two driver handles may be equal.                   
20480>>>>>>>>>>>>>
20480>>>>>>>>>>>>>Class cSQLHandleManager is a cObject
20481>>>>>>>>>>>>>    
20481>>>>>>>>>>>>>    Procedure Construct_object
20483>>>>>>>>>>>>>        Forward Send Construct_object
20485>>>>>>>>>>>>>        
20485>>>>>>>>>>>>>        Property String  psDefaultDriver      ""
20486>>>>>>>>>>>>>        Property String  psDefaultConnection  ""
20487>>>>>>>>>>>>>        
20487>>>>>>>>>>>>>    End_Procedure
20488>>>>>>>>>>>>>    
20488>>>>>>>>>>>>>    // Create a cSQLConnection object
20488>>>>>>>>>>>>>    Function CreateSQLConnection Returns Handle
20490>>>>>>>>>>>>>        Handle hoSQLConnection
20490>>>>>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
20491>>>>>>>>>>>>>        Function_Return hoSQLConnection
20492>>>>>>>>>>>>>    End_Function
20493>>>>>>>>>>>>>    
20493>>>>>>>>>>>>>    
20493>>>>>>>>>>>>>    // Store default connection information
20493>>>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
20495>>>>>>>>>>>>>        Set psDefaultDriver      to sDriver
20496>>>>>>>>>>>>>        Set psDefaultConnection  to sConnect
20497>>>>>>>>>>>>>    End_Procedure
20498>>>>>>>>>>>>>    
20498>>>>>>>>>>>>>    
20498>>>>>>>>>>>>>    // Make a connection to an embedded SQL server
20498>>>>>>>>>>>>>    // Returns : The DataFlex handle to the connection
20498>>>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
20500>>>>>>>>>>>>>        Handle hoSQLConnection
20500>>>>>>>>>>>>>        Integer bOK
20500>>>>>>>>>>>>>        
20500>>>>>>>>>>>>>        // Check arguments
20500>>>>>>>>>>>>>        If (sDrvrID = "" and sConnect = "") Begin
20502>>>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
20503>>>>>>>>>>>>>            Get psDefaultConnection  to sConnect
20504>>>>>>>>>>>>>        End
20504>>>>>>>>>>>>>>
20504>>>>>>>>>>>>>        
20504>>>>>>>>>>>>>        // Create a cSQLConnection object
20504>>>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20505>>>>>>>>>>>>>        // Connect to the database
20505>>>>>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
20506>>>>>>>>>>>>>        
20506>>>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20506>>>>>>>>>>>>>        If (not(bOK)) Begin
20508>>>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20509>>>>>>>>>>>>>            Move 0 to hoSQLConnection
20510>>>>>>>>>>>>>        End
20510>>>>>>>>>>>>>>
20510>>>>>>>>>>>>>        
20510>>>>>>>>>>>>>        Function_Return hoSQLConnection
20511>>>>>>>>>>>>>    End_Function
20512>>>>>>>>>>>>>    
20512>>>>>>>>>>>>>    
20512>>>>>>>>>>>>>    
20512>>>>>>>>>>>>>    // Make an existing connection available for use with Embedded SQL.
20512>>>>>>>>>>>>>    // The connection is identified by the number of a file
20512>>>>>>>>>>>>>    // that is open for that connection.
20512>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
20514>>>>>>>>>>>>>        Handle hoSQLConnection
20514>>>>>>>>>>>>>        Integer bOK
20514>>>>>>>>>>>>>        
20514>>>>>>>>>>>>>        // Create a cSQLConnection object
20514>>>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20515>>>>>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
20516>>>>>>>>>>>>>        
20516>>>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20516>>>>>>>>>>>>>        If (not(bOK)) Begin
20518>>>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20519>>>>>>>>>>>>>            Move 0 to hoSQLConnection
20520>>>>>>>>>>>>>        End
20520>>>>>>>>>>>>>>
20520>>>>>>>>>>>>>        
20520>>>>>>>>>>>>>        Function_Return hoSQLConnection
20521>>>>>>>>>>>>>    End_Function
20522>>>>>>>>>>>>>    
20522>>>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
20522>>>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
20522>>>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
20522>>>>>>>>>>>>>    // The connectstrings must be an exact match, but can be case insensitive
20522>>>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
20522>>>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
20522>>>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
20524>>>>>>>>>>>>>        Handle hoSQLConnection
20524>>>>>>>>>>>>>        Integer bOK
20524>>>>>>>>>>>>>        
20524>>>>>>>>>>>>>        // Check arguments
20524>>>>>>>>>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
20526>>>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
20527>>>>>>>>>>>>>            Get psDefaultConnection  to sConnectString
20528>>>>>>>>>>>>>        End
20528>>>>>>>>>>>>>>
20528>>>>>>>>>>>>>        
20528>>>>>>>>>>>>>        // Create a cSQLConnection object
20528>>>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
20529>>>>>>>>>>>>>        // Connect to the database
20529>>>>>>>>>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
20530>>>>>>>>>>>>>        
20530>>>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
20530>>>>>>>>>>>>>        If (not(bOK)) Begin
20532>>>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
20533>>>>>>>>>>>>>            Move 0 to hoSQLConnection
20534>>>>>>>>>>>>>        End
20534>>>>>>>>>>>>>>
20534>>>>>>>>>>>>>        
20534>>>>>>>>>>>>>        Function_Return hoSQLConnection
20535>>>>>>>>>>>>>    End_Function
20536>>>>>>>>>>>>>    
20536>>>>>>>>>>>>>    
20536>>>>>>>>>>>>>End_Class
20537>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
20537>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
20537>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
20537>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>Use Cli.pkg
20537>>>>>>>>>>>>>Use SQL.pkg
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>//   Driver Indentification
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>//   Error number constants
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>// SQL Server spcific types.
20537>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
20537>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
20537>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
20537>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>// SQL Server spcific types.
20537>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
20537>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
20537>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
20537>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
20537>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
20537>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
20537>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
20537>>>>>>>>>>>>>//
20537>>>>>>>>>>>>>//     Setup a constraint for a file.
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>
20537>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
20538>>>>>>>>>>>>>    
20538>>>>>>>>>>>>>    Procedure Construct_Object
20540>>>>>>>>>>>>>        Forward Send Construct_Object
20542>>>>>>>>>>>>>        
20542>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
20543>>>>>>>>>>>>>    End_Procedure
20544>>>>>>>>>>>>>    
20544>>>>>>>>>>>>>    
20544>>>>>>>>>>>>>    
20544>>>>>>>>>>>>>    //   Extract the list from the out connect string.
20544>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
20546>>>>>>>>>>>>>        String  sItem
20546>>>>>>>>>>>>>        Integer iStart
20546>>>>>>>>>>>>>        Integer iEnd
20546>>>>>>>>>>>>>        
20546>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
20549>>>>>>>>>>>>>        
20549>>>>>>>>>>>>>        Send Delete_Data to hoStore
20550>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
20551>>>>>>>>>>>>>        While (iStart > 0)
20555>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
20556>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
20559>>>>>>>>>>>>>            Else Begin
20560>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
20561>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
20562>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
20565>>>>>>>>>>>>>                
20565>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
20568>>>>>>>>>>>>>                
20568>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
20571>>>>>>>>>>>>>            End
20571>>>>>>>>>>>>>>
20571>>>>>>>>>>>>>        Loop
20572>>>>>>>>>>>>>>
20572>>>>>>>>>>>>>        
20572>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
20573>>>>>>>>>>>>>    End_Procedure
20574>>>>>>>>>>>>>    
20574>>>>>>>>>>>>>    
20574>>>>>>>>>>>>>    
20574>>>>>>>>>>>>>    //   Call the driver's browse connect function
20574>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
20576>>>>>>>>>>>>>        String  sDriver
20576>>>>>>>>>>>>>        String  sOutConnStr
20576>>>>>>>>>>>>>        Integer iArg
20576>>>>>>>>>>>>>        Integer iRetval
20576>>>>>>>>>>>>>        
20576>>>>>>>>>>>>>        Get psDriverID to sDriver
20577>>>>>>>>>>>>>        If (sDriver <> "") Begin
20579>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
20580>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
20585>>>>>>>>>>>>>        End
20585>>>>>>>>>>>>>>
20585>>>>>>>>>>>>>        
20585>>>>>>>>>>>>>        Function_Return sOutConnStr
20586>>>>>>>>>>>>>    End_Function// BrowseConnect
20587>>>>>>>>>>>>>    
20587>>>>>>>>>>>>>    
20587>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
20589>>>>>>>>>>>>>        String  sDriver
20589>>>>>>>>>>>>>        String  sOutConnStr
20589>>>>>>>>>>>>>        Integer iArg
20589>>>>>>>>>>>>>        Integer iRetval
20589>>>>>>>>>>>>>        
20589>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
20590>>>>>>>>>>>>>        
20590>>>>>>>>>>>>>        Get psDriverID to sDriver
20591>>>>>>>>>>>>>        If (sDriver <> "") Begin
20593>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
20594>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
20599>>>>>>>>>>>>>        End
20599>>>>>>>>>>>>>>
20599>>>>>>>>>>>>>        
20599>>>>>>>>>>>>>        Function_Return sOutConnStr
20600>>>>>>>>>>>>>    End_Function// BrowseConnect
20601>>>>>>>>>>>>>    
20601>>>>>>>>>>>>>    
20601>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
20603>>>>>>>>>>>>>        String  sServerList
20603>>>>>>>>>>>>>        Integer iNumServers
20603>>>>>>>>>>>>>        Integer iDriver
20603>>>>>>>>>>>>>        Integer iClientVersion
20603>>>>>>>>>>>>>        String  sDriver
20603>>>>>>>>>>>>>        
20603>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
20604>>>>>>>>>>>>>        
20604>>>>>>>>>>>>>        If (iDriver) Begin
20606>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
20609>>>>>>>>>>>>>            
20609>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
20610>>>>>>>>>>>>>            
20610>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
20611>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
20613>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
20614>>>>>>>>>>>>>            End
20614>>>>>>>>>>>>>>
20614>>>>>>>>>>>>>            Else Begin
20615>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
20616>>>>>>>>>>>>>            End
20616>>>>>>>>>>>>>>
20616>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
20617>>>>>>>>>>>>>        End
20617>>>>>>>>>>>>>>
20617>>>>>>>>>>>>>        
20617>>>>>>>>>>>>>        Function_Return iNumServers
20618>>>>>>>>>>>>>    End_Function
20619>>>>>>>>>>>>>    
20619>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
20619>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
20619>>>>>>>>>>>>>    //   This may take a long time.
20619>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
20619>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
20621>>>>>>>>>>>>>        Integer iNumServers
20621>>>>>>>>>>>>>        Integer iNetworkLocal
20621>>>>>>>>>>>>>        
20621>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
20622>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
20623>>>>>>>>>>>>>
20623>>>>>>>>>>>>>        Function_Return iNumServers
20624>>>>>>>>>>>>>    End_Function
20625>>>>>>>>>>>>>    
20625>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
20625>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
20625>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
20625>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
20627>>>>>>>>>>>>>        Integer iNumServers
20627>>>>>>>>>>>>>        Integer iNetworkLocal
20627>>>>>>>>>>>>>        
20627>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
20628>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
20629>>>>>>>>>>>>>        
20629>>>>>>>>>>>>>        Function_Return iNumServers
20630>>>>>>>>>>>>>    End_Function
20631>>>>>>>>>>>>>    
20631>>>>>>>>>>>>>    //   Enumerate database in a given server.
20631>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
20633>>>>>>>>>>>>>        Integer hoSQL
20633>>>>>>>>>>>>>        String  sConnect
20633>>>>>>>>>>>>>        String  sDatabase
20633>>>>>>>>>>>>>        Integer hdbc
20633>>>>>>>>>>>>>        Integer hstmt
20633>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
20633>>>>>>>>>>>>>        
20633>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
20636>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
20639>>>>>>>>>>>>>        
20639>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
20642>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
20644>>>>>>>>>>>>>
20644>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
20645>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
20648>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
20650>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
20651>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
20652>>>>>>>>>>>>>        End
20652>>>>>>>>>>>>>>
20652>>>>>>>>>>>>>        
20652>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
20654>>>>>>>>>>>>>            Move Current_Object to hoSQL
20655>>>>>>>>>>>>>        End_Object
20656>>>>>>>>>>>>>        
20656>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
20658>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
20659>>>>>>>>>>>>>            If (hdbc <> 0) Begin
20661>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
20662>>>>>>>>>>>>>                If (hstmt <> 0) Begin
20664>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
20664>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
20664>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
20664>>>>>>>>>>>>>                    //   stay the same.
20664>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
20665>>>>>>>>>>>>>                    Send SQLCall to hstmt
20666>>>>>>>>>>>>>                    Repeat
20666>>>>>>>>>>>>>>
20666>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
20667>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
20669>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
20670>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
20671>>>>>>>>>>>>>                        End
20671>>>>>>>>>>>>>>
20671>>>>>>>>>>>>>                    Until (iFetchResult = 0)
20673>>>>>>>>>>>>>                    
20673>>>>>>>>>>>>>                    Send SQLClose to hstmt
20674>>>>>>>>>>>>>                End
20674>>>>>>>>>>>>>>
20674>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
20675>>>>>>>>>>>>>            End
20675>>>>>>>>>>>>>>
20675>>>>>>>>>>>>>        End
20675>>>>>>>>>>>>>>
20675>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
20676>>>>>>>>>>>>>        
20676>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
20677>>>>>>>>>>>>>    End_Function
20678>>>>>>>>>>>>>    
20678>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
20680>>>>>>>>>>>>>        String  sSqlServerClientVersionName
20680>>>>>>>>>>>>>        
20680>>>>>>>>>>>>>        Case Begin
20680>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
20682>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
20683>>>>>>>>>>>>>                Case Break
20684>>>>>>>>>>>>>            
20684>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
20687>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
20688>>>>>>>>>>>>>                Case Break
20689>>>>>>>>>>>>>                
20689>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
20692>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
20693>>>>>>>>>>>>>                Case Break
20694>>>>>>>>>>>>>            
20694>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
20697>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
20698>>>>>>>>>>>>>                Case Break
20699>>>>>>>>>>>>>            
20699>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
20702>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
20703>>>>>>>>>>>>>                Case Break
20704>>>>>>>>>>>>>            
20704>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
20707>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
20708>>>>>>>>>>>>>                Case Break
20709>>>>>>>>>>>>>            
20709>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
20712>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
20713>>>>>>>>>>>>>                Case Break
20714>>>>>>>>>>>>>            
20714>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
20717>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
20718>>>>>>>>>>>>>                Case Break
20719>>>>>>>>>>>>>            
20719>>>>>>>>>>>>>            Case Else
20719>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
20720>>>>>>>>>>>>>        Case End
20720>>>>>>>>>>>>>        
20720>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
20721>>>>>>>>>>>>>    End_Function
20722>>>>>>>>>>>>>
20722>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
20724>>>>>>>>>>>>>        String  sSqlServerClientDriverName
20724>>>>>>>>>>>>>        
20724>>>>>>>>>>>>>        Case Begin
20724>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
20726>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
20727>>>>>>>>>>>>>                Case Break
20728>>>>>>>>>>>>>
20728>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
20731>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
20732>>>>>>>>>>>>>                Case Break
20733>>>>>>>>>>>>>                
20733>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
20736>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
20737>>>>>>>>>>>>>                Case Break
20738>>>>>>>>>>>>>            
20738>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
20741>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
20742>>>>>>>>>>>>>                Case Break
20743>>>>>>>>>>>>>            
20743>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
20746>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
20747>>>>>>>>>>>>>                Case Break
20748>>>>>>>>>>>>>            
20748>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
20751>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
20752>>>>>>>>>>>>>                Case Break
20753>>>>>>>>>>>>>            
20753>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
20756>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
20757>>>>>>>>>>>>>                Case Break
20758>>>>>>>>>>>>>            
20758>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
20761>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
20762>>>>>>>>>>>>>                Case Break
20763>>>>>>>>>>>>>            
20763>>>>>>>>>>>>>            Case Else
20763>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
20764>>>>>>>>>>>>>        Case End
20764>>>>>>>>>>>>>        
20764>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
20765>>>>>>>>>>>>>    End_Function
20766>>>>>>>>>>>>>    
20766>>>>>>>>>>>>>End_Class
20767>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
20767>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
20767>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
20767>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
20767>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>Use Cli.pkg
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// Driver attributes
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// Driver Indentification
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// Error number constants
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// Call driver function identifiers
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// DB2 specific data types
20767>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
20767>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
20767>>>>>>>>>>>>>Define SQL_XML            for   (-370)
20767>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
20767>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
20767>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
20767>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
20767>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// Extra DB2 commands
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
20767>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>
20767>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
20768>>>>>>>>>>>>>    
20768>>>>>>>>>>>>>    Procedure Construct_Object
20770>>>>>>>>>>>>>        Forward Send Construct_Object
20772>>>>>>>>>>>>>        
20772>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
20773>>>>>>>>>>>>>    End_Procedure
20774>>>>>>>>>>>>>    
20774>>>>>>>>>>>>>    
20774>>>>>>>>>>>>>    
20774>>>>>>>>>>>>>    // Reset the datasource list to the beginning
20774>>>>>>>>>>>>>    Procedure SeedDataSources
20776>>>>>>>>>>>>>        String  sDriver
20776>>>>>>>>>>>>>        String  sVoid
20776>>>>>>>>>>>>>        Integer iRetval
20776>>>>>>>>>>>>>        
20776>>>>>>>>>>>>>        Get psDriverID to sDriver
20777>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
20784>>>>>>>>>>>>>    End_Procedure
20785>>>>>>>>>>>>>    
20785>>>>>>>>>>>>>    
20785>>>>>>>>>>>>>    
20785>>>>>>>>>>>>>    // Call the driver's data sources function
20785>>>>>>>>>>>>>    Function DataSources Returns String
20787>>>>>>>>>>>>>        String  sDriver
20787>>>>>>>>>>>>>        String  sDataSource
20787>>>>>>>>>>>>>        String  sDescription
20787>>>>>>>>>>>>>        Integer iLength
20787>>>>>>>>>>>>>        Integer iRetval
20787>>>>>>>>>>>>>        
20787>>>>>>>>>>>>>        Get psDriverID to sDriver
20788>>>>>>>>>>>>>        If (sDriver <> "") Begin
20790>>>>>>>>>>>>>            Move 8192 to iLength
20791>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
20792>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
20793>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
20798>>>>>>>>>>>>>        End
20798>>>>>>>>>>>>>>
20798>>>>>>>>>>>>>        
20798>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
20801>>>>>>>>>>>>>        Else ;            Function_Return ""
20803>>>>>>>>>>>>>    End_Function
20804>>>>>>>>>>>>>    
20804>>>>>>>>>>>>>End_Class
20805>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
20805>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
20805>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
20805>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
20805>>>>>>>>>>>>>
20805>>>>>>>>>>>>>Use Cli.pkg
20805>>>>>>>>>>>>>
20805>>>>>>>>>>>>>// Driver Indentification
20805>>>>>>>>>>>>>
20805>>>>>>>>>>>>>// Error number constants
20805>>>>>>>>>>>>>
20805>>>>>>>>>>>>>// Call driver function identifiers
20805>>>>>>>>>>>>>
20805>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
20806>>>>>>>>>>>>>    
20806>>>>>>>>>>>>>    Procedure Construct_Object
20808>>>>>>>>>>>>>        Forward Send Construct_Object
20810>>>>>>>>>>>>>        
20810>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
20811>>>>>>>>>>>>>    End_Procedure
20812>>>>>>>>>>>>>    
20812>>>>>>>>>>>>>    
20812>>>>>>>>>>>>>    
20812>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
20812>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
20814>>>>>>>>>>>>>        String  sDriver
20814>>>>>>>>>>>>>        String  sVoid
20814>>>>>>>>>>>>>        Integer iRetval
20814>>>>>>>>>>>>>        
20814>>>>>>>>>>>>>        Get psDriverID to sDriver
20815>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
20822>>>>>>>>>>>>>    End_Procedure
20823>>>>>>>>>>>>>    
20823>>>>>>>>>>>>>    
20823>>>>>>>>>>>>>    // Call the driver's data sources function
20823>>>>>>>>>>>>>    Function DataSources Returns String
20825>>>>>>>>>>>>>        String  sDriver
20825>>>>>>>>>>>>>        String  sDataSource
20825>>>>>>>>>>>>>        String  sDescription
20825>>>>>>>>>>>>>        Integer iLength
20825>>>>>>>>>>>>>        Integer iRetval
20825>>>>>>>>>>>>>        
20825>>>>>>>>>>>>>        Get psDriverID to sDriver
20826>>>>>>>>>>>>>        If (sDriver <> "") Begin
20828>>>>>>>>>>>>>            Move 8192 to iLength
20829>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
20830>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
20831>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
20836>>>>>>>>>>>>>        End
20836>>>>>>>>>>>>>>
20836>>>>>>>>>>>>>        
20836>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
20839>>>>>>>>>>>>>        Else ;            Function_Return ""
20841>>>>>>>>>>>>>    End_Function
20842>>>>>>>>>>>>>    
20842>>>>>>>>>>>>>End_Class
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
20843>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
20843>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
20843>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
20843>>>>>>>>>>>>>Use Ui
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Driver Indentification
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>// Driver attributes
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Call_Driver functions ID's
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to create all vars which may be needed
20843>>>>>>>>>>>>>// in other commands.
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
20843>>>>>>>>>>>>>// File must have been opened.
20843>>>>>>>>>>>>>// Filenumber needs to be passed.
20843>>>>>>>>>>>>>// To clear set the owner to "".
20843>>>>>>>>>>>>>// Examples:
20843>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
20843>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
20843>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
20843>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
20843>>>>>>>>>>>>>// To clear:
20843>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
20843>>>>>>>>>>>>>// options.
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to parse for Callback
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
20843>>>>>>>>>>>>>// File must have been opened.
20843>>>>>>>>>>>>>// Filenumber needs to be passed.
20843>>>>>>>>>>>>>// Examples:
20843>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
20843>>>>>>>>>>>>>// which will be tries when opening files.
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
20843>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
20843>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
20843>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to change the transaction type.
20843>>>>>>>>>>>>>// Valid types are:
20843>>>>>>>>>>>>>//     DFBTRTT_NONE
20843>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
20843>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to get the current transaction type.
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to set explicit_locking
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to get explicit locking
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
20843>>>>>>>>>>>>>//
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
20843>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
20843>>>>>>>>>>>>>
20843>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
20844>>>>>>>>>>>>>    
20844>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
20846>>>>>>>>>>>>>        Forward Send Construct_object iImage
20848>>>>>>>>>>>>>        
20848>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
20849>>>>>>>>>>>>>    End_Procedure
20850>>>>>>>>>>>>>    
20850>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
20850>>>>>>>>>>>>>    //
20850>>>>>>>>>>>>>    
20850>>>>>>>>>>>>>    Function CKRevision Returns String
20852>>>>>>>>>>>>>        String  sDriverID
20852>>>>>>>>>>>>>        String  sRevision
20852>>>>>>>>>>>>>        String  sVoid
20852>>>>>>>>>>>>>        Integer iRetval
20852>>>>>>>>>>>>>        
20852>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20852>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20852>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20852>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20853>>>>>>>>>>>>>        Get psDriverID to sDriverID
20854>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
20855>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
20860>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20861>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
20863>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20863>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
20864>>>>>>>>>>>>>        End
20864>>>>>>>>>>>>>>
20864>>>>>>>>>>>>>        Function_Return sRevision
20865>>>>>>>>>>>>>    End_Function
20866>>>>>>>>>>>>>    
20866>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
20868>>>>>>>>>>>>>        String  sDriverID
20868>>>>>>>>>>>>>        String  sVoid1
20868>>>>>>>>>>>>>        String  sVoid2
20868>>>>>>>>>>>>>        Integer iRetval
20868>>>>>>>>>>>>>        
20868>>>>>>>>>>>>>        Get psDriverID to sDriverID
20869>>>>>>>>>>>>>        
20869>>>>>>>>>>>>>        Move 0 to iRetval
20870>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20870>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20870>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
20870>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20871>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
20876>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20877>>>>>>>>>>>>>        
20877>>>>>>>>>>>>>        Function_Return iRetval
20878>>>>>>>>>>>>>    End_Function
20879>>>>>>>>>>>>>    
20879>>>>>>>>>>>>>    
20879>>>>>>>>>>>>>    
20879>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
20879>>>>>>>>>>>>>    //
20879>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
20879>>>>>>>>>>>>>    //
20879>>>>>>>>>>>>>    
20879>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
20881>>>>>>>>>>>>>        Integer iPartRev
20881>>>>>>>>>>>>>        Integer iCurrentPart
20881>>>>>>>>>>>>>        Integer iSeparatorPos
20881>>>>>>>>>>>>>        
20881>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
20884>>>>>>>>>>>>>        
20884>>>>>>>>>>>>>        Move 0 to iCurrentPart
20885>>>>>>>>>>>>>        Repeat
20885>>>>>>>>>>>>>>
20885>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
20886>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
20888>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
20889>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
20890>>>>>>>>>>>>>                Increment iCurrentPart
20891>>>>>>>>>>>>>            End
20891>>>>>>>>>>>>>>
20891>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
20894>>>>>>>>>>>>>                Move sRevision to iPartRev
20895>>>>>>>>>>>>>                Move "" to sRevision
20896>>>>>>>>>>>>>                Increment iCurrentPart
20897>>>>>>>>>>>>>            End
20897>>>>>>>>>>>>>>
20897>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
20899>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
20901>>>>>>>>>>>>>        
20901>>>>>>>>>>>>>        Function_Return iPartRev
20902>>>>>>>>>>>>>    End_Function
20903>>>>>>>>>>>>>    
20903>>>>>>>>>>>>>    
20903>>>>>>>>>>>>>    
20903>>>>>>>>>>>>>    //
20903>>>>>>>>>>>>>    //  Returns the major revision of the CK
20903>>>>>>>>>>>>>    //
20903>>>>>>>>>>>>>    
20903>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
20905>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
20906>>>>>>>>>>>>>    End_Function
20907>>>>>>>>>>>>>    
20907>>>>>>>>>>>>>    
20907>>>>>>>>>>>>>    
20907>>>>>>>>>>>>>    //  Returns the minor revision of the CK
20907>>>>>>>>>>>>>    //
20907>>>>>>>>>>>>>    
20907>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
20909>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
20910>>>>>>>>>>>>>    End_Function
20911>>>>>>>>>>>>>    
20911>>>>>>>>>>>>>    
20911>>>>>>>>>>>>>    //  Returns the release revision of the CK
20911>>>>>>>>>>>>>    //
20911>>>>>>>>>>>>>    
20911>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
20913>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
20914>>>>>>>>>>>>>    End_Function
20915>>>>>>>>>>>>>    
20915>>>>>>>>>>>>>    
20915>>>>>>>>>>>>>    //  Returns the major revision of the CK
20915>>>>>>>>>>>>>    //
20915>>>>>>>>>>>>>    
20915>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
20917>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
20918>>>>>>>>>>>>>    End_Function
20919>>>>>>>>>>>>>    
20919>>>>>>>>>>>>>    
20919>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
20919>>>>>>>>>>>>>    //
20919>>>>>>>>>>>>>    
20919>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
20921>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
20924>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
20927>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
20930>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
20933>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
20936>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
20940>>>>>>>>>>>>>            End
20940>>>>>>>>>>>>>>
20940>>>>>>>>>>>>>        End
20940>>>>>>>>>>>>>>
20940>>>>>>>>>>>>>        
20940>>>>>>>>>>>>>        Function_Return (False)
20941>>>>>>>>>>>>>    End_Function
20942>>>>>>>>>>>>>    
20942>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
20942>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
20942>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
20942>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
20942>>>>>>>>>>>>>    //
20942>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
20942>>>>>>>>>>>>>    //   in the following format:
20942>>>>>>>>>>>>>    //       <version>.<revision>.<type>
20942>>>>>>>>>>>>>    //   possible values for <type>:
20942>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
20942>>>>>>>>>>>>>    //         server using Workgroup authentication mode
20942>>>>>>>>>>>>>    //       C for client cache engine
20942>>>>>>>>>>>>>    //       D for DOS workstation
20942>>>>>>>>>>>>>    //       N for client Requester
20942>>>>>>>>>>>>>    //       S for NetWare server
20942>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
20942>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
20942>>>>>>>>>>>>>    //
20942>>>>>>>>>>>>>    //   example:
20942>>>>>>>>>>>>>    //       8.50.T
20942>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
20942>>>>>>>>>>>>>    //   32-bits Windows server.
20942>>>>>>>>>>>>>    //
20942>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
20942>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
20942>>>>>>>>>>>>>    //
20942>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
20942>>>>>>>>>>>>>    //   the functions will return "0.0.0"
20942>>>>>>>>>>>>>    
20942>>>>>>>>>>>>>    //  Returns the version information of the
20942>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
20942>>>>>>>>>>>>>    
20942>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
20944>>>>>>>>>>>>>        
20944>>>>>>>>>>>>>        String  sDriverID
20944>>>>>>>>>>>>>        String  sVersion
20944>>>>>>>>>>>>>        String  sVoid
20944>>>>>>>>>>>>>        Integer iRetval
20944>>>>>>>>>>>>>        
20944>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20944>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20944>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20944>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20945>>>>>>>>>>>>>        Get psDriverID to sDriverID
20946>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20947>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20952>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20953>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20955>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20955>>>>>>>>>>>>>            Move "0.0.0" to sVersion
20956>>>>>>>>>>>>>        End
20956>>>>>>>>>>>>>>
20956>>>>>>>>>>>>>        Function_Return sVersion
20957>>>>>>>>>>>>>    End_Function
20958>>>>>>>>>>>>>    
20958>>>>>>>>>>>>>    //           Pervasive.SQL Engine
20958>>>>>>>>>>>>>    
20958>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
20960>>>>>>>>>>>>>        
20960>>>>>>>>>>>>>        String  sDriverID
20960>>>>>>>>>>>>>        String  sVersion
20960>>>>>>>>>>>>>        String  sVoid
20960>>>>>>>>>>>>>        Integer iRetval
20960>>>>>>>>>>>>>        
20960>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20960>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20960>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20960>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20961>>>>>>>>>>>>>        Get psDriverID to sDriverID
20962>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20963>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20968>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20969>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20971>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20971>>>>>>>>>>>>>            Move "0.0.0" to sVersion
20972>>>>>>>>>>>>>        End
20972>>>>>>>>>>>>>>
20972>>>>>>>>>>>>>        Function_Return sVersion
20973>>>>>>>>>>>>>    End_Function
20974>>>>>>>>>>>>>    
20974>>>>>>>>>>>>>    //  Returns the version information of the
20974>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
20974>>>>>>>>>>>>>    
20974>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
20976>>>>>>>>>>>>>        
20976>>>>>>>>>>>>>        String  sDriverID
20976>>>>>>>>>>>>>        String  sVersion
20976>>>>>>>>>>>>>        String  sVoid
20976>>>>>>>>>>>>>        Integer iRetval
20976>>>>>>>>>>>>>        
20976>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
20976>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
20976>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
20976>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
20977>>>>>>>>>>>>>        Get psDriverID to sDriverID
20978>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
20979>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
20984>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
20985>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
20987>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
20987>>>>>>>>>>>>>            Move "0.0.0" to sVersion
20988>>>>>>>>>>>>>        End
20988>>>>>>>>>>>>>>
20988>>>>>>>>>>>>>        Function_Return sVersion
20989>>>>>>>>>>>>>    End_Function
20990>>>>>>>>>>>>>    
20990>>>>>>>>>>>>>End_Class
20991>>>>>>>>>>>>>
20991>>>>>>>>>>>>>
20991>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
20991>>>>>>>>>>>>>//****************************************************************************
20991>>>>>>>>>>>>>// $Module type: Include file
20991>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
20991>>>>>>>>>>>>>//
20991>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
20991>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
20991>>>>>>>>>>>>>// E-mail      : support@rdctools.com
20991>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
20991>>>>>>>>>>>>>//
20991>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
20991>>>>>>>>>>>>>//
20991>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
20991>>>>>>>>>>>>>//
20991>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
20991>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
20991>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
20991>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
20991>>>>>>>>>>>>>// in the help folder for more details.
20991>>>>>>>>>>>>>//
20991>>>>>>>>>>>>>Use Winkern.pkg
20991>>>>>>>>>>>>>Use cIniFile.pkg
20991>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
20991>>>>>>>>>>>>>>>Use VdfBase.pkg
20991>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
20991>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
20991>>>>>>>>>>>>>>>>>// Algorithm classes
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
20991>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Algorithm types
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
20991>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Generic sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// RSA sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// DSS sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// DES sub_ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
20991>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
20991>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
20991>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
20991>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
20991>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
20991>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
20991>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
20991>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Fortezza sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
20991>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// RC2 sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
20991>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
20991>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Hash sub ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
20991>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
20991>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
20991>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
20991>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
20991>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
20991>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// secure channel sub ids
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
20991>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
20991>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
20991>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// algorithm identifier definitions
20991>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
20991>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
20991>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
20991>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
20991>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
20991>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
20991>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
20991>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
20991>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
20991>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
20991>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
20991>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
20991>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
20991>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
20991>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
20991>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
20991>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
20991>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
20991>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
20991>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
20991>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
20991>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
20991>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
20991>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
20991>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
20991>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
20991>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
20991>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
20991>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
20991>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
20991>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
20991>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
20991>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
20991>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
20991>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
20991>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
20991>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
20991>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
20991>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
20991>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
20991>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
20991>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
20991>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
20991>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Providers
20991>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
20991>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
20991>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
20991>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
20991>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
20991>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
20991>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
20991>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
20991>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
20991>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
20991>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
20991>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
20991>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
20991>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
20991>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
20991>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
20991>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
20991>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
20991>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
20991>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
20991>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
20991>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
20991>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
20991>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
20991>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Provider types
20991>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
20991>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
20991>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
20991>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
20991>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
20991>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
20991>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
20991>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
20991>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
20991>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
20991>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
20991>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
20991>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
20991>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
20991>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
20991>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
20991>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
20991>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// KP_MODE
20991>>>>>>>>>>>>>>>>>// KP_MODE
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
20991>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
20991>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
20991>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
20991>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
20991>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
20991>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
20991>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
20991>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
20991>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
20991>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
20991>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
20991>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
20991>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
20991>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
20991>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
20991>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
20991>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
20991>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
20991>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
20991>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
20991>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
20991>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
20991>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
20991>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
20991>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
20991>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
20991>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
20991>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
20991>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
20991>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
20991>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
20991>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
20991>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
20991>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
20991>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
20991>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
20991>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
20991>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
20991>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
20991>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
20991>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
20991>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
20991>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
20991>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
20991>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
20991>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
20991>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// key BLOB types
20991>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
20991>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
20991>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
20991>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
20991>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
20991>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
20991>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
20991>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// KP_PADDING
20991>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
20991>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
20991>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
20991>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
20991>>>>>>>>>>>>>>>>>    UChar    bType
20991>>>>>>>>>>>>>>>>>    UChar    bVersion
20991>>>>>>>>>>>>>>>>>    UShort   reserved
20991>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
20991>>>>>>>>>>>>>>>>>End_Struct
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
20991>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
20991>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
20991>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
20991>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
20991>>>>>>>>>>>>>>>>>End_Struct
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
20991>>>>>>>>>>>>>>>>>Struct HMAC_INFO
20991>>>>>>>>>>>>>>>>>    UInteger HashAlgid
20991>>>>>>>>>>>>>>>>>    Pointer pbInnerString
20991>>>>>>>>>>>>>>>>>    DWord cbInnerString
20991>>>>>>>>>>>>>>>>>    Pointer pbOuterString
20991>>>>>>>>>>>>>>>>>    DWord cbOuterString
20991>>>>>>>>>>>>>>>>>End_Struct
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>Struct BLOBHEADER
20991>>>>>>>>>>>>>>>>>    UChar   bType
20991>>>>>>>>>>>>>>>>>    UChar   bVersion
20991>>>>>>>>>>>>>>>>>    Short   reserved
20991>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
20991>>>>>>>>>>>>>>>>>End_Struct
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>Struct CryptoBlob
20991>>>>>>>>>>>>>>>>>    BLOBHEADER  header
20991>>>>>>>>>>>>>>>>>    BLOBHEADER  header
20991>>>>>>>>>>>>>>>>>    Integer     cbKeySize
20991>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
20991>>>>>>>>>>>>>>>>>End_Struct
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>
20991>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
20991>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
20992>>>>>>>>>>>>>>>>>
20992>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
20992>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
20994>>>>>>>>>>>>>>>>>    
20994>>>>>>>>>>>>>>>>>    Boolean bResult
20994>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
20994>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
20994>>>>>>>>>>>>>>>>>
20994>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
20995>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
20996>>>>>>>>>>>>>>>>>    
20996>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
20997>>>>>>>>>>>>>>>>>
20997>>>>>>>>>>>>>>>>>    Function_Return bResult
20998>>>>>>>>>>>>>>>>>End_Function
20999>>>>>>>>>>>>>>>>>
20999>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
21000>>>>>>>>>>>>>>>>>
21000>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
21001>>>>>>>>>>>>>>>>>
21001>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
21002>>>>>>>>>>>>>>>>>
21002>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
21003>>>>>>>>>>>>>>>>>
21003>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
21004>>>>>>>>>>>>>>>>>
21004>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
21005>>>>>>>>>>>>>>>>>
21005>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
21006>>>>>>>>>>>>>>>>>
21006>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
21007>>>>>>>>>>>>>>>>>
21007>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
21008>>>>>>>>>>>>>>>>>    
21008>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
21009>>>>>>>>>>>>>>>>>
21009>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
21010>>>>>>>>>>>>>>>>>
21010>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
21011>>>>>>>>>>>>>>>>>
21011>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
21012>>>>>>>>>>>>>>>>>    
21012>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
21013>>>>>>>>>>>>>>>>>    
21013>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
21014>>>>>>>>>>>>>>>>>    
21014>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
21015>>>>>>>>>>>>>>>
21015>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
21016>>>>>>>>>>>>>>>    
21016>>>>>>>>>>>>>>>    Procedure Construct_Object
21018>>>>>>>>>>>>>>>        Forward Send Construct_Object
21020>>>>>>>>>>>>>>>        
21020>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
21021>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
21022>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
21023>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
21024>>>>>>>>>>>>>>>        
21024>>>>>>>>>>>>>>>        // Private properties
21024>>>>>>>>>>>>>>>        Property Handle     Private_phProv
21025>>>>>>>>>>>>>>>        
21025>>>>>>>>>>>>>>>        // Block cipher properties
21025>>>>>>>>>>>>>>>        Property UChar[]    paKey
21026>>>>>>>>>>>>>>>        Property UChar[]    paIV
21027>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
21028>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
21029>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
21030>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
21031>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
21032>>>>>>>>>>>>>>>    End_Procedure
21033>>>>>>>>>>>>>>>    
21033>>>>>>>>>>>>>>>    
21033>>>>>>>>>>>>>>>    // Acquire key container handle
21033>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
21035>>>>>>>>>>>>>>>        Integer iProvider
21035>>>>>>>>>>>>>>>        WString wProvider
21035>>>>>>>>>>>>>>>        Handle hProv
21035>>>>>>>>>>>>>>>        Boolean bOk
21035>>>>>>>>>>>>>>>        Pointer pProv
21035>>>>>>>>>>>>>>>        
21035>>>>>>>>>>>>>>>        Move 0 to hProv
21036>>>>>>>>>>>>>>>        Get piProvider to iProvider
21037>>>>>>>>>>>>>>>        Get psProvider to wProvider
21038>>>>>>>>>>>>>>>        
21038>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
21038>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
21040>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
21041>>>>>>>>>>>>>>>        End
21041>>>>>>>>>>>>>>>>
21041>>>>>>>>>>>>>>>        Else Begin
21042>>>>>>>>>>>>>>>            Move 0 to pProv
21043>>>>>>>>>>>>>>>        End
21043>>>>>>>>>>>>>>>>
21043>>>>>>>>>>>>>>>        
21043>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
21043>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
21044>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
21046>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
21047>>>>>>>>>>>>>>>        End
21047>>>>>>>>>>>>>>>>
21047>>>>>>>>>>>>>>>        
21047>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
21049>>>>>>>>>>>>>>>            // Fallback to original
21049>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
21050>>>>>>>>>>>>>>>            
21050>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
21052>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
21053>>>>>>>>>>>>>>>            End
21053>>>>>>>>>>>>>>>>
21053>>>>>>>>>>>>>>>        End
21053>>>>>>>>>>>>>>>>
21053>>>>>>>>>>>>>>>        Set Private_phProv to hProv
21054>>>>>>>>>>>>>>>        
21054>>>>>>>>>>>>>>>        Function_Return hProv
21055>>>>>>>>>>>>>>>    End_Function
21056>>>>>>>>>>>>>>>    
21056>>>>>>>>>>>>>>>    // Releases key container handle
21056>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
21058>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
21059>>>>>>>>>>>>>>>    End_Function
21060>>>>>>>>>>>>>>>    
21060>>>>>>>>>>>>>>>    // Creates hash object
21060>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
21062>>>>>>>>>>>>>>>        Integer iAlgorithm
21062>>>>>>>>>>>>>>>        Handle hHash
21062>>>>>>>>>>>>>>>        Boolean bOk
21062>>>>>>>>>>>>>>>        
21062>>>>>>>>>>>>>>>        Move 0 to hHash
21063>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
21064>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
21065>>>>>>>>>>>>>>>        
21065>>>>>>>>>>>>>>>        Function_Return hHash
21066>>>>>>>>>>>>>>>    End_Function
21067>>>>>>>>>>>>>>>    
21067>>>>>>>>>>>>>>>    // Destroys the hash object
21067>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
21069>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
21070>>>>>>>>>>>>>>>    End_Function
21071>>>>>>>>>>>>>>>    
21071>>>>>>>>>>>>>>>    // Adds data to hash object
21071>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
21073>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
21074>>>>>>>>>>>>>>>    End_Function
21075>>>>>>>>>>>>>>>    
21075>>>>>>>>>>>>>>>    // Generates session key
21075>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
21077>>>>>>>>>>>>>>>        Integer iAlgorithm
21077>>>>>>>>>>>>>>>        Handle hKey
21077>>>>>>>>>>>>>>>        Boolean bOk
21077>>>>>>>>>>>>>>>        
21077>>>>>>>>>>>>>>>        Move 0 to hKey
21078>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
21079>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
21080>>>>>>>>>>>>>>>        
21080>>>>>>>>>>>>>>>        Function_Return hKey
21081>>>>>>>>>>>>>>>    End_Function
21082>>>>>>>>>>>>>>>    
21082>>>>>>>>>>>>>>>    // Imports a plain text key
21082>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
21084>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
21084>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
21084>>>>>>>>>>>>>>>        Boolean   bSuccess
21084>>>>>>>>>>>>>>>        Handle    hKey
21084>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
21084>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
21085>>>>>>>>>>>>>>>        Integer iVoid
21085>>>>>>>>>>>>>>>        
21085>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
21086>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
21087>>>>>>>>>>>>>>>        
21087>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
21088>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
21089>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
21090>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
21091>>>>>>>>>>>>>>>        
21091>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
21092>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
21093>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
21094>>>>>>>>>>>>>>>        
21094>>>>>>>>>>>>>>>        Move 0 to hKey
21095>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
21096>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
21098>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
21099>>>>>>>>>>>>>>>        End
21099>>>>>>>>>>>>>>>>
21099>>>>>>>>>>>>>>>        
21099>>>>>>>>>>>>>>>        Function_Return hKey
21100>>>>>>>>>>>>>>>    End_Function
21101>>>>>>>>>>>>>>>    
21101>>>>>>>>>>>>>>>    // Destroys the key
21101>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
21103>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
21104>>>>>>>>>>>>>>>    End_Function
21105>>>>>>>>>>>>>>>    
21105>>>>>>>>>>>>>>>    // Retrieves key data
21105>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
21107>>>>>>>>>>>>>>>        Integer iBuffer iLen
21107>>>>>>>>>>>>>>>        Boolean bOk
21107>>>>>>>>>>>>>>>        
21107>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
21108>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
21109>>>>>>>>>>>>>>>        Function_Return iBuffer
21110>>>>>>>>>>>>>>>    End_Function
21111>>>>>>>>>>>>>>>    
21111>>>>>>>>>>>>>>>    // Retrieves a hash value
21111>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
21113>>>>>>>>>>>>>>>        UChar[] ucHash
21114>>>>>>>>>>>>>>>        Integer liResult
21114>>>>>>>>>>>>>>>        DWord   dwDataLen
21114>>>>>>>>>>>>>>>        
21114>>>>>>>>>>>>>>>        Move 0 to dwDataLen
21115>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
21116>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
21119>>>>>>>>>>>>>>>        
21119>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
21120>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
21121>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
21124>>>>>>>>>>>>>>>        
21124>>>>>>>>>>>>>>>        Function_Return ucHash
21125>>>>>>>>>>>>>>>    End_Function
21126>>>>>>>>>>>>>>>
21126>>>>>>>>>>>>>>>    // Encrypts data
21126>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
21128>>>>>>>>>>>>>>>        Handle hProv hHash hKey
21128>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
21128>>>>>>>>>>>>>>>        Boolean bOk
21128>>>>>>>>>>>>>>>        
21128>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21129>>>>>>>>>>>>>>>        If (hProv) Begin
21131>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
21132>>>>>>>>>>>>>>>            If (hHash) Begin
21134>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
21135>>>>>>>>>>>>>>>                If (bOk) Begin
21137>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
21138>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
21139>>>>>>>>>>>>>>>                End
21139>>>>>>>>>>>>>>>>
21139>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
21140>>>>>>>>>>>>>>>            End
21140>>>>>>>>>>>>>>>>
21140>>>>>>>>>>>>>>>            
21140>>>>>>>>>>>>>>>            If (hKey) Begin
21142>>>>>>>>>>>>>>>                //  First call to determine resulting data size
21142>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
21143>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
21144>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
21145>>>>>>>>>>>>>>>                
21145>>>>>>>>>>>>>>>                //  Reserve space in string
21145>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
21147>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
21148>>>>>>>>>>>>>>>                End
21148>>>>>>>>>>>>>>>>
21148>>>>>>>>>>>>>>>                
21148>>>>>>>>>>>>>>>                //  Call to really decrypt
21148>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
21149>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
21149>>>>>>>>>>>>>>>                //Move "" to sData
21149>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
21149>>>>>>>>>>>>>>>                //End
21149>>>>>>>>>>>>>>>                
21149>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21150>>>>>>>>>>>>>>>            End 
21150>>>>>>>>>>>>>>>>
21150>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21151>>>>>>>>>>>>>>>        End 
21151>>>>>>>>>>>>>>>>
21151>>>>>>>>>>>>>>>        Function_Return ucData
21152>>>>>>>>>>>>>>>    End_Function
21153>>>>>>>>>>>>>>>    
21153>>>>>>>>>>>>>>>    // Decrypts data
21153>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
21155>>>>>>>>>>>>>>>        Handle hProv hHash hKey
21155>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
21155>>>>>>>>>>>>>>>        Boolean bOk
21155>>>>>>>>>>>>>>>        
21155>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21156>>>>>>>>>>>>>>>        If (hProv) Begin
21158>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
21159>>>>>>>>>>>>>>>            If (hHash) Begin
21161>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
21162>>>>>>>>>>>>>>>                If (bOk) Begin
21164>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
21165>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
21166>>>>>>>>>>>>>>>                End
21166>>>>>>>>>>>>>>>>
21166>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
21167>>>>>>>>>>>>>>>            End
21167>>>>>>>>>>>>>>>>
21167>>>>>>>>>>>>>>>            
21167>>>>>>>>>>>>>>>            If (hKey) Begin
21169>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
21170>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
21171>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
21171>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
21173>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
21174>>>>>>>>>>>>>>>                End
21174>>>>>>>>>>>>>>>>
21174>>>>>>>>>>>>>>>                
21174>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21175>>>>>>>>>>>>>>>            End
21175>>>>>>>>>>>>>>>>
21175>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21176>>>>>>>>>>>>>>>        End
21176>>>>>>>>>>>>>>>>
21176>>>>>>>>>>>>>>>        Function_Return ucData
21177>>>>>>>>>>>>>>>    End_Function
21178>>>>>>>>>>>>>>>    
21178>>>>>>>>>>>>>>>    // Creates a key
21178>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
21180>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
21180>>>>>>>>>>>>>>>        CryptoBlob keyBlob
21180>>>>>>>>>>>>>>>        CryptoBlob keyBlob
21180>>>>>>>>>>>>>>>        Boolean bOk
21180>>>>>>>>>>>>>>>        Handle hKey
21180>>>>>>>>>>>>>>>        UChar[] aKey
21181>>>>>>>>>>>>>>>
21181>>>>>>>>>>>>>>>        Get paKey to aKey
21182>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
21183>>>>>>>>>>>>>>>        Get piKeyType to iType
21184>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
21185>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
21186>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
21187>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
21188>>>>>>>>>>>>>>>        
21188>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
21189>>>>>>>>>>>>>>>        For iByte from 0 to iLength
21195>>>>>>>>>>>>>>>>
21195>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
21196>>>>>>>>>>>>>>>        Loop
21197>>>>>>>>>>>>>>>>
21197>>>>>>>>>>>>>>>        
21197>>>>>>>>>>>>>>>        Move 0 to hKey
21198>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
21199>>>>>>>>>>>>>>>        Function_Return hKey
21200>>>>>>>>>>>>>>>    End_Function
21201>>>>>>>>>>>>>>>    
21201>>>>>>>>>>>>>>>    // Sets the key parameters
21201>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
21203>>>>>>>>>>>>>>>        Integer iPadding iMode
21203>>>>>>>>>>>>>>>        Boolean bOk
21203>>>>>>>>>>>>>>>        UChar[] aIV
21204>>>>>>>>>>>>>>>        
21204>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
21204>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
21204>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
21204>>>>>>>>>>>>>>>        //Loop
21204>>>>>>>>>>>>>>>
21204>>>>>>>>>>>>>>>        // Set initialization vector
21204>>>>>>>>>>>>>>>        Get paIV to aIV
21205>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
21206>>>>>>>>>>>>>>>        If (bOk) Begin
21208>>>>>>>>>>>>>>>            // Set padding
21208>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
21209>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
21210>>>>>>>>>>>>>>>            If (bOk) Begin
21212>>>>>>>>>>>>>>>                // Set move
21212>>>>>>>>>>>>>>>                Get piKeyMode to iMode
21213>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
21214>>>>>>>>>>>>>>>            End
21214>>>>>>>>>>>>>>>>
21214>>>>>>>>>>>>>>>        End
21214>>>>>>>>>>>>>>>>
21214>>>>>>>>>>>>>>>        Function_Return bOk        
21215>>>>>>>>>>>>>>>    End_Function
21216>>>>>>>>>>>>>>>    
21216>>>>>>>>>>>>>>>    // Encrypts using block cipher
21216>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
21218>>>>>>>>>>>>>>>        Handle hProv hKey
21218>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
21218>>>>>>>>>>>>>>>        Boolean bOk
21218>>>>>>>>>>>>>>>        
21218>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21219>>>>>>>>>>>>>>>        If (hProv) Begin
21221>>>>>>>>>>>>>>>            // Create key
21221>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
21222>>>>>>>>>>>>>>>            If (hKey) Begin
21224>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
21225>>>>>>>>>>>>>>>                If (bOk) Begin
21227>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
21227>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
21228>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
21229>>>>>>>>>>>>>>>                    
21229>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
21230>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
21231>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
21232>>>>>>>>>>>>>>>                End
21232>>>>>>>>>>>>>>>>
21232>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21233>>>>>>>>>>>>>>>            End
21233>>>>>>>>>>>>>>>>
21233>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21234>>>>>>>>>>>>>>>        End
21234>>>>>>>>>>>>>>>>
21234>>>>>>>>>>>>>>>        Function_Return ucData
21235>>>>>>>>>>>>>>>    End_Function
21236>>>>>>>>>>>>>>>    
21236>>>>>>>>>>>>>>>    // Decrypts using block cipher
21236>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
21238>>>>>>>>>>>>>>>        Handle hProv hKey
21238>>>>>>>>>>>>>>>        Integer iLen
21238>>>>>>>>>>>>>>>        Boolean bOk
21238>>>>>>>>>>>>>>>        
21238>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21239>>>>>>>>>>>>>>>        If (hProv) Begin
21241>>>>>>>>>>>>>>>            // Create key
21241>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
21242>>>>>>>>>>>>>>>            If (hKey) Begin
21244>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
21245>>>>>>>>>>>>>>>                If (bOk) Begin
21247>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
21248>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
21249>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
21250>>>>>>>>>>>>>>>                End
21250>>>>>>>>>>>>>>>>
21250>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
21251>>>>>>>>>>>>>>>            End
21251>>>>>>>>>>>>>>>>
21251>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
21252>>>>>>>>>>>>>>>        End
21252>>>>>>>>>>>>>>>>
21252>>>>>>>>>>>>>>>        Function_Return ucData
21253>>>>>>>>>>>>>>>    End_Function
21254>>>>>>>>>>>>>>>    
21254>>>>>>>>>>>>>>>    
21254>>>>>>>>>>>>>>>    //  Generates random data.
21254>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
21256>>>>>>>>>>>>>>>        Handle hProv
21256>>>>>>>>>>>>>>>        UChar[] uaResult
21257>>>>>>>>>>>>>>>        Boolean bRes
21257>>>>>>>>>>>>>>>        
21257>>>>>>>>>>>>>>>        Get AcquireContext to hProv
21258>>>>>>>>>>>>>>>        
21258>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
21259>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
21260>>>>>>>>>>>>>>>        
21260>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
21261>>>>>>>>>>>>>>>        
21261>>>>>>>>>>>>>>>        Function_Return uaResult
21262>>>>>>>>>>>>>>>    End_Function
21263>>>>>>>>>>>>>>>    
21263>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
21263>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
21265>>>>>>>>>>>>>>>        String sResult
21265>>>>>>>>>>>>>>>        UChar[] ucData
21266>>>>>>>>>>>>>>>        Pointer pBase64
21266>>>>>>>>>>>>>>>        Integer iVoid
21266>>>>>>>>>>>>>>>        
21266>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
21267>>>>>>>>>>>>>>>        
21267>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
21268>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
21269>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21270>>>>>>>>>>>>>>>        
21270>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
21271>>>>>>>>>>>>>>>    End_Function
21272>>>>>>>>>>>>>>>    
21272>>>>>>>>>>>>>>>End_Class
21273>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
21273>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
21273>>>>>>>>>>>>>>>//>
21273>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
21273>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
21273>>>>>>>>>>>>>>>//>
21273>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
21273>>>>>>>>>>>>>>>//> strings.
21273>>>>>>>>>>>>>>>//>
21273>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
21273>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
21273>>>>>>>>>>>>>>>//>
21273>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
21273>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
21273>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
21273>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
21273>>>>>>>>>>>>>>>
21273>>>>>>>>>>>>>>>Use VdfBase.pkg
21273>>>>>>>>>>>>>>>
21273>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
21273>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
21274>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
21275>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
21276>>>>>>>>>>>>>>>
21276>>>>>>>>>>>>>>>// Structure
21276>>>>>>>>>>>>>>>Struct txxfBase64Buffer
21276>>>>>>>>>>>>>>>    Pointer pData
21276>>>>>>>>>>>>>>>    Integer iLength
21276>>>>>>>>>>>>>>>End_Struct 
21276>>>>>>>>>>>>>>>
21276>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
21276>>>>>>>>>>>>>>>
21276>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
21278>>>>>>>>>>>>>>>    Move Self to oBase64Functions
21279>>>>>>>>>>>>>>>
21279>>>>>>>>>>>>>>>
21279>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
21282>>>>>>>>>>>>>>>        Address pBase64
21282>>>>>>>>>>>>>>>        String sResult
21282>>>>>>>>>>>>>>>        Integer iVoid
21282>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
21283>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
21284>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21285>>>>>>>>>>>>>>>        Function_Return sResult
21286>>>>>>>>>>>>>>>    End_Function
21287>>>>>>>>>>>>>>>
21287>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
21290>>>>>>>>>>>>>>>        Address pBinary
21290>>>>>>>>>>>>>>>        String sBinary
21290>>>>>>>>>>>>>>>        Integer iVoid iLen
21290>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
21291>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
21292>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
21293>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
21294>>>>>>>>>>>>>>>        Function_Return sBinary
21295>>>>>>>>>>>>>>>    End_Function
21296>>>>>>>>>>>>>>>
21296>>>>>>>>>>>>>>>End_Object
21297>>>>>>>>>>>>>Use MSSqldrv.pkg
21297>>>>>>>>>>>>>Use db2_drv.pkg
21297>>>>>>>>>>>>>Use odbc_drv.pkg
21297>>>>>>>>>>>>>Use DFBtrDrv.pkg
21297>>>>>>>>>>>>>Use vWin32fh.pkg
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>Use DUFLanguageConstants.inc
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
21297>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
21297>>>>>>>>>>>>>// They can have slightly different SQL keywords.
21297>>>>>>>>>>>>>// Note: If a new type is added to the list,
21297>>>>>>>>>>>>>//       the struct array xxx must be adjusted
21297>>>>>>>>>>>>>//       so that it is filled with all SQL
21297>>>>>>>>>>>>>//       keywords for that new type.
21297>>>>>>>>>>>>>Enum_List  
21297>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
21297>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
21297>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
21297>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
21297>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
21297>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
21297>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
21297>>>>>>>>>>>>>End_Enum_List
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
21297>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
21297>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
21297>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
21297>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
21297>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
21297>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
21297>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
21297>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
21297>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// SQLConnection.ini constants:
21297>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
21297>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
21297>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
21297>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
21297>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// DF 19 ini-file settings:
21297>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
21297>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
21297>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
21297>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
21297>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
21297>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
21297>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
21297>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
21297>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
21297>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
21297>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
21297>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// Database Update Framework extended settings:
21297>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
21297>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
21297>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
21297>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
21297>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
21297>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
21297>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
21297>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
21297>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>Struct tSQLConnection
21297>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
21297>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
21297>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
21297>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
21297>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
21297>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
21297>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
21297>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
21297>>>>>>>>>>>>>    String sUserID                  // 9. User ID
21297>>>>>>>>>>>>>    String sPassword                // 10. Password
21297>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
21297>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
21297>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
21297>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
21297>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
21297>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
21297>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
21297>>>>>>>>>>>>>End_Struct
21297>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
21297>>>>>>>>>>>>>Use DUFLanguageConstants.inc
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
21297>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
21297>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
21297>>>>>>>>>>>>>
21297>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
21297>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSQLScriptArray
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
21298>>>>>>>>>>>>>    Integer iOrgArgumentSize
21298>>>>>>>>>>>>>    String[] sSQLScriptArray
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSqlErrorArray
21298>>>>>>>>>>>>>    String[]  sSqlErrorArray
21298>>>>>>>>>>>>>    String[]  sSqlStatementArray
21298>>>>>>>>>>>>>    Integer[] iSqlErrorArray
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSqlColumnNew
21298>>>>>>>>>>>>>    String  sBaseColumnName
21298>>>>>>>>>>>>>    String  sBaseTableName
21298>>>>>>>>>>>>>    String  sLabel
21298>>>>>>>>>>>>>    Integer iSqlType
21298>>>>>>>>>>>>>    Integer iSize
21298>>>>>>>>>>>>>    Integer iPrecision
21298>>>>>>>>>>>>>    Integer iDFType
21298>>>>>>>>>>>>>    Integer iDFNativeType
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tColumnType
21298>>>>>>>>>>>>>    String  sSQLType
21298>>>>>>>>>>>>>    Integer iSQLType
21298>>>>>>>>>>>>>    Boolean bCanEditSize
21298>>>>>>>>>>>>>    Integer iDefaultSize
21298>>>>>>>>>>>>>    Integer iMinSize
21298>>>>>>>>>>>>>    Number  nMaxSize
21298>>>>>>>>>>>>>    String  sDataFlexType
21298>>>>>>>>>>>>>    Integer iDataFlexType
21298>>>>>>>>>>>>>    Boolean bNativeDataType
21298>>>>>>>>>>>>>    String  sPrecision
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
21298>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
21298>>>>>>>>>>>>>// keywords.
21298>>>>>>>>>>>>>Struct tSQLKeyWords
21298>>>>>>>>>>>>>    Integer iSQLWord
21298>>>>>>>>>>>>>    Integer iSQLDbType
21298>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSQLRelation
21298>>>>>>>>>>>>>    Integer iFileNumber
21298>>>>>>>>>>>>>    Integer iFieldNumber
21298>>>>>>>>>>>>>    String  sFileName
21298>>>>>>>>>>>>>    String  sFieldName
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSQLLoggedInUser
21298>>>>>>>>>>>>>    String sUser
21298>>>>>>>>>>>>>    String sProgram
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
21298>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
21298>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
21298>>>>>>>>>>>>>// They can have slightly different SQL keywords.
21298>>>>>>>>>>>>>// Note: If a new type is added to the list,
21298>>>>>>>>>>>>>//       the struct array xxx must be adjusted
21298>>>>>>>>>>>>>//       so that it is filled with all SQL
21298>>>>>>>>>>>>>//       keywords for that new type.
21298>>>>>>>>>>>>>Enum_List
21298>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
21298>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
21298>>>>>>>>>>>>>//    Define EN_DbTypeOracle
21298>>>>>>>>>>>>>//    Define EN_DbTypeDB2
21298>>>>>>>>>>>>>//    Define EN_DbTypePostgre
21298>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
21298>>>>>>>>>>>>>End_Enum_List
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
21298>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
21298>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
21298>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
21298>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
21298>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
21298>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
21298>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
21298>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
21298>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
21298>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
21298>>>>>>>>>>>>>Enum_List
21298>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
21298>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
21298>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
21298>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
21298>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
21298>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
21298>>>>>>>>>>>>>End_Enum_List
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
21298>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
21298>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// These are not defined pre DF 18:
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSQLIntTableInfo
21298>>>>>>>>>>>>>    String sDriverName
21298>>>>>>>>>>>>>    String sServerName
21298>>>>>>>>>>>>>    String sDatabaseName
21298>>>>>>>>>>>>>    String sSchemaName
21298>>>>>>>>>>>>>    Boolean bRecnumTable
21298>>>>>>>>>>>>>    Integer iPrimaryIndex
21298>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
21298>>>>>>>>>>>>>    String sTableCharacterFormat
21298>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
21298>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
21298>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
21298>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
21298>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
21298>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
21298>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
21298>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
21298>>>>>>>>>>>>>    String sFileIndexTablespace
21298>>>>>>>>>>>>>    String sFileLongTablespace
21298>>>>>>>>>>>>>    String sTableTablespace
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tSQLIntColumnInfo
21298>>>>>>>>>>>>>    Integer iFieldNumber
21298>>>>>>>>>>>>>    Integer iFieldIndex
21298>>>>>>>>>>>>>    Integer iFieldRelatedFile
21298>>>>>>>>>>>>>    Integer iFieldRelatedField
21298>>>>>>>>>>>>>    Integer iIndexNumber
21298>>>>>>>>>>>>>    Integer iIndexNumberSegments
21298>>>>>>>>>>>>>    Integer iIndexSegmentField1
21298>>>>>>>>>>>>>    Integer iIndexSegmentField2
21298>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
21298>>>>>>>>>>>>>    String  sIndexName
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIColumn
21298>>>>>>>>>>>>>    Integer iFieldNumber
21298>>>>>>>>>>>>>    String  sFieldName
21298>>>>>>>>>>>>>    Integer iType
21298>>>>>>>>>>>>>    String  sType
21298>>>>>>>>>>>>>    Integer iLength
21298>>>>>>>>>>>>>    Integer iPrecision
21298>>>>>>>>>>>>>    Integer iOptions
21298>>>>>>>>>>>>>    Boolean bIsSQLType
21298>>>>>>>>>>>>>    Boolean bAllowNULL
21298>>>>>>>>>>>>>    String  sDefaultValue
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIColumnCompare
21298>>>>>>>>>>>>>    Integer iFieldNumber
21298>>>>>>>>>>>>>    // FROM database:
21298>>>>>>>>>>>>>    Boolean bExistsFrom
21298>>>>>>>>>>>>>    String  sFieldNameFrom
21298>>>>>>>>>>>>>    Integer iTypeFrom
21298>>>>>>>>>>>>>    String  sTypeFrom
21298>>>>>>>>>>>>>    Integer iLengthFrom
21298>>>>>>>>>>>>>    Integer iPrecisionFrom
21298>>>>>>>>>>>>>    Integer iOptionsFrom
21298>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
21298>>>>>>>>>>>>>    Boolean bAllowNULLFrom
21298>>>>>>>>>>>>>    String  sDefaultValueFrom
21298>>>>>>>>>>>>>    Boolean bShouldChangeFrom
21298>>>>>>>>>>>>>    Boolean bCancelFrom
21298>>>>>>>>>>>>>    Boolean bErrorFrom
21298>>>>>>>>>>>>>    // TO database:
21298>>>>>>>>>>>>>    Boolean bExistsTo
21298>>>>>>>>>>>>>    Integer iFieldNumberTo
21298>>>>>>>>>>>>>    String  sFieldNameTo
21298>>>>>>>>>>>>>    Integer iTypeTo
21298>>>>>>>>>>>>>    String  sTypeTo
21298>>>>>>>>>>>>>    Integer iLengthTo
21298>>>>>>>>>>>>>    Integer iPrecisionTo
21298>>>>>>>>>>>>>    Integer iOptionsTo
21298>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
21298>>>>>>>>>>>>>    Boolean bAllowNULLTo
21298>>>>>>>>>>>>>    String  sDefaultValueTo
21298>>>>>>>>>>>>>    Boolean bShouldChangeTo
21298>>>>>>>>>>>>>    Boolean bCancelTo
21298>>>>>>>>>>>>>    Boolean bErrorTo
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIRelation
21298>>>>>>>>>>>>>    Handle  hTableFrom
21298>>>>>>>>>>>>>    Integer iColumnFrom
21298>>>>>>>>>>>>>    Handle  hTableTo
21298>>>>>>>>>>>>>    Integer iColumnTo
21298>>>>>>>>>>>>>    String  sLogicalNameFrom
21298>>>>>>>>>>>>>    String  sLogicalNameTo
21298>>>>>>>>>>>>>    String  sFieldNameFrom
21298>>>>>>>>>>>>>    String  sFieldNameTo
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIRelationCompare
21298>>>>>>>>>>>>>    // Common:
21298>>>>>>>>>>>>>    Handle  hTableFrom
21298>>>>>>>>>>>>>    Integer iColumnFrom
21298>>>>>>>>>>>>>    Handle  hTableTo
21298>>>>>>>>>>>>>    Integer iColumnTo
21298>>>>>>>>>>>>>    // FROM database:
21298>>>>>>>>>>>>>    Boolean bExistsFrom
21298>>>>>>>>>>>>>    String  sLogicalNameFrom_From
21298>>>>>>>>>>>>>    String  sLogicalNameTo_From
21298>>>>>>>>>>>>>    String  sFieldNameFrom_From
21298>>>>>>>>>>>>>    String  sFieldNameTo_From
21298>>>>>>>>>>>>>    Boolean bShouldChange_From
21298>>>>>>>>>>>>>    Boolean bCancel_From
21298>>>>>>>>>>>>>    Boolean bError_From
21298>>>>>>>>>>>>>    // TO database:
21298>>>>>>>>>>>>>    Boolean bExistsTo
21298>>>>>>>>>>>>>    String  sLogicalNameFrom_To
21298>>>>>>>>>>>>>    String  sLogicalNameTo_To
21298>>>>>>>>>>>>>    String  sFieldNameFrom_To
21298>>>>>>>>>>>>>    String  sFieldNameTo_To
21298>>>>>>>>>>>>>    Boolean bShouldChange_To
21298>>>>>>>>>>>>>    Boolean bCancel_To
21298>>>>>>>>>>>>>    Boolean bError_To
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIIndexSegment
21298>>>>>>>>>>>>>    Integer iFieldNumber
21298>>>>>>>>>>>>>    String  sFieldName
21298>>>>>>>>>>>>>    Boolean bUppercase
21298>>>>>>>>>>>>>    Boolean bAscending
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIIndex
21298>>>>>>>>>>>>>    Integer iIndexNumber
21298>>>>>>>>>>>>>    Integer iPrimaryIndex
21298>>>>>>>>>>>>>    String  sSQLIndexName
21298>>>>>>>>>>>>>    Integer iSQLIndexType
21298>>>>>>>>>>>>>    Boolean bIsSQLClustered
21298>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
21298>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
21298>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPIIndexCompare
21298>>>>>>>>>>>>>    // Common:
21298>>>>>>>>>>>>>    Integer iIndexNumber
21298>>>>>>>>>>>>>    // FROM database:
21298>>>>>>>>>>>>>    Boolean bExistsFrom
21298>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
21298>>>>>>>>>>>>>    String  sSQLIndexNameFrom
21298>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
21298>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
21298>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
21298>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
21298>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
21298>>>>>>>>>>>>>    Boolean bShouldChangeFrom
21298>>>>>>>>>>>>>    Boolean bCancelFrom
21298>>>>>>>>>>>>>    Boolean bErrorFrom
21298>>>>>>>>>>>>>    // TO database:
21298>>>>>>>>>>>>>    Boolean bExistsTo
21298>>>>>>>>>>>>>    Integer iPrimaryIndexTo
21298>>>>>>>>>>>>>    String  sSQLIndexNameTo
21298>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
21298>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
21298>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
21298>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
21298>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
21298>>>>>>>>>>>>>    Boolean bShouldChangeTo
21298>>>>>>>>>>>>>    Boolean bCancelTo
21298>>>>>>>>>>>>>    Boolean bErrorTo
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPITableNameInfo
21298>>>>>>>>>>>>>    Integer iTableNumber
21298>>>>>>>>>>>>>    String  sRootName
21298>>>>>>>>>>>>>    String  sLogicalName
21298>>>>>>>>>>>>>    String  sDisplayName
21298>>>>>>>>>>>>>    String  sDriverID
21298>>>>>>>>>>>>>    Boolean bIsAlias
21298>>>>>>>>>>>>>    Boolean bIsSQL
21298>>>>>>>>>>>>>    Boolean bIsSystemFile
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
21298>>>>>>>>>>>>>    Integer iTableNumber
21298>>>>>>>>>>>>>    // FROM
21298>>>>>>>>>>>>>    Boolean bExistsFrom
21298>>>>>>>>>>>>>    String  sRootNameFrom
21298>>>>>>>>>>>>>    String  sLogicalNameFrom
21298>>>>>>>>>>>>>    String  sDisplayNameFrom
21298>>>>>>>>>>>>>    String  sDriverIDFrom
21298>>>>>>>>>>>>>    Boolean bIsAliasFrom
21298>>>>>>>>>>>>>    Boolean bIsSQLFrom
21298>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
21298>>>>>>>>>>>>>    // TO database:
21298>>>>>>>>>>>>>    Boolean bExistsTo
21298>>>>>>>>>>>>>    String  sRootNameTo
21298>>>>>>>>>>>>>    String  sLogicalNameTo
21298>>>>>>>>>>>>>    String  sDisplayNameTo
21298>>>>>>>>>>>>>    String  sDriverIDTo
21298>>>>>>>>>>>>>    Boolean bIsAliasTo
21298>>>>>>>>>>>>>    Boolean bIsSQLTo
21298>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPITable
21298>>>>>>>>>>>>>    Handle hTable
21298>>>>>>>>>>>>>    Boolean bFromTable
21298>>>>>>>>>>>>>    Boolean bToTable
21298>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
21298>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
21298>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
21298>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
21298>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
21298>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
21298>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
21298>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
21298>>>>>>>>>>>>>    Boolean bShouldChange
21298>>>>>>>>>>>>>    Boolean bCancel
21298>>>>>>>>>>>>>    Boolean bError
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPITableCompare
21298>>>>>>>>>>>>>    Handle hTable
21298>>>>>>>>>>>>>    // FROM database:
21298>>>>>>>>>>>>>    Boolean bExistsFrom
21298>>>>>>>>>>>>>    // TO database:
21298>>>>>>>>>>>>>    Boolean bExistsTo
21298>>>>>>>>>>>>>    // Both:
21298>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
21298>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
21298>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
21298>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
21298>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
21298>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
21298>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
21298>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
21298>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
21298>>>>>>>>>>>>>    Boolean bCancel         // User cancel
21298>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Struct tAPITableBooleans
21298>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
21298>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
21298>>>>>>>>>>>>>    Boolean bCompareIndexAscending
21298>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
21298>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
21298>>>>>>>>>>>>>End_Struct
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
21298>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
21298>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
21298>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
21298>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
21298>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
21298>>>>>>>>>>>>>Enum_List
21298>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
21298>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
21298>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
21298>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
21298>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
21298>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
21298>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
21298>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
21298>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
21298>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
21298>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
21298>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
21298>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
21298>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
21298>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
21298>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
21298>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
21298>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
21298>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
21298>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
21298>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
21298>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
21298>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
21298>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
21298>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
21298>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
21298>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
21298>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
21298>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
21298>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
21298>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
21298>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
21298>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
21298>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
21298>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
21298>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
21298>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
21298>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
21298>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
21298>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
21298>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
21298>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
21298>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
21298>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
21298>>>>>>>>>>>>>End_Enum_List
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>>>
21298>>>>>>>>>>>
21298>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
21299>>>>>>>>>>>
21299>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
21301>>>>>>>>>>>        Handle hoSQLManagerMT
21301>>>>>>>>>>>
21301>>>>>>>>>>>        Property String private.psUseDatabase ""
21302>>>>>>>>>>>
21302>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
21302>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
21303>>>>>>>>>>>        Property Integer private.piCurrentField 0
21304>>>>>>>>>>>
21304>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
21305>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
21306>>>>>>>>>>>
21306>>>>>>>>>>>        Property Handle phoSQLManagerMT
21307>>>>>>>>>>>
21307>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
21308>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
21309>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
21310>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
21311>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
21312>>>>>>>>>>>
21312>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
21313>>>>>>>>>>>
21313>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
21314>>>>>>>>>>>        Property String[] paSQLFetchResults
21315>>>>>>>>>>>
21315>>>>>>>>>>>        // Error handling
21315>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
21316>>>>>>>>>>>        Property Boolean pbSqlError False
21317>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
21318>>>>>>>>>>>        Property Boolean pbProcessingError False
21319>>>>>>>>>>>
21319>>>>>>>>>>>        // Statistics on query
21319>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
21320>>>>>>>>>>>        Property TimeSpan ptsQueryExec
21321>>>>>>>>>>>        Property TimeSpan ptsFetchResults
21322>>>>>>>>>>>        Property Integer piColumns 0
21323>>>>>>>>>>>        Property Integer piRows 0
21324>>>>>>>>>>>        Property Integer piRowType 0
21325>>>>>>>>>>>        Property String[] paQueryMessages
21326>>>>>>>>>>>        Property String psSQLStatementString
21327>>>>>>>>>>>
21327>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
21328>>>>>>>>>>>
21328>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
21329>>>>>>>>>>>
21329>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
21329>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
21329>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
21329>>>>>>>>>>>        Property Integer piChunkMax 500
21330>>>>>>>>>>>
21330>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
21330>>>>>>>>>>>        Send SetupSQLKeywordArray
21331>>>>>>>>>>>    End_Procedure
21332>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
21332>>>>>>>>>>>>
21332>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
21334>>>>>>>>>>>>    Integer iStart iEnd
21334>>>>>>>>>>>>    String sRetval
21334>>>>>>>>>>>>
21334>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
21335>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
21336>>>>>>>>>>>>    If (iStart = 0) Begin
21338>>>>>>>>>>>>        Function_Return ""
21339>>>>>>>>>>>>    End
21339>>>>>>>>>>>>>
21339>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
21340>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
21341>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
21343>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21344>>>>>>>>>>>>    End
21344>>>>>>>>>>>>>
21344>>>>>>>>>>>>    Else Begin
21345>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
21346>>>>>>>>>>>>    End
21346>>>>>>>>>>>>>
21346>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
21348>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21349>>>>>>>>>>>>        Decrement iEnd
21350>>>>>>>>>>>>    End
21350>>>>>>>>>>>>>
21350>>>>>>>>>>>>    If (iEnd <> 0) Begin
21352>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
21353>>>>>>>>>>>>    End
21353>>>>>>>>>>>>>
21353>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
21354>>>>>>>>>>>>
21354>>>>>>>>>>>>    Function_Return (Trim(sRetval))
21355>>>>>>>>>>>>End_Function
21356>>>>>>>>>>>>
21356>>>>>>>>>>>>
21356>>>>>>>>>>>
21356>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
21356>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
21358>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
21360>>>>>>>>>>>            Function_Return (EQ)
21361>>>>>>>>>>>        End
21361>>>>>>>>>>>>
21361>>>>>>>>>>>        Function_Return (GT)
21362>>>>>>>>>>>    End_Function
21363>>>>>>>>>>>
21363>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
21363>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
21365>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
21368>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
21371>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
21374>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
21377>>>>>>>>>>>
21377>>>>>>>>>>>        Function_Return (EQ)
21378>>>>>>>>>>>    End_Function
21379>>>>>>>>>>>
21379>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
21381>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
21381>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
21382>>>>>>>>>>>        Integer iSize
21382>>>>>>>>>>>
21382>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
21383>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
21384>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
21385>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
21386>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
21387>>>>>>>>>>>
21387>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
21388>>>>>>>>>>>    End_Procedure
21389>>>>>>>>>>>
21389>>>>>>>>>>>    // Creates a struct array with all SQL keywords
21389>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
21389>>>>>>>>>>>    // have slightly different wording.
21389>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
21389>>>>>>>>>>>    // needs to be done for every keyword group below.
21389>>>>>>>>>>>    Procedure SetupSQLKeywordArray
21391>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
21391>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
21393>>>>>>>>>>>
21393>>>>>>>>>>>        // This should only be called once; but in case it is
21393>>>>>>>>>>>        // we delete the array first.
21393>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
21394>>>>>>>>>>>
21394>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
21394>>>>>>>>>>>        //
21394>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
21395>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
21396>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
21397>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
21398>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
21399>>>>>>>>>>>
21399>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
21400>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
21401>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
21402>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
21403>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
21404>>>>>>>>>>>
21404>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
21405>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
21406>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
21407>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
21408>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
21409>>>>>>>>>>>
21409>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
21410>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
21411>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
21412>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
21413>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
21414>>>>>>>>>>>
21414>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
21415>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
21416>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
21417>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
21418>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
21419>>>>>>>>>>>
21419>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
21420>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
21421>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
21422>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
21423>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
21424>>>>>>>>>>>
21424>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
21425>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
21426>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
21427>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
21428>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
21429>>>>>>>>>>>
21429>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
21430>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
21431>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
21432>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
21433>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
21434>>>>>>>>>>>
21434>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
21435>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
21436>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
21437>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
21438>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
21439>>>>>>>>>>>
21439>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
21440>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
21441>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
21442>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
21443>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
21444>>>>>>>>>>>
21444>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
21445>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
21446>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
21447>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
21448>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
21449>>>>>>>>>>>
21449>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
21450>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
21451>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
21452>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
21453>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
21454>>>>>>>>>>>
21454>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
21455>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
21456>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
21457>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
21458>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
21459>>>>>>>>>>>
21459>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
21460>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
21461>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
21462>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
21463>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
21464>>>>>>>>>>>
21464>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
21465>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
21466>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
21467>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
21468>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
21469>>>>>>>>>>>
21469>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
21470>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
21471>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
21472>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
21473>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
21474>>>>>>>>>>>
21474>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
21475>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
21476>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
21477>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
21478>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
21479>>>>>>>>>>>
21479>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
21480>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
21481>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
21482>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
21483>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
21484>>>>>>>>>>>
21484>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
21485>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
21486>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
21487>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
21488>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
21489>>>>>>>>>>>
21489>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
21490>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
21491>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
21492>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
21493>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
21494>>>>>>>>>>>
21494>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
21495>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
21496>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
21497>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
21498>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
21499>>>>>>>>>>>
21499>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
21500>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
21501>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
21502>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
21503>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
21504>>>>>>>>>>>
21504>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
21505>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
21506>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
21507>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
21508>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
21509>>>>>>>>>>>
21509>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
21510>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
21511>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
21512>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
21513>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
21514>>>>>>>>>>>
21514>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
21515>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
21516>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
21517>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
21518>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
21519>>>>>>>>>>>
21519>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
21520>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
21521>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
21522>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
21523>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
21524>>>>>>>>>>>
21524>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
21525>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
21526>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
21527>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
21528>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
21529>>>>>>>>>>>
21529>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
21530>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
21531>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
21532>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
21533>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
21534>>>>>>>>>>>
21534>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
21535>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
21536>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
21537>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
21538>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
21539>>>>>>>>>>>
21539>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
21540>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
21541>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
21542>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
21543>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
21544>>>>>>>>>>>
21544>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
21545>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
21546>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
21547>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
21548>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
21549>>>>>>>>>>>
21549>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
21550>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
21551>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
21552>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
21553>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
21554>>>>>>>>>>>
21554>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
21555>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
21556>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
21557>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
21558>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
21559>>>>>>>>>>>
21559>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
21560>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
21561>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
21562>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
21563>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
21564>>>>>>>>>>>
21564>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
21565>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
21566>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
21567>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
21568>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
21569>>>>>>>>>>>
21569>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
21570>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
21571>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
21572>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
21573>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
21574>>>>>>>>>>>
21574>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
21575>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
21576>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
21577>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
21578>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
21579>>>>>>>>>>>
21579>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
21580>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
21581>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
21582>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
21583>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
21584>>>>>>>>>>>
21584>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
21585>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
21586>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
21587>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
21588>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
21589>>>>>>>>>>>
21589>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
21590>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
21591>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
21592>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
21593>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
21594>>>>>>>>>>>
21594>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
21595>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
21596>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
21597>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
21598>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
21599>>>>>>>>>>>
21599>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
21600>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
21601>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
21602>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
21603>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
21604>>>>>>>>>>>
21604>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
21605>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
21606>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
21607>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
21608>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
21609>>>>>>>>>>>
21609>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
21610>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
21611>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
21612>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
21613>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
21614>>>>>>>>>>>
21614>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
21614>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
21615>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
21616>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
21617>>>>>>>>>>>
21617>>>>>>>>>>>    End_Procedure
21618>>>>>>>>>>>
21618>>>>>>>>>>>End_Class
21619>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
21619>>>>>>>>>>>//****************************************************************************
21619>>>>>>>>>>>// $Module type: Class
21619>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
21619>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
21619>>>>>>>>>>>// Web-site    : http://www.rdctools.com
21619>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
21619>>>>>>>>>>>//
21619>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
21619>>>>>>>>>>>//
21619>>>>>>>>>>>// $Rev History:
21619>>>>>>>>>>>//    2015-08-11  Module header created
21619>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
21619>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
21619>>>>>>>>>>>//                Added better error handling.
21619>>>>>>>>>>>//                Added a decompose message for the connection string.
21619>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
21619>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
21619>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
21619>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
21619>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
21619>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
21619>>>>>>>>>>>//****************************************************************************
21619>>>>>>>>>>>Use cli.pkg
21619>>>>>>>>>>>Use MSSqldrv.pkg
21619>>>>>>>>>>>Use db2_drv.pkg
21619>>>>>>>>>>>Use odbc_drv.pkg
21619>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
21619>>>>>>>>>>>>>//****************************************************************************
21619>>>>>>>>>>>>>// $Module type: Class
21619>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
21619>>>>>>>>>>>>>//
21619>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
21619>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
21619>>>>>>>>>>>>>// E-mail      : support@rdctools.com
21619>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
21619>>>>>>>>>>>>>//
21619>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
21619>>>>>>>>>>>>>//
21619>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
21619>>>>>>>>>>>>>//               properties of that object.
21619>>>>>>>>>>>>>//
21619>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
21619>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
21619>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
21619>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
21619>>>>>>>>>>>>>// in the help folder for more details.
21619>>>>>>>>>>>>>//
21619>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
21619>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
21619>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
21619>>>>>>>>>>>>>>>
21619>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
21620>>>>>>>>>>>>>>>    Procedure Construct_Object
21622>>>>>>>>>>>>>>>        Forward Send Construct_Object
21624>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
21625>>>>>>>>>>>>>>>    End_Procedure
21626>>>>>>>>>>>>>>>
21626>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
21628>>>>>>>>>>>>>>>        String sRetval
21628>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
21630>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
21631>>>>>>>>>>>>>>>        End                                        
21631>>>>>>>>>>>>>>>>
21631>>>>>>>>>>>>>>>        Else Begin
21632>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
21633>>>>>>>>>>>>>>>        End
21633>>>>>>>>>>>>>>>>
21633>>>>>>>>>>>>>>>            
21633>>>>>>>>>>>>>>>        Function_Return sRetval
21634>>>>>>>>>>>>>>>    End_Function
21635>>>>>>>>>>>>>>>
21635>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21637>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
21637>>>>>>>>>>>>>>>        Integer iClientVersion
21637>>>>>>>>>>>>>>>        
21637>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21638>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
21639>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
21640>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
21642>>>>>>>>>>>>>>>            Move "" to sDatabase
21643>>>>>>>>>>>>>>>        End
21643>>>>>>>>>>>>>>>>
21643>>>>>>>>>>>>>>>        
21643>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
21645>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
21646>>>>>>>>>>>>>>>        End
21646>>>>>>>>>>>>>>>>
21646>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
21648>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
21649>>>>>>>>>>>>>>>        End
21649>>>>>>>>>>>>>>>>
21649>>>>>>>>>>>>>>>        Else Begin
21650>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
21651>>>>>>>>>>>>>>>        End
21651>>>>>>>>>>>>>>>>
21651>>>>>>>>>>>>>>>        
21651>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
21653>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
21654>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
21656>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
21657>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
21658>>>>>>>>>>>>>>>            End
21658>>>>>>>>>>>>>>>>
21658>>>>>>>>>>>>>>>        End
21658>>>>>>>>>>>>>>>>
21658>>>>>>>>>>>>>>>        
21658>>>>>>>>>>>>>>>        Function_Return sConnect
21659>>>>>>>>>>>>>>>    End_Function
21660>>>>>>>>>>>>>>>
21660>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21662>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21662>>>>>>>>>>>>>>>        String sDriverID
21662>>>>>>>>>>>>>>>
21662>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21663>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
21665>>>>>>>>>>>>>>>            Function_Return True
21666>>>>>>>>>>>>>>>        End
21666>>>>>>>>>>>>>>>>
21666>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
21667>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
21669>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
21670>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
21672>>>>>>>>>>>>>>>        End
21672>>>>>>>>>>>>>>>>
21672>>>>>>>>>>>>>>>        Else Begin
21673>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
21675>>>>>>>>>>>>>>>        End
21675>>>>>>>>>>>>>>>>
21675>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
21676>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21677>>>>>>>>>>>>>>>    End_Function
21678>>>>>>>>>>>>>>>
21678>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
21680>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
21680>>>>>>>>>>>>>>>        String sDriver
21680>>>>>>>>>>>>>>>        
21680>>>>>>>>>>>>>>>        Move 0 to iDriver
21681>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
21684>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
21686>>>>>>>>>>>>>>>            Load_Driver sDriverID
21687>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
21690>>>>>>>>>>>>>>>        End
21690>>>>>>>>>>>>>>>>
21690>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
21696>>>>>>>>>>>>>>>>
21696>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
21699>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
21701>>>>>>>>>>>>>>>                Move iCount to iDriver
21702>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
21703>>>>>>>>>>>>>>>            End
21703>>>>>>>>>>>>>>>>
21703>>>>>>>>>>>>>>>        Loop
21704>>>>>>>>>>>>>>>>
21704>>>>>>>>>>>>>>>    
21704>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
21704>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
21706>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
21709>>>>>>>>>>>>>>>        End
21709>>>>>>>>>>>>>>>>
21709>>>>>>>>>>>>>>>        Function_Return iClientVersion
21710>>>>>>>>>>>>>>>    End_Function
21711>>>>>>>>>>>>>>>    
21711>>>>>>>>>>>>>>>End_Class
21712>>>>>>>>>>>>>>>
21712>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
21713>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
21715>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
21716>>>>>>>>>>>>>>>    End_Function
21717>>>>>>>>>>>>>>>
21717>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21719>>>>>>>>>>>>>>>        Integer iClientVersion
21719>>>>>>>>>>>>>>>        String sConnect
21719>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21719>>>>>>>>>>>>>>>        
21719>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
21720>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
21722>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
21723>>>>>>>>>>>>>>>        End
21723>>>>>>>>>>>>>>>>
21723>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
21725>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
21726>>>>>>>>>>>>>>>        End
21726>>>>>>>>>>>>>>>>
21726>>>>>>>>>>>>>>>        Else Begin
21727>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
21728>>>>>>>>>>>>>>>        End
21728>>>>>>>>>>>>>>>>
21728>>>>>>>>>>>>>>>
21728>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
21729>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
21731>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
21732>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
21733>>>>>>>>>>>>>>>        End
21733>>>>>>>>>>>>>>>>
21733>>>>>>>>>>>>>>>        
21733>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
21735>>>>>>>>>>>>>>>
21735>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21736>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21737>>>>>>>>>>>>>>>    End_Function
21738>>>>>>>>>>>>>>>
21738>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
21740>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
21740>>>>>>>>>>>>>>>        String sDriver
21740>>>>>>>>>>>>>>>        
21740>>>>>>>>>>>>>>>        Move 0 to iDriver
21741>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
21744>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
21746>>>>>>>>>>>>>>>            Load_Driver sDriverID
21747>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
21750>>>>>>>>>>>>>>>        End
21750>>>>>>>>>>>>>>>>
21750>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
21756>>>>>>>>>>>>>>>>
21756>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
21759>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
21761>>>>>>>>>>>>>>>                Move iCount to iDriver
21762>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
21763>>>>>>>>>>>>>>>            End
21763>>>>>>>>>>>>>>>>
21763>>>>>>>>>>>>>>>        Loop
21764>>>>>>>>>>>>>>>>
21764>>>>>>>>>>>>>>>    
21764>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
21764>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
21766>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
21769>>>>>>>>>>>>>>>        End
21769>>>>>>>>>>>>>>>>
21769>>>>>>>>>>>>>>>        Function_Return iClientVersion
21770>>>>>>>>>>>>>>>    End_Function
21771>>>>>>>>>>>>>>>    
21771>>>>>>>>>>>>>>>End_Class
21772>>>>>>>>>>>>>>>
21772>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
21773>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21775>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21775>>>>>>>>>>>>>>>        String sDriverID
21775>>>>>>>>>>>>>>>
21775>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21776>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
21777>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
21779>>>>>>>>>>>>>>>            Function_Return True
21780>>>>>>>>>>>>>>>        End
21780>>>>>>>>>>>>>>>>
21780>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
21781>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
21783>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
21785>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
21786>>>>>>>>>>>>>>>            End
21786>>>>>>>>>>>>>>>>
21786>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21789>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21790>>>>>>>>>>>>>>>            End
21790>>>>>>>>>>>>>>>>
21790>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
21792>>>>>>>>>>>>>>>        End
21792>>>>>>>>>>>>>>>>
21792>>>>>>>>>>>>>>>        Else Begin
21793>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
21795>>>>>>>>>>>>>>>        End
21795>>>>>>>>>>>>>>>>
21795>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
21796>>>>>>>>>>>>>>>
21796>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21797>>>>>>>>>>>>>>>    End_Function
21798>>>>>>>>>>>>>>>End_Class
21799>>>>>>>>>>>>>>>
21799>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
21800>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21802>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21802>>>>>>>>>>>>>>>        String sDriverID
21802>>>>>>>>>>>>>>>
21802>>>>>>>>>>>>>>>        Move False to Err
21803>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21804>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21806>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21807>>>>>>>>>>>>>>>        End
21807>>>>>>>>>>>>>>>>
21807>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21809>>>>>>>>>>>>>>>
21809>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21810>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21811>>>>>>>>>>>>>>>    End_Function
21812>>>>>>>>>>>>>>>End_Class
21813>>>>>>>>>>>>>>>
21813>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
21814>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21816>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21816>>>>>>>>>>>>>>>        String sDriverID
21816>>>>>>>>>>>>>>>
21816>>>>>>>>>>>>>>>        Move False to Err
21817>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21818>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
21818>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
21818>>>>>>>>>>>>>>>//        End
21818>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
21820>>>>>>>>>>>>>>>
21820>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
21821>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21822>>>>>>>>>>>>>>>    End_Function
21823>>>>>>>>>>>>>>>End_Class
21824>>>>>>>>>>>>>>>
21824>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
21825>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21827>>>>>>>>>>>>>>>        Function_Return ""
21828>>>>>>>>>>>>>>>    End_Function
21829>>>>>>>>>>>>>>>End_Class
21830>>>>>>>>>>>>>>>
21830>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
21831>>>>>>>>>>>>>>>    Procedure Construct_Object
21833>>>>>>>>>>>>>>>        Forward Send Construct_Object
21835>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
21836>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
21837>>>>>>>>>>>>>>>    End_Procedure
21838>>>>>>>>>>>>>>>
21838>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
21840>>>>>>>>>>>>>>>        String sDriverID sObjectName
21840>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
21840>>>>>>>>>>>>>>>
21840>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
21841>>>>>>>>>>>>>>>        Case Begin
21841>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
21843>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
21844>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
21845>>>>>>>>>>>>>>>                Case Break
21846>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
21849>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
21850>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
21851>>>>>>>>>>>>>>>                Case Break
21852>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
21855>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
21856>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
21857>>>>>>>>>>>>>>>                Case Break               
21858>>>>>>>>>>>>>>>            Case Else
21858>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
21858>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
21859>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
21860>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
21861>>>>>>>>>>>>>>>        Case End
21861>>>>>>>>>>>>>>>
21861>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
21862>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
21863>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
21864>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
21865>>>>>>>>>>>>>>>
21865>>>>>>>>>>>>>>>        Function_Return hoDriver
21866>>>>>>>>>>>>>>>    End_Function
21867>>>>>>>>>>>>>>>
21867>>>>>>>>>>>>>>>    Procedure DestroyDriver
21869>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
21871>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
21872>>>>>>>>>>>>>>>        End
21872>>>>>>>>>>>>>>>>
21872>>>>>>>>>>>>>>>    End_Procedure
21873>>>>>>>>>>>>>>>
21873>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21875>>>>>>>>>>>>>>>        String sConnect
21875>>>>>>>>>>>>>>>        Handle hoDriver
21875>>>>>>>>>>>>>>>
21875>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
21876>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
21878>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
21879>>>>>>>>>>>>>>>        End
21879>>>>>>>>>>>>>>>>
21879>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
21880>>>>>>>>>>>>>>>        Send DestroyDriver
21881>>>>>>>>>>>>>>>        Function_Return sConnect
21882>>>>>>>>>>>>>>>    End_Function
21883>>>>>>>>>>>>>>>
21883>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
21885>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
21885>>>>>>>>>>>>>>>        Handle hoDriver
21885>>>>>>>>>>>>>>>
21885>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
21886>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
21888>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
21889>>>>>>>>>>>>>>>        End
21889>>>>>>>>>>>>>>>>
21889>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
21890>>>>>>>>>>>>>>>        Send DestroyDriver
21891>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
21892>>>>>>>>>>>>>>>    End_Function
21893>>>>>>>>>>>>>>>
21893>>>>>>>>>>>>>>>End_Class
21894>>>>>>>>>>>>>
21894>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
21894>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
21894>>>>>>>>>>>>>>>
21894>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
21895>>>>>>>>>>>>>>>    
21895>>>>>>>>>>>>>>>    Procedure Construct_Object
21897>>>>>>>>>>>>>>>        Forward Send Construct_Object
21899>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
21899>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
21900>>>>>>>>>>>>>>>        
21900>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
21902>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
21903>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
21904>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
21905>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
21906>>>>>>>>>>>>>>>        End_Object
21907>>>>>>>>>>>>>>>    End_Procedure
21908>>>>>>>>>>>>>>>    
21908>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
21908>>>>>>>>>>>>>>>    // hidden mechanism desired.
21908>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
21910>>>>>>>>>>>>>>>        String sPassword
21910>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
21911>>>>>>>>>>>>>>>        Function_Return sPassword
21912>>>>>>>>>>>>>>>    End_Function
21913>>>>>>>>>>>>>>>    
21913>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
21913>>>>>>>>>>>>>>>    //
21913>>>>>>>>>>>>>>>    // Params:
21913>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
21913>>>>>>>>>>>>>>>    // Returns:
21913>>>>>>>>>>>>>>>    //   Base64 encoded hash.
21913>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
21915>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
21915>>>>>>>>>>>>>>>        UChar[] ucBinary
21916>>>>>>>>>>>>>>>        Pointer pBase64
21916>>>>>>>>>>>>>>>        Integer iVoid
21916>>>>>>>>>>>>>>>        
21916>>>>>>>>>>>>>>>        //  Encrypt Key
21916>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
21917>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
21919>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
21920>>>>>>>>>>>>>>>>
21920>>>>>>>>>>>>>>>        End
21920>>>>>>>>>>>>>>>>
21920>>>>>>>>>>>>>>>        
21920>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
21921>>>>>>>>>>>>>>>        
21921>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
21923>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
21924>>>>>>>>>>>>>>>>
21924>>>>>>>>>>>>>>>            Function_Return ""
21925>>>>>>>>>>>>>>>        End
21925>>>>>>>>>>>>>>>>
21925>>>>>>>>>>>>>>>        
21925>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
21925>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
21926>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
21927>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
21928>>>>>>>>>>>>>>>        
21928>>>>>>>>>>>>>>>        Function_Return sBase64
21929>>>>>>>>>>>>>>>    End_Function
21930>>>>>>>>>>>>>>>    
21930>>>>>>>>>>>>>>>    
21930>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
21930>>>>>>>>>>>>>>>    //
21930>>>>>>>>>>>>>>>    // Params:
21930>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
21930>>>>>>>>>>>>>>>    // Returns:
21930>>>>>>>>>>>>>>>    //   Readable plain text password
21930>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
21932>>>>>>>>>>>>>>>        String sEncryptPassword
21932>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
21934>>>>>>>>>>>>>>>        Boolean bIsHex
21934>>>>>>>>>>>>>>>        Integer iLen iVoid
21934>>>>>>>>>>>>>>>        Pointer pBinary
21934>>>>>>>>>>>>>>>        
21934>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
21936>>>>>>>>>>>>>>>            //  Decode from Base64
21936>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
21937>>>>>>>>>>>>>>>            
21937>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
21938>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
21939>>>>>>>>>>>>>>>                        
21939>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
21940>>>>>>>>>>>>>>>            
21940>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
21940>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
21941>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
21942>>>>>>>>>>>>>>>        End
21942>>>>>>>>>>>>>>>>
21942>>>>>>>>>>>>>>>        
21942>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
21943>>>>>>>>>>>>>>>    End_Function
21944>>>>>>>>>>>>>>>End_Class
21945>>>>>>>>>>>>>
21945>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
21946>>>>>>>>>>>>>    Procedure Construct_Object
21948>>>>>>>>>>>>>        Forward Send Construct_Object
21950>>>>>>>>>>>>>
21950>>>>>>>>>>>>>        Property String Private_psIniFilePath
21951>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
21952>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
21953>>>>>>>>>>>>>
21953>>>>>>>>>>>>>        Property Boolean pbDFConnId False
21954>>>>>>>>>>>>>
21954>>>>>>>>>>>>>        // *** You really want to change this value! ***
21954>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
21954>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
21955>>>>>>>>>>>>>
21955>>>>>>>>>>>>>    End_Procedure
21956>>>>>>>>>>>>>
21956>>>>>>>>>>>>>    Procedure End_Construct_Object
21958>>>>>>>>>>>>>        Forward Send End_Construct_Object
21960>>>>>>>>>>>>>    End_Procedure
21961>>>>>>>>>>>>>
21961>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
21963>>>>>>>>>>>>>        String sIniFile
21963>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
21964>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
21965>>>>>>>>>>>>>        Get psIniFileName to sIniFile
21966>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
21967>>>>>>>>>>>>>    End_Procedure
21968>>>>>>>>>>>>>
21968>>>>>>>>>>>>>    Function psIniFilePath Returns String
21970>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
21971>>>>>>>>>>>>>    End_Function
21972>>>>>>>>>>>>>
21972>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
21974>>>>>>>>>>>>>        String sPath
21974>>>>>>>>>>>>>        Get psIniFilePath to sPath
21975>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
21976>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
21977>>>>>>>>>>>>>    End_Procedure
21978>>>>>>>>>>>>>
21978>>>>>>>>>>>>>    Function psIniFileName Returns String
21980>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
21981>>>>>>>>>>>>>    End_Function
21982>>>>>>>>>>>>>
21982>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
21982>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
21982>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
21982>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
21984>>>>>>>>>>>>>        String sIniFile sPath
21984>>>>>>>>>>>>>
21984>>>>>>>>>>>>>        Get psIniFilePath to sPath
21985>>>>>>>>>>>>>        Get psIniFileName to sIniFile
21986>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
21987>>>>>>>>>>>>>        Set psFileName to sIniFile
21988>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
21989>>>>>>>>>>>>>    End_Procedure
21990>>>>>>>>>>>>>
21990>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
21990>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
21990>>>>>>>>>>>>>    // Returns the value
21990>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
21992>>>>>>>>>>>>>        String sValue sIniFile sPath
21992>>>>>>>>>>>>>
21992>>>>>>>>>>>>>        Get psIniFilePath to sPath
21993>>>>>>>>>>>>>        Get psIniFileName to sIniFile
21994>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
21995>>>>>>>>>>>>>        Set psFileName to sIniFile
21996>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
21997>>>>>>>>>>>>>
21997>>>>>>>>>>>>>        Function_Return sValue
21998>>>>>>>>>>>>>    End_Function
21999>>>>>>>>>>>>>
21999>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
21999>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
22001>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
22004>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
22007>>>>>>>>>>>>>
22007>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
22010>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
22013>>>>>>>>>>>>>
22013>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
22016>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
22019>>>>>>>>>>>>>
22019>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
22022>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
22025>>>>>>>>>>>>>
22025>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
22028>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
22031>>>>>>>>>>>>>
22031>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
22034>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
22037>>>>>>>>>>>>>
22037>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
22040>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
22043>>>>>>>>>>>>>
22043>>>>>>>>>>>>>        Function_Return (EQ)
22044>>>>>>>>>>>>>    End_Function
22045>>>>>>>>>>>>>
22045>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
22047>>>>>>>>>>>>>        Handle hoSections
22047>>>>>>>>>>>>>        Integer iItems
22047>>>>>>>>>>>>>
22047>>>>>>>>>>>>>        Send ReadSections hoSections
22048>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
22049>>>>>>>>>>>>>        Function_Return iItems
22050>>>>>>>>>>>>>    End_Function
22051>>>>>>>>>>>>>
22051>>>>>>>>>>>>>    // The normal connection string looks something like this;
22051>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
22051>>>>>>>>>>>>>    // ...but the full connection string looks like this;
22051>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
22051>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
22051>>>>>>>>>>>>>//        String sSection
22051>>>>>>>>>>>>>//        Integer iCount
22051>>>>>>>>>>>>>//
22051>>>>>>>>>>>>>//        Move False to Err
22051>>>>>>>>>>>>>//        Get psIniSectionName to sSection
22051>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
22051>>>>>>>>>>>>>//        Increment iCount
22051>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
22051>>>>>>>>>>>>>//
22051>>>>>>>>>>>>>//        Function_Return (Err = False)
22051>>>>>>>>>>>>>//    End_Function
22051>>>>>>>>>>>>>
22051>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
22053>>>>>>>>>>>>>        Integer iCount
22053>>>>>>>>>>>>>        Boolean bExists
22053>>>>>>>>>>>>>        String sSection
22053>>>>>>>>>>>>>
22053>>>>>>>>>>>>>        Move False to Err
22054>>>>>>>>>>>>>        Move 1 to iCount
22055>>>>>>>>>>>>>        Get psIniSectionName to sSection
22056>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22057>>>>>>>>>>>>>        While (bExists = True)
22061>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
22062>>>>>>>>>>>>>            Increment iCount
22063>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22064>>>>>>>>>>>>>        Loop
22065>>>>>>>>>>>>>>
22065>>>>>>>>>>>>>        Function_Return (Err = False)
22066>>>>>>>>>>>>>    End_Function
22067>>>>>>>>>>>>>
22067>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
22069>>>>>>>>>>>>>        Integer iCount
22069>>>>>>>>>>>>>        String sSection
22069>>>>>>>>>>>>>        Boolean bExists
22069>>>>>>>>>>>>>
22069>>>>>>>>>>>>>        Move False to Err
22070>>>>>>>>>>>>>        Move 1 to iCount
22071>>>>>>>>>>>>>        Get psIniSectionName to sSection
22072>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
22073>>>>>>>>>>>>>        While (bExists = True)
22077>>>>>>>>>>>>>            If (iCount = iItem) Begin
22079>>>>>>>>>>>>>                Send DeleteSection sSection
22080>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
22080>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
22081>>>>>>>>>>>>>            End
22081>>>>>>>>>>>>>>
22081>>>>>>>>>>>>>            Increment iCount
22082>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
22083>>>>>>>>>>>>>        Loop
22084>>>>>>>>>>>>>>
22084>>>>>>>>>>>>>
22084>>>>>>>>>>>>>        Function_Return (Err = False)
22085>>>>>>>>>>>>>    End_Function
22086>>>>>>>>>>>>>
22086>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
22086>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
22086>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
22088>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22088>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22089>>>>>>>>>>>>>        tSQLConnection   SQLConnection
22089>>>>>>>>>>>>>        tSQLConnection   SQLConnection
22089>>>>>>>>>>>>>        Integer iIndex
22089>>>>>>>>>>>>>
22089>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
22090>>>>>>>>>>>>>        If (iIndex = -1) Begin
22092>>>>>>>>>>>>>            Move True to SQLConnection.bError
22093>>>>>>>>>>>>>            Function_Return SQLConnection
22094>>>>>>>>>>>>>        End
22094>>>>>>>>>>>>>>
22094>>>>>>>>>>>>>
22094>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22095>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
22096>>>>>>>>>>>>>
22096>>>>>>>>>>>>>        Function_Return SQLConnection
22097>>>>>>>>>>>>>    End_Function
22098>>>>>>>>>>>>>
22098>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
22098>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
22100>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22100>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22101>>>>>>>>>>>>>        Integer iRetval iCount iSize
22101>>>>>>>>>>>>>        String sValue
22101>>>>>>>>>>>>>        Boolean bExists
22101>>>>>>>>>>>>>
22101>>>>>>>>>>>>>        Move -1 to iRetval
22102>>>>>>>>>>>>>
22102>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22103>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22104>>>>>>>>>>>>>        Decrement iSize
22105>>>>>>>>>>>>>        For iCount from 0 to iSize
22111>>>>>>>>>>>>>>
22111>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
22112>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
22113>>>>>>>>>>>>>            If (bExists) Begin
22115>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
22116>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
22117>>>>>>>>>>>>>            End
22117>>>>>>>>>>>>>>
22117>>>>>>>>>>>>>        Loop
22118>>>>>>>>>>>>>>
22118>>>>>>>>>>>>>
22118>>>>>>>>>>>>>        Function_Return iRetval
22119>>>>>>>>>>>>>    End_Function
22120>>>>>>>>>>>>>
22120>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
22120>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
22120>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
22122>>>>>>>>>>>>>        Integer iCount iSize iItems
22122>>>>>>>>>>>>>        String sValue
22122>>>>>>>>>>>>>        Boolean bExists
22122>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22122>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22123>>>>>>>>>>>>>
22123>>>>>>>>>>>>>        Move 0 to iItems
22124>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22125>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22126>>>>>>>>>>>>>        Decrement iSize
22127>>>>>>>>>>>>>        For iCount from 0 to iSize
22133>>>>>>>>>>>>>>
22133>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
22134>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
22135>>>>>>>>>>>>>            If (bExists) Begin
22137>>>>>>>>>>>>>                Increment iItems
22138>>>>>>>>>>>>>            End
22138>>>>>>>>>>>>>>
22138>>>>>>>>>>>>>        Loop
22139>>>>>>>>>>>>>>
22139>>>>>>>>>>>>>
22139>>>>>>>>>>>>>        Function_Return (iItems > 1)
22140>>>>>>>>>>>>>    End_Function
22141>>>>>>>>>>>>>
22141>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
22141>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
22143>>>>>>>>>>>>>        Boolean bOK
22143>>>>>>>>>>>>>        Integer iSize iCount
22143>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22143>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22144>>>>>>>>>>>>>        tSQLConnection SQLConnection
22144>>>>>>>>>>>>>        tSQLConnection SQLConnection
22144>>>>>>>>>>>>>        String sConnectionString
22144>>>>>>>>>>>>>
22144>>>>>>>>>>>>>        Move False to Err
22145>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
22146>>>>>>>>>>>>>
22146>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22147>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22148>>>>>>>>>>>>>        Decrement iSize
22149>>>>>>>>>>>>>        // Set all current connection to inactive.
22149>>>>>>>>>>>>>        For iCount from 0 to iSize
22155>>>>>>>>>>>>>>
22155>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
22156>>>>>>>>>>>>>        Loop
22157>>>>>>>>>>>>>>
22157>>>>>>>>>>>>>
22157>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
22158>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
22159>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
22160>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
22161>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
22162>>>>>>>>>>>>>
22162>>>>>>>>>>>>>        Function_Return (bOK = True)
22163>>>>>>>>>>>>>    End_Function
22164>>>>>>>>>>>>>
22164>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
22164>>>>>>>>>>>>>    // Returns True if successful.
22164>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
22166>>>>>>>>>>>>>        Boolean bOK
22166>>>>>>>>>>>>>        Integer iItem iSize iCount
22166>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22166>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22167>>>>>>>>>>>>>
22167>>>>>>>>>>>>>        Move False to Err
22168>>>>>>>>>>>>>        Move -1 to iItem
22169>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
22170>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22171>>>>>>>>>>>>>        Decrement iSize
22172>>>>>>>>>>>>>        // Set all current connection to inactive.
22172>>>>>>>>>>>>>        For iCount from 0 to iSize
22178>>>>>>>>>>>>>>
22178>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
22179>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
22181>>>>>>>>>>>>>                Move iCount to iItem
22182>>>>>>>>>>>>>            End
22182>>>>>>>>>>>>>>
22182>>>>>>>>>>>>>        Loop
22183>>>>>>>>>>>>>>
22183>>>>>>>>>>>>>
22183>>>>>>>>>>>>>        If (iItem <> -1) Begin
22185>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
22186>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
22187>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
22188>>>>>>>>>>>>>        End
22188>>>>>>>>>>>>>>
22188>>>>>>>>>>>>>
22188>>>>>>>>>>>>>        Function_Return (bOK = True)
22189>>>>>>>>>>>>>    End_Function
22190>>>>>>>>>>>>>
22190>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
22192>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22192>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
22193>>>>>>>>>>>>>        String sSection sValue
22193>>>>>>>>>>>>>        Integer iCount
22193>>>>>>>>>>>>>        Boolean bExists
22193>>>>>>>>>>>>>
22193>>>>>>>>>>>>>        Get psIniSectionName to sSection
22194>>>>>>>>>>>>>        Get SectionExists sSection to bExists
22195>>>>>>>>>>>>>        If (bExists = False) Begin
22197>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
22198>>>>>>>>>>>>>        End
22198>>>>>>>>>>>>>>
22198>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
22199>>>>>>>>>>>>>        If (bExists = True) Begin
22201>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
22202>>>>>>>>>>>>>>
22202>>>>>>>>>>>>>        End
22202>>>>>>>>>>>>>>
22202>>>>>>>>>>>>>
22202>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
22203>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22204>>>>>>>>>>>>>
22204>>>>>>>>>>>>>        While (bExists = True)                 
22208>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
22208>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
22208>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
22208>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
22208>>>>>>>>>>>>>
22208>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
22209>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
22210>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
22211>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
22212>>>>>>>>>>>>>
22212>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
22212>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
22213>>>>>>>>>>>>>            If (sValue = "99") Begin
22215>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
22216>>>>>>>>>>>>>            End
22216>>>>>>>>>>>>>>
22216>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
22217>>>>>>>>>>>>>
22217>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
22218>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
22219>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
22221>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
22222>>>>>>>>>>>>>            End
22222>>>>>>>>>>>>>>
22222>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
22224>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
22225>>>>>>>>>>>>>            End
22225>>>>>>>>>>>>>>
22225>>>>>>>>>>>>>
22225>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
22226>>>>>>>>>>>>>
22226>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
22227>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
22228>>>>>>>>>>>>>
22228>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
22229>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
22230>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
22232>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
22233>>>>>>>>>>>>>            End
22233>>>>>>>>>>>>>>
22233>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
22234>>>>>>>>>>>>>
22234>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
22234>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
22235>>>>>>>>>>>>>
22235>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
22236>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
22237>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
22238>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
22239>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
22240>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
22241>>>>>>>>>>>>>
22241>>>>>>>>>>>>>            Increment iCount
22242>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
22243>>>>>>>>>>>>>        Loop
22244>>>>>>>>>>>>>>
22244>>>>>>>>>>>>>
22244>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
22244>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
22246>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
22247>>>>>>>>>>>>>        End
22247>>>>>>>>>>>>>>
22247>>>>>>>>>>>>>
22247>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
22248>>>>>>>>>>>>>    End_Function
22249>>>>>>>>>>>>>
22249>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
22251>>>>>>>>>>>>>        Integer iCount iSize
22251>>>>>>>>>>>>>        Boolean bOK
22251>>>>>>>>>>>>>        String sSection sValue
22251>>>>>>>>>>>>>
22251>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
22251>>>>>>>>>>>>>        Move 0 to iCount
22252>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
22253>>>>>>>>>>>>>        If (bOK = False) Begin
22255>>>>>>>>>>>>>            Function_Return False
22256>>>>>>>>>>>>>        End
22256>>>>>>>>>>>>>>
22256>>>>>>>>>>>>>
22256>>>>>>>>>>>>>        Move False to Err
22257>>>>>>>>>>>>>        Get psIniSectionName to sSection
22258>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
22258>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
22259>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
22260>>>>>>>>>>>>>        Decrement iSize
22261>>>>>>>>>>>>>
22261>>>>>>>>>>>>>        For iCount from 0 to iSize
22267>>>>>>>>>>>>>>
22267>>>>>>>>>>>>>            // DF 19 compatible settings:
22267>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
22268>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
22269>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
22270>>>>>>>>>>>>>            
22270>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
22271>>>>>>>>>>>>>
22271>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
22272>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
22274>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
22275>>>>>>>>>>>>>            End
22275>>>>>>>>>>>>>>
22275>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
22276>>>>>>>>>>>>>
22276>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
22278>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
22279>>>>>>>>>>>>>            End
22279>>>>>>>>>>>>>>
22279>>>>>>>>>>>>>
22279>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
22280>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
22281>>>>>>>>>>>>>
22281>>>>>>>>>>>>>            // The Database Update Framework extended settings:
22281>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
22282>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
22283>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
22284>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
22285>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
22286>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
22287>>>>>>>>>>>>>        Loop
22288>>>>>>>>>>>>>>
22288>>>>>>>>>>>>>
22288>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
22289>>>>>>>>>>>>>    End_Function
22290>>>>>>>>>>>>>
22290>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
22290>>>>>>>>>>>>>    //
22290>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
22290>>>>>>>>>>>>>    // corresponding to the passed iDbType.
22290>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
22292>>>>>>>>>>>>>        String sRetval
22292>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
22294>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
22295>>>>>>>>>>>>>        End
22295>>>>>>>>>>>>>>
22295>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
22297>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
22298>>>>>>>>>>>>>        End
22298>>>>>>>>>>>>>>
22298>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
22300>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
22301>>>>>>>>>>>>>        End
22301>>>>>>>>>>>>>>
22301>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
22303>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
22304>>>>>>>>>>>>>        End
22304>>>>>>>>>>>>>>
22304>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
22306>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
22307>>>>>>>>>>>>>        End
22307>>>>>>>>>>>>>>
22307>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
22309>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
22310>>>>>>>>>>>>>        End
22310>>>>>>>>>>>>>>
22310>>>>>>>>>>>>>        Function_Return sRetval
22311>>>>>>>>>>>>>    End_Function
22312>>>>>>>>>>>>>
22312>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
22312>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
22312>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
22314>>>>>>>>>>>>>        Integer iRetval
22314>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
22316>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
22317>>>>>>>>>>>>>        End
22317>>>>>>>>>>>>>>
22317>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
22319>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22320>>>>>>>>>>>>>        End
22320>>>>>>>>>>>>>>
22320>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
22322>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
22323>>>>>>>>>>>>>        End
22323>>>>>>>>>>>>>>
22323>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
22325>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
22326>>>>>>>>>>>>>        End
22326>>>>>>>>>>>>>>
22326>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
22328>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
22329>>>>>>>>>>>>>        End
22329>>>>>>>>>>>>>>
22329>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
22331>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
22332>>>>>>>>>>>>>        End
22332>>>>>>>>>>>>>>
22332>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
22334>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
22335>>>>>>>>>>>>>        End
22335>>>>>>>>>>>>>>
22335>>>>>>>>>>>>>        Function_Return iRetval
22336>>>>>>>>>>>>>    End_Function
22337>>>>>>>>>>>>>
22337>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
22337>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
22337>>>>>>>>>>>>>    // the SQL Connection program's grid.
22337>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
22339>>>>>>>>>>>>>        String sRetval
22339>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
22341>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
22342>>>>>>>>>>>>>        End
22342>>>>>>>>>>>>>>
22342>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
22344>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
22345>>>>>>>>>>>>>        End
22345>>>>>>>>>>>>>>
22345>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
22347>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
22348>>>>>>>>>>>>>        End
22348>>>>>>>>>>>>>>
22348>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
22350>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
22351>>>>>>>>>>>>>        End
22351>>>>>>>>>>>>>>
22351>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
22353>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
22354>>>>>>>>>>>>>        End
22354>>>>>>>>>>>>>>
22354>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
22356>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
22357>>>>>>>>>>>>>        End
22357>>>>>>>>>>>>>>
22357>>>>>>>>>>>>>        Function_Return sRetval
22358>>>>>>>>>>>>>    End_Function
22359>>>>>>>>>>>>>
22359>>>>>>>>>>>>>    // Pass a driver id and the function will return
22359>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
22359>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
22359>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
22361>>>>>>>>>>>>>        Integer iRetval
22361>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
22363>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22364>>>>>>>>>>>>>        End
22364>>>>>>>>>>>>>>
22364>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
22366>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
22367>>>>>>>>>>>>>        End
22367>>>>>>>>>>>>>>
22367>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
22369>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
22370>>>>>>>>>>>>>        End
22370>>>>>>>>>>>>>>
22370>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
22372>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
22373>>>>>>>>>>>>>        End
22373>>>>>>>>>>>>>>
22373>>>>>>>>>>>>>        Function_Return iRetval
22374>>>>>>>>>>>>>    End_Function
22375>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
22375>>>>>>>>>>>>>>
22375>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
22377>>>>>>>>>>>>>>    Integer iStart iEnd
22377>>>>>>>>>>>>>>    String sRetval
22377>>>>>>>>>>>>>>
22377>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
22378>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
22379>>>>>>>>>>>>>>    If (iStart = 0) Begin
22381>>>>>>>>>>>>>>        Function_Return ""
22382>>>>>>>>>>>>>>    End
22382>>>>>>>>>>>>>>>
22382>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
22383>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
22384>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
22386>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
22387>>>>>>>>>>>>>>    End
22387>>>>>>>>>>>>>>>
22387>>>>>>>>>>>>>>    Else Begin
22388>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
22389>>>>>>>>>>>>>>    End
22389>>>>>>>>>>>>>>>
22389>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
22391>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
22392>>>>>>>>>>>>>>        Decrement iEnd
22393>>>>>>>>>>>>>>    End
22393>>>>>>>>>>>>>>>
22393>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
22395>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
22396>>>>>>>>>>>>>>    End
22396>>>>>>>>>>>>>>>
22396>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
22397>>>>>>>>>>>>>>
22397>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
22398>>>>>>>>>>>>>>End_Function
22399>>>>>>>>>>>>>>
22399>>>>>>>>>>>>>>
22399>>>>>>>>>>>>>
22399>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
22401>>>>>>>>>>>>>        String sConnect
22401>>>>>>>>>>>>>        Handle hoDriver
22401>>>>>>>>>>>>>
22401>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
22402>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
22403>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
22404>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
22405>>>>>>>>>>>>>        Send Destroy of hoDriver
22406>>>>>>>>>>>>>
22406>>>>>>>>>>>>>        Function_Return sConnect
22407>>>>>>>>>>>>>    End_Function
22408>>>>>>>>>>>>>
22408>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
22408>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
22410>>>>>>>>>>>>>        String sConnect
22410>>>>>>>>>>>>>
22410>>>>>>>>>>>>>        Case Begin
22410>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
22412>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
22413>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22415>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22416>>>>>>>>>>>>>                End
22416>>>>>>>>>>>>>>
22416>>>>>>>>>>>>>                Case Break
22417>>>>>>>>>>>>>
22417>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
22420>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
22422>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
22423>>>>>>>>>>>>>                End
22423>>>>>>>>>>>>>>
22423>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
22426>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22427>>>>>>>>>>>>>                End
22427>>>>>>>>>>>>>>
22427>>>>>>>>>>>>>
22427>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22429>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22430>>>>>>>>>>>>>                End
22430>>>>>>>>>>>>>>
22430>>>>>>>>>>>>>                Case Break
22431>>>>>>>>>>>>>
22431>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
22434>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
22435>>>>>>>>>>>>>                If (sDatabase <> "") Begin
22437>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
22438>>>>>>>>>>>>>                End
22438>>>>>>>>>>>>>>
22438>>>>>>>>>>>>>                Case Break
22439>>>>>>>>>>>>>
22439>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
22442>>>>>>>>>>>>>                Break
22443>>>>>>>>>>>>>
22443>>>>>>>>>>>>>            Case Else
22443>>>>>>>>>>>>>                Move "" to sConnect
22444>>>>>>>>>>>>>        Case End
22444>>>>>>>>>>>>>
22444>>>>>>>>>>>>>        Function_Return sConnect
22445>>>>>>>>>>>>>    End_Function
22446>>>>>>>>>>>>>
22446>>>>>>>>>>>>>    // Use Base64
22446>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
22448>>>>>>>>>>>>>        String sRetval
22448>>>>>>>>>>>>>        Handle hoLoginEncryption
22448>>>>>>>>>>>>>
22448>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
22449>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
22450>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
22451>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
22452>>>>>>>>>>>>>          
22452>>>>>>>>>>>>>        Function_Return sRetval
22453>>>>>>>>>>>>>    End_Function
22454>>>>>>>>>>>>>
22454>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
22456>>>>>>>>>>>>>        String sRetval
22456>>>>>>>>>>>>>        Handle hoLoginEncryption
22456>>>>>>>>>>>>>
22456>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
22457>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
22458>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
22459>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
22460>>>>>>>>>>>>>
22460>>>>>>>>>>>>>        Function_Return sRetval
22461>>>>>>>>>>>>>    End_Function
22462>>>>>>>>>>>>>
22462>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
22462>>>>>>>>>>>>>    Function ApplicationPath Returns String
22464>>>>>>>>>>>>>        String sApplicationFileName sPath
22464>>>>>>>>>>>>>        Integer iNumChars iRetval
22464>>>>>>>>>>>>>
22464>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
22465>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
22466>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
22467>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
22468>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
22469>>>>>>>>>>>>>
22469>>>>>>>>>>>>>        Function_Return sPath
22470>>>>>>>>>>>>>    End_Function
22471>>>>>>>>>>>>>
22471>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
22471>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
22471>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
22471>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
22473>>>>>>>>>>>>>        Boolean bExists
22473>>>>>>>>>>>>>        Handle hoPaths hoIniFile
22473>>>>>>>>>>>>>        String[] asWorkSpaceFiles
22474>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
22474>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
22474>>>>>>>>>>>>>        
22474>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
22475>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
22476>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
22477>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
22478>>>>>>>>>>>>>        If (bExists = True) Begin
22480>>>>>>>>>>>>>            Function_Return sProgramsPath
22481>>>>>>>>>>>>>        End                      
22481>>>>>>>>>>>>>>
22481>>>>>>>>>>>>>    
22481>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
22482>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
22484>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
22485>>>>>>>>>>>>>        End                                              
22485>>>>>>>>>>>>>>
22485>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
22486>>>>>>>>>>>>>        
22486>>>>>>>>>>>>>        Move False to bExists
22487>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
22488>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
22489>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
22490>>>>>>>>>>>>>        Decrement iSize       
22491>>>>>>>>>>>>>        
22491>>>>>>>>>>>>>        For iCount from 0 to iSize
22497>>>>>>>>>>>>>>
22497>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
22498>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
22499>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
22500>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
22501>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
22507>>>>>>>>>>>>>>
22507>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
22508>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
22509>>>>>>>>>>>>>                // Check if there are more than one path specified;
22509>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
22510>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
22512>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
22513>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
22519>>>>>>>>>>>>>>
22519>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
22520>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
22521>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
22522>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
22523>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
22524>>>>>>>>>>>>>                        If (bExists = True) Begin
22526>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
22527>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
22528>>>>>>>>>>>>>                            Move iSize to iCount
22529>>>>>>>>>>>>>                        End                                                    
22529>>>>>>>>>>>>>>
22529>>>>>>>>>>>>>                    Loop
22530>>>>>>>>>>>>>>
22530>>>>>>>>>>>>>                End
22530>>>>>>>>>>>>>>
22530>>>>>>>>>>>>>                Else Begin
22531>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
22532>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
22533>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
22534>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
22535>>>>>>>>>>>>>                    If (bExists = True) Begin
22537>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
22538>>>>>>>>>>>>>                        Move iSize to iCount
22539>>>>>>>>>>>>>                    End                                                    
22539>>>>>>>>>>>>>>
22539>>>>>>>>>>>>>                End
22539>>>>>>>>>>>>>>
22539>>>>>>>>>>>>>            Loop
22540>>>>>>>>>>>>>>
22540>>>>>>>>>>>>>            If (bExists = False) Begin
22542>>>>>>>>>>>>>                Move "" to sPath    
22543>>>>>>>>>>>>>            End
22543>>>>>>>>>>>>>>
22543>>>>>>>>>>>>>            Send Destroy of hoIniFile          
22544>>>>>>>>>>>>>        Loop        
22545>>>>>>>>>>>>>>
22545>>>>>>>>>>>>>        Send Destroy of hoPaths
22546>>>>>>>>>>>>>        
22546>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
22546>>>>>>>>>>>>>        If (sPath = "") Begin
22548>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
22549>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
22550>>>>>>>>>>>>>        End                  
22550>>>>>>>>>>>>>>
22550>>>>>>>>>>>>>        
22550>>>>>>>>>>>>>        Function_Return sPath    
22551>>>>>>>>>>>>>    End_Function
22552>>>>>>>>>>>>>    
22552>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
22552>>>>>>>>>>>>>    // with one or more .ws file names.
22552>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
22552>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
22552>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
22552>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
22554>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
22556>>>>>>>>>>>>>        String sFile sHomePath sDirSep
22556>>>>>>>>>>>>>        Integer iCh iSize
22556>>>>>>>>>>>>>        Boolean bExists      
22556>>>>>>>>>>>>>        Handle hoIniFile 
22556>>>>>>>>>>>>>        
22556>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
22557>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
22558>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
22560>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
22561>>>>>>>>>>>>>        End                                              
22561>>>>>>>>>>>>>>
22561>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
22562>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
22563>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
22564>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
22565>>>>>>>>>>>>>        
22565>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
22565>>>>>>>>>>>>>        // read the name of the .ws file name.
22565>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
22566>>>>>>>>>>>>>        If (bExists = True) Begin
22568>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
22569>>>>>>>>>>>>>            If (iCh < 0) Begin
22571>>>>>>>>>>>>>                Function_Return asSWSFiles
22572>>>>>>>>>>>>>            End                                 
22572>>>>>>>>>>>>>>
22572>>>>>>>>>>>>>            
22572>>>>>>>>>>>>>            Repeat
22572>>>>>>>>>>>>>>
22572>>>>>>>>>>>>>                Readln channel iCh sFile
22574>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
22576>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
22577>>>>>>>>>>>>>                End
22577>>>>>>>>>>>>>>
22577>>>>>>>>>>>>>            Until (SeqEof = True)
22579>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
22580>>>>>>>>>>>>>            
22580>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
22581>>>>>>>>>>>>>            If (iSize <> 0) Begin
22583>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
22584>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
22584>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
22584>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
22585>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
22586>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
22587>>>>>>>>>>>>>                If (sFile <> "") Begin
22589>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
22590>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
22591>>>>>>>>>>>>>                    File_Exist sFile bExists
22592>>>>>>>>>>>>>                    If (bExists = True) Begin
22594>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
22595>>>>>>>>>>>>>                    End
22595>>>>>>>>>>>>>>
22595>>>>>>>>>>>>>                End
22595>>>>>>>>>>>>>>
22595>>>>>>>>>>>>>                Send Destroy of hoIniFile
22596>>>>>>>>>>>>>            End
22596>>>>>>>>>>>>>>
22596>>>>>>>>>>>>>        End
22596>>>>>>>>>>>>>>
22596>>>>>>>>>>>>>        
22596>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
22596>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
22598>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
22599>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
22600>>>>>>>>>>>>>            If (bExists = False) Begin
22602>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
22603>>>>>>>>>>>>>            End
22603>>>>>>>>>>>>>>
22603>>>>>>>>>>>>>        
22603>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
22604>>>>>>>>>>>>>            If (iCh < 0) Begin
22606>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
22607>>>>>>>>>>>>>            End                                 
22607>>>>>>>>>>>>>>
22607>>>>>>>>>>>>>            
22607>>>>>>>>>>>>>            Repeat
22607>>>>>>>>>>>>>>
22607>>>>>>>>>>>>>                Readln channel iCh sFile
22609>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
22611>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
22612>>>>>>>>>>>>>                End
22612>>>>>>>>>>>>>>
22612>>>>>>>>>>>>>            Until (SeqEof = True)
22614>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
22615>>>>>>>>>>>>>        End
22615>>>>>>>>>>>>>>
22615>>>>>>>>>>>>>        
22615>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
22616>>>>>>>>>>>>>    End_Function
22617>>>>>>>>>>>>>
22617>>>>>>>>>>>>>End_Class
22618>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
22618>>>>>>>>>>>Use vWin32fh.pkg
22618>>>>>>>>>>>
22618>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
22618>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
22618>>>>>>>>>>>    Use cConnectionDUF.pkg
Including file: cConnectionDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cConnectionDUF.pkg)
22618>>>>>>>>>>>>>// * Dummy class * that will only be used if DF 18.2 or less.
22618>>>>>>>>>>>>>//
22618>>>>>>>>>>>>>// The cConnection class is new to DF 19 and that DF 19 package/class
22618>>>>>>>>>>>>>// will be used automatically instead of this package
22618>>>>>>>>>>>>>// if the current DF version is 19 and up _and_ the class
22618>>>>>>>>>>>>>// has been instantianted in the cApplication object.
22618>>>>>>>>>>>>>//
22618>>>>>>>>>>>>>// If an object of the original cConnection class is placed in
22618>>>>>>>>>>>>>// the cApplication, that connection logic will be used instead
22618>>>>>>>>>>>>>// of the Database Update Framework's SQLConnections logic. Or more
22618>>>>>>>>>>>>>// correctly; "Managed Connection" settings will be read and applied
22618>>>>>>>>>>>>>// instead of those defined in the framework's SQLConnections.ini file.
22618>>>>>>>>>>>>>//
22618>>>>>>>>>>>>>Struct tConnection
22618>>>>>>>>>>>>>    String sId                // connection id
22618>>>>>>>>>>>>>    String sString            // server-string as added via the ini file
22618>>>>>>>>>>>>>    String sUID               // User Id
22618>>>>>>>>>>>>>    String sPWD               // non-encrypted password
22618>>>>>>>>>>>>>    Boolean bTrustedConnection // Trusted connection
22618>>>>>>>>>>>>>    Integer iOptions          // connection ID options (don't use)
22618>>>>>>>>>>>>>    String sDriver            // name of driver
22618>>>>>>>>>>>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
22618>>>>>>>>>>>>>    String sConnectionString  // Full connection string assembled from various strings
22618>>>>>>>>>>>>>    String sSection           // this is usually the section name as it appears
22618>>>>>>>>>>>>>                              // in the connections ini file (e.g., [Connection1])
22618>>>>>>>>>>>>>    Boolean bDisabled         // if set, this is not an active Id
22618>>>>>>>>>>>>>End_Struct
22618>>>>>>>>>>>>>
22618>>>>>>>>>>>>>
22618>>>>>>>>>>>>>Class cConnection is a cObject
22619>>>>>>>>>>>>>
22619>>>>>>>>>>>>>    Procedure Construct_Object
22621>>>>>>>>>>>>>        Forward Send Construct_Object
22623>>>>>>>>>>>>>
22623>>>>>>>>>>>>>    End_Procedure
22624>>>>>>>>>>>>>
22624>>>>>>>>>>>>>    Function ConnectionIdInfo Returns tConnection
22626>>>>>>>>>>>>>        tConnection Connection
22626>>>>>>>>>>>>>        tConnection Connection
22626>>>>>>>>>>>>>        Function_Return Connection
22627>>>>>>>>>>>>>    End_Function
22628>>>>>>>>>>>>>
22628>>>>>>>>>>>>>    Function IsConnectionIdLoggedIn Returns Boolean
22630>>>>>>>>>>>>>        Function_Return False
22631>>>>>>>>>>>>>    End_Function
22632>>>>>>>>>>>>>
22632>>>>>>>>>>>>>    Function LoginConnectionId Returns String
22634>>>>>>>>>>>>>        Function_Return ""
22635>>>>>>>>>>>>>    End_Function
22636>>>>>>>>>>>>>
22636>>>>>>>>>>>>>    // get array of managed connections across all drivers
22636>>>>>>>>>>>>>    // returns array of connections in tConnection.
22636>>>>>>>>>>>>>    Function ConnectionIDs Returns tConnection[]
22638>>>>>>>>>>>>>        tConnection[] Connections
22638>>>>>>>>>>>>>        tConnection[] Connections
22639>>>>>>>>>>>>>        Function_Return Connections
22640>>>>>>>>>>>>>    End_Function
22641>>>>>>>>>>>>>
22641>>>>>>>>>>>>>    Function ConnectionIdIndex String sConnectionID Returns Integer
22643>>>>>>>>>>>>>        Function_Return 0
22644>>>>>>>>>>>>>    End_Function
22645>>>>>>>>>>>>>
22645>>>>>>>>>>>>>    Function RedirectConnectionId String sConnectionID String sServer String sUserId String sPw Boolean bTrusted Boolean bKeepOpen Returns Boolean
22647>>>>>>>>>>>>>        Function_Return False
22648>>>>>>>>>>>>>    End_Function
22649>>>>>>>>>>>>>
22649>>>>>>>>>>>>>End_Class
22650>>>>>>>>>>>
22650>>>>>>>>>>>// We're making references to this object handle so we need it defined
22650>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
22650>>>>>>>>>>>
22650>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
22650>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
22651>>>>>>>>>>>
22651>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
22652>>>>>>>>>>>
22652>>>>>>>>>>>    Procedure Construct_Object
22654>>>>>>>>>>>        Handle ho
22654>>>>>>>>>>>        Forward Send Construct_Object
22656>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
22657>>>>>>>>>>>
22657>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
22658>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
22659>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
22660>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
22661>>>>>>>>>>>        
22661>>>>>>>>>>>
22661>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
22661>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
22661>>>>>>>>>>>        // methods to this class.
22661>>>>>>>>>>>        Property Boolean pbUseConnectionID True
22662>>>>>>>>>>>        Property Boolean pbToANSI          True
22663>>>>>>>>>>>        Property Boolean pbRecnum          True
22664>>>>>>>>>>>        Property Boolean pbCopyData        True
22665>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
22666>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
22667>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
22668>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
22669>>>>>>>>>>>
22669>>>>>>>>>>>        // Driver default value settings:
22669>>>>>>>>>>>        // Note: When the object is created the corresponding values
22669>>>>>>>>>>>        // from the driver .int files are read.
22669>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
22669>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
22670>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
22671>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
22672>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
22673>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
22674>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
22675>>>>>>>>>>>
22675>>>>>>>>>>>        // Driver "nullability" settings:
22675>>>>>>>>>>>        // Note: When the object is created the corresponding values
22675>>>>>>>>>>>        // from the driver .int files are read.
22675>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
22675>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
22676>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
22677>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
22678>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
22679>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
22680>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
22681>>>>>>>>>>>
22681>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
22681>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
22681>>>>>>>>>>>        //     driver interfaces.
22681>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
22681>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
22681>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
22682>>>>>>>>>>>
22682>>>>>>>>>>>    End_Procedure
22683>>>>>>>>>>>
22683>>>>>>>>>>>    Procedure End_Construct_Object
22685>>>>>>>>>>>        tSQLConnection SQLConnection
22685>>>>>>>>>>>        tSQLConnection SQLConnection
22685>>>>>>>>>>>
22685>>>>>>>>>>>        Forward Send End_Construct_Object
22687>>>>>>>>>>>
22687>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
22687>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
22688>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22689>>>>>>>>>>>    End_Procedure
22690>>>>>>>>>>>
22690>>>>>>>>>>>    // *** Properties ***
22690>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
22690>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
22690>>>>>>>>>>>    // merely here for conveniance.
22690>>>>>>>>>>>    //
22690>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
22690>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
22690>>>>>>>>>>>    // This struct property contains all the connection data.
22690>>>>>>>>>>>    //
22690>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
22692>>>>>>>>>>>        Boolean bOK
22692>>>>>>>>>>>
22692>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22693>>>>>>>>>>>
22693>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
22693>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
22695>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
22695>>>>>>>>>>>            Procedure_Return
22696>>>>>>>>>>>        End
22696>>>>>>>>>>>>
22696>>>>>>>>>>>
22696>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
22696>>>>>>>>>>>        // be logged in already and don't want to do it again.
22696>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
22698>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
22698>>>>>>>>>>>            // driver interfaces about the change & make a new login.
22698>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
22699>>>>>>>>>>>            If (bOK = False) Begin
22701>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
22702>>>>>>>>>>>>
22702>>>>>>>>>>>            End
22702>>>>>>>>>>>>
22702>>>>>>>>>>>        End
22702>>>>>>>>>>>>
22702>>>>>>>>>>>
22702>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
22702>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
22703>>>>>>>>>>>
22703>>>>>>>>>>>    End_Procedure
22704>>>>>>>>>>>
22704>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
22704>>>>>>>>>>>    // attempt to load the driver.
22704>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
22704>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
22706>>>>>>>>>>>        Boolean bOK
22706>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
22707>>>>>>>>>>>        Function_Return bOK
22708>>>>>>>>>>>    End_Function
22709>>>>>>>>>>>
22709>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
22709>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
22711>>>>>>>>>>>        String sAttributeValue
22711>>>>>>>>>>>        Integer iDriverID
22711>>>>>>>>>>>        Boolean bNULL bSQLDriver
22711>>>>>>>>>>>
22711>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
22712>>>>>>>>>>>        If (bSQLDriver = False) Begin
22714>>>>>>>>>>>            Procedure_Return
22715>>>>>>>>>>>        End                                      
22715>>>>>>>>>>>>
22715>>>>>>>>>>>        
22715>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
22716>>>>>>>>>>>
22716>>>>>>>>>>>        // Driver default values for various data types:
22716>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
22719>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
22720>>>>>>>>>>>
22720>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
22723>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
22724>>>>>>>>>>>
22724>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
22727>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
22728>>>>>>>>>>>
22728>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
22731>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
22732>>>>>>>>>>>
22732>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
22735>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
22736>>>>>>>>>>>
22736>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
22739>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
22740>>>>>>>>>>>
22740>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
22740>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
22743>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
22744>>>>>>>>>>>
22744>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
22747>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
22748>>>>>>>>>>>
22748>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
22751>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
22752>>>>>>>>>>>
22752>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
22755>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
22756>>>>>>>>>>>
22756>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
22759>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
22760>>>>>>>>>>>
22760>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
22763>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
22764>>>>>>>>>>>
22764>>>>>>>>>>>    End_Procedure
22765>>>>>>>>>>>
22765>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
22767>>>>>>>>>>>        Boolean bOK bIsDaw
22767>>>>>>>>>>>        String sConnectionString
22767>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
22767>>>>>>>>>>>        Integer iDriverID
22767>>>>>>>>>>>
22767>>>>>>>>>>>        Move False to bOK
22768>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
22769>>>>>>>>>>>
22769>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
22770>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
22771>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
22772>>>>>>>>>>>        If (iDriverID = 0) Begin
22774>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
22775>>>>>>>>>>>            Function_Return False
22776>>>>>>>>>>>        End
22776>>>>>>>>>>>>
22776>>>>>>>>>>>
22776>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
22779>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
22780>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
22781>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
22782>>>>>>>>>>>        Send Destroy   of hoDriver
22783>>>>>>>>>>>
22783>>>>>>>>>>>        Function_Return bOK
22784>>>>>>>>>>>    End_Function
22785>>>>>>>>>>>
22785>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
22787>>>>>>>>>>>        tSQLConnection SQLConnection
22787>>>>>>>>>>>        tSQLConnection SQLConnection
22787>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22788>>>>>>>>>>>        Function_Return SQLConnection
22789>>>>>>>>>>>    End_Function
22790>>>>>>>>>>>
22790>>>>>>>>>>>    Procedure Set psConnectionID String sValue
22792>>>>>>>>>>>        tSQLConnection SQLConnection
22792>>>>>>>>>>>        tSQLConnection SQLConnection
22792>>>>>>>>>>>
22792>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22793>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
22795>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
22796>>>>>>>>>>>        End
22796>>>>>>>>>>>>
22796>>>>>>>>>>>
22796>>>>>>>>>>>        // Else we might want to change the current connection ID
22796>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
22799>>>>>>>>>>>            Move False to Err
22800>>>>>>>>>>>            Logout SQLConnection.sDriverID
22801>>>>>>>>>>>            // This will also make a login to the new server.
22801>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
22802>>>>>>>>>>>        End
22802>>>>>>>>>>>>
22802>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22803>>>>>>>>>>>    End_Procedure
22804>>>>>>>>>>>
22804>>>>>>>>>>>    Function psConnectionID Returns String
22806>>>>>>>>>>>        tSQLConnection SQLConnection
22806>>>>>>>>>>>        tSQLConnection SQLConnection
22806>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22807>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
22808>>>>>>>>>>>    End_Function
22809>>>>>>>>>>>
22809>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
22809>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
22809>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
22809>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
22809>>>>>>>>>>>    Procedure Set psDriverID String sValue
22811>>>>>>>>>>>        tSQLConnection SQLConnection
22811>>>>>>>>>>>        tSQLConnection SQLConnection
22811>>>>>>>>>>>        Get pSQLConnection to SQLConnection
22812>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
22813>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22814>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
22816>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22817>>>>>>>>>>>        End
22817>>>>>>>>>>>>
22817>>>>>>>>>>>    End_Procedure
22818>>>>>>>>>>>
22818>>>>>>>>>>>    Function psDriverID Returns String
22820>>>>>>>>>>>        tSQLConnection SQLConnection
22820>>>>>>>>>>>        tSQLConnection SQLConnection
22820>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22821>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
22823>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
22824>>>>>>>>>>>        End
22824>>>>>>>>>>>>
22824>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
22825>>>>>>>>>>>    End_Function
22826>>>>>>>>>>>
22826>>>>>>>>>>>    Procedure Set psConnectionString String sValue
22828>>>>>>>>>>>        tSQLConnection SQLConnection
22828>>>>>>>>>>>        tSQLConnection SQLConnection
22828>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22829>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
22830>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22831>>>>>>>>>>>    End_Procedure
22832>>>>>>>>>>>
22832>>>>>>>>>>>    Function psConnectionString Returns String
22834>>>>>>>>>>>        tSQLConnection SQLConnection
22834>>>>>>>>>>>        tSQLConnection SQLConnection
22834>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22835>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
22836>>>>>>>>>>>    End_Function
22837>>>>>>>>>>>
22837>>>>>>>>>>>    Procedure Set psServer String sValue
22839>>>>>>>>>>>        tSQLConnection SQLConnection
22839>>>>>>>>>>>        tSQLConnection SQLConnection
22839>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22840>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
22841>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22842>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22843>>>>>>>>>>>    End_Procedure
22844>>>>>>>>>>>
22844>>>>>>>>>>>    Function psServer Returns String
22846>>>>>>>>>>>        tSQLConnection SQLConnection
22846>>>>>>>>>>>        tSQLConnection SQLConnection
22846>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22847>>>>>>>>>>>        Function_Return SQLConnection.sServer
22848>>>>>>>>>>>    End_Function
22849>>>>>>>>>>>
22849>>>>>>>>>>>    Procedure Set psDatabase String sValue
22851>>>>>>>>>>>        tSQLConnection SQLConnection
22851>>>>>>>>>>>        tSQLConnection SQLConnection
22851>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22852>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
22853>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22854>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22855>>>>>>>>>>>    End_Procedure
22856>>>>>>>>>>>
22856>>>>>>>>>>>    Function psDatabase Returns String
22858>>>>>>>>>>>        tSQLConnection SQLConnection
22858>>>>>>>>>>>        tSQLConnection SQLConnection
22858>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22859>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
22860>>>>>>>>>>>    End_Function
22861>>>>>>>>>>>
22861>>>>>>>>>>>    Procedure Set psUserID String sValue
22863>>>>>>>>>>>        tSQLConnection SQLConnection
22863>>>>>>>>>>>        tSQLConnection SQLConnection
22863>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22864>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
22865>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22866>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22867>>>>>>>>>>>    End_Procedure
22868>>>>>>>>>>>
22868>>>>>>>>>>>    Function psUserID Returns String
22870>>>>>>>>>>>        tSQLConnection SQLConnection
22870>>>>>>>>>>>        tSQLConnection SQLConnection
22870>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22871>>>>>>>>>>>        Function_Return SQLConnection.sUserID
22872>>>>>>>>>>>    End_Function
22873>>>>>>>>>>>
22873>>>>>>>>>>>    // This is the uncrypted password
22873>>>>>>>>>>>    Procedure Set psPassword String sValue
22875>>>>>>>>>>>        tSQLConnection SQLConnection
22875>>>>>>>>>>>        tSQLConnection SQLConnection
22875>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22876>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
22877>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22878>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22879>>>>>>>>>>>    End_Procedure
22880>>>>>>>>>>>
22880>>>>>>>>>>>    Function psPassword Returns String
22882>>>>>>>>>>>        tSQLConnection SQLConnection
22882>>>>>>>>>>>        tSQLConnection SQLConnection
22882>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22883>>>>>>>>>>>        Function_Return SQLConnection.sPassword
22884>>>>>>>>>>>    End_Function
22885>>>>>>>>>>>
22885>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
22887>>>>>>>>>>>        tSQLConnection SQLConnection
22887>>>>>>>>>>>        tSQLConnection SQLConnection
22887>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22888>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
22889>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
22890>>>>>>>>>>>        Set pSQLConnection to SQLConnection
22891>>>>>>>>>>>    End_Procedure
22892>>>>>>>>>>>
22892>>>>>>>>>>>    Function pbTrusted Returns Boolean
22894>>>>>>>>>>>        tSQLConnection SQLConnection
22894>>>>>>>>>>>        tSQLConnection SQLConnection
22894>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22895>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
22896>>>>>>>>>>>    End_Function
22897>>>>>>>>>>>
22897>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
22897>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
22897>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
22897>>>>>>>>>>>    //     the central pSQLConnection "hub".
22897>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
22899>>>>>>>>>>>        tSQLConnection SQLConnection
22899>>>>>>>>>>>        tSQLConnection SQLConnection
22899>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22900>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
22901>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22902>>>>>>>>>>>    End_Procedure
22903>>>>>>>>>>>
22903>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
22905>>>>>>>>>>>        tSQLConnection SQLConnection
22905>>>>>>>>>>>        tSQLConnection SQLConnection
22905>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22906>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
22907>>>>>>>>>>>    End_Function
22908>>>>>>>>>>>
22908>>>>>>>>>>>    Procedure Set piDbType Integer iValue
22910>>>>>>>>>>>        tSQLConnection SQLConnection
22910>>>>>>>>>>>        tSQLConnection SQLConnection
22910>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22911>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
22912>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22913>>>>>>>>>>>    End_Procedure
22914>>>>>>>>>>>
22914>>>>>>>>>>>    Function piDbType Returns Integer
22916>>>>>>>>>>>        tSQLConnection SQLConnection
22916>>>>>>>>>>>        tSQLConnection SQLConnection
22916>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22917>>>>>>>>>>>        Function_Return SQLConnection.iDbType
22918>>>>>>>>>>>    End_Function
22919>>>>>>>>>>>
22919>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
22921>>>>>>>>>>>        tSQLConnection SQLConnection
22921>>>>>>>>>>>        tSQLConnection SQLConnection
22921>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22922>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
22923>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22924>>>>>>>>>>>    End_Procedure
22925>>>>>>>>>>>
22925>>>>>>>>>>>    Function psBaseTableSpace Returns String
22927>>>>>>>>>>>        tSQLConnection SQLConnection
22927>>>>>>>>>>>        tSQLConnection SQLConnection
22927>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22928>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
22929>>>>>>>>>>>    End_Function
22930>>>>>>>>>>>
22930>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
22932>>>>>>>>>>>        tSQLConnection SQLConnection
22932>>>>>>>>>>>        tSQLConnection SQLConnection
22932>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22933>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
22934>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22935>>>>>>>>>>>    End_Procedure
22936>>>>>>>>>>>
22936>>>>>>>>>>>    Function psIndexTableSpace Returns String
22938>>>>>>>>>>>        tSQLConnection SQLConnection
22938>>>>>>>>>>>        tSQLConnection SQLConnection
22938>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22939>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
22940>>>>>>>>>>>    End_Function
22941>>>>>>>>>>>
22941>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
22943>>>>>>>>>>>        tSQLConnection SQLConnection
22943>>>>>>>>>>>        tSQLConnection SQLConnection
22943>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22944>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
22945>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22946>>>>>>>>>>>    End_Procedure
22947>>>>>>>>>>>
22947>>>>>>>>>>>    Function psLongTableSpace Returns String
22949>>>>>>>>>>>        tSQLConnection SQLConnection
22949>>>>>>>>>>>        tSQLConnection SQLConnection
22949>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22950>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
22951>>>>>>>>>>>    End_Function
22952>>>>>>>>>>>
22952>>>>>>>>>>>    Procedure Set psSchema String sValue
22954>>>>>>>>>>>        tSQLConnection SQLConnection
22954>>>>>>>>>>>        tSQLConnection SQLConnection
22954>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22955>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
22956>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22957>>>>>>>>>>>    End_Procedure
22958>>>>>>>>>>>
22958>>>>>>>>>>>    Function psSchema Returns String
22960>>>>>>>>>>>        tSQLConnection SQLConnection
22960>>>>>>>>>>>        tSQLConnection SQLConnection
22960>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22961>>>>>>>>>>>        Function_Return SQLConnection.sSchema
22962>>>>>>>>>>>    End_Function
22963>>>>>>>>>>>
22963>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
22965>>>>>>>>>>>        tSQLConnection SQLConnection
22965>>>>>>>>>>>        tSQLConnection SQLConnection
22965>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22966>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
22967>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
22968>>>>>>>>>>>    End_Procedure
22969>>>>>>>>>>>
22969>>>>>>>>>>>    Function pbEnabled Returns Boolean
22971>>>>>>>>>>>        tSQLConnection SQLConnection
22971>>>>>>>>>>>        tSQLConnection SQLConnection
22971>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
22972>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
22973>>>>>>>>>>>    End_Function
22974>>>>>>>>>>>
22974>>>>>>>>>>>
22974>>>>>>>>>>>    // ************************************
22974>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
22976>>>>>>>>>>>        tSQLConnection SQLConnection
22976>>>>>>>>>>>        tSQLConnection SQLConnection
22976>>>>>>>>>>>
22976>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
22976>>>>>>>>>>>        // deferr reading SQL connection values until later.
22976>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
22978>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
22978>>>>>>>>>>>            If (ghoConnection > 0) Begin
22980>>>>>>>>>>>                Get ReadcConnections to SQLConnection
22981>>>>>>>>>>>            End
22981>>>>>>>>>>>>
22981>>>>>>>>>>>
22981>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
22981>>>>>>>>>>>            // object is used.
22981>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
22983>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
22984>>>>>>>>>>>            End
22984>>>>>>>>>>>>
22984>>>>>>>>>>>        End
22984>>>>>>>>>>>>
22984>>>>>>>>>>>
22984>>>>>>>>>>>        Function_Return SQLConnection
22985>>>>>>>>>>>    End_Function
22986>>>>>>>>>>>
22986>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
22986>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
22988>>>>>>>>>>>        tConnection Connection
22988>>>>>>>>>>>        tConnection Connection
22988>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22988>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
22988>>>>>>>>>>>        Integer iRetval iDbType
22988>>>>>>>>>>>        Boolean bOK bConnected
22988>>>>>>>>>>>        String sConnectionID
22988>>>>>>>>>>>
22988>>>>>>>>>>>
22988>>>>>>>>>>>        Function_Return SQLConnection
22989>>>>>>>>>>>    End_Function
22990>>>>>>>>>>>
22990>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
22990>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
22990>>>>>>>>>>>    // connection id for a particular driver.
22990>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
22990>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
22990>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
22990>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
22990>>>>>>>>>>>    // connections of the DAW cConnect class.
22990>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
22992>>>>>>>>>>>        tConnection[] ConnIdArray
22992>>>>>>>>>>>        tConnection[] ConnIdArray
22993>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
22993>>>>>>>>>>>        Boolean bEnabled bFound
22993>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
22993>>>>>>>>>>>
22993>>>>>>>>>>>        Move False to bFound
22994>>>>>>>>>>>        If (ghoConnection > 0) Begin
22996>>>>>>>>>>>
22996>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
22996>>>>>>>>>>>            Get psDriverID to sDriverID
22997>>>>>>>>>>>
22997>>>>>>>>>>>            Move 0 to iConnectionIDCounter
22998>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
22998>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
22999>>>>>>>>>>>            Decrement iSize
23000>>>>>>>>>>>            For iCount from 0 to iSize
23006>>>>>>>>>>>>
23006>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
23007>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
23008>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
23009>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
23009>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
23009>>>>>>>>>>>                If (sConnectionID = "") Begin
23011>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
23012>>>>>>>>>>>                End
23012>>>>>>>>>>>>
23012>>>>>>>>>>>                Else Begin
23013>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
23015>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
23016>>>>>>>>>>>                    End
23016>>>>>>>>>>>>
23016>>>>>>>>>>>                End
23016>>>>>>>>>>>>
23016>>>>>>>>>>>
23016>>>>>>>>>>>                If (bFound = True) Begin
23018>>>>>>>>>>>                    Increment iConnectionIDCounter
23019>>>>>>>>>>>                End
23019>>>>>>>>>>>>
23019>>>>>>>>>>>            Loop
23020>>>>>>>>>>>>
23020>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
23021>>>>>>>>>>>            If (bFound = True) Begin
23023>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
23024>>>>>>>>>>>            End
23024>>>>>>>>>>>>
23024>>>>>>>>>>>        End
23024>>>>>>>>>>>>
23024>>>>>>>>>>>
23024>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
23024>>>>>>>>>>>        // but no DFConn.ini record has been created.
23024>>>>>>>>>>>        If (iSize = -1) Begin
23026>>>>>>>>>>>            Move True to bFound
23027>>>>>>>>>>>        End
23027>>>>>>>>>>>>
23027>>>>>>>>>>>
23027>>>>>>>>>>>        Function_Return bFound
23028>>>>>>>>>>>    End_Function
23029>>>>>>>>>>>
23029>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
23029>>>>>>>>>>>    // create a connection to the server.
23029>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
23031>>>>>>>>>>>        String sPath sFileName
23031>>>>>>>>>>>        Boolean bExists bActive
23031>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
23031>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
23032>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
23032>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
23032>>>>>>>>>>>        Handle hoIniFile
23032>>>>>>>>>>>        Integer iSize iCount iRetval
23032>>>>>>>>>>>
23032>>>>>>>>>>>        Get psIniFilePath to sPath
23033>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
23034>>>>>>>>>>>        If (sPath = "") Begin
23036>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
23037>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
23038>>>>>>>>>>>        End
23038>>>>>>>>>>>>
23038>>>>>>>>>>>        Get vFolderFormat sPath to sPath
23039>>>>>>>>>>>        Get psIniFileName to sFileName
23040>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
23041>>>>>>>>>>>
23041>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
23042>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
23043>>>>>>>>>>>        If (iSize = 0) Begin
23045>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
23045>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
23045>>>>>>>>>>>            // in the cApplication object.
23045>>>>>>>>>>>            Get pSQLConnection to SQLConnection
23046>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
23048>>>>>>>>>>>                Function_Return SQLConnectionEmpty
23049>>>>>>>>>>>            End
23049>>>>>>>>>>>>
23049>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
23050>>>>>>>>>>>            Move 1 to iSize
23051>>>>>>>>>>>        End
23051>>>>>>>>>>>>
23051>>>>>>>>>>>
23051>>>>>>>>>>>        Move False to bActive
23052>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
23052>>>>>>>>>>>        Decrement iSize
23053>>>>>>>>>>>        For iCount from 0 to iSize
23059>>>>>>>>>>>>
23059>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
23060>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
23062>>>>>>>>>>>                Move True to bActive
23063>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
23064>>>>>>>>>>>            End
23064>>>>>>>>>>>>
23064>>>>>>>>>>>        Loop
23065>>>>>>>>>>>>
23065>>>>>>>>>>>
23065>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
23065>>>>>>>>>>>        If (bActive = False) Begin
23067>>>>>>>>>>>            Function_Return SQLConnectionEmpty
23068>>>>>>>>>>>        End
23068>>>>>>>>>>>>
23068>>>>>>>>>>>
23068>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
23069>>>>>>>>>>>
23069>>>>>>>>>>>        Set pSQLConnection to SQLConnection
23070>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
23071>>>>>>>>>>>
23071>>>>>>>>>>>        Function_Return SQLConnection
23072>>>>>>>>>>>    End_Function
23073>>>>>>>>>>>
23073>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
23075>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
23076>>>>>>>>>>>    End_Procedure
23077>>>>>>>>>>>
23077>>>>>>>>>>>    Function psIniFilePath Returns String
23079>>>>>>>>>>>        String sRetval
23079>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
23080>>>>>>>>>>>        Function_Return sRetval
23081>>>>>>>>>>>    End_Function
23082>>>>>>>>>>>
23082>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
23084>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
23085>>>>>>>>>>>    End_Procedure
23086>>>>>>>>>>>
23086>>>>>>>>>>>    Function psIniFileName Returns String
23088>>>>>>>>>>>        String sRetval
23088>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
23089>>>>>>>>>>>        Function_Return sRetval
23090>>>>>>>>>>>    End_Function
23091>>>>>>>>>>>
23091>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
23093>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
23094>>>>>>>>>>>    End_Procedure
23095>>>>>>>>>>>
23095>>>>>>>>>>>    Function psIniSectionName Returns String
23097>>>>>>>>>>>        String sRetval
23097>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
23098>>>>>>>>>>>        Function_Return sRetval
23099>>>>>>>>>>>    End_Function
23100>>>>>>>>>>>
23100>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
23102>>>>>>>>>>>        Handle ho
23102>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23103>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
23104>>>>>>>>>>>    End_Procedure
23105>>>>>>>>>>>
23105>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
23107>>>>>>>>>>>        Handle ho
23107>>>>>>>>>>>        String sRetval
23107>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23108>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
23109>>>>>>>>>>>        Function_Return sRetval
23110>>>>>>>>>>>    End_Function
23111>>>>>>>>>>>
23111>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
23113>>>>>>>>>>>        Handle ho
23113>>>>>>>>>>>        Boolean bRetval
23113>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23114>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
23115>>>>>>>>>>>        Function_Return bRetval
23116>>>>>>>>>>>    End_Function
23117>>>>>>>>>>>
23117>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
23119>>>>>>>>>>>        Handle ho
23119>>>>>>>>>>>        Boolean bRetval
23119>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23120>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
23121>>>>>>>>>>>        Function_Return bRetval
23122>>>>>>>>>>>    End_Function
23123>>>>>>>>>>>
23123>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
23125>>>>>>>>>>>        Handle ho
23125>>>>>>>>>>>        String sRetval
23125>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23126>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
23127>>>>>>>>>>>        Function_Return sRetval
23128>>>>>>>>>>>    End_Function
23129>>>>>>>>>>>
23129>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
23131>>>>>>>>>>>        Handle ho
23131>>>>>>>>>>>        String sRetval
23131>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23132>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
23133>>>>>>>>>>>        Function_Return sRetval
23134>>>>>>>>>>>    End_Function
23135>>>>>>>>>>>
23135>>>>>>>>>>>    // *** Main Connection Message ***
23135>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
23137>>>>>>>>>>>        Handle hoDriver
23137>>>>>>>>>>>        String sConnectionString sError
23137>>>>>>>>>>>        Boolean bLoginSuccessful
23137>>>>>>>>>>>
23137>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
23138>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
23139>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
23140>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
23141>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
23143>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
23144>>>>>>>>>>>>
23144>>>>>>>>>>>            If (bExitProgram = True) Begin
23146>>>>>>>>>>>                Send Exit_Application
23147>>>>>>>>>>>            End
23147>>>>>>>>>>>>
23147>>>>>>>>>>>        End
23147>>>>>>>>>>>>
23147>>>>>>>>>>>        Send Destroy of hoDriver
23148>>>>>>>>>>>    End_Procedure
23149>>>>>>>>>>>
23149>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
23151>>>>>>>>>>>        Integer iRetval
23151>>>>>>>>>>>        Handle hoCLI
23151>>>>>>>>>>>        String sDriverID
23151>>>>>>>>>>>
23151>>>>>>>>>>>        Get psDriverID to sDriverID
23152>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
23153>>>>>>>>>>>        If (hoCLI <> 0) Begin
23155>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
23156>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
23157>>>>>>>>>>>            Send Destroy of hoCLI
23158>>>>>>>>>>>        End
23158>>>>>>>>>>>>
23158>>>>>>>>>>>
23158>>>>>>>>>>>        Function_Return iRetval
23159>>>>>>>>>>>    End_Function
23160>>>>>>>>>>>
23160>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
23162>>>>>>>>>>>        tSQLConnection SQLConnection
23162>>>>>>>>>>>        tSQLConnection SQLConnection
23162>>>>>>>>>>>
23162>>>>>>>>>>>        Set psDriverID to sDriverID
23163>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
23164>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
23165>>>>>>>>>>>    End_Procedure
23166>>>>>>>>>>>
23166>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
23166>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
23166>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
23166>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
23166>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
23166>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
23166>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
23166>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
23168>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
23168>>>>>>>>>>>        Handle hoCLI
23168>>>>>>>>>>>        String sID
23168>>>>>>>>>>>
23168>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
23170>>>>>>>>>>>            Procedure_Return
23171>>>>>>>>>>>        End
23171>>>>>>>>>>>>
23171>>>>>>>>>>>
23171>>>>>>>>>>>        Move 0 to iResult
23172>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23173>>>>>>>>>>>        If (hoCLI <> 0) Begin
23175>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
23176>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
23177>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
23180>>>>>>>>>>>            Decrement iNumConn
23181>>>>>>>>>>>            For iConn from 0 to iNumConn
23187>>>>>>>>>>>>
23187>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
23190>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
23192>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
23193>>>>>>>>>>>                End
23193>>>>>>>>>>>>
23193>>>>>>>>>>>            Loop
23194>>>>>>>>>>>>
23194>>>>>>>>>>>            Send Destroy of hoCLI
23195>>>>>>>>>>>        End
23195>>>>>>>>>>>>
23195>>>>>>>>>>>
23195>>>>>>>>>>>    End_Procedure
23196>>>>>>>>>>>
23196>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
23198>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
23198>>>>>>>>>>>        Handle hoCLI
23198>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
23198>>>>>>>>>>>        tSQLConnection SQLConnection
23198>>>>>>>>>>>        tSQLConnection SQLConnection
23198>>>>>>>>>>>        Boolean bTrusted
23198>>>>>>>>>>>
23198>>>>>>>>>>>        Move 0 to iResult
23199>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23200>>>>>>>>>>>        If (hoCLI <> 0) Begin
23202>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
23203>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
23204>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
23207>>>>>>>>>>>            Decrement iNumConn
23208>>>>>>>>>>>            For iConn from 0 to iNumConn
23214>>>>>>>>>>>>
23214>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
23217>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
23219>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
23220>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
23223>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
23226>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
23227>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
23230>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
23231>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
23232>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
23233>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
23234>>>>>>>>>>>
23234>>>>>>>>>>>                    Case Begin
23234>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
23236>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
23237>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
23238>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
23239>>>>>>>>>>>                            Case Break
23240>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
23243>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23244>>>>>>>>>>>                            Case Break
23245>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
23248>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
23249>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
23251>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
23252>>>>>>>>>>>                            End
23252>>>>>>>>>>>>
23252>>>>>>>>>>>                            Case Break
23253>>>>>>>>>>>                        Case Else
23253>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
23254>>>>>>>>>>>>
23254>>>>>>>>>>>                            Case Break
23255>>>>>>>>>>>                    Case End
23255>>>>>>>>>>>                End
23255>>>>>>>>>>>>
23255>>>>>>>>>>>            Loop
23256>>>>>>>>>>>>
23256>>>>>>>>>>>            Send Destroy of hoCLI
23257>>>>>>>>>>>        End
23257>>>>>>>>>>>>
23257>>>>>>>>>>>
23257>>>>>>>>>>>        Function_Return SQLConnection
23258>>>>>>>>>>>    End_Function
23259>>>>>>>>>>>
23259>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
23261>>>>>>>>>>>        String  sCurrentDriver
23261>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
23261>>>>>>>>>>>
23261>>>>>>>>>>>        Move 0 to iDriver
23262>>>>>>>>>>>        Move 0 to iCount
23263>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
23266>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
23272>>>>>>>>>>>>
23272>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
23275>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
23277>>>>>>>>>>>                Function_Return iCount
23278>>>>>>>>>>>            End
23278>>>>>>>>>>>>
23278>>>>>>>>>>>        Loop
23279>>>>>>>>>>>>
23279>>>>>>>>>>>
23279>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
23279>>>>>>>>>>>        If (iDriver = 0) Begin
23281>>>>>>>>>>>            Move 0 to LastErr
23282>>>>>>>>>>>            Load_Driver sDriverID
23283>>>>>>>>>>>            // If driver could not be loaded.
23283>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
23285>>>>>>>>>>>                Move -1 to iCount
23286>>>>>>>>>>>            End
23286>>>>>>>>>>>>
23286>>>>>>>>>>>        End
23286>>>>>>>>>>>>
23286>>>>>>>>>>>        Function_Return iCount
23287>>>>>>>>>>>    End_Function
23288>>>>>>>>>>>
23288>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
23288>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
23290>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
23290>>>>>>>>>>>        Boolean bTrusted bSilent
23290>>>>>>>>>>>        Integer iRetval
23290>>>>>>>>>>>
23290>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
23291>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
23292>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
23293>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
23294>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
23295>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
23296>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
23297>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
23298>>>>>>>>>>>
23298>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
23299>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
23299>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
23300>>>>>>>>>>>    End_Procedure
23301>>>>>>>>>>>
23301>>>>>>>>>>>    // Called when the object is constructed.
23301>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
23301>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
23301>>>>>>>>>>>    // the database is needed.
23301>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
23303>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
23303>>>>>>>>>>>        Integer iDriver iRetval
23303>>>>>>>>>>>        Handle hoCLI
23303>>>>>>>>>>>        Boolean bOK bSilent
23303>>>>>>>>>>>
23303>>>>>>>>>>>        Get pbSilentLogin      to bSilent
23304>>>>>>>>>>>        Get psConnectionID     to sConnectionID
23305>>>>>>>>>>>        Get psConnectionString to sConnectionString
23306>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
23306>>>>>>>>>>>        Get psDriverID to sDriverID
23307>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23308>>>>>>>>>>>        If (bOK = False) Begin
23310>>>>>>>>>>>            Function_Return False
23311>>>>>>>>>>>        End
23311>>>>>>>>>>>>
23311>>>>>>>>>>>
23311>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
23312>>>>>>>>>>>        // If driver not loaded; load it.
23312>>>>>>>>>>>        If (iDriver = 0) Begin
23314>>>>>>>>>>>            Load_Driver sDriverID
23315>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
23316>>>>>>>>>>>        End
23316>>>>>>>>>>>>
23316>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
23316>>>>>>>>>>>        If (iDriver = 0) Begin
23318>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
23319>>>>>>>>>>>>
23319>>>>>>>>>>>            Function_Return False
23320>>>>>>>>>>>        End           
23320>>>>>>>>>>>>
23320>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
23323>>>>>>>>>>>        
23323>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
23324>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
23325>>>>>>>>>>>        // Delete the connection first; in case it exists
23325>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
23326>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
23327>>>>>>>>>>>        Send Destroy of hoCLI
23328>>>>>>>>>>>
23328>>>>>>>>>>>        Function_Return (iRetval = 0)
23329>>>>>>>>>>>    End_Function
23330>>>>>>>>>>>
23330>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
23332>>>>>>>>>>>        Boolean bOK
23332>>>>>>>>>>>
23332>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
23333>>>>>>>>>>>
23333>>>>>>>>>>>        If (bOK = False) Begin
23335>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
23336>>>>>>>>>>>>
23336>>>>>>>>>>>            Function_Return False
23337>>>>>>>>>>>        End
23337>>>>>>>>>>>>
23337>>>>>>>>>>>
23337>>>>>>>>>>>        Function_Return True
23338>>>>>>>>>>>    End_Function
23339>>>>>>>>>>>
23339>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
23341>>>>>>>>>>>        Boolean bOK
23341>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
23342>>>>>>>>>>>        Function_Return bOK
23343>>>>>>>>>>>    End_Function
23344>>>>>>>>>>>
23344>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
23346>>>>>>>>>>>        Handle hoIniFile
23346>>>>>>>>>>>        String sConnect
23346>>>>>>>>>>>
23346>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
23347>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
23348>>>>>>>>>>>
23348>>>>>>>>>>>        Function_Return sConnect
23349>>>>>>>>>>>    End_Function
23350>>>>>>>>>>>
23350>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
23350>>>>>>>>>>>    // Pass a complete driver connection string
23350>>>>>>>>>>>    // Returns the following as a struct:
23350>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
23350>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
23350>>>>>>>>>>>    //
23350>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
23352>>>>>>>>>>>        tSQLConnection SQLConnection
23352>>>>>>>>>>>        tSQLConnection SQLConnection
23352>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
23352>>>>>>>>>>>        Boolean bTrusted bSilent bOK
23352>>>>>>>>>>>        Integer iPos
23352>>>>>>>>>>>
23352>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23353>>>>>>>>>>>        If (bOK = False) Begin
23355>>>>>>>>>>>            Function_Return SQLConnection
23356>>>>>>>>>>>        End
23356>>>>>>>>>>>>
23356>>>>>>>>>>>
23356>>>>>>>>>>>        Move False to bTrusted
23357>>>>>>>>>>>        Move False to bSilent
23358>>>>>>>>>>>
23358>>>>>>>>>>>        Case Begin
23358>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
23360>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
23361>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
23362>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23363>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23364>>>>>>>>>>>                If (bTrusted = False) Begin
23366>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23367>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23368>>>>>>>>>>>                End
23368>>>>>>>>>>>>
23368>>>>>>>>>>>                Case Break
23369>>>>>>>>>>>
23369>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
23372>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
23374>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
23375>>>>>>>>>>>                End
23375>>>>>>>>>>>>
23375>>>>>>>>>>>                Else Begin
23376>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23377>>>>>>>>>>>                End
23377>>>>>>>>>>>>
23377>>>>>>>>>>>
23377>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
23378>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
23379>>>>>>>>>>>                If (bTrusted = False) Begin
23381>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
23382>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
23383>>>>>>>>>>>                End
23383>>>>>>>>>>>>
23383>>>>>>>>>>>                Case Break
23384>>>>>>>>>>>
23384>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
23387>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
23388>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
23389>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
23390>>>>>>>>>>>                Case Break
23391>>>>>>>>>>>
23391>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
23394>>>>>>>>>>>                Break
23395>>>>>>>>>>>        Case End
23395>>>>>>>>>>>
23395>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
23396>>>>>>>>>>>
23396>>>>>>>>>>>        // bSilent?
23396>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
23397>>>>>>>>>>>        If (iPos = 0) Begin
23399>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
23400>>>>>>>>>>>        End
23400>>>>>>>>>>>>
23400>>>>>>>>>>>        If (iPos = 0) Begin
23402>>>>>>>>>>>            Move "0"                                                            to sValue
23403>>>>>>>>>>>        End
23403>>>>>>>>>>>>
23403>>>>>>>>>>>        Else Begin
23404>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
23405>>>>>>>>>>>        End
23405>>>>>>>>>>>>
23405>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
23406>>>>>>>>>>>
23406>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
23407>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
23408>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
23409>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
23410>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
23411>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
23412>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
23413>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
23414>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
23415>>>>>>>>>>>
23415>>>>>>>>>>>        Function_Return SQLConnection
23416>>>>>>>>>>>    End_Function
23417>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
23417>>>>>>>>>>>>
23417>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
23419>>>>>>>>>>>>    Integer iStart iEnd
23419>>>>>>>>>>>>    String sRetval
23419>>>>>>>>>>>>
23419>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
23420>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
23421>>>>>>>>>>>>    If (iStart = 0) Begin
23423>>>>>>>>>>>>        Function_Return ""
23424>>>>>>>>>>>>    End
23424>>>>>>>>>>>>>
23424>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
23425>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
23426>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
23428>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
23429>>>>>>>>>>>>    End
23429>>>>>>>>>>>>>
23429>>>>>>>>>>>>    Else Begin
23430>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
23431>>>>>>>>>>>>    End
23431>>>>>>>>>>>>>
23431>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
23433>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
23434>>>>>>>>>>>>        Decrement iEnd
23435>>>>>>>>>>>>    End
23435>>>>>>>>>>>>>
23435>>>>>>>>>>>>    If (iEnd <> 0) Begin
23437>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
23438>>>>>>>>>>>>    End
23438>>>>>>>>>>>>>
23438>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
23439>>>>>>>>>>>>
23439>>>>>>>>>>>>    Function_Return (Trim(sRetval))
23440>>>>>>>>>>>>End_Function
23441>>>>>>>>>>>>
23441>>>>>>>>>>>>
23441>>>>>>>>>>>
23441>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
23441>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
23443>>>>>>>>>>>        Handle ho
23443>>>>>>>>>>>        Integer iIndex
23443>>>>>>>>>>>        Boolean bRetval bOK
23443>>>>>>>>>>>        tSQLConnection SQLConnection
23443>>>>>>>>>>>        tSQLConnection SQLConnection
23443>>>>>>>>>>>
23443>>>>>>>>>>>        Get pSQLConnection to SQLConnection
23444>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
23445>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
23446>>>>>>>>>>>        If (iIndex = -1) Begin
23448>>>>>>>>>>>            Function_Return False
23449>>>>>>>>>>>        End
23449>>>>>>>>>>>>
23449>>>>>>>>>>>
23449>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
23450>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
23451>>>>>>>>>>>        If (ghoConnection > 0) Begin
23453>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
23454>>>>>>>>>>>            If (iIndex <> -1) Begin
23456>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
23457>>>>>>>>>>>            End
23457>>>>>>>>>>>>
23457>>>>>>>>>>>        End
23457>>>>>>>>>>>>
23457>>>>>>>>>>>
23457>>>>>>>>>>>        Function_Return bRetval
23458>>>>>>>>>>>    End_Function
23459>>>>>>>>>>>
23459>>>>>>>>>>>End_Class
23460>>>>>>>>>Use vWin32fh.pkg
23460>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
23460>>>>>>>>>>>Use LanguageText.pkg
23460>>>>>>>>>>>Use Windows.pkg
23460>>>>>>>>>>>Use Dfclient.pkg
Including file: Dfclient.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfclient.pkg)
23460>>>>>>>>>>>>>Use Windows.pkg
23460>>>>>>>>>>>>>Use DfPanel.pkg
Including file: Dfpanel.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfpanel.pkg)
23460>>>>>>>>>>>>>>>Use Windows.pkg
23460>>>>>>>>>>>>>>>Use dfcolor.pkg
23460>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>//  Used when help object makes a request to the object requesting help.
23460>>>>>>>>>>>>>>>Use HelpSystemConstants.pkg
23460>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>Enumeration_List
23460>>>>>>>>>>>>>>>    Define amTop
23460>>>>>>>>>>>>>>>    Define amBottom
23460>>>>>>>>>>>>>>>    Define amLeft
23460>>>>>>>>>>>>>>>    Define amRight
23460>>>>>>>>>>>>>>>End_Enumeration_List
23460>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>Use DFAStBar.pkg  // df application status bar
Including file: Dfastbar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfastbar.pkg)
23460>>>>>>>>>>>>>>>>>Register_Procedure Add_Border_Object
23460>>>>>>>>>>>>>>>>>Register_Procedure Remove_Border_Object
23460>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>Use DFStatBr.pkg
Including file: Dfstatbr.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfstatbr.pkg)
23460>>>>>>>>>>>>>>>>>>>Use windows.pkg
23460>>>>>>>>>>>>>>>>>>>Use CommCtrl.pkg
23460>>>>>>>>>>>>>>>>>>>Use WinGDI.pkg
23460>>>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>>>
23460>>>>>>>>>>>>>>>>>>>Class BasicStatusBar is a dfBaseList
23461>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23463>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23465>>>>>>>>>>>>>>>>>>>        Property Integer Private.Simple_State False
23466>>>>>>>>>>>>>>>>>>>        
23466>>>>>>>>>>>>>>>>>>>        Property String  Private.Simple_Value ''
23467>>>>>>>>>>>>>>>>>>>        
23467>>>>>>>>>>>>>>>>>>>        Property Integer Tooltips_State False // this does nothing
23468>>>>>>>>>>>>>>>>>>>        Set Scroll_Bar_Visible_State to False
23469>>>>>>>>>>>>>>>>>>>        Set Border_Style             to Border_None
23470>>>>>>>>>>>>>>>>>>>        Set External_class_Name "cObsoleteBasicStatusBar" to "msctls_statusbar32"
23471>>>>>>>>>>>>>>>>>>>        Set Color to clDefault
23472>>>>>>>>>>>>>>>>>>>    End_Procedure
23473>>>>>>>>>>>>>>>>>>>    
23473>>>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
23475>>>>>>>>>>>>>>>>>>>        //If (Tooltips_State(self)) Set Window_Style To SBT_TOOLTIPS True
23475>>>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
23477>>>>>>>>>>>>>>>>>>>    End_Procedure
23478>>>>>>>>>>>>>>>>>>>    
23478>>>>>>>>>>>>>>>>>>>    Procedure Set Simple_State Integer bState
23480>>>>>>>>>>>>>>>>>>>        Handle hWnd
23480>>>>>>>>>>>>>>>>>>>        Set Private.Simple_state to bState
23481>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23482>>>>>>>>>>>>>>>>>>>        If hWnd ;            Send Windows_Message SB_SIMPLE bState 0
23485>>>>>>>>>>>>>>>>>>>    End_Procedure
23486>>>>>>>>>>>>>>>>>>>    
23486>>>>>>>>>>>>>>>>>>>    Function Simple_State Returns Integer
23488>>>>>>>>>>>>>>>>>>>        Function_Return (Private.Simple_state(Self))
23489>>>>>>>>>>>>>>>>>>>    End_Function
23490>>>>>>>>>>>>>>>>>>>    
23490>>>>>>>>>>>>>>>>>>>    Procedure Set Simple_Value String sValue
23492>>>>>>>>>>>>>>>>>>>        Integer iVoid
23492>>>>>>>>>>>>>>>>>>>        Handle hWnd
23492>>>>>>>>>>>>>>>>>>>        WString wsValue
23492>>>>>>>>>>>>>>>>>>>        
23492>>>>>>>>>>>>>>>>>>>        Set Private.Simple_Value to sValue
23493>>>>>>>>>>>>>>>>>>>        
23493>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23494>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23496>>>>>>>>>>>>>>>>>>>            Append sValue ( Character(0) )
23497>>>>>>>>>>>>>>>>>>>            Move sValue to wsValue
23498>>>>>>>>>>>>>>>>>>>            
23498>>>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SETTEXT (255 + sbNORMAL) (AddressOf(wsValue))
23499>>>>>>>>>>>>>>>>>>>        End
23499>>>>>>>>>>>>>>>>>>>>
23499>>>>>>>>>>>>>>>>>>>        Set Simple_State to True
23500>>>>>>>>>>>>>>>>>>>    End_Procedure
23501>>>>>>>>>>>>>>>>>>>    
23501>>>>>>>>>>>>>>>>>>>    Function Simple_Value Returns String
23503>>>>>>>>>>>>>>>>>>>        Function_Return (private.Simple_value(Self))
23504>>>>>>>>>>>>>>>>>>>    End_Function
23505>>>>>>>>>>>>>>>>>>>    
23505>>>>>>>>>>>>>>>>>>>    Procedure Activate
23507>>>>>>>>>>>>>>>>>>>    End_Procedure
23508>>>>>>>>>>>>>>>>>>>    
23508>>>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer iState
23510>>>>>>>>>>>>>>>>>>>        Handle hWnd
23510>>>>>>>>>>>>>>>>>>>        Get Window_handle to hWnd
23511>>>>>>>>>>>>>>>>>>>        Forward Send Page_Object iState
23513>>>>>>>>>>>>>>>>>>>        If (iState and hWnd = 0) ;            Send DoRestructure
23516>>>>>>>>>>>>>>>>>>>    End_Procedure
23517>>>>>>>>>>>>>>>>>>>    
23517>>>>>>>>>>>>>>>>>>>    Procedure Page Integer iState
23519>>>>>>>>>>>>>>>>>>>        Forward Send Page iState
23521>>>>>>>>>>>>>>>>>>>        If (iState=1) Begin
23523>>>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SETBKCOLOR 0 (Color(Self))
23524>>>>>>>>>>>>>>>>>>>        End
23524>>>>>>>>>>>>>>>>>>>>
23524>>>>>>>>>>>>>>>>>>>    End_Procedure
23525>>>>>>>>>>>>>>>>>>>    
23525>>>>>>>>>>>>>>>>>>>    Procedure DoRestructure
23527>>>>>>>>>>>>>>>>>>>        Integer iLoop icItems iWidth icWidth iRetVal
23527>>>>>>>>>>>>>>>>>>>        Handle hWnd
23527>>>>>>>>>>>>>>>>>>>        Integer[] aItems
23528>>>>>>>>>>>>>>>>>>>        
23528>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23529>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23531>>>>>>>>>>>>>>>>>>>            
23531>>>>>>>>>>>>>>>>>>>            Send Windows_Message SB_SIMPLE (Simple_State(Self)) 0
23532>>>>>>>>>>>>>>>>>>>            Set Simple_Value to (Simple_Value(Self))
23533>>>>>>>>>>>>>>>>>>>            
23533>>>>>>>>>>>>>>>>>>>            Get Item_Count to icItems
23534>>>>>>>>>>>>>>>>>>>            
23534>>>>>>>>>>>>>>>>>>>            For iLoop from 1 to (icItems -1)
23540>>>>>>>>>>>>>>>>>>>>
23540>>>>>>>>>>>>>>>>>>>                Get Message (iLoop -1) to iWidth
23541>>>>>>>>>>>>>>>>>>>                Move (icWidth + iWidth) to icWidth
23542>>>>>>>>>>>>>>>>>>>                Move (icWidth) to aItems[iLoop - 1]
23543>>>>>>>>>>>>>>>>>>>                
23543>>>>>>>>>>>>>>>>>>>                Set Value (iLoop -1) to (Value(Self, iLoop -1))
23544>>>>>>>>>>>>>>>>>>>            Loop
23545>>>>>>>>>>>>>>>>>>>>
23545>>>>>>>>>>>>>>>>>>>            // Now make the last item 'spring' to the end
23545>>>>>>>>>>>>>>>>>>>            Move -1 to aItems[icItems - 1]
23546>>>>>>>>>>>>>>>>>>>                        
23546>>>>>>>>>>>>>>>>>>>            Move (SendMessage(hWnd, SB_SETPARTS, icItems, AddressOf(aItems))) to iRetVal
23547>>>>>>>>>>>>>>>>>>>            For iLoop from 0 to (icItems -1)
23553>>>>>>>>>>>>>>>>>>>>
23553>>>>>>>>>>>>>>>>>>>                Set Value iLoop to (Value(Self, iLoop))
23554>>>>>>>>>>>>>>>>>>>            Loop
23555>>>>>>>>>>>>>>>>>>>>
23555>>>>>>>>>>>>>>>>>>>            
23555>>>>>>>>>>>>>>>>>>>        End
23555>>>>>>>>>>>>>>>>>>>>
23555>>>>>>>>>>>>>>>>>>>    End_Procedure
23556>>>>>>>>>>>>>>>>>>>    
23556>>>>>>>>>>>>>>>>>>>    Procedure Add_Item Integer iItemWidth String sValue // this is obsolete
23558>>>>>>>>>>>>>>>>>>>        Integer iRetVal icItems
23558>>>>>>>>>>>>>>>>>>>        Handle hWnd
23558>>>>>>>>>>>>>>>>>>>        
23558>>>>>>>>>>>>>>>>>>>        Forward Send Add_Item iItemWidth sValue
23560>>>>>>>>>>>>>>>>>>>        Get Item_Count to icItems
23561>>>>>>>>>>>>>>>>>>>        Set Value (icItems -1) to sValue
23562>>>>>>>>>>>>>>>>>>>        If (Window_Handle(Self)) ;            Send DoRestructure
23565>>>>>>>>>>>>>>>>>>>        Set Current_item to (icItems -1)
23566>>>>>>>>>>>>>>>>>>>    End_Procedure
23567>>>>>>>>>>>>>>>>>>>    
23567>>>>>>>>>>>>>>>>>>>    Procedure AddPane Integer iItemWidth String sValue Integer iStyle
23569>>>>>>>>>>>>>>>>>>>        Integer iRetVal icItem
23569>>>>>>>>>>>>>>>>>>>        Handle hWnd
23569>>>>>>>>>>>>>>>>>>>        
23569>>>>>>>>>>>>>>>>>>>        Send Add_Item iItemWidth sValue
23570>>>>>>>>>>>>>>>>>>>        Get Item_Count to icItem
23571>>>>>>>>>>>>>>>>>>>        Set Value (icItem -1) to sValue
23572>>>>>>>>>>>>>>>>>>>        Set Aux_Value (icItem -1) to iStyle
23573>>>>>>>>>>>>>>>>>>>        If (Window_Handle(Self)) ;            Send DoRestructure
23576>>>>>>>>>>>>>>>>>>>    End_Procedure
23577>>>>>>>>>>>>>>>>>>>    
23577>>>>>>>>>>>>>>>>>>>    Procedure AutoSizeLocate
23579>>>>>>>>>>>>>>>>>>>        Integer iSize iRetVal
23579>>>>>>>>>>>>>>>>>>>        Handle hWnd
23579>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23580>>>>>>>>>>>>>>>>>>>        Delegate Get GuiSize to iSize
23582>>>>>>>>>>>>>>>>>>>        If hWnd ;            Move (SendMessage(hWnd, WM_SIZE, 0, iSize)) to iRetVal
23585>>>>>>>>>>>>>>>>>>>    End_Procedure
23586>>>>>>>>>>>>>>>>>>>    
23586>>>>>>>>>>>>>>>>>>>    Procedure Set Item_Display_Style Integer iItem Integer iStyle  // this is obsolete, Use PaneStyle
23588>>>>>>>>>>>>>>>>>>>        If (num_arguments = 2) ;            Set Aux_Value iItem to iStyle
23591>>>>>>>>>>>>>>>>>>>        Else ;            Set Aux_Value (current_item(Self)) to iItem //iStyle passed as arg1
23593>>>>>>>>>>>>>>>>>>>    End_Procedure
23594>>>>>>>>>>>>>>>>>>>    
23594>>>>>>>>>>>>>>>>>>>    Function Item_Display_Style Integer iItem Returns Integer // this is obsolete, use PaneStyle
23596>>>>>>>>>>>>>>>>>>>        Function_Return (Aux_value(Self, iItem))
23597>>>>>>>>>>>>>>>>>>>    End_Function
23598>>>>>>>>>>>>>>>>>>>    
23598>>>>>>>>>>>>>>>>>>>    Procedure Set Value Integer iItem String sValue
23600>>>>>>>>>>>>>>>>>>>        Handle hWnd
23600>>>>>>>>>>>>>>>>>>>        Integer iRetVal iTextStyle iVoid
23600>>>>>>>>>>>>>>>>>>>        String sNull
23600>>>>>>>>>>>>>>>>>>>        WString wsValue
23600>>>>>>>>>>>>>>>>>>>        
23600>>>>>>>>>>>>>>>>>>>        Forward Set Value iItem to sValue
23602>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23603>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23605>>>>>>>>>>>>>>>>>>>            Get Item_Display_Style iItem to iTextStyle
23606>>>>>>>>>>>>>>>>>>>            Append sValue ( Character(0) )
23607>>>>>>>>>>>>>>>>>>>            Move sValue to wsValue
23608>>>>>>>>>>>>>>>>>>>            Move (SendMessage(hWnd, SB_SETTEXT, iItem + iTextStyle, AddressOf(wsValue))) to iRetVal
23609>>>>>>>>>>>>>>>>>>>        End
23609>>>>>>>>>>>>>>>>>>>>
23609>>>>>>>>>>>>>>>>>>>        Set Simple_State to False
23610>>>>>>>>>>>>>>>>>>>    End_Procedure
23611>>>>>>>>>>>>>>>>>>>    
23611>>>>>>>>>>>>>>>>>>>    Function IsSimpleMode Returns Integer
23613>>>>>>>>>>>>>>>>>>>        Function_Return (WindowsMessage(SB_ISSIMPLE, 0, 0))
23614>>>>>>>>>>>>>>>>>>>    End_Function
23615>>>>>>>>>>>>>>>>>>>    
23615>>>>>>>>>>>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
23617>>>>>>>>>>>>>>>>>>>        Integer iVoid iCode
23617>>>>>>>>>>>>>>>>>>>        Longptr iPane
23617>>>>>>>>>>>>>>>>>>>        tWinNmMouse NmMouse
23617>>>>>>>>>>>>>>>>>>>        tWinNmMouse NmMouse
23617>>>>>>>>>>>>>>>>>>>        
23617>>>>>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(NmMouse), lParam, SizeOfType(tWinNmMouse))) to iVoid
23618>>>>>>>>>>>>>>>>>>>        
23618>>>>>>>>>>>>>>>>>>>        Move NmMouse.hdr.code   to iCode
23619>>>>>>>>>>>>>>>>>>>        Move NmMouse.dwItemSpec to iPane
23620>>>>>>>>>>>>>>>>>>>        
23620>>>>>>>>>>>>>>>>>>>        If (iCode = SBN_SIMPLEMODECHANGE) ;            Send OnSimpleModeChange
23623>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_CLICK) ;            Send OnClick            iPane
23627>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_DBLCLK) ;            Send OnDoubleClick      iPane
23631>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_RCLICK) ;            Send OnRightClick       iPane
23635>>>>>>>>>>>>>>>>>>>        Else If (iCode = NM_RDBLCLK) ;            Send OnDoubleRightClick iPane
23639>>>>>>>>>>>>>>>>>>>    End_Procedure
23640>>>>>>>>>>>>>>>>>>>    
23640>>>>>>>>>>>>>>>>>>>    //  This needs to be chagned to return the real GUISize of the status bar
23640>>>>>>>>>>>>>>>>>>>    //  by making API calls.
23640>>>>>>>>>>>>>>>>>>>    //
23640>>>>>>>>>>>>>>>>>>>    Function GuiSize Returns Integer
23642>>>>>>>>>>>>>>>>>>>        Handle hWnd
23642>>>>>>>>>>>>>>>>>>>        Integer cy cx iVoid
23642>>>>>>>>>>>>>>>>>>>        tWinRect Rect
23642>>>>>>>>>>>>>>>>>>>        tWinRect Rect
23642>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23643>>>>>>>>>>>>>>>>>>>        If hWnd Begin
23645>>>>>>>>>>>>>>>>>>>            Move (GetWindowRect(hWnd, AddressOf(Rect))) to iVoid
23646>>>>>>>>>>>>>>>>>>>            Move (Rect.right - Rect.left) to cx
23647>>>>>>>>>>>>>>>>>>>            Move (Rect.bottom - Rect.top) to cy
23648>>>>>>>>>>>>>>>>>>>        End
23648>>>>>>>>>>>>>>>>>>>>
23648>>>>>>>>>>>>>>>>>>>        Else Begin
23649>>>>>>>>>>>>>>>>>>>            Move 25 to cy
23650>>>>>>>>>>>>>>>>>>>            Move 19 to cx
23651>>>>>>>>>>>>>>>>>>>        End
23651>>>>>>>>>>>>>>>>>>>>
23651>>>>>>>>>>>>>>>>>>>        Function_Return ( cy*65536 + cx )
23652>>>>>>>>>>>>>>>>>>>    End_Function
23653>>>>>>>>>>>>>>>>>>>    
23653>>>>>>>>>>>>>>>>>>>    Function PaneTextWidth WString sText Returns Integer
23655>>>>>>>>>>>>>>>>>>>        Handle hWnd hDC
23655>>>>>>>>>>>>>>>>>>>        Integer bOK
23655>>>>>>>>>>>>>>>>>>>        tWinPoint Point
23655>>>>>>>>>>>>>>>>>>>        tWinPoint Point
23655>>>>>>>>>>>>>>>>>>>        
23655>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23656>>>>>>>>>>>>>>>>>>>        Move (GetDC(hWnd)) to hDC
23657>>>>>>>>>>>>>>>>>>>        
23657>>>>>>>>>>>>>>>>>>>        Move (GetTextExtentW(hDC, AddressOf(sText), length(sText), AddressOf(Point))) to bOk
23658>>>>>>>>>>>>>>>>>>>        
23658>>>>>>>>>>>>>>>>>>>        Move (ReleaseDC(hWnd, hDC)) to hDC
23659>>>>>>>>>>>>>>>>>>>        
23659>>>>>>>>>>>>>>>>>>>        Function_Return Point.x
23660>>>>>>>>>>>>>>>>>>>    End_Function
23661>>>>>>>>>>>>>>>>>>>    
23661>>>>>>>>>>>>>>>>>>>    Procedure Set PaneWidth Integer iPane Integer cxPane
23663>>>>>>>>>>>>>>>>>>>        Set Message iPane to cxPane
23664>>>>>>>>>>>>>>>>>>>    End_Procedure
23665>>>>>>>>>>>>>>>>>>>    
23665>>>>>>>>>>>>>>>>>>>    Function PaneWidth Integer iPane Returns Integer
23667>>>>>>>>>>>>>>>>>>>        Function_Return (Message(Self,iPane))
23668>>>>>>>>>>>>>>>>>>>    End_Function
23669>>>>>>>>>>>>>>>>>>>    
23669>>>>>>>>>>>>>>>>>>>    Procedure Set PaneStyle Integer iPane Integer iStyle
23671>>>>>>>>>>>>>>>>>>>        Set Aux_Value iPane to iStyle
23672>>>>>>>>>>>>>>>>>>>    End_Procedure
23673>>>>>>>>>>>>>>>>>>>    
23673>>>>>>>>>>>>>>>>>>>    Function PaneStyle Integer iPane Returns Integer
23675>>>>>>>>>>>>>>>>>>>        Function_Return (Aux_Value(Self,iPane))
23676>>>>>>>>>>>>>>>>>>>    End_Function
23677>>>>>>>>>>>>>>>>>>>    
23677>>>>>>>>>>>>>>>>>>>    Procedure Set PaneText Integer iPane String sText
23679>>>>>>>>>>>>>>>>>>>        Set Value iPane to sText
23680>>>>>>>>>>>>>>>>>>>    End_Procedure
23681>>>>>>>>>>>>>>>>>>>    
23681>>>>>>>>>>>>>>>>>>>    Function PaneText Integer iPane Returns String
23683>>>>>>>>>>>>>>>>>>>        Function_Return (Value(Self,iPane))
23684>>>>>>>>>>>>>>>>>>>    End_Function
23685>>>>>>>>>>>>>>>>>>>    
23685>>>>>>>>>>>>>>>>>>>    Function PaneCount Returns Integer
23687>>>>>>>>>>>>>>>>>>>        Function_Return (Item_Count(Self))
23688>>>>>>>>>>>>>>>>>>>    End_Function
23689>>>>>>>>>>>>>>>>>>>    
23689>>>>>>>>>>>>>>>>>>>    Procedure OnClick Longptr iPane
23691>>>>>>>>>>>>>>>>>>>    End_Procedure
23692>>>>>>>>>>>>>>>>>>>    
23692>>>>>>>>>>>>>>>>>>>    Procedure OnDoubleClick Longptr iPane
23694>>>>>>>>>>>>>>>>>>>    End_Procedure
23695>>>>>>>>>>>>>>>>>>>    
23695>>>>>>>>>>>>>>>>>>>    Procedure OnRightClick Longptr iPane
23697>>>>>>>>>>>>>>>>>>>    End_Procedure
23698>>>>>>>>>>>>>>>>>>>    
23698>>>>>>>>>>>>>>>>>>>    Procedure OnDoubleRightClick Longptr iPane
23700>>>>>>>>>>>>>>>>>>>    End_Procedure
23701>>>>>>>>>>>>>>>>>>>    
23701>>>>>>>>>>>>>>>>>>>    Procedure OnSimpleModeChange
23703>>>>>>>>>>>>>>>>>>>    End_Procedure
23704>>>>>>>>>>>>>>>>>>>End_Class
23705>>>>>>>>>>>>>>>>>>>
23705>>>>>>>>>>>>>>>>>
23705>>>>>>>>>>>>>>>>>Class AppStatusBar is a BasicStatusBar
23706>>>>>>>>>>>>>>>>>    
23706>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23708>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23710>>>>>>>>>>>>>>>>>        Property Integer Status_Help_Item 0
23711>>>>>>>>>>>>>>>>>        Property Integer Menu_Simple_State TRUE
23712>>>>>>>>>>>>>>>>>        
23712>>>>>>>>>>>>>>>>>        // SET s/b private, Get is public
23712>>>>>>>>>>>>>>>>>        Property Integer Menu_status_State False // MUST start false
23713>>>>>>>>>>>>>>>>>        
23713>>>>>>>>>>>>>>>>>        Property Integer Old_Simple_State  false
23714>>>>>>>>>>>>>>>>>        
23714>>>>>>>>>>>>>>>>>        Property String  Old_Status_Value  ''
23715>>>>>>>>>>>>>>>>>        
23715>>>>>>>>>>>>>>>>>        Set Popup_State         To TRUE
23716>>>>>>>>>>>>>>>>>        Set Attach_Parent_State To TRUE
23717>>>>>>>>>>>>>>>>>        // register status-bar with container
23717>>>>>>>>>>>>>>>>>        Delegate Set StatusBar_id To self
23719>>>>>>>>>>>>>>>>>    End_Procedure
23720>>>>>>>>>>>>>>>>>    
23720>>>>>>>>>>>>>>>>>    Procedure Set Status_Help_Value String sHelp
23722>>>>>>>>>>>>>>>>>        Integer iPart
23722>>>>>>>>>>>>>>>>>        Get Status_Help_Item To iPart
23723>>>>>>>>>>>>>>>>>        Set Value iPart to sHelp
23724>>>>>>>>>>>>>>>>>    End_Procedure
23725>>>>>>>>>>>>>>>>>    
23725>>>>>>>>>>>>>>>>>    Function Status_Help_Value Returns String
23727>>>>>>>>>>>>>>>>>        Integer iPart
23727>>>>>>>>>>>>>>>>>        String sHelp
23727>>>>>>>>>>>>>>>>>        Get Status_Help_Item To iPart
23728>>>>>>>>>>>>>>>>>        Get Value iPart To sHelp
23729>>>>>>>>>>>>>>>>>        Function_Return sHelp
23730>>>>>>>>>>>>>>>>>    End_Procedure
23731>>>>>>>>>>>>>>>>>    
23731>>>>>>>>>>>>>>>>>    Procedure Initialize_Menu
23733>>>>>>>>>>>>>>>>>        Integer iState OldState
23733>>>>>>>>>>>>>>>>>        If Not (Menu_Status_state(self)) Begin
23735>>>>>>>>>>>>>>>>>            Get Simple_State to OldState
23736>>>>>>>>>>>>>>>>>            Set Old_Simple_State to OldState
23737>>>>>>>>>>>>>>>>>            If OldState ;                Set Old_Status_Value to (Simple_Value(self))
23740>>>>>>>>>>>>>>>>>            Else ;                Set Old_Status_Value to (Status_Help_Value(self))
23742>>>>>>>>>>>>>>>>>            Set Simple_State to (Menu_Simple_State(self))
23743>>>>>>>>>>>>>>>>>            Set Menu_Status_State to TRUE
23744>>>>>>>>>>>>>>>>>        End
23744>>>>>>>>>>>>>>>>>>
23744>>>>>>>>>>>>>>>>>    End_Procedure
23745>>>>>>>>>>>>>>>>>    
23745>>>>>>>>>>>>>>>>>    Procedure Exit_Menu
23747>>>>>>>>>>>>>>>>>        Integer OldState
23747>>>>>>>>>>>>>>>>>        String OldVal
23747>>>>>>>>>>>>>>>>>        If (Menu_Status_state(self)) Begin
23749>>>>>>>>>>>>>>>>>            Get Old_Simple_State to OldState
23750>>>>>>>>>>>>>>>>>            Set Simple_State     to OldState
23751>>>>>>>>>>>>>>>>>            Get old_status_Value to oldVal
23752>>>>>>>>>>>>>>>>>            If OldState ;                Set Simple_Value to OldVal
23755>>>>>>>>>>>>>>>>>            Else ;                Set Status_Help_Value to OldVal
23757>>>>>>>>>>>>>>>>>            Set Menu_Status_State to FALSE
23758>>>>>>>>>>>>>>>>>        End
23758>>>>>>>>>>>>>>>>>>
23758>>>>>>>>>>>>>>>>>    End_Procedure
23759>>>>>>>>>>>>>>>>>    
23759>>>>>>>>>>>>>>>>>    Procedure Show_Status_Help String sHelp
23761>>>>>>>>>>>>>>>>>        Integer iState
23761>>>>>>>>>>>>>>>>>        Get Simple_State to iState
23762>>>>>>>>>>>>>>>>>        If not iState ;            Set Status_Help_Value to sHelp
23765>>>>>>>>>>>>>>>>>        Else ;            Set Simple_Value      to sHelp
23767>>>>>>>>>>>>>>>>>    End_Procedure
23768>>>>>>>>>>>>>>>>>    
23768>>>>>>>>>>>>>>>>>    Function Current_Status_Help Returns String
23770>>>>>>>>>>>>>>>>>        Integer iState
23770>>>>>>>>>>>>>>>>>        String sHelp
23770>>>>>>>>>>>>>>>>>        Get Simple_State to iState
23771>>>>>>>>>>>>>>>>>        If not iState ;            Get Status_Help_Value to sHelp
23774>>>>>>>>>>>>>>>>>        Else ;            Get Simple_Value      to sHelp
23776>>>>>>>>>>>>>>>>>        Function_Return sHelp
23777>>>>>>>>>>>>>>>>>    End_Function
23778>>>>>>>>>>>>>>>>>    
23778>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer bShow
23780>>>>>>>>>>>>>>>>>        Integer hoClient
23780>>>>>>>>>>>>>>>>>        Handle hHndl
23780>>>>>>>>>>>>>>>>>        Get Window_Handle to hHndl
23781>>>>>>>>>>>>>>>>>        Forward Send Page_Object bShow
23783>>>>>>>>>>>>>>>>>        If (bShow AND hHndl=0) Begin
23785>>>>>>>>>>>>>>>>>            Delegate Get Client_Id To hoClient
23787>>>>>>>>>>>>>>>>>            If hoClient ;                Send Add_Border_Object to hoClient self amBOTTOM
23790>>>>>>>>>>>>>>>>>        End
23790>>>>>>>>>>>>>>>>>>
23790>>>>>>>>>>>>>>>>>    End_Procedure
23791>>>>>>>>>>>>>>>>>    
23791>>>>>>>>>>>>>>>>>    Procedure Deactivating
23793>>>>>>>>>>>>>>>>>        Integer hoClient
23793>>>>>>>>>>>>>>>>>        Delegate Get Client_Id To hoClient
23795>>>>>>>>>>>>>>>>>        Forward Send DeActivating
23797>>>>>>>>>>>>>>>>>        If hoClient ;            Send Remove_Border_Object to hoClient self amBOTTOM
23800>>>>>>>>>>>>>>>>>    End_Procedure
23801>>>>>>>>>>>>>>>>>    
23801>>>>>>>>>>>>>>>>>End_Class
23802>>>>>>>>>>>>>>>Use DFABtBar.pkg  // df application button bar
Including file: Dfabtbar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfabtbar.pkg)
23802>>>>>>>>>>>>>>>>>Register_Procedure Add_Border_Object
23802>>>>>>>>>>>>>>>>>Register_Procedure Remove_Border_Object
23802>>>>>>>>>>>>>>>>>
23802>>>>>>>>>>>>>>>>>Use Windows.pkg
23802>>>>>>>>>>>>>>>>>
23802>>>>>>>>>>>>>>>>>Class AppToolBar is a BasicToolBar
23803>>>>>>>>>>>>>>>>>    
23803>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23805>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23807>>>>>>>>>>>>>>>>>        Set Scope_State         to True
23808>>>>>>>>>>>>>>>>>        Set Attach_Parent_State to True
23809>>>>>>>>>>>>>>>>>        Set Popup_State         to True
23810>>>>>>>>>>>>>>>>>        Set Client_Area_State   to True
23811>>>>>>>>>>>>>>>>>        Delegate Set ToolBar_Id to Self
23813>>>>>>>>>>>>>>>>>    End_Procedure
23814>>>>>>>>>>>>>>>>>    
23814>>>>>>>>>>>>>>>>>    Procedure Page Integer bState
23816>>>>>>>>>>>>>>>>>        Integer hoClient
23816>>>>>>>>>>>>>>>>>        Handle  hWnd
23816>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
23817>>>>>>>>>>>>>>>>>        Forward Send Page bState
23819>>>>>>>>>>>>>>>>>        If (bState=1 and hWnd=0) Begin
23821>>>>>>>>>>>>>>>>>            Delegate Get Client_Id to hoClient
23823>>>>>>>>>>>>>>>>>            If hoClient ;                Send Add_Border_Object to hoClient Self amTOP
23826>>>>>>>>>>>>>>>>>        End
23826>>>>>>>>>>>>>>>>>>
23826>>>>>>>>>>>>>>>>>    End_Procedure
23827>>>>>>>>>>>>>>>>>    
23827>>>>>>>>>>>>>>>>>    Procedure Deactivating
23829>>>>>>>>>>>>>>>>>        Integer hoClient
23829>>>>>>>>>>>>>>>>>        Forward Send DeActivating
23831>>>>>>>>>>>>>>>>>        Delegate Get Client_Id to hoClient
23833>>>>>>>>>>>>>>>>>        If hoClient Begin
23835>>>>>>>>>>>>>>>>>            Send Remove_Border_Object to hoClient Self amTOP
23836>>>>>>>>>>>>>>>>>        End
23836>>>>>>>>>>>>>>>>>>
23836>>>>>>>>>>>>>>>>>    End_Procedure
23837>>>>>>>>>>>>>>>>>    
23837>>>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
23839>>>>>>>>>>>>>>>>>        Forward Set GuiSize to cy cx
23841>>>>>>>>>>>>>>>>>    End_Procedure
23842>>>>>>>>>>>>>>>>>    
23842>>>>>>>>>>>>>>>>>    // Container_Handle:
23842>>>>>>>>>>>>>>>>>    // JvH: - This function was put in to allow support for combo-form & other
23842>>>>>>>>>>>>>>>>>    // controls in the toolbar.
23842>>>>>>>>>>>>>>>>>    Function Container_Handle Returns Handle
23844>>>>>>>>>>>>>>>>>        Function_Return (window_handle(Self))
23845>>>>>>>>>>>>>>>>>    End_Function
23846>>>>>>>>>>>>>>>>>End_Class
23847>>>>>>>>>>>>>>>>>
23847>>>>>>>>>>>>>>>Use DFAClnt.pkg   // df application Client
Including file: Dfaclnt.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfaclnt.pkg)
23847>>>>>>>>>>>>>>>>>Use Windows.pkg
23847>>>>>>>>>>>>>>>>>Use Set.pkg
Including file: set.pkg    (C:\Program Files\DataFlex 24.0\Pkg\set.pkg)
23847>>>>>>>>>>>>>>>>>>>Use VDFBase.pkg
23847>>>>>>>>>>>>>>>>>>>
23847>>>>>>>>>>>>>>>>>>>Class Set is an ARRAY
23848>>>>>>>>>>>>>>>>>>>    
23848>>>>>>>>>>>>>>>>>>>    Function Find_Element String ElemStr Returns Integer
23850>>>>>>>>>>>>>>>>>>>        Integer ndx retVal ArrMax
23850>>>>>>>>>>>>>>>>>>>        String ArrVal
23850>>>>>>>>>>>>>>>>>>>        Get item_count to ArrMax
23851>>>>>>>>>>>>>>>>>>>        Move -1 to retVal
23852>>>>>>>>>>>>>>>>>>>        Move 0 to ndx
23853>>>>>>>>>>>>>>>>>>>        While (ndx < ArrMax and retVal = -1)
23857>>>>>>>>>>>>>>>>>>>            Get array_value  ndx to ArrVal
23858>>>>>>>>>>>>>>>>>>>            If (ArrVal = ElemStr) ;                Move ndx to retVal
23861>>>>>>>>>>>>>>>>>>>            Move (ndx + 1) to ndx
23862>>>>>>>>>>>>>>>>>>>        loop
23863>>>>>>>>>>>>>>>>>>>>
23863>>>>>>>>>>>>>>>>>>>        Function_Return retVal
23864>>>>>>>>>>>>>>>>>>>    End_Function
23865>>>>>>>>>>>>>>>>>>>    
23865>>>>>>>>>>>>>>>>>>>    Procedure Add_Element String Elem_Str Returns Integer
23867>>>>>>>>>>>>>>>>>>>        Integer Ret_Val
23867>>>>>>>>>>>>>>>>>>>        
23867>>>>>>>>>>>>>>>>>>>        Get Find_Element Elem_Str to Ret_Val
23868>>>>>>>>>>>>>>>>>>>        
23868>>>>>>>>>>>>>>>>>>>        If (Ret_Val < 0) ;            Get Item_Count to Ret_Val
23871>>>>>>>>>>>>>>>>>>>        
23871>>>>>>>>>>>>>>>>>>>        Set Array_Value  Ret_Val to Elem_Str
23872>>>>>>>>>>>>>>>>>>>        
23872>>>>>>>>>>>>>>>>>>>        Procedure_Return Ret_Val
23873>>>>>>>>>>>>>>>>>>>    End_Procedure
23874>>>>>>>>>>>>>>>>>>>    
23874>>>>>>>>>>>>>>>>>>>    Procedure Remove_Element String sElement
23876>>>>>>>>>>>>>>>>>>>        Integer iIndex
23876>>>>>>>>>>>>>>>>>>>        Get Find_Element sElement to iIndex
23877>>>>>>>>>>>>>>>>>>>        If (iIndex > -1) ;            Send delete_item iIndex
23880>>>>>>>>>>>>>>>>>>>    End_Procedure
23881>>>>>>>>>>>>>>>>>>>    
23881>>>>>>>>>>>>>>>>>>>    
23881>>>>>>>>>>>>>>>>>>>End_Class
23882>>>>>>>>>>>>>>>>>>>
23882>>>>>>>>>>>>>>>>>>>//
23882>>>>>>>>>>>>>>>>>>>// global function to create set instances at random
23882>>>>>>>>>>>>>>>>>>>//
23882>>>>>>>>>>>>>>>>>>>Function make_set for cDesktop Returns Integer
23884>>>>>>>>>>>>>>>>>>>    Integer retval
23884>>>>>>>>>>>>>>>>>>>    Object SetTemplate is a Set
23886>>>>>>>>>>>>>>>>>>>        Move Self to retval
23887>>>>>>>>>>>>>>>>>>>    End_Object
23888>>>>>>>>>>>>>>>>>>>    Function_Return retval
23889>>>>>>>>>>>>>>>>>>>End_Function
23890>>>>>>>>>>>>>>>>>>>
23890>>>>>>>>>>>>>>>>>>>
23890>>>>>>>>>>>>>>>>>>>
23890>>>>>>>>>>>>>>>>>Use Dfpanel.pkg
23890>>>>>>>>>>>>>>>>>
23890>>>>>>>>>>>>>>>>>Class AppClientArea is a MdiClientArea
23891>>>>>>>>>>>>>>>>>    
23891>>>>>>>>>>>>>>>>>    Procedure Construct_Object
23893>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
23895>>>>>>>>>>>>>>>>>        
23895>>>>>>>>>>>>>>>>>        Property Integer Auto_Arrange_Icons_State True
23896>>>>>>>>>>>>>>>>>        
23896>>>>>>>>>>>>>>>>>        Property Integer Private.Client_Scrollbar_State   True
23897>>>>>>>>>>>>>>>>>        
23897>>>>>>>>>>>>>>>>>        Delegate Set Client_Id to Self
23899>>>>>>>>>>>>>>>>>        // keep track of all child dialog objects (views)
23899>>>>>>>>>>>>>>>>>        
23899>>>>>>>>>>>>>>>>>        Object Mdi_Dialogs is a Set
23901>>>>>>>>>>>>>>>>>        End_Object
23902>>>>>>>>>>>>>>>>>        
23902>>>>>>>>>>>>>>>>>        Property Integer Private.Last_Dialog_Item -1
23903>>>>>>>>>>>>>>>>>    End_Procedure
23904>>>>>>>>>>>>>>>>>    
23904>>>>>>>>>>>>>>>>>    Procedure Set Client_Scrollbar_State Integer bState
23906>>>>>>>>>>>>>>>>>        Set Scroll_bar_Visible_State to bState
23907>>>>>>>>>>>>>>>>>        Set Private.Client_Scrollbar_State to bState
23908>>>>>>>>>>>>>>>>>    End_Procedure
23909>>>>>>>>>>>>>>>>>    
23909>>>>>>>>>>>>>>>>>    Function Client_Scrollbar_State Returns Integer
23911>>>>>>>>>>>>>>>>>        Function_Return (Private.Client_Scrollbar_State(Self))
23912>>>>>>>>>>>>>>>>>    End_Function
23913>>>>>>>>>>>>>>>>>    
23913>>>>>>>>>>>>>>>>>    Procedure Add_Mdi_Dialog Integer Id#
23915>>>>>>>>>>>>>>>>>        Send Add_element to (mdi_dialogs(Self)) Id#
23916>>>>>>>>>>>>>>>>>    End_Procedure
23917>>>>>>>>>>>>>>>>>    
23917>>>>>>>>>>>>>>>>>    Procedure Remove_Mdi_Dialog Integer Id#
23919>>>>>>>>>>>>>>>>>        Integer obj#
23919>>>>>>>>>>>>>>>>>        Move (mdi_dialogs(Self)) to Obj#
23920>>>>>>>>>>>>>>>>>        If Obj# ;            Send Remove_element to (mdi_dialogs(Obj#)) Id#
23923>>>>>>>>>>>>>>>>>    End_Procedure
23924>>>>>>>>>>>>>>>>>    
23924>>>>>>>>>>>>>>>>>    Function Next_Mdi_Dialog Integer FindFirst Returns Integer
23926>>>>>>>>>>>>>>>>>        Integer Id# Item# Obj#
23926>>>>>>>>>>>>>>>>>        Get Private.Last_dialog_item to Item#
23927>>>>>>>>>>>>>>>>>        If FindFirst ;            Move -1 to Item#
23930>>>>>>>>>>>>>>>>>        Increment Item#
23931>>>>>>>>>>>>>>>>>        Set Private.Last_dialog_item to Item#
23932>>>>>>>>>>>>>>>>>        Move (Mdi_dialogs(Self)) to Obj#
23933>>>>>>>>>>>>>>>>>        If (Item_count(Obj#)>Item#) ;            Get Value of Obj# Item# to Id#
23936>>>>>>>>>>>>>>>>>        Function_Return Id#
23937>>>>>>>>>>>>>>>>>    End_Function
23938>>>>>>>>>>>>>>>>>    
23938>>>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer cy Integer cx
23940>>>>>>>>>>>>>>>>>        Forward Set GuiSize to cy cx
23942>>>>>>>>>>>>>>>>>        If (active_state(Self) and Auto_Arrange_Icons_State(Self)) ;            Send Arrange_icons
23945>>>>>>>>>>>>>>>>>    End_Procedure
23946>>>>>>>>>>>>>>>>>    
23946>>>>>>>>>>>>>>>>>    Procedure Private.Adjust_MDI_Margins Integer cy Integer cx Integer BorderFlag
23948>>>>>>>>>>>>>>>>>        Integer cMargin
23948>>>>>>>>>>>>>>>>>        If (BorderFlag = amTOP) Begin
23950>>>>>>>>>>>>>>>>>            Get mdi_top_margin to cMargin
23951>>>>>>>>>>>>>>>>>            Set mdi_top_margin to (cMargin + cy)
23952>>>>>>>>>>>>>>>>>        End
23952>>>>>>>>>>>>>>>>>>
23952>>>>>>>>>>>>>>>>>        Else If (BorderFlag = amBOTTOM) Begin
23955>>>>>>>>>>>>>>>>>            Get mdi_bottom_margin to cMargin
23956>>>>>>>>>>>>>>>>>            Set mdi_bottom_margin to (cMargin + cy)
23957>>>>>>>>>>>>>>>>>        End
23957>>>>>>>>>>>>>>>>>>
23957>>>>>>>>>>>>>>>>>        Else If (BorderFlag = amLEFT) Begin
23960>>>>>>>>>>>>>>>>>            Get mdi_left_margin to cMargin
23961>>>>>>>>>>>>>>>>>            Set mdi_left_margin to (cMargin + cx)
23962>>>>>>>>>>>>>>>>>        End
23962>>>>>>>>>>>>>>>>>>
23962>>>>>>>>>>>>>>>>>        Else If (BorderFlag = amRIGHT) Begin
23965>>>>>>>>>>>>>>>>>            Get mdi_right_margin to cMargin
23966>>>>>>>>>>>>>>>>>            Set mdi_right_margin to (cMargin + cx)
23967>>>>>>>>>>>>>>>>>        End
23967>>>>>>>>>>>>>>>>>>
23967>>>>>>>>>>>>>>>>>    End_Procedure
23968>>>>>>>>>>>>>>>>>    
23968>>>>>>>>>>>>>>>>>    Procedure Add_Border_Object Integer hoBorder Integer BorderFlag
23970>>>>>>>>>>>>>>>>>        Integer cy cx
23970>>>>>>>>>>>>>>>>>        Move (hi(GuiSize(hoBorder)))  to cy
23971>>>>>>>>>>>>>>>>>        Move (low(GuiSize(hoBorder))) to cx
23972>>>>>>>>>>>>>>>>>        
23972>>>>>>>>>>>>>>>>>        Send Private.Adjust_MDI_Margins cy cx BorderFlag
23973>>>>>>>>>>>>>>>>>    End_Procedure
23974>>>>>>>>>>>>>>>>>    
23974>>>>>>>>>>>>>>>>>    Procedure Remove_Border_Object Integer hoBorder Integer BorderFlag
23976>>>>>>>>>>>>>>>>>        Integer cy cx
23976>>>>>>>>>>>>>>>>>        Move (-(hi(GuiSize(hoBorder))))  to cy
23977>>>>>>>>>>>>>>>>>        Move (-(low(GuiSize(hoBorder)))) to cx
23978>>>>>>>>>>>>>>>>>        
23978>>>>>>>>>>>>>>>>>        Send Private.Adjust_MDI_Margins cy cx BorderFlag
23979>>>>>>>>>>>>>>>>>    End_Procedure
23980>>>>>>>>>>>>>>>>>    
23980>>>>>>>>>>>>>>>>>    //
23980>>>>>>>>>>>>>>>>>    // default behavior of mdi client is to passively pass these
23980>>>>>>>>>>>>>>>>>    // message on to their mdi dialogs (views)
23980>>>>>>>>>>>>>>>>>    //
23980>>>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
23982>>>>>>>>>>>>>>>>>        Integer rVal Id#
23982>>>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
23983>>>>>>>>>>>>>>>>>        While (Id# and Rval=0)
23987>>>>>>>>>>>>>>>>>            Get Verify_Exit_application of Id# to rVal
23988>>>>>>>>>>>>>>>>>            If not rval ;                Get Next_Mdi_Dialog False to Id#
23991>>>>>>>>>>>>>>>>>        End
23992>>>>>>>>>>>>>>>>>>
23992>>>>>>>>>>>>>>>>>        Function_Return rval
23993>>>>>>>>>>>>>>>>>    End_Function
23994>>>>>>>>>>>>>>>>>    
23994>>>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
23996>>>>>>>>>>>>>>>>>        Integer Id#
23996>>>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
23997>>>>>>>>>>>>>>>>>        While Id#
24001>>>>>>>>>>>>>>>>>            Send Notify_Exit_Application to Id#
24002>>>>>>>>>>>>>>>>>            Get Next_Mdi_Dialog False to Id#
24003>>>>>>>>>>>>>>>>>        End
24004>>>>>>>>>>>>>>>>>>
24004>>>>>>>>>>>>>>>>>    End_Procedure
24005>>>>>>>>>>>>>>>>>    
24005>>>>>>>>>>>>>>>>>    Procedure Make_all_ViewMode Integer Mode
24007>>>>>>>>>>>>>>>>>        Integer Id#
24007>>>>>>>>>>>>>>>>>        Get Next_Mdi_Dialog True to Id#
24008>>>>>>>>>>>>>>>>>        While Id#
24012>>>>>>>>>>>>>>>>>            If (active_State(Id#)) ;                Set View_Mode of Id# to Mode
24015>>>>>>>>>>>>>>>>>            Get Next_Mdi_Dialog False to Id#
24016>>>>>>>>>>>>>>>>>        End
24017>>>>>>>>>>>>>>>>>>
24017>>>>>>>>>>>>>>>>>    End_Procedure
24018>>>>>>>>>>>>>>>>>    
24018>>>>>>>>>>>>>>>>>    Procedure Minimize_all_Windows
24020>>>>>>>>>>>>>>>>>        Send Make_All_ViewMode VIEWMODE_ICONIZE
24021>>>>>>>>>>>>>>>>>    End_Procedure
24022>>>>>>>>>>>>>>>>>    
24022>>>>>>>>>>>>>>>>>    Procedure Restore_all_Windows
24024>>>>>>>>>>>>>>>>>        Send Make_All_ViewMode VIEWMODE_NORMAL
24025>>>>>>>>>>>>>>>>>    End_Procedure
24026>>>>>>>>>>>>>>>>>    
24026>>>>>>>>>>>>>>>>>    // The framework has used activate_about for years to activate an about
24026>>>>>>>>>>>>>>>>>    // dialog. As of 12.1, we have a sub-class for this and providing the
24026>>>>>>>>>>>>>>>>>    // required message makes things work better. It is expected that a
24026>>>>>>>>>>>>>>>>>    // developer will augment this in their clientarea to call the about
24026>>>>>>>>>>>>>>>>>    // object that they created.
24026>>>>>>>>>>>>>>>>>    Procedure Activate_About
24028>>>>>>>>>>>>>>>>>    End_Procedure
24029>>>>>>>>>>>>>>>>>    
24029>>>>>>>>>>>>>>>>>    
24029>>>>>>>>>>>>>>>>>End_Class
24030>>>>>>>>>>>>>>>Use DFADlg.pkg    // df application Dialog
Including file: Dfadlg.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfadlg.pkg)
24030>>>>>>>>>>>>>>>>>Use LanguageText.pkg
24030>>>>>>>>>>>>>>>>>Use Windows.pkg
24030>>>>>>>>>>>>>>>>>Use dfConfrm.pkg
Including file: Dfconfrm.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfconfrm.pkg)
24030>>>>>>>>>>>>>>>>>>>Use LanguageText.pkg
24030>>>>>>>>>>>>>>>>>>>Use msgbox.pkg
24030>>>>>>>>>>>>>>>>>>>
24030>>>>>>>>>>>>>>>>>>>// General purpose confirm function. Added to all classes
24030>>>>>>>>>>>>>>>>>>>//
24030>>>>>>>>>>>>>>>>>>>Function Confirm for cUIObject String item_name Returns Integer
24032>>>>>>>>>>>>>>>>>>>    Integer rval
24032>>>>>>>>>>>>>>>>>>>    Move (YesNo_Box(item_name, C_$Confirm, MB_DEFBUTTON1 )) to rval
24033>>>>>>>>>>>>>>>>>>>    Function_Return (rval<>MBR_YES)
24034>>>>>>>>>>>>>>>>>>>End_function
24035>>>>>>>>>>>>>>>>>>>
24035>>>>>>>>>>>>>>>>>>>Function Save_Confirmation for cUIObject Returns integer
24037>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$SaveThisRecord))
24038>>>>>>>>>>>>>>>>>>>End_function
24039>>>>>>>>>>>>>>>>>>>
24039>>>>>>>>>>>>>>>>>>>Function Delete_Confirmation for cUIObject Returns integer
24041>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$DeleteThisRecord))
24042>>>>>>>>>>>>>>>>>>>End_function
24043>>>>>>>>>>>>>>>>>>>
24043>>>>>>>>>>>>>>>>>>>Function Line_Save_Confirmation for cUIObject Returns Integer
24045>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$SaveThisLine))
24046>>>>>>>>>>>>>>>>>>>End_function
24047>>>>>>>>>>>>>>>>>>>
24047>>>>>>>>>>>>>>>>>>>Function Line_Delete_Confirmation for cUIObject Returns Integer
24049>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$DeleteThisLine))
24050>>>>>>>>>>>>>>>>>>>End_function
24051>>>>>>>>>>>>>>>>>>>
24051>>>>>>>>>>>>>>>>>>>Function Data_Loss_Confirmation for cUIObject Returns integer
24053>>>>>>>>>>>>>>>>>>>    Function_return (confirm(self, C_$AbandonChanges))
24054>>>>>>>>>>>>>>>>>>>End_function
24055>>>>>>>>>>>>>>>>>>>
24055>>>>>>>>>>>>>>>>>>>Function Exit_Loss_Confirmation for cUIObject Returns integer
24057>>>>>>>>>>>>>>>>>>>    Integer tmp
24057>>>>>>>>>>>>>>>>>>>    get Should_save_recursive to tmp
24058>>>>>>>>>>>>>>>>>>>    If (tmp <> 0) ;        Function_Return (confirm(Self, C_$ChangesExistAbandon))
24061>>>>>>>>>>>>>>>>>>>End_function
24062>>>>>>>>>>>>>>>>>>>
24062>>>>>>>>>>>>>>>>>>>Function No_Confirmation for cUIObject Returns integer
24064>>>>>>>>>>>>>>>>>>>End_function
24065>>>>>>>>>>>>>>>>>>>
24065>>>>>>>>>>>>>>>>>>>Function Should_Save for cUIObject returns integer
24067>>>>>>>>>>>>>>>>>>>end_function
24068>>>>>>>>>>>>>>>>>>>
24068>>>>>>>>>>>>>>>>>>>Function Should_Save_Recursive for cUIObject returns integer
24070>>>>>>>>>>>>>>>>>>>    Integer rVal
24070>>>>>>>>>>>>>>>>>>>    Get Should_Save to Rval // changes in this object???
24071>>>>>>>>>>>>>>>>>>>    If (rVal = 0) ;        Broadcast Get Should_Save_Recursive to Rval // check w/ kids
24075>>>>>>>>>>>>>>>>>>>    Function_return rVal
24076>>>>>>>>>>>>>>>>>>>End_Function
24077>>>>>>>>>>>>>>>>>>>
24077>>>>>>>>>>>>>>>>>>>
24077>>>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
24077>>>>>>>>>>>>>>>>>Use tWinStructs.pkg
24077>>>>>>>>>>>>>>>>>Use Dfpanel.pkg
24077>>>>>>>>>>>>>>>>>
24077>>>>>>>>>>>>>>>>>
24077>>>>>>>>>>>>>>>>>// as of 15.0, moved some of dbViews features up to this level. Load/Save Environment showing view name
24077>>>>>>>>>>>>>>>>>Class AppDialog is a MdiDialog
24078>>>>>>>>>>>>>>>>>    
24078>>>>>>>>>>>>>>>>>    Procedure Construct_Object
24080>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
24082>>>>>>>>>>>>>>>>>        
24082>>>>>>>>>>>>>>>>>        // This can be used to stop this view from loading and saving its environment.
24082>>>>>>>>>>>>>>>>>        Property Boolean pbDisableSaveEnvironment False
24083>>>>>>>>>>>>>>>>>        
24083>>>>>>>>>>>>>>>>>        // set true to auto-activate the view. This does not work if the object is deferred.
24083>>>>>>>>>>>>>>>>>        // this is a design time property which is applied during end_construct_object. This should
24083>>>>>>>>>>>>>>>>>        Property Boolean pbAutoActivate False
24084>>>>>>>>>>>>>>>>>        
24084>>>>>>>>>>>>>>>>>        // used to keep track of window placment when deactivated object is reactivated.
24084>>>>>>>>>>>>>>>>>        Property tWinWindowPlacement pWindowPlacement
24085>>>>>>>>>>>>>>>>>    End_Procedure
24086>>>>>>>>>>>>>>>>>    
24086>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24088>>>>>>>>>>>>>>>>>        Boolean bAutoActivate
24088>>>>>>>>>>>>>>>>>        Delegate Send Add_Mdi_Dialog Self
24090>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
24092>>>>>>>>>>>>>>>>>        // if auto-activate, add this to he the panel's array of objects to be acivated.
24092>>>>>>>>>>>>>>>>>        Get pbAutoActivate to bAutoActivate
24093>>>>>>>>>>>>>>>>>        If bAutoActivate Begin
24095>>>>>>>>>>>>>>>>>            Delegate Send AddAutoActivateView Self
24097>>>>>>>>>>>>>>>>>        End
24097>>>>>>>>>>>>>>>>>>
24097>>>>>>>>>>>>>>>>>    End_Procedure
24098>>>>>>>>>>>>>>>>>    
24098>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
24100>>>>>>>>>>>>>>>>>        Integer obj
24100>>>>>>>>>>>>>>>>>        Move Self to obj
24101>>>>>>>>>>>>>>>>>        Delegate Send Remove_Mdi_Dialog obj
24103>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
24105>>>>>>>>>>>>>>>>>    End_Procedure
24106>>>>>>>>>>>>>>>>>    
24106>>>>>>>>>>>>>>>>>    // Augmented to save view position
24106>>>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24108>>>>>>>>>>>>>>>>>        Send Save_Environment
24109>>>>>>>>>>>>>>>>>    End_Procedure
24110>>>>>>>>>>>>>>>>>    
24110>>>>>>>>>>>>>>>>>    Function View_Changed Returns Integer
24112>>>>>>>>>>>>>>>>>    End_Function
24113>>>>>>>>>>>>>>>>>    
24113>>>>>>>>>>>>>>>>>    //
24113>>>>>>>>>>>>>>>>>    // Augment exit_application_check to see if view is changed. If changed,
24113>>>>>>>>>>>>>>>>>    // display exit message as required
24113>>>>>>>>>>>>>>>>>    
24113>>>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24115>>>>>>>>>>>>>>>>>        Integer Fail
24115>>>>>>>>>>>>>>>>>        Get View_Changed to Fail // Ask for changes in Data-sets
24116>>>>>>>>>>>>>>>>>        If fail ; // ok a change exist...activate changed view.            Get confirm (SFormat(C_$ChangesExistExit, Label(Self)) ) to fail
24119>>>>>>>>>>>>>>>>>        Function_Return fail
24120>>>>>>>>>>>>>>>>>    End_Function
24121>>>>>>>>>>>>>>>>>    
24121>>>>>>>>>>>>>>>>>    // Activates the view. If view is minimized it restores it first
24121>>>>>>>>>>>>>>>>>    // works with both popup_state T and F
24121>>>>>>>>>>>>>>>>>    
24121>>>>>>>>>>>>>>>>>    Procedure Activate_View Returns Integer
24123>>>>>>>>>>>>>>>>>        Integer rVal
24123>>>>>>>>>>>>>>>>>        If ( View_mode(Self)=VIEWMODE_ICONIZE ) ;            Set view_mode to viewmode_normal
24126>>>>>>>>>>>>>>>>>        If (Popup_state(Self)) ;    // support both popup and            Get Msg_Popup to rVal
24129>>>>>>>>>>>>>>>>>        Else ;            Get Msg_Activate to rVal
24131>>>>>>>>>>>>>>>>>        Procedure_Return rVal
24132>>>>>>>>>>>>>>>>>    End_Procedure
24133>>>>>>>>>>>>>>>>>    
24133>>>>>>>>>>>>>>>>>    
24133>>>>>>>>>>>>>>>>>    // augmented to load last view position
24133>>>>>>>>>>>>>>>>>    
24133>>>>>>>>>>>>>>>>>    Procedure Add_Focus Integer hoBase Returns Integer
24135>>>>>>>>>>>>>>>>>        Integer iRetVal bState
24135>>>>>>>>>>>>>>>>>        Get Visible_State to bState
24136>>>>>>>>>>>>>>>>>        Set Visible_State to False
24137>>>>>>>>>>>>>>>>>        Forward Get Msg_Add_Focus hoBase to iRetVal
24139>>>>>>>>>>>>>>>>>        If (iRetVal=0) Begin
24141>>>>>>>>>>>>>>>>>            Send Load_Environment
24142>>>>>>>>>>>>>>>>>        End
24142>>>>>>>>>>>>>>>>>>
24142>>>>>>>>>>>>>>>>>        Set Visible_State to bState
24143>>>>>>>>>>>>>>>>>        Procedure_Return iRetVal
24144>>>>>>>>>>>>>>>>>    End_Procedure
24145>>>>>>>>>>>>>>>>>    
24145>>>>>>>>>>>>>>>>>    // This is augmented to send save_environment during a view close (was in close_panel)
24145>>>>>>>>>>>>>>>>>    // we set view_mode to normal if it is zoomed. This is needed to make the MDI stuff work
24145>>>>>>>>>>>>>>>>>    // properly with the save/load environment. The Saved environment data will make it zoom if needed.
24145>>>>>>>>>>>>>>>>>    //
24145>>>>>>>>>>>>>>>>>    Procedure Deactivate Integer eDeactivateScope Returns Integer
24147>>>>>>>>>>>>>>>>>        Integer eArea iFail
24147>>>>>>>>>>>>>>>>>        Boolean bPreserveEnvironment
24147>>>>>>>>>>>>>>>>>        Move (If(num_arguments=0, Area_Type, eDeactivateScope)) to eArea // in case no param is passed
24148>>>>>>>>>>>>>>>>>        If (eArea<>0) Begin
24150>>>>>>>>>>>>>>>>>            Forward Get msg_deactivate eArea to iFail
24152>>>>>>>>>>>>>>>>>        End
24152>>>>>>>>>>>>>>>>>>
24152>>>>>>>>>>>>>>>>>        Else Begin
24153>>>>>>>>>>>>>>>>>            Send Save_Environment
24154>>>>>>>>>>>>>>>>>            Forward Get msg_deactivate eArea to iFail
24156>>>>>>>>>>>>>>>>>            
24156>>>>>>>>>>>>>>>>>            // this works around a problem where maximized MDI views get saved but don't come back
24156>>>>>>>>>>>>>>>>>            // correctly when loaded again without exiting. It turns out the the MDI client restores
24156>>>>>>>>>>>>>>>>>            // the view sometimes without telling view_mode. If view_mode is normal, it always works.
24156>>>>>>>>>>>>>>>>>            // This must happen after the view is deactivated!
24156>>>>>>>>>>>>>>>>>            
24156>>>>>>>>>>>>>>>>>            If ghoApplication Begin
24158>>>>>>>>>>>>>>>>>                Get pbPreserveEnvironment of ghoApplication to bPreserveEnvironment
24159>>>>>>>>>>>>>>>>>            End
24159>>>>>>>>>>>>>>>>>>
24159>>>>>>>>>>>>>>>>>            // do these checks to have as small of an effect as possible.
24159>>>>>>>>>>>>>>>>>            If (bPreserveEnvironment and iFail=0 and view_mode(Self)=Viewmode_Zoom) Begin
24161>>>>>>>>>>>>>>>>>                Set View_Mode to Viewmode_Normal
24162>>>>>>>>>>>>>>>>>            End
24162>>>>>>>>>>>>>>>>>>
24162>>>>>>>>>>>>>>>>>        End
24162>>>>>>>>>>>>>>>>>>
24162>>>>>>>>>>>>>>>>>        Procedure_Return iFail
24163>>>>>>>>>>>>>>>>>    End_Procedure
24164>>>>>>>>>>>>>>>>>    
24164>>>>>>>>>>>>>>>>>    // Save the window placement information for this to the application object
24164>>>>>>>>>>>>>>>>>    
24164>>>>>>>>>>>>>>>>>    Procedure Save_Environment
24166>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24166>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24166>>>>>>>>>>>>>>>>>        Boolean bSuccess bCancel
24166>>>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to bCancel
24167>>>>>>>>>>>>>>>>>        If not bCancel Begin
24169>>>>>>>>>>>>>>>>>            
24169>>>>>>>>>>>>>>>>>            // save environment to the object, in case it is reactivated during the same run.
24169>>>>>>>>>>>>>>>>>            Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
24170>>>>>>>>>>>>>>>>>            Move (GetWindowPlacement(Window_Handle(Self), addressof(WindowPlacement))) to bSuccess
24171>>>>>>>>>>>>>>>>>            If bSuccess Begin
24173>>>>>>>>>>>>>>>>>                // if minimized, assume restored, as we don't want to restart minimized!
24173>>>>>>>>>>>>>>>>>                If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
24175>>>>>>>>>>>>>>>>>                    Move SW_SHOWNORMAL to WindowPlacement.showCmd
24176>>>>>>>>>>>>>>>>>                End
24176>>>>>>>>>>>>>>>>>>
24176>>>>>>>>>>>>>>>>>                Set pWindowPlacement to WindowPlacement
24177>>>>>>>>>>>>>>>>>            End
24177>>>>>>>>>>>>>>>>>>
24177>>>>>>>>>>>>>>>>>            // also save environment to the application object, so it can be used when reloaded
24177>>>>>>>>>>>>>>>>>            If ghoApplication ;                Send DoSaveEnvironment of ghoApplication Self False
24180>>>>>>>>>>>>>>>>>        End
24180>>>>>>>>>>>>>>>>>>
24180>>>>>>>>>>>>>>>>>    End_Procedure
24181>>>>>>>>>>>>>>>>>    
24181>>>>>>>>>>>>>>>>>    // Load the window placement information for this from the application object
24181>>>>>>>>>>>>>>>>>    
24181>>>>>>>>>>>>>>>>>    Procedure Load_Environment
24183>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24183>>>>>>>>>>>>>>>>>        tWinWindowPlacement WindowPlacement
24183>>>>>>>>>>>>>>>>>        Boolean bSuccess bCancel
24183>>>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to bCancel
24184>>>>>>>>>>>>>>>>>        If not bCancel Begin
24186>>>>>>>>>>>>>>>>>            // if view has alrady been activated and deactivated use the setting from windowplacement saved in the object
24186>>>>>>>>>>>>>>>>>            Get pWindowPlacement to WindowPlacement
24187>>>>>>>>>>>>>>>>>            //  if length is zero, assume it has never been used before (never deactivated).
24187>>>>>>>>>>>>>>>>>            If (WindowPlacement.length>0) Begin
24189>>>>>>>>>>>>>>>>>                Move (SetWindowPlacement(Window_Handle(Self), AddressOf(WindowPlacement))) to bSuccess
24190>>>>>>>>>>>>>>>>>            End
24190>>>>>>>>>>>>>>>>>>
24190>>>>>>>>>>>>>>>>>            Else Begin
24191>>>>>>>>>>>>>>>>>                If ghoApplication ;                    Send DoLoadEnvironment of ghoApplication Self False
24194>>>>>>>>>>>>>>>>>            End
24194>>>>>>>>>>>>>>>>>>
24194>>>>>>>>>>>>>>>>>        End
24194>>>>>>>>>>>>>>>>>>
24194>>>>>>>>>>>>>>>>>    End_Procedure
24195>>>>>>>>>>>>>>>>>    
24195>>>>>>>>>>>>>>>>>    Procedure Entering_Scope Returns Integer
24197>>>>>>>>>>>>>>>>>        Integer rVal
24197>>>>>>>>>>>>>>>>>        Forward Get MSG_Entering_Scope to rVal
24199>>>>>>>>>>>>>>>>>        If not rVal ;            Send Show_View_Name (Label(Self))
24202>>>>>>>>>>>>>>>>>    End_Procedure
24203>>>>>>>>>>>>>>>>>    
24203>>>>>>>>>>>>>>>>>    Procedure Exiting_Scope Integer whereto Returns Integer
24205>>>>>>>>>>>>>>>>>        Integer rVal
24205>>>>>>>>>>>>>>>>>        Forward Get MSG_Exiting_Scope whereto to rVal
24207>>>>>>>>>>>>>>>>>        If not rVal ;            Send Show_View_Name ''
24210>>>>>>>>>>>>>>>>>    End_Procedure
24211>>>>>>>>>>>>>>>>>    
24211>>>>>>>>>>>>>>>>>    Procedure Show_view_Name String sHelp
24213>>>>>>>>>>>>>>>>>        Integer rVal Id
24213>>>>>>>>>>>>>>>>>        Get Statusbar_id to id
24214>>>>>>>>>>>>>>>>>        If Id ;            Send Show_View_Name to Id sHelp
24217>>>>>>>>>>>>>>>>>    End_Procedure
24218>>>>>>>>>>>>>>>>>    
24218>>>>>>>>>>>>>>>>>    // force object to be modal and then pop it up. Upon complettion restore it to a normal view
24218>>>>>>>>>>>>>>>>>    Procedure Popup_Modal Returns Integer
24220>>>>>>>>>>>>>>>>>        
24220>>>>>>>>>>>>>>>>>        Integer OldBMS OldAPS OldPS OldRS OldSS OldMDIState
24220>>>>>>>>>>>>>>>>>        Integer OldLoc OldAutoLoc OldKeyPath OldDisableSaveEnv OldMin OldMax
24220>>>>>>>>>>>>>>>>>        Integer rVal
24220>>>>>>>>>>>>>>>>>        
24220>>>>>>>>>>>>>>>>>        // If object is active we can't do anything. -1 means already active
24220>>>>>>>>>>>>>>>>>        If (Active_State(Self)) ;            Procedure_Return -1
24223>>>>>>>>>>>>>>>>>        
24223>>>>>>>>>>>>>>>>>        // Remember all important modal property settings.
24223>>>>>>>>>>>>>>>>>        Get Block_mouse_State to OldBMS
24224>>>>>>>>>>>>>>>>>        Get Attach_parent_State to OldAPS
24225>>>>>>>>>>>>>>>>>        Get Popup_State to OldPS
24226>>>>>>>>>>>>>>>>>        Get Ring_State to OldRS
24227>>>>>>>>>>>>>>>>>        Get Scope_State to OldSS
24228>>>>>>>>>>>>>>>>>        Get MDI_State to OldMDIState
24229>>>>>>>>>>>>>>>>>        Get Key_Path to OldKeyPath
24230>>>>>>>>>>>>>>>>>        Get Location to OldLoc
24231>>>>>>>>>>>>>>>>>        Get Maximize_Icon to OldMax
24232>>>>>>>>>>>>>>>>>        Get Minimize_Icon to OldMin
24233>>>>>>>>>>>>>>>>>        Get Auto_Locate_State to OldAutoLoc
24234>>>>>>>>>>>>>>>>>        Get pbDisableSaveEnvironment to OldDisableSaveEnv
24235>>>>>>>>>>>>>>>>>        
24235>>>>>>>>>>>>>>>>>        // set propertie required to make this a modal dialog
24235>>>>>>>>>>>>>>>>>        Set pbDisableSaveEnvironment to True
24236>>>>>>>>>>>>>>>>>        Set MDI_State to False
24237>>>>>>>>>>>>>>>>>        Set Auto_Locate_State to True
24238>>>>>>>>>>>>>>>>>        Set Key_path to Desktop
24239>>>>>>>>>>>>>>>>>        Set Block_mouse_state to True
24240>>>>>>>>>>>>>>>>>        Set Attach_parent_state to False
24241>>>>>>>>>>>>>>>>>        // we used to set Exit_Application_Local_State to True - as of 19.1 we don't
24241>>>>>>>>>>>>>>>>>        Set Popup_State to True
24242>>>>>>>>>>>>>>>>>        Set Ring_State to True
24243>>>>>>>>>>>>>>>>>        Set Scope_State to True
24244>>>>>>>>>>>>>>>>>        Set Minimize_Icon to False
24245>>>>>>>>>>>>>>>>>        Set Maximize_Icon to False
24246>>>>>>>>>>>>>>>>>        
24246>>>>>>>>>>>>>>>>>        Get Msg_Popup to rVal
24247>>>>>>>>>>>>>>>>>        If rval ;            Move -2 to rVal      // did not activate
24250>>>>>>>>>>>>>>>>>        Else ;            Move StrMark to rVal // StrMark keeps track of UI value
24252>>>>>>>>>>>>>>>>>        // if 0- a stop_ui, if >0, ret value
24252>>>>>>>>>>>>>>>>>        // restore all expected properties
24252>>>>>>>>>>>>>>>>>        Set Auto_Locate_State to OldAutoLoc
24253>>>>>>>>>>>>>>>>>        Set Location to (hi(OldLoc)) (Low(OldLoc))
24254>>>>>>>>>>>>>>>>>        Set pbDisableSaveEnvironment to OldDisableSaveEnv
24255>>>>>>>>>>>>>>>>>        Set MDI_State to OldMDIState
24256>>>>>>>>>>>>>>>>>        Set Maximize_Icon to OldMax
24257>>>>>>>>>>>>>>>>>        Set Minimize_Icon to OldMin
24258>>>>>>>>>>>>>>>>>        Set Block_mouse_State   to OldBMS
24259>>>>>>>>>>>>>>>>>        Set Attach_parent_State to OldAPS
24260>>>>>>>>>>>>>>>>>        Set Popup_State         to OldPS
24261>>>>>>>>>>>>>>>>>        Set Ring_State          to OldRS
24262>>>>>>>>>>>>>>>>>        Set Scope_State         to OldSS
24263>>>>>>>>>>>>>>>>>        Procedure_Return rVal
24264>>>>>>>>>>>>>>>>>        
24264>>>>>>>>>>>>>>>>>    End_Procedure
24265>>>>>>>>>>>>>>>>>    
24265>>>>>>>>>>>>>>>>>End_Class
24266>>>>>>>>>>>>>>>>>
24266>>>>>>>>>>>>>>>>>// logically this is required
24266>>>>>>>>>>>>>>>>>//{ DesignerClass=cDTView }
24266>>>>>>>>>>>>>>>>>Class View is an AppDialog
24267>>>>>>>>>>>>>>>>>End_Class
24268>>>>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>>>Register_Function pbPreserveEnvironment Returns Boolean
24268>>>>>>>>>>>>>>>Register_Procedure Set phoMainPanel Handle hoMain
24268>>>>>>>>>>>>>>>Register_Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
24268>>>>>>>>>>>>>>>Register_Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
24268>>>>>>>>>>>>>>>Register_Procedure Set pbVisible Boolean bVisible
24268>>>>>>>>>>>>>>>Register_Function  pbVisible Returns Boolean
24268>>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>>>
24268>>>>>>>>>>>>>>>Class AppPanel is a BasicPanel
24269>>>>>>>>>>>>>>>    //
24269>>>>>>>>>>>>>>>    //  Panel defaults. Use windows MDI color
24269>>>>>>>>>>>>>>>    //
24269>>>>>>>>>>>>>>>    //
24269>>>>>>>>>>>>>>>    Procedure Construct_Object
24271>>>>>>>>>>>>>>>        Forward Send Construct_Object
24273>>>>>>>>>>>>>>>        
24273>>>>>>>>>>>>>>>        Property Integer Auto_Activate_State True
24274>>>>>>>>>>>>>>>        
24274>>>>>>>>>>>>>>>        // Support status for toolbar and status bar. For now we support
24274>>>>>>>>>>>>>>>        // 0=Hide, 1=Show,
24274>>>>>>>>>>>>>>>        //
24274>>>>>>>>>>>>>>>        Property Integer Private.ToolBar_State  1
24275>>>>>>>>>>>>>>>        
24275>>>>>>>>>>>>>>>        Property Integer Private.StatusBar_State  1
24276>>>>>>>>>>>>>>>        
24276>>>>>>>>>>>>>>>        Property Handle[] phoAutoActivateViews
24277>>>>>>>>>>>>>>>        
24277>>>>>>>>>>>>>>>        Set Scope_State to True
24278>>>>>>>>>>>>>>>        Set Mdi_State to True
24279>>>>>>>>>>>>>>>        
24279>>>>>>>>>>>>>>>        Set Size to 274 479
24280>>>>>>>>>>>>>>>        Set pbSizeToClientArea  to False
24281>>>>>>>>>>>>>>>    End_Procedure
24282>>>>>>>>>>>>>>>    
24282>>>>>>>>>>>>>>>    Procedure Set Auto_Arrange_Icons_State Integer bState
24284>>>>>>>>>>>>>>>        Integer hoClient
24284>>>>>>>>>>>>>>>        Get Client_id to hoClient
24285>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Set Auto_Arrange_Icons_State of hoClient to bState
24288>>>>>>>>>>>>>>>    End_Procedure
24289>>>>>>>>>>>>>>>    
24289>>>>>>>>>>>>>>>    Function Auto_Arrange_Icons_State Returns Integer
24291>>>>>>>>>>>>>>>        Integer hoClient bState
24291>>>>>>>>>>>>>>>        Get Client_id to hoClient
24292>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Get Auto_Arrange_Icons_State of hoClient to bState
24295>>>>>>>>>>>>>>>        Function_Return bState
24296>>>>>>>>>>>>>>>    End_Function
24297>>>>>>>>>>>>>>>    
24297>>>>>>>>>>>>>>>    Procedure Toggle_Auto_Arrange_Icons
24299>>>>>>>>>>>>>>>        Set Auto_Arrange_Icons_State ;            to (not(Auto_Arrange_Icons_State(Self)))
24300>>>>>>>>>>>>>>>    End_Procedure
24301>>>>>>>>>>>>>>>    
24301>>>>>>>>>>>>>>>    Procedure Set Client_Scrollbar_State Integer bState
24303>>>>>>>>>>>>>>>        Integer hoClient
24303>>>>>>>>>>>>>>>        Get Client_id to hoClient
24304>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Set Client_Scrollbar_State of hoClient to bState
24307>>>>>>>>>>>>>>>    End_Procedure
24308>>>>>>>>>>>>>>>    
24308>>>>>>>>>>>>>>>    Function Client_Scrollbar_State Returns Integer
24310>>>>>>>>>>>>>>>        Integer hoClient bState
24310>>>>>>>>>>>>>>>        Get Client_id to hoClient
24311>>>>>>>>>>>>>>>        If (hoClient and hoClient<>Self ) ;            Get Client_Scrollbar_State of hoClient to bState
24314>>>>>>>>>>>>>>>        Function_Return bState
24315>>>>>>>>>>>>>>>    End_Function
24316>>>>>>>>>>>>>>>    
24316>>>>>>>>>>>>>>>    Procedure Toggle_Client_Scrollbar_State
24318>>>>>>>>>>>>>>>        Set Client_Scrollbar_State ;            to (not(Client_Scrollbar_State(Self)))
24319>>>>>>>>>>>>>>>    End_Procedure
24320>>>>>>>>>>>>>>>    
24320>>>>>>>>>>>>>>>    Function ToolBar_State Returns Integer
24322>>>>>>>>>>>>>>>        Function_Return (private.Toolbar_State(Self))
24323>>>>>>>>>>>>>>>    End_Function
24324>>>>>>>>>>>>>>>    
24324>>>>>>>>>>>>>>>    Procedure Set Toolbar_State Integer bState
24326>>>>>>>>>>>>>>>        Integer hoToolBar
24326>>>>>>>>>>>>>>>        Handle hoCommandBars
24326>>>>>>>>>>>>>>>        If (bState<>toolbar_State(Self)) Begin
24328>>>>>>>>>>>>>>>            Set private.toolbar_State to bState
24329>>>>>>>>>>>>>>>            
24329>>>>>>>>>>>>>>>            Get phoCommandBars to hoCommandbars
24330>>>>>>>>>>>>>>>            If hoCommandbars ;                Procedure_Return
24333>>>>>>>>>>>>>>>            
24333>>>>>>>>>>>>>>>            If (Window_Handle(Self)) Begin
24335>>>>>>>>>>>>>>>                Get toolBar_ID to hoToolBar
24336>>>>>>>>>>>>>>>                If hoToolBar ;                    Send Activate_Component hoToolBar bState (Focus_Mode(hoToolbar))
24339>>>>>>>>>>>>>>>            End
24339>>>>>>>>>>>>>>>>
24339>>>>>>>>>>>>>>>        End
24339>>>>>>>>>>>>>>>>
24339>>>>>>>>>>>>>>>    End_Procedure
24340>>>>>>>>>>>>>>>    
24340>>>>>>>>>>>>>>>    Procedure Toggle_Toolbar
24342>>>>>>>>>>>>>>>        Set Toolbar_State to (not(Toolbar_State(Self)))
24343>>>>>>>>>>>>>>>    End_Procedure
24344>>>>>>>>>>>>>>>    
24344>>>>>>>>>>>>>>>    Function StatusBar_State Returns Integer
24346>>>>>>>>>>>>>>>        Handle hoCommandBars hoStatusBar
24346>>>>>>>>>>>>>>>        Boolean bState
24346>>>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24347>>>>>>>>>>>>>>>        If hoCommandbars Begin
24349>>>>>>>>>>>>>>>            Get Statusbar_ID to hoStatusBar
24350>>>>>>>>>>>>>>>            If hoStatusBar Begin
24352>>>>>>>>>>>>>>>                Get pbVisible of hoStatusBar to bState
24353>>>>>>>>>>>>>>>            End
24353>>>>>>>>>>>>>>>>
24353>>>>>>>>>>>>>>>        End
24353>>>>>>>>>>>>>>>>
24353>>>>>>>>>>>>>>>        Else Begin
24354>>>>>>>>>>>>>>>            Get private.Statusbar_state to bState
24355>>>>>>>>>>>>>>>        End
24355>>>>>>>>>>>>>>>>
24355>>>>>>>>>>>>>>>        Function_Return bState
24356>>>>>>>>>>>>>>>    End_Function
24357>>>>>>>>>>>>>>>    
24357>>>>>>>>>>>>>>>    Procedure Set Statusbar_State Integer bState
24359>>>>>>>>>>>>>>>        Handle hoStatusBar hoCommandBars
24359>>>>>>>>>>>>>>>        If (bState<>Statusbar_State(Self)) Begin
24361>>>>>>>>>>>>>>>            Set private.Statusbar_State to bState
24362>>>>>>>>>>>>>>>            Get Statusbar_ID to hoStatusBar
24363>>>>>>>>>>>>>>>            
24363>>>>>>>>>>>>>>>            Get phoCommandBars to hoCommandbars
24364>>>>>>>>>>>>>>>            If hoCommandbars Begin
24366>>>>>>>>>>>>>>>                If hoStatusBar Begin
24368>>>>>>>>>>>>>>>                    Set pbVisible of hoStatusBar to bState
24369>>>>>>>>>>>>>>>                End
24369>>>>>>>>>>>>>>>>
24369>>>>>>>>>>>>>>>            End
24369>>>>>>>>>>>>>>>>
24369>>>>>>>>>>>>>>>            Else Begin
24370>>>>>>>>>>>>>>>                If (Window_Handle(Self)) Begin
24372>>>>>>>>>>>>>>>                    If hoStatusBar ;                        Send Activate_Component hoStatusBar bState  nonfocusable
24375>>>>>>>>>>>>>>>                End
24375>>>>>>>>>>>>>>>>
24375>>>>>>>>>>>>>>>            End
24375>>>>>>>>>>>>>>>>
24375>>>>>>>>>>>>>>>        End
24375>>>>>>>>>>>>>>>>
24375>>>>>>>>>>>>>>>    End_Procedure
24376>>>>>>>>>>>>>>>    
24376>>>>>>>>>>>>>>>    Procedure Toggle_Statusbar
24378>>>>>>>>>>>>>>>        Set Statusbar_State to (not(statusbar_State(Self)))
24379>>>>>>>>>>>>>>>    End_Procedure
24380>>>>>>>>>>>>>>>    
24380>>>>>>>>>>>>>>>    Procedure AutoSizeLocate
24382>>>>>>>>>>>>>>>    End_Procedure
24383>>>>>>>>>>>>>>>    
24383>>>>>>>>>>>>>>>    Procedure Size_Components
24385>>>>>>>>>>>>>>>        Integer iToolBar iStatBar //iClient
24385>>>>>>>>>>>>>>>        Integer iSizeToolBar
24385>>>>>>>>>>>>>>>        Handle hoCommandbars
24385>>>>>>>>>>>>>>>        
24385>>>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24386>>>>>>>>>>>>>>>        If hoCommandbars ;            Procedure_Return
24389>>>>>>>>>>>>>>>        
24389>>>>>>>>>>>>>>>        If not (Window_Handle(Self)) ;            Procedure_Return
24392>>>>>>>>>>>>>>>        
24392>>>>>>>>>>>>>>>        Get ToolBar_id   to iToolBar
24393>>>>>>>>>>>>>>>        Get StatusBar_id to iStatBar
24394>>>>>>>>>>>>>>>        //Get Client_id    To iClient
24394>>>>>>>>>>>>>>>        
24394>>>>>>>>>>>>>>>        If (iToolBar and Window_Handle(iToolbar)) Begin
24396>>>>>>>>>>>>>>>            //Send AutoSizeLocate To iToolBar
24396>>>>>>>>>>>>>>>            Get GuiSize of iToolbar to iSizeToolbar
24397>>>>>>>>>>>>>>>            Set GUIsize of iToolbar to (hi(iSizeToolbar)) (low(iSizeToolbar)) // forces auto resize - don't change size
24398>>>>>>>>>>>>>>>            //set GUIsize of iToolbar to 28 800 // forces auto resize
24398>>>>>>>>>>>>>>>        End
24398>>>>>>>>>>>>>>>>
24398>>>>>>>>>>>>>>>        
24398>>>>>>>>>>>>>>>        If (iStatBar and Window_Handle(iStatBar)) Begin
24400>>>>>>>>>>>>>>>            Send AutoSizeLocate to iStatBar
24401>>>>>>>>>>>>>>>        End
24401>>>>>>>>>>>>>>>>
24401>>>>>>>>>>>>>>>    End_Procedure
24402>>>>>>>>>>>>>>>    
24402>>>>>>>>>>>>>>>    Procedure Activate_Component Integer Obj Integer st Integer focusmode
24404>>>>>>>>>>>>>>>        Integer act
24404>>>>>>>>>>>>>>>        If not Obj ;            Procedure_Return
24407>>>>>>>>>>>>>>>        Get Active_State of Obj to act
24408>>>>>>>>>>>>>>>        If (st and act=0) Begin
24410>>>>>>>>>>>>>>>            Set Focus_Mode of obj to focusable
24411>>>>>>>>>>>>>>>            Send Add_focus to obj Self
24412>>>>>>>>>>>>>>>            Set Focus_Mode of obj to focusmode
24413>>>>>>>>>>>>>>>        End
24413>>>>>>>>>>>>>>>>
24413>>>>>>>>>>>>>>>        Else If (st=0 and act) ;            Send deactivate to obj
24417>>>>>>>>>>>>>>>    End_Procedure
24418>>>>>>>>>>>>>>>    
24418>>>>>>>>>>>>>>>    Procedure Add_Components
24420>>>>>>>>>>>>>>>        Integer hClient
24420>>>>>>>>>>>>>>>        Handle hoCommandbars
24420>>>>>>>>>>>>>>>        Get phoCommandBars to hoCommandbars
24421>>>>>>>>>>>>>>>        If not hoCommandbars Begin
24423>>>>>>>>>>>>>>>            Get Client_id to hClient
24424>>>>>>>>>>>>>>>            If (hClient and hClient<>Self ) ; // this forces the client to start at a                Set mdi_top_margin of hClient to (mdi_top_margin(hClient)) // proper size when maximized w/ no components.
24427>>>>>>>>>>>>>>>            Send Activate_Component (Toolbar_Id(Self)) ;                (Toolbar_State(Self)) nonfocusable
24428>>>>>>>>>>>>>>>            Send Activate_Component (Statusbar_Id(Self)) ;                (Statusbar_State(Self)) nonfocusable
24429>>>>>>>>>>>>>>>            Send Size_Components
24430>>>>>>>>>>>>>>>        End
24430>>>>>>>>>>>>>>>>
24430>>>>>>>>>>>>>>>    End_Procedure
24431>>>>>>>>>>>>>>>    
24431>>>>>>>>>>>>>>>    Procedure Activate Returns Integer
24433>>>>>>>>>>>>>>>        Integer bFail
24433>>>>>>>>>>>>>>>        Forward Get MSG_activate to bFail
24435>>>>>>>>>>>>>>>        //If NOT bFail Send Add_Components
24435>>>>>>>>>>>>>>>        Send Add_Components
24436>>>>>>>>>>>>>>>        Set Main_Window to Self
24437>>>>>>>>>>>>>>>        Procedure_Return bFail
24438>>>>>>>>>>>>>>>    End_Procedure
24439>>>>>>>>>>>>>>>    
24439>>>>>>>>>>>>>>>    Procedure Client_Message Integer Msg_Id
24441>>>>>>>>>>>>>>>        Integer hoClient
24441>>>>>>>>>>>>>>>        Get Client_id to hoClient
24442>>>>>>>>>>>>>>>        If (hoClient and hoClient <> Self) ;            Send Msg_id to hoClient
24445>>>>>>>>>>>>>>>    End_Procedure
24446>>>>>>>>>>>>>>>    
24446>>>>>>>>>>>>>>>    Procedure Arrange_Icons
24448>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24449>>>>>>>>>>>>>>>    End_Procedure
24450>>>>>>>>>>>>>>>    
24450>>>>>>>>>>>>>>>    Procedure Cascade_Windows
24452>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24453>>>>>>>>>>>>>>>    End_Procedure
24454>>>>>>>>>>>>>>>    
24454>>>>>>>>>>>>>>>    Procedure Tile_Windows_Horizontal
24456>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24457>>>>>>>>>>>>>>>    End_Procedure
24458>>>>>>>>>>>>>>>    
24458>>>>>>>>>>>>>>>    Procedure Tile_Windows_Vertical
24460>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24461>>>>>>>>>>>>>>>    End_Procedure
24462>>>>>>>>>>>>>>>    
24462>>>>>>>>>>>>>>>    Procedure Set GuiSize Integer sizy Integer sizx
24464>>>>>>>>>>>>>>>        Forward Set GUISize to sizy sizx
24466>>>>>>>>>>>>>>>        If BuildingObjectId ;            Procedure_Return
24469>>>>>>>>>>>>>>>        Send Size_Components
24470>>>>>>>>>>>>>>>    End_Procedure
24471>>>>>>>>>>>>>>>    
24471>>>>>>>>>>>>>>>    //  Returns false to indicate that this is not a DEO. This is used by
24471>>>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
24471>>>>>>>>>>>>>>>    //  send a DEO message. DEO view clients set this true
24471>>>>>>>>>>>>>>>    //
24471>>>>>>>>>>>>>>>    Function Is_Function Integer MsgId Integer ObjId Integer DelegateFg Returns Integer
24473>>>>>>>>>>>>>>>        Integer DelMode rVal Id
24473>>>>>>>>>>>>>>>        Move ( If(DelegateFg,Self,ObjId) ) to Id
24474>>>>>>>>>>>>>>>        Get Delegation_mode of Id to DelMode
24475>>>>>>>>>>>>>>>        Set Delegation_mode of Id to No_Delegate_or_Error
24476>>>>>>>>>>>>>>>        Get MsgId of ObjId to rVal
24477>>>>>>>>>>>>>>>        Set Delegation_mode of Id to DelMode
24478>>>>>>>>>>>>>>>        Function_Return rVal
24479>>>>>>>>>>>>>>>    End_Function
24480>>>>>>>>>>>>>>>    
24480>>>>>>>>>>>>>>>    // In this class this should return an id or nothing (no delegation).
24480>>>>>>>>>>>>>>>    // Note, if no context exists return a 0 or ''.
24480>>>>>>>>>>>>>>>    //
24480>>>>>>>>>>>>>>>    Function Help_Context Integer Context_Type Returns String
24482>>>>>>>>>>>>>>>        Integer ID
24482>>>>>>>>>>>>>>>        String  rVal
24482>>>>>>>>>>>>>>>        
24482>>>>>>>>>>>>>>>        If (Context_Type = HELP_CONTEXT_ID) ;            Get Help_ID to rVal
24485>>>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_KEYWORD) ;            Get Help_Keyword to rVal
24489>>>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_ID_OR_KEY) Begin
24492>>>>>>>>>>>>>>>            Get Help_ID to ID
24493>>>>>>>>>>>>>>>            If (ID = 0) ;                Get Help_Keyword to rVal
24496>>>>>>>>>>>>>>>            Move ID to rVal
24497>>>>>>>>>>>>>>>            If (rval = '') ;                Move 0 to rVal
24500>>>>>>>>>>>>>>>        End
24500>>>>>>>>>>>>>>>>
24500>>>>>>>>>>>>>>>        Else If (Context_Type = HELP_CONTEXT_DATAFILE) ;            Move '' to rVal
24504>>>>>>>>>>>>>>>        
24504>>>>>>>>>>>>>>>        Function_Return rVal
24505>>>>>>>>>>>>>>>    End_Function
24506>>>>>>>>>>>>>>>    
24506>>>>>>>>>>>>>>>    // Get context based on eContext. If no content found, Don't delegate with panels --- end the search (added to 11.1. See help_mx.pkg)
24506>>>>>>>>>>>>>>>    //
24506>>>>>>>>>>>>>>>    Function HtmlHelpContext Integer eContext String ByRef sContext Returns Integer
24508>>>>>>>>>>>>>>>        Integer eContextFound
24508>>>>>>>>>>>>>>>        Get HtmlHelpObjectContext eContext (&sContext) to eContextFound // context for this one object
24509>>>>>>>>>>>>>>>        Function_Return eContextFound
24510>>>>>>>>>>>>>>>    End_Function
24511>>>>>>>>>>>>>>>    
24511>>>>>>>>>>>>>>>    
24511>>>>>>>>>>>>>>>    // When verify_exit_appliction is received by default just
24511>>>>>>>>>>>>>>>    // send this message to the Mdi-client Id.
24511>>>>>>>>>>>>>>>    //
24511>>>>>>>>>>>>>>>    Function Verify_Exit_Application Returns Integer
24513>>>>>>>>>>>>>>>        Integer Id rVal
24513>>>>>>>>>>>>>>>        Get Client_Id to id
24514>>>>>>>>>>>>>>>        If (Id and Id<>Self) ;            Get Verify_Exit_application of Id to rVal
24517>>>>>>>>>>>>>>>        Function_Return Rval
24518>>>>>>>>>>>>>>>    End_Function
24519>>>>>>>>>>>>>>>    
24519>>>>>>>>>>>>>>>    // When exit notifiction is received by default just
24519>>>>>>>>>>>>>>>    // send this message to the Mdi-client Id.
24519>>>>>>>>>>>>>>>    //
24519>>>>>>>>>>>>>>>    Procedure Notify_Exit_Application
24521>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24522>>>>>>>>>>>>>>>        
24522>>>>>>>>>>>>>>>        Forward Send Notify_Exit_Application
24524>>>>>>>>>>>>>>>    End_Procedure
24525>>>>>>>>>>>>>>>    
24525>>>>>>>>>>>>>>>    Procedure Minimize_all_Windows
24527>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24528>>>>>>>>>>>>>>>    End_Procedure
24529>>>>>>>>>>>>>>>    
24529>>>>>>>>>>>>>>>    Procedure Restore_all_Windows
24531>>>>>>>>>>>>>>>        Send Client_Message Current_Message
24532>>>>>>>>>>>>>>>    End_Procedure
24533>>>>>>>>>>>>>>>    
24533>>>>>>>>>>>>>>>    // augmented to  activate if required
24533>>>>>>>>>>>>>>>    //
24533>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24535>>>>>>>>>>>>>>>        Forward Send End_Construct_object
24537>>>>>>>>>>>>>>>        If (Auto_activate_state(Self)) ;            Send Activate
24540>>>>>>>>>>>>>>>    End_Procedure
24541>>>>>>>>>>>>>>>    
24541>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
24543>>>>>>>>>>>>>>>        Integer iError i iViews
24543>>>>>>>>>>>>>>>        Handle[] hoAutoActivateViews
24544>>>>>>>>>>>>>>>        Forward Get msg_Add_Focus hoParent to iError
24546>>>>>>>>>>>>>>>        If (iError=0) Begin
24548>>>>>>>>>>>>>>>            Get phoAutoActivateViews to hoAutoActivateViews
24549>>>>>>>>>>>>>>>            Move (SizeOfArray(hoAutoActivateViews)) to iViews
24550>>>>>>>>>>>>>>>            For i from 0 to (iViews-1)
24556>>>>>>>>>>>>>>>>
24556>>>>>>>>>>>>>>>                Send Activate_View of hoAutoActivateViews[i]
24557>>>>>>>>>>>>>>>            Loop
24558>>>>>>>>>>>>>>>>
24558>>>>>>>>>>>>>>>        End
24558>>>>>>>>>>>>>>>>
24558>>>>>>>>>>>>>>>    End_Procedure
24559>>>>>>>>>>>>>>>    
24559>>>>>>>>>>>>>>>    // adds a view to the array of views to be autoactivated
24559>>>>>>>>>>>>>>>    
24559>>>>>>>>>>>>>>>    Procedure AddAutoActivateView Handle hoView
24561>>>>>>>>>>>>>>>        Handle[] hoAutoActivateViews
24562>>>>>>>>>>>>>>>        Get phoAutoActivateViews to hoAutoActivateViews
24563>>>>>>>>>>>>>>>        Move hoView to hoAutoActivateViews[SizeOfArray(hoAutoActivateViews)]
24564>>>>>>>>>>>>>>>        Set phoAutoActivateViews to hoAutoActivateViews
24565>>>>>>>>>>>>>>>    End_Procedure
24566>>>>>>>>>>>>>>>    
24566>>>>>>>>>>>>>>>End_Class
24567>>>>>>>>>>>>>>>
24567>>>>>>>>>>>>>>>
24567>>>>>>>>>>>>>>>Use DFCursor.pkg
24567>>>>>>>>>>>>>>>
24567>>>>>>>>>>>>>>>//  Main DEO High level main Panel Class
24567>>>>>>>>>>>>>>>//
24567>>>>>>>>>>>>>>>Class Panel is a AppPanel
24568>>>>>>>>>>>>>>>    
24568>>>>>>>>>>>>>>>    Procedure Construct_Object
24570>>>>>>>>>>>>>>>        String St
24570>>>>>>>>>>>>>>>        Integer iVal
24570>>>>>>>>>>>>>>>        DWord dwState
24570>>>>>>>>>>>>>>>        Forward Send Construct_Object
24572>>>>>>>>>>>>>>>        
24572>>>>>>>>>>>>>>>        // defaults to hourglass...end_construct will remove
24572>>>>>>>>>>>>>>>        Send Cursor_wait to (Cursor_Control(Self)) // hourglass
24573>>>>>>>>>>>>>>>        
24573>>>>>>>>>>>>>>>        Set private_pbEnvironmentProgram to True
24574>>>>>>>>>>>>>>>    End_Procedure
24575>>>>>>>>>>>>>>>    
24575>>>>>>>>>>>>>>>    
24575>>>>>>>>>>>>>>>    // This sends the message register_active_view to all child objects.
24575>>>>>>>>>>>>>>>    // It passes the object ID of the object that is requesting this
24575>>>>>>>>>>>>>>>    // information. The flag BCast_Focus determines if this should
24575>>>>>>>>>>>>>>>    // broadcast or broadcast_focus
24575>>>>>>>>>>>>>>>    //
24575>>>>>>>>>>>>>>>    Procedure Notify_All_Views Integer Msg Integer obj Integer Bcast_Focus
24577>>>>>>>>>>>>>>>        Integer clobj
24577>>>>>>>>>>>>>>>        Get Client_ID to clObj
24578>>>>>>>>>>>>>>>        If (ClObj = 0) ;            Move Self to ClObj
24581>>>>>>>>>>>>>>>        If BCast_Focus ;            Broadcast_Focus Send Msg to Clobj obj
24585>>>>>>>>>>>>>>>        Else ;            Broadcast       Send Msg to Clobj obj
24588>>>>>>>>>>>>>>>    End_Procedure
24589>>>>>>>>>>>>>>>    
24589>>>>>>>>>>>>>>>
24589>>>>>>>>>>>>>>>    
24589>>>>>>>>>>>>>>>    // augmented to remove hourglass
24589>>>>>>>>>>>>>>>    //
24589>>>>>>>>>>>>>>>    Procedure End_Construct_Object
24591>>>>>>>>>>>>>>>        // if application object exists, we need to tell that object that we are the main panel
24591>>>>>>>>>>>>>>>        If ghoApplication ;            Set phoMainPanel of ghoApplication to Self
24594>>>>>>>>>>>>>>>        Forward Send End_Construct_object
24596>>>>>>>>>>>>>>>        Send Cursor_ready to (Cursor_Control(Self)) // restore
24597>>>>>>>>>>>>>>>    End_Procedure
24598>>>>>>>>>>>>>>>    
24598>>>>>>>>>>>>>>>    Procedure Page Integer iState
24600>>>>>>>>>>>>>>>        Forward Send Page iState
24602>>>>>>>>>>>>>>>        If (iState =1) Begin
24604>>>>>>>>>>>>>>>            Send Load_Environment
24605>>>>>>>>>>>>>>>        End
24605>>>>>>>>>>>>>>>>
24605>>>>>>>>>>>>>>>    End_Procedure
24606>>>>>>>>>>>>>>>    
24606>>>>>>>>>>>>>>>End_Class
24607>>>>>>>>>>>>>>>
24607>>>>>>>>>>>>>>>//  Main DEO High level main MDI Client Class
24607>>>>>>>>>>>>>>>//
24607>>>>>>>>>>>>>>>//  Currently there is nothing special about this class but it was
24607>>>>>>>>>>>>>>>//  created because it is logically correct. Extensions may go here in
24607>>>>>>>>>>>>>>>//  the futire
24607>>>>>>>>>>>>>>>Class ClientArea is a AppClientArea
24608>>>>>>>>>>>>>>>End_Class
24609>>>>>>>>>>>>>>>
24609>>>>>>>>>>>>>Use EnClient.pkg
Including file: Enclient.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Enclient.pkg)
24609>>>>>>>>>>>>>>>Use windows.pkg
24609>>>>>>>>>>>>>>>Use NESTING.pkg       //include DEO nesting standard support module
Including file: nesting.pkg    (C:\Program Files\DataFlex 24.0\Pkg\nesting.pkg)
24609>>>>>>>>>>>>>>>>>Use VDFBase.pkg
24609>>>>>>>>>>>>>>>>>
24609>>>>>>>>>>>>>>>>>Class nesting_mixin is a mixin
24610>>>>>>>>>>>>>>>>>    
24610>>>>>>>>>>>>>>>>>    //   Component_State indicates if this object has a parent object which is
24610>>>>>>>>>>>>>>>>>    //   also a data-entry object.
24610>>>>>>>>>>>>>>>>>    //
24610>>>>>>>>>>>>>>>>>    //   Has_Components_State indicates if this object has at least one child-
24610>>>>>>>>>>>>>>>>>    //   object which is also a data-entry object.
24610>>>>>>>>>>>>>>>>>    //
24610>>>>>>>>>>>>>>>>>    //   First_DEO and Last_DEO are used temporarily during the searches for
24610>>>>>>>>>>>>>>>>>    //   the first and last data-entry object children of this object (see
24610>>>>>>>>>>>>>>>>>    //   Find_First_DEO, Find_Last_DEO, Inquire_First_DEO and Inquire_Last_DEO).
24610>>>>>>>>>>>>>>>>>    //
24610>>>>>>>>>>>>>>>>>    Procedure define_nesting
24612>>>>>>>>>>>>>>>>>        Property Integer Component_State        0
24613>>>>>>>>>>>>>>>>>        Property Integer Has_Components_State   0
24614>>>>>>>>>>>>>>>>>        Property Integer First_DEO              0
24615>>>>>>>>>>>>>>>>>        Property Integer Last_DEO               0
24616>>>>>>>>>>>>>>>>>        
24616>>>>>>>>>>>>>>>>>        // Stop_ui support - Moved from its own mixin package.
24616>>>>>>>>>>>>>>>>>        Property Integer Stop_UI_State False
24617>>>>>>>>>>>>>>>>>        
24617>>>>>>>>>>>>>>>>>    End_Procedure
24618>>>>>>>>>>>>>>>>>    
24618>>>>>>>>>>>>>>>>>    
24618>>>>>>>>>>>>>>>>>    //   This procedure is used to locate the first data-entry object among
24618>>>>>>>>>>>>>>>>>    //   this object's siblings (its parent's children).
24618>>>>>>>>>>>>>>>>>    //
24618>>>>>>>>>>>>>>>>>    //   This procedure is typically invoked via the BROADCAST command from
24618>>>>>>>>>>>>>>>>>    //   the Find_First_DEO function of this object's parent.
24618>>>>>>>>>>>>>>>>>    //
24618>>>>>>>>>>>>>>>>>    Procedure inquire_first_DEO Integer obj# Integer recurseClients
24620>>>>>>>>>>>>>>>>>        If (focus_mode(Self) = FOCUSABLE) Begin
24622>>>>>>>>>>>>>>>>>            If (recurseClients and client_area_state(Self)) ;                Broadcast_Focus Send inquire_first_DEO obj# recurseClients
24626>>>>>>>>>>>>>>>>>            Else Begin
24627>>>>>>>>>>>>>>>>>                Set first_DEO of obj# to Self
24628>>>>>>>>>>>>>>>>>                Procedure_Return 1  //to stop broadcast, since this object answered
24629>>>>>>>>>>>>>>>>>            End
24629>>>>>>>>>>>>>>>>>>
24629>>>>>>>>>>>>>>>>>        End
24629>>>>>>>>>>>>>>>>>>
24629>>>>>>>>>>>>>>>>>    End_Procedure
24630>>>>>>>>>>>>>>>>>    
24630>>>>>>>>>>>>>>>>>    //   If this object is focusable, set Lastt_DEO to this object's id.
24630>>>>>>>>>>>>>>>>>    //
24630>>>>>>>>>>>>>>>>>    //   This procedure is used to locate the last data-entry object among
24630>>>>>>>>>>>>>>>>>    //   this object's siblings (its parent's children).
24630>>>>>>>>>>>>>>>>>    //
24630>>>>>>>>>>>>>>>>>    //   This procedure is typically invoked via the BROADCAST command from
24630>>>>>>>>>>>>>>>>>    //   the Find_Last_DEO function of this object's parent.
24630>>>>>>>>>>>>>>>>>    //
24630>>>>>>>>>>>>>>>>>    Procedure inquire_last_DEO Integer obj# Integer recurseClients
24632>>>>>>>>>>>>>>>>>        If (focus_mode(Self) = FOCUSABLE) Begin
24634>>>>>>>>>>>>>>>>>            If (recurseClients and client_area_state(Self)) ;                Broadcast_Focus Send inquire_last_DEO obj# recurseClients
24638>>>>>>>>>>>>>>>>>            Else ;                Set last_DEO of obj# to Self
24640>>>>>>>>>>>>>>>>>        End
24640>>>>>>>>>>>>>>>>>>
24640>>>>>>>>>>>>>>>>>    End_Procedure
24641>>>>>>>>>>>>>>>>>    
24641>>>>>>>>>>>>>>>>>    //   This function returns the object id of the first data-entry object
24641>>>>>>>>>>>>>>>>>    //   which is a child of this object, or 0.
24641>>>>>>>>>>>>>>>>>    //
24641>>>>>>>>>>>>>>>>>    //   This function 'searches' by broadcasting Inquire_First_DEO, which
24641>>>>>>>>>>>>>>>>>    //   returns a 1 to terminate the broadcast after the first data-entry
24641>>>>>>>>>>>>>>>>>    //   object has been located.
24641>>>>>>>>>>>>>>>>>    //
24641>>>>>>>>>>>>>>>>>    Function find_first_DEO Returns Integer
24643>>>>>>>>>>>>>>>>>        Set First_DEO to 0
24644>>>>>>>>>>>>>>>>>        Broadcast_Focus Send inquire_first_DEO Self False //sets First_DEO property
24646>>>>>>>>>>>>>>>>>        Function_Return (first_deo(Self))
24647>>>>>>>>>>>>>>>>>    End_Function
24648>>>>>>>>>>>>>>>>>    
24648>>>>>>>>>>>>>>>>>    
24648>>>>>>>>>>>>>>>>>    //   This function returns the object id of the last data-entry object
24648>>>>>>>>>>>>>>>>>    //   which is a child of this object, or 0.
24648>>>>>>>>>>>>>>>>>    //
24648>>>>>>>>>>>>>>>>>    //   This function 'searches' by broadcasting Inquire_Last_DEO, which sets
24648>>>>>>>>>>>>>>>>>    //   the property Last_DEO.  Thus, the last object reached by the broadcast
24648>>>>>>>>>>>>>>>>>    //   is the last value to be set into Last_DEO.
24648>>>>>>>>>>>>>>>>>    //
24648>>>>>>>>>>>>>>>>>    Function find_last_DEO Returns Integer
24650>>>>>>>>>>>>>>>>>        Set Last_DEO to 0
24651>>>>>>>>>>>>>>>>>        Broadcast_Focus Send inquire_last_DEO Self False //sets Last_DEO property
24653>>>>>>>>>>>>>>>>>        Function_Return (Last_DEO(Self))
24654>>>>>>>>>>>>>>>>>    End_Function
24655>>>>>>>>>>>>>>>>>    
24655>>>>>>>>>>>>>>>>>    //   Removes this object from the screen and focus-tree, and also removes
24655>>>>>>>>>>>>>>>>>    //   this object's children from the screen and focus-tree.
24655>>>>>>>>>>>>>>>>>    //
24655>>>>>>>>>>>>>>>>>    //   If no flag argument was passed, AREA_TYPE becomes the flag parameter.
24655>>>>>>>>>>>>>>>>>    //
24655>>>>>>>>>>>>>>>>>    //   Client-objects already automatically remove their children from the
24655>>>>>>>>>>>>>>>>>    //   focus-tree.
24655>>>>>>>>>>>>>>>>>    //
24655>>>>>>>>>>>>>>>>>    Procedure Deactivate Integer eDeactivateScope Returns Integer
24657>>>>>>>>>>>>>>>>>        Integer retval Fg
24657>>>>>>>>>>>>>>>>>        If (num_arguments > 0) ;            Move eDeactivateScope to Fg
24660>>>>>>>>>>>>>>>>>        Else ;            Move AREA_TYPE to Fg
24662>>>>>>>>>>>>>>>>>        Forward Get msg_deactivate fg to retval
24664>>>>>>>>>>>>>>>>>        
24664>>>>>>>>>>>>>>>>>        If ( not(retval) and (fg = 0) ) Begin
24666>>>>>>>>>>>>>>>>>            
24666>>>>>>>>>>>>>>>>>            // This broadcast no_stop is probably not ever used, but would be if a
24666>>>>>>>>>>>>>>>>>            // child was in the focus tree, but not as a focus-child. weird, but needs be here.
24666>>>>>>>>>>>>>>>>>            If ( client_Area_state(Self)=0) ;                Broadcast NO_STOP Send deactivate 0
24671>>>>>>>>>>>>>>>>>            
24671>>>>>>>>>>>>>>>>>            If ( Stop_UI_State(Self) ) ;                Send Stop_Ui
24674>>>>>>>>>>>>>>>>>        End
24674>>>>>>>>>>>>>>>>>>
24674>>>>>>>>>>>>>>>>>        Procedure_Return retval
24675>>>>>>>>>>>>>>>>>    End_Procedure
24676>>>>>>>>>>>>>>>>>    
24676>>>>>>>>>>>>>>>>>    //   This procedure marks an object as a child data-entry object, and
24676>>>>>>>>>>>>>>>>>    //   attempts to use its parent's Server if this object has no Server.
24676>>>>>>>>>>>>>>>>>    //   Typically sent via broadcast from parent DEO.
24676>>>>>>>>>>>>>>>>>    //
24676>>>>>>>>>>>>>>>>>    Procedure Mark_As_Component
24678>>>>>>>>>>>>>>>>>        Set Component_State to True
24679>>>>>>>>>>>>>>>>>        Delegate Set Has_Components_State to True
24681>>>>>>>>>>>>>>>>>    End_Procedure
24682>>>>>>>>>>>>>>>>>    
24682>>>>>>>>>>>>>>>>>    
24682>>>>>>>>>>>>>>>>>    //   This procedure marks child data-entry objects as components.
24682>>>>>>>>>>>>>>>>>    //
24682>>>>>>>>>>>>>>>>>    //   The child data-entry objects must understand Mark_As_Component as a
24682>>>>>>>>>>>>>>>>>    //   method of setting their Component_State to TRUE.
24682>>>>>>>>>>>>>>>>>    Procedure Mark_Components
24684>>>>>>>>>>>>>>>>>        Set Component_State to False
24685>>>>>>>>>>>>>>>>>        Broadcast Send Mark_As_Component
24687>>>>>>>>>>>>>>>>>    End_Procedure
24688>>>>>>>>>>>>>>>>>End_Class
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>Use NAVIGATE.pkg      //include DEO navigation standard support module
Including file: navigate.pkg    (C:\Program Files\DataFlex 24.0\Pkg\navigate.pkg)
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>>>Use VDFBase.pkg
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>>>Register_Function verify_data_loss Returns Integer
24689>>>>>>>>>>>>>>>>>
24689>>>>>>>>>>>>>>>>>Class navigate_mixin is a mixin
24690>>>>>>>>>>>>>>>>>    
24690>>>>>>>>>>>>>>>>>    Procedure define_navigation
24692>>>>>>>>>>>>>>>>>        On_Key kBegin_of_Panel    Send Beginning_of_Panel PRIVATE
24693>>>>>>>>>>>>>>>>>        On_Key kCancel            Send Request_Cancel     PRIVATE
24694>>>>>>>>>>>>>>>>>        On_Key kEnd_of_Panel      Send End_of_Panel       PRIVATE
24695>>>>>>>>>>>>>>>>>        On_Key kExit_Function     Send Exit_Function      PRIVATE
24696>>>>>>>>>>>>>>>>>        On_Key kSwitch            Send Switch             PRIVATE
24697>>>>>>>>>>>>>>>>>        On_Key kSwitch_Back       Send Switch_Back        PRIVATE
24698>>>>>>>>>>>>>>>>>        Property Integer Auto_Top_Panel_State             True
24699>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Exit_Msg          0
24700>>>>>>>>>>>>>>>>>    End_Procedure
24701>>>>>>>>>>>>>>>>>    
24701>>>>>>>>>>>>>>>>>    Function Verify_Exit_msg Returns Integer
24703>>>>>>>>>>>>>>>>>        Integer msg#
24703>>>>>>>>>>>>>>>>>        Get private.verify_exit_msg to msg#
24704>>>>>>>>>>>>>>>>>        If (msg# = 0 and Component_State(Self)) ;            Delegate Get verify_exit_msg to msg#
24708>>>>>>>>>>>>>>>>>        Function_Return msg#
24709>>>>>>>>>>>>>>>>>    End_Function
24710>>>>>>>>>>>>>>>>>    
24710>>>>>>>>>>>>>>>>>    
24710>>>>>>>>>>>>>>>>>    Procedure Set Verify_Exit_msg Integer msg#
24712>>>>>>>>>>>>>>>>>        Set private.verify_Exit_Msg to msg#
24713>>>>>>>>>>>>>>>>>    End_Procedure
24714>>>>>>>>>>>>>>>>>    
24714>>>>>>>>>>>>>>>>>    
24714>>>>>>>>>>>>>>>>>    Function Verify_Exit Returns Integer
24716>>>>>>>>>>>>>>>>>        Integer msg#
24716>>>>>>>>>>>>>>>>>        Get verify_Exit_msg to msg#
24717>>>>>>>>>>>>>>>>>        If (msg# <> 0) ;            Get msg# to msg#
24720>>>>>>>>>>>>>>>>>        Function_Return msg#
24721>>>>>>>>>>>>>>>>>    End_Function
24722>>>>>>>>>>>>>>>>>    
24722>>>>>>>>>>>>>>>>>    
24722>>>>>>>>>>>>>>>>>    
24722>>>>>>>>>>>>>>>>>    
24722>>>>>>>>>>>>>>>>>    //   The deactivate message-send passes AREA_FLAG, which means that we want
24722>>>>>>>>>>>>>>>>>    //   to deactivate the object in the focus tree which is either a scope
24722>>>>>>>>>>>>>>>>>    //   (i.e. Scope_State = TRUE) or a pop-up (i.e. PopUp_State = TRUE), and
24722>>>>>>>>>>>>>>>>>    //   which is closest to this object in an 'upward' direction (i.e.
24722>>>>>>>>>>>>>>>>>    //   client/parent, not child or sibling).
24722>>>>>>>>>>>>>>>>>    //
24722>>>>>>>>>>>>>>>>>    Procedure Request_Cancel
24724>>>>>>>>>>>>>>>>>        Integer foc#
24724>>>>>>>>>>>>>>>>>        If (verify_exit(Self) = 0) Begin
24726>>>>>>>>>>>>>>>>>            Send deactivate AREA_FLAG
24727>>>>>>>>>>>>>>>>>            Get focus of desktop to foc#
24728>>>>>>>>>>>>>>>>>            If (foc# and skip_State(foc#)) ;                Send switch to foc#
24731>>>>>>>>>>>>>>>>>        End
24731>>>>>>>>>>>>>>>>>>
24731>>>>>>>>>>>>>>>>>    End_Procedure
24732>>>>>>>>>>>>>>>>>    
24732>>>>>>>>>>>>>>>>>    
24732>>>>>>>>>>>>>>>>>    
24732>>>>>>>>>>>>>>>>>    Procedure Exit_Function
24734>>>>>>>>>>>>>>>>>        Send request_cancel
24735>>>>>>>>>>>>>>>>>    End_Procedure
24736>>>>>>>>>>>>>>>>>    
24736>>>>>>>>>>>>>>>>>End_Class
24737>>>>>>>>>>>>>>>>>
24737>>>>>>>>>>>>>>>>>
24737>>>>>>>>>>>>>>>>>
24737>>>>>>>>>>>>>>>Use SERVER.pkg        //include Server support module
Including file: Server.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Server.pkg)
24737>>>>>>>>>>>>>>>>>
24737>>>>>>>>>>>>>>>>>Use VDFBase.pkg
24737>>>>>>>>>>>>>>>>>Use brdcster.pkg
Including file: brdcster.pkg    (C:\Program Files\DataFlex 24.0\Pkg\brdcster.pkg)
24737>>>>>>>>>>>>>>>>>>>Use Set.pkg
24737>>>>>>>>>>>>>>>>>>>
24737>>>>>>>>>>>>>>>>>>>//   This class is defined as a subclass of Set with a C language handler
24737>>>>>>>>>>>>>>>>>>>//   providing additional behavior.
24737>>>>>>>>>>>>>>>>>>>//
24737>>>>>>>>>>>>>>>>>>>Class Broadcaster is a Set 0 0 Broadcast_Handler
24738>>>>>>>>>>>>>>>>>>>End_Class
24739>>>>>>>>>>>>>>>>>>>
24739>>>>>>>>>>>>>>>>>>>
24739>>>>>>>>>>>>>>>>>>>Function make_broadcaster for cDesktop Returns Integer
24741>>>>>>>>>>>>>>>>>>>    Integer obj#
24741>>>>>>>>>>>>>>>>>>>    Object broadcasterTemplate is a broadcaster
24743>>>>>>>>>>>>>>>>>>>        Move Self to obj#
24744>>>>>>>>>>>>>>>>>>>    End_Object
24745>>>>>>>>>>>>>>>>>>>    Function_Return obj#
24746>>>>>>>>>>>>>>>>>>>End_Function
24747>>>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>Register_Procedure Item_Find Integer mode Integer datafile Integer datafield ;    Integer entUpdtFlag Integer errFlag Integer dfrdFlag
24747>>>>>>>>>>>>>>>>>Register_Procedure Add_User_Interface Integer obj#
24747>>>>>>>>>>>>>>>>>Register_Procedure Remove_User_Interface Integer obj#
24747>>>>>>>>>>>>>>>>>Register_Procedure Clear
24747>>>>>>>>>>>>>>>>>Register_Function  Component_State Returns Integer
24747>>>>>>>>>>>>>>>>>Register_Function  Can_Delete Returns Integer
24747>>>>>>>>>>>>>>>>>Register_Object Element
24747>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>// Values for DSO_Detach_Mode
24747>>>>>>>>>>>>>>>>>//   DETACH_NEVER        = Never
24747>>>>>>>>>>>>>>>>>//   DETACH_IF_ALLOWED   = do if changed_state=F and DEO Static_Server
24747>>>>>>>>>>>>>>>>>//   DETACH_IF_NO_CHANGE = do if changed_state=F
24747>>>>>>>>>>>>>>>>>//   DETACH_ALWAYS       = do it no matter what
24747>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>Enumeration_List
24747>>>>>>>>>>>>>>>>>    Define Detach_Never
24747>>>>>>>>>>>>>>>>>    Define Detach_If_No_Change
24747>>>>>>>>>>>>>>>>>    Define Detach_Always
24747>>>>>>>>>>>>>>>>>    Define Detach_If_Allowed
24747>>>>>>>>>>>>>>>>>End_Enumeration_List
24747>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>
24747>>>>>>>>>>>>>>>>>Class server_mixin is a mixin
24748>>>>>>>>>>>>>>>>>    
24748>>>>>>>>>>>>>>>>>    //   Server is the object id of the database agent for this object.
24748>>>>>>>>>>>>>>>>>    //
24748>>>>>>>>>>>>>>>>>    //   Watched_Servers is a set of object ids for database agents whose state
24748>>>>>>>>>>>>>>>>>    //   must also be monitored by this object (but which never receive requests
24748>>>>>>>>>>>>>>>>>    //   directly from this object, unlike the Server).
24748>>>>>>>>>>>>>>>>>    //
24748>>>>>>>>>>>>>>>>>    //   Servers_Scanned determines if the items of this object have been
24748>>>>>>>>>>>>>>>>>    //   scanned to see if this object should be connected to other database
24748>>>>>>>>>>>>>>>>>    //   agents as 'just watching' (see Watched_Servers, above).
24748>>>>>>>>>>>>>>>>>    //
24748>>>>>>>>>>>>>>>>>    //   Auto_Fill_State determines if this object should always automatically
24748>>>>>>>>>>>>>>>>>    //   fill itself with data when it is activated.
24748>>>>>>>>>>>>>>>>>    //
24748>>>>>>>>>>>>>>>>>    //   Deferred_State determines if this object's browsing in database files
24748>>>>>>>>>>>>>>>>>    //   should be reflected immediately in this object's database agent (and
24748>>>>>>>>>>>>>>>>>    //   the agents' agents, etc.), or not.
24748>>>>>>>>>>>>>>>>>    //
24748>>>>>>>>>>>>>>>>>    //
24748>>>>>>>>>>>>>>>>>    Procedure define_server
24750>>>>>>>>>>>>>>>>>        Integer obj#
24750>>>>>>>>>>>>>>>>>        Property Integer private.Server           0
24751>>>>>>>>>>>>>>>>>        Property Integer Watched_Servers          0
24752>>>>>>>>>>>>>>>>>        // used to send Set Changed_State to "foreign" servers, while Watched_Servers
24752>>>>>>>>>>>>>>>>>        // is used for sending messages from the DDO to DEOs (there are more of them)
24752>>>>>>>>>>>>>>>>>        Property Integer ChangedStateWatched_Servers     0
24753>>>>>>>>>>>>>>>>>        Property Integer private.Servers_Scanned  0
24754>>>>>>>>>>>>>>>>>        
24754>>>>>>>>>>>>>>>>>        Property Integer Auto_Fill_State False
24755>>>>>>>>>>>>>>>>>        Property Boolean pbAutoFillOnInit True      // Used to tell DDO's that we want autofill on initialization when DEO is attaching
24756>>>>>>>>>>>>>>>>>        
24756>>>>>>>>>>>>>>>>>        Property Integer Deferred_State  False
24757>>>>>>>>>>>>>>>>>        
24757>>>>>>>>>>>>>>>>>        // added to support DEO request-delegation. This is set true
24757>>>>>>>>>>>>>>>>>        // if the server is explicitly set in this DEO (normally via a
24757>>>>>>>>>>>>>>>>>        // USING parameter).
24757>>>>>>>>>>>>>>>>>        Property Integer explicit_server_state False
24758>>>>>>>>>>>>>>>>>        
24758>>>>>>>>>>>>>>>>>        // Since this package's SET changed_state is using change_
24758>>>>>>>>>>>>>>>>>        // disabled_state we might as well define it here. This gets changed
24758>>>>>>>>>>>>>>>>>        // by Clear_mx to support setting of defaults without changing the
24758>>>>>>>>>>>>>>>>>        // objects changed_state.
24758>>>>>>>>>>>>>>>>>        
24758>>>>>>>>>>>>>>>>>        // This stops changed_state from getting changed. It allows item_changed_
24758>>>>>>>>>>>>>>>>>        // state to chagne without the object's changed_state getting changed.
24758>>>>>>>>>>>>>>>>>        // This should be considered protected (i.e., likely to change). The new
24758>>>>>>>>>>>>>>>>>        // messages Entry_Defaults and Set Default_Value are both public and use
24758>>>>>>>>>>>>>>>>>        // this. Try to use these messages instead of this property.
24758>>>>>>>>>>>>>>>>>        Property Integer Change_Disabled_State  False
24759>>>>>>>>>>>>>>>>>        
24759>>>>>>>>>>>>>>>>>        // If true DEO will not disconnect from server when deactivating.
24759>>>>>>>>>>>>>>>>>        // If true View should handles attaching and detaching.
24759>>>>>>>>>>>>>>>>>        Register_Function Default_static_server_state Returns Integer
24759>>>>>>>>>>>>>>>>>        Property Integer Static_Server_State  (Default_Static_Server_State(Self))
24760>>>>>>>>>>>>>>>>>        
24760>>>>>>>>>>>>>>>>>        // Properties to better support tables. If Refresh_dirty_state
24760>>>>>>>>>>>>>>>>>        // is true then the list object needs refreshing (because it was inactive
24760>>>>>>>>>>>>>>>>>        // and changes were made that were not updated). After add_focus is
24760>>>>>>>>>>>>>>>>>        // complete the add_focus_msg is sent (allows tables to initialize the
24760>>>>>>>>>>>>>>>>>        // list).
24760>>>>>>>>>>>>>>>>>        Property Integer Refresh_dirty_state  True // when not active/dirty
24761>>>>>>>>>>>>>>>>>        Property Integer Add_focus_msg        0    // by dflt no message
24762>>>>>>>>>>>>>>>>>        
24762>>>>>>>>>>>>>>>>>        // This will call a stub procedure which will be augmented (or replaced)
24762>>>>>>>>>>>>>>>>>        // by the xdeo mixins
24762>>>>>>>>>>>>>>>>>        Send Define_Extended_DEO_Mixin
24763>>>>>>>>>>>>>>>>>        
24763>>>>>>>>>>>>>>>>>    End_Procedure
24764>>>>>>>>>>>>>>>>>    
24764>>>>>>>>>>>>>>>>>    
24764>>>>>>>>>>>>>>>>>    Procedure remove_deo_from_server
24766>>>>>>>>>>>>>>>>>        Integer obj# isclient wsrvr
24766>>>>>>>>>>>>>>>>>        Get Server to obj#
24767>>>>>>>>>>>>>>>>>        // as of 17.0, containers will be added as a DEO so it receives the Refresh message
24767>>>>>>>>>>>>>>>>>        If (obj# <> 0) ;            Send remove_user_interface to obj# Self
24770>>>>>>>>>>>>>>>>>        Get Watched_Servers to wsrvr
24771>>>>>>>>>>>>>>>>>        If wsrvr ;            Send remove_user_interface to wsrvr Self True // TRUE for watchers
24774>>>>>>>>>>>>>>>>>        Set Refresh_dirty_state to True
24775>>>>>>>>>>>>>>>>>    End_Procedure
24776>>>>>>>>>>>>>>>>>    
24776>>>>>>>>>>>>>>>>>    
24776>>>>>>>>>>>>>>>>>    //   This function returns the object id of the database server which
24776>>>>>>>>>>>>>>>>>    //   encloses this object, if any.  Note that only the Data_Set class
24776>>>>>>>>>>>>>>>>>    //   defines this function to return anything other than 0.
24776>>>>>>>>>>>>>>>>>    //
24776>>>>>>>>>>>>>>>>>    //   This function is used with delegation to locate the Data_Set
24776>>>>>>>>>>>>>>>>>    //   which is the closest parent of this object.
24776>>>>>>>>>>>>>>>>>    //
24776>>>>>>>>>>>>>>>>>    Function Find_Server Returns Integer
24778>>>>>>>>>>>>>>>>>    End_Function
24779>>>>>>>>>>>>>>>>>    
24779>>>>>>>>>>>>>>>>>    Register_Function Server Returns Integer
24779>>>>>>>>>>>>>>>>>    
24779>>>>>>>>>>>>>>>>>    
24779>>>>>>>>>>>>>>>>>    //   This function returns the object id of the database agent of this object,
24779>>>>>>>>>>>>>>>>>    //   or 0.
24779>>>>>>>>>>>>>>>>>    Function Locate_Server Returns Integer
24781>>>>>>>>>>>>>>>>>        Function_Return (Server(Self))
24782>>>>>>>>>>>>>>>>>    End_Function
24783>>>>>>>>>>>>>>>>>    
24783>>>>>>>>>>>>>>>>>    
24783>>>>>>>>>>>>>>>>>    //   This function returns the object id of the database agent of this
24783>>>>>>>>>>>>>>>>>    //   object, or 0.
24783>>>>>>>>>>>>>>>>>    //   If this object's Server is 0, this object's parent's Server is
24783>>>>>>>>>>>>>>>>>    //   returned, if any.
24783>>>>>>>>>>>>>>>>>    //
24783>>>>>>>>>>>>>>>>>    // Notes
24783>>>>>>>>>>>>>>>>>    //
24783>>>>>>>>>>>>>>>>>    //   This function is used to allow nested data-entry objects to use the
24783>>>>>>>>>>>>>>>>>    //   database agent defined by their parent object.
24783>>>>>>>>>>>>>>>>>    //
24783>>>>>>>>>>>>>>>>>    Function Server Returns Integer
24785>>>>>>>>>>>>>>>>>        Integer obj#
24785>>>>>>>>>>>>>>>>>        Get private.Server to obj#
24786>>>>>>>>>>>>>>>>>        If (obj# = 0 and Component_State(Self)) ;            Function_Return (Locate_Server(parent(Self)))
24789>>>>>>>>>>>>>>>>>        Function_Return obj#
24790>>>>>>>>>>>>>>>>>    End_Function
24791>>>>>>>>>>>>>>>>>    
24791>>>>>>>>>>>>>>>>>    
24791>>>>>>>>>>>>>>>>>    //   This procedure sets the value of the Server property of this object,
24791>>>>>>>>>>>>>>>>>    //   notifying child-objects of the change, and destroying and creating
24791>>>>>>>>>>>>>>>>>    //   connections with database agents, as required.
24791>>>>>>>>>>>>>>>>>    //
24791>>>>>>>>>>>>>>>>>    //   If the Server of this object is changed while this object is inactive,
24791>>>>>>>>>>>>>>>>>    //   no notification of child-objects is required or performed.
24791>>>>>>>>>>>>>>>>>    Procedure Set Server Integer newVal
24793>>>>>>>>>>>>>>>>>        Integer oldVal
24793>>>>>>>>>>>>>>>>>        Set explicit_server_state to (newVal <> 0)
24794>>>>>>>>>>>>>>>>>        Get Server to oldVal
24795>>>>>>>>>>>>>>>>>        If (newVal <> 0) ;            Set private.Server to (object_id(newVal))
24798>>>>>>>>>>>>>>>>>        Else ;            Set private.Server to newVal
24800>>>>>>>>>>>>>>>>>        If (active_state(Self)) Begin
24802>>>>>>>>>>>>>>>>>            Broadcast Send server_changed oldVal newVal
24804>>>>>>>>>>>>>>>>>            If (oldVal <> 0) ;                Send remove_deo_from_server  //detach from current server
24807>>>>>>>>>>>>>>>>>            If (newval <> 0) ;                Send attach_deo_to_server    //attach to new server
24810>>>>>>>>>>>>>>>>>        End
24810>>>>>>>>>>>>>>>>>>
24810>>>>>>>>>>>>>>>>>    End_Procedure
24811>>>>>>>>>>>>>>>>>    
24811>>>>>>>>>>>>>>>>>    //   This procedure servers as notification of a change in the connection
24811>>>>>>>>>>>>>>>>>    //   of this object's parent to its database agent.  If this object uses
24811>>>>>>>>>>>>>>>>>    //   its parent's database agent by default (see the Server and Find_Server
24811>>>>>>>>>>>>>>>>>    //   functions, above), it must disconnect from the old agent and connect
24811>>>>>>>>>>>>>>>>>    //   with the new agent.
24811>>>>>>>>>>>>>>>>>    Procedure server_changed Integer oldVal Integer newVal
24813>>>>>>>>>>>>>>>>>        Integer oldSrvr
24813>>>>>>>>>>>>>>>>>        // as of 17.0, containers will be added as a DEO so it receives the Refresh message
24813>>>>>>>>>>>>>>>>>        Get private.Server to oldSrvr
24814>>>>>>>>>>>>>>>>>        If (oldSrvr = 0) Begin  //assumes Server(self) = oldVal by deleg
24816>>>>>>>>>>>>>>>>>            If (oldVal <> 0) ;                Send remove_user_interface to oldVal Self
24819>>>>>>>>>>>>>>>>>            If (newVal <> 0) ;                Send add_user_interface to newVal Self
24822>>>>>>>>>>>>>>>>>        End
24822>>>>>>>>>>>>>>>>>>
24822>>>>>>>>>>>>>>>>>    End_Procedure
24823>>>>>>>>>>>>>>>>>    
24823>>>>>>>>>>>>>>>>>    
24823>>>>>>>>>>>>>>>>>    //   This procedure empties the Watched_Servers broadcaster, after
24823>>>>>>>>>>>>>>>>>    //   detaching this object from all of the broadcaster's elements.
24823>>>>>>>>>>>>>>>>>    //   This procedure is invoked by Find_Servers_to_Watch, in preparation
24823>>>>>>>>>>>>>>>>>    //   for a scan. Deletes both sets of watched servers
24823>>>>>>>>>>>>>>>>>    //
24823>>>>>>>>>>>>>>>>>    Procedure delete_watched_servers
24825>>>>>>>>>>>>>>>>>        Integer vis#
24825>>>>>>>>>>>>>>>>>        
24825>>>>>>>>>>>>>>>>>        Get watched_servers to vis#
24826>>>>>>>>>>>>>>>>>        If vis# Begin
24828>>>>>>>>>>>>>>>>>            Send Remove_User_Interface to vis# Self True //detach from all, TRUE for watchers
24829>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24830>>>>>>>>>>>>>>>>>            Send delete_Data to vis#                    //empty it
24831>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24832>>>>>>>>>>>>>>>>>        End
24832>>>>>>>>>>>>>>>>>>
24832>>>>>>>>>>>>>>>>>        
24832>>>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to vis#
24833>>>>>>>>>>>>>>>>>        If vis# Begin
24835>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24836>>>>>>>>>>>>>>>>>            Send delete_Data to vis#                    //empty it
24837>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24838>>>>>>>>>>>>>>>>>        End
24838>>>>>>>>>>>>>>>>>>
24838>>>>>>>>>>>>>>>>>    End_Procedure
24839>>>>>>>>>>>>>>>>>    
24839>>>>>>>>>>>>>>>>>    //   This procedure adds the specified object id (obj#) to this object's
24839>>>>>>>>>>>>>>>>>    //   set of database agents who are merely 'watched', and establishes a
24839>>>>>>>>>>>>>>>>>    //   connection between the database agent and this object.
24839>>>>>>>>>>>>>>>>>    Procedure add_watched_server Integer obj#
24841>>>>>>>>>>>>>>>>>        Integer vis# ndx
24841>>>>>>>>>>>>>>>>>        Get watched_servers to vis#
24842>>>>>>>>>>>>>>>>>        // if w server does not exist, first create it
24842>>>>>>>>>>>>>>>>>        If (Vis# = 0) Begin
24844>>>>>>>>>>>>>>>>>            Get Create of Desktop U_Broadcaster to Vis#
24845>>>>>>>>>>>>>>>>>            Set Watched_Servers to Vis#
24846>>>>>>>>>>>>>>>>>        End
24846>>>>>>>>>>>>>>>>>>
24846>>>>>>>>>>>>>>>>>        //
24846>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to False
24847>>>>>>>>>>>>>>>>>        Get find_element of vis# obj# to ndx
24848>>>>>>>>>>>>>>>>>        If (ndx < 0) ;            Send add_element to vis# obj#
24851>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to True
24852>>>>>>>>>>>>>>>>>        If (ndx lt 0 and active_State(Self)) ;            Send add_user_interface to obj# Self True // TRUE for watchers
24855>>>>>>>>>>>>>>>>>    End_Procedure
24856>>>>>>>>>>>>>>>>>    
24856>>>>>>>>>>>>>>>>>    Procedure add_ChangedStateWatched_Servers Integer obj#
24858>>>>>>>>>>>>>>>>>        Integer vis# ndx
24858>>>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to vis#
24859>>>>>>>>>>>>>>>>>        If (Vis# = 0) Begin
24861>>>>>>>>>>>>>>>>>            Get Create of Desktop U_Broadcaster to Vis#
24862>>>>>>>>>>>>>>>>>            Set ChangedStateWatched_Servers to Vis#
24863>>>>>>>>>>>>>>>>>        End
24863>>>>>>>>>>>>>>>>>>
24863>>>>>>>>>>>>>>>>>        //
24863>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to False
24864>>>>>>>>>>>>>>>>>        Get find_element of vis# obj# to ndx
24865>>>>>>>>>>>>>>>>>        If (ndx < 0) ;            Send add_element to vis# obj#
24868>>>>>>>>>>>>>>>>>        Set broadcast_state of vis# to True
24869>>>>>>>>>>>>>>>>>    End_Procedure
24870>>>>>>>>>>>>>>>>>    
24870>>>>>>>>>>>>>>>>>    
24870>>>>>>>>>>>>>>>>>    //   This procedure removes the specified object id (obj#) from this object's
24870>>>>>>>>>>>>>>>>>    //   set of database agents who are merely 'watched', and destroys the
24870>>>>>>>>>>>>>>>>>    //   connection between the database agent and this object.
24870>>>>>>>>>>>>>>>>>    Procedure remove_watched_server Integer obj#
24872>>>>>>>>>>>>>>>>>        Integer vis# ndx
24872>>>>>>>>>>>>>>>>>        Get watched_servers to vis#
24873>>>>>>>>>>>>>>>>>        // Only if w server exists
24873>>>>>>>>>>>>>>>>>        If vis# Begin
24875>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to False
24876>>>>>>>>>>>>>>>>>            Get find_element of vis# obj# to ndx
24877>>>>>>>>>>>>>>>>>            If (ndx >= 0) ;                Send remove_element to vis# obj#
24880>>>>>>>>>>>>>>>>>            Set broadcast_state of vis# to True
24881>>>>>>>>>>>>>>>>>            If (ndx >= 0 and active_State(Self)) ;                Send remove_user_interface to obj# Self True // TRUE for watchers
24884>>>>>>>>>>>>>>>>>        End
24884>>>>>>>>>>>>>>>>>>
24884>>>>>>>>>>>>>>>>>    End_Procedure
24885>>>>>>>>>>>>>>>>>    
24885>>>>>>>>>>>>>>>>>    //   This procedure causes the scanning of this object's items' fields,
24885>>>>>>>>>>>>>>>>>    //   and the production of a set of database agents who should be 'watched'.
24885>>>>>>>>>>>>>>>>>    //   This procedure depends completely upon Find_Servers_To_Watch, below.
24885>>>>>>>>>>>>>>>>>    //
24885>>>>>>>>>>>>>>>>>    Procedure Scan_Servers
24887>>>>>>>>>>>>>>>>>        Send find_servers_to_watch False
24888>>>>>>>>>>>>>>>>>    End_Procedure
24889>>>>>>>>>>>>>>>>>    
24889>>>>>>>>>>>>>>>>>    //   This procedure scans the fields of this object's items to determine
24889>>>>>>>>>>>>>>>>>    //   what other database agents (data_sets) other than this object's Server
24889>>>>>>>>>>>>>>>>>    //   should be 'watched' (for data changes).
24889>>>>>>>>>>>>>>>>>    //   This procedure is invoked once per object, the first time the object
24889>>>>>>>>>>>>>>>>>    //   is activated.  If the data_file, data_field, and/or main_file of this
24889>>>>>>>>>>>>>>>>>    //   object are changed (don't change them while this object is active!),
24889>>>>>>>>>>>>>>>>>    //   set Private.Servers_Scanned to FALSE to force this object to scan
24889>>>>>>>>>>>>>>>>>    //   again (when it is next activated).
24889>>>>>>>>>>>>>>>>>    //
24889>>>>>>>>>>>>>>>>>    
24889>>>>>>>>>>>>>>>>>    // 17.0: The logic has been retooled to add more watched servers to the DDOs. This is done so
24889>>>>>>>>>>>>>>>>>    // DD operations will send Refresh to these additional watched-servers. There are two changes:
24889>>>>>>>>>>>>>>>>>    // 1. Containers are now made watched servers for the Server and all parent servers
24889>>>>>>>>>>>>>>>>>    // 2. Non-file.field DEOs (e.g., expressions) are made watched servers for the server (which it
24889>>>>>>>>>>>>>>>>>    //    already did and for all parent servers. Without this, parent entry_item expressions were not
24889>>>>>>>>>>>>>>>>>    //    getting updated
24889>>>>>>>>>>>>>>>>>    // Here is how watched-servers works.
24889>>>>>>>>>>>>>>>>>    // Each DEO attaches and detaches from its Server by sending Add_User_interface and Remove_User_interface
24889>>>>>>>>>>>>>>>>>    // to the server DD. Once attached, the DD knows about this DEO and sends messages to it as needed (Refresh,
24889>>>>>>>>>>>>>>>>>    // Entry_Update, etc.). In addition, a DEO may need to attach a parent DDO so that changes in that parent DD
24889>>>>>>>>>>>>>>>>>    // results in those messages being sent. This is needed if the binding table in entry_item refers to a parent
24889>>>>>>>>>>>>>>>>>    // table. So we need to send Add_User_interface and Remove_User_interface to that parent server as well. If a DEO
24889>>>>>>>>>>>>>>>>>    // has multiple, there could be multiple parent servers. As of 17.0, we are also attaching to parent servers if
24889>>>>>>>>>>>>>>>>>    // we are unsure about how the DEO is being used. If an expression is used, it might need to be updated when
24889>>>>>>>>>>>>>>>>>    // a parent (or any ancestor) changes. Each DEO keeps track of servers that it attaches to and this is referred
24889>>>>>>>>>>>>>>>>>    // to as the watched_server list. This list is maintained so the DEO knows which DDOs to attach and detach to.
24889>>>>>>>>>>>>>>>>>    
24889>>>>>>>>>>>>>>>>>    
24889>>>>>>>>>>>>>>>>>    Procedure find_servers_to_watch Integer tableFlag
24891>>>>>>>>>>>>>>>>>        Integer i file# obj# maxitems count p srvr# self# srvrfile
24891>>>>>>>>>>>>>>>>>        String fileStr fStr
24891>>>>>>>>>>>>>>>>>        Boolean bContainer bDoAll
24891>>>>>>>>>>>>>>>>>        
24891>>>>>>>>>>>>>>>>>        Get Client_Area_State to bContainer
24892>>>>>>>>>>>>>>>>>        Set private.Servers_Scanned to True
24893>>>>>>>>>>>>>>>>>        
24893>>>>>>>>>>>>>>>>>        Get Server to srvr#
24894>>>>>>>>>>>>>>>>>        
24894>>>>>>>>>>>>>>>>>        If (srvr#=0) Begin
24896>>>>>>>>>>>>>>>>>            Procedure_Return
24897>>>>>>>>>>>>>>>>>        End
24897>>>>>>>>>>>>>>>>>>
24897>>>>>>>>>>>>>>>>>        
24897>>>>>>>>>>>>>>>>>        Send delete_watched_servers  //empty Watched_Servers broadcaster first
24898>>>>>>>>>>>>>>>>>        
24898>>>>>>>>>>>>>>>>>        Get main_file of srvr# to srvrfile  // data-set's main-file
24899>>>>>>>>>>>>>>>>>        
24899>>>>>>>>>>>>>>>>>        If bContainer Begin
24901>>>>>>>>>>>>>>>>>            // containers should get added to all parent DDOs
24901>>>>>>>>>>>>>>>>>            Send WatchAllParentServers srvr#
24902>>>>>>>>>>>>>>>>>            Procedure_Return
24903>>>>>>>>>>>>>>>>>        End
24903>>>>>>>>>>>>>>>>>>
24903>>>>>>>>>>>>>>>>>        
24903>>>>>>>>>>>>>>>>>        If (tableFlag <> 0) ;            Get Prototype_Object to self# // tables
24906>>>>>>>>>>>>>>>>>        Else ;            Move Self to self# // forms and text windows
24908>>>>>>>>>>>>>>>>>        
24908>>>>>>>>>>>>>>>>>        Get item_count of self# to maxitems
24909>>>>>>>>>>>>>>>>>        Decrement maxitems
24910>>>>>>>>>>>>>>>>>        
24910>>>>>>>>>>>>>>>>>        // if no items do nothing
24910>>>>>>>>>>>>>>>>>        // if one item do quick check
24910>>>>>>>>>>>>>>>>>        // if multiple items do it the hard way
24910>>>>>>>>>>>>>>>>>        
24910>>>>>>>>>>>>>>>>>        If (maxitems<0) Begin
24912>>>>>>>>>>>>>>>>>            // if no items, which is unusual, we don't know what this DEO is so we will treat it like a container
24912>>>>>>>>>>>>>>>>>            // and add it as a watched server for all DDOs
24912>>>>>>>>>>>>>>>>>            Send WatchAllParentServers srvr#
24913>>>>>>>>>>>>>>>>>            Procedure_Return  // no items
24914>>>>>>>>>>>>>>>>>        End
24914>>>>>>>>>>>>>>>>>>
24914>>>>>>>>>>>>>>>>>        
24914>>>>>>>>>>>>>>>>>        If (maxitems=0) Begin // only 1 item - skip most of the nonsense
24916>>>>>>>>>>>>>>>>>            Get data_file of self# 0 to file#
24917>>>>>>>>>>>>>>>>>            // we need watched server if file exists, it is not the main file
24917>>>>>>>>>>>>>>>>>            // and is not an updating file (as opposed to updating data-set).
24917>>>>>>>>>>>>>>>>>            If (file#>0 and file#<>srvrfile) Begin
24919>>>>>>>>>>>>>>>>>                Get which_data_set of srvr# file# to obj#
24920>>>>>>>>>>>>>>>>>                If (obj# <> 0 and obj# <> srvr#) Begin
24922>>>>>>>>>>>>>>>>>                    Send add_Watched_server obj#
24923>>>>>>>>>>>>>>>>>                    Send add_ChangedStateWatched_Servers obj#
24924>>>>>>>>>>>>>>>>>                End
24924>>>>>>>>>>>>>>>>>>
24924>>>>>>>>>>>>>>>>>            End
24924>>>>>>>>>>>>>>>>>>
24924>>>>>>>>>>>>>>>>>            Else If (file#=0) Begin
24927>>>>>>>>>>>>>>>>>                // if no file (e.g., expression) we don't know when it changes so we tell all servers
24927>>>>>>>>>>>>>>>>>                // that this is a watcher
24927>>>>>>>>>>>>>>>>>                Send WatchAllParentServers srvr#
24928>>>>>>>>>>>>>>>>>            End
24928>>>>>>>>>>>>>>>>>>
24928>>>>>>>>>>>>>>>>>            If File# ;                Send Copy_Item_Options Srvr# file# (Data_Field(Self#,0)) Self# 0
24931>>>>>>>>>>>>>>>>>        End
24931>>>>>>>>>>>>>>>>>>
24931>>>>>>>>>>>>>>>>>        Else Begin  // multiple items - do what you must
24932>>>>>>>>>>>>>>>>>            Move -1 to count
24933>>>>>>>>>>>>>>>>>            Move "," to fileStr
24934>>>>>>>>>>>>>>>>>            If tableFlag Begin
24936>>>>>>>>>>>>>>>>>                Get main_file to file#
24937>>>>>>>>>>>>>>>>>                If (file# <> srvrfile) Begin    // only do this if mainfile is not the srvr file
24939>>>>>>>>>>>>>>>>>                    Append fileStr file# ","   //insert mainfile to be sure it's watched
24941>>>>>>>>>>>>>>>>>                    Increment count
24942>>>>>>>>>>>>>>>>>                End
24942>>>>>>>>>>>>>>>>>>
24942>>>>>>>>>>>>>>>>>            End
24942>>>>>>>>>>>>>>>>>>
24942>>>>>>>>>>>>>>>>>            For i from 0 to maxitems
24948>>>>>>>>>>>>>>>>>>
24948>>>>>>>>>>>>>>>>>                Get data_file of self# i to file#
24949>>>>>>>>>>>>>>>>>                If (file#=0) Begin
24951>>>>>>>>>>>>>>>>>                    // as soon as we don't know what the item is used for we will have
24951>>>>>>>>>>>>>>>>>                    // to attach to all parent DDOs.
24951>>>>>>>>>>>>>>>>>                    Move True to bDoAll
24952>>>>>>>>>>>>>>>>>                End
24952>>>>>>>>>>>>>>>>>>
24952>>>>>>>>>>>>>>>>>                If (file# > 0 and file#<>srvrfile and ;                    not(fileStr contains (","+String(file#)+",")) ) Begin
24954>>>>>>>>>>>>>>>>>                    Move (fileStr+String(file#) + ",") to fileStr
24955>>>>>>>>>>>>>>>>>                    Increment count
24956>>>>>>>>>>>>>>>>>                End
24956>>>>>>>>>>>>>>>>>>
24956>>>>>>>>>>>>>>>>>                If File# ;                    Send Copy_Item_Options Srvr# file# (Data_Field(Self#,i)) Self# i
24959>>>>>>>>>>>>>>>>>            Loop
24960>>>>>>>>>>>>>>>>>>
24960>>>>>>>>>>>>>>>>>            
24960>>>>>>>>>>>>>>>>>            // if an item's binding table is unknown, we watch all parent DDOs.
24960>>>>>>>>>>>>>>>>>            If bDoAll Begin
24962>>>>>>>>>>>>>>>>>                Send WatchAllParentServers srvr#
24963>>>>>>>>>>>>>>>>>            End
24963>>>>>>>>>>>>>>>>>>
24963>>>>>>>>>>>>>>>>>            Else Begin
24964>>>>>>>>>>>>>>>>>                If (count >= 0) Begin // any watched items?
24966>>>>>>>>>>>>>>>>>                    Move (Right(fileStr, length(fileStr) - 1))  to fileStr  //remove leading comma
24967>>>>>>>>>>>>>>>>>                    For i from 0 to count
24973>>>>>>>>>>>>>>>>>>
24973>>>>>>>>>>>>>>>>>                        Move (Pos( "," ,fileStr)) to p
24974>>>>>>>>>>>>>>>>>                        If (p > 1) Begin
24976>>>>>>>>>>>>>>>>>                            Move (Left( fileStr , p-1)) to fStr
24977>>>>>>>>>>>>>>>>>                            Move (Right( fileStr, length(fileStr) - p)) to fileStr
24978>>>>>>>>>>>>>>>>>                            Move fStr to file#
24979>>>>>>>>>>>>>>>>>                            Get which_data_set of srvr# file# to obj#
24980>>>>>>>>>>>>>>>>>                            If (obj# <> 0 and obj# <> srvr#) Begin
24982>>>>>>>>>>>>>>>>>                                Send add_Watched_server obj#
24983>>>>>>>>>>>>>>>>>                                Send add_ChangedStateWatched_Servers obj#
24984>>>>>>>>>>>>>>>>>                            End
24984>>>>>>>>>>>>>>>>>>
24984>>>>>>>>>>>>>>>>>                        End
24984>>>>>>>>>>>>>>>>>>
24984>>>>>>>>>>>>>>>>>                    Loop
24985>>>>>>>>>>>>>>>>>>
24985>>>>>>>>>>>>>>>>>                End
24985>>>>>>>>>>>>>>>>>>
24985>>>>>>>>>>>>>>>>>            End
24985>>>>>>>>>>>>>>>>>>
24985>>>>>>>>>>>>>>>>>        End
24985>>>>>>>>>>>>>>>>>>
24985>>>>>>>>>>>>>>>>>    End_Procedure
24986>>>>>>>>>>>>>>>>>    
24986>>>>>>>>>>>>>>>>>    // This does nothing. Other sub-classes (or later mixins) should add
24986>>>>>>>>>>>>>>>>>    // logic to this.
24986>>>>>>>>>>>>>>>>>    Procedure Copy_Item_Options Integer iDSO Integer iFile Integer iField ;            Integer iDEO Integer iItem
24988>>>>>>>>>>>>>>>>>    End_Procedure
24989>>>>>>>>>>>>>>>>>    
24989>>>>>>>>>>>>>>>>>    // This does little. Other sub-classes (or later mixins) should add
24989>>>>>>>>>>>>>>>>>    // logic to this.
24989>>>>>>>>>>>>>>>>>    Procedure Define_Extended_DEO_Mixin
24991>>>>>>>>>>>>>>>>>    End_Procedure
24992>>>>>>>>>>>>>>>>>    
24992>>>>>>>>>>>>>>>>>    
24992>>>>>>>>>>>>>>>>>    // created for Nesting support
24992>>>>>>>>>>>>>>>>>    Procedure Mark_As_Component
24994>>>>>>>>>>>>>>>>>        Integer ser#
24994>>>>>>>>>>>>>>>>>        Set Component_State to True
24995>>>>>>>>>>>>>>>>>        Delegate Set Has_Components_State to True
24997>>>>>>>>>>>>>>>>>        Get private.Server to ser#
24998>>>>>>>>>>>>>>>>>        If (ser# = 0) Begin
25000>>>>>>>>>>>>>>>>>            Delegate Get Locate_Server to ser#
25002>>>>>>>>>>>>>>>>>            If (ser# <> 0) ;                Set private.Server to ser#
25005>>>>>>>>>>>>>>>>>        End
25005>>>>>>>>>>>>>>>>>>
25005>>>>>>>>>>>>>>>>>    End_Procedure
25006>>>>>>>>>>>>>>>>>    
25006>>>>>>>>>>>>>>>>>    // This only gets called when the developer is killing this object. During application
25006>>>>>>>>>>>>>>>>>    // shut-down, only destroy_object is called. This augmentation destroys the watched broadcaster
25006>>>>>>>>>>>>>>>>>    // (which is sitting on the desktop). During program shut down we don't care if this is called
25006>>>>>>>>>>>>>>>>>    // because it is getting destroyed anyway. We are making the assumption that a developer controlled
25006>>>>>>>>>>>>>>>>>    // destroy will always be called with the watcher still existing.
25006>>>>>>>>>>>>>>>>>    
25006>>>>>>>>>>>>>>>>>    Procedure Destroy
25008>>>>>>>>>>>>>>>>>        Handle hoWatched
25008>>>>>>>>>>>>>>>>>        Set Changed_State to False //   is this really needed anymore???
25009>>>>>>>>>>>>>>>>>        // if non 0, The watched server, must still exist.
25009>>>>>>>>>>>>>>>>>        Get Watched_Servers to hoWatched
25010>>>>>>>>>>>>>>>>>        If hoWatched Begin
25012>>>>>>>>>>>>>>>>>            Set Broadcast_State of hoWatched to False
25013>>>>>>>>>>>>>>>>>            Send Destroy of hoWatched     // destroy the bcaster
25014>>>>>>>>>>>>>>>>>        End
25014>>>>>>>>>>>>>>>>>>
25014>>>>>>>>>>>>>>>>>        // if non 0, The bound watched server, must still exist.
25014>>>>>>>>>>>>>>>>>        Get ChangedStateWatched_Servers to hoWatched
25015>>>>>>>>>>>>>>>>>        If hoWatched Begin
25017>>>>>>>>>>>>>>>>>            Set Broadcast_State of hoWatched to False
25018>>>>>>>>>>>>>>>>>            Send Destroy of hoWatched     // destroy the bcaster
25019>>>>>>>>>>>>>>>>>        End
25019>>>>>>>>>>>>>>>>>>
25019>>>>>>>>>>>>>>>>>        Forward Send Destroy
25021>>>>>>>>>>>>>>>>>    End_Procedure
25022>>>>>>>>>>>>>>>>>    
25022>>>>>>>>>>>>>>>>>    
25022>>>>>>>>>>>>>>>>>    Function Should_Save Returns Integer
25024>>>>>>>>>>>>>>>>>        Integer Obj# Chngd
25024>>>>>>>>>>>>>>>>>        Get Server to Obj#
25025>>>>>>>>>>>>>>>>>        Get Changed_state to Chngd
25026>>>>>>>>>>>>>>>>>        Function_Return ( Chngd or (obj# <> 0 and Should_Save(obj#)) )
25027>>>>>>>>>>>>>>>>>    End_Function
25028>>>>>>>>>>>>>>>>>    
25028>>>>>>>>>>>>>>>>>    // Added server scan logic here instead of add_focus.
25028>>>>>>>>>>>>>>>>>    Procedure Attach_Deo_To_Server
25030>>>>>>>>>>>>>>>>>        Integer obj# isclient srvscn wsrvr
25030>>>>>>>>>>>>>>>>>        Get Server to obj#
25031>>>>>>>>>>>>>>>>>        Get client_area_state to isclient
25032>>>>>>>>>>>>>>>>>        If (obj# <> 0) ;            Send add_user_interface to obj# Self
25035>>>>>>>>>>>>>>>>>        Get private.Servers_Scanned to srvscn
25036>>>>>>>>>>>>>>>>>        If (srvscn = 0) ;            Send scan_servers
25039>>>>>>>>>>>>>>>>>        Get Watched_Servers to wsrvr
25040>>>>>>>>>>>>>>>>>        If wsrvr Send add_user_interface ;            to wsrvr Self True // TRUE for watchers
25043>>>>>>>>>>>>>>>>>        If (obj# <> 0 and isclient = 0) ;            Send update_dependent_items
25046>>>>>>>>>>>>>>>>>    End_Procedure
25047>>>>>>>>>>>>>>>>>    
25047>>>>>>>>>>>>>>>>>    // Removed server scan logic and moved it to attach-deo_to_server
25047>>>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
25049>>>>>>>>>>>>>>>>>        Integer srvscn retval msg
25049>>>>>>>>>>>>>>>>>        //
25049>>>>>>>>>>>>>>>>>        // standard DEO behavior
25049>>>>>>>>>>>>>>>>>        //
25049>>>>>>>>>>>>>>>>>        Forward Get msg_Add_Focus hoParent to retval
25051>>>>>>>>>>>>>>>>>        If retval ;            Procedure_Return retval
25054>>>>>>>>>>>>>>>>>        
25054>>>>>>>>>>>>>>>>>        If (client_area_State(Self) = 0) ; //clients already broadcast            Broadcast NO_STOP Send add_focus Self
25059>>>>>>>>>>>>>>>>>        //
25059>>>>>>>>>>>>>>>>>        // server augmentation
25059>>>>>>>>>>>>>>>>>        //
25059>>>>>>>>>>>>>>>>>        If (focus_mode(Self) <> NO_ACTIVATE and Active_State(Self)) ;            Send attach_DEO_to_server
25062>>>>>>>>>>>>>>>>>        
25062>>>>>>>>>>>>>>>>>        // last thing to do is send custom message. With list deos
25062>>>>>>>>>>>>>>>>>        // msg is probably initialize_list. With non-list deos it
25062>>>>>>>>>>>>>>>>>        // is probably nothing
25062>>>>>>>>>>>>>>>>>        Get add_focus_msg to msg
25063>>>>>>>>>>>>>>>>>        If msg ;            Send msg
25066>>>>>>>>>>>>>>>>>    End_Procedure
25067>>>>>>>>>>>>>>>>>    
25067>>>>>>>>>>>>>>>>>    // Connect DEO to Server if Demanded (DoAllfg=t) or ;
25067>>>>>>>>>>>>>>>>>    // allowed  (static_server_State=t). Broadcast if children exist
25067>>>>>>>>>>>>>>>>>    Procedure Connect_DEOs_to_Servers Integer DoAllFg
25069>>>>>>>>>>>>>>>>>        If (DoAllfg or Static_Server_State(Self)) ;            Send Attach_Deo_to_Server
25072>>>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Connect_DEOs_to_Servers DoAllfg
25076>>>>>>>>>>>>>>>>>    End_Procedure
25077>>>>>>>>>>>>>>>>>    
25077>>>>>>>>>>>>>>>>>    // Disconnect DEOs from Servers according to rules. Broadcast
25077>>>>>>>>>>>>>>>>>    // to child components.
25077>>>>>>>>>>>>>>>>>    //
25077>>>>>>>>>>>>>>>>>    // Pass: DoAllMode
25077>>>>>>>>>>>>>>>>>    //    DETACH_NEVER        Never
25077>>>>>>>>>>>>>>>>>    //    DETACH_IF_NO_CHANGE Do if changed_state=F
25077>>>>>>>>>>>>>>>>>    //    DETACH_ALWAYS       Do it no matter what
25077>>>>>>>>>>>>>>>>>    //    DETACH_IF_ALLOWED   Do if changed_state=F and auto_attach
25077>>>>>>>>>>>>>>>>>    //                        (I don't think this will be needed!)
25077>>>>>>>>>>>>>>>>>    //
25077>>>>>>>>>>>>>>>>>    Procedure Disconnect_DEOs_from_Servers Integer DoAllMode
25079>>>>>>>>>>>>>>>>>        If (DoAllMode <> DETACH_NEVER) Begin
25081>>>>>>>>>>>>>>>>>            If ( DoAllMode=DETACH_ALWAYS or ; // do all no matter what                ( (Changed_state(Self)=0) and ;                ( (DoAllMode=DETACH_IF_NO_CHANGE) or  ;                (Static_Server_State(Self)) ) ) ) ;                Send Remove_deo_from_server
25084>>>>>>>>>>>>>>>>>            If (Has_Components_State(Self)) ;                Broadcast Send Disconnect_DEOs_from_Servers DoAllMode
25088>>>>>>>>>>>>>>>>>        End
25088>>>>>>>>>>>>>>>>>>
25088>>>>>>>>>>>>>>>>>    End_Procedure
25089>>>>>>>>>>>>>>>>>    
25089>>>>>>>>>>>>>>>>>    // Changed to not remove from server if static.
25089>>>>>>>>>>>>>>>>>    Procedure Remove_Object
25091>>>>>>>>>>>>>>>>>        Forward Send remove_object
25093>>>>>>>>>>>>>>>>>        // remove if not static and no changes
25093>>>>>>>>>>>>>>>>>        If ( Static_Server_State(Self)=0 and ;            Changed_State(Self)=0 ) ;  // only detach if unchanged!            Send remove_DEO_from_server
25096>>>>>>>>>>>>>>>>>    End_Procedure
25097>>>>>>>>>>>>>>>>>    
25097>>>>>>>>>>>>>>>>>    
25097>>>>>>>>>>>>>>>>>    // (JJT) Changed so that this respects Change_disabled_state. I don't
25097>>>>>>>>>>>>>>>>>    //       like this here but its the best I can think of. Therefore, all
25097>>>>>>>>>>>>>>>>>    //       objects using server.pkg must understand Change_disabled_state.
25097>>>>>>>>>>>>>>>>>    //
25097>>>>>>>>>>>>>>>>>    // (JJT) Checks deferred_state and if set do not change the
25097>>>>>>>>>>>>>>>>>    // changed state of the server object. This had been in datalist and is
25097>>>>>>>>>>>>>>>>>    // required to make deferred_state work right. Deferred_state was created
25097>>>>>>>>>>>>>>>>>    // to make selection-lists work correctly and as far as I am concerned it
25097>>>>>>>>>>>>>>>>>    // should be the only supported use of this. Therefore, I would not *ever*
25097>>>>>>>>>>>>>>>>>    // expect deferred_state to be set true in tables, entry_forms, or text_
25097>>>>>>>>>>>>>>>>>    // windows. Since deferred-state is known to this mixin the change
25097>>>>>>>>>>>>>>>>>    // belongs here - but I expect it to only ever change behaviors in
25097>>>>>>>>>>>>>>>>>    // selection-lists.
25097>>>>>>>>>>>>>>>>>    
25097>>>>>>>>>>>>>>>>>    
25097>>>>>>>>>>>>>>>>>    // Changed to not remove from server if static.
25097>>>>>>>>>>>>>>>>>    Procedure Set Changed_State Integer newVal
25099>>>>>>>>>>>>>>>>>        Integer srvr# wsrvr
25099>>>>>>>>>>>>>>>>>        If not (Change_Disabled_State(Self)) Begin
25101>>>>>>>>>>>>>>>>>            Forward Set Changed_State to newVal
25103>>>>>>>>>>>>>>>>>            Get server to srvr#
25104>>>>>>>>>>>>>>>>>            
25104>>>>>>>>>>>>>>>>>            // if deferred keep the server out of it.
25104>>>>>>>>>>>>>>>>>            If not (deferred_State(Self)) Begin
25106>>>>>>>>>>>>>>>>>                If (newVal and srvr#) Begin
25108>>>>>>>>>>>>>>>>>                    Set Changed_State of srvr# to True
25109>>>>>>>>>>>>>>>>>                    // We also set changed_state of all "foreign" servers. These
25109>>>>>>>>>>>>>>>>>                    // are the ones whose Data_File is a parent File
25109>>>>>>>>>>>>>>>>>                    Get ChangedStateWatched_Servers to wsrvr
25110>>>>>>>>>>>>>>>>>                    If wsrvr ;                        Set Changed_State of wSrvr to True
25113>>>>>>>>>>>>>>>>>                End
25113>>>>>>>>>>>>>>>>>>
25113>>>>>>>>>>>>>>>>>                
25113>>>>>>>>>>>>>>>>>                // Remove is changed-state=false, not active and not static
25113>>>>>>>>>>>>>>>>>                If ( not(newVal) and not(Active_State(Self)) and ;                    not(Static_Server_State(Self)) ) ;                    Send remove_DEO_from_Server
25116>>>>>>>>>>>>>>>>>            End
25116>>>>>>>>>>>>>>>>>>
25116>>>>>>>>>>>>>>>>>        End
25116>>>>>>>>>>>>>>>>>>
25116>>>>>>>>>>>>>>>>>    End_Procedure
25117>>>>>>>>>>>>>>>>>    
25117>>>>>>>>>>>>>>>>>    // When an object is created this sets the default value for
25117>>>>>>>>>>>>>>>>>    // Static_Server_state. If a parent DEO exists it will use its
25117>>>>>>>>>>>>>>>>>    // static_server_state property. An Entry_view_Client0 object sets
25117>>>>>>>>>>>>>>>>>    // this - this way view based daf programs will use the new behavior
25117>>>>>>>>>>>>>>>>>    // (although it can be disabled)  but non-daf programs will work like
25117>>>>>>>>>>>>>>>>>    // they always did.
25117>>>>>>>>>>>>>>>>>    Function Default_Static_Server_State Returns Integer
25119>>>>>>>>>>>>>>>>>        Integer rVal
25119>>>>>>>>>>>>>>>>>        // We delegate to get the actual (not default) static state
25119>>>>>>>>>>>>>>>>>        // Note: Can't check with component_state - it not defined yet
25119>>>>>>>>>>>>>>>>>        Delegate Get Static_Server_State to rVal
25121>>>>>>>>>>>>>>>>>        Function_Return rVal
25122>>>>>>>>>>>>>>>>>    End_Function
25123>>>>>>>>>>>>>>>>>    
25123>>>>>>>>>>>>>>>>>    // This adds every parent DDO for the passed DDO to the DEO's list of DDOs to watch.
25123>>>>>>>>>>>>>>>>>    // It adds the parents and then does this recursively up the DDO tree.
25123>>>>>>>>>>>>>>>>>    // This means that this DEO will respond to any DD change for any server. This does not
25123>>>>>>>>>>>>>>>>>    Procedure WatchAllParentServers Handle hoDDO
25125>>>>>>>>>>>>>>>>>        Handle hoSrvr
25125>>>>>>>>>>>>>>>>>        Integer iServer iServers
25125>>>>>>>>>>>>>>>>>        Get Data_Set_Server_Count of hoDDO to iServers
25126>>>>>>>>>>>>>>>>>        For iServer from 0 to (iServers-1)
25132>>>>>>>>>>>>>>>>>>
25132>>>>>>>>>>>>>>>>>            Get Data_Set_Server of hoDDO iServer to hoSrvr
25133>>>>>>>>>>>>>>>>>            Send Add_Watched_Server hoSrvr
25134>>>>>>>>>>>>>>>>>            Send WatchAllParentServers hoSrvr
25135>>>>>>>>>>>>>>>>>        Loop
25136>>>>>>>>>>>>>>>>>>
25136>>>>>>>>>>>>>>>>>    End_Procedure
25137>>>>>>>>>>>>>>>>>    
25137>>>>>>>>>>>>>>>>>    
25137>>>>>>>>>>>>>>>>>End_Class
25138>>>>>>>>>>>>>>>>>
25138>>>>>>>>>>>>>>>>>//
25138>>>>>>>>>>>>>>>>>// The use of using on an object name is no longer supported. We will check for it's usage in case
25138>>>>>>>>>>>>>>>>>// developer's use this in old code.
25138>>>>>>>>>>>>>>>>>// Insetad of using, one should use "Set Server"
25138>>>>>>>>>>>>>>>>>//
25138>>>>>>>>>>>>>>>>>
25138>>>>>>>>>>>>>>>Use VERIFY.pkg        //include Verification support module
Including file: verify.pkg    (C:\Program Files\DataFlex 24.0\Pkg\verify.pkg)
25138>>>>>>>>>>>>>>>>>Use VDFBase.pkg
25138>>>>>>>>>>>>>>>>>
25138>>>>>>>>>>>>>>>>>Register_Function Component_State Returns Integer
25138>>>>>>>>>>>>>>>>>
25138>>>>>>>>>>>>>>>>>
25138>>>>>>>>>>>>>>>>>Class verify_mixin is a mixin
25139>>>>>>>>>>>>>>>>>    Procedure define_verify
25141>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Save_Msg      0
25142>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Delete_Msg    0
25143>>>>>>>>>>>>>>>>>        Property Integer private.Verify_Data_Loss_Msg 0
25144>>>>>>>>>>>>>>>>>    End_Procedure
25145>>>>>>>>>>>>>>>>>    
25145>>>>>>>>>>>>>>>>>    
25145>>>>>>>>>>>>>>>>>    Procedure Set Verify_Save_msg Integer val
25147>>>>>>>>>>>>>>>>>        Set private.Verify_Save_Msg to val
25148>>>>>>>>>>>>>>>>>    End_Procedure
25149>>>>>>>>>>>>>>>>>    
25149>>>>>>>>>>>>>>>>>    Procedure Set Verify_Delete_msg Integer val
25151>>>>>>>>>>>>>>>>>        Set private.Verify_Delete_Msg to val
25152>>>>>>>>>>>>>>>>>    End_Procedure
25153>>>>>>>>>>>>>>>>>    
25153>>>>>>>>>>>>>>>>>    Procedure Set Verify_Data_Loss_msg Integer val
25155>>>>>>>>>>>>>>>>>        Set private.Verify_Data_Loss_Msg to val
25156>>>>>>>>>>>>>>>>>    End_Procedure
25157>>>>>>>>>>>>>>>>>    
25157>>>>>>>>>>>>>>>>>    Function Verify_Save_msg Returns Integer
25159>>>>>>>>>>>>>>>>>        Integer retval
25159>>>>>>>>>>>>>>>>>        Get private.Verify_Save_Msg to retval
25160>>>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Save_Msg to retval
25164>>>>>>>>>>>>>>>>>        Function_Return retval
25165>>>>>>>>>>>>>>>>>    End_Function
25166>>>>>>>>>>>>>>>>>    
25166>>>>>>>>>>>>>>>>>    Function Verify_Delete_msg Returns Integer
25168>>>>>>>>>>>>>>>>>        Integer retval
25168>>>>>>>>>>>>>>>>>        Get private.Verify_Delete_Msg to retval
25169>>>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Delete_Msg to retval
25173>>>>>>>>>>>>>>>>>        Function_Return retval
25174>>>>>>>>>>>>>>>>>    End_Function
25175>>>>>>>>>>>>>>>>>    
25175>>>>>>>>>>>>>>>>>    
25175>>>>>>>>>>>>>>>>>    Function Verify_Data_Loss_msg Returns Integer
25177>>>>>>>>>>>>>>>>>        Integer retval
25177>>>>>>>>>>>>>>>>>        Get private.Verify_Data_Loss_Msg to retval
25178>>>>>>>>>>>>>>>>>        If (retval = 0 and Component_State(Self)) ;            Delegate Get Verify_Data_Loss_Msg to retval
25182>>>>>>>>>>>>>>>>>        Function_Return retval
25183>>>>>>>>>>>>>>>>>    End_Function
25184>>>>>>>>>>>>>>>>>    
25184>>>>>>>>>>>>>>>>>    Function Verify_Save Returns Integer
25186>>>>>>>>>>>>>>>>>        Integer msg# retval
25186>>>>>>>>>>>>>>>>>        Get Verify_Save_Msg to msg#
25187>>>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25189>>>>>>>>>>>>>>>>>            Get msg# to retval
25190>>>>>>>>>>>>>>>>>            Function_Return retval
25191>>>>>>>>>>>>>>>>>        End
25191>>>>>>>>>>>>>>>>>>
25191>>>>>>>>>>>>>>>>>    End_Function
25192>>>>>>>>>>>>>>>>>    
25192>>>>>>>>>>>>>>>>>    Function Verify_Delete Returns Integer
25194>>>>>>>>>>>>>>>>>        Integer msg# retval
25194>>>>>>>>>>>>>>>>>        Get Verify_Delete_Msg to msg#
25195>>>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25197>>>>>>>>>>>>>>>>>            Get msg# to retval
25198>>>>>>>>>>>>>>>>>            Function_Return retval
25199>>>>>>>>>>>>>>>>>        End
25199>>>>>>>>>>>>>>>>>>
25199>>>>>>>>>>>>>>>>>    End_Function
25200>>>>>>>>>>>>>>>>>    
25200>>>>>>>>>>>>>>>>>    Function Verify_Data_Loss Returns Integer
25202>>>>>>>>>>>>>>>>>        Integer msg# retval
25202>>>>>>>>>>>>>>>>>        Get Verify_Data_Loss_Msg to msg#
25203>>>>>>>>>>>>>>>>>        If (msg# <> 0) Begin
25205>>>>>>>>>>>>>>>>>            Get msg# to retval
25206>>>>>>>>>>>>>>>>>            Function_Return retval
25207>>>>>>>>>>>>>>>>>        End
25207>>>>>>>>>>>>>>>>>>
25207>>>>>>>>>>>>>>>>>    End_Function
25208>>>>>>>>>>>>>>>>>    
25208>>>>>>>>>>>>>>>>>End_Class
25209>>>>>>>>>>>>>>>Use ACTIONBR.pkg      //include action-bar support module
Including file: Actionbr.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Actionbr.pkg)
25209>>>>>>>>>>>>>>>>>Use VDFBase.pkg
25209>>>>>>>>>>>>>>>>>
25209>>>>>>>>>>>>>>>>>Class Action_Bar_Mixin is a mixin
25210>>>>>>>>>>>>>>>>>    Procedure Define_Action_bar
25212>>>>>>>>>>>>>>>>>    End_Procedure
25213>>>>>>>>>>>>>>>>>    
25213>>>>>>>>>>>>>>>>>    Procedure Define_Access_Keys
25215>>>>>>>>>>>>>>>>>    End_Procedure
25216>>>>>>>>>>>>>>>>>    
25216>>>>>>>>>>>>>>>>>    Procedure Add_Action_bar
25218>>>>>>>>>>>>>>>>>    End_Procedure
25219>>>>>>>>>>>>>>>>>End_Class
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>Use AutoLcMx.pkg   // Auto locate of popup mixin
25220>>>>>>>>>>>>>>>Use DEODlgMx.pkg   // DEO delegation support
Including file: deodlgmx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\deodlgmx.pkg)
25220>>>>>>>>>>>>>>>>>Use VDFBase.pkg
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>>>Enum_List
25220>>>>>>>>>>>>>>>>>    Define DELEGATE_NEVER
25220>>>>>>>>>>>>>>>>>    Define DELEGATE_SERVER
25220>>>>>>>>>>>>>>>>>    Define DELEGATE_ALWAYS
25220>>>>>>>>>>>>>>>>>End_Enum_List
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>>>Register_Function component_state Returns Integer
25220>>>>>>>>>>>>>>>>>
25220>>>>>>>>>>>>>>>>>Class deo_delegate_mixin is a mixin
25221>>>>>>>>>>>>>>>>>    Procedure define_deo_delegate
25223>>>>>>>>>>>>>>>>>        
25223>>>>>>>>>>>>>>>>>        Property Integer DEO_Delegate_Mode     Delegate_Server
25224>>>>>>>>>>>>>>>>>        
25224>>>>>>>>>>>>>>>>>        Property Integer delegate_clear_state  True
25225>>>>>>>>>>>>>>>>>        
25225>>>>>>>>>>>>>>>>>        Property Integer delegate_delete_state True
25226>>>>>>>>>>>>>>>>>        
25226>>>>>>>>>>>>>>>>>        Property Integer delegate_find_state   False
25227>>>>>>>>>>>>>>>>>        
25227>>>>>>>>>>>>>>>>>        Property Integer delegate_save_state   True
25228>>>>>>>>>>>>>>>>>    End_Procedure
25229>>>>>>>>>>>>>>>>>    
25229>>>>>>>>>>>>>>>>>    Function should_delegate Returns Integer
25231>>>>>>>>>>>>>>>>>        Integer Mode Dlg_Obj
25231>>>>>>>>>>>>>>>>>        
25231>>>>>>>>>>>>>>>>>        Delegate Get Object_Id to Dlg_Obj
25233>>>>>>>>>>>>>>>>>        Get Deo_Delegate_Mode to Mode
25234>>>>>>>>>>>>>>>>>        Function_Return ( (((Mode = DELEGATE_SERVER) and ;            not(Explicit_Server_State(Self)) and ;            (Locate_Server(Self) <> Dlg_Obj)) or ; // don't delegate if the object to delegate to is a server.            (Mode = DELEGATE_ALWAYS)) and Component_State(Self))
25235>>>>>>>>>>>>>>>>>    End_Function
25236>>>>>>>>>>>>>>>>>    
25236>>>>>>>>>>>>>>>>>    Function Should_delegate_Clear Returns Integer
25238>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_clear_state(Self))
25239>>>>>>>>>>>>>>>>>    End_Function
25240>>>>>>>>>>>>>>>>>    
25240>>>>>>>>>>>>>>>>>    Function Should_delegate_Save Returns Integer
25242>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_Save_state(Self))
25243>>>>>>>>>>>>>>>>>    End_Function
25244>>>>>>>>>>>>>>>>>    
25244>>>>>>>>>>>>>>>>>    Function Should_delegate_Delete Returns Integer
25246>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_delete_state(Self))
25247>>>>>>>>>>>>>>>>>    End_Function
25248>>>>>>>>>>>>>>>>>    
25248>>>>>>>>>>>>>>>>>    Function Should_delegate_Find Returns Integer
25250>>>>>>>>>>>>>>>>>        Function_Return (should_delegate(Self) and ;            delegate_Find_state(Self))
25251>>>>>>>>>>>>>>>>>    End_Function
25252>>>>>>>>>>>>>>>>>    
25252>>>>>>>>>>>>>>>>>End_Class
25253>>>>>>>>>>>>>>>>>
25253>>>>>>>>>>>>>>>>>//  During a clear (or a save/delete which sends clear) object-validation is
25253>>>>>>>>>>>>>>>>>//  properly shut off. However, the false assumption had been made that the
25253>>>>>>>>>>>>>>>>>//  DEO request_clear/clear_all messages originated with the object that had
25253>>>>>>>>>>>>>>>>>//  the focus. This was never true and is now even less likely to be true
25253>>>>>>>>>>>>>>>>>//  with the request_??? delegation method. The proper solution is to shut
25253>>>>>>>>>>>>>>>>>//  off object-validation in the focus object. The problem here is that
25253>>>>>>>>>>>>>>>>>//  the focus object may not understand this message (text_windows, buttons,
25253>>>>>>>>>>>>>>>>>//  etc). The work-around for now is to make sure that all objects understand
25253>>>>>>>>>>>>>>>>>//  these message. We can not directly add an Object_Validation message to the
25253>>>>>>>>>>>>>>>>>//  desktop (Object class). Because this message is internal this didn't work.
25253>>>>>>>>>>>>>>>>>//  By default this does nothing. Objects using val_mx actually pass this on
25253>>>>>>>>>>>>>>>>>//  object_validation.
25253>>>>>>>>>>>>>>>>>
25253>>>>>>>>>>>>>>>>>Procedure Set Object_Item_validation for cUIObject Integer fg
25255>>>>>>>>>>>>>>>>>End_Procedure
25256>>>>>>>>>>>>>>>>>
25256>>>>>>>>>>>>>>>>>Function Object_Item_Validation for cUIObject Returns Integer
25258>>>>>>>>>>>>>>>>>End_Function
25259>>>>>>>>>>>>>>>
25259>>>>>>>>>>>>>>>Register_Procedure Refind_DD_Records
25259>>>>>>>>>>>>>>>
25259>>>>>>>>>>>>>>>Class Entry_Client_mixin is a mixin
25260>>>>>>>>>>>>>>>
25260>>>>>>>>>>>>>>>    Procedure Construct_Object Integer myImg
25262>>>>>>>>>>>>>>>        Forward Send construct_object myImg
25264>>>>>>>>>>>>>>>        Set Ring_State to False
25265>>>>>>>>>>>>>>>        Property Integer private.Changed_State 0
25266>>>>>>>>>>>>>>>        
25266>>>>>>>>>>>>>>>        // We need this property to fully emulate a DEO
25266>>>>>>>>>>>>>>>        // (Actually, entry_clients should realy support ALL the DEO messages!)
25266>>>>>>>>>>>>>>>        Property Integer Auto_Clear_DEO_State True
25267>>>>>>>>>>>>>>>        
25267>>>>>>>>>>>>>>>        Send define_nesting      //invoke DEO nesting standard support constructor
25268>>>>>>>>>>>>>>>        Send define_navigation   //invoke DEO navigation standard support constructor
25269>>>>>>>>>>>>>>>        Send define_server       //invoke Server support constructor
25270>>>>>>>>>>>>>>>        Send define_action_bar   //invoke action-bar support constructor
25271>>>>>>>>>>>>>>>        Send define_verify       //invoke Verification support constructor
25272>>>>>>>>>>>>>>>        Send define_DEO_Delegate
25273>>>>>>>>>>>>>>>        Send Define_Auto_Locate
25274>>>>>>>>>>>>>>>        
25274>>>>>>>>>>>>>>>    End_Procedure
25275>>>>>>>>>>>>>>>    
25275>>>>>>>>>>>>>>>    Import_Class_Protocol NESTING_Mixin
25276>>>>>>>>>>>>>>>    Import_Class_Protocol NAVIGATE_Mixin
25277>>>>>>>>>>>>>>>    Import_Class_Protocol SERVER_Mixin
25278>>>>>>>>>>>>>>>    Import_Class_Protocol VERIFY_Mixin
25279>>>>>>>>>>>>>>>    Import_Class_Protocol ACTION_BAR_Mixin
25280>>>>>>>>>>>>>>>    Import_Class_Protocol Auto_Locate_Mixin
25281>>>>>>>>>>>>>>>    Import_Class_Protocol Deo_Delegate_Mixin
25282>>>>>>>>>>>>>>>    
25282>>>>>>>>>>>>>>>    
25282>>>>>>>>>>>>>>>    //
25282>>>>>>>>>>>>>>>    // created for Server support
25282>>>>>>>>>>>>>>>    //
25282>>>>>>>>>>>>>>>    Procedure Display
25284>>>>>>>>>>>>>>>        Broadcast Send display
25286>>>>>>>>>>>>>>>    End_Procedure
25287>>>>>>>>>>>>>>>    
25287>>>>>>>>>>>>>>>    //
25287>>>>>>>>>>>>>>>    // created for Server support
25287>>>>>>>>>>>>>>>    //
25287>>>>>>>>>>>>>>>    Procedure Clear
25289>>>>>>>>>>>>>>>        Broadcast Send Clear
25291>>>>>>>>>>>>>>>    End_Procedure
25292>>>>>>>>>>>>>>>    
25292>>>>>>>>>>>>>>>    //
25292>>>>>>>>>>>>>>>    // created for Server support
25292>>>>>>>>>>>>>>>    //
25292>>>>>>>>>>>>>>>    Procedure Clear_Set
25294>>>>>>>>>>>>>>>        Broadcast Send clear_set
25296>>>>>>>>>>>>>>>    End_Procedure
25297>>>>>>>>>>>>>>>    
25297>>>>>>>>>>>>>>>    //
25297>>>>>>>>>>>>>>>    // created for property support
25297>>>>>>>>>>>>>>>    //
25297>>>>>>>>>>>>>>>    Function Changed_State Returns Integer
25299>>>>>>>>>>>>>>>        Integer retval
25299>>>>>>>>>>>>>>>        Get Private.Changed_State to retval
25300>>>>>>>>>>>>>>>        Function_Return retval
25301>>>>>>>>>>>>>>>    End_Function
25302>>>>>>>>>>>>>>>    
25302>>>>>>>>>>>>>>>    //
25302>>>>>>>>>>>>>>>    // cancelled from Server mixin
25302>>>>>>>>>>>>>>>    //
25302>>>>>>>>>>>>>>>    Procedure Set Changed_State Integer newVal
25304>>>>>>>>>>>>>>>    End_Procedure
25305>>>>>>>>>>>>>>>    
25305>>>>>>>>>>>>>>>    //
25305>>>>>>>>>>>>>>>    // created for EntItem convenience
25305>>>>>>>>>>>>>>>    //
25305>>>>>>>>>>>>>>>    Procedure Entry_Clear Integer file#
25307>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Clear file#
25311>>>>>>>>>>>>>>>    End_Procedure
25312>>>>>>>>>>>>>>>    
25312>>>>>>>>>>>>>>>    //
25312>>>>>>>>>>>>>>>    // created for EntItem convenience
25312>>>>>>>>>>>>>>>    //
25312>>>>>>>>>>>>>>>    Procedure Entry_Clear_All Integer file#
25314>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Clear_All file#
25318>>>>>>>>>>>>>>>    End_Procedure
25319>>>>>>>>>>>>>>>    
25319>>>>>>>>>>>>>>>    //
25319>>>>>>>>>>>>>>>    // created for EntItem convenience
25319>>>>>>>>>>>>>>>    //
25319>>>>>>>>>>>>>>>    Procedure Entry_Display Integer file# Integer flag
25321>>>>>>>>>>>>>>>        If (Has_Components_State(Self)) ;            Broadcast Send Entry_Display file# flag
25325>>>>>>>>>>>>>>>    End_Procedure
25326>>>>>>>>>>>>>>>    
25326>>>>>>>>>>>>>>>    Procedure End_Construct_Object
25328>>>>>>>>>>>>>>>        Send Mark_Components      // nesting
25329>>>>>>>>>>>>>>>        Send Define_Access_Keys 0 // action_bar_keys
25330>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
25332>>>>>>>>>>>>>>>    End_Procedure
25333>>>>>>>>>>>>>>>    
25333>>>>>>>>>>>>>>>    // Added for deo delegate support
25333>>>>>>>>>>>>>>>    Procedure Request_Clear
25335>>>>>>>>>>>>>>>        Integer obj# retval foc
25335>>>>>>>>>>>>>>>        If (should_delegate_clear(Self)) ;            Delegate Send request_clear
25339>>>>>>>>>>>>>>>        Else Begin
25340>>>>>>>>>>>>>>>            Get Locate_Server to obj# // locate needed in case this is a DSO
25341>>>>>>>>>>>>>>>            If (should_save(Self) and ;                (Verify_Data_Loss(Self) <> 0)) ;                Procedure_Return
25344>>>>>>>>>>>>>>>            
25344>>>>>>>>>>>>>>>            Get Focus of desktop to Foc
25345>>>>>>>>>>>>>>>            Get Object_Item_Validation of Foc to retval
25346>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to False
25347>>>>>>>>>>>>>>>            
25347>>>>>>>>>>>>>>>            If (obj# <> 0) ;                Send Clear to obj#
25350>>>>>>>>>>>>>>>            Else ;                Send entry_clear 0
25352>>>>>>>>>>>>>>>            If (Auto_Top_Panel_State(Self)) ;                Send beginning_of_panel
25355>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to retval
25356>>>>>>>>>>>>>>>        End
25356>>>>>>>>>>>>>>>>
25356>>>>>>>>>>>>>>>    End_Procedure
25357>>>>>>>>>>>>>>>    
25357>>>>>>>>>>>>>>>    Procedure Request_Clear_All
25359>>>>>>>>>>>>>>>        Integer obj# retval foc
25359>>>>>>>>>>>>>>>        If (should_delegate_clear(Self)) ;            Delegate Send request_clear_all
25363>>>>>>>>>>>>>>>        Else Begin
25364>>>>>>>>>>>>>>>            Get Locate_Server to obj#
25365>>>>>>>>>>>>>>>            If (Should_Save(Self) and ;                (Verify_Data_Loss(Self) <> 0)) ;                Procedure_Return
25368>>>>>>>>>>>>>>>            
25368>>>>>>>>>>>>>>>            Get Focus of desktop to Foc
25369>>>>>>>>>>>>>>>            Get Object_Item_Validation of Foc to retval
25370>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to False
25371>>>>>>>>>>>>>>>            
25371>>>>>>>>>>>>>>>            If (obj# <> 0) ;                Send clear_all to obj#
25374>>>>>>>>>>>>>>>            Else ;                Send entry_clear_all 0
25376>>>>>>>>>>>>>>>            If (Auto_Top_Panel_State(Self)) ;                Send beginning_of_panel
25379>>>>>>>>>>>>>>>            Set Object_Item_Validation of Foc to retval
25380>>>>>>>>>>>>>>>        End
25380>>>>>>>>>>>>>>>>
25380>>>>>>>>>>>>>>>    End_Procedure
25381>>>>>>>>>>>>>>>    
25381>>>>>>>>>>>>>>>    Procedure Request_Delete
25383>>>>>>>>>>>>>>>        Integer obj#
25383>>>>>>>>>>>>>>>        
25383>>>>>>>>>>>>>>>        If (should_delegate_delete(Self)) ;            Delegate Send request_delete
25387>>>>>>>>>>>>>>>        Else Begin
25388>>>>>>>>>>>>>>>            Move False to Err
25389>>>>>>>>>>>>>>>            Get Locate_Server to obj#
25390>>>>>>>>>>>>>>>            If (obj# <> 0 and can_delete(obj#) <> 0) Begin
25392>>>>>>>>>>>>>>>                If (Verify_Delete(Self) <> 0) ;                    Procedure_Return
25395>>>>>>>>>>>>>>>                Set changed_State to False
25396>>>>>>>>>>>>>>>                If (Deferred_State(Self)) ;                    Send Request_Assign to obj# 0  //0 means main_file of Server
25399>>>>>>>>>>>>>>>                Send Request_Delete to obj#
25400>>>>>>>>>>>>>>>                // ignore auto_clear_deo_state in deletes. Always clear deleted record
25400>>>>>>>>>>>>>>>                If (not(err)) ;                    Send Request_Clear
25403>>>>>>>>>>>>>>>            End
25403>>>>>>>>>>>>>>>>
25403>>>>>>>>>>>>>>>        End
25403>>>>>>>>>>>>>>>>
25403>>>>>>>>>>>>>>>    End_Procedure
25404>>>>>>>>>>>>>>>    
25404>>>>>>>>>>>>>>>    Procedure Request_Find Integer mode Integer entUpdtFlag
25406>>>>>>>>>>>>>>>        If (should_delegate_find(Self)) ;            Delegate Send request_find mode entUpdtFlag
25410>>>>>>>>>>>>>>>        Else Begin // for now don't support any default find behavior
25411>>>>>>>>>>>>>>>            // in clients
25411>>>>>>>>>>>>>>>            Procedure_Return
25412>>>>>>>>>>>>>>>        End
25412>>>>>>>>>>>>>>>>
25412>>>>>>>>>>>>>>>    End_Procedure
25413>>>>>>>>>>>>>>>    
25413>>>>>>>>>>>>>>>    Procedure Request_Save
25415>>>>>>>>>>>>>>>        Integer obj# retval
25415>>>>>>>>>>>>>>>        
25415>>>>>>>>>>>>>>>        If (should_delegate_save(Self)) ;            Delegate Send request_save
25419>>>>>>>>>>>>>>>        Else Begin
25420>>>>>>>>>>>>>>>            Get Locate_Server to obj#
25421>>>>>>>>>>>>>>>            
25421>>>>>>>>>>>>>>>            If (obj# <> 0 and not(Read_Only_State(obj#))) Begin
25423>>>>>>>>>>>>>>>                Move False to Err
25424>>>>>>>>>>>>>>>                
25424>>>>>>>>>>>>>>>                If (Should_Save(Self)) Begin
25426>>>>>>>>>>>>>>>                    Get Request_Validate of obj# to retval
25427>>>>>>>>>>>>>>>                    If (retval <> 0) ;                        Procedure_Return
25430>>>>>>>>>>>>>>>                    //
25430>>>>>>>>>>>>>>>                    // modification for Verify support
25430>>>>>>>>>>>>>>>                    //
25430>>>>>>>>>>>>>>>                    If (Verify_Save(Self) <> 0) ;                        Procedure_Return
25433>>>>>>>>>>>>>>>                    //
25433>>>>>>>>>>>>>>>                    // modification for Save support
25433>>>>>>>>>>>>>>>                    //
25433>>>>>>>>>>>>>>>                    If (Deferred_State(Self)) ;                        Send Request_Assign to obj# 0  //0 means main_file of server
25436>>>>>>>>>>>>>>>                    
25436>>>>>>>>>>>>>>>                    Send Request_Save to obj#
25437>>>>>>>>>>>>>>>                End
25437>>>>>>>>>>>>>>>>
25437>>>>>>>>>>>>>>>                //
25437>>>>>>>>>>>>>>>                If (not(err) and Auto_Clear_DEO_State(Self)) ;                    Send Request_Clear
25440>>>>>>>>>>>>>>>            End
25440>>>>>>>>>>>>>>>>
25440>>>>>>>>>>>>>>>        End
25440>>>>>>>>>>>>>>>>
25440>>>>>>>>>>>>>>>    End_Procedure
25441>>>>>>>>>>>>>>>    
25441>>>>>>>>>>>>>>>    // this allows us to save a record without it clearing regardless of
25441>>>>>>>>>>>>>>>    // the Auto_Clear_DEO_State value
25441>>>>>>>>>>>>>>>    //
25441>>>>>>>>>>>>>>>    Procedure Request_Save_No_Clear
25443>>>>>>>>>>>>>>>        Integer oldclr
25443>>>>>>>>>>>>>>>        If (should_delegate_save(Self)) ;            Delegate Send request_save_no_clear
25447>>>>>>>>>>>>>>>        Else Begin
25448>>>>>>>>>>>>>>>            Get Auto_Clear_DEO_State to OldClr  // whatever it was
25449>>>>>>>>>>>>>>>            Set Auto_Clear_DEO_State to False   // it is no NO!
25450>>>>>>>>>>>>>>>            Send request_save                   // do your magic
25451>>>>>>>>>>>>>>>            Set Auto_Clear_DEO_State to OldClr  // back to whatever it was
25452>>>>>>>>>>>>>>>        End
25452>>>>>>>>>>>>>>>>
25452>>>>>>>>>>>>>>>    End_Procedure
25453>>>>>>>>>>>>>>>    
25453>>>>>>>>>>>>>>>    Procedure Request_Superfind Integer mode
25455>>>>>>>>>>>>>>>        Integer ser# datafile
25455>>>>>>>>>>>>>>>        
25455>>>>>>>>>>>>>>>        If (should_delegate_find(Self)) ;            Delegate Send request_superfind mode
25459>>>>>>>>>>>>>>>        Else Begin
25460>>>>>>>>>>>>>>>            Procedure_Return
25461>>>>>>>>>>>>>>>        End
25461>>>>>>>>>>>>>>>>
25461>>>>>>>>>>>>>>>    End_Procedure
25462>>>>>>>>>>>>>>>    
25462>>>>>>>>>>>>>>>    //  Augment to Support AutoLocate.
25462>>>>>>>>>>>>>>>    //  This replaces (not augments) the procedure in actionbr. We need
25462>>>>>>>>>>>>>>>    //  to look into this (activating is very risky to augment activating
25462>>>>>>>>>>>>>>>    //  in mixins).
25462>>>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25462>>>>>>>>>>>>>>>    Procedure Activating // Returns Integer
25464>>>>>>>>>>>>>>>        Integer InvokingId RVal
25464>>>>>>>>>>>>>>>        Get Focus of desktop to InvokingId
25465>>>>>>>>>>>>>>>        //
25465>>>>>>>>>>>>>>>        Forward Get MSG_activating to rVal   //  This is the standard
25467>>>>>>>>>>>>>>>        If rVal ;            Procedure_Return rVal        //  actionbr activating
25470>>>>>>>>>>>>>>>        Send Add_action_bar                  //  logic
25471>>>>>>>>>>>>>>>        If (Auto_Locate_State(Self) ) ;            Send Auto_Locate InvokingId
25474>>>>>>>>>>>>>>>    End_Procedure
25475>>>>>>>>>>>>>>>    
25475>>>>>>>>>>>>>>>    // add this so that all db clients delegate this message.
25475>>>>>>>>>>>>>>>    // this is used to catch sub-views (tabview). Tab views (sub
25475>>>>>>>>>>>>>>>    // views) will augment this to do something useful
25475>>>>>>>>>>>>>>>    Function SubView_Changed Returns Integer
25477>>>>>>>>>>>>>>>        Integer hObj
25477>>>>>>>>>>>>>>>        Broadcast Get SubView_Changed to hObj
25479>>>>>>>>>>>>>>>        Function_Return hObj
25480>>>>>>>>>>>>>>>    End_Function
25481>>>>>>>>>>>>>>>    
25481>>>>>>>>>>>>>>>    // these are needed to pass these on to possible tabview.
25481>>>>>>>>>>>>>>>    Function Opening_view_Recursive Returns Integer
25483>>>>>>>>>>>>>>>        Integer bFail
25483>>>>>>>>>>>>>>>        Broadcast Get Opening_View_Recursive to bFail
25485>>>>>>>>>>>>>>>        Function_Return bFail
25486>>>>>>>>>>>>>>>    End_Function
25487>>>>>>>>>>>>>>>    
25487>>>>>>>>>>>>>>>    // these are needed to pass these on to possible tabview.
25487>>>>>>>>>>>>>>>    Procedure Seed_Data_Sets_Recursive
25489>>>>>>>>>>>>>>>        Broadcast Send Seed_Data_Sets_Recursive
25491>>>>>>>>>>>>>>>    End_Procedure
25492>>>>>>>>>>>>>>>    
25492>>>>>>>>>>>>>>>    // as of 17.0, clients are added to a DDOs DEO list, which means they receive the messages
25492>>>>>>>>>>>>>>>    // Refresh, Validate_Items and Entry_Update. These are stubs. The Refresh message is the one
25492>>>>>>>>>>>>>>>    // that will be useful. A developer can use this to process DD changes within a view or other
25492>>>>>>>>>>>>>>>    // container
25492>>>>>>>>>>>>>>>    
25492>>>>>>>>>>>>>>>    Procedure Refresh Integer eMode
25494>>>>>>>>>>>>>>>    End_Procedure
25495>>>>>>>>>>>>>>>    
25495>>>>>>>>>>>>>>>    Function Validate_Items Returns Integer
25497>>>>>>>>>>>>>>>    End_Function
25498>>>>>>>>>>>>>>>    
25498>>>>>>>>>>>>>>>    Procedure Entry_Update Integer file# Integer flag
25500>>>>>>>>>>>>>>>    End_Procedure
25501>>>>>>>>>>>>>>>    
25501>>>>>>>>>>>>>>>    Function Data_File Integer iItem Returns Integer
25503>>>>>>>>>>>>>>>        Function_Return 0
25504>>>>>>>>>>>>>>>    End_Function
25505>>>>>>>>>>>>>>>    
25505>>>>>>>>>>>>>>>    Function Data_Field Integer iItem Returns Integer
25507>>>>>>>>>>>>>>>        Function_Return 0
25508>>>>>>>>>>>>>>>    End_Function
25509>>>>>>>>>>>>>>>    
25509>>>>>>>>>>>>>>>    
25509>>>>>>>>>>>>>>>End_Class
25510>>>>>>>>>>>>>>>
25510>>>>>>>>>>>>>>>
25510>>>>>>>>>>>>>>>Define DEFAULT_VIEW_LATCH_STATE         for 1
25510>>>>>>>>>>>>>>>Define DEFAULT_VIEW_STATIC_SERVER_STATE for 1
25510>>>>>>>>>>>>>>>Define DEFAULT_DSO_DETACH_MODE          for DETACH_IF_NO_CHANGE
25510>>>>>>>>>>>>>>>
25510>>>>>>>>>>>>>>>Class Entry_View_Client_mixin is a mixin
25511>>>>>>>>>>>>>>>    Procedure Construct_Object Integer img#
25513>>>>>>>>>>>>>>>        Forward Send construct_object img#
25515>>>>>>>>>>>>>>>        Property String View_Name ''  // default name...could be useful
25516>>>>>>>>>>>>>>>        Set scope_State to True         // defaults to a Scope
25517>>>>>>>>>>>>>>>        Set Attach_Parent_State to True // default...controls parentage better
25518>>>>>>>>>>>>>>>        Set Ring_State to True          // default to Ring...makes sense
25519>>>>>>>>>>>>>>>        
25519>>>>>>>>>>>>>>>        Property Integer DSO_Detach_Mode          Default_DSO_Detach_Mode
25520>>>>>>>>>>>>>>>        Property Integer DEO_Attach_All_State     False
25521>>>>>>>>>>>>>>>        
25521>>>>>>>>>>>>>>>        Property Integer View_Latch_State         True  // Default_View_Latch_State
25522>>>>>>>>>>>>>>>        Property Integer Main_DD                  0
25523>>>>>>>>>>>>>>>        // keeps track of main-file record when new view is entered!
25523>>>>>>>>>>>>>>>        
25523>>>>>>>>>>>>>>>        Property RowID priInitialRowId
25524>>>>>>>>>>>>>>>        
25524>>>>>>>>>>>>>>>        // when false activate will attempt to activate the scope_focus
25524>>>>>>>>>>>>>>>        // when true, activate activates first object.
25524>>>>>>>>>>>>>>>        Property Integer Auto_Top_View_State      False
25525>>>>>>>>>>>>>>>
25525>>>>>>>>>>>>>>>        // When activate is performed (as opposed to set current_scope) the
25525>>>>>>>>>>>>>>>        // first focusable object is activated. Should the first item of the
25525>>>>>>>>>>>>>>>        // first object become the current_item?
25525>>>>>>>>>>>>>>>        // If Top_View is true and Top_Item is false you get the old dac
25525>>>>>>>>>>>>>>>        // behaviors.
25525>>>>>>>>>>>>>>>        Property Integer Auto_Top_Item_State      True
25526>>>>>>>>>>>>>>>        
25526>>>>>>>>>>>>>>>        // When changing views this will keep track of the object that had
25526>>>>>>>>>>>>>>>        // the focus when this view (scope) was exited. This manages nested
25526>>>>>>>>>>>>>>>        // scopes within a view.
25526>>>>>>>>>>>>>>>        Property Integer private.Last_View_Focus  0
25527>>>>>>>>>>>>>>>        Property Integer wasNotinUse_State        False // internal use
25528>>>>>>>>>>>>>>>    End_Procedure
25529>>>>>>>>>>>>>>>    
25529>>>>>>>>>>>>>>>    // Augment exit_application_check. If a change
25529>>>>>>>>>>>>>>>    // is detected activate the changed view. This way the user sees what
25529>>>>>>>>>>>>>>>    // has been changed.
25529>>>>>>>>>>>>>>>    //
25529>>>>>>>>>>>>>>>    Function Exit_Application_Check Returns Integer
25531>>>>>>>>>>>>>>>        Integer rVal Obj
25531>>>>>>>>>>>>>>>        
25531>>>>>>>>>>>>>>>        Get Should_Save to Rval // changes in this object???
25532>>>>>>>>>>>>>>>        If (rVal = 0) ;            Broadcast Get Exit_Application_Check to Rval // check w/ kids
25536>>>>>>>>>>>>>>>        
25536>>>>>>>>>>>>>>>        If (rVal <> 0) Begin  // ok a change exist...activate changed view.
25538>>>>>>>>>>>>>>>            //
25538>>>>>>>>>>>>>>>            // before activating the changed view make sure that we are not
25538>>>>>>>>>>>>>>>            // trying to activate this on top of a modal object. Check the current
25538>>>>>>>>>>>>>>>            // focus and all of its parent record up to (but not including) the
25538>>>>>>>>>>>>>>>            // desktop. If any of these object are modal (have block_mouse_state
25538>>>>>>>>>>>>>>>            // set to true) then do not display the changed view.
25538>>>>>>>>>>>>>>>            //
25538>>>>>>>>>>>>>>>            Get Focus of desktop to Obj
25539>>>>>>>>>>>>>>>            While Obj Gt DESKTOP
25543>>>>>>>>>>>>>>>                If (Block_Mouse_State(Obj)) ;                    Function_Return rVal // if modal..exit
25546>>>>>>>>>>>>>>>                Get Parent of Obj to Obj
25547>>>>>>>>>>>>>>>            Loop
25548>>>>>>>>>>>>>>>>
25548>>>>>>>>>>>>>>>            Send Activate
25549>>>>>>>>>>>>>>>        End
25549>>>>>>>>>>>>>>>>
25549>>>>>>>>>>>>>>>        Function_Return rVal
25550>>>>>>>>>>>>>>>    End_Function
25551>>>>>>>>>>>>>>>    
25551>>>>>>>>>>>>>>>    Function Opening_view_Recursive Returns Integer
25553>>>>>>>>>>>>>>>        Integer main bFail
25553>>>>>>>>>>>>>>>        Set delegation_mode to delegate_to_parent
25554>>>>>>>>>>>>>>>        Get Main_DD to Main
25555>>>>>>>>>>>>>>>        Set WasNotInUse_State to ( Main and In_use_State(Main)=0 )
25556>>>>>>>>>>>>>>>        Get Opening_View to bFail
25557>>>>>>>>>>>>>>>        If not bFail ;            Broadcast Get Opening_View_Recursive to bFail
25561>>>>>>>>>>>>>>>        Function_Return bFail
25562>>>>>>>>>>>>>>>    End_Function
25563>>>>>>>>>>>>>>>    
25563>>>>>>>>>>>>>>>    Procedure Seed_Data_Sets_Recursive
25565>>>>>>>>>>>>>>>        Integer NotInUse
25565>>>>>>>>>>>>>>>        Set delegation_mode to delegate_to_parent
25566>>>>>>>>>>>>>>>        Get WasNotInUse_State to NotInUse
25567>>>>>>>>>>>>>>>        If NotInUse ;            Send Seed_Data_Sets  // if ok, we've got blank in-use DSO.
25570>>>>>>>>>>>>>>>        Set WasNotInUse_State to False
25571>>>>>>>>>>>>>>>        Broadcast Send Seed_Data_Sets_Recursive
25573>>>>>>>>>>>>>>>    End_Procedure
25574>>>>>>>>>>>>>>>    
25574>>>>>>>>>>>>>>>    
25574>>>>>>>>>>>>>>>    //  Augmented to send Opening_view. If add_focus fails it sends
25574>>>>>>>>>>>>>>>    //  closing_view to reverse effects of Opening_view
25574>>>>>>>>>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
25576>>>>>>>>>>>>>>>        Integer rVal Main NotInUse
25576>>>>>>>>>>>>>>>        Get Opening_View_Recursive to rval
25577>>>>>>>>>>>>>>>        //
25577>>>>>>>>>>>>>>>        If (rVal = 0) Begin
25579>>>>>>>>>>>>>>>            // Connect DEOs and DSOs as required.
25579>>>>>>>>>>>>>>>            Send Connect_DEOs_to_Servers (DEO_Attach_All_State(Self))
25580>>>>>>>>>>>>>>>            Forward Get MSG_add_focus hoParent to rVal
25582>>>>>>>>>>>>>>>            Send Seed_Data_Sets_Recursive
25583>>>>>>>>>>>>>>>        End
25583>>>>>>>>>>>>>>>>
25583>>>>>>>>>>>>>>>        Procedure_Return rVal
25584>>>>>>>>>>>>>>>    End_Procedure
25585>>>>>>>>>>>>>>>    
25585>>>>>>>>>>>>>>>    // Augmented to Send Closing view
25585>>>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25585>>>>>>>>>>>>>>>    Procedure Deactivating //Returns Integer
25587>>>>>>>>>>>>>>>        Integer rVal
25587>>>>>>>>>>>>>>>        Forward Get MSG_Deactivating to rVal
25589>>>>>>>>>>>>>>>        If (rVal = 0) ;            Send closing_View
25592>>>>>>>>>>>>>>>    End_Procedure
25593>>>>>>>>>>>>>>>    
25593>>>>>>>>>>>>>>>    //  Disconnect servers from deos according to rules.
25593>>>>>>>>>>>>>>>    //
25593>>>>>>>>>>>>>>>    Procedure Closing_View
25595>>>>>>>>>>>>>>>        Integer Mode
25595>>>>>>>>>>>>>>>        Get DSO_Detach_Mode to Mode
25596>>>>>>>>>>>>>>>        // If we had a View with no DEOs the DSOs would remain in use. We
25596>>>>>>>>>>>>>>>        // will take the extra step to set all DSOs in-use-states to false.
25596>>>>>>>>>>>>>>>        Send Disconnect_DEOs_from_Servers Mode
25597>>>>>>>>>>>>>>>        // we assume that only DSOs understand Set In_Use_State and that
25597>>>>>>>>>>>>>>>        // no delegation occurs as part of setting this to false.
25597>>>>>>>>>>>>>>>        If (Mode = DETACH_ALWAYS) ;            Broadcast Recursive Set In_use_State to False
25601>>>>>>>>>>>>>>>    End_Procedure
25602>>>>>>>>>>>>>>>    
25602>>>>>>>>>>>>>>>    // use to preload anything into DSOs. By default, if a Main_DD is
25602>>>>>>>>>>>>>>>    // defined, we will attempt to latch on
25602>>>>>>>>>>>>>>>    // the record that was in the buffer when the view was entered!
25602>>>>>>>>>>>>>>>    Procedure Seed_Data_Sets
25604>>>>>>>>>>>>>>>        Integer srvr# File#
25604>>>>>>>>>>>>>>>        Integer bFill
25604>>>>>>>>>>>>>>>        RowID   riInitalRowId
25604>>>>>>>>>>>>>>>        Boolean bFound
25604>>>>>>>>>>>>>>>        Get Main_DD to srvr#
25605>>>>>>>>>>>>>>>        // If no Main-dd we don't do anything automatically, you are on your
25605>>>>>>>>>>>>>>>        // own to seed the data-sets any way you want.
25605>>>>>>>>>>>>>>>        If Srvr# Begin
25607>>>>>>>>>>>>>>>            Get auto_fill_State of srvr# to bFill
25608>>>>>>>>>>>>>>>            // if not auto-fill and we've got a record, someone went to a lot of
25608>>>>>>>>>>>>>>>            // trouble to set up a record. Don't change it. Normally this would
25608>>>>>>>>>>>>>>>            // occur w/ selection lists (which are not auto-fill) that seed the
25608>>>>>>>>>>>>>>>            // list in advance.
25608>>>>>>>>>>>>>>>            If ( bFill=0 and HasRecord(srvr#) ) ;                Procedure_Return
25611>>>>>>>>>>>>>>>            Get priInitialRowId to riInitalRowId
25612>>>>>>>>>>>>>>>            If ( not(IsNullRowId(riInitalRowId)) and View_Latch_State(Self) ) Begin
25614>>>>>>>>>>>>>>>                // if initial record and we latch, refind it via DSO
25614>>>>>>>>>>>>>>>                // Find & relate record manually and then perform
25614>>>>>>>>>>>>>>>                // a request_assign. This will not work if the finding file is
25614>>>>>>>>>>>>>>>                // a constrained child file
25614>>>>>>>>>>>>>>>                Get Main_file of Srvr# to File#
25615>>>>>>>>>>>>>>>                // we can now do this in a single step
25615>>>>>>>>>>>>>>>                Get FindByRowIdEx of srvr# File# riInitalRowId to bFound
25616>>>>>>>>>>>>>>>            End
25616>>>>>>>>>>>>>>>>
25616>>>>>>>>>>>>>>>            Else ;                 // if no initial record, do a formal                If not bFill ;                Send Clear to Srvr# // clear
25620>>>>>>>>>>>>>>>            // If the srvr is auto-fill and there was no initial record we
25620>>>>>>>>>>>>>>>            // will chose to do nothing under the assumption that the server
25620>>>>>>>>>>>>>>>            // has already done an auto-fill and its guess is as good as
25620>>>>>>>>>>>>>>>            // anything we could come up with.
25620>>>>>>>>>>>>>>>        End
25620>>>>>>>>>>>>>>>>
25620>>>>>>>>>>>>>>>    End_Procedure
25621>>>>>>>>>>>>>>>    
25621>>>>>>>>>>>>>>>    //  Needed by view. Find the record number of the requested file.
25621>>>>>>>>>>>>>>>    //  If file = 0 use the main_file of Main_DD (if it exists).
25621>>>>>>>>>>>>>>>    Function FileRowId Integer iFile Returns RowID
25623>>>>>>>>>>>>>>>        Handle hoMain
25623>>>>>>>>>>>>>>>        RowID  riID
25623>>>>>>>>>>>>>>>        // if file not passed use main-file of main data set
25623>>>>>>>>>>>>>>>        If (iFile=0) Begin
25625>>>>>>>>>>>>>>>            Get Main_DD to hoMain
25626>>>>>>>>>>>>>>>            If hoMain Begin
25628>>>>>>>>>>>>>>>                Get main_file of hoMain to iFile
25629>>>>>>>>>>>>>>>            End
25629>>>>>>>>>>>>>>>>
25629>>>>>>>>>>>>>>>        End
25629>>>>>>>>>>>>>>>>
25629>>>>>>>>>>>>>>>        If iFile Begin
25631>>>>>>>>>>>>>>>            Move (GetRowId(iFile)) to riId
25632>>>>>>>>>>>>>>>        End
25632>>>>>>>>>>>>>>>>
25632>>>>>>>>>>>>>>>        Function_Return riId
25633>>>>>>>>>>>>>>>    End_Function
25634>>>>>>>>>>>>>>>    
25634>>>>>>>>>>>>>>>    // We maintain Last_View_Focus to control for nested scopes. A normal
25634>>>>>>>>>>>>>>>    // will have its scope_state true and no scoped children. However, a
25634>>>>>>>>>>>>>>>    // zoom might be scoped. We control this by keeping track of the scope when
25634>>>>>>>>>>>>>>>    // a scope is exited.
25634>>>>>>>>>>>>>>>    
25634>>>>>>>>>>>>>>>    Procedure Set Last_View_Focus Integer Foc
25636>>>>>>>>>>>>>>>        Set private.Last_View_Focus to Foc
25637>>>>>>>>>>>>>>>    End_Procedure
25638>>>>>>>>>>>>>>>    
25638>>>>>>>>>>>>>>>    // Returns The last scope in the view to have the focus. Before returning
25638>>>>>>>>>>>>>>>    // the value make sure that the scope object is active, else return 0
25638>>>>>>>>>>>>>>>    Function Last_View_Focus Returns Integer
25640>>>>>>>>>>>>>>>        Integer foc
25640>>>>>>>>>>>>>>>        Get private.Last_View_Focus to Foc
25641>>>>>>>>>>>>>>>        // if not a valid object or this object is not active make it 0
25641>>>>>>>>>>>>>>>        If (Foc<=DESKTOP or Active_state(Self)=0 or Active_State(Foc)=0) ;            Move 0 to Foc
25644>>>>>>>>>>>>>>>        Function_Return Foc
25645>>>>>>>>>>>>>>>    End_Function
25646>>>>>>>>>>>>>>>    
25646>>>>>>>>>>>>>>>    // Take care of any buffer initialization
25646>>>>>>>>>>>>>>>    Function Opening_View Returns Integer
25648>>>>>>>>>>>>>>>        Integer main
25648>>>>>>>>>>>>>>>        RowID riId
25648>>>>>>>>>>>>>>>        
25648>>>>>>>>>>>>>>>        // if a main DSO exists and it is not in use we must perform
25648>>>>>>>>>>>>>>>        // any required pre-seeding logic.
25648>>>>>>>>>>>>>>>        //Get Main_DD to Main
25648>>>>>>>>>>>>>>>        //If ( Main AND In_use_State(Main)=0 ) Begin
25648>>>>>>>>>>>>>>>        If ( wasNotinUse_State(Self))  Begin
25650>>>>>>>>>>>>>>>            // Always clear all file buffers and keep track of the record number
25650>>>>>>>>>>>>>>>            // that was in the main-dso's file-buffer.
25650>>>>>>>>>>>>>>>            // This is used by seed_data_sets to seed as required.
25650>>>>>>>>>>>>>>>            Get FileRowId 0 to riId
25651>>>>>>>>>>>>>>>            Set priInitialRowId to riId
25652>>>>>>>>>>>>>>>            //Set Initial_Main_record to Rec#
25652>>>>>>>>>>>>>>>            Send Prepare_Data_Sets         // allow custom setting
25653>>>>>>>>>>>>>>>            Broadcast Send clear_main_file // Send refind_records to main
25655>>>>>>>>>>>>>>>        End
25655>>>>>>>>>>>>>>>>
25655>>>>>>>>>>>>>>>    End_Function
25656>>>>>>>>>>>>>>>    
25656>>>>>>>>>>>>>>>    // only called if Main_DD exists and it is not yet in-use
25656>>>>>>>>>>>>>>>    Procedure Prepare_Data_Sets
25658>>>>>>>>>>>>>>>    End_Procedure
25659>>>>>>>>>>>>>>>    
25659>>>>>>>>>>>>>>>    // added to make the file buffers more reliable
25659>>>>>>>>>>>>>>>    Procedure Entering_Scope Returns Integer
25661>>>>>>>>>>>>>>>        Integer rVal
25661>>>>>>>>>>>>>>>        Forward Get MSG_entering_scope to rVal
25663>>>>>>>>>>>>>>>        // The refind is probably a feature that should always happen.
25663>>>>>>>>>>>>>>>        // The main-data-set was a way to make this backwards compatable.
25663>>>>>>>>>>>>>>>        // Maybe that made no sense.
25663>>>>>>>>>>>>>>>        If (rVal = 0) ;            Broadcast Send refind_DD_records // only refinds in-use DDs.
25667>>>>>>>>>>>>>>>        Procedure_Return rVal
25668>>>>>>>>>>>>>>>    End_Procedure
25669>>>>>>>>>>>>>>>    
25669>>>>>>>>>>>>>>>    // Augment to keep track of the scope that had the focus when this
25669>>>>>>>>>>>>>>>    // view was exited. Exiting_Scope seems to get called at the right
25669>>>>>>>>>>>>>>>    // times - only when focus is moved to an object outside of view's focus.
25669>>>>>>>>>>>>>>>    Procedure Exiting_Scope Handle hoNewScope
25671>>>>>>>>>>>>>>>        Integer rVal
25671>>>>>>>>>>>>>>>        Forward Get MSG_Exiting_Scope hoNewScope to rVal
25673>>>>>>>>>>>>>>>        If (rVal = 0) ;            Set Last_View_Focus to (Current_Scope(Self))
25676>>>>>>>>>>>>>>>    End_Procedure
25677>>>>>>>>>>>>>>>    
25677>>>>>>>>>>>>>>>    //  Augmented to allow views to take the focus without changing the
25677>>>>>>>>>>>>>>>    //  focus within the object. The property Auto_top_View_State controls
25677>>>>>>>>>>>>>>>    //  this. If true, always return to first object, first item. If false
25677>>>>>>>>>>>>>>>    //  return to current-item of scope focus (when possible).
25677>>>>>>>>>>>>>>>    //
25677>>>>>>>>>>>>>>>    Procedure Activate Returns Integer
25679>>>>>>>>>>>>>>>        Integer rVal Foc
25679>>>>>>>>>>>>>>>        If ( Auto_Top_View_State(Self)=0 and ; // Do we want behavior?            scope_state(Self) and ;           // s/b true.            Active_state(Self) ) Begin        // Only if active.
25681>>>>>>>>>>>>>>>            // Last_View_Focus is the last scope to have the focus.
25681>>>>>>>>>>>>>>>            // It should be active (if not the prop is 0).
25681>>>>>>>>>>>>>>>            // If for some reason the focus is 0, do a vanilla activate.
25681>>>>>>>>>>>>>>>            Get Last_View_Focus to Foc
25682>>>>>>>>>>>>>>>            If Foc ;                Set Current_Scope to Foc
25685>>>>>>>>>>>>>>>            Else ;                Forward Get Msg_Activate to rVal
25688>>>>>>>>>>>>>>>        End
25688>>>>>>>>>>>>>>>>
25688>>>>>>>>>>>>>>>        Else Begin
25689>>>>>>>>>>>>>>>            Forward Get Msg_Activate to rVal
25691>>>>>>>>>>>>>>>            // first Item of first object.
25691>>>>>>>>>>>>>>>            If ( Rval=0 and Auto_Top_Item_State(Self) ) ;                Send Beginning_of_Panel
25694>>>>>>>>>>>>>>>        End
25694>>>>>>>>>>>>>>>>
25694>>>>>>>>>>>>>>>        Procedure_Return rVal
25695>>>>>>>>>>>>>>>    End_Procedure
25696>>>>>>>>>>>>>>>    
25696>>>>>>>>>>>>>>>    // Views don't delegate to get this property. It uses system default
25696>>>>>>>>>>>>>>>    Function Default_Static_Server_State Returns Integer
25698>>>>>>>>>>>>>>>        Function_Return DEFAULT_VIEW_STATIC_SERVER_STATE
25699>>>>>>>>>>>>>>>    End_Function
25700>>>>>>>>>>>>>>>    
25700>>>>>>>>>>>>>>>End_Class
25701>>>>>>>>>>>>>>>
25701>>>>>>>>>>>>>>>//
25701>>>>>>>>>>>>>>>//  Client for Selection Lists.
25701>>>>>>>>>>>>>>>//
25701>>>>>>>>>>>>>>>//  Selection_lists and Pick_lists need to know if they should
25701>>>>>>>>>>>>>>>//  move their values out. With simple sel/pick lists it figures this
25701>>>>>>>>>>>>>>>//  out if the list is a popup object. (POPUP sets the property
25701>>>>>>>>>>>>>>>//  move_value_out_state to TRUE. If the sel\pick list needs to be
25701>>>>>>>>>>>>>>>//  encapulsated by a client the actual list object is no longer a
25701>>>>>>>>>>>>>>>//  popup (the client is). We need this special client to set the
25701>>>>>>>>>>>>>>>//  move_value_out_state of the list. It does this by broadcasting
25701>>>>>>>>>>>>>>>//  this to all objects. This only works if the sel/pick list object is
25701>>>>>>>>>>>>>>>//  a direct child of the client (which it always will be).
25701>>>>>>>>>>>>>>>//
25701>>>>>>>>>>>>>>>//  Also note that this class supports movable objects
25701>>>>>>>>>>>>>>>
25701>>>>>>>>>>>>>>>Register_Procedure Set Move_Value_Out_State Integer State
25701>>>>>>>>>>>>>>>
25701>>>>>>>>>>>>>>>// used to catch old obsolete syntax
25701>>>>>>>>>>>>>Use DFNav_mx.pkg // Navigation changes for DF DEOs
Including file: Dfnav_mx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfnav_mx.pkg)
25701>>>>>>>>>>>>>>>Use VDFBase.pkg
25701>>>>>>>>>>>>>>>
25701>>>>>>>>>>>>>>>Class DFnavigate_mixin is a Mixin
25702>>>>>>>>>>>>>>>    
25702>>>>>>>>>>>>>>>    Procedure define_DFNavigation
25704>>>>>>>>>>>>>>>        
25704>>>>>>>>>>>>>>>        On_Key kSwitch            Send Switch_Next_Area   PRIVATE
25705>>>>>>>>>>>>>>>        On_Key kSwitch_Back       Send Switch_Prior_Area  PRIVATE
25706>>>>>>>>>>>>>>>        
25706>>>>>>>>>>>>>>>        //  Change Panel switching to view switching.
25706>>>>>>>>>>>>>>>        //  The messages Switch_next_view and Switch_Prior_View
25706>>>>>>>>>>>>>>>        //  need to be resolved (via delegation) in the view object.
25706>>>>>>>>>>>>>>>        //  This means that all dfentry object must be placed inside
25706>>>>>>>>>>>>>>>        //  of a view object. This might cause problems ... we will see.
25706>>>>>>>>>>>>>>>        
25706>>>>>>>>>>>>>>>    End_Procedure
25707>>>>>>>>>>>>>>>    
25707>>>>>>>>>>>>>>>    Procedure Close_Panel
25709>>>>>>>>>>>>>>>        Send Exit_Function
25710>>>>>>>>>>>>>>>    End_Procedure
25711>>>>>>>>>>>>>>>    
25711>>>>>>>>>>>>>>>End_Class
25712>>>>>>>>>>>>>Use dfConfrm.pkg
25712>>>>>>>>>>>>>Use Dfdbmdpn.pkg // adds obsolete pointerButton for dbModalPanel
Including file: Dfdbmdpn.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfdbmdpn.pkg)
25712>>>>>>>>>>>>>>>Use Windows.pkg
25712>>>>>>>>>>>>>>>
25712>>>>>>>>>>>>>>>Class PointerButton is a Button
25713>>>>>>>>>>>>>>>    
25713>>>>>>>>>>>>>>>    Procedure Construct_Object
25715>>>>>>>>>>>>>>>        Forward Send Construct_Object
25717>>>>>>>>>>>>>>>        Set focus_mode to pointer_Only
25718>>>>>>>>>>>>>>>    End_Procedure
25719>>>>>>>>>>>>>>>    
25719>>>>>>>>>>>>>>>    Procedure Command Integer i1 Integer i2
25721>>>>>>>>>>>>>>>        Send Redirect_Message
25722>>>>>>>>>>>>>>>    End_Procedure
25723>>>>>>>>>>>>>>>    
25723>>>>>>>>>>>>>>>    Procedure Redirect_Message Returns Integer
25725>>>>>>>>>>>>>>>        Integer msg obj rval
25725>>>>>>>>>>>>>>>        Get message 0 to Msg
25726>>>>>>>>>>>>>>>        Get Aux_Value 0 to obj
25727>>>>>>>>>>>>>>>        If Msg ;            Get Msg of ( If(obj, obj, Focus(desktop)) ) to rval
25730>>>>>>>>>>>>>>>        Procedure_Return rval
25731>>>>>>>>>>>>>>>    End_Procedure
25732>>>>>>>>>>>>>>>    
25732>>>>>>>>>>>>>>>End_Class
25733>>>>>>>>>>>>>Use Dfdafmac.pkg
Including file: Dfdafmac.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfdafmac.pkg)
25733>>>>>>>>>>>>>>>Use Windows.pkg
25733>>>>>>>>>>>>>>>Use dfcursor.pkg
25733>>>>>>>>>>>>>>>
25733>>>>>>>>>>>>>>>
25733>>>>>>>>>>>>>>>//  This expects to create a view INSIDE of another object
25733>>>>>>>>>>>>>>>//  (Like a panel)
25733>>>>>>>>>>>>>>>//
25733>>>>>>>>>>>>>>>
25733>>>>>>>>>>>>>>>
25733>>>>>>>>>>>>>>>Define DEFERRED_OBJECT for Deferred_View
25733>>>>>>>>>>>>>>>
25733>>>>>>>>>>>>>>>Class CD_Client is a Container
25734>>>>>>>>>>>>>>>    
25734>>>>>>>>>>>>>>>    Procedure Construct_Object
25736>>>>>>>>>>>>>>>        Forward Send Construct_Object
25738>>>>>>>>>>>>>>>        
25738>>>>>>>>>>>>>>>        Property Integer Created_object_id 0
25739>>>>>>>>>>>>>>>        
25739>>>>>>>>>>>>>>>        Set focus_mode to nonfocusable
25740>>>>>>>>>>>>>>>    End_Procedure
25741>>>>>>>>>>>>>>>    
25741>>>>>>>>>>>>>>>    Procedure Popup
25743>>>>>>>>>>>>>>>        Send Popup_Modal
25744>>>>>>>>>>>>>>>    End_Procedure
25745>>>>>>>>>>>>>>>    
25745>>>>>>>>>>>>>>>    Register_Function Destroy_Object_State Returns Integer
25745>>>>>>>>>>>>>>>    
25745>>>>>>>>>>>>>>>    // is augmented by object instance. Should never
25745>>>>>>>>>>>>>>>    // be called.
25745>>>>>>>>>>>>>>>    Function Popup_Handle Returns Handle
25747>>>>>>>>>>>>>>>        Error DFERR_PROGRAM "Improper use of CD_Popup_Object command"
25748>>>>>>>>>>>>>>>>
25748>>>>>>>>>>>>>>>    End_Function
25749>>>>>>>>>>>>>>>    
25749>>>>>>>>>>>>>>>    Procedure Popup_Modal Returns Integer
25751>>>>>>>>>>>>>>>        Integer iRet
25751>>>>>>>>>>>>>>>        Handle hoId
25751>>>>>>>>>>>>>>>        Boolean bDestroy
25751>>>>>>>>>>>>>>>        Get Popup_Handle to hoId
25752>>>>>>>>>>>>>>>        If hoId Begin
25754>>>>>>>>>>>>>>>            Get msg_Popup_Modal of hoId to iRet
25755>>>>>>>>>>>>>>>            Get Destroy_Object_State of hoId to bDestroy
25756>>>>>>>>>>>>>>>            If bDestroy Begin
25758>>>>>>>>>>>>>>>                Send Destroy of hoId
25759>>>>>>>>>>>>>>>                Set Created_Object_Id to 0
25760>>>>>>>>>>>>>>>            End
25760>>>>>>>>>>>>>>>>
25760>>>>>>>>>>>>>>>            Procedure_Return iRet
25761>>>>>>>>>>>>>>>        End
25761>>>>>>>>>>>>>>>>
25761>>>>>>>>>>>>>>>    End_Procedure
25762>>>>>>>>>>>>>>>    
25762>>>>>>>>>>>>>>>End_Class
25763>>>>>>>>>>>>>>>
25763>>>>>>>>>>>>>>>
25763>>>>>>>>>>>>>>>
25763>>>>>>>>>>>>>
25763>>>>>>>>>>>>>Register_Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
25763>>>>>>>>>>>>>Register_Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
25763>>>>>>>>>>>>>
25763>>>>>>>>>>>>>Register_Function Data_Set_Should_Save Returns Integer
25763>>>>>>>>>>>>>
25763>>>>>>>>>>>>>//
25763>>>>>>>>>>>>>//  Grouping classes: Used within views to group objects
25763>>>>>>>>>>>>>//
25763>>>>>>>>>>>>>//  dbContainer3d_
25763>>>>>>>>>>>>>//     dbContainer3d
25763>>>>>>>>>>>>>//
25763>>>>>>>>>>>>>Class dbContainer3d_ is a Container3d STARTMAC ECstart
25764>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25764>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin // mixin in CM DEO behaviors
25765>>>>>>>>>>>>>    
25765>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25765>>>>>>>>>>>>>    //
25765>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25765>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25767>>>>>>>>>>>>>        Integer RVal
25767>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25769>>>>>>>>>>>>>        Procedure_Return rVal
25770>>>>>>>>>>>>>    End_Procedure
25771>>>>>>>>>>>>>End_Class
25772>>>>>>>>>>>>>
25772>>>>>>>>>>>>>Class dbContainer3d is a dbContainer3d_
25773>>>>>>>>>>>>>    Procedure Construct_Object
25775>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25777>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25778>>>>>>>>>>>>>    End_Procedure
25779>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25780>>>>>>>>>>>>>End_Class
25781>>>>>>>>>>>>>
25781>>>>>>>>>>>>>//
25781>>>>>>>>>>>>>// Group Based containers
25781>>>>>>>>>>>>>//
25781>>>>>>>>>>>>>//  dbGroup_
25781>>>>>>>>>>>>>//     dbGroup
25781>>>>>>>>>>>>>//
25781>>>>>>>>>>>>>Class dbGroup_ is a Group STARTMAC ECstart
25782>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25782>>>>>>>>>>>>>    
25782>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25783>>>>>>>>>>>>>    
25783>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25783>>>>>>>>>>>>>    //
25783>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25783>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25785>>>>>>>>>>>>>        Integer RVal
25785>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25787>>>>>>>>>>>>>        Procedure_Return rVal
25788>>>>>>>>>>>>>    End_Procedure
25789>>>>>>>>>>>>>End_Class
25790>>>>>>>>>>>>>
25790>>>>>>>>>>>>>Class dbGroup is a dbGroup_
25791>>>>>>>>>>>>>    Procedure Construct_Object
25793>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25795>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25796>>>>>>>>>>>>>    End_Procedure
25797>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25798>>>>>>>>>>>>>End_Class
25799>>>>>>>>>>>>>
25799>>>>>>>>>>>>>
25799>>>>>>>>>>>>>//
25799>>>>>>>>>>>>>// Invisible Grouping object
25799>>>>>>>>>>>>>//
25799>>>>>>>>>>>>>//   dbContainer - invisible container
25799>>>>>>>>>>>>>//
25799>>>>>>>>>>>>>Class dbContainer is an dbContainer3d
25800>>>>>>>>>>>>>    Import_Class_Protocol NonVisual_Container_Mixin
25801>>>>>>>>>>>>>End_Class
25802>>>>>>>>>>>>>
25802>>>>>>>>>>>>>//
25802>>>>>>>>>>>>>// View Support (views are mdi dialogs)
25802>>>>>>>>>>>>>//
25802>>>>>>>>>>>>>//   dbAppClient_
25802>>>>>>>>>>>>>//     dbAppView_
25802>>>>>>>>>>>>>//       dbView
25802>>>>>>>>>>>>>//
25802>>>>>>>>>>>>>Class dbAppClient_ is a View  STARTMAC ECstart
25803>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25803>>>>>>>>>>>>>    
25803>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25804>>>>>>>>>>>>>    
25804>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25804>>>>>>>>>>>>>    //
25804>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25804>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25806>>>>>>>>>>>>>        Integer RVal
25806>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25808>>>>>>>>>>>>>        Procedure_Return rVal
25809>>>>>>>>>>>>>    End_Procedure
25810>>>>>>>>>>>>>End_Class
25811>>>>>>>>>>>>>
25811>>>>>>>>>>>>>Class dbAppView_ is a dbAppClient_
25812>>>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
25813>>>>>>>>>>>>>End_Class
25814>>>>>>>>>>>>>
25814>>>>>>>>>>>>>Class dbView is a dbAppView_
25815>>>>>>>>>>>>>    
25815>>>>>>>>>>>>>    Procedure Construct_Object
25817>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25819>>>>>>>>>>>>>        
25819>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25820>>>>>>>>>>>>>        // dialog views get activated as popup objects.
25820>>>>>>>>>>>>>        Set Dso_Detach_Mode to Detach_Always
25821>>>>>>>>>>>>>        
25821>>>>>>>>>>>>>        // set default verify messages. These are good defaults. The
25821>>>>>>>>>>>>>        // developer may wish to change these in their object or sub-class.
25821>>>>>>>>>>>>>        // Note: these messsages are defined in dfconfrm.pkg
25821>>>>>>>>>>>>>        Set Verify_Data_Loss_Msg   to (RefFunc(Data_Loss_Confirmation))
25822>>>>>>>>>>>>>        Set Verify_Delete_Msg      to (RefFunc(Delete_Confirmation))
25823>>>>>>>>>>>>>        Set Verify_Save_Msg        to (RefFunc(Save_Confirmation))
25824>>>>>>>>>>>>>        Set Verify_Exit_Msg        to (RefFunc(Exit_Loss_Confirmation))
25825>>>>>>>>>>>>>        //
25825>>>>>>>>>>>>>    End_Procedure
25826>>>>>>>>>>>>>    
25826>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25827>>>>>>>>>>>>>    
25827>>>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
25827>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
25827>>>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
25827>>>>>>>>>>>>>    //
25827>>>>>>>>>>>>>    Function DEO_Object Returns Integer
25829>>>>>>>>>>>>>        Function_Return 1
25830>>>>>>>>>>>>>    End_Function
25831>>>>>>>>>>>>>    
25831>>>>>>>>>>>>>    //
25831>>>>>>>>>>>>>    //  Activate message for views that:
25831>>>>>>>>>>>>>    //  1. restores the view if it is minimized
25831>>>>>>>>>>>>>    //  2. Maintains the current scope's focus.
25831>>>>>>>>>>>>>    //
25831>>>>>>>>>>>>>    Procedure Activate_current_scope
25833>>>>>>>>>>>>>        If ( View_mode(Self)=VIEWMODE_ICONIZE ) ;            Set view_mode to viewmode_normal
25836>>>>>>>>>>>>>        Set Current_Scope to Self
25837>>>>>>>>>>>>>    End_Procedure
25838>>>>>>>>>>>>>    
25838>>>>>>>>>>>>>    // ------------deprecated....Use Object_label.
25838>>>>>>>>>>>>>    //  Pass full object name - return the relative name
25838>>>>>>>>>>>>>    //  e.g.,  Main.View.Obj1 --> Obj1
25838>>>>>>>>>>>>>    Function Local_Object_name String nm Returns String
25840>>>>>>>>>>>>>        Integer ps
25840>>>>>>>>>>>>>        Repeat
25840>>>>>>>>>>>>>>
25840>>>>>>>>>>>>>            Move (Pos( ".", nm)) to ps
25841>>>>>>>>>>>>>            If (ps = 0) ;                Function_Return nm
25844>>>>>>>>>>>>>            Increment ps
25845>>>>>>>>>>>>>            Move (Mid( Nm, 255, ps)) to Nm
25846>>>>>>>>>>>>>        Loop
25847>>>>>>>>>>>>>>
25847>>>>>>>>>>>>>    End_Function
25848>>>>>>>>>>>>>    
25848>>>>>>>>>>>>>    Function View_Changed Returns Integer
25850>>>>>>>>>>>>>        Integer Changed
25850>>>>>>>>>>>>>        // first see if any DDOs at this level are changed.
25850>>>>>>>>>>>>>        Broadcast Get Data_Set_Should_Save to Changed // Ask for changes in Data-sets
25852>>>>>>>>>>>>>        // if no changes, see if we have any sub-views that are changed
25852>>>>>>>>>>>>>        // This is used to catch tab-view pages.
25852>>>>>>>>>>>>>        If not Changed ;            Broadcast Get SubView_Changed to Changed
25856>>>>>>>>>>>>>        Function_Return Changed
25857>>>>>>>>>>>>>    End_Function
25858>>>>>>>>>>>>>    
25858>>>>>>>>>>>>>    Procedure Close_Client
25860>>>>>>>>>>>>>        Send Exit_Function
25861>>>>>>>>>>>>>    End_Procedure
25862>>>>>>>>>>>>>    
25862>>>>>>>>>>>>>End_Class
25863>>>>>>>>>>>>>
25863>>>>>>>>>>>>>
25863>>>>>>>>>>>>>
25863>>>>>>>>>>>>>//
25863>>>>>>>>>>>>>// ToolPanel Based Classes
25863>>>>>>>>>>>>>//
25863>>>>>>>>>>>>>//  dbFloatingPanel_
25863>>>>>>>>>>>>>//     dbFloatingPanel
25863>>>>>>>>>>>>>//        dbViewFloatingPanel
25863>>>>>>>>>>>>>//           dbViewToolPanel
25863>>>>>>>>>>>>>//           dbModalPanel <---this will get used
25863>>>>>>>>>>>>>//
25863>>>>>>>>>>>>>Class dbFloatingPanel_ is a FloatingPanel STARTMAC ECstart
25864>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
25864>>>>>>>>>>>>>    
25864>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
25865>>>>>>>>>>>>>    
25865>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
25865>>>>>>>>>>>>>    //
25865>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
25865>>>>>>>>>>>>>    Procedure Activating //Returns Integer
25867>>>>>>>>>>>>>        Integer RVal
25867>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
25869>>>>>>>>>>>>>        Procedure_Return rVal
25870>>>>>>>>>>>>>    End_Procedure
25871>>>>>>>>>>>>>End_Class
25872>>>>>>>>>>>>>
25872>>>>>>>>>>>>>Class dbFloatingPanel is a dbFloatingPanel_
25873>>>>>>>>>>>>>    Procedure Construct_Object
25875>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25877>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
25878>>>>>>>>>>>>>        Set Minimize_Icon to False
25879>>>>>>>>>>>>>        Set Maximize_Icon to False
25880>>>>>>>>>>>>>    End_Procedure
25881>>>>>>>>>>>>>    
25881>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
25882>>>>>>>>>>>>>    
25882>>>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
25882>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
25882>>>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
25882>>>>>>>>>>>>>    //
25882>>>>>>>>>>>>>    Function DEO_Object Returns Integer
25884>>>>>>>>>>>>>        Function_Return 1
25885>>>>>>>>>>>>>    End_Function
25886>>>>>>>>>>>>>    
25886>>>>>>>>>>>>>    // we Modify this not delegate and look for a parent verify exit msg if this msg is 0.
25886>>>>>>>>>>>>>    // We assume that toolpanels and dbModalPanels are self contained in terms of opening and closing
25886>>>>>>>>>>>>>    // and therefore should only use themselves to figure out if there is a verify exit msg. This is needed
25886>>>>>>>>>>>>>    // in case a db modal panel physically placed inside of another DEO.
25886>>>>>>>>>>>>>    Function Verify_Exit_msg Returns Integer
25888>>>>>>>>>>>>>        Integer msg#
25888>>>>>>>>>>>>>        Get private.verify_exit_msg to msg#
25889>>>>>>>>>>>>>        // don't look at parent DEOs like we do elsewhere.
25889>>>>>>>>>>>>>        //if (msg# = 0 AND Component_State(self)) ;
25889>>>>>>>>>>>>>        //    delegate get verify_exit_msg to msg#
25889>>>>>>>>>>>>>        Function_Return msg#
25890>>>>>>>>>>>>>    End_Function
25891>>>>>>>>>>>>>    
25891>>>>>>>>>>>>>End_Class
25892>>>>>>>>>>>>>
25892>>>>>>>>>>>>>Class dbViewFloatingPanel is a dbFloatingPanel
25893>>>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
25894>>>>>>>>>>>>>End_Class
25895>>>>>>>>>>>>>
25895>>>>>>>>>>>>>Class dbViewToolPanel is a dbViewFloatingPanel
25896>>>>>>>>>>>>>    
25896>>>>>>>>>>>>>    Procedure Construct_Object
25898>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25900>>>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_TOOLWINDOW True
25901>>>>>>>>>>>>>    End_Procedure
25902>>>>>>>>>>>>>    
25902>>>>>>>>>>>>>End_Class
25903>>>>>>>>>>>>>
25903>>>>>>>>>>>>>//  EntryModalPanel
25903>>>>>>>>>>>>>
25903>>>>>>>>>>>>>Class dbModalPanel is a dbViewFloatingPanel
25904>>>>>>>>>>>>>    Procedure Construct_Object
25906>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
25908>>>>>>>>>>>>>        
25908>>>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True
25909>>>>>>>>>>>>>        Set Modal_State to True
25910>>>>>>>>>>>>>        
25910>>>>>>>>>>>>>        Property Integer List_Object  0
25911>>>>>>>>>>>>>        
25911>>>>>>>>>>>>>        Property Integer Button_Height     14
25912>>>>>>>>>>>>>        Property Integer Button_Width      50
25913>>>>>>>>>>>>>        
25913>>>>>>>>>>>>>        Property Integer Max_Text_Extent   0
25914>>>>>>>>>>>>>        
25914>>>>>>>>>>>>>        Object Button_Ids is an array
25916>>>>>>>>>>>>>        End_Object
25917>>>>>>>>>>>>>    End_Procedure
25918>>>>>>>>>>>>>    
25918>>>>>>>>>>>>>    Function Button_Count Returns Integer
25920>>>>>>>>>>>>>        Function_Return (Item_count(Button_Ids))
25921>>>>>>>>>>>>>    End_Function
25922>>>>>>>>>>>>>    
25922>>>>>>>>>>>>>    Procedure Add_Button String sLabel Integer hMsg Integer hoTo
25924>>>>>>>>>>>>>        Integer hoBtn tx
25924>>>>>>>>>>>>>        // 8.2 - use newer syntax for creating dynamic objects
25924>>>>>>>>>>>>>        Get Create U_PointerButton to hoBtn
25925>>>>>>>>>>>>>        Set peAnchors of hoBtn to anBottomRight
25926>>>>>>>>>>>>>        Set Value of hoBtn 0 to sLabel
25927>>>>>>>>>>>>>        Set Message of hoBtn 0 to hMsg
25928>>>>>>>>>>>>>        If (Num_Arguments>2) ;            Set aux_value of hoBtn 0 to hoTo
25931>>>>>>>>>>>>>        Get Text_Extent of hoBtn sLabel to tx
25932>>>>>>>>>>>>>        Move (low(tx)) to tx
25933>>>>>>>>>>>>>        Set Array_Value of Button_Ids (Button_Count(Self)) to hoBtn
25934>>>>>>>>>>>>>        If (tx > Max_Text_Extent(Self));            Set Max_Text_Extent to tx
25937>>>>>>>>>>>>>    End_Procedure
25938>>>>>>>>>>>>>    
25938>>>>>>>>>>>>>    Procedure Size_Buttons
25940>>>>>>>>>>>>>        Integer bheight bwidth nb obj Bobj bt mt gsiz gwd
25940>>>>>>>>>>>>>        
25940>>>>>>>>>>>>>        Get button_height to bheight
25941>>>>>>>>>>>>>        Get button_width  to bwidth
25942>>>>>>>>>>>>>        Get Button_count to nb
25943>>>>>>>>>>>>>        Decrement nb
25944>>>>>>>>>>>>>        
25944>>>>>>>>>>>>>        Move Button_ids to obj
25945>>>>>>>>>>>>>        
25945>>>>>>>>>>>>>        For bt from 0 to nb
25951>>>>>>>>>>>>>>
25951>>>>>>>>>>>>>            Get integer_value of obj bt to bobj // button id
25952>>>>>>>>>>>>>            Set Size of bobj to bheight bwidth       // set dflt size
25953>>>>>>>>>>>>>            If (bt = 0) Begin
25955>>>>>>>>>>>>>                Get Max_Text_Extent to mt
25956>>>>>>>>>>>>>                Add 8 to mt
25957>>>>>>>>>>>>>                Get guisize of bobj to gsiz
25958>>>>>>>>>>>>>                Move (low(gsiz)) to gwd
25959>>>>>>>>>>>>>                If (gwd < mt) Begin
25961>>>>>>>>>>>>>                    Set guisize of bobj to (hi(gsiz)) mt
25962>>>>>>>>>>>>>                    Send adjust_logicals to bobj
25963>>>>>>>>>>>>>                    Move (low(size(bobj))) to bwidth
25964>>>>>>>>>>>>>                    Set Button_width to bwidth
25965>>>>>>>>>>>>>                End
25965>>>>>>>>>>>>>>
25965>>>>>>>>>>>>>            End
25965>>>>>>>>>>>>>>
25965>>>>>>>>>>>>>        Loop
25966>>>>>>>>>>>>>>
25966>>>>>>>>>>>>>    End_Procedure
25967>>>>>>>>>>>>>    
25967>>>>>>>>>>>>>    Procedure Position_Child_Objects
25969>>>>>>>>>>>>>        Integer lsz psz wd pwd ht llc nb mt bobj obj cht col bt list_obj
25969>>>>>>>>>>>>>        Integer rmrgn swd
25969>>>>>>>>>>>>>        
25969>>>>>>>>>>>>>        If (not(pbSizeToClientArea(Self))) Begin
25971>>>>>>>>>>>>>            // if using old sizing, we have not changed anything for 14.0
25971>>>>>>>>>>>>>            If (caption_bar(Self)) ;                Move (Hi(Physical_fontsize(Self))+4+6) to cht
25974>>>>>>>>>>>>>            Else ;                Move 0 to cht
25976>>>>>>>>>>>>>            
25976>>>>>>>>>>>>>            Get GUISize to psz               // size of panel
25977>>>>>>>>>>>>>            Get List_Object to List_obj      // id of the list object
25978>>>>>>>>>>>>>            If list_obj Begin
25980>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
25981>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
25982>>>>>>>>>>>>>                Move (low(llc)+low(lsz)+2) to rmrgn
25983>>>>>>>>>>>>>            End
25983>>>>>>>>>>>>>>
25983>>>>>>>>>>>>>            Else ;                Move (low(psz)-8) to rmrgn
25985>>>>>>>>>>>>>            
25985>>>>>>>>>>>>>            Get Button_count to nb        // number of buttons
25986>>>>>>>>>>>>>            
25986>>>>>>>>>>>>>            If (nb = 0) ;                Move ( hi(psz) - 4 - cht - 8) to ht
25989>>>>>>>>>>>>>            Else Begin
25990>>>>>>>>>>>>>                Move Button_ids to obj
25991>>>>>>>>>>>>>                Get integer_value of obj 0 to bobj
25992>>>>>>>>>>>>>                Get guisize of bobj to ht
25993>>>>>>>>>>>>>                Move (low(ht)) to wd
25994>>>>>>>>>>>>>                Move ( hi(ht)) to ht
25995>>>>>>>>>>>>>                Move 8 to swd // width of each space
25996>>>>>>>>>>>>>                If ( (rmrgn - ((wd+swd)*nb-swd)) < 0 ) ;                    Move 2 to swd
25999>>>>>>>>>>>>>                Move ( hi(psz) - ht - 4 - cht - 8) to ht
26000>>>>>>>>>>>>>                
26000>>>>>>>>>>>>>                Move (rmrgn-wd) to col
26001>>>>>>>>>>>>>                Decrement nb
26002>>>>>>>>>>>>>                While nb ge 0
26006>>>>>>>>>>>>>                    Get integer_value of obj nb to bobj
26007>>>>>>>>>>>>>                    Set GUIlocation of bobj to ht col
26008>>>>>>>>>>>>>                    Send Adjust_Logicals to bobj
26009>>>>>>>>>>>>>                    Move (col - swd - wd) to col
26010>>>>>>>>>>>>>                    Decrement nb
26011>>>>>>>>>>>>>                End
26012>>>>>>>>>>>>>>
26012>>>>>>>>>>>>>            End
26012>>>>>>>>>>>>>>
26012>>>>>>>>>>>>>            
26012>>>>>>>>>>>>>            If list_obj Begin
26014>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26015>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26016>>>>>>>>>>>>>                Move ( ht - Hi(llc) - 12 ) to ht
26017>>>>>>>>>>>>>                Set GUIsize of list_obj to ht (low(lsz))
26018>>>>>>>>>>>>>                Send Adjust_Logicals to list_obj
26019>>>>>>>>>>>>>            End
26019>>>>>>>>>>>>>>
26019>>>>>>>>>>>>>        End
26019>>>>>>>>>>>>>>
26019>>>>>>>>>>>>>        Else Begin
26020>>>>>>>>>>>>>            
26020>>>>>>>>>>>>>            // this is still obsolete, but we will make it work with client sizing, which makes it simpler actually
26020>>>>>>>>>>>>>            // bote that 8 is used through out as the GUI spacing amount. This is legacy and will not be changed
26020>>>>>>>>>>>>>            
26020>>>>>>>>>>>>>            Get GUISize to psz               // size of panel
26021>>>>>>>>>>>>>            Get List_Object to List_obj      // id of the list object
26022>>>>>>>>>>>>>            If list_obj Begin
26024>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26025>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26026>>>>>>>>>>>>>                Move (low(llc)+low(lsz)) to rmrgn
26027>>>>>>>>>>>>>            End
26027>>>>>>>>>>>>>>
26027>>>>>>>>>>>>>            Else Begin
26028>>>>>>>>>>>>>                Move (low(psz)-8) to rmrgn
26029>>>>>>>>>>>>>            End
26029>>>>>>>>>>>>>>
26029>>>>>>>>>>>>>            
26029>>>>>>>>>>>>>            Get Button_count to nb        // number of buttons
26030>>>>>>>>>>>>>            
26030>>>>>>>>>>>>>            If (nb = 0) ;                Move ( hi(psz) ) to ht
26033>>>>>>>>>>>>>            Else Begin
26034>>>>>>>>>>>>>                Move Button_ids to obj
26035>>>>>>>>>>>>>                Get integer_value of obj 0 to bobj
26036>>>>>>>>>>>>>                Get guisize of bobj to ht
26037>>>>>>>>>>>>>                Move (low(ht)) to wd
26038>>>>>>>>>>>>>                Move ( hi(ht)) to ht
26039>>>>>>>>>>>>>                Move 8 to swd // width of each space
26040>>>>>>>>>>>>>                Move ( hi(psz) - ht - 8) to ht
26041>>>>>>>>>>>>>                
26041>>>>>>>>>>>>>                Move (rmrgn-wd) to col
26042>>>>>>>>>>>>>                Decrement nb
26043>>>>>>>>>>>>>                While (nb>=0)
26047>>>>>>>>>>>>>                    Get integer_value of obj nb to bobj
26048>>>>>>>>>>>>>                    Set GUIlocation of bobj to ht col
26049>>>>>>>>>>>>>                    Send Adjust_Logicals to bobj
26050>>>>>>>>>>>>>                    Move (col - swd - wd) to col
26051>>>>>>>>>>>>>                    Decrement nb
26052>>>>>>>>>>>>>                End
26053>>>>>>>>>>>>>>
26053>>>>>>>>>>>>>            End
26053>>>>>>>>>>>>>>
26053>>>>>>>>>>>>>            
26053>>>>>>>>>>>>>            If list_obj Begin
26055>>>>>>>>>>>>>                Get GUISize of list_obj to lSz
26056>>>>>>>>>>>>>                Get GUIlocation of list_obj to llc
26057>>>>>>>>>>>>>                Move ( ht - Hi(llc) - 8 ) to ht
26058>>>>>>>>>>>>>                Set GUIsize of list_obj to ht (low(lsz))
26059>>>>>>>>>>>>>                Send Adjust_Logicals of list_obj
26060>>>>>>>>>>>>>            End
26060>>>>>>>>>>>>>>
26060>>>>>>>>>>>>>        End
26060>>>>>>>>>>>>>>
26060>>>>>>>>>>>>>    End_Procedure
26061>>>>>>>>>>>>>    
26061>>>>>>>>>>>>>    Procedure End_Construct_Object
26063>>>>>>>>>>>>>        Send Size_Buttons
26064>>>>>>>>>>>>>        Send Position_Child_Objects
26065>>>>>>>>>>>>>        Forward Send end_construct_object
26067>>>>>>>>>>>>>    End_Procedure
26068>>>>>>>>>>>>>    
26068>>>>>>>>>>>>>    Procedure Search
26070>>>>>>>>>>>>>        Integer Obj#
26070>>>>>>>>>>>>>        Get List_Object to obj#
26071>>>>>>>>>>>>>        If Obj# ;            Send Search to Obj#
26074>>>>>>>>>>>>>    End_Procedure
26075>>>>>>>>>>>>>    
26075>>>>>>>>>>>>>    // created for advanced CD_popup_object support. Returns the true handle of the
26075>>>>>>>>>>>>>    // popup object whether it is a regular object or a CD popup object.
26075>>>>>>>>>>>>>    Function Popup_Handle Returns Handle
26077>>>>>>>>>>>>>        Function_Return Self
26078>>>>>>>>>>>>>    End_Function
26079>>>>>>>>>>>>>    
26079>>>>>>>>>>>>>End_Class
26080>>>>>>>>>>>>>
26080>>>>>>>>>>>>>//
26080>>>>>>>>>>>>>// Panel Based Classes
26080>>>>>>>>>>>>>//
26080>>>>>>>>>>>>>//  dbPanel_
26080>>>>>>>>>>>>>//     dbPanel
26080>>>>>>>>>>>>>//        dbViewPanel_
26080>>>>>>>>>>>>>//           dbViewPanel
26080>>>>>>>>>>>>>//
26080>>>>>>>>>>>>>// None of these are likely to be used
26080>>>>>>>>>>>>>//
26080>>>>>>>>>>>>>
26080>>>>>>>>>>>>>Class dbPanel_ is a BasicPanel STARTMAC ECstart
26081>>>>>>>>>>>>>    // the startmac is used to catch old obsolete code at compiletime
26081>>>>>>>>>>>>>    
26081>>>>>>>>>>>>>    Import_Class_Protocol Entry_Client_mixin
26082>>>>>>>>>>>>>    
26082>>>>>>>>>>>>>    //  Defeat the activating augmentation for auto-locate
26082>>>>>>>>>>>>>    //
26082>>>>>>>>>>>>>    // as of 15.1 we changed all deactivating/activating signatures to not return values (see windows.pkg / ComboForm / Activating for more)
26082>>>>>>>>>>>>>    Procedure Activating //Returns Integer
26084>>>>>>>>>>>>>        Integer RVal
26084>>>>>>>>>>>>>        Forward Get MSG_activating to rVal
26086>>>>>>>>>>>>>        Procedure_Return rVal
26087>>>>>>>>>>>>>    End_Procedure
26088>>>>>>>>>>>>>End_Class
26089>>>>>>>>>>>>>
26089>>>>>>>>>>>>>Class dbPanel is a dbPanel_
26090>>>>>>>>>>>>>    Procedure Construct_Object
26092>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
26094>>>>>>>>>>>>>        Send Define_DFNavigation  // GUI navigate changes
26095>>>>>>>>>>>>>    End_Procedure
26096>>>>>>>>>>>>>    Import_Class_Protocol DFNavigate_Mixin
26097>>>>>>>>>>>>>End_Class
26098>>>>>>>>>>>>>
26098>>>>>>>>>>>>>Class dbViewPanel_ is a dbPanel
26099>>>>>>>>>>>>>    Import_Class_Protocol entry_view_Client_mixin
26100>>>>>>>>>>>>>End_Class
26101>>>>>>>>>>>>>
26101>>>>>>>>>>>>>Class dbViewPanel is a dbViewPanel_
26102>>>>>>>>>>>>>    Procedure Construct_Object
26104>>>>>>>>>>>>>        Forward Send Construct_Object No_Image
26106>>>>>>>>>>>>>    End_Procedure
26107>>>>>>>>>>>>>    
26107>>>>>>>>>>>>>    //  Returns TRUE to indicate that this is a DEO. This is used by
26107>>>>>>>>>>>>>    //  delegation to figure out if you are within a DEO and should therefore
26107>>>>>>>>>>>>>    //  send a DEO message. DEO clients set this true
26107>>>>>>>>>>>>>    //
26107>>>>>>>>>>>>>    Function DEO_Object Returns Integer
26109>>>>>>>>>>>>>        Function_Return 1
26110>>>>>>>>>>>>>    End_Function
26111>>>>>>>>>>>>>End_Class
26112>>>>>>>>>>>Use DFbitmap.pkg
Including file: Dfbitmap.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Dfbitmap.pkg)
26112>>>>>>>>>>>>>Use LanguageText.pkg
26112>>>>>>>>>>>>>Use Windows.pkg
26112>>>>>>>>>>>>>Use File_Dlg.pkg
26112>>>>>>>>>>>>>
26112>>>>>>>>>>>>>Class BitmapContainer is a Container3D
26113>>>>>>>>>>>>>    
26113>>>>>>>>>>>>>    Procedure Construct_Object
26115>>>>>>>>>>>>>        Forward Send Construct_Object
26117>>>>>>>>>>>>>        
26117>>>>>>>>>>>>>        Property Integer Changed_State False
26118>>>>>>>>>>>>>        
26118>>>>>>>>>>>>>        // If true, double click sends Get Select_Bitmap which invokes
26118>>>>>>>>>>>>>        // an open file dialog
26118>>>>>>>>>>>>>        Property Integer Allow_Select_Bitmap_State  False
26119>>>>>>>>>>>>>        
26119>>>>>>>>>>>>>        // title for common file dialog
26119>>>>>>>>>>>>>        Property String Dialog_Caption C_$SelectBitmapFile
26120>>>>>>>>>>>>>        
26120>>>>>>>>>>>>>        // start-up directory for common file dialog
26120>>>>>>>>>>>>>        Property String Initial_Folder ""
26121>>>>>>>>>>>>>        
26121>>>>>>>>>>>>>        Send Define_ToolTip_Support_Mixin
26122>>>>>>>>>>>>>        
26122>>>>>>>>>>>>>        // this object should not take the focus
26122>>>>>>>>>>>>>        Set Focus_Mode to NonFocusable
26123>>>>>>>>>>>>>        Set Client_Area_State to False
26124>>>>>>>>>>>>>        Set pbUseFormWindowHandle to False   // must come after Define_ToolTip_Support_Mixin
26125>>>>>>>>>>>>>    End_Procedure
26126>>>>>>>>>>>>>    
26126>>>>>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
26127>>>>>>>>>>>>>    
26127>>>>>>>>>>>>>    // Although this is not a client it should add child objects to
26127>>>>>>>>>>>>>    // the focus tree. Should only be textboxes!
26127>>>>>>>>>>>>>    //
26127>>>>>>>>>>>>>    Procedure Add_Focus Integer Obj
26129>>>>>>>>>>>>>        Forward Send Add_Focus Obj
26131>>>>>>>>>>>>>        Broadcast Send Add_Focus Self
26133>>>>>>>>>>>>>    End_Procedure
26134>>>>>>>>>>>>>    
26134>>>>>>>>>>>>>    // Popup an open file dialog and select a bitmap file. Returns file
26134>>>>>>>>>>>>>    // name
26134>>>>>>>>>>>>>    //
26134>>>>>>>>>>>>>    Function Select_Bitmap Returns String
26136>>>>>>>>>>>>>        String sFileName
26136>>>>>>>>>>>>>        String sPropVal
26136>>>>>>>>>>>>>        Integer iRet
26136>>>>>>>>>>>>>        Handle hoOpenFile
26136>>>>>>>>>>>>>        
26136>>>>>>>>>>>>>        Get Create U_OpenDialog to  hoOpenFile
26137>>>>>>>>>>>>>        // Mask will look like this: "Bitmaps (.bmp;*.rle)|*.bmp;*.rle|All Files (*.*)|*.*"
26137>>>>>>>>>>>>>        Set Filter_String  of hoOpenFile to (C_$Bitmaps * "(.bmp;*.rle)|*.bmp;*.rle|" + C_$AllFiles * "(*.*)|*.*")
26138>>>>>>>>>>>>>        Get Dialog_Caption to sPropVal
26139>>>>>>>>>>>>>        Set Dialog_Caption of hoOpenFile to sPropVal
26140>>>>>>>>>>>>>        Get Initial_Folder to sPropVal
26141>>>>>>>>>>>>>        Set Initial_Folder of hoOpenFile to sPropVal
26142>>>>>>>>>>>>>        Get Show_Dialog    of hoOpenFile  to iRet
26143>>>>>>>>>>>>>        If iRet ;            Get File_Name of hoOpenFile  to sFileName
26146>>>>>>>>>>>>>        Send Destroy of hoOpenFile
26147>>>>>>>>>>>>>        Function_Return sFileName
26148>>>>>>>>>>>>>    End_Function
26149>>>>>>>>>>>>>    
26149>>>>>>>>>>>>>    Procedure Invoke_Select_Bitmap
26151>>>>>>>>>>>>>        String sFileName
26151>>>>>>>>>>>>>        Get Select_Bitmap to sFileName
26152>>>>>>>>>>>>>        If (sFileName<>"") Begin
26154>>>>>>>>>>>>>            Set Bitmap to sFileName
26155>>>>>>>>>>>>>            Set Changed_State to True
26156>>>>>>>>>>>>>        End
26156>>>>>>>>>>>>>>
26156>>>>>>>>>>>>>    End_Procedure
26157>>>>>>>>>>>>>    
26157>>>>>>>>>>>>>    
26157>>>>>>>>>>>>>    // Augmented to invoke the filedialog to retrieve a new bitmap
26157>>>>>>>>>>>>>    Procedure Mouse_Click Integer i1 Integer i2
26159>>>>>>>>>>>>>        Forward Send Mouse_Click i1 i2
26161>>>>>>>>>>>>>        If (Allow_Select_Bitmap_State(Self)) Begin
26163>>>>>>>>>>>>>            Send Invoke_Select_Bitmap
26164>>>>>>>>>>>>>        End
26164>>>>>>>>>>>>>>
26164>>>>>>>>>>>>>    End_Procedure
26165>>>>>>>>>>>>>    
26165>>>>>>>>>>>>>    Procedure Page_Object Integer iState
26167>>>>>>>>>>>>>        Forward Send Page_Object iState
26169>>>>>>>>>>>>>        
26169>>>>>>>>>>>>>        // Handle tooltip support....
26169>>>>>>>>>>>>>        If (iState = 0) Begin
26171>>>>>>>>>>>>>            Send RequestDeleteToolTip
26172>>>>>>>>>>>>>        End
26172>>>>>>>>>>>>>>
26172>>>>>>>>>>>>>        Else Begin
26173>>>>>>>>>>>>>            Send RequestAddToolTip
26174>>>>>>>>>>>>>        End
26174>>>>>>>>>>>>>>
26174>>>>>>>>>>>>>    End_Procedure
26175>>>>>>>>>>>>>    
26175>>>>>>>>>>>>>    
26175>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
26175>>>>>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
26175>>>>>>>>>>>>>    // is implemented in a mixin class.
26175>>>>>>>>>>>>>    Procedure RequestAddToolTip
26177>>>>>>>>>>>>>        Send AddToolTip
26178>>>>>>>>>>>>>    End_Procedure
26179>>>>>>>>>>>>>    
26179>>>>>>>>>>>>>    
26179>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
26179>>>>>>>>>>>>>    Procedure RequestDeleteToolTip
26181>>>>>>>>>>>>>        Send DeleteToolTip
26182>>>>>>>>>>>>>    End_Procedure
26183>>>>>>>>>>>>>End_Class
26184>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
26184>>>>>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cRichEdit.pkg)
26184>>>>>>>>>>>>>Use Windows.pkg
26184>>>>>>>>>>>>>Use cEdit_Mixin.pkg
Including file: cEdit_mixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cEdit_mixin.pkg)
26184>>>>>>>>>>>>>>>// mixin used by both cRichEdit and cTextEdit
26184>>>>>>>>>>>>>>>Use Windows.pkg
26184>>>>>>>>>>>>>>>
26184>>>>>>>>>>>>>>>// for undoType and RedoType
26184>>>>>>>>>>>>>>>Enum_List
26184>>>>>>>>>>>>>>>    Define utUnknown
26184>>>>>>>>>>>>>>>    Define utTyping
26184>>>>>>>>>>>>>>>    Define utDelete
26184>>>>>>>>>>>>>>>    Define utDragDrop
26184>>>>>>>>>>>>>>>    Define utCut
26184>>>>>>>>>>>>>>>    Define utPaste
26184>>>>>>>>>>>>>>>End_Enum_List
26184>>>>>>>>>>>>>>>
26184>>>>>>>>>>>>>>>Class cEdit_Mixin is a Mixin
26185>>>>>>>>>>>>>>>    
26185>>>>>>>>>>>>>>>    Procedure Define_cEdit_Mixin
26187>>>>>>>>>>>>>>>        Send Define_Standard_Object_Mixin
26188>>>>>>>>>>>>>>>        Send Define_Dflabel_Mixin
26189>>>>>>>>>>>>>>>        Send Define_ToolTip_Support_Mixin
26190>>>>>>>>>>>>>>>        
26190>>>>>>>>>>>>>>>        Set Label_Offset to 1 0
26191>>>>>>>>>>>>>>>        Set Label_Justification_Mode to Jmode_Top
26192>>>>>>>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
26193>>>>>>>>>>>>>>>        Set Color     to clWindow      // should be the default...also system colors don't work
26194>>>>>>>>>>>>>>>        Set TextColor to clWindowText  // should be the default
26195>>>>>>>>>>>>>>>        
26195>>>>>>>>>>>>>>>        Property Boolean Changed_State False
26196>>>>>>>>>>>>>>>        
26196>>>>>>>>>>>>>>>        Property Integer pbSuppressChange False
26197>>>>>>>>>>>>>>>        
26197>>>>>>>>>>>>>>>        Property Integer piPriorEnabledColor 0 // private, used by shadow_display
26198>>>>>>>>>>>>>>>        
26198>>>>>>>>>>>>>>>        Send Define_Shadow_Mixin
26199>>>>>>>>>>>>>>>        
26199>>>>>>>>>>>>>>>        Property Integer Floating_Menu_Object Default_Form_Floating_Menu_Id
26200>>>>>>>>>>>>>>>        
26200>>>>>>>>>>>>>>>        On_Key kEnter Send default_key
26201>>>>>>>>>>>>>>>        
26201>>>>>>>>>>>>>>>        Set Disable_default_action_button_state to True
26202>>>>>>>>>>>>>>>        
26202>>>>>>>>>>>>>>>    End_Procedure
26203>>>>>>>>>>>>>>>    
26203>>>>>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
26204>>>>>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
26205>>>>>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
26206>>>>>>>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
26207>>>>>>>>>>>>>>>    
26207>>>>>>>>>>>>>>>    // currently there is no built in context menu support (old edit has one).
26207>>>>>>>>>>>>>>>    Procedure Mouse_Down2 Integer iWindowNumber Integer iPosition
26209>>>>>>>>>>>>>>>        Integer obj rval
26209>>>>>>>>>>>>>>>        Forward Send mouse_down2 iWindowNumber iPosition
26211>>>>>>>>>>>>>>>        Get Floating_Menu_object to obj
26212>>>>>>>>>>>>>>>        If obj Begin
26214>>>>>>>>>>>>>>>            If (Focus(desktop)<>Self) Begin
26216>>>>>>>>>>>>>>>                Get msg_Activate to rval
26217>>>>>>>>>>>>>>>            End
26217>>>>>>>>>>>>>>>>
26217>>>>>>>>>>>>>>>            If (Focus(desktop)=Self) Begin
26219>>>>>>>>>>>>>>>                Send Popup to obj
26220>>>>>>>>>>>>>>>            End
26220>>>>>>>>>>>>>>>>
26220>>>>>>>>>>>>>>>        End
26220>>>>>>>>>>>>>>>>
26220>>>>>>>>>>>>>>>    End_Procedure
26221>>>>>>>>>>>>>>>    
26221>>>>>>>>>>>>>>>    Function Object_Shadow_State Returns Integer
26223>>>>>>>>>>>>>>>        Function_Return (Private.Shadow_State(Self))
26224>>>>>>>>>>>>>>>    End_Function
26225>>>>>>>>>>>>>>>    
26225>>>>>>>>>>>>>>>    // enables or disables an active window. Allows enabled_state to be used after object is paged
26225>>>>>>>>>>>>>>>    Procedure Enable_Window Integer iState
26227>>>>>>>>>>>>>>>        Handle hWnd
26227>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
26228>>>>>>>>>>>>>>>        If hWnd ;            Move (EnableWindow(hWnd,iState)) to hWnd
26231>>>>>>>>>>>>>>>    End_Procedure
26232>>>>>>>>>>>>>>>    
26232>>>>>>>>>>>>>>>    Procedure Set Current_Shadow_State Integer iState
26234>>>>>>>>>>>>>>>        Set Private.Shadow_State to iState     // used by get object_shadow_state/enabled_state
26235>>>>>>>>>>>>>>>        Set Window_Style to WS_DISABLED iState // used to set style before the object is paged
26236>>>>>>>>>>>>>>>        Send Enable_Window (not(iState))       // used to enable/disable after object is paged
26237>>>>>>>>>>>>>>>    End_Procedure
26238>>>>>>>>>>>>>>>    
26238>>>>>>>>>>>>>>>    
26238>>>>>>>>>>>>>>>    Procedure Shadow_Display
26240>>>>>>>>>>>>>>>        // control will take care of shadowing itself
26240>>>>>>>>>>>>>>>        Send Label_Shadow_Display // if object has a label text box, handle disabling this
26241>>>>>>>>>>>>>>>    End_Procedure
26242>>>>>>>>>>>>>>>    
26242>>>>>>>>>>>>>>>    Procedure Set Item_Shadow_State Integer iItem Integer iState
26244>>>>>>>>>>>>>>>    End_Procedure
26245>>>>>>>>>>>>>>>    
26245>>>>>>>>>>>>>>>    Function Item_Shadow_State Integer iItem Returns Integer
26247>>>>>>>>>>>>>>>    End_Function
26248>>>>>>>>>>>>>>>    
26248>>>>>>>>>>>>>>>    Procedure OnChange
26250>>>>>>>>>>>>>>>    End_Procedure
26251>>>>>>>>>>>>>>>    
26251>>>>>>>>>>>>>>>    Procedure OnMaxText
26253>>>>>>>>>>>>>>>    End_Procedure
26254>>>>>>>>>>>>>>>    
26254>>>>>>>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
26256>>>>>>>>>>>>>>>        Integer iParam
26256>>>>>>>>>>>>>>>        Forward Send Command wParam lParam
26258>>>>>>>>>>>>>>>        Move (hi(wParam)) to iParam
26259>>>>>>>>>>>>>>>        If (iParam=EN_CHANGE) Begin
26261>>>>>>>>>>>>>>>            // if we are supressing change notification, do nothing.
26261>>>>>>>>>>>>>>>            If (pbSuppressChange(Self)) ;                Procedure_Return
26264>>>>>>>>>>>>>>>            If not (changed_state(Self)) Begin
26266>>>>>>>>>>>>>>>                Set Changed_state to True
26267>>>>>>>>>>>>>>>            End
26267>>>>>>>>>>>>>>>>
26267>>>>>>>>>>>>>>>            Send OnChange
26268>>>>>>>>>>>>>>>        End
26268>>>>>>>>>>>>>>>>
26268>>>>>>>>>>>>>>>        Else If (iParam=EN_MAXTEXT) Begin
26271>>>>>>>>>>>>>>>            Send OnMaxText
26272>>>>>>>>>>>>>>>        End
26272>>>>>>>>>>>>>>>>
26272>>>>>>>>>>>>>>>    End_Procedure
26273>>>>>>>>>>>>>>>    
26273>>>>>>>>>>>>>>>    // Some messages trigger the command message with a change event. In some circumstances we must suppress this.
26273>>>>>>>>>>>>>>>    // The delete_data message and the page message both do this.
26273>>>>>>>>>>>>>>>    
26273>>>>>>>>>>>>>>>    Procedure Delete_Data
26275>>>>>>>>>>>>>>>        Boolean bWas
26275>>>>>>>>>>>>>>>        Get pbSuppressChange to bWas
26276>>>>>>>>>>>>>>>        Set pbSuppressChange to True // Delete_Data sends command which triggers change. We suppress that here
26277>>>>>>>>>>>>>>>        Forward Send delete_data
26279>>>>>>>>>>>>>>>        Set changed_state to False
26280>>>>>>>>>>>>>>>        Send OnChange
26281>>>>>>>>>>>>>>>        Set pbSuppressChange to bWas
26282>>>>>>>>>>>>>>>    End_Procedure
26283>>>>>>>>>>>>>>>    
26283>>>>>>>>>>>>>>>    Procedure Page Integer iState
26285>>>>>>>>>>>>>>>        Boolean bWas
26285>>>>>>>>>>>>>>>        Get pbSuppressChange to bWas
26286>>>>>>>>>>>>>>>        Set pbSuppressChange to True  // Page sends command which triggers change. We suppress that here
26287>>>>>>>>>>>>>>>        Forward Send Page iState
26289>>>>>>>>>>>>>>>        Set pbSuppressChange to bWas
26290>>>>>>>>>>>>>>>    End_Procedure
26291>>>>>>>>>>>>>>>    
26291>>>>>>>>>>>>>>>    
26291>>>>>>>>>>>>>>>    Procedure AppendTextLn String sText
26293>>>>>>>>>>>>>>>        Send AppendText sText
26294>>>>>>>>>>>>>>>        Send AppendText (character(10))
26295>>>>>>>>>>>>>>>    End_Procedure
26296>>>>>>>>>>>>>>>    
26296>>>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
26296>>>>>>>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
26296>>>>>>>>>>>>>>>    // is implemented in a mixin class.
26296>>>>>>>>>>>>>>>    Procedure RequestAddToolTip
26298>>>>>>>>>>>>>>>        Send AddToolTip
26299>>>>>>>>>>>>>>>    End_Procedure
26300>>>>>>>>>>>>>>>    
26300>>>>>>>>>>>>>>>    
26300>>>>>>>>>>>>>>>    // Called by Page_Object. Handles tooltip removal.
26300>>>>>>>>>>>>>>>    Procedure RequestDeleteToolTip
26302>>>>>>>>>>>>>>>        Send DeleteToolTip
26303>>>>>>>>>>>>>>>    End_Procedure
26304>>>>>>>>>>>>>>>End_Class
26305>>>>>>>>>>>>>
26305>>>>>>>>>>>>>// constants used for RichEdit Properties
26305>>>>>>>>>>>>>// peAlignment
26305>>>>>>>>>>>>>Enum_List
26305>>>>>>>>>>>>>    Define alLeft   for 1
26305>>>>>>>>>>>>>    Define alRight  for 2
26305>>>>>>>>>>>>>    Define alCenter for 3
26305>>>>>>>>>>>>>End_Enum_List
26305>>>>>>>>>>>>>
26305>>>>>>>>>>>>>// peBullets
26305>>>>>>>>>>>>>Enum_List
26305>>>>>>>>>>>>>    Define buNone
26305>>>>>>>>>>>>>    Define buBullets
26305>>>>>>>>>>>>>    Define buArabicNumbers
26305>>>>>>>>>>>>>    Define buLowerLetters
26305>>>>>>>>>>>>>    Define buUpperLetters
26305>>>>>>>>>>>>>    Define buLowerRomans
26305>>>>>>>>>>>>>    Define buUpperRomans
26305>>>>>>>>>>>>>End_Enum_List
26305>>>>>>>>>>>>>
26305>>>>>>>>>>>>>// peBulletStyle
26305>>>>>>>>>>>>>Enum_List
26305>>>>>>>>>>>>>    Define busRightParen   for 0
26305>>>>>>>>>>>>>    Define busEncloseParen for 256
26305>>>>>>>>>>>>>    Define busPeriod       for 512
26305>>>>>>>>>>>>>    Define busNumberOnly   for 768
26305>>>>>>>>>>>>>    Define busNoDisplay    for 1024
26305>>>>>>>>>>>>>End_Enum_List
26305>>>>>>>>>>>>>
26305>>>>>>>>>>>>>// peLineSpacingType
26305>>>>>>>>>>>>>Enum_List
26305>>>>>>>>>>>>>    Define lstSingle
26305>>>>>>>>>>>>>    Define lstSingleAndOneHalf
26305>>>>>>>>>>>>>    Define lstDouble
26305>>>>>>>>>>>>>End_Enum_List
26305>>>>>>>>>>>>>
26305>>>>>>>>>>>>>Class cRichEdit is a DFBaseRichEdit
26306>>>>>>>>>>>>>    
26306>>>>>>>>>>>>>    Procedure Construct_Object
26308>>>>>>>>>>>>>        Forward Send Construct_Object
26310>>>>>>>>>>>>>        Send Define_cEdit_Mixin
26311>>>>>>>>>>>>>        
26311>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
26312>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
26313>>>>>>>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
26314>>>>>>>>>>>>>        
26314>>>>>>>>>>>>>    End_Procedure
26315>>>>>>>>>>>>>    
26315>>>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
26316>>>>>>>>>>>>>    
26316>>>>>>>>>>>>>    Procedure ToggleBold
26318>>>>>>>>>>>>>        Set pbBold to (not(pbBold(Self)))
26319>>>>>>>>>>>>>    End_Procedure
26320>>>>>>>>>>>>>    
26320>>>>>>>>>>>>>    Procedure ToggleItalics
26322>>>>>>>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
26323>>>>>>>>>>>>>    End_Procedure
26324>>>>>>>>>>>>>    
26324>>>>>>>>>>>>>    Procedure ToggleUnderline
26326>>>>>>>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
26327>>>>>>>>>>>>>    End_Procedure
26328>>>>>>>>>>>>>    
26328>>>>>>>>>>>>>End_Class
26329>>>>>>>>>>>>>
26329>>>>>>>>>>>>>
26329>>>>>>>>>>>Use cTextEdit.pkg
Including file: cTextEdit.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cTextEdit.pkg)
26329>>>>>>>>>>>>>use Windows.pkg
26329>>>>>>>>>>>>>Use cEdit_Mixin.pkg
26329>>>>>>>>>>>>>
26329>>>>>>>>>>>>>Class cTextEdit is a DFBaseTextEdit
26330>>>>>>>>>>>>>    
26330>>>>>>>>>>>>>    Procedure Construct_Object
26332>>>>>>>>>>>>>        Forward Send Construct_Object
26334>>>>>>>>>>>>>        Send Define_cEdit_Mixin
26335>>>>>>>>>>>>>    End_Procedure
26336>>>>>>>>>>>>>    
26336>>>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
26337>>>>>>>>>>>>>    
26337>>>>>>>>>>>>>End_Class
26338>>>>>>>>>>>>>
26338>>>>>>>>>>>>>
26338>>>>>>>>>>>>>
26338>>>>>>>>>>>Use cRichEdit.pkg
26338>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
26338>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
26338>>>>>>>>>>>>>>>Use VDFBase.pkg
26338>>>>>>>>>>>>>>>
26338>>>>>>>>>>>>>>>Class cFormatter is an cObject
26339>>>>>>>>>>>>>>>    
26339>>>>>>>>>>>>>>>    Procedure Construct_object
26341>>>>>>>>>>>>>>>        Integer iCh
26341>>>>>>>>>>>>>>>        Forward Send construct_object
26343>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
26344>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
26345>>>>>>>>>>>>>>>        
26345>>>>>>>>>>>>>>>        Property String  psLeft
26346>>>>>>>>>>>>>>>        Property String  psright
26347>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
26348>>>>>>>>>>>>>>>        Property Integer piPoints
26349>>>>>>>>>>>>>>>        
26349>>>>>>>>>>>>>>>        Property String  psCurPosLeft
26350>>>>>>>>>>>>>>>        Property String  psCurPosright
26351>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
26352>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
26353>>>>>>>>>>>>>>>        
26353>>>>>>>>>>>>>>>        Property String  psCurNegLeft
26354>>>>>>>>>>>>>>>        Property String  psCurNegright
26355>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
26356>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
26357>>>>>>>>>>>>>>>        
26357>>>>>>>>>>>>>>>        Property String  psNumPosLeft
26358>>>>>>>>>>>>>>>        Property String  psNumPosright
26359>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
26360>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
26361>>>>>>>>>>>>>>>        
26361>>>>>>>>>>>>>>>        Property String  psNumNegLeft
26362>>>>>>>>>>>>>>>        Property String  psNumNegright
26363>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
26364>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
26365>>>>>>>>>>>>>>>        
26365>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
26366>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
26367>>>>>>>>>>>>>>>        
26367>>>>>>>>>>>>>>>    End_Procedure
26368>>>>>>>>>>>>>>>    
26368>>>>>>>>>>>>>>>    // internal
26368>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
26368>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
26370>>>>>>>>>>>>>>>        
26370>>>>>>>>>>>>>>>        String sLeft sRight sDigit
26370>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
26370>>>>>>>>>>>>>>>        
26370>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
26370>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
26370>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
26371>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
26372>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
26373>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
26374>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
26375>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
26376>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
26377>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
26378>>>>>>>>>>>>>>>        
26378>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
26379>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
26382>>>>>>>>>>>>>>>        
26382>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
26383>>>>>>>>>>>>>>>        
26383>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
26384>>>>>>>>>>>>>>>        
26384>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
26384>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
26385>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
26386>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
26387>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
26388>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
26389>>>>>>>>>>>>>>>        
26389>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
26391>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
26392>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
26394>>>>>>>>>>>>>>>                Move -2 to iDigits
26395>>>>>>>>>>>>>>>                Increment i
26396>>>>>>>>>>>>>>>            End
26396>>>>>>>>>>>>>>>>
26396>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
26400>>>>>>>>>>>>>>>                Increment i
26401>>>>>>>>>>>>>>>            Loop
26402>>>>>>>>>>>>>>>>
26402>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
26403>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
26406>>>>>>>>>>>>>>>            //
26406>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
26407>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
26411>>>>>>>>>>>>>>>                Increment i
26412>>>>>>>>>>>>>>>            Loop
26413>>>>>>>>>>>>>>>>
26413>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
26414>>>>>>>>>>>>>>>        End
26414>>>>>>>>>>>>>>>>
26414>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
26415>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
26416>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
26417>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
26419>>>>>>>>>>>>>>>                Move sFmt to sLeft
26420>>>>>>>>>>>>>>>                Move ""   to sRight
26421>>>>>>>>>>>>>>>            End
26421>>>>>>>>>>>>>>>>
26421>>>>>>>>>>>>>>>            Else Begin
26422>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
26423>>>>>>>>>>>>>>>                Move 1 to i
26424>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
26428>>>>>>>>>>>>>>>                    Increment i
26429>>>>>>>>>>>>>>>                Loop
26430>>>>>>>>>>>>>>>>
26430>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
26431>>>>>>>>>>>>>>>            End
26431>>>>>>>>>>>>>>>>
26431>>>>>>>>>>>>>>>        End
26431>>>>>>>>>>>>>>>>
26431>>>>>>>>>>>>>>>        // set temporary format properties and exit
26431>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
26432>>>>>>>>>>>>>>>        Set psLeft         to sLeft
26433>>>>>>>>>>>>>>>        Set psRight        to sRight
26434>>>>>>>>>>>>>>>        Set piPoints       to iDigits
26435>>>>>>>>>>>>>>>    End_Procedure
26436>>>>>>>>>>>>>>>    
26436>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
26436>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
26436>>>>>>>>>>>>>>>    //
26436>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
26436>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
26438>>>>>>>>>>>>>>>        String sPos sNeg
26438>>>>>>>>>>>>>>>        Integer iPos
26438>>>>>>>>>>>>>>>        
26438>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
26439>>>>>>>>>>>>>>>        If iPos Begin
26441>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
26442>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
26443>>>>>>>>>>>>>>>        End
26443>>>>>>>>>>>>>>>>
26443>>>>>>>>>>>>>>>        Else Begin
26444>>>>>>>>>>>>>>>            Move sFmt         to sPos
26445>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
26446>>>>>>>>>>>>>>>        End
26446>>>>>>>>>>>>>>>>
26446>>>>>>>>>>>>>>>        Send ParseFormat sPos
26447>>>>>>>>>>>>>>>        If bCurrency Begin
26449>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
26450>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
26451>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
26452>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
26453>>>>>>>>>>>>>>>        End
26453>>>>>>>>>>>>>>>>
26453>>>>>>>>>>>>>>>        Else Begin
26454>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
26455>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
26456>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
26457>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
26458>>>>>>>>>>>>>>>        End
26458>>>>>>>>>>>>>>>>
26458>>>>>>>>>>>>>>>        
26458>>>>>>>>>>>>>>>        Send ParseFormat sNeg
26459>>>>>>>>>>>>>>>        If bCurrency Begin
26461>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
26462>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
26463>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
26464>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
26465>>>>>>>>>>>>>>>        End
26465>>>>>>>>>>>>>>>>
26465>>>>>>>>>>>>>>>        Else Begin
26466>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
26467>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
26468>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
26469>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
26470>>>>>>>>>>>>>>>        End
26470>>>>>>>>>>>>>>>>
26470>>>>>>>>>>>>>>>    End_Procedure
26471>>>>>>>>>>>>>>>    
26471>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
26471>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
26473>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
26473>>>>>>>>>>>>>>>        Integer iDec iLen iCh
26473>>>>>>>>>>>>>>>        
26473>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
26476>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
26477>>>>>>>>>>>>>>>        
26477>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
26478>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
26479>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
26480>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
26481>>>>>>>>>>>>>>>        // format for decimal separator
26481>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
26484>>>>>>>>>>>>>>>        
26484>>>>>>>>>>>>>>>        // format for thousand sep.
26484>>>>>>>>>>>>>>>        If bSep Begin
26486>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
26489>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
26490>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
26491>>>>>>>>>>>>>>>            While (iLen>3)
26495>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
26496>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
26497>>>>>>>>>>>>>>>            Loop
26498>>>>>>>>>>>>>>>>
26498>>>>>>>>>>>>>>>        End
26498>>>>>>>>>>>>>>>>
26498>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
26498>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
26501>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
26502>>>>>>>>>>>>>>>    End_Function
26503>>>>>>>>>>>>>>>    
26503>>>>>>>>>>>>>>>    // Public: Format for currency
26503>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
26505>>>>>>>>>>>>>>>        String  sLeft sRight
26505>>>>>>>>>>>>>>>        Integer bSep
26505>>>>>>>>>>>>>>>        If (nNumber<0) Begin
26507>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
26508>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
26509>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
26510>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
26513>>>>>>>>>>>>>>>        End
26513>>>>>>>>>>>>>>>>
26513>>>>>>>>>>>>>>>        Else Begin
26514>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
26515>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
26516>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
26517>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
26520>>>>>>>>>>>>>>>        End
26520>>>>>>>>>>>>>>>>
26520>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26521>>>>>>>>>>>>>>>    End_Function
26522>>>>>>>>>>>>>>>    
26522>>>>>>>>>>>>>>>    // Public: Format for numeric
26522>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
26524>>>>>>>>>>>>>>>        String  sLeft sRight
26524>>>>>>>>>>>>>>>        Integer bSep
26524>>>>>>>>>>>>>>>        If (nNumber<0) Begin
26526>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
26527>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
26528>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
26529>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
26532>>>>>>>>>>>>>>>        End
26532>>>>>>>>>>>>>>>>
26532>>>>>>>>>>>>>>>        Else Begin
26533>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
26534>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
26535>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
26536>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
26539>>>>>>>>>>>>>>>        End
26539>>>>>>>>>>>>>>>>
26539>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26540>>>>>>>>>>>>>>>    End_Function
26541>>>>>>>>>>>>>>>    
26541>>>>>>>>>>>>>>>    
26541>>>>>>>>>>>>>>>    // Public: Format passing format string
26541>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
26543>>>>>>>>>>>>>>>        Integer iPos bIsNeg
26543>>>>>>>>>>>>>>>        String  sLeft sRight
26543>>>>>>>>>>>>>>>        Integer iPoints bSep
26543>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
26544>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
26545>>>>>>>>>>>>>>>        Case Begin
26545>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
26548>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
26552>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
26556>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
26558>>>>>>>>>>>>>>>        Case End
26558>>>>>>>>>>>>>>>        Send ParseFormat sFmt
26559>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
26560>>>>>>>>>>>>>>>        Get psLeft         to sLeft
26561>>>>>>>>>>>>>>>        Get psRight        to sRight
26562>>>>>>>>>>>>>>>        Get piPoints       to iPoints
26563>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
26564>>>>>>>>>>>>>>>    End_Function
26565>>>>>>>>>>>>>>>    
26565>>>>>>>>>>>>>>>End_Class
26566>>>>>>>>>>>>>
26566>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
26566>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
26567>>>>>>>>>>>>>
26567>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
26569>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
26570>>>>>>>>>>>>>End_Function
26571>>>>>>>>>>>>>
26571>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
26573>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
26574>>>>>>>>>>>>>End_Function
26575>>>>>>>>>>>>>
26575>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
26577>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
26578>>>>>>>>>>>>>End_Function
26579>>>>>>>>>>>>>
26579>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
26581>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
26582>>>>>>>>>>>>>End_Procedure
26583>>>>>>>>>>>>>
26583>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
26585>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
26586>>>>>>>>>>>>>End_Procedure
26587>>>>>>>>>>>>>
26587>>>>>>>>>>>>>
26587>>>>>>>>>>>Use tWinStructs.pkg
26587>>>>>>>>>>>
26587>>>>>>>>>>>Use cli.pkg
26587>>>>>>>>>>>Use DFBTRDRV.PKG
26587>>>>>>>>>>>Use MSSqldrv.pkg
26587>>>>>>>>>>>Use db2_drv.pkg
26587>>>>>>>>>>>Use odbc_drv.pkg
26587>>>>>>>>>>>Use seq_chnl.pkg
26587>>>>>>>>>>>
26587>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
26587>>>>>>>>>>>Register_Function Help_filename Returns String
26587>>>>>>>>>>>Register_Function GetHelpFile Returns String
26587>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
26587>>>>>>>>>>>
26587>>>>>>>>>>>// *** Constant Declarations: ***
26587>>>>>>>>>>>//
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>// System icon menu constants. If the upper left hand
26587>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
26587>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
26587>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
26587>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
26587>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
26587>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
26587>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
26587>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
26587>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
26587>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
26587>>>>>>>>>>>
26587>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
26587>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
26587>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
26587>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
26587>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
26587>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
26587>>>>>>>>>>>
26587>>>>>>>>>>>// *** Struct Declarations: ***
26587>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
26587>>>>>>>>>>>    DWord   cbSize
26587>>>>>>>>>>>    Integer fMask
26587>>>>>>>>>>>    Handle  hwnd
26587>>>>>>>>>>>    Pointer lpVerb
26587>>>>>>>>>>>    Pointer lpFile
26587>>>>>>>>>>>    Pointer lpParameters
26587>>>>>>>>>>>    Pointer lpDirectory
26587>>>>>>>>>>>    Integer nShow
26587>>>>>>>>>>>    Integer iMissingAlignment1
26587>>>>>>>>>>>    Pointer hInstApp
26587>>>>>>>>>>>    Pointer lpIDList
26587>>>>>>>>>>>    Pointer lpClass
26587>>>>>>>>>>>    Handle  hkeyClass
26587>>>>>>>>>>>    DWord   dwHotKey
26587>>>>>>>>>>>    Integer iMissingAlignment2
26587>>>>>>>>>>>    Handle  hIconMonitor // Union
26587>>>>>>>>>>>    //Handle  hMonitor     // Union
26587>>>>>>>>>>>    Handle  hProcess
26587>>>>>>>>>>>End_Struct
26587>>>>>>>>>>>
26587>>>>>>>>>>>
26587>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
26587>>>>>>>>>>>//Type MEMORYSTATUS
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
26587>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
26587>>>>>>>>>>>//End_Type
26587>>>>>>>>>>>
26587>>>>>>>>>>>// *** External Function calls: ***
26587>>>>>>>>>>>//
26587>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
26588>>>>>>>>>>>
26588>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
26589>>>>>>>>>>>
26589>>>>>>>>>>>// Do not call directly, use the wrapper function instead
26589>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
26590>>>>>>>>>>>
26590>>>>>>>>>>>    // Wrapper Function WNetGetUser
26590>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
26592>>>>>>>>>>>
26592>>>>>>>>>>>        DWord   dwResult
26592>>>>>>>>>>>        UWide   uwName uwUserName
26592>>>>>>>>>>>        UWide   uwName uwUserName
26592>>>>>>>>>>>
26592>>>>>>>>>>>        Send StringToWide lpName (&uwName)
26593>>>>>>>>>>>
26593>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
26594>>>>>>>>>>>
26594>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
26595>>>>>>>>>>>
26595>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
26596>>>>>>>>>>>
26596>>>>>>>>>>>        Function_Return dwResult
26597>>>>>>>>>>>    End_Function
26598>>>>>>>>>>>
26598>>>>>>>>>>>
26598>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
26599>>>>>>>>>>>
26599>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
26600>>>>>>>>>>>
26600>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
26601>>>>>>>>>>>
26601>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
26602>>>>>>>>>>>
26602>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
26603>>>>>>>>>>>
26603>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
26603>>>>>>>>>>>
26603>>>>>>>>>>>Function ComputerName Desktop Returns String
26605>>>>>>>>>>>    String sName
26605>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
26606>>>>>>>>>>>>
26606>>>>>>>>>>>    Function_Return sName
26607>>>>>>>>>>>End_Function
26608>>>>>>>>>>>
26608>>>>>>>>>>>Function Network_User_Name Desktop Returns String
26610>>>>>>>>>>>    WString wName
26610>>>>>>>>>>>    Integer iRetval iLength
26610>>>>>>>>>>>
26610>>>>>>>>>>>    Move 0 to iLength
26611>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
26612>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
26613>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
26614>>>>>>>>>>>
26614>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
26616>>>>>>>>>>>        Function_Return (CString (wName))
26617>>>>>>>>>>>    End
26617>>>>>>>>>>>>
26617>>>>>>>>>>>
26617>>>>>>>>>>>    Function_Return "User Unknown"
26618>>>>>>>>>>>End_Function
26619>>>>>>>>>>>
26619>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
26621>>>>>>>>>>>    String sClient sDriver sClientDriver
26621>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
26621>>>>>>>>>>>    Handle hoMsqlDrv
26621>>>>>>>>>>>
26621>>>>>>>>>>>    Move 0 to iDriver
26622>>>>>>>>>>>    Move "" to sClient
26623>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
26626>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
26632>>>>>>>>>>>>
26632>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
26635>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
26637>>>>>>>>>>>            Move iCount to iDriver
26638>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
26639>>>>>>>>>>>        End
26639>>>>>>>>>>>>
26639>>>>>>>>>>>    Loop
26640>>>>>>>>>>>>
26640>>>>>>>>>>>
26640>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
26640>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
26642>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
26645>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
26646>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
26647>>>>>>>>>>>        Send Destroy of hoMsqlDrv
26648>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
26649>>>>>>>>>>>    End
26649>>>>>>>>>>>>
26649>>>>>>>>>>>
26649>>>>>>>>>>>    Function_Return sClient
26650>>>>>>>>>>>End_Function
26651>>>>>>>>>>>
26651>>>>>>>>>>>// *** Class Declarations: ***
26651>>>>>>>>>>>//
26651>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
26652>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
26654>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
26655>>>>>>>>>>>    End_Procedure
26656>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
26658>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
26660>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
26661>>>>>>>>>>>    End_Procedure
26662>>>>>>>>>>>End_Class
26663>>>>>>>>>>>
26663>>>>>>>>>>>Class cCopyEditorContentButton is a Button
26664>>>>>>>>>>>    Procedure Construct_Object
26666>>>>>>>>>>>        Forward Send Construct_Object
26668>>>>>>>>>>>        Property Handle phoEditorHandle
26669>>>>>>>>>>>        Set psToolTip to C_$DescCopy
26670>>>>>>>>>>>    End_Procedure
26671>>>>>>>>>>>
26671>>>>>>>>>>>    Procedure CopyToWindowsClipboard
26673>>>>>>>>>>>        Handle hoEditor
26673>>>>>>>>>>>        Boolean bCanCopy
26673>>>>>>>>>>>        Address aEditorAddress
26673>>>>>>>>>>>
26673>>>>>>>>>>>        Get phoEditorHandle to hoEditor
26674>>>>>>>>>>>        Send Select_All of hoEditor
26675>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
26676>>>>>>>>>>>        If (bCanCopy = True) Begin
26678>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
26679>>>>>>>>>>>            Send Copy   of hoEditor
26680>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
26680>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
26681>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
26682>>>>>>>>>>>        End
26682>>>>>>>>>>>>
26682>>>>>>>>>>>    End_Procedure
26683>>>>>>>>>>>End_Class
26684>>>>>>>>>>>
26684>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
26685>>>>>>>>>>>    Procedure Construct_Object
26687>>>>>>>>>>>        Forward Send Construct_Object
26689>>>>>>>>>>>
26689>>>>>>>>>>>        Set Size to 100 245
26690>>>>>>>>>>>        Set Location to 6 6
26691>>>>>>>>>>>        Set Border_Style to Border_None
26692>>>>>>>>>>>        Set Read_Only_State to True
26693>>>>>>>>>>>        Set pbWrap to True
26694>>>>>>>>>>>        Set peAnchors to anAll
26695>>>>>>>>>>>    End_Procedure
26696>>>>>>>>>>>
26696>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
26696>>>>>>>>>>>
26696>>>>>>>>>>>    Procedure AppendTextLn String sText
26698>>>>>>>>>>>        String sWorkspaceWSFile
26698>>>>>>>>>>>
26698>>>>>>>>>>>        // Only works for English:
26698>>>>>>>>>>>        If (ghoApplication > 0) Begin
26700>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
26702>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
26703>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
26704>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
26705>>>>>>>>>>>            End
26705>>>>>>>>>>>>
26705>>>>>>>>>>>        End
26705>>>>>>>>>>>>
26705>>>>>>>>>>>        Send AppendText sText
26706>>>>>>>>>>>        Send AppendText (character(10))
26707>>>>>>>>>>>    End_Procedure
26708>>>>>>>>>>>
26708>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
26708>>>>>>>>>>>    //    information box
26708>>>>>>>>>>>    Procedure Show_Current_Directory
26710>>>>>>>>>>>        String sDir
26710>>>>>>>>>>>
26710>>>>>>>>>>>        Get_Current_Directory To sDir
26711>>>>>>>>>>>
26711>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
26712>>>>>>>>>>>    End_Procedure
26713>>>>>>>>>>>
26713>>>>>>>>>>>    Procedure Show_Windows_Directory
26715>>>>>>>>>>>        String sWindir
26715>>>>>>>>>>>
26715>>>>>>>>>>>        Get_Windows_Directory To sWindir
26716>>>>>>>>>>>
26716>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
26717>>>>>>>>>>>    End_Procedure
26718>>>>>>>>>>>
26718>>>>>>>>>>>    Procedure Show_Current_User
26720>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
26721>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
26722>>>>>>>>>>>    End_Procedure
26723>>>>>>>>>>>
26723>>>>>>>>>>>    Procedure Show_Number_Format
26725>>>>>>>>>>>        Integer iFormat
26725>>>>>>>>>>>        String sFormatText
26725>>>>>>>>>>>
26725>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
26728>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
26729>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
26730>>>>>>>>>>>
26730>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
26733>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
26734>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
26735>>>>>>>>>>>    End_Procedure
26736>>>>>>>>>>>
26736>>>>>>>>>>>    Procedure Show_Filelist_Name
26738>>>>>>>>>>>        String sFilename
26738>>>>>>>>>>>
26738>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
26741>>>>>>>>>>>
26741>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
26742>>>>>>>>>>>    End_Procedure
26743>>>>>>>>>>>
26743>>>>>>>>>>>    Procedure Show_Lock_Delay
26745>>>>>>>>>>>        Integer iLockdelay
26745>>>>>>>>>>>
26745>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
26748>>>>>>>>>>>
26748>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
26749>>>>>>>>>>>    End_Procedure
26750>>>>>>>>>>>
26750>>>>>>>>>>>    Procedure Show_Lock_Timeout
26752>>>>>>>>>>>        Integer iLockTimeout
26752>>>>>>>>>>>
26752>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
26755>>>>>>>>>>>
26755>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
26756>>>>>>>>>>>    End_Procedure
26757>>>>>>>>>>>
26757>>>>>>>>>>>    Procedure Show_Screen_Size
26759>>>>>>>>>>>        Integer iYscreensize iXscreensize
26759>>>>>>>>>>>
26759>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
26760>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
26761>>>>>>>>>>>
26761>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
26762>>>>>>>>>>>    End_Procedure
26763>>>>>>>>>>>
26763>>>>>>>>>>>    Procedure Show_Page_Size
26765>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
26766>>>>>>>>>>>    End_procedure
26767>>>>>>>>>>>
26767>>>>>>>>>>>    Procedure Show_Date
26769>>>>>>>>>>>        Date dToday
26769>>>>>>>>>>>
26769>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
26770>>>>>>>>>>>
26770>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
26771>>>>>>>>>>>    End_procedure
26772>>>>>>>>>>>
26772>>>>>>>>>>>    Procedure Show_Date_Format
26774>>>>>>>>>>>        Integer iDateFormat
26774>>>>>>>>>>>        String sDateFormat
26774>>>>>>>>>>>
26774>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
26777>>>>>>>>>>>        Case Begin
26777>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
26779>>>>>>>>>>>                Move C_$USA To sDateFormat
26780>>>>>>>>>>>                Case Break
26781>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
26784>>>>>>>>>>>                Move C_$European To sDateFormat
26785>>>>>>>>>>>                Case Break
26786>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
26789>>>>>>>>>>>                Move C_$Military To sDateFormat
26790>>>>>>>>>>>                Case Break
26791>>>>>>>>>>>            Case Else
26791>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
26792>>>>>>>>>>>                Case Break
26793>>>>>>>>>>>        Case End
26793>>>>>>>>>>>
26793>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
26794>>>>>>>>>>>    End_Procedure
26795>>>>>>>>>>>
26795>>>>>>>>>>>    // 2013-08-14 NGS
26795>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
26795>>>>>>>>>>>    Procedure Show_Systemresources
26797>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
26797>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
26797>>>>>>>>>>>        Integer iRetval
26797>>>>>>>>>>>        Number nValue
26797>>>>>>>>>>>        String sValue
26797>>>>>>>>>>>
26797>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
26798>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
26799>>>>>>>>>>>        If (iRetval = 0) Begin
26801>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
26802>>>>>>>>>>>            Procedure_Return
26803>>>>>>>>>>>        End
26803>>>>>>>>>>>>
26803>>>>>>>>>>>
26803>>>>>>>>>>>        Send AppendTextLn ""
26804>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
26805>>>>>>>>>>>
26805>>>>>>>>>>>        // Show memory in Gigabytes:
26805>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
26806>>>>>>>>>>>        Move (Round(nValue)) to nValue
26807>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
26808>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
26809>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
26810>>>>>>>>>>>
26810>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
26810>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
26811>>>>>>>>>>>        Move (Round(nValue)) to nValue
26812>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26813>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
26814>>>>>>>>>>>
26814>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
26814>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
26815>>>>>>>>>>>        Move (Round(nValue)) to nValue
26816>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26817>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
26818>>>>>>>>>>>
26818>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
26818>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
26819>>>>>>>>>>>        Move (Round(nValue)) to nValue
26820>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
26821>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
26822>>>>>>>>>>>
26822>>>>>>>>>>>        // Add an empty row after the memory information:
26822>>>>>>>>>>>        Send AppendTextLn ""
26823>>>>>>>>>>>    End_Procedure
26824>>>>>>>>>>>
26824>>>>>>>>>>>    Procedure Show_Registration
26826>>>>>>>>>>>        String sRegName
26826>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
26826>>>>>>>>>>>
26826>>>>>>>>>>>        Registration sRegName iSN
26827>>>>>>>>>>>>
26827>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
26828>>>>>>>>>>>        Get_Current_User_Count to iUserCount
26829>>>>>>>>>>>
26829>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
26830>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
26831>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
26832>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
26833>>>>>>>>>>>    End_Procedure
26834>>>>>>>>>>>
26834>>>>>>>>>>>    //****************************************************************************
26834>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
26834>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
26834>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
26834>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
26834>>>>>>>>>>>    // information To be displayed
26834>>>>>>>>>>>    //****************************************************************************
26834>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
26834>>>>>>>>>>>
26834>>>>>>>>>>>    Procedure Show_ServicePack
26836>>>>>>>>>>>        String sKey sVersion sDataFlex
26836>>>>>>>>>>>        Handle hoRegistry
26836>>>>>>>>>>>        Boolean bExists bOpened
26836>>>>>>>>>>>
26836>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
26837>>>>>>>>>>>
26837>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
26838>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
26839>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
26840>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
26841>>>>>>>>>>>
26841>>>>>>>>>>>        If (bExists) Begin
26843>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
26844>>>>>>>>>>>        End
26844>>>>>>>>>>>>
26844>>>>>>>>>>>        Else Begin
26845>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
26846>>>>>>>>>>>        End
26846>>>>>>>>>>>>
26846>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
26847>>>>>>>>>>>        If (bExists) Begin
26849>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
26850>>>>>>>>>>>            If (bOpened) Begin
26852>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
26853>>>>>>>>>>>                If (bExists) Begin
26855>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
26856>>>>>>>>>>>                End
26856>>>>>>>>>>>>
26856>>>>>>>>>>>                Send CloseKey of hoRegistry
26857>>>>>>>>>>>            End
26857>>>>>>>>>>>>
26857>>>>>>>>>>>        End
26857>>>>>>>>>>>>
26857>>>>>>>>>>>        Send Destroy of hoRegistry
26858>>>>>>>>>>>
26858>>>>>>>>>>>        If (sVersion <> "") Begin
26860>>>>>>>>>>>           Send AppendTextLn sVersion
26861>>>>>>>>>>>           Send AppendTextLn ""
26862>>>>>>>>>>>        End
26862>>>>>>>>>>>>
26862>>>>>>>>>>>    End_Procedure
26863>>>>>>>>>>>
26863>>>>>>>>>>>    Procedure Show_WorkspaceInformation
26865>>>>>>>>>>>        Integer hoWorkspace
26865>>>>>>>>>>>
26865>>>>>>>>>>>        If (ghoApplication <> 0) Begin
26867>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
26868>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
26870>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
26871>>>>>>>>>>>            End
26871>>>>>>>>>>>>
26871>>>>>>>>>>>        End
26871>>>>>>>>>>>>
26871>>>>>>>>>>>    End_Procedure
26872>>>>>>>>>>>
26872>>>>>>>>>>>    //****************************************************************************
26872>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
26872>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
26872>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
26872>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
26872>>>>>>>>>>>    // the information To be displayed
26872>>>>>>>>>>>    //****************************************************************************
26872>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
26872>>>>>>>>>>>
26872>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
26874>>>>>>>>>>>        If (ghoConnection > 0) Begin
26876>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
26877>>>>>>>>>>>            Send AppendTextLn ""
26878>>>>>>>>>>>        End
26878>>>>>>>>>>>>
26878>>>>>>>>>>>    End_Procedure
26879>>>>>>>>>>>
26879>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
26881>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
26882>>>>>>>>>>>    End_Function
26883>>>>>>>>>>>
26883>>>>>>>>>>>    Procedure Show_Versions
26885>>>>>>>>>>>        Integer iVersion iRevision iBuild
26885>>>>>>>>>>>
26885>>>>>>>>>>>        Version_information iVersion iRevision iBuild
26887>>>>>>>>>>>
26887>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
26888>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
26889>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
26890>>>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
26891>>>>>>>>>>>    End_Procedure
26892>>>>>>>>>>>
26892>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
26894>>>>>>>>>>>        Boolean bOK
26894>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
26895>>>>>>>>>>>        Function_Return bOK
26896>>>>>>>>>>>    End_Function
26897>>>>>>>>>>>
26897>>>>>>>>>>>    //***
26897>>>>>>>>>>>    //*** BW
26897>>>>>>>>>>>    //*** Procedure: Show_Drivers
26897>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
26897>>>>>>>>>>>    //***
26897>>>>>>>>>>>
26897>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
26897>>>>>>>>>>>//    #Warning -3
26897>>>>>>>>>>>//#ENDIF
26897>>>>>>>>>>>    Procedure Show_Drivers
26899>>>>>>>>>>>        String sDriverID sVersion sClient sValue
26899>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
26899>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
26899>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
26899>>>>>>>>>>>
26899>>>>>>>>>>>        Move False to bStudioLicense
26900>>>>>>>>>>>
26900>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
26901>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
26902>>>>>>>>>>>
26902>>>>>>>>>>>        // For testing purposes:
26902>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
26902>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
26902>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
26902>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
26902>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
26902>>>>>>>>>>>//
26902>>>>>>>>>>>        Move False to Err
26903>>>>>>>>>>>
26903>>>>>>>>>>>        // Loop through all loaded drivers.
26903>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
26906>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
26908>>>>>>>>>>>            Send AppendTextLn ""
26909>>>>>>>>>>>        End
26909>>>>>>>>>>>>
26909>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
26915>>>>>>>>>>>>
26915>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
26916>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
26919>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
26920>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
26921>>>>>>>>>>>
26921>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
26923>>>>>>>>>>>
26923>>>>>>>>>>>                // Pervasive/Btrieve database
26923>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
26925>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
26926>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
26927>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
26929>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
26930>>>>>>>>>>>                    End
26930>>>>>>>>>>>>
26930>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
26931>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
26933>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
26934>>>>>>>>>>>                    End
26934>>>>>>>>>>>>
26934>>>>>>>>>>>                End
26934>>>>>>>>>>>>
26934>>>>>>>>>>>
26934>>>>>>>>>>>                Else Begin
26935>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
26936>>>>>>>>>>>                    Move 0 to iNumServers
26937>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
26939>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
26942>>>>>>>>>>>                    End
26942>>>>>>>>>>>>
26942>>>>>>>>>>>
26942>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
26944>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
26946>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
26947>>>>>>>>>>>                        End
26947>>>>>>>>>>>>
26947>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
26948>>>>>>>>>>>                    End
26948>>>>>>>>>>>>
26948>>>>>>>>>>>
26948>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
26948>>>>>>>>>>>                    // Studio licens is in use and there is no
26948>>>>>>>>>>>                    // number of max users defined because the driver is
26948>>>>>>>>>>>                    // relying on the info from the VDF license.
26948>>>>>>>>>>>                    If (bStudioLicense = False) Begin
26950>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
26951>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
26952>>>>>>>>>>>                    End
26952>>>>>>>>>>>>
26952>>>>>>>>>>>                End
26952>>>>>>>>>>>>
26952>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
26953>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
26955>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
26956>>>>>>>>>>>                End
26956>>>>>>>>>>>>
26956>>>>>>>>>>>                If (iNumServers <> 0) Begin
26958>>>>>>>>>>>                    For iCount from 1 to iNumServers
26964>>>>>>>>>>>>
26964>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
26967>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
26969>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
26970>>>>>>>>>>>                        End
26970>>>>>>>>>>>>
26970>>>>>>>>>>>                    Loop
26971>>>>>>>>>>>>
26971>>>>>>>>>>>                End
26971>>>>>>>>>>>>
26971>>>>>>>>>>>            End
26971>>>>>>>>>>>>
26971>>>>>>>>>>>        Loop
26972>>>>>>>>>>>>
26972>>>>>>>>>>>
26972>>>>>>>>>>>        Send AppendTextLn ""
26973>>>>>>>>>>>        If (bStudioLicense = False) Begin
26975>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
26976>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
26977>>>>>>>>>>>        End
26977>>>>>>>>>>>>
26977>>>>>>>>>>>        Else Begin
26978>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
26979>>>>>>>>>>>        End
26979>>>>>>>>>>>>
26979>>>>>>>>>>>        Send Destroy of hoCLIHandler
26980>>>>>>>>>>>        Send Destroy of hoBtrvHandler
26981>>>>>>>>>>>    End_Procedure
26982>>>>>>>>>>>
26982>>>>>>>>>>>    Procedure Show_HelpFile
26984>>>>>>>>>>>        String sHelpFile
26984>>>>>>>>>>>        Integer eHelpType
26984>>>>>>>>>>>
26984>>>>>>>>>>>        If (ghoApplication <> 0) Begin
26986>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
26987>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
26989>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
26990>>>>>>>>>>>            End
26990>>>>>>>>>>>>
26990>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
26993>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
26994>>>>>>>>>>>            End
26994>>>>>>>>>>>>
26994>>>>>>>>>>>            Else Begin
26995>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
26996>>>>>>>>>>>            End
26996>>>>>>>>>>>>
26996>>>>>>>>>>>
26996>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
26997>>>>>>>>>>>        End
26997>>>>>>>>>>>>
26997>>>>>>>>>>>    End_Procedure
26998>>>>>>>>>>>
26998>>>>>>>>>>>    Procedure Show_EnterAsTab
27000>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
27000>>>>>>>>>>>        String sText
27000>>>>>>>>>>>
27000>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27002>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
27003>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
27005>>>>>>>>>>>                Move "True" To sText
27006>>>>>>>>>>>            End
27006>>>>>>>>>>>>
27006>>>>>>>>>>>            Else Begin
27007>>>>>>>>>>>                Move "False" To sText
27008>>>>>>>>>>>            End
27008>>>>>>>>>>>>
27008>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
27009>>>>>>>>>>>        End
27009>>>>>>>>>>>>
27009>>>>>>>>>>>    End_Procedure
27010>>>>>>>>>>>
27010>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
27010>>>>>>>>>>>    //    found systeminformation
27010>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
27012>>>>>>>>>>>        Forward Send Add_Focus hoRoot
27014>>>>>>>>>>>
27014>>>>>>>>>>>        Send Delete_Data
27015>>>>>>>>>>>
27015>>>>>>>>>>>        Set Changed_State To False
27016>>>>>>>>>>>        Set Read_Only_State To True
27017>>>>>>>>>>>
27017>>>>>>>>>>>        Send Show_Registration
27018>>>>>>>>>>>        Send Show_Drivers
27019>>>>>>>>>>>        Send Show_ServicePack
27020>>>>>>>>>>>        Send Show_Versions
27021>>>>>>>>>>>        Send AppendTextLn ""
27022>>>>>>>>>>>
27022>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27024>>>>>>>>>>>            Send Show_WorkSpaceInformation
27025>>>>>>>>>>>            Send Show_HelpFile
27026>>>>>>>>>>>            Send AppendTextLn ""
27027>>>>>>>>>>>        End
27027>>>>>>>>>>>>
27027>>>>>>>>>>>        Else Begin
27028>>>>>>>>>>>            Send AppendTextLn ""
27029>>>>>>>>>>>        End
27029>>>>>>>>>>>>
27029>>>>>>>>>>>
27029>>>>>>>>>>>        If (ghoConnection <> 0) Begin
27031>>>>>>>>>>>            Send Show_ConnectionIdInformation
27032>>>>>>>>>>>        End
27032>>>>>>>>>>>>
27032>>>>>>>>>>>
27032>>>>>>>>>>>        Send Show_Current_User
27033>>>>>>>>>>>        Send Show_Windows_Directory
27034>>>>>>>>>>>        Send Show_Current_Directory
27035>>>>>>>>>>>
27035>>>>>>>>>>>        // This is already shown in the workspace details,
27035>>>>>>>>>>>        // unless no workspace object is present:
27035>>>>>>>>>>>        If (ghoApplication = 0) Begin
27037>>>>>>>>>>>            Send Show_Filelist_Name
27038>>>>>>>>>>>        End
27038>>>>>>>>>>>>
27038>>>>>>>>>>>
27038>>>>>>>>>>>        If (ghoApplication <> 0) Begin
27040>>>>>>>>>>>            Send AppendTextLn ""
27041>>>>>>>>>>>            Send Show_EnterAsTab
27042>>>>>>>>>>>        End
27042>>>>>>>>>>>>
27042>>>>>>>>>>>
27042>>>>>>>>>>>        Send Show_Screen_Size
27043>>>>>>>>>>>        Send Show_Page_Size
27044>>>>>>>>>>>        Send Show_Number_Format
27045>>>>>>>>>>>        Send Show_Date_Format
27046>>>>>>>>>>>        Send Show_Lock_Delay
27047>>>>>>>>>>>        Send Show_Lock_Timeout
27048>>>>>>>>>>>        Send Show_Date
27049>>>>>>>>>>>        Send Show_Systemresources
27050>>>>>>>>>>>        Send Beginning_of_Data
27051>>>>>>>>>>>
27051>>>>>>>>>>>        Set Icon to 'default.ico'
27052>>>>>>>>>>>    End_Procedure
27053>>>>>>>>>>>End_Class
27054>>>>>>>>>>>
27054>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
27055>>>>>>>>>>>    Procedure Construct_Object
27057>>>>>>>>>>>        Forward Send Construct_Object
27059>>>>>>>>>>>
27059>>>>>>>>>>>        Set Label to C_$SystemInformation
27060>>>>>>>>>>>        Set Size to 140 267
27061>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
27062>>>>>>>>>>>        Set Border_Style to Border_Thick
27063>>>>>>>>>>>        Set Sysmenu_Icon to False
27064>>>>>>>>>>>
27064>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
27064>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
27065>>>>>>>>>>>
27065>>>>>>>>>>>        // 2014-09-14 NGS
27065>>>>>>>>>>>        // Added a container object around the cTexteditor
27065>>>>>>>>>>>        // object to get a border around the text.
27065>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
27067>>>>>>>>>>>            Set Location to 2 4
27068>>>>>>>>>>>            Set Size to 110 255
27069>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
27070>>>>>>>>>>>            Set Color to clWhite
27071>>>>>>>>>>>            Set peAnchors to anAll
27072>>>>>>>>>>>
27072>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
27074>>>>>>>>>>>            End_Object
27075>>>>>>>>>>>
27075>>>>>>>>>>>        End_Object
27076>>>>>>>>>>>
27076>>>>>>>>>>>        Object oCloseButton is a Button
27078>>>>>>>>>>>            Set Label to C_$Close
27079>>>>>>>>>>>            Set Location to 120 210
27080>>>>>>>>>>>            CompilerWarnings Off
27080>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
27081>>>>>>>>>>>            CompilerWarnings On
27081>>>>>>>>>>>            Set Default_State To True
27082>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
27082>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
27082>>>>>>>>>>>            // for that situation.
27082>>>>>>>>>>>            Set peAnchors to anBottomRight
27083>>>>>>>>>>>        End_Object
27084>>>>>>>>>>>
27084>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
27086>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
27087>>>>>>>>>>>            Set Size to 14 50
27088>>>>>>>>>>>            Set Location to 120 158
27089>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27089>>>>>>>>>>>            // we might as well prepare the object for it.
27089>>>>>>>>>>>            Set peAnchors to anBottomRight
27090>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
27091>>>>>>>>>>>        End_Object
27092>>>>>>>>>>>
27092>>>>>>>>>>>        On_Key kCancel Send Close_Panel
27093>>>>>>>>>>>    End_Procedure
27094>>>>>>>>>>>
27094>>>>>>>>>>>    Procedure Page Integer iPageObject
27096>>>>>>>>>>>        Handle hMenu
27096>>>>>>>>>>>        Integer iPrevState
27096>>>>>>>>>>>
27096>>>>>>>>>>>        Forward Send Page iPageObject
27098>>>>>>>>>>>
27098>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
27098>>>>>>>>>>>        //
27098>>>>>>>>>>>    End_Procedure
27099>>>>>>>>>>>
27099>>>>>>>>>>>End_Class
27100>>>>>>>>>>>
27100>>>>>>>>>>>Class cAboutEdit is an cRichEdit
27101>>>>>>>>>>>    Procedure Construct_Object
27103>>>>>>>>>>>        Forward Send Construct_Object
27105>>>>>>>>>>>
27105>>>>>>>>>>>        Property String psContentText
27106>>>>>>>>>>>
27106>>>>>>>>>>>        Set Size to 77 153
27107>>>>>>>>>>>        Set Location to 8 60
27108>>>>>>>>>>>        Set Read_Only_State to True
27109>>>>>>>>>>>        Set Skip_State to True
27110>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
27110>>>>>>>>>>>        // or 1/20 of a printer's point.
27110>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
27111>>>>>>>>>>>        Set Border_Style  to Border_None
27112>>>>>>>>>>>    End_Procedure
27113>>>>>>>>>>>
27113>>>>>>>>>>>    // Adds a line of text to the edit object
27113>>>>>>>>>>>    Procedure Add_Line String sText
27115>>>>>>>>>>>        String sContentText
27115>>>>>>>>>>>        Get psContentText to sContentText
27116>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
27117>>>>>>>>>>>        Set psContentText to sContentText
27118>>>>>>>>>>>    End_Procedure
27119>>>>>>>>>>>
27119>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
27119>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
27119>>>>>>>>>>>    // because the object isn't paged yet when we add these
27119>>>>>>>>>>>    // values and the COM edit object needs to be paged
27119>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
27119>>>>>>>>>>>    Procedure Add_LineLn String sText
27121>>>>>>>>>>>        String sContentText sCR
27121>>>>>>>>>>>
27121>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
27122>>>>>>>>>>>        Get psContentText to sContentText
27123>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
27124>>>>>>>>>>>        Set psContentText to sContentText
27125>>>>>>>>>>>    End_Procedure
27126>>>>>>>>>>>
27126>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
27128>>>>>>>>>>>        String sLinkText
27128>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
27129>>>>>>>>>>>        Send Show_HomePage sLinkText
27130>>>>>>>>>>>    End_Procedure
27131>>>>>>>>>>>
27131>>>>>>>>>>>    Procedure Page Integer iPageObject
27133>>>>>>>>>>>        String sContentText
27133>>>>>>>>>>>
27133>>>>>>>>>>>        Forward Send Page iPageObject
27135>>>>>>>>>>>        Get psContentText to sContentText
27136>>>>>>>>>>>        Send AppendText sContentText
27137>>>>>>>>>>>        send Beginning_of_Data
27138>>>>>>>>>>>    End_Procedure
27139>>>>>>>>>>>
27139>>>>>>>>>>>End_Class
27140>>>>>>>>>>>
27140>>>>>>>>>>>Class AboutDialog is a ModalPanel
27141>>>>>>>>>>>    Procedure Construct_Object
27143>>>>>>>>>>>
27143>>>>>>>>>>>        Forward Send Construct_Object
27145>>>>>>>>>>>
27145>>>>>>>>>>>        Set Label to C_$About
27146>>>>>>>>>>>        Set Size to 118 230
27147>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
27148>>>>>>>>>>>        Set Border_Style to Border_Thick
27149>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
27150>>>>>>>>>>>
27150>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
27152>>>>>>>>>>>        End_Object
27153>>>>>>>>>>>
27153>>>>>>>>>>>        Object oBox is a Container3d
27155>>>>>>>>>>>            Set Border_Style to Border_Normal
27156>>>>>>>>>>>            Set Size to 90 220
27157>>>>>>>>>>>            Set Location to 4 5
27158>>>>>>>>>>>            Set Color to clWhite
27159>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27159>>>>>>>>>>>            // we might as well prepare the object for it.
27159>>>>>>>>>>>            Set peAnchors to anAll
27160>>>>>>>>>>>
27160>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
27162>>>>>>>>>>>                Set Border_Style To Border_None
27163>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
27164>>>>>>>>>>>                Set Color to clWhite
27165>>>>>>>>>>>                Set Size to 45 50
27166>>>>>>>>>>>                Set Location to 0 3
27167>>>>>>>>>>>            End_Object
27168>>>>>>>>>>>
27168>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
27170>>>>>>>>>>>                Set Border_Style to Border_None
27171>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
27172>>>>>>>>>>>                Set Color to clWhite
27173>>>>>>>>>>>                Set Size to 30 55
27174>>>>>>>>>>>                Set Location to 50 3
27175>>>>>>>>>>>            End_Object
27176>>>>>>>>>>>
27176>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
27178>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
27178>>>>>>>>>>>                // we might as well prepare the object for it.
27178>>>>>>>>>>>                Set peAnchors to anAll
27179>>>>>>>>>>>            End_Object
27180>>>>>>>>>>>
27180>>>>>>>>>>>            // These objects are here for backwards compatability only.
27180>>>>>>>>>>>            // They are not used.
27180>>>>>>>>>>>            Object oProductName is a TextBox
27182>>>>>>>>>>>                Set Label To C_$ProductName
27183>>>>>>>>>>>                Set Size To 10 45
27184>>>>>>>>>>>                Set Location To 8 53
27185>>>>>>>>>>>                Set Visible_State to False
27186>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27187>>>>>>>>>>>            End_Object
27188>>>>>>>>>>>
27188>>>>>>>>>>>            Object oVersion is a TextBox
27190>>>>>>>>>>>                Set Label To C_$Version
27191>>>>>>>>>>>                Set Size To 10 25
27192>>>>>>>>>>>                Set Location To 21 53
27193>>>>>>>>>>>                Set Visible_State to False
27194>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27195>>>>>>>>>>>            End_Object
27196>>>>>>>>>>>
27196>>>>>>>>>>>            Object oCopyright is a TextBox
27198>>>>>>>>>>>                Set Label To C_$Copyright
27199>>>>>>>>>>>                Set Size To 10 31
27200>>>>>>>>>>>                Set Location To 34 53
27201>>>>>>>>>>>                Set Visible_State to False
27202>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27203>>>>>>>>>>>            End_Object
27204>>>>>>>>>>>
27204>>>>>>>>>>>            Object oAuthor is a TextBox
27206>>>>>>>>>>>                Set Label To C_$Author
27207>>>>>>>>>>>                Set Size To 10 22
27208>>>>>>>>>>>                Set Location To 46 53
27209>>>>>>>>>>>                Set Visible_State to False
27210>>>>>>>>>>>                Set Focus_Mode to NonFocusable
27211>>>>>>>>>>>            End_Object
27212>>>>>>>>>>>
27212>>>>>>>>>>>        End_Object
27213>>>>>>>>>>>
27213>>>>>>>>>>>        Object oOKButton is a Button
27215>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
27216>>>>>>>>>>>            Set Location to 98 176
27217>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27217>>>>>>>>>>>            // we might as well prepare the object for it.
27217>>>>>>>>>>>            Set peAnchors to anBottomRight
27218>>>>>>>>>>>        End_Object
27219>>>>>>>>>>>
27219>>>>>>>>>>>        Object oSysInfoButton is a Button
27221>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
27222>>>>>>>>>>>            Set Location to 98 123
27223>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27223>>>>>>>>>>>            // we might as well prepare the object for it.
27223>>>>>>>>>>>            Set peAnchors to anBottomRight
27224>>>>>>>>>>>        End_Object
27225>>>>>>>>>>>
27225>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
27227>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
27228>>>>>>>>>>>            Set Size to 14 50
27229>>>>>>>>>>>            Set Location to 98 70
27230>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
27230>>>>>>>>>>>            // we might as well prepare the object for it.
27230>>>>>>>>>>>            Set peAnchors to anBottomRight
27231>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
27232>>>>>>>>>>>        End_Object
27233>>>>>>>>>>>
27233>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
27234>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
27235>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
27236>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
27236>>>>>>>>>>>    End_Procedure
27237>>>>>>>>>>>
27237>>>>>>>>>>>    Procedure Page Integer iPageObject
27239>>>>>>>>>>>        Handle hMenu
27239>>>>>>>>>>>        Integer iPrevState
27239>>>>>>>>>>>
27239>>>>>>>>>>>        Forward Send Page iPageObject
27241>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
27241>>>>>>>>>>>        Set Icon to "Default.ico"
27242>>>>>>>>>>>
27242>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
27242>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
27243>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27244>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
27244>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27244>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27245>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27246>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27247>>>>>>>>>>>        // The "Close" menu command may be good to have.
27247>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
27247>>>>>>>>>>>    End_Procedure
27248>>>>>>>>>>>
27248>>>>>>>>>>>    Procedure Set ProductName String sText
27250>>>>>>>>>>>        Set Value of oProductName to sText
27251>>>>>>>>>>>    End_Procedure
27252>>>>>>>>>>>
27252>>>>>>>>>>>    Procedure Set Copyright String sText
27254>>>>>>>>>>>        Set Value of oCopyright to sText
27255>>>>>>>>>>>    End_Procedure
27256>>>>>>>>>>>
27256>>>>>>>>>>>    Procedure Set Author String sText
27258>>>>>>>>>>>        Set Value of oAuthor to sText
27259>>>>>>>>>>>    End_Procedure
27260>>>>>>>>>>>
27260>>>>>>>>>>>    Procedure Set Version String sVersion
27262>>>>>>>>>>>        Handle hoVersionInfo
27262>>>>>>>>>>>        Boolean bIncluded
27262>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
27262>>>>>>>>>>>//        Date dCompileDate
27262>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
27262>>>>>>>>>>>
27262>>>>>>>>>>>        If (sVersion = "") Begin
27264>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
27264>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
27264>>>>>>>>>>>            If (ghoApplication <> 0) Begin
27266>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
27267>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
27269>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
27270>>>>>>>>>>>                    If (bIncluded) Begin
27272>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
27273>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
27274>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
27275>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
27276>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
27277>>>>>>>>>>>                    End
27277>>>>>>>>>>>>
27277>>>>>>>>>>>                End
27277>>>>>>>>>>>>
27277>>>>>>>>>>>            End
27277>>>>>>>>>>>>
27277>>>>>>>>>>>        End
27277>>>>>>>>>>>>
27277>>>>>>>>>>>
27277>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
27277>>>>>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
27278>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
27280>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
27281>>>>>>>>>>>        End
27281>>>>>>>>>>>>
27281>>>>>>>>>>>//        Get GetCompileDate to dCompileDate
27281>>>>>>>>>>>//        If (sVersion <> "") Begin
27281>>>>>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
27281>>>>>>>>>>>//        End
27281>>>>>>>>>>>
27281>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
27282>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
27284>>>>>>>>>>>            If (sCertInfo <> "") Begin
27286>>>>>>>>>>>                Send Add_LineLn sCertInfo
27287>>>>>>>>>>>            End
27287>>>>>>>>>>>>
27287>>>>>>>>>>>            Else Begin
27288>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
27289>>>>>>>>>>>            End
27289>>>>>>>>>>>>
27289>>>>>>>>>>>        End
27289>>>>>>>>>>>>
27289>>>>>>>>>>>    End_Procedure
27290>>>>>>>>>>>
27290>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
27292>>>>>>>>>>>        Boolean bIsDate
27292>>>>>>>>>>>        String sGoodCharacters sChar
27292>>>>>>>>>>>        Integer iCount iLength
27292>>>>>>>>>>>
27292>>>>>>>>>>>        Move True to bIsDate
27293>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
27294>>>>>>>>>>>        Move (Length(sDate)) to iLength
27295>>>>>>>>>>>        For iCount from 1 to iLength
27301>>>>>>>>>>>>
27301>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
27302>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
27303>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
27304>>>>>>>>>>>            If (bIsDate = False) Begin
27306>>>>>>>>>>>                Move iLength to iCount
27307>>>>>>>>>>>            End
27307>>>>>>>>>>>>
27307>>>>>>>>>>>        Loop
27308>>>>>>>>>>>>
27308>>>>>>>>>>>        Function_Return bIsDate
27309>>>>>>>>>>>    End_Function
27310>>>>>>>>>>>
27310>>>>>>>>>>>    Function GetCompileDate Returns Date
27312>>>>>>>>>>>        Date dCompileDate
27312>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
27312>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
27312>>>>>>>>>>>        Boolean bIsValid   
27312>>>>>>>>>>>        
27312>>>>>>>>>>>        Move 0 to dCompileDate
27313>>>>>>>>>>>        // Get full path to the current running executable
27313>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
27314>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
27315>>>>>>>>>>>
27315>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
27315>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
27316>>>>>>>>>>>
27316>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
27318>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
27319>>>>>>>>>>>        If (iPos > 0) Begin
27321>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
27321>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
27322>>>>>>>>>>>
27322>>>>>>>>>>>            // If the current date format is non US, we need to temporary
27322>>>>>>>>>>>            // change the format and then move the string to the date variable.
27322>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
27325>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
27328>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
27329>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
27331>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
27332>>>>>>>>>>>            End
27332>>>>>>>>>>>>
27332>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
27333>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
27334>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
27337>>>>>>>>>>>        End
27337>>>>>>>>>>>>
27337>>>>>>>>>>>        Else Begin
27338>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
27339>>>>>>>>>>>>
27339>>>>>>>>>>>        End
27339>>>>>>>>>>>>
27339>>>>>>>>>>>
27339>>>>>>>>>>>        Send Seq_Close_Channel iChannel
27340>>>>>>>>>>>
27340>>>>>>>>>>>        Function_Return dCompileDate
27341>>>>>>>>>>>    End_Function
27342>>>>>>>>>>>
27342>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
27342>>>>>>>>>>>    // (the passed program), has been finished
27342>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
27342>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
27344>>>>>>>>>>>        Handle hProcess
27344>>>>>>>>>>>        Integer iVoid
27344>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
27344>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
27344>>>>>>>>>>>
27344>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
27345>>>>>>>>>>>
27345>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
27346>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
27347>>>>>>>>>>>
27347>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
27348>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
27349>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
27349>>>>>>>>>>>        Move 0                       to sInfo.nShow
27350>>>>>>>>>>>
27350>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
27351>>>>>>>>>>>        Move sInfo.hProcess to hProcess
27352>>>>>>>>>>>        If (hProcess) Begin
27354>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
27355>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
27356>>>>>>>>>>>        End
27356>>>>>>>>>>>>
27356>>>>>>>>>>>    End_Procedure
27357>>>>>>>>>>>
27357>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
27359>>>>>>>>>>>        String sDirSep
27359>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
27360>>>>>>>>>>>        Move (Trim(sPath)) to sPath
27361>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
27363>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
27364>>>>>>>>>>>        End
27364>>>>>>>>>>>>
27364>>>>>>>>>>>        Function_Return sPath
27365>>>>>>>>>>>    End_Function
27366>>>>>>>>>>>
27366>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
27366>>>>>>>>>>>    // or there is a problem with the certificate.
27366>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
27366>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
27366>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
27368>>>>>>>>>>>        Boolean bExists
27368>>>>>>>>>>>        String sPath sProgram sParams sRetval
27368>>>>>>>>>>>        Integer iCh
27368>>>>>>>>>>>
27368>>>>>>>>>>>        Move "" to sRetval
27369>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
27370>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
27371>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
27372>>>>>>>>>>>        If (bExists = False) Begin
27374>>>>>>>>>>>            Function_Return "-1"
27375>>>>>>>>>>>        End
27375>>>>>>>>>>>>
27375>>>>>>>>>>>
27375>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
27376>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
27377>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
27378>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
27379>>>>>>>>>>>        Get Seq_New_Channel to iCh
27380>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
27382>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
27385>>>>>>>>>>>        Close_Output channel iCh
27387>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
27387>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
27388>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
27390>>>>>>>>>>>            Readln channel iCh sRetval
27392>>>>>>>>>>>            Readln channel iCh sRetval
27394>>>>>>>>>>>            Readln channel iCh sRetval
27396>>>>>>>>>>>            Readln channel iCh sRetval
27398>>>>>>>>>>>        Close_Input channel iCh
27400>>>>>>>>>>>        Send Seq_Release_Channel iCh
27401>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
27403>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
27404>>>>>>>>>>>        End
27404>>>>>>>>>>>>
27404>>>>>>>>>>>        Else Begin
27405>>>>>>>>>>>            Move "" to sRetval
27406>>>>>>>>>>>        End
27406>>>>>>>>>>>>
27406>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
27406>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
27407>>>>>>>>>>>>
27407>>>>>>>>>>>        Function_Return sRetval
27408>>>>>>>>>>>    End_Function
27409>>>>>>>>>>>
27409>>>>>>>>>>>    Procedure Add_LineLn String sValue
27411>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
27412>>>>>>>>>>>    End_Procedure
27413>>>>>>>>>>>
27413>>>>>>>>>>>    Procedure Add_Line String sValue
27415>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
27416>>>>>>>>>>>    End_Procedure
27417>>>>>>>>>>>
27417>>>>>>>>>>>    Procedure Set Logo string sLogo
27419>>>>>>>>>>>        // Square bitmaps of 80x80 work best
27419>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
27420>>>>>>>>>>>    End_Procedure
27421>>>>>>>>>>>
27421>>>>>>>>>>>    Procedure Set LogoDF String sLogo
27423>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
27424>>>>>>>>>>>    End_Procedure
27425>>>>>>>>>>>
27425>>>>>>>>>>>    Procedure Show_Sysinfo
27427>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
27428>>>>>>>>>>>    End_Procedure
27429>>>>>>>>>>>
27429>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
27431>>>>>>>>>>>        Handle hWnd
27431>>>>>>>>>>>        Get Window_Handle to hWnd
27432>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
27433>>>>>>>>>>>    End_Procedure
27434>>>>>>>>>>>
27434>>>>>>>>>>>End_Class
27435>>>>>>>>>
27435>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
27437>>>>>>>>>    End_Function
27438>>>>>>>>>
27438>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
27439>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
27440>>>>>>>>>>
27440>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
27442>>>>>>>>>>    Integer iStart iEnd
27442>>>>>>>>>>    String sRetval
27442>>>>>>>>>>
27442>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
27443>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
27444>>>>>>>>>>    If (iStart = 0) Begin
27446>>>>>>>>>>        Function_Return ""
27447>>>>>>>>>>    End
27447>>>>>>>>>>>
27447>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
27448>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
27449>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
27451>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
27452>>>>>>>>>>    End
27452>>>>>>>>>>>
27452>>>>>>>>>>    Else Begin
27453>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
27454>>>>>>>>>>    End
27454>>>>>>>>>>>
27454>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
27456>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
27457>>>>>>>>>>        Decrement iEnd
27458>>>>>>>>>>    End
27458>>>>>>>>>>>
27458>>>>>>>>>>    If (iEnd <> 0) Begin
27460>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
27461>>>>>>>>>>    End
27461>>>>>>>>>>>
27461>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
27462>>>>>>>>>>
27462>>>>>>>>>>    Function_Return (Trim(sRetval))
27463>>>>>>>>>>End_Function
27464>>>>>>>>>>
27464>>>>>>>>>>
27464>>>>>>>>>    
27464>>>>>>>>>    Procedure Construct_Object
27466>>>>>>>>>        Handle ho
27466>>>>>>>>>        Forward Send Construct_Object
27468>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
27469>>>>>>>>>        
27469>>>>>>>>>        Send CreateDbUpdateLibraryProperties
27470>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
27471>>>>>>>>>
27471>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
27471>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
27471>>>>>>>>>        // etc settings.
27471>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27473>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
27474>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
27475>>>>>>>>>            Set phoSQLConnectionHandler to ho
27476>>>>>>>>>        End
27476>>>>>>>>>>
27476>>>>>>>>>
27476>>>>>>>>>    End_Procedure
27477>>>>>>>>>
27477>>>>>>>>>    Procedure End_Construct_Object
27479>>>>>>>>>        Forward Send End_Construct_Object
27481>>>>>>>>>
27481>>>>>>>>>    End_Procedure
27482>>>>>>>>>
27482>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
27482>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
27482>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
27482>>>>>>>>>    // Good read about which collation to select:
27482>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
27482>>>>>>>>>    Procedure Set psCollation String sCollation
27484>>>>>>>>>        Set private.psCollation to sCollation
27485>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
27487>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
27488>>>>>>>>>        End
27488>>>>>>>>>>
27488>>>>>>>>>    End_Procedure
27489>>>>>>>>>
27489>>>>>>>>>    Function psCollation Returns String
27491>>>>>>>>>        String sCollation
27491>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
27493>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
27494>>>>>>>>>        End   
27494>>>>>>>>>>
27494>>>>>>>>>        Else Begin
27495>>>>>>>>>            Get private.psCollation to sCollation
27496>>>>>>>>>        End
27496>>>>>>>>>>
27496>>>>>>>>>        Function_Return sCollation
27497>>>>>>>>>    End_Function
27498>>>>>>>>>
27498>>>>>>>>>    // Array sorting helper functions:
27498>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
27500>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
27502>>>>>>>>>            Function_Return (EQ)
27503>>>>>>>>>        End
27503>>>>>>>>>>
27503>>>>>>>>>
27503>>>>>>>>>        Function_Return (GT)
27504>>>>>>>>>    End_Function
27505>>>>>>>>>
27505>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
27507>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
27510>>>>>>>>>
27510>>>>>>>>>        Function_Return (GT)
27511>>>>>>>>>    End_Function
27512>>>>>>>>>
27512>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
27512>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
27512>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
27514>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
27514>>>>>>>>>        Handle hTable
27514>>>>>>>>>        Boolean bIsSame
27514>>>>>>>>>
27514>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
27515>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
27516>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
27519>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
27520>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
27523>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
27526>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
27527>>>>>>>>>
27527>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
27529>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
27530>>>>>>>>>        End
27530>>>>>>>>>>
27530>>>>>>>>>        Else Begin
27531>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
27532>>>>>>>>>        End
27532>>>>>>>>>>
27532>>>>>>>>>
27532>>>>>>>>>        Function_Return bIsSame
27533>>>>>>>>>    End_Function
27534>>>>>>>>>
27534>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
27536>>>>>>>>>        Integer iRetval
27536>>>>>>>>>        Move 1 to iRetval
27537>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
27539>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
27540>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
27541>>>>>>>>>        End
27541>>>>>>>>>>
27541>>>>>>>>>        Function_Return (iRetval = 0)
27542>>>>>>>>>    End_Function
27543>>>>>>>>>
27543>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
27545>>>>>>>>>        String sDirSep
27545>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
27546>>>>>>>>>        Move (Trim(sPath)) to sPath
27547>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
27549>>>>>>>>>            Move (sPath + sDirSep) to sPath
27550>>>>>>>>>        End
27550>>>>>>>>>>
27550>>>>>>>>>        Function_Return sPath
27551>>>>>>>>>    End_Function
27552>>>>>>>>>
27552>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
27554>>>>>>>>>        Integer i iCols iItem
27554>>>>>>>>>        tSqlColumnNew[] aQueryColumns
27554>>>>>>>>>        tSqlColumnNew[] aQueryColumns
27555>>>>>>>>>
27555>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
27556>>>>>>>>>        For i from 1 to iCols
27562>>>>>>>>>>
27562>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
27563>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
27564>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
27565>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
27566>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
27567>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
27568>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
27569>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
27570>>>>>>>>>        Loop
27571>>>>>>>>>>
27571>>>>>>>>>        Set piColumns to iCols
27572>>>>>>>>>        Set paQueryColumns to aQueryColumns
27573>>>>>>>>>    End_Procedure
27574>>>>>>>>>
27574>>>>>>>>>    // *** Property Messages ***
27574>>>>>>>>>    //
27574>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
27574>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
27574>>>>>>>>>    //
27574>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
27576>>>>>>>>>        tSQLConnection SQLConnection
27576>>>>>>>>>        tSQLConnection SQLConnection
27576>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27578>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
27578>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27579>>>>>>>>>>
27579>>>>>>>>>            Function_Return
27580>>>>>>>>>        End
27580>>>>>>>>>>
27580>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
27581>>>>>>>>>        Function_Return SQLConnection
27582>>>>>>>>>    End_Function
27583>>>>>>>>>
27583>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27583>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
27585>>>>>>>>>        Function_Return False
27586>>>>>>>>>    End_Function
27587>>>>>>>>>
27587>>>>>>>>>    Procedure Set psServer String sValue
27589>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27591>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
27591>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27592>>>>>>>>>>
27592>>>>>>>>>            Procedure_Return
27593>>>>>>>>>        End
27593>>>>>>>>>>
27593>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
27594>>>>>>>>>    End_Procedure
27595>>>>>>>>>
27595>>>>>>>>>    Function psServer Returns String
27597>>>>>>>>>        String sValue
27597>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27599>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27600>>>>>>>>>>
27600>>>>>>>>>            Function_Return
27601>>>>>>>>>        End
27601>>>>>>>>>>
27601>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
27602>>>>>>>>>        Function_Return sValue
27603>>>>>>>>>    End_Function
27604>>>>>>>>>
27604>>>>>>>>>    Procedure Set psDatabase String sValue
27606>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27608>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27609>>>>>>>>>>
27609>>>>>>>>>            Procedure_Return
27610>>>>>>>>>        End
27610>>>>>>>>>>
27610>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
27611>>>>>>>>>    End_Procedure
27612>>>>>>>>>
27612>>>>>>>>>    Function psDatabase Returns String
27614>>>>>>>>>        String sValue
27614>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27616>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27617>>>>>>>>>>
27617>>>>>>>>>            Function_Return
27618>>>>>>>>>        End
27618>>>>>>>>>>
27618>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
27619>>>>>>>>>        Function_Return sValue
27620>>>>>>>>>    End_Function
27621>>>>>>>>>
27621>>>>>>>>>    Procedure Set psUserID String sValue
27623>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27625>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27626>>>>>>>>>>
27626>>>>>>>>>            Procedure_Return
27627>>>>>>>>>        End
27627>>>>>>>>>>
27627>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
27628>>>>>>>>>    End_Procedure
27629>>>>>>>>>
27629>>>>>>>>>    Function psUserID Returns String
27631>>>>>>>>>        String sValue
27631>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27633>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27634>>>>>>>>>>
27634>>>>>>>>>            Function_Return
27635>>>>>>>>>        End
27635>>>>>>>>>>
27635>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
27636>>>>>>>>>        Function_Return sValue
27637>>>>>>>>>    End_Function
27638>>>>>>>>>
27638>>>>>>>>>    Procedure Set psPassword String sValue
27640>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27642>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27643>>>>>>>>>>
27643>>>>>>>>>            Procedure_Return
27644>>>>>>>>>        End
27644>>>>>>>>>>
27644>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
27645>>>>>>>>>    End_Procedure
27646>>>>>>>>>
27646>>>>>>>>>    Function psPassword Returns String
27648>>>>>>>>>        String sValue
27648>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27650>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27651>>>>>>>>>>
27651>>>>>>>>>            Function_Return
27652>>>>>>>>>        End
27652>>>>>>>>>>
27652>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
27653>>>>>>>>>        Function_Return sValue
27654>>>>>>>>>    End_Function
27655>>>>>>>>>
27655>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
27657>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27659>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27660>>>>>>>>>>
27660>>>>>>>>>            Procedure_Return
27661>>>>>>>>>        End
27661>>>>>>>>>>
27661>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
27662>>>>>>>>>    End_Procedure
27663>>>>>>>>>
27663>>>>>>>>>    Function pbTrusted Returns Boolean
27665>>>>>>>>>        Boolean bValue
27665>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27667>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27668>>>>>>>>>>
27668>>>>>>>>>            Function_Return
27669>>>>>>>>>        End
27669>>>>>>>>>>
27669>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
27670>>>>>>>>>        Function_Return bValue
27671>>>>>>>>>    End_Function
27672>>>>>>>>>
27672>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
27674>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27676>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27677>>>>>>>>>>
27677>>>>>>>>>            Procedure_Return
27678>>>>>>>>>        End
27678>>>>>>>>>>
27678>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
27679>>>>>>>>>    End_Procedure
27680>>>>>>>>>
27680>>>>>>>>>    Function pbSilentLogin Returns Boolean
27682>>>>>>>>>        Boolean bValue
27682>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27684>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27685>>>>>>>>>>
27685>>>>>>>>>            Function_Return
27686>>>>>>>>>        End
27686>>>>>>>>>>
27686>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
27687>>>>>>>>>        Function_Return bValue
27688>>>>>>>>>    End_Function
27689>>>>>>>>>
27689>>>>>>>>>    Procedure Set psConnectionID String sValue
27691>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27693>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27694>>>>>>>>>>
27694>>>>>>>>>            Procedure_Return
27695>>>>>>>>>        End
27695>>>>>>>>>>
27695>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
27696>>>>>>>>>    End_Procedure
27697>>>>>>>>>
27697>>>>>>>>>    Function psConnectionID Returns String
27699>>>>>>>>>        String sValue
27699>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27701>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27702>>>>>>>>>>
27702>>>>>>>>>            Function_Return
27703>>>>>>>>>        End
27703>>>>>>>>>>
27703>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
27704>>>>>>>>>        Function_Return sValue
27705>>>>>>>>>    End_Function
27706>>>>>>>>>
27706>>>>>>>>>    Procedure Set psConnectionString String sValue
27708>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27710>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27711>>>>>>>>>>
27711>>>>>>>>>            Procedure_Return
27712>>>>>>>>>        End
27712>>>>>>>>>>
27712>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
27713>>>>>>>>>    End_Procedure
27714>>>>>>>>>
27714>>>>>>>>>    Function psConnectionString Returns String
27716>>>>>>>>>        String sValue
27716>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27718>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27719>>>>>>>>>>
27719>>>>>>>>>            Function_Return
27720>>>>>>>>>        End
27720>>>>>>>>>>
27720>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
27721>>>>>>>>>        Function_Return sValue
27722>>>>>>>>>    End_Function
27723>>>>>>>>>
27723>>>>>>>>>    // The normal connection string looks something like this;
27723>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
27723>>>>>>>>>    // ...and the full connection string looks like this;
27723>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
27723>>>>>>>>>    Function psFullConnectionString Returns String
27725>>>>>>>>>        String sConnectionID sConnectionString
27725>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27727>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27728>>>>>>>>>>
27728>>>>>>>>>            Function_Return
27729>>>>>>>>>        End
27729>>>>>>>>>>
27729>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
27730>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
27731>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
27732>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
27733>>>>>>>>>    End_Function
27734>>>>>>>>>
27734>>>>>>>>>    Function piConnectionOptions Returns Integer
27736>>>>>>>>>        Integer iValue
27736>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27738>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27739>>>>>>>>>>
27739>>>>>>>>>            Function_Return
27740>>>>>>>>>        End
27740>>>>>>>>>>
27740>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
27741>>>>>>>>>        Function_Return iValue
27742>>>>>>>>>    End_Function
27743>>>>>>>>>
27743>>>>>>>>>    Procedure Set psSchema String sValue
27745>>>>>>>>>        tSQLConnection SQLConnection
27745>>>>>>>>>        tSQLConnection SQLConnection
27745>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27747>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27748>>>>>>>>>>
27748>>>>>>>>>            Procedure_Return
27749>>>>>>>>>        End
27749>>>>>>>>>>
27749>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
27750>>>>>>>>>    End_Procedure
27751>>>>>>>>>
27751>>>>>>>>>    Function psSchema Returns String
27753>>>>>>>>>        String sRetval
27753>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27755>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27756>>>>>>>>>>
27756>>>>>>>>>            Function_Return
27757>>>>>>>>>        End
27757>>>>>>>>>>
27757>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
27758>>>>>>>>>        Function_Return sRetval
27759>>>>>>>>>    End_Function
27760>>>>>>>>>
27760>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
27762>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27764>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27765>>>>>>>>>>
27765>>>>>>>>>            Procedure_Return
27766>>>>>>>>>        End
27766>>>>>>>>>>
27766>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
27767>>>>>>>>>    End_Procedure
27768>>>>>>>>>
27768>>>>>>>>>    Function psBaseTableSpace Returns String
27770>>>>>>>>>        String sRetval
27770>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27772>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27773>>>>>>>>>>
27773>>>>>>>>>            Function_Return
27774>>>>>>>>>        End
27774>>>>>>>>>>
27774>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
27775>>>>>>>>>        Function_Return sRetval
27776>>>>>>>>>    End_Function
27777>>>>>>>>>
27777>>>>>>>>>    Procedure Set psLongTableSpace String sValue
27779>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27781>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27782>>>>>>>>>>
27782>>>>>>>>>            Procedure_Return
27783>>>>>>>>>        End
27783>>>>>>>>>>
27783>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
27784>>>>>>>>>    End_Procedure
27785>>>>>>>>>
27785>>>>>>>>>    Function psLongTableSpace Returns String
27787>>>>>>>>>        String sRetval
27787>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27789>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27790>>>>>>>>>>
27790>>>>>>>>>            Function_Return
27791>>>>>>>>>        End
27791>>>>>>>>>>
27791>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
27792>>>>>>>>>        Function_Return sRetval
27793>>>>>>>>>    End_Function
27794>>>>>>>>>
27794>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
27796>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27798>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27799>>>>>>>>>>
27799>>>>>>>>>            Procedure_Return
27800>>>>>>>>>        End
27800>>>>>>>>>>
27800>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
27801>>>>>>>>>    End_Procedure
27802>>>>>>>>>
27802>>>>>>>>>    Function psIndexTableSpace Returns String
27804>>>>>>>>>        String sRetval
27804>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27806>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27807>>>>>>>>>>
27807>>>>>>>>>            Function_Return
27808>>>>>>>>>        End
27808>>>>>>>>>>
27808>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
27809>>>>>>>>>        Function_Return sRetval
27810>>>>>>>>>    End_Function
27811>>>>>>>>>
27811>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
27813>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27815>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27816>>>>>>>>>>
27816>>>>>>>>>            Procedure_Return
27817>>>>>>>>>        End
27817>>>>>>>>>>
27817>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
27818>>>>>>>>>    End_Procedure
27819>>>>>>>>>
27819>>>>>>>>>    Function pbUseConnectionID Returns Boolean
27821>>>>>>>>>        Boolean bState
27821>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27823>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27824>>>>>>>>>>
27824>>>>>>>>>            Function_Return
27825>>>>>>>>>        End
27825>>>>>>>>>>
27825>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
27826>>>>>>>>>        Function_Return bState
27827>>>>>>>>>    End_Function
27828>>>>>>>>>
27828>>>>>>>>>    Procedure Set pbToANSI Boolean bState
27830>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27832>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27833>>>>>>>>>>
27833>>>>>>>>>            Procedure_Return
27834>>>>>>>>>        End
27834>>>>>>>>>>
27834>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
27835>>>>>>>>>    End_Procedure
27836>>>>>>>>>
27836>>>>>>>>>    Function pbToANSI Returns Boolean
27838>>>>>>>>>        Boolean bState
27838>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27840>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27841>>>>>>>>>>
27841>>>>>>>>>            Function_Return
27842>>>>>>>>>        End
27842>>>>>>>>>>
27842>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
27843>>>>>>>>>        Function_Return bState
27844>>>>>>>>>    End_Function
27845>>>>>>>>>
27845>>>>>>>>>    Procedure Set pbRecnum Boolean bState
27847>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27849>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27850>>>>>>>>>>
27850>>>>>>>>>            Procedure_Return
27851>>>>>>>>>        End
27851>>>>>>>>>>
27851>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
27852>>>>>>>>>    End_Procedure
27853>>>>>>>>>
27853>>>>>>>>>    Function pbRecnum Returns Boolean
27855>>>>>>>>>        Boolean bState
27855>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27857>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27858>>>>>>>>>>
27858>>>>>>>>>            Function_Return
27859>>>>>>>>>        End
27859>>>>>>>>>>
27859>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
27860>>>>>>>>>        Function_Return bState
27861>>>>>>>>>    End_Function
27862>>>>>>>>>
27862>>>>>>>>>    Procedure Set pbCopyData Boolean bState
27864>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27866>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27867>>>>>>>>>>
27867>>>>>>>>>            Procedure_Return
27868>>>>>>>>>        End
27868>>>>>>>>>>
27868>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
27869>>>>>>>>>    End_Procedure
27870>>>>>>>>>
27870>>>>>>>>>    Function pbCopyData Returns Boolean
27872>>>>>>>>>        Boolean bState
27872>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27874>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27875>>>>>>>>>>
27875>>>>>>>>>            Function_Return
27876>>>>>>>>>        End
27876>>>>>>>>>>
27876>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
27877>>>>>>>>>        Function_Return bState
27878>>>>>>>>>    End_Function
27879>>>>>>>>>
27879>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
27881>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27883>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27884>>>>>>>>>>
27884>>>>>>>>>            Procedure_Return
27885>>>>>>>>>        End
27885>>>>>>>>>>
27885>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
27886>>>>>>>>>    End_Procedure
27887>>>>>>>>>
27887>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
27889>>>>>>>>>        Boolean bState
27889>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27891>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27892>>>>>>>>>>
27892>>>>>>>>>            Function_Return
27893>>>>>>>>>        End
27893>>>>>>>>>>
27893>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
27894>>>>>>>>>        Function_Return bState
27895>>>>>>>>>    End_Function
27896>>>>>>>>>
27896>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
27898>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27900>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27901>>>>>>>>>>
27901>>>>>>>>>            Procedure_Return
27902>>>>>>>>>        End
27902>>>>>>>>>>
27902>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
27903>>>>>>>>>    End_Procedure
27904>>>>>>>>>
27904>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
27906>>>>>>>>>        Boolean bState
27906>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27908>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27909>>>>>>>>>>
27909>>>>>>>>>            Function_Return
27910>>>>>>>>>        End
27910>>>>>>>>>>
27910>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
27911>>>>>>>>>        Function_Return bState
27912>>>>>>>>>    End_Function
27913>>>>>>>>>
27913>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
27915>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27917>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27918>>>>>>>>>>
27918>>>>>>>>>            Procedure_Return
27919>>>>>>>>>        End
27919>>>>>>>>>>
27919>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
27920>>>>>>>>>    End_Procedure
27921>>>>>>>>>
27921>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
27923>>>>>>>>>        Boolean bState
27923>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27925>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27926>>>>>>>>>>
27926>>>>>>>>>            Function_Return
27927>>>>>>>>>        End
27927>>>>>>>>>>
27927>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
27928>>>>>>>>>        Function_Return bState
27929>>>>>>>>>    End_Function
27930>>>>>>>>>
27930>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
27932>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27934>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27935>>>>>>>>>>
27935>>>>>>>>>            Procedure_Return
27936>>>>>>>>>        End
27936>>>>>>>>>>
27936>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
27937>>>>>>>>>    End_Procedure
27938>>>>>>>>>
27938>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
27940>>>>>>>>>        Boolean bState
27940>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27942>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
27943>>>>>>>>>>
27943>>>>>>>>>            Function_Return
27944>>>>>>>>>        End
27944>>>>>>>>>>
27944>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
27945>>>>>>>>>        Function_Return bState
27946>>>>>>>>>    End_Function
27947>>>>>>>>>
27947>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
27949>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27951>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
27952>>>>>>>>>>
27952>>>>>>>>>            Procedure_Return
27953>>>>>>>>>        End
27953>>>>>>>>>>
27953>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
27954>>>>>>>>>    End_Procedure
27955>>>>>>>>>
27955>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
27957>>>>>>>>>        String sRetval
27957>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27959>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
27960>>>>>>>>>>
27960>>>>>>>>>            Function_Return
27961>>>>>>>>>        End
27961>>>>>>>>>>
27961>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
27962>>>>>>>>>        Function_Return sRetval
27963>>>>>>>>>    End_Function
27964>>>>>>>>>
27964>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
27966>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27968>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
27969>>>>>>>>>>
27969>>>>>>>>>            Procedure_Return
27970>>>>>>>>>        End
27970>>>>>>>>>>
27970>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
27971>>>>>>>>>    End_Procedure
27972>>>>>>>>>
27972>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
27974>>>>>>>>>        String sRetval
27974>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27976>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
27977>>>>>>>>>>
27977>>>>>>>>>            Function_Return
27978>>>>>>>>>        End
27978>>>>>>>>>>
27978>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
27979>>>>>>>>>        Function_Return sRetval
27980>>>>>>>>>    End_Function
27981>>>>>>>>>
27981>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
27983>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27985>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
27986>>>>>>>>>>
27986>>>>>>>>>            Procedure_Return
27987>>>>>>>>>        End
27987>>>>>>>>>>
27987>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
27988>>>>>>>>>    End_Procedure
27989>>>>>>>>>
27989>>>>>>>>>    Function psDriverDefaultValueDate Returns String
27991>>>>>>>>>        String sRetval
27991>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
27993>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
27994>>>>>>>>>>
27994>>>>>>>>>            Function_Return
27995>>>>>>>>>        End
27995>>>>>>>>>>
27995>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
27996>>>>>>>>>        Function_Return sRetval
27997>>>>>>>>>    End_Function
27998>>>>>>>>>
27998>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
28000>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28002>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28003>>>>>>>>>>
28003>>>>>>>>>            Procedure_Return
28004>>>>>>>>>        End
28004>>>>>>>>>>
28004>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
28005>>>>>>>>>    End_Procedure
28006>>>>>>>>>
28006>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
28008>>>>>>>>>        String sRetval
28008>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28010>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28011>>>>>>>>>>
28011>>>>>>>>>            Function_Return
28012>>>>>>>>>        End
28012>>>>>>>>>>
28012>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
28013>>>>>>>>>        Function_Return sRetval
28014>>>>>>>>>    End_Function
28015>>>>>>>>>
28015>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
28017>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28019>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28020>>>>>>>>>>
28020>>>>>>>>>            Procedure_Return
28021>>>>>>>>>        End
28021>>>>>>>>>>
28021>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
28022>>>>>>>>>    End_Procedure
28023>>>>>>>>>
28023>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
28025>>>>>>>>>        String sRetval
28025>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28027>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28028>>>>>>>>>>
28028>>>>>>>>>            Function_Return
28029>>>>>>>>>        End
28029>>>>>>>>>>
28029>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
28030>>>>>>>>>        Function_Return sRetval
28031>>>>>>>>>    End_Function
28032>>>>>>>>>
28032>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
28034>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28036>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28037>>>>>>>>>>
28037>>>>>>>>>            Procedure_Return
28038>>>>>>>>>        End
28038>>>>>>>>>>
28038>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
28039>>>>>>>>>    End_Procedure
28040>>>>>>>>>
28040>>>>>>>>>    Function psDriverDefaultValueText Returns String
28042>>>>>>>>>        String sRetval
28042>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28044>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28045>>>>>>>>>>
28045>>>>>>>>>            Function_Return
28046>>>>>>>>>        End
28046>>>>>>>>>>
28046>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
28047>>>>>>>>>        Function_Return sRetval
28048>>>>>>>>>    End_Function
28049>>>>>>>>>
28049>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
28051>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28053>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28054>>>>>>>>>>
28054>>>>>>>>>            Procedure_Return
28055>>>>>>>>>        End
28055>>>>>>>>>>
28055>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
28056>>>>>>>>>    End_Procedure
28057>>>>>>>>>
28057>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
28059>>>>>>>>>        Boolean bState
28059>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28061>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28062>>>>>>>>>>
28062>>>>>>>>>            Function_Return
28063>>>>>>>>>        End
28063>>>>>>>>>>
28063>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
28064>>>>>>>>>        Function_Return bState
28065>>>>>>>>>    End_Function
28066>>>>>>>>>
28066>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
28068>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28070>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28071>>>>>>>>>>
28071>>>>>>>>>            Procedure_Return
28072>>>>>>>>>        End
28072>>>>>>>>>>
28072>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
28073>>>>>>>>>    End_Procedure
28074>>>>>>>>>
28074>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
28076>>>>>>>>>        Boolean bState
28076>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28078>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28079>>>>>>>>>>
28079>>>>>>>>>            Function_Return
28080>>>>>>>>>        End
28080>>>>>>>>>>
28080>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
28081>>>>>>>>>        Function_Return bState
28082>>>>>>>>>    End_Function
28083>>>>>>>>>
28083>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
28085>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28087>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28088>>>>>>>>>>
28088>>>>>>>>>            Procedure_Return
28089>>>>>>>>>        End
28089>>>>>>>>>>
28089>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
28090>>>>>>>>>    End_Procedure
28091>>>>>>>>>
28091>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
28093>>>>>>>>>        Boolean bState
28093>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28095>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28096>>>>>>>>>>
28096>>>>>>>>>            Function_Return
28097>>>>>>>>>        End
28097>>>>>>>>>>
28097>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
28098>>>>>>>>>        Function_Return bState
28099>>>>>>>>>    End_Function
28100>>>>>>>>>
28100>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
28102>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28104>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28105>>>>>>>>>>
28105>>>>>>>>>            Procedure_Return
28106>>>>>>>>>        End
28106>>>>>>>>>>
28106>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
28107>>>>>>>>>    End_Procedure
28108>>>>>>>>>
28108>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
28110>>>>>>>>>        Boolean bState
28110>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28112>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28113>>>>>>>>>>
28113>>>>>>>>>            Function_Return
28114>>>>>>>>>        End
28114>>>>>>>>>>
28114>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
28115>>>>>>>>>        Function_Return bState
28116>>>>>>>>>    End_Function
28117>>>>>>>>>
28117>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
28119>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28121>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28122>>>>>>>>>>
28122>>>>>>>>>            Procedure_Return
28123>>>>>>>>>        End
28123>>>>>>>>>>
28123>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
28124>>>>>>>>>    End_Procedure
28125>>>>>>>>>
28125>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
28127>>>>>>>>>        Boolean bState
28127>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28129>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28130>>>>>>>>>>
28130>>>>>>>>>            Function_Return
28131>>>>>>>>>        End
28131>>>>>>>>>>
28131>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
28132>>>>>>>>>        Function_Return bState
28133>>>>>>>>>    End_Function
28134>>>>>>>>>
28134>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
28136>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28138>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28139>>>>>>>>>>
28139>>>>>>>>>            Procedure_Return
28140>>>>>>>>>        End
28140>>>>>>>>>>
28140>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
28141>>>>>>>>>    End_Procedure
28142>>>>>>>>>
28142>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
28144>>>>>>>>>        Boolean bState
28144>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
28146>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
28147>>>>>>>>>>
28147>>>>>>>>>            Function_Return
28148>>>>>>>>>        End
28148>>>>>>>>>>
28148>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
28149>>>>>>>>>        Function_Return bState
28150>>>>>>>>>    End_Function
28151>>>>>>>>>
28151>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
28151>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
28151>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
28151>>>>>>>>>    //       for a connection string has the wrong format for that driver.
28151>>>>>>>>>    Procedure Set psDriverID String sValue
28153>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
28154>>>>>>>>>        Delegate Set psDriverID to sValue
28156>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
28157>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
28158>>>>>>>>>    End_Procedure
28159>>>>>>>>>
28159>>>>>>>>>    Function psDriverID Returns String
28161>>>>>>>>>        String sDriverID
28161>>>>>>>>>
28161>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
28162>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
28162>>>>>>>>>        Delegate Get psDriverID to sDriverID
28164>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
28165>>>>>>>>>        Move False to Err
28166>>>>>>>>>
28166>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
28166>>>>>>>>>        // probably used as "utilites" from a special made program and
28166>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
28166>>>>>>>>>        If (sDriverID = "") Begin
28168>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
28169>>>>>>>>>        End
28169>>>>>>>>>>
28169>>>>>>>>>        Function_Return sDriverID
28170>>>>>>>>>    End_Function
28171>>>>>>>>>
28171>>>>>>>>>    Procedure Set piDbType Integer iValue
28173>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
28174>>>>>>>>>        Delegate Set piDbType to iValue
28176>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
28177>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
28178>>>>>>>>>    End_Procedure
28179>>>>>>>>>
28179>>>>>>>>>    Function piDbType Returns Integer
28181>>>>>>>>>        Integer iRetval
28181>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
28182>>>>>>>>>        Function_Return iRetval
28183>>>>>>>>>    End_Function
28184>>>>>>>>>
28184>>>>>>>>>    // Returns the index for the passed sTableName
28184>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
28184>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
28186>>>>>>>>>        Integer iIndex iSize iCount
28186>>>>>>>>>        String[] sTablesArray
28187>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
28187>>>>>>>>>
28187>>>>>>>>>        Move -1 to iIndex
28188>>>>>>>>>        Get psConnectionString to sConnectionString
28189>>>>>>>>>        Get psDatabase to sDatabase
28190>>>>>>>>>        Get psSchema   to sSchema
28191>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
28192>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
28193>>>>>>>>>        Decrement iSize
28194>>>>>>>>>        For iCount from 0 to iSize
28200>>>>>>>>>>
28200>>>>>>>>>            Move sTablesArray[iCount] to sVal
28201>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
28203>>>>>>>>>                Move iCount to iIndex // We found it!
28204>>>>>>>>>                Move iSize to iCount  // End the loop
28205>>>>>>>>>            End
28205>>>>>>>>>>
28205>>>>>>>>>        Loop
28206>>>>>>>>>>
28206>>>>>>>>>
28206>>>>>>>>>        Function_Return iIndex
28207>>>>>>>>>    End_Function
28208>>>>>>>>>
28208>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
28208>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
28210>>>>>>>>>        String[] sReturnArray
28211>>>>>>>>>        Boolean bOK
28211>>>>>>>>>
28211>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28212>>>>>>>>>        If (bOK = False) Begin
28214>>>>>>>>>            Function_Return sReturnArray
28215>>>>>>>>>        End
28215>>>>>>>>>>
28215>>>>>>>>>
28215>>>>>>>>>        Case Begin
28215>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
28217>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
28218>>>>>>>>>                Case Break
28219>>>>>>>>>
28219>>>>>>>>>            Case Else
28219>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
28220>>>>>>>>>>
28220>>>>>>>>>                Case Break
28221>>>>>>>>>        Case End
28221>>>>>>>>>
28221>>>>>>>>>        Function_Return sReturnArray
28222>>>>>>>>>    End_Function
28223>>>>>>>>>
28223>>>>>>>>>    // Returns a string array with all tables for the current database.
28223>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
28225>>>>>>>>>        String[] sReturnArray sArray
28227>>>>>>>>>        String sConnectionString sSelect
28227>>>>>>>>>        Integer iSize iCount iDbType
28227>>>>>>>>>        Boolean bOK
28227>>>>>>>>>
28227>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
28229>>>>>>>>>            Function_Return sArray
28230>>>>>>>>>        End
28230>>>>>>>>>>
28230>>>>>>>>>
28230>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28231>>>>>>>>>        If (bOK = False) Begin
28233>>>>>>>>>            Function_Return sReturnArray
28234>>>>>>>>>        End
28234>>>>>>>>>>
28234>>>>>>>>>        If (sSchema = "") Begin
28236>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
28237>>>>>>>>>        End
28237>>>>>>>>>>
28237>>>>>>>>>
28237>>>>>>>>>        Get psConnectionString to sConnectionString
28238>>>>>>>>>
28238>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
28238>>>>>>>>>        // the dbType.
28238>>>>>>>>>        Get piDbType to iDbType
28239>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
28241>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
28243>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
28244>>>>>>>>>            End
28244>>>>>>>>>>
28244>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
28246>>>>>>>>>                Move DB2_DRV_ID to sDriverID
28247>>>>>>>>>            End
28247>>>>>>>>>>
28247>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
28249>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
28250>>>>>>>>>            End
28250>>>>>>>>>>
28250>>>>>>>>>        End
28250>>>>>>>>>>
28250>>>>>>>>>
28250>>>>>>>>>        Case Begin
28250>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
28252>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
28253>>>>>>>>>                Case Break
28254>>>>>>>>>
28254>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
28257>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
28258>>>>>>>>>                Case Break
28259>>>>>>>>>
28259>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
28262>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
28263>>>>>>>>>                Case Break
28264>>>>>>>>>
28264>>>>>>>>>            Case Else
28264>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
28265>>>>>>>>>>
28265>>>>>>>>>                Case Break
28266>>>>>>>>>        Case End
28266>>>>>>>>>
28266>>>>>>>>>        Function_Return sReturnArray
28267>>>>>>>>>    End_Function
28268>>>>>>>>>
28268>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
28268>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
28270>>>>>>>>>        String[] sReturnArray
28271>>>>>>>>>        Boolean bOK
28271>>>>>>>>>
28271>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28272>>>>>>>>>        If (bOK = False) Begin
28274>>>>>>>>>            Function_Return sReturnArray
28275>>>>>>>>>        End
28275>>>>>>>>>>
28275>>>>>>>>>
28275>>>>>>>>>        Case Begin
28275>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
28277>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
28278>>>>>>>>>                Case Break
28279>>>>>>>>>
28279>>>>>>>>>            Case Else
28279>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
28280>>>>>>>>>>
28280>>>>>>>>>                Case Break
28281>>>>>>>>>        Case End
28281>>>>>>>>>
28281>>>>>>>>>        Function_Return sReturnArray
28282>>>>>>>>>    End_Function
28283>>>>>>>>>
28283>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
28283>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
28285>>>>>>>>>        String[] sReturnArray
28286>>>>>>>>>        String sConnectionString sSelect sSchema
28286>>>>>>>>>        Boolean bOK
28286>>>>>>>>>        Integer iDbType
28286>>>>>>>>>
28286>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28287>>>>>>>>>        If (bOK = False) Begin
28289>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
28290>>>>>>>>>>
28290>>>>>>>>>            Function_Return sReturnArray
28291>>>>>>>>>        End
28291>>>>>>>>>>
28291>>>>>>>>>
28291>>>>>>>>>        Get psConnectionString to sConnectionString
28292>>>>>>>>>        Get psSchema to sSchema
28293>>>>>>>>>
28293>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
28293>>>>>>>>>        // the dbType.
28293>>>>>>>>>        Get piDbType to iDbType
28294>>>>>>>>>
28294>>>>>>>>>        Case Begin
28294>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
28296>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
28298>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
28299>>>>>>>>>                End
28299>>>>>>>>>>
28299>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
28301>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
28302>>>>>>>>>                End
28302>>>>>>>>>>
28302>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
28304>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
28305>>>>>>>>>                End
28305>>>>>>>>>>
28305>>>>>>>>>
28305>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
28306>>>>>>>>>                Case Break
28307>>>>>>>>>
28307>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
28310>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
28311>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
28312>>>>>>>>>                Case Break
28313>>>>>>>>>
28313>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
28316>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
28317>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
28318>>>>>>>>>                Case Break
28319>>>>>>>>>
28319>>>>>>>>>            Case Else
28319>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
28320>>>>>>>>>>
28320>>>>>>>>>                Case Break
28321>>>>>>>>>        Case End
28321>>>>>>>>>
28321>>>>>>>>>        Function_Return sReturnArray
28322>>>>>>>>>    End_Function
28323>>>>>>>>>
28323>>>>>>>>>
28323>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
28323>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
28325>>>>>>>>>        String[] sReturnArray sReturnArray2
28327>>>>>>>>>        String sConnectionString sSelect sSchema
28327>>>>>>>>>        Boolean bOK
28327>>>>>>>>>        Integer iCount iSize
28327>>>>>>>>>
28327>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28328>>>>>>>>>        If (bOK = False) Begin
28330>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
28331>>>>>>>>>>
28331>>>>>>>>>            Function_Return sReturnArray
28332>>>>>>>>>        End
28332>>>>>>>>>>
28332>>>>>>>>>
28332>>>>>>>>>        Get psConnectionString to sConnectionString
28333>>>>>>>>>        Get psSchema to sSchema
28334>>>>>>>>>
28334>>>>>>>>>        Case Begin
28334>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
28336>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
28337>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
28338>>>>>>>>>                Case Break
28339>>>>>>>>>
28339>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
28342>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
28343>>>>>>>>>>
28343>>>>>>>>>//                Move () to sSelect
28343>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
28343>>>>>>>>>                Case Break
28344>>>>>>>>>
28344>>>>>>>>>            Case Else
28344>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
28345>>>>>>>>>>
28345>>>>>>>>>                Case Break
28346>>>>>>>>>        Case End
28346>>>>>>>>>
28346>>>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
28347>>>>>>>>>        Decrement iSize
28348>>>>>>>>>        For iCount from 0 to iSize
28354>>>>>>>>>>
28354>>>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
28356>>>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
28357>>>>>>>>>            End
28357>>>>>>>>>>
28357>>>>>>>>>        Loop
28358>>>>>>>>>>
28358>>>>>>>>>
28358>>>>>>>>>        Function_Return sReturnArray2
28359>>>>>>>>>    End_Function
28360>>>>>>>>>
28360>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
28360>>>>>>>>>    // The format of the array is "TableName.FieldName"
28360>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
28362>>>>>>>>>        String[] sFileNameArray sFieldNameArray
28364>>>>>>>>>        tSQLRelation[] sRelationsArray
28364>>>>>>>>>        tSQLRelation[] sRelationsArray
28365>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
28365>>>>>>>>>        Boolean bOK
28365>>>>>>>>>        Integer iCount iSize iLength
28365>>>>>>>>>
28365>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
28366>>>>>>>>>        If (bOK = False) Begin
28368>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
28369>>>>>>>>>>
28369>>>>>>>>>            Function_Return sRelationsArray
28370>>>>>>>>>        End
28370>>>>>>>>>>
28370>>>>>>>>>
28370>>>>>>>>>        Get psConnectionString to sConnectionString
28371>>>>>>>>>        Get psSchema to sSchema
28372>>>>>>>>>
28372>>>>>>>>>        Case Begin
28372>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
28374>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
28375>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
28376>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
28377>>>>>>>>>                Case Break
28378>>>>>>>>>
28378>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
28381>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
28382>>>>>>>>>>
28382>>>>>>>>>//                Move () to sSelect
28382>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
28382>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
28382>>>>>>>>>                Case Break
28383>>>>>>>>>
28383>>>>>>>>>            Case Else
28383>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
28384>>>>>>>>>>
28384>>>>>>>>>                Case Break
28385>>>>>>>>>        Case End
28385>>>>>>>>>
28385>>>>>>>>>        Move (Length(sTableName)) to iLength
28386>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
28387>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
28388>>>>>>>>>        Decrement iSize
28389>>>>>>>>>        For iCount from 0 to iSize
28395>>>>>>>>>>
28395>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
28397>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
28398>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
28399>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
28400>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
28401>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
28402>>>>>>>>>            End
28402>>>>>>>>>>
28402>>>>>>>>>        Loop
28403>>>>>>>>>>
28403>>>>>>>>>
28403>>>>>>>>>        Function_Return sRelationsArray
28404>>>>>>>>>    End_Function
28405>>>>>>>>>
28405>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
28407>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
28407>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
28408>>>>>>>>>        String[] sUsers sPrograms
28410>>>>>>>>>        String sSelect
28410>>>>>>>>>        Integer iSize iCount
28410>>>>>>>>>
28410>>>>>>>>>        Case Begin
28410>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
28412>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
28413>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
28414>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
28415>>>>>>>>>                Case Break
28416>>>>>>>>>            Case Else
28416>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
28417>>>>>>>>>>
28417>>>>>>>>>        Case End
28417>>>>>>>>>
28417>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
28418>>>>>>>>>        Decrement iSize
28419>>>>>>>>>        For iCount from 0 to iSize
28425>>>>>>>>>>
28425>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
28426>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
28427>>>>>>>>>        Loop
28428>>>>>>>>>>
28428>>>>>>>>>
28428>>>>>>>>>        Function_Return SQLLoggedInUser
28429>>>>>>>>>    End_Function
28430>>>>>>>>>
28430>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
28430>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
28430>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
28432>>>>>>>>>        String[] sFilesData
28433>>>>>>>>>        Boolean bExists
28433>>>>>>>>>        Integer iCh
28433>>>>>>>>>        String sFileName sExt
28433>>>>>>>>>
28433>>>>>>>>>        Get vFolderExists sDataPath to bExists
28434>>>>>>>>>        If (bExists = True) Begin
28436>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
28437>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
28438>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
28439>>>>>>>>>            Direct_Input channel iCh sDataPath
28441>>>>>>>>>                Repeat
28441>>>>>>>>>>
28441>>>>>>>>>                    Readln channel iCh sFileName
28443>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
28444>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
28446>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
28448>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
28449>>>>>>>>>                        End
28449>>>>>>>>>>
28449>>>>>>>>>                    End
28449>>>>>>>>>>
28449>>>>>>>>>                Until (SeqEof = True)
28451>>>>>>>>>            Close_Input channel iCh
28453>>>>>>>>>            Send Seq_Release_Channel iCh
28454>>>>>>>>>        End
28454>>>>>>>>>>
28454>>>>>>>>>        Function_Return sFilesData
28455>>>>>>>>>    End_Function
28456>>>>>>>>>
28456>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
28456>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
28458>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
28458>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
28458>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
28458>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
28458>>>>>>>>>        tSQLConnection SQLConnection
28458>>>>>>>>>        tSQLConnection SQLConnection
28458>>>>>>>>>        String[] asCollations
28459>>>>>>>>>        
28459>>>>>>>>>        If (sDriverID = "") Begin
28461>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
28462>>>>>>>>>>
28462>>>>>>>>>            Function_Return asCollations
28463>>>>>>>>>        End
28463>>>>>>>>>>
28463>>>>>>>>>
28463>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
28463>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
28465>>>>>>>>>            Function_Return asCollations
28466>>>>>>>>>        End                 
28466>>>>>>>>>>
28466>>>>>>>>>
28466>>>>>>>>>        Get phoSQLManager to hoSQLManager
28467>>>>>>>>>        Get psConnectionID     to sConnectionID
28468>>>>>>>>>        Get psConnectionString to sConnectionString
28469>>>>>>>>>        Move 0 to LastErr
28470>>>>>>>>>
28470>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28471>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
28472>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28473>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
28475>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
28476>>>>>>>>>>
28476>>>>>>>>>            Function_Return asCollations
28477>>>>>>>>>        End
28477>>>>>>>>>>
28477>>>>>>>>>
28477>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
28478>>>>>>>>>
28478>>>>>>>>>        If (hStmt = 0) Begin
28480>>>>>>>>>            Send SqlDisconnect of hoSQLManager
28481>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
28482>>>>>>>>>>
28482>>>>>>>>>            Function_Return asCollations
28483>>>>>>>>>        End
28483>>>>>>>>>>
28483>>>>>>>>>
28483>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
28484>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
28485>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
28486>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
28487>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
28488>>>>>>>>>
28488>>>>>>>>>        // MS-SQL Syntax:  
28488>>>>>>>>>        // SELECT name, description
28488>>>>>>>>>        //   from sys.fn_helpcollations();
28488>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
28489>>>>>>>>>
28489>>>>>>>>>        Move 1 to iColumn
28490>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
28491>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
28492>>>>>>>>>        Repeat
28492>>>>>>>>>>
28492>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
28493>>>>>>>>>            If (iFetchResult <> 0) Begin
28495>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
28496>>>>>>>>>                If (sValue <> sPrevious) Begin         
28498>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
28498>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
28498>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
28499>>>>>>>>>                    If (iPos <> 1) Begin
28501>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
28502>>>>>>>>>                    End
28502>>>>>>>>>>
28502>>>>>>>>>                End
28502>>>>>>>>>>
28502>>>>>>>>>                Move sValue to sPrevious
28503>>>>>>>>>            End
28503>>>>>>>>>>
28503>>>>>>>>>        Until (iFetchResult = 0)
28505>>>>>>>>>        Send SQLClose of hStmt
28506>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
28507>>>>>>>>>
28507>>>>>>>>>        Function_Return asCollations
28508>>>>>>>>>    End_Function
28509>>>>>>>>>
28509>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
28509>>>>>>>>>    // for DAW drivers.
28509>>>>>>>>>    // Returns: A string array.
28509>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
28511>>>>>>>>>        String[] sReturnArray
28512>>>>>>>>>        String sValue sPrevious
28512>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
28512>>>>>>>>>        Integer iFetchResult iRows
28512>>>>>>>>>        tSQLConnection SQLConnection
28512>>>>>>>>>        tSQLConnection SQLConnection
28512>>>>>>>>>
28512>>>>>>>>>        Get phoSQLManager to hoSQLHandler
28513>>>>>>>>>
28513>>>>>>>>>        If (hoSQLHandler <> 0) Begin
28515>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28516>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
28517>>>>>>>>>
28517>>>>>>>>>            If (hoSQLConnect <> 0) Begin
28519>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
28520>>>>>>>>>                If (hstmt <> 0) Begin
28522>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
28523>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
28524>>>>>>>>>                    Repeat
28524>>>>>>>>>>
28524>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
28525>>>>>>>>>                        If (iFetchResult <> 0) Begin
28527>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
28528>>>>>>>>>                            If (sValue <> sPrevious) Begin
28530>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
28531>>>>>>>>>                            End
28531>>>>>>>>>>
28531>>>>>>>>>                            Move sValue to sPrevious
28532>>>>>>>>>                        End
28532>>>>>>>>>>
28532>>>>>>>>>                    Until (iFetchResult = 0)
28534>>>>>>>>>                    Send SQLClose of hstmt
28535>>>>>>>>>                End
28535>>>>>>>>>>
28535>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
28536>>>>>>>>>            End
28536>>>>>>>>>>
28536>>>>>>>>>        End
28536>>>>>>>>>>
28536>>>>>>>>>
28536>>>>>>>>>        Function_Return sReturnArray
28537>>>>>>>>>    End_Function
28538>>>>>>>>>
28538>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
28540>>>>>>>>>        String[] sReturnArray
28541>>>>>>>>>        String sDataSource
28541>>>>>>>>>        Handle hoSQLHandler
28541>>>>>>>>>        Integer iItem
28541>>>>>>>>>
28541>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
28542>>>>>>>>>        Send SeedDataSources of hoSQLHandler
28543>>>>>>>>>
28543>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28544>>>>>>>>>
28544>>>>>>>>>        Repeat
28544>>>>>>>>>>
28544>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
28545>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
28546>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
28547>>>>>>>>>            Increment iItem
28548>>>>>>>>>        Until (sDataSource = "")
28550>>>>>>>>>
28550>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28551>>>>>>>>>
28551>>>>>>>>>        Function_Return sReturnArray
28552>>>>>>>>>    End_Function
28553>>>>>>>>>
28553>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
28555>>>>>>>>>        String[] sReturnArray
28556>>>>>>>>>        String sDataSource
28556>>>>>>>>>        Handle hoSQLHandler
28556>>>>>>>>>        Integer iItem
28556>>>>>>>>>
28556>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
28557>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28558>>>>>>>>>
28558>>>>>>>>>        Send SeedDataSources of hoSQLHandler
28559>>>>>>>>>
28559>>>>>>>>>        Repeat
28559>>>>>>>>>>
28559>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
28560>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
28562>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
28563>>>>>>>>>                Increment iItem
28564>>>>>>>>>            End
28564>>>>>>>>>>
28564>>>>>>>>>        Until (sDataSource = "")
28566>>>>>>>>>
28566>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28567>>>>>>>>>
28567>>>>>>>>>        Function_Return sReturnArray
28568>>>>>>>>>    End_Function
28569>>>>>>>>>
28569>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
28571>>>>>>>>>        String[] sDataSources
28572>>>>>>>>>        tSQLConnection SQLConnection
28572>>>>>>>>>        tSQLConnection SQLConnection
28572>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
28572>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
28573>>>>>>>>>        Integer iDataSources iCount iItem
28573>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
28573>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
28573>>>>>>>>>        Boolean bExists bKeyOpened
28573>>>>>>>>>
28573>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28574>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
28575>>>>>>>>>        Move SQLConnection.sServer           to sServer
28576>>>>>>>>>
28576>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
28576>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
28578>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
28579>>>>>>>>>            Set psFileName of hoIniFile to sServer
28580>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
28581>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
28582>>>>>>>>>            Send Destroy of hoIniFile
28583>>>>>>>>>        End
28583>>>>>>>>>>
28583>>>>>>>>>
28583>>>>>>>>>        // DSN - read DATABASE name from the registry
28583>>>>>>>>>        Else Begin
28584>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
28585>>>>>>>>>
28585>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
28585>>>>>>>>>            // most probably place the info is kept that we're after.
28585>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
28586>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
28587>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
28588>>>>>>>>>            If (bExists = True) Begin
28590>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
28591>>>>>>>>>            End
28591>>>>>>>>>>
28591>>>>>>>>>            Else Begin
28592>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
28593>>>>>>>>>            End
28593>>>>>>>>>>
28593>>>>>>>>>
28593>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
28594>>>>>>>>>            If (bExists) Begin
28596>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
28597>>>>>>>>>                If (bKeyOpened) Begin
28599>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
28600>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
28601>>>>>>>>>                    If (iDataSources > 0) Begin
28603>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
28604>>>>>>>>>                        Decrement iDataSources
28605>>>>>>>>>                        for iCount from 0 to iDataSources
28611>>>>>>>>>>
28611>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
28612>>>>>>>>>                        Loop
28613>>>>>>>>>>
28613>>>>>>>>>                        Move 0 to iItem
28614>>>>>>>>>                        for iCount from 0 to iDataSources
28620>>>>>>>>>>
28620>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
28621>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
28622>>>>>>>>>                            If (bKeyOpened = True) Begin
28624>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
28625>>>>>>>>>                                If (bExists = True) Begin
28627>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
28628>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
28629>>>>>>>>>                                    Increment iItem
28630>>>>>>>>>                                End
28630>>>>>>>>>>
28630>>>>>>>>>                            End
28630>>>>>>>>>>
28630>>>>>>>>>                        Loop
28631>>>>>>>>>>
28631>>>>>>>>>                    End
28631>>>>>>>>>>
28631>>>>>>>>>                    Send CloseKey of hoRegistry
28632>>>>>>>>>                    Send Destroy of hoODBCDataSources
28633>>>>>>>>>                End
28633>>>>>>>>>>
28633>>>>>>>>>            End
28633>>>>>>>>>>
28633>>>>>>>>>
28633>>>>>>>>>            // We then check the "User DNS" area in the registry.
28633>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
28634>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
28635>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
28636>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
28637>>>>>>>>>
28637>>>>>>>>>            If (bExists) Begin
28639>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
28640>>>>>>>>>                If (bKeyOpened) Begin
28642>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
28643>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
28644>>>>>>>>>                    If (iDataSources > 0) Begin
28646>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
28647>>>>>>>>>                        Decrement iDataSources
28648>>>>>>>>>                        for iCount from 0 to iDataSources
28654>>>>>>>>>>
28654>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
28655>>>>>>>>>                        Loop
28656>>>>>>>>>>
28656>>>>>>>>>                        for iCount from 0 to iDataSources
28662>>>>>>>>>>
28662>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
28663>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
28664>>>>>>>>>                            If (bKeyOpened = True) Begin
28666>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
28667>>>>>>>>>                                If (bExists = True) Begin
28669>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
28670>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
28671>>>>>>>>>                                    Increment iItem
28672>>>>>>>>>                                End
28672>>>>>>>>>>
28672>>>>>>>>>                            End
28672>>>>>>>>>>
28672>>>>>>>>>                        Loop
28673>>>>>>>>>>
28673>>>>>>>>>                    End
28673>>>>>>>>>>
28673>>>>>>>>>                    Send CloseKey of hoRegistry
28674>>>>>>>>>                    Send Destroy of hoODBCDataSources
28675>>>>>>>>>                End
28675>>>>>>>>>>
28675>>>>>>>>>            End
28675>>>>>>>>>>
28675>>>>>>>>>
28675>>>>>>>>>            Send Destroy of hoRegistry
28676>>>>>>>>>        End
28676>>>>>>>>>>
28676>>>>>>>>>
28676>>>>>>>>>        Function_Return sReturnArray
28677>>>>>>>>>    End_Function
28678>>>>>>>>>
28678>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
28678>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
28678>>>>>>>>>    // insert it for scriplets to come after the first one.
28678>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
28680>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
28680>>>>>>>>>        Integer iStart iEnd iDbType
28680>>>>>>>>>        Boolean bOK
28680>>>>>>>>>
28680>>>>>>>>>        Get piDbType to iDbType
28681>>>>>>>>>        Get psDriverID to sDriverID
28682>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
28683>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
28684>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
28685>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
28686>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
28687>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
28689>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
28690>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
28691>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
28692>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
28693>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
28694>>>>>>>>>        End
28694>>>>>>>>>>
28694>>>>>>>>>        Else Begin
28695>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
28696>>>>>>>>>
28696>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
28696>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
28698>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
28699>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
28700>>>>>>>>>            End
28700>>>>>>>>>>
28700>>>>>>>>>
28700>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
28700>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
28700>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
28700>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
28703>>>>>>>>>                // Make sure we only have one space between statements/words.
28703>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
28704>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
28705>>>>>>>>>                Move (Trim(sTmp)) to sTmp
28706>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
28707>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
28708>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
28710>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
28711>>>>>>>>>                End
28711>>>>>>>>>>
28711>>>>>>>>>                Move (Trim(sTmp)) to sTmp
28712>>>>>>>>>                // Remove data view as it already exists!
28712>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
28713>>>>>>>>>            End
28713>>>>>>>>>>
28713>>>>>>>>>        End
28713>>>>>>>>>>
28713>>>>>>>>>
28713>>>>>>>>>        Function_Return sStmt
28714>>>>>>>>>    End_Function
28715>>>>>>>>>
28715>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
28715>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
28717>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
28717>>>>>>>>>        Integer iRetval
28717>>>>>>>>>        Boolean bOK
28717>>>>>>>>>
28717>>>>>>>>>        Get psDriverID to sDriverID
28718>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
28719>>>>>>>>>
28719>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
28720>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
28721>>>>>>>>>        Set psSQLStatementString to sSQLString
28722>>>>>>>>>
28722>>>>>>>>>        // As we don't check if the view exist or not, it might happen
28722>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
28722>>>>>>>>>        Move False to Err
28723>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28724>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
28725>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
28726>>>>>>>>>        Move 0 to LastErr
28727>>>>>>>>>
28727>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
28727>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
28728>>>>>>>>>
28728>>>>>>>>>        Function_Return (Err = False)
28729>>>>>>>>>    End_Function
28730>>>>>>>>>
28730>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
28730>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
28732>>>>>>>>>        String sRetval
28732>>>>>>>>>        Integer iDbType iIndex
28732>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
28732>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
28733>>>>>>>>>        tSQLKeyWords   SQLKeyWords
28733>>>>>>>>>        tSQLKeyWords   SQLKeyWords
28733>>>>>>>>>
28733>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
28733>>>>>>>>>        Move "" to sRetval
28734>>>>>>>>>        Get piDbType to iDbType
28735>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
28736>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
28737>>>>>>>>>
28737>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
28738>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
28739>>>>>>>>>        If (iIndex >= 0) Begin
28741>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
28742>>>>>>>>>        End
28742>>>>>>>>>>
28742>>>>>>>>>
28742>>>>>>>>>        Function_Return sRetval
28743>>>>>>>>>    End_Function
28744>>>>>>>>>
28744>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
28744>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
28746>>>>>>>>>        String[] sSQLScriptArray
28747>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
28747>>>>>>>>>        Integer iSize iCount
28747>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
28747>>>>>>>>>
28747>>>>>>>>>        Move False to bCommentStart
28748>>>>>>>>>        Move False to bCommentEnd
28749>>>>>>>>>        Move False to bDashComment
28750>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
28751>>>>>>>>>        Move "*/"  to sCommentEnd
28752>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
28753>>>>>>>>>
28753>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
28754>>>>>>>>>        Decrement iSize
28755>>>>>>>>>        Move "" to sText
28756>>>>>>>>>
28756>>>>>>>>>        for iCount from 0 to iSize
28762>>>>>>>>>>
28762>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
28763>>>>>>>>>            Move (Trim(sLine)) to sTmp
28764>>>>>>>>>            If (sTmp <> "") Begin
28766>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
28767>>>>>>>>>                If (bCommentStart = False) Begin
28769>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
28770>>>>>>>>>                    If (bCommentStart = False) Begin
28772>>>>>>>>>                    End
28772>>>>>>>>>>
28772>>>>>>>>>                End
28772>>>>>>>>>>
28772>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
28773>>>>>>>>>                If (bCommentEnd = True) Begin
28775>>>>>>>>>                    Move False to bCommentStart
28776>>>>>>>>>                End
28776>>>>>>>>>>
28776>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
28778>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
28779>>>>>>>>>                End
28779>>>>>>>>>>
28779>>>>>>>>>            End
28779>>>>>>>>>>
28779>>>>>>>>>        Loop
28780>>>>>>>>>>
28780>>>>>>>>>
28780>>>>>>>>>        // Update the retval struct array:
28780>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
28781>>>>>>>>>        Function_Return SqlScriptArray
28782>>>>>>>>>    End_Function
28783>>>>>>>>>
28783>>>>>>>>>    // Helper function that builds a string like;
28783>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
28783>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
28785>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
28785>>>>>>>>>
28785>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
28786>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
28787>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
28788>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
28789>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
28790>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
28791>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
28792>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
28793>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
28794>>>>>>>>>        Function_Return sRetval
28795>>>>>>>>>    End_Function
28796>>>>>>>>>
28796>>>>>>>>>    // Helper function to create a SQL statement like;
28796>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
28796>>>>>>>>>    // Used for checking if an index exists.
28796>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
28798>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
28798>>>>>>>>>
28798>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
28799>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
28800>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
28801>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
28802>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
28803>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
28804>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
28805>>>>>>>>>
28805>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
28806>>>>>>>>>
28806>>>>>>>>>        Function_Return sRetval
28807>>>>>>>>>    End_Function
28808>>>>>>>>>
28808>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
28808>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
28808>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
28810>>>>>>>>>        String sRetval
28810>>>>>>>>>        If (iLength <> 0) Begin
28812>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
28813>>>>>>>>>            If (iDecimals <> 0) Begin
28815>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
28816>>>>>>>>>            End
28816>>>>>>>>>>
28816>>>>>>>>>            Move (sRetval + ")") to sRetval
28817>>>>>>>>>        End
28817>>>>>>>>>>
28817>>>>>>>>>        Function_Return sRetval
28818>>>>>>>>>    End_Function
28819>>>>>>>>>
28819>>>>>>>>>    // Checks that the passed sDriverID is defined.
28819>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
28819>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
28821>>>>>>>>>        Boolean bOK
28821>>>>>>>>>        Integer iDriver
28821>>>>>>>>>
28821>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
28823>>>>>>>>>            Function_Return False
28824>>>>>>>>>        End
28824>>>>>>>>>>
28824>>>>>>>>>
28824>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
28825>>>>>>>>>
28825>>>>>>>>>        If (bOK = False) Begin
28827>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
28828>>>>>>>>>>
28828>>>>>>>>>            Function_Return False
28829>>>>>>>>>        End
28829>>>>>>>>>>
28829>>>>>>>>>
28829>>>>>>>>>        Get DriverIndex sDriverID to iDriver
28830>>>>>>>>>        If (iDriver = 0) Begin
28832>>>>>>>>>            Load_Driver sDriverID
28833>>>>>>>>>        End
28833>>>>>>>>>>
28833>>>>>>>>>
28833>>>>>>>>>        Function_Return True
28834>>>>>>>>>    End_Function
28835>>>>>>>>>
28835>>>>>>>>>    // Checks that the length parameter has been passed correctly.
28835>>>>>>>>>    // This is only of concern for certain SQL data types.
28835>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
28837>>>>>>>>>        Integer iLength
28837>>>>>>>>>        Boolean bOK bCheckTypeLength
28837>>>>>>>>>
28837>>>>>>>>>        If (num_arguments > 1) Begin
28839>>>>>>>>>            Move iLen to iLength
28840>>>>>>>>>        End
28840>>>>>>>>>>
28840>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
28841>>>>>>>>>
28841>>>>>>>>>        If (bCheckTypeLength = True) Begin
28843>>>>>>>>>            Move (iLength > 0) to bOK
28844>>>>>>>>>        End
28844>>>>>>>>>>
28844>>>>>>>>>
28844>>>>>>>>>        Function_Return (bOK = True)
28845>>>>>>>>>    End_Function
28846>>>>>>>>>
28846>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
28848>>>>>>>>>        String sVal sSchema sDriverID
28848>>>>>>>>>        Integer iDbType
28848>>>>>>>>>
28848>>>>>>>>>        If (Trim(sTableName) = "") Begin
28850>>>>>>>>>            Function_Return ""
28851>>>>>>>>>        End
28851>>>>>>>>>>
28851>>>>>>>>>
28851>>>>>>>>>        Get psDriverID to sDriverID
28852>>>>>>>>>        Get piDbType   to iDbType
28853>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
28855>>>>>>>>>            Get psUserID to sSchema
28856>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
28856>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
28857>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
28858>>>>>>>>>            Function_Return sTableName
28859>>>>>>>>>        End
28859>>>>>>>>>>
28859>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
28861>>>>>>>>>            Get psDatabase to sVal
28862>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
28863>>>>>>>>>            Function_Return sTableName
28864>>>>>>>>>        End
28864>>>>>>>>>>
28864>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
28866>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
28867>>>>>>>>>            Function_Return sTableName
28868>>>>>>>>>        End
28868>>>>>>>>>>
28868>>>>>>>>>
28868>>>>>>>>>        Get psSchema to sSchema
28869>>>>>>>>>        If (sSchema = "") Begin
28871>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
28872>>>>>>>>>        End
28872>>>>>>>>>>
28872>>>>>>>>>
28872>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
28873>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
28875>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
28877>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
28878>>>>>>>>>            End
28878>>>>>>>>>>
28878>>>>>>>>>            Else Begin
28879>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
28880>>>>>>>>>            End
28880>>>>>>>>>>
28880>>>>>>>>>        End
28880>>>>>>>>>>
28880>>>>>>>>>
28880>>>>>>>>>        Function_Return sTableName
28881>>>>>>>>>    End_Function
28882>>>>>>>>>
28882>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
28882>>>>>>>>>    // the passed sFieldName has the correct spelling.
28882>>>>>>>>>    // Used with Embedded SQL statement calls.
28882>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
28882>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
28884>>>>>>>>>        String sRetval sValue sDriverID
28884>>>>>>>>>        String[] sColumnNamesArray
28885>>>>>>>>>        Integer iCount iColumns
28885>>>>>>>>>
28885>>>>>>>>>        Move "" to sRetval
28886>>>>>>>>>        Get psDriverID to sDriverID
28887>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
28888>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
28889>>>>>>>>>        Decrement iColumns
28890>>>>>>>>>
28890>>>>>>>>>        For iCount from 0 to iColumns
28896>>>>>>>>>>
28896>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
28897>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
28899>>>>>>>>>                Move sValue to sRetval
28900>>>>>>>>>                Move iColumns to iCount // We're done.
28901>>>>>>>>>            End
28901>>>>>>>>>>
28901>>>>>>>>>        Loop
28902>>>>>>>>>>
28902>>>>>>>>>
28902>>>>>>>>>        Function_Return sRetval
28903>>>>>>>>>    End_Function
28904>>>>>>>>>
28904>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
28906>>>>>>>>>        String[] sReturnArray
28907>>>>>>>>>        Handle hoSQLHandler
28907>>>>>>>>>        Integer iCount iSize iItem
28907>>>>>>>>>        String sServer
28907>>>>>>>>>        tSQLConnection SQLConnection
28907>>>>>>>>>        tSQLConnection SQLConnection
28907>>>>>>>>>
28907>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
28908>>>>>>>>>        Send Delete_Data    of hoSQLHandler
28909>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
28910>>>>>>>>>
28910>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28911>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
28912>>>>>>>>>        Decrement iSize
28913>>>>>>>>>
28913>>>>>>>>>        For iCount from 0 to iSize
28919>>>>>>>>>>
28919>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
28920>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
28921>>>>>>>>>            Increment iItem
28922>>>>>>>>>        Loop
28923>>>>>>>>>>
28923>>>>>>>>>
28923>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28924>>>>>>>>>
28924>>>>>>>>>        Function_Return sReturnArray
28925>>>>>>>>>    End_Function
28926>>>>>>>>>
28926>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
28928>>>>>>>>>        String[] sReturnArray
28929>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
28929>>>>>>>>>        Handle hoSQLHandler
28929>>>>>>>>>        Integer iCount iSize iItem iPos
28929>>>>>>>>>        Boolean bOK
28929>>>>>>>>>        tSQLConnection SQLConnection
28929>>>>>>>>>        tSQLConnection SQLConnection
28929>>>>>>>>>
28929>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28930>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
28932>>>>>>>>>            Function_Return sReturnArray
28933>>>>>>>>>        End
28933>>>>>>>>>>
28933>>>>>>>>>
28933>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
28934>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
28935>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
28936>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
28937>>>>>>>>>
28937>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
28938>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
28939>>>>>>>>>        Send Delete_Data  of hoSQLHandler
28940>>>>>>>>>
28940>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28941>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
28942>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
28942>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
28942>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
28942>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
28942>>>>>>>>>//                If (iPos > 0) Begin
28942>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
28942>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
28942>>>>>>>>>//                End
28942>>>>>>>>>//            End
28942>>>>>>>>>//        End
28942>>>>>>>>>
28942>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
28943>>>>>>>>>        Move False to Err
28944>>>>>>>>>        Move 0 to iItem
28945>>>>>>>>>
28945>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
28945>>>>>>>>>        For iCount from 1 to iSize
28951>>>>>>>>>>
28951>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
28952>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
28953>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
28954>>>>>>>>>            If (sSchema = "") Begin
28956>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
28957>>>>>>>>>            End
28957>>>>>>>>>>
28957>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
28958>>>>>>>>>            Move (Trim(sTable)) to sTable
28959>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
28961>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
28962>>>>>>>>>            End
28962>>>>>>>>>>
28962>>>>>>>>>            Else Begin
28963>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
28964>>>>>>>>>            End
28964>>>>>>>>>>
28964>>>>>>>>>            If (bOK = True) Begin
28966>>>>>>>>>                Move sTable to sReturnArray[iItem]
28967>>>>>>>>>                Increment iItem
28968>>>>>>>>>            End
28968>>>>>>>>>>
28968>>>>>>>>>        Loop
28969>>>>>>>>>>
28969>>>>>>>>>
28969>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
28970>>>>>>>>>
28970>>>>>>>>>        Function_Return sReturnArray
28971>>>>>>>>>    End_Function
28972>>>>>>>>>
28972>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
28974>>>>>>>>>        String[] sReturnArray
28975>>>>>>>>>        String sValue
28975>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
28975>>>>>>>>>        Integer iRetval iCols iFetchResult
28975>>>>>>>>>        tSQLConnection SQLConnection
28975>>>>>>>>>        tSQLConnection SQLConnection
28975>>>>>>>>>
28975>>>>>>>>>        Get phoSQLManager to hoSQLHandler
28976>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
28977>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
28978>>>>>>>>>
28978>>>>>>>>>        If (hoSQLConnect <> 0) Begin
28980>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
28981>>>>>>>>>            If (hStmt <> 0) Begin
28983>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
28984>>>>>>>>>                If (sArgument <> "") Begin
28986>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
28987>>>>>>>>>                End
28987>>>>>>>>>>
28987>>>>>>>>>
28987>>>>>>>>>                Send SqlCall             of hStmt
28988>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
28989>>>>>>>>>                If (iRetval = 0) Begin
28991>>>>>>>>>                    Repeat
28991>>>>>>>>>>
28991>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
28992>>>>>>>>>                        If (iCols > 0) Begin
28994>>>>>>>>>                            Repeat
28994>>>>>>>>>>
28994>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
28995>>>>>>>>>                                If (iFetchResult <> 0) Begin
28997>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
28998>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
28999>>>>>>>>>                                End
28999>>>>>>>>>>
28999>>>>>>>>>                            Until (iFetchResult = 0)
29001>>>>>>>>>                        End
29001>>>>>>>>>>
29001>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
29002>>>>>>>>>                    Until (iRetval = 0)
29004>>>>>>>>>                    Send SqlClose of hStmt
29005>>>>>>>>>                End
29005>>>>>>>>>>
29005>>>>>>>>>            End
29005>>>>>>>>>>
29005>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
29006>>>>>>>>>        End
29006>>>>>>>>>>
29006>>>>>>>>>        Function_Return sReturnArray
29007>>>>>>>>>    End_Function
29008>>>>>>>>>
29008>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
29010>>>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
29010>>>>>>>>>        Boolean bOpened bOK
29010>>>>>>>>>
29010>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
29010>>>>>>>>>        // which makes the program unable to run because they can't be opened.
29010>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
29010>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
29010>>>>>>>>>        // proper .int files for the two tables.
29010>>>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
29012>>>>>>>>>            Function_Return True
29013>>>>>>>>>        End
29013>>>>>>>>>>
29013>>>>>>>>>
29013>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29016>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
29017>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
29018>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
29019>>>>>>>>>        Get AutoConnectionIDLogin to bOK
29020>>>>>>>>>
29020>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
29020>>>>>>>>>        Sleep 1
29021>>>>>>>>>
29021>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
29024>>>>>>>>>        If (bOpened = False) Begin
29026>>>>>>>>>            Open hTable
29028>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
29031>>>>>>>>>        End
29031>>>>>>>>>>
29031>>>>>>>>>        If (bOpened = False) Begin
29033>>>>>>>>>            Function_Return False
29034>>>>>>>>>        End
29034>>>>>>>>>>
29034>>>>>>>>>
29034>>>>>>>>>        Get psDriverID to sDriverID
29035>>>>>>>>>
29035>>>>>>>>>        Move False to Err
29036>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29039>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
29040>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
29040>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
29040>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
29041>>>>>>>>>
29041>>>>>>>>>        Move False to Err
29042>>>>>>>>>
29042>>>>>>>>>        If (hTable > 0) Begin
29044>>>>>>>>>            Structure_Start hTable
29045>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
29048>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29051>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
29053>>>>>>>>>        End
29053>>>>>>>>>>
29053>>>>>>>>>        Else Begin
29054>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
29057>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
29060>>>>>>>>>        End
29060>>>>>>>>>>
29060>>>>>>>>>        Function_Return (Err = False)
29061>>>>>>>>>    End_Function
29062>>>>>>>>>
29062>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
29062>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
29064>>>>>>>>>        Handle hTable
29064>>>>>>>>>        String sConnectionID
29064>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
29064>>>>>>>>>
29064>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
29065>>>>>>>>>        If (bSameTableNames = True) Begin
29067>>>>>>>>>            Function_Return True
29068>>>>>>>>>        End
29068>>>>>>>>>>
29068>>>>>>>>>
29068>>>>>>>>>        Move True to bOK
29069>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
29070>>>>>>>>>        Set Private.phCurrentTable              to hTable
29071>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
29074>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
29077>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
29080>>>>>>>>>
29080>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
29082>>>>>>>>>            Get psConnectionID to sConnectionID
29083>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
29084>>>>>>>>>            If (bTableExists = True) Begin
29086>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
29087>>>>>>>>>            End
29087>>>>>>>>>>
29087>>>>>>>>>            Else Begin
29088>>>>>>>>>                Get pbToANSI to bANSI
29089>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
29090>>>>>>>>>            End
29090>>>>>>>>>>
29090>>>>>>>>>        End
29090>>>>>>>>>>
29090>>>>>>>>>
29090>>>>>>>>>        Function_Return bOK
29091>>>>>>>>>    End_Function
29092>>>>>>>>>
29092>>>>>>>>>    // The table must already exist in the filelist for this function to work.
29092>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
29092>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
29094>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
29094>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
29094>>>>>>>>>        String[] sIndexArray
29095>>>>>>>>>        Integer iCount iCh iSize
29095>>>>>>>>>
29095>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
29096>>>>>>>>>        Get psConnectionString to sConnectionString
29097>>>>>>>>>
29097>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
29098>>>>>>>>>        If (bANSI = False) Begin
29100>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
29101>>>>>>>>>        End
29101>>>>>>>>>>
29101>>>>>>>>>
29101>>>>>>>>>        Get psDataPathFirstPart to sDataPath
29102>>>>>>>>>        Get vFolderExists sDataPath to bOK
29103>>>>>>>>>        If (bOK = False) Begin
29105>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
29106>>>>>>>>>>
29106>>>>>>>>>            Function_Return False
29107>>>>>>>>>        End
29107>>>>>>>>>>
29107>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29108>>>>>>>>>
29108>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
29111>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
29114>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
29115>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
29116>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
29117>>>>>>>>>
29117>>>>>>>>>        Get psSchema hTable to sSchemaName
29118>>>>>>>>>        If (sSchemaName = "") Begin
29120>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
29121>>>>>>>>>        End
29121>>>>>>>>>>
29121>>>>>>>>>
29121>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
29121>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
29122>>>>>>>>>        If (bExists = True) Begin
29124>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
29125>>>>>>>>>        End
29125>>>>>>>>>>
29125>>>>>>>>>
29125>>>>>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
29126>>>>>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
29127>>>>>>>>>
29127>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
29128>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
29133>>>>>>>>>            If (bUseConnectionID = True) Begin
29135>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
29142>>>>>>>>>            End
29142>>>>>>>>>>
29142>>>>>>>>>            Else Begin
29143>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
29150>>>>>>>>>            End
29150>>>>>>>>>>
29150>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
29155>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
29160>>>>>>>>>            // There seems to be a new order how these are set from DF19.
29160>>>>>>>>>            If (bSysFile = True) Begin
29162>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
29167>>>>>>>>>            End
29167>>>>>>>>>>
29167>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
29172>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
29177>>>>>>>>>            If (bSysFile = True) Begin
29179>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
29184>>>>>>>>>            End
29184>>>>>>>>>>
29184>>>>>>>>>
29184>>>>>>>>>            If (bSysFile = False) Begin
29186>>>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
29187>>>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
29188>>>>>>>>>                If (iSize > 0) Begin
29190>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
29193>>>>>>>>>                    Writeln channel iCh // Just an empty line
29195>>>>>>>>>                End
29195>>>>>>>>>>
29195>>>>>>>>>                Decrement iSize
29196>>>>>>>>>                for iCount from 0 to iSize
29202>>>>>>>>>>
29202>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
29205>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
29208>>>>>>>>>                    Writeln channel iCh
29210>>>>>>>>>                Loop
29211>>>>>>>>>>
29211>>>>>>>>>            End
29211>>>>>>>>>>
29211>>>>>>>>>        Send Seq_Close_Channel iCh
29212>>>>>>>>>
29212>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
29212>>>>>>>>>        Sleep 1
29213>>>>>>>>>
29213>>>>>>>>>        Function_Return (bOK = True)
29214>>>>>>>>>    End_Function
29215>>>>>>>>>
29215>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
29217>>>>>>>>>        String sDataPath sDriverID
29217>>>>>>>>>        Boolean bOK
29217>>>>>>>>>        Integer iPos
29217>>>>>>>>>
29217>>>>>>>>>        If (sTableName contains ".") Begin
29219>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
29220>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
29221>>>>>>>>>        End
29221>>>>>>>>>>
29221>>>>>>>>>
29221>>>>>>>>>        Get psDriverID to sDriverID
29222>>>>>>>>>        Get psDataPathFirstPart to sDataPath
29223>>>>>>>>>        // First delete the cache file:
29223>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
29224>>>>>>>>>
29224>>>>>>>>>        Function_Return bOK
29225>>>>>>>>>    End_Function
29226>>>>>>>>>
29226>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
29226>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
29226>>>>>>>>>    // if it is an SQL table
29226>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
29228>>>>>>>>>        Boolean bExists bIsSQLTable
29228>>>>>>>>>        String sDataPath sRootName
29228>>>>>>>>>
29228>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
29229>>>>>>>>>        If (bExists = False) Begin
29231>>>>>>>>>            Function_Return False
29232>>>>>>>>>        End
29232>>>>>>>>>>
29232>>>>>>>>>
29232>>>>>>>>>        Move False to bIsSQLTable
29233>>>>>>>>>        If (hTable > 0) Begin
29235>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
29238>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
29239>>>>>>>>>        End
29239>>>>>>>>>>
29239>>>>>>>>>        If (bIsSQLTable = True) Begin
29241>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
29242>>>>>>>>>            Function_Return bExists
29243>>>>>>>>>        End
29243>>>>>>>>>>
29243>>>>>>>>>        Else Begin
29244>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
29245>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
29246>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
29247>>>>>>>>>        End
29247>>>>>>>>>>
29247>>>>>>>>>
29247>>>>>>>>>        Function_Return bExists
29248>>>>>>>>>    End_Function
29249>>>>>>>>>
29249>>>>>>>>>    // Pass a table handle
29249>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
29249>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
29251>>>>>>>>>        Handle hTable
29251>>>>>>>>>        Boolean bFound
29251>>>>>>>>>
29251>>>>>>>>>        Move False to bFound
29252>>>>>>>>>        Move 0 to hTable
29253>>>>>>>>>        Repeat
29253>>>>>>>>>>
29253>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
29256>>>>>>>>>            If (hTable > 0) Begin
29258>>>>>>>>>                If (hTable = hCheckTable) Begin
29260>>>>>>>>>                    Move True to bFound
29261>>>>>>>>>                End
29261>>>>>>>>>>
29261>>>>>>>>>            End
29261>>>>>>>>>>
29261>>>>>>>>>            If (bFound = True) ;                Break
29264>>>>>>>>>        Until (hTable = 0)
29266>>>>>>>>>
29266>>>>>>>>>        Function_Return (bFound = True)
29267>>>>>>>>>    End_Function
29268>>>>>>>>>
29268>>>>>>>>>    // DataFlex Embedded Database Data Types:
29268>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
29268>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
29270>>>>>>>>>        tColumnType[] ColumnType
29270>>>>>>>>>        tColumnType[] ColumnType
29271>>>>>>>>>        Integer i
29271>>>>>>>>>
29271>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
29272>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
29273>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
29274>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
29275>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
29276>>>>>>>>>        Increment i
29277>>>>>>>>>
29277>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
29278>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
29279>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
29280>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
29281>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
29282>>>>>>>>>        Increment i
29283>>>>>>>>>
29283>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
29284>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
29285>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
29286>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
29287>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
29288>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
29289>>>>>>>>>        Increment i
29290>>>>>>>>>
29290>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
29291>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
29292>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
29293>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
29294>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
29295>>>>>>>>>        Increment i
29296>>>>>>>>>
29296>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
29297>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
29298>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
29299>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
29300>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
29301>>>>>>>>>        Increment i
29302>>>>>>>>>
29302>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
29303>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
29304>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
29305>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
29306>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
29307>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
29308>>>>>>>>>        Increment i
29309>>>>>>>>>
29309>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
29310>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
29311>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
29312>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
29313>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
29314>>>>>>>>>
29314>>>>>>>>>        Function_Return ColumnType
29315>>>>>>>>>    End_Function
29316>>>>>>>>>
29316>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
29318>>>>>>>>>        tColumnType[] aColumnType
29318>>>>>>>>>        tColumnType[] aColumnType
29319>>>>>>>>>        Integer i
29319>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
29319>>>>>>>>>>// Generated By The Database Update Framework
29319>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
29319>>>>>>>>>>// Driver COLUMN DATA TYPES
29319>>>>>>>>>>//
29319>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
29319>>>>>>>>>>
29319>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
29320>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
29321>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29322>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29323>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
29324>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29325>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29326>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29327>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29328>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29329>>>>>>>>>>            Increment i
29330>>>>>>>>>>
29330>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
29331>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
29332>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29333>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29334>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29335>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29336>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29337>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29338>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29339>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29340>>>>>>>>>>            Increment i
29341>>>>>>>>>>
29341>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
29342>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
29343>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29344>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29345>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29346>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29347>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29348>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29349>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29350>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29351>>>>>>>>>>            Increment i
29352>>>>>>>>>>
29352>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
29353>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
29354>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29355>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29356>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29357>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29358>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29359>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29360>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29361>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29362>>>>>>>>>>            Increment i
29363>>>>>>>>>>
29363>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
29364>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
29365>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29366>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29367>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29368>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29369>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29370>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29371>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29372>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29373>>>>>>>>>>            Increment i
29374>>>>>>>>>>
29374>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
29375>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
29376>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29377>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29378>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29379>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
29380>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
29381>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29382>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29383>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
29384>>>>>>>>>>            Increment i
29385>>>>>>>>>>
29385>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
29386>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
29387>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29388>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29389>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
29390>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
29391>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
29392>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29393>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29394>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
29395>>>>>>>>>>            Increment i
29396>>>>>>>>>>
29396>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
29397>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
29398>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29399>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29400>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
29401>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
29402>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
29403>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29404>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29405>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
29406>>>>>>>>>>            Increment i
29407>>>>>>>>>>
29407>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
29408>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
29409>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29410>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29411>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29412>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29413>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29414>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29415>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29416>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29417>>>>>>>>>>            Increment i
29418>>>>>>>>>>
29418>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
29419>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
29420>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29421>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29422>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
29423>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29424>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29425>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
29426>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
29427>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29428>>>>>>>>>>            Increment i
29429>>>>>>>>>>
29429>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
29430>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
29431>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29432>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29433>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29434>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29435>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29436>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29437>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29438>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29439>>>>>>>>>>            Increment i
29440>>>>>>>>>>
29440>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
29441>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
29442>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29443>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29444>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
29445>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29446>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
29447>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29448>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29449>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
29450>>>>>>>>>>            Increment i
29451>>>>>>>>>>
29451>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
29452>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
29453>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29454>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29455>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29456>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29457>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29458>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29459>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29460>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29461>>>>>>>>>>            Increment i
29462>>>>>>>>>>
29462>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
29463>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
29464>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29465>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29466>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29467>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29468>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
29469>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29470>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29471>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
29472>>>>>>>>>>            Increment i
29473>>>>>>>>>>
29473>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
29474>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
29475>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29476>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29477>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29478>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29479>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29480>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29481>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29482>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29483>>>>>>>>>>            Increment i
29484>>>>>>>>>>
29484>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
29485>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
29486>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29487>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29488>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29489>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29490>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29491>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
29492>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
29493>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
29494>>>>>>>>>>            Increment i
29495>>>>>>>>>>
29495>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
29496>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
29497>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29498>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29499>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29500>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29501>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
29502>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29503>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29504>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
29505>>>>>>>>>>            Increment i
29506>>>>>>>>>>
29506>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
29507>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
29508>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29509>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29510>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29511>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29512>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29513>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29514>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29515>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29516>>>>>>>>>>            Increment i
29517>>>>>>>>>>
29517>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
29518>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
29519>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29520>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29521>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
29522>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29523>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29524>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29525>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29526>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29527>>>>>>>>>>            Increment i
29528>>>>>>>>>>
29528>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
29529>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
29530>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29531>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29532>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29533>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29534>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29535>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29536>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29537>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29538>>>>>>>>>>            Increment i
29539>>>>>>>>>>
29539>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
29540>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
29541>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29542>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29543>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
29544>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29545>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
29546>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29547>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29548>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
29549>>>>>>>>>>            Increment i
29550>>>>>>>>>>
29550>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
29551>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
29552>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29553>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29554>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29555>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29556>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29557>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29558>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29559>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29560>>>>>>>>>>            Increment i
29561>>>>>>>>>>
29561>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
29562>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
29563>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29564>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29565>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29566>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29567>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29568>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29569>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29570>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29571>>>>>>>>>>            Increment i
29572>>>>>>>>>>
29572>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
29573>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
29574>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29575>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29576>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
29577>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
29578>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
29579>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29580>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29581>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
29582>>>>>>>>>>            Increment i
29583>>>>>>>>>>
29583>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
29584>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
29585>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29586>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29587>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
29588>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29589>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
29590>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29591>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29592>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
29593>>>>>>>>>>            Increment i
29594>>>>>>>>>>
29594>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
29595>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
29596>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29597>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29598>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29599>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29600>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29601>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29602>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29603>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29604>>>>>>>>>>            Increment i
29605>>>>>>>>>>
29605>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
29606>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
29607>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29608>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29609>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
29610>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29611>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29612>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29613>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29614>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29615>>>>>>>>>>            Increment i
29616>>>>>>>>>>
29616>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
29617>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
29618>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29619>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29620>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29621>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29622>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29623>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29624>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29625>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29626>>>>>>>>>>            Increment i
29627>>>>>>>>>>
29627>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
29628>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
29629>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29630>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29631>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29632>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29633>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29634>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29635>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29636>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29637>>>>>>>>>>            Increment i
29638>>>>>>>>>>
29638>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
29639>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
29640>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29641>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29642>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29643>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29644>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29645>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29646>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29647>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29648>>>>>>>>>>            Increment i
29649>>>>>>>>>>
29649>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
29650>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
29651>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29652>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29653>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29654>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29655>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29656>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29657>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29658>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29659>>>>>>>>>>            Increment i
29660>>>>>>>>>>
29660>>>>>>>>>>
29660>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        // ToDo: We need to change the sType when using this!
29660>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
29660>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
29660>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        // ToDo: We need to change the sType when using this!
29660>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
29660>>>>>>>>>//        Increment i
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
29660>>>>>>>>>//
29660>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
29660>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
29660>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
29660>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
29660>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
29660>>>>>>>>>
29660>>>>>>>>>        Function_Return aColumnType
29661>>>>>>>>>    End_Function
29662>>>>>>>>>
29662>>>>>>>>>    // Microsoft SQL Server Database Data Types:
29662>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
29662>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
29664>>>>>>>>>        tColumnType[] aColumnType
29664>>>>>>>>>        tColumnType[] aColumnType
29665>>>>>>>>>        Integer i
29665>>>>>>>>>
29665>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
29667>>>>>>>>>>// Generated By The Database Update Framework
29667>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
29667>>>>>>>>>>// Driver COLUMN DATA TYPES
29667>>>>>>>>>>//
29667>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
29667>>>>>>>>>>
29667>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
29668>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
29669>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29670>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29671>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
29672>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29673>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29674>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29675>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29676>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29677>>>>>>>>>>            Increment i
29678>>>>>>>>>>
29678>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
29679>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
29680>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29681>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29682>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29683>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29684>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29685>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
29686>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
29687>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29688>>>>>>>>>>            Increment i
29689>>>>>>>>>>
29689>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
29690>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
29691>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29692>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29693>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29694>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29695>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29696>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29697>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29698>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29699>>>>>>>>>>            Increment i
29700>>>>>>>>>>
29700>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
29701>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
29702>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29703>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29704>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29705>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29706>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29707>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29708>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29709>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29710>>>>>>>>>>            Increment i
29711>>>>>>>>>>
29711>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
29712>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
29713>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29714>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29715>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29716>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29717>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29718>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
29719>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
29720>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
29721>>>>>>>>>>            Increment i
29722>>>>>>>>>>
29722>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
29723>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
29724>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29725>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29726>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29727>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
29728>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
29729>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
29730>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
29731>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
29732>>>>>>>>>>            Increment i
29733>>>>>>>>>>
29733>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
29734>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
29735>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29736>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29737>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
29738>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
29739>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
29740>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
29741>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
29742>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
29743>>>>>>>>>>            Increment i
29744>>>>>>>>>>
29744>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
29745>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
29746>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29747>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29748>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
29749>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
29750>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
29751>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
29752>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
29753>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
29754>>>>>>>>>>            Increment i
29755>>>>>>>>>>
29755>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
29756>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
29757>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29758>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29759>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29760>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29761>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29762>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29763>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29764>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29765>>>>>>>>>>            Increment i
29766>>>>>>>>>>
29766>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
29767>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
29768>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29769>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29770>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
29771>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29772>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29773>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29774>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29775>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29776>>>>>>>>>>            Increment i
29777>>>>>>>>>>
29777>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
29778>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
29779>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29780>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29781>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29782>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29783>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29784>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
29785>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
29786>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29787>>>>>>>>>>            Increment i
29788>>>>>>>>>>
29788>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
29789>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
29790>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29791>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29792>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
29793>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29794>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
29795>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29796>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29797>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
29798>>>>>>>>>>            Increment i
29799>>>>>>>>>>
29799>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
29800>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
29801>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29802>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29803>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29804>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29805>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29806>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29807>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29808>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29809>>>>>>>>>>            Increment i
29810>>>>>>>>>>
29810>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
29811>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
29812>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29813>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29814>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29815>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29816>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
29817>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29818>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29819>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
29820>>>>>>>>>>            Increment i
29821>>>>>>>>>>
29821>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
29822>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
29823>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29824>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29825>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29826>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29827>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29828>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
29829>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
29830>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29831>>>>>>>>>>            Increment i
29832>>>>>>>>>>
29832>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
29833>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
29834>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29835>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29836>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29837>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29838>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29839>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29840>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29841>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29842>>>>>>>>>>            Increment i
29843>>>>>>>>>>
29843>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
29844>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
29845>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29846>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29847>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29848>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29849>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
29850>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29851>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29852>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
29853>>>>>>>>>>            Increment i
29854>>>>>>>>>>
29854>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
29855>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
29856>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29857>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29858>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29859>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29860>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29861>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29862>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29863>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29864>>>>>>>>>>            Increment i
29865>>>>>>>>>>
29865>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
29866>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
29867>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29868>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29869>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
29870>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29871>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
29872>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29873>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29874>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
29875>>>>>>>>>>            Increment i
29876>>>>>>>>>>
29876>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
29877>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
29878>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29879>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29880>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29881>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29882>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29883>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
29884>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
29885>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29886>>>>>>>>>>            Increment i
29887>>>>>>>>>>
29887>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
29888>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
29889>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29890>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29891>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
29892>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29893>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
29894>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29895>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29896>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
29897>>>>>>>>>>            Increment i
29898>>>>>>>>>>
29898>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
29899>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
29900>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29901>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29902>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29903>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29904>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29905>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29906>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29907>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29908>>>>>>>>>>            Increment i
29909>>>>>>>>>>
29909>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
29910>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
29911>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29912>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29913>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29914>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29915>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29916>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
29917>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
29918>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29919>>>>>>>>>>            Increment i
29920>>>>>>>>>>
29920>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
29921>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
29922>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29923>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29924>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
29925>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
29926>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
29927>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29928>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29929>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
29930>>>>>>>>>>            Increment i
29931>>>>>>>>>>
29931>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
29932>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
29933>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29934>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29935>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
29936>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29937>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
29938>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
29939>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
29940>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
29941>>>>>>>>>>            Increment i
29942>>>>>>>>>>
29942>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
29943>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
29944>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
29945>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29946>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
29947>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
29948>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
29949>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29950>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29951>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
29952>>>>>>>>>>            Increment i
29953>>>>>>>>>>
29953>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
29954>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
29955>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29956>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29957>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
29958>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29959>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29960>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
29961>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
29962>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29963>>>>>>>>>>            Increment i
29964>>>>>>>>>>
29964>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
29965>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
29966>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29967>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29968>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29969>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29970>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29971>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29972>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29973>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29974>>>>>>>>>>            Increment i
29975>>>>>>>>>>
29975>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
29976>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
29977>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29978>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29979>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
29980>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29981>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
29982>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
29983>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
29984>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
29985>>>>>>>>>>            Increment i
29986>>>>>>>>>>
29986>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
29987>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
29988>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
29989>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
29990>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
29991>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
29992>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
29993>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
29994>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
29995>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
29996>>>>>>>>>>            Increment i
29997>>>>>>>>>>
29997>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
29998>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
29999>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30000>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30001>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
30002>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30003>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
30004>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
30005>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
30006>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
30007>>>>>>>>>>            Increment i
30008>>>>>>>>>>
30008>>>>>>>>>>
30008>>>>>>>>>
30008>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>//
30008>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
30008>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
30008>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
30008>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
30008>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
30008>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
30008>>>>>>>>>//            Increment i
30008>>>>>>>>>
30008>>>>>>>>>        End
30008>>>>>>>>>>
30008>>>>>>>>>
30008>>>>>>>>>        Function_Return aColumnType
30009>>>>>>>>>    End_Function
30010>>>>>>>>>
30010>>>>>>>>>    // MySQL Data Types
30010>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
30012>>>>>>>>>        tColumnType[] aColumnType
30012>>>>>>>>>        tColumnType[] aColumnType
30013>>>>>>>>>        Integer i
30013>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
30013>>>>>>>>>>// Generated By The Database Update Framework
30013>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
30013>>>>>>>>>>// Driver COLUMN DATA TYPES
30013>>>>>>>>>>//
30013>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
30013>>>>>>>>>>
30013>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
30014>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
30015>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30016>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30017>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30018>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30019>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30020>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30021>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30022>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30023>>>>>>>>>>            Increment i
30024>>>>>>>>>>
30024>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
30025>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
30026>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30027>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30028>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
30029>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30030>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
30031>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30032>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30033>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
30034>>>>>>>>>>            Increment i
30035>>>>>>>>>>
30035>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
30036>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
30037>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30038>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30039>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30040>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30041>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30042>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30043>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30044>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30045>>>>>>>>>>            Increment i
30046>>>>>>>>>>
30046>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
30047>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
30048>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30049>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30050>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30051>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30052>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
30053>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30054>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30055>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
30056>>>>>>>>>>            Increment i
30057>>>>>>>>>>
30057>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
30058>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
30059>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30060>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30061>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
30062>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30063>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30064>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
30065>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
30066>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
30067>>>>>>>>>>            Increment i
30068>>>>>>>>>>
30068>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
30069>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
30070>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30071>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30072>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30073>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
30074>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
30075>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30076>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30077>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
30078>>>>>>>>>>            Increment i
30079>>>>>>>>>>
30079>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
30080>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
30081>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30082>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30083>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30084>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30085>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30086>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30087>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30088>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30089>>>>>>>>>>            Increment i
30090>>>>>>>>>>
30090>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
30091>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
30092>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30093>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30094>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30095>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30096>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30097>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30098>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30099>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30100>>>>>>>>>>            Increment i
30101>>>>>>>>>>
30101>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
30102>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
30103>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30104>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30105>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30106>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30107>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30108>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30109>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30110>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30111>>>>>>>>>>            Increment i
30112>>>>>>>>>>
30112>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
30113>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
30114>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30115>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30116>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
30117>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30118>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
30119>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30120>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30121>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
30122>>>>>>>>>>            Increment i
30123>>>>>>>>>>
30123>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
30124>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
30125>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30126>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30127>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
30128>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30129>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30130>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30131>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30132>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30133>>>>>>>>>>            Increment i
30134>>>>>>>>>>
30134>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
30135>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
30136>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30137>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30138>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
30139>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30140>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
30141>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30142>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30143>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
30144>>>>>>>>>>            Increment i
30145>>>>>>>>>>
30145>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
30146>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
30147>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30148>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30149>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30150>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30151>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30152>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30153>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30154>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30155>>>>>>>>>>            Increment i
30156>>>>>>>>>>
30156>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
30157>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
30158>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30159>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30160>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30161>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30162>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30163>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
30164>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
30165>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30166>>>>>>>>>>            Increment i
30167>>>>>>>>>>
30167>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
30168>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
30169>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30170>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30171>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30172>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30173>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30174>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30175>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30176>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30177>>>>>>>>>>            Increment i
30178>>>>>>>>>>
30178>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
30179>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
30180>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30181>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30182>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
30183>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30184>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
30185>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30186>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30187>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
30188>>>>>>>>>>            Increment i
30189>>>>>>>>>>
30189>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
30190>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
30191>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30192>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30193>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30194>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30195>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30196>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
30197>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
30198>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30199>>>>>>>>>>            Increment i
30200>>>>>>>>>>
30200>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
30201>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
30202>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30203>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30204>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
30205>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30206>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
30207>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30208>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30209>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
30210>>>>>>>>>>            Increment i
30211>>>>>>>>>>
30211>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
30212>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
30213>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30214>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30215>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
30216>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30217>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
30218>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30219>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30220>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
30221>>>>>>>>>>            Increment i
30222>>>>>>>>>>
30222>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
30223>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
30224>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30225>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30226>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30227>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30228>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30229>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
30230>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
30231>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30232>>>>>>>>>>            Increment i
30233>>>>>>>>>>
30233>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
30234>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
30235>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30236>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30237>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
30238>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30239>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30240>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30241>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30242>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30243>>>>>>>>>>            Increment i
30244>>>>>>>>>>
30244>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
30245>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
30246>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30247>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30248>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
30249>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
30250>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
30251>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30252>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30253>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
30254>>>>>>>>>>            Increment i
30255>>>>>>>>>>
30255>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
30256>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
30257>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30258>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30259>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
30260>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30261>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
30262>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30263>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30264>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
30265>>>>>>>>>>            Increment i
30266>>>>>>>>>>
30266>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
30267>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
30268>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30269>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30270>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
30271>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30272>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
30273>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30274>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30275>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
30276>>>>>>>>>>            Increment i
30277>>>>>>>>>>
30277>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
30278>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
30279>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30280>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30281>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
30282>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30283>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
30284>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30285>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30286>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
30287>>>>>>>>>>            Increment i
30288>>>>>>>>>>
30288>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
30289>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
30290>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30291>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30292>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
30293>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30294>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30295>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30296>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30297>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30298>>>>>>>>>>            Increment i
30299>>>>>>>>>>
30299>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
30300>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
30301>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30302>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30303>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
30304>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30305>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30306>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30307>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30308>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30309>>>>>>>>>>            Increment i
30310>>>>>>>>>>
30310>>>>>>>>>>
30310>>>>>>>>>
30310>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
30310>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
30310>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>//
30310>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
30310>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
30310>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30310>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
30310>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
30310>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30310>>>>>>>>>//        Increment i
30310>>>>>>>>>
30310>>>>>>>>>        Function_Return aColumnType
30311>>>>>>>>>    End_Function
30312>>>>>>>>>
30312>>>>>>>>>    // Oracle Data Types
30312>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
30314>>>>>>>>>        tColumnType[] aColumnType
30314>>>>>>>>>        tColumnType[] aColumnType
30315>>>>>>>>>        Integer i
30315>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
30315>>>>>>>>>>// Generated By The Database Update Framework
30315>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
30315>>>>>>>>>>// Driver COLUMN DATA TYPES
30315>>>>>>>>>>//
30315>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
30315>>>>>>>>>>
30315>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
30316>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
30317>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30318>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30319>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30320>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30321>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30322>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30323>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30324>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30325>>>>>>>>>>            Increment i
30326>>>>>>>>>>
30326>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
30327>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
30328>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30329>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30330>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30331>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30332>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
30333>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30334>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30335>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
30336>>>>>>>>>>            Increment i
30337>>>>>>>>>>
30337>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
30338>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
30339>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30340>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30341>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30342>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30343>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30344>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
30345>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
30346>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30347>>>>>>>>>>            Increment i
30348>>>>>>>>>>
30348>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
30349>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
30350>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30351>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30352>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
30353>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
30354>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
30355>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
30356>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
30357>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
30358>>>>>>>>>>            Increment i
30359>>>>>>>>>>
30359>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
30360>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
30361>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30362>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30363>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30364>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30365>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30366>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30367>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30368>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30369>>>>>>>>>>            Increment i
30370>>>>>>>>>>
30370>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
30371>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
30372>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30373>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30374>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30375>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30376>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30377>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30378>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30379>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30380>>>>>>>>>>            Increment i
30381>>>>>>>>>>
30381>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
30382>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
30383>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30384>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30385>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30386>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30387>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30388>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30389>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30390>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30391>>>>>>>>>>            Increment i
30392>>>>>>>>>>
30392>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
30393>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
30394>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30395>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30396>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30397>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30398>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30399>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30400>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30401>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30402>>>>>>>>>>            Increment i
30403>>>>>>>>>>
30403>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
30404>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
30405>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30406>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30407>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30408>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30409>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30410>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30411>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30412>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30413>>>>>>>>>>            Increment i
30414>>>>>>>>>>
30414>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
30415>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
30416>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30417>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30418>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30419>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30420>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30421>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30422>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30423>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30424>>>>>>>>>>            Increment i
30425>>>>>>>>>>
30425>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
30426>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
30427>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30428>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30429>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30430>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30431>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
30432>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30433>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30434>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
30435>>>>>>>>>>            Increment i
30436>>>>>>>>>>
30436>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
30437>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
30438>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30439>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30440>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
30441>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30442>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30443>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
30444>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
30445>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30446>>>>>>>>>>            Increment i
30447>>>>>>>>>>
30447>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
30448>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
30449>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30450>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30451>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30452>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30453>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30454>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30455>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30456>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30457>>>>>>>>>>            Increment i
30458>>>>>>>>>>
30458>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
30459>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
30460>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30461>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30462>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30463>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30464>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
30465>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30466>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30467>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
30468>>>>>>>>>>            Increment i
30469>>>>>>>>>>
30469>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
30470>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
30471>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30472>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30473>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30474>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30475>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
30476>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30477>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30478>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
30479>>>>>>>>>>            Increment i
30480>>>>>>>>>>
30480>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
30481>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
30482>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30483>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30484>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30485>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30486>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30487>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30488>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30489>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30490>>>>>>>>>>            Increment i
30491>>>>>>>>>>
30491>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
30492>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
30493>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30494>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30495>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30496>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30497>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30498>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30499>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30500>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30501>>>>>>>>>>            Increment i
30502>>>>>>>>>>
30502>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
30503>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
30504>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30505>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30506>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30507>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30508>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30509>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30510>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30511>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30512>>>>>>>>>>            Increment i
30513>>>>>>>>>>
30513>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
30514>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
30515>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30516>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30517>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30518>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30519>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
30520>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30521>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30522>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
30523>>>>>>>>>>            Increment i
30524>>>>>>>>>>
30524>>>>>>>>>>
30524>>>>>>>>>
30524>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
30524>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
30524>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
30524>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
30524>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
30524>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
30524>>>>>>>>>//        Increment i
30524>>>>>>>>>//
30524>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
30524>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
30524>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30524>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30524>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30524>>>>>>>>>
30524>>>>>>>>>        Function_Return aColumnType
30525>>>>>>>>>    End_Function
30526>>>>>>>>>
30526>>>>>>>>>    // PostgreSQL Data Types
30526>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
30528>>>>>>>>>        tColumnType[] aColumnType
30528>>>>>>>>>        tColumnType[] aColumnType
30529>>>>>>>>>        Integer i
30529>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
30529>>>>>>>>>>// Generated By The Database Update Framework
30529>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
30529>>>>>>>>>>// Driver COLUMN DATA TYPES
30529>>>>>>>>>>//
30529>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
30529>>>>>>>>>>
30529>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
30530>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
30531>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30532>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30533>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30534>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30535>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30536>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30537>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30538>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30539>>>>>>>>>>            Increment i
30540>>>>>>>>>>
30540>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
30541>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
30542>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30543>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30544>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30545>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30546>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30547>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30548>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30549>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30550>>>>>>>>>>            Increment i
30551>>>>>>>>>>
30551>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
30552>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
30553>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30554>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30555>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30556>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30557>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30558>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30559>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30560>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30561>>>>>>>>>>            Increment i
30562>>>>>>>>>>
30562>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
30563>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
30564>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30565>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30566>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30567>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30568>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30569>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30570>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30571>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30572>>>>>>>>>>            Increment i
30573>>>>>>>>>>
30573>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
30574>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
30575>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30576>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30577>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30578>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30579>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30580>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30581>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30582>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30583>>>>>>>>>>            Increment i
30584>>>>>>>>>>
30584>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
30585>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
30586>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30587>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30588>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30589>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30590>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30591>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30592>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30593>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30594>>>>>>>>>>            Increment i
30595>>>>>>>>>>
30595>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
30596>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
30597>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30598>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30599>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
30600>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30601>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30602>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
30603>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
30604>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
30605>>>>>>>>>>            Increment i
30606>>>>>>>>>>
30606>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
30607>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
30608>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30609>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30610>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30611>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30612>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30613>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30614>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30615>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30616>>>>>>>>>>            Increment i
30617>>>>>>>>>>
30617>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
30618>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
30619>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30620>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30621>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
30622>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30623>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
30624>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30625>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30626>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
30627>>>>>>>>>>            Increment i
30628>>>>>>>>>>
30628>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
30629>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
30630>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30631>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30632>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
30633>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30634>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
30635>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30636>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30637>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
30638>>>>>>>>>>            Increment i
30639>>>>>>>>>>
30639>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
30640>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
30641>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30642>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30643>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
30644>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30645>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
30646>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30647>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30648>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
30649>>>>>>>>>>            Increment i
30650>>>>>>>>>>
30650>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
30651>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
30652>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30653>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30654>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
30655>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30656>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30657>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
30658>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
30659>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30660>>>>>>>>>>            Increment i
30661>>>>>>>>>>
30661>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
30662>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
30663>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30664>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30665>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
30666>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30667>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
30668>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30669>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30670>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
30671>>>>>>>>>>            Increment i
30672>>>>>>>>>>
30672>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
30673>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
30674>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30675>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30676>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
30677>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30678>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30679>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30680>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30681>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30682>>>>>>>>>>            Increment i
30683>>>>>>>>>>
30683>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
30684>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
30685>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30686>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30687>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
30688>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30689>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
30690>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
30691>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
30692>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
30693>>>>>>>>>>            Increment i
30694>>>>>>>>>>
30694>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
30695>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
30696>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30697>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30698>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30699>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30700>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30701>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30702>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30703>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30704>>>>>>>>>>            Increment i
30705>>>>>>>>>>
30705>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
30706>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
30707>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30708>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30709>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
30710>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
30711>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
30712>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30713>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30714>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
30715>>>>>>>>>>            Increment i
30716>>>>>>>>>>
30716>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
30717>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
30718>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30719>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30720>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30721>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30722>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30723>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
30724>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
30725>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30726>>>>>>>>>>            Increment i
30727>>>>>>>>>>
30727>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
30728>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
30729>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30730>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30731>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
30732>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30733>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30734>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30735>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30736>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30737>>>>>>>>>>            Increment i
30738>>>>>>>>>>
30738>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
30739>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
30740>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
30741>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30742>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
30743>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
30744>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
30745>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30746>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30747>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
30748>>>>>>>>>>            Increment i
30749>>>>>>>>>>
30749>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
30750>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
30751>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30752>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30753>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30754>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30755>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30756>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30757>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30758>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30759>>>>>>>>>>            Increment i
30760>>>>>>>>>>
30760>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
30761>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
30762>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
30763>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
30764>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
30765>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
30766>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
30767>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
30768>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
30769>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
30770>>>>>>>>>>            Increment i
30771>>>>>>>>>>
30771>>>>>>>>>>
30771>>>>>>>>>
30771>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
30771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
30771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
30771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
30771>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>//
30771>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
30771>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
30771>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
30771>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
30771>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
30771>>>>>>>>>//        Increment i
30771>>>>>>>>>
30771>>>>>>>>>        Function_Return aColumnType
30772>>>>>>>>>    End_Function
30773>>>>>>>>>
30773>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
30773>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
30775>>>>>>>>>        Integer iValue iSize iCount iStart
30775>>>>>>>>>        tColumnType[] ColumnTypeArray
30775>>>>>>>>>        tColumnType[] ColumnTypeArray
30776>>>>>>>>>        tColumnType RetvalType
30776>>>>>>>>>        tColumnType RetvalType
30776>>>>>>>>>        String sValue
30776>>>>>>>>>        Boolean bFrameworkDataFlexType
30776>>>>>>>>>
30776>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
30777>>>>>>>>>        Move -1999       to RetvalType.iSQLType
30778>>>>>>>>>
30778>>>>>>>>>        Move 0 to iStart
30779>>>>>>>>>        Move (Uppercase(sType)) to sType
30780>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
30781>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
30783>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
30784>>>>>>>>>            Function_Return RetvalType
30785>>>>>>>>>        End
30785>>>>>>>>>>
30785>>>>>>>>>
30785>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
30786>>>>>>>>>
30786>>>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
30787>>>>>>>>>        Decrement iSize
30788>>>>>>>>>
30788>>>>>>>>>        For iCount from iStart to iSize
30794>>>>>>>>>>
30794>>>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
30795>>>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
30796>>>>>>>>>            If (bIntegerInputType = True) Begin
30798>>>>>>>>>                If (iValue = iType) Begin
30800>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
30801>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
30802>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
30803>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
30804>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
30805>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
30806>>>>>>>>>                    Move iSize to iCount // We're done!
30807>>>>>>>>>                End
30807>>>>>>>>>>
30807>>>>>>>>>            End
30807>>>>>>>>>>
30807>>>>>>>>>            Else Begin
30808>>>>>>>>>                Move (Uppercase(sValue)) to sValue
30809>>>>>>>>>                If (sValue = sType) Begin
30811>>>>>>>>>                    Move sType                                  to RetvalType.sSQLType
30812>>>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
30813>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
30814>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
30815>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
30816>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
30817>>>>>>>>>                    Move iSize to iCount // We're done!
30818>>>>>>>>>                End
30818>>>>>>>>>>
30818>>>>>>>>>            End
30818>>>>>>>>>>
30818>>>>>>>>>        Loop
30819>>>>>>>>>>
30819>>>>>>>>>
30819>>>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
30819>>>>>>>>>        // In which case we search for a match in DataFlex standard types:
30819>>>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
30821>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
30822>>>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
30823>>>>>>>>>            Decrement iSize
30824>>>>>>>>>
30824>>>>>>>>>            For iCount from iStart to iSize
30830>>>>>>>>>>
30830>>>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
30831>>>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
30832>>>>>>>>>                If (iValue = iType) Begin
30834>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
30835>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
30836>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
30837>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
30838>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
30839>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
30840>>>>>>>>>                    Move iSize to iCount // We're done!
30841>>>>>>>>>                End
30841>>>>>>>>>>
30841>>>>>>>>>            Loop
30842>>>>>>>>>>
30842>>>>>>>>>        End
30842>>>>>>>>>>
30842>>>>>>>>>
30842>>>>>>>>>        Function_Return RetvalType
30843>>>>>>>>>    End_Function
30844>>>>>>>>>
30844>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
30844>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
30846>>>>>>>>>        tColumnType[] ColumnType
30846>>>>>>>>>        tColumnType[] ColumnType
30847>>>>>>>>>
30847>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
30847>>>>>>>>>        // the dbType.
30847>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30849>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
30851>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
30852>>>>>>>>>            End
30852>>>>>>>>>>
30852>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
30854>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
30855>>>>>>>>>            End
30855>>>>>>>>>>
30855>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
30857>>>>>>>>>                Move DB2_DRV_ID to sDriverID
30858>>>>>>>>>            End
30858>>>>>>>>>>
30858>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
30860>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
30861>>>>>>>>>            End
30861>>>>>>>>>>
30861>>>>>>>>>        End
30861>>>>>>>>>>
30861>>>>>>>>>
30861>>>>>>>>>        Case Begin
30861>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
30863>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
30864>>>>>>>>>                Case Break
30865>>>>>>>>>
30865>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
30868>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
30869>>>>>>>>>                Case Break
30870>>>>>>>>>
30870>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
30873>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
30874>>>>>>>>>                Case Break
30875>>>>>>>>>        Case End
30875>>>>>>>>>
30875>>>>>>>>>        Function_Return ColumnType
30876>>>>>>>>>    End_Function
30877>>>>>>>>>
30877>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
30877>>>>>>>>>    // are mapped to a DUF data type.
30877>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
30879>>>>>>>>>        tColumnType ColumnType
30879>>>>>>>>>        tColumnType ColumnType
30879>>>>>>>>>        String sDataType
30879>>>>>>>>>        Integer iDriverID iCount
30879>>>>>>>>>
30879>>>>>>>>>        Move 0 to iCount
30880>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
30881>>>>>>>>>
30881>>>>>>>>>        Case Begin
30881>>>>>>>>>            // DF_ASCII
30881>>>>>>>>>            Case (iType = DF_ASCII_DUF)
30883>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30885>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
30888>>>>>>>>>                End
30888>>>>>>>>>>
30888>>>>>>>>>                Else Begin
30889>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
30892>>>>>>>>>                End
30892>>>>>>>>>>
30892>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
30893>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
30894>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
30895>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
30896>>>>>>>>>                Move False       to ColumnType.bCanEditSize
30897>>>>>>>>>                Case Break
30898>>>>>>>>>
30898>>>>>>>>>            // DF_BINARY
30898>>>>>>>>>            Case (iType = DF_BINARY_DUF)
30901>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30903>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
30906>>>>>>>>>                End
30906>>>>>>>>>>
30906>>>>>>>>>                Else Begin
30907>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
30910>>>>>>>>>                End
30910>>>>>>>>>>
30910>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
30911>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
30912>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
30913>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
30914>>>>>>>>>                Move False       to ColumnType.bCanEditSize
30915>>>>>>>>>                Case Break
30916>>>>>>>>>
30916>>>>>>>>>            // DF_DATE
30916>>>>>>>>>            Case (iType = DF_DATE_DUF)
30919>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30921>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
30924>>>>>>>>>                End
30924>>>>>>>>>>
30924>>>>>>>>>                Else Begin
30925>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
30928>>>>>>>>>                End
30928>>>>>>>>>>
30928>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
30929>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
30930>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
30931>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
30932>>>>>>>>>                Move True        to ColumnType.bCanEditSize
30933>>>>>>>>>                Case Break
30934>>>>>>>>>
30934>>>>>>>>>            // DF_DATETIME
30934>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
30937>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30939>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
30942>>>>>>>>>                End
30942>>>>>>>>>>
30942>>>>>>>>>                Else Begin
30943>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
30946>>>>>>>>>                End
30946>>>>>>>>>>
30946>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
30947>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
30948>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
30949>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
30950>>>>>>>>>                Move True        to ColumnType.bCanEditSize
30951>>>>>>>>>                Case Break
30952>>>>>>>>>
30952>>>>>>>>>            // DF_NUMERIC
30952>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
30952>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
30952>>>>>>>>>            // we make them here all "Numeric"...
30952>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
30952>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
30952>>>>>>>>>            // End
30952>>>>>>>>>            // Else Begin
30952>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
30952>>>>>>>>>            // End
30952>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
30952>>>>>>>>>            Case (iType = DF_BCD_DUF)
30955>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
30956>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
30957>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
30958>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
30959>>>>>>>>>                Move False       to ColumnType.bCanEditSize
30960>>>>>>>>>                Case Break
30961>>>>>>>>>
30961>>>>>>>>>            // DF_TEXT
30961>>>>>>>>>            Case (iType = DF_TEXT_DUF)
30964>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30966>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
30969>>>>>>>>>                End
30969>>>>>>>>>>
30969>>>>>>>>>                Else Begin
30970>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
30973>>>>>>>>>                End
30973>>>>>>>>>>
30973>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
30974>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
30975>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
30976>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
30977>>>>>>>>>                Move False       to ColumnType.bCanEditSize
30978>>>>>>>>>                Case Break
30979>>>>>>>>>
30979>>>>>>>>>            Case Else
30979>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
30980>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
30981>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
30982>>>>>>>>>                Move -1999       to ColumnType.iSQLType
30983>>>>>>>>>                Move True        to ColumnType.bCanEditSize
30984>>>>>>>>>
30984>>>>>>>>>        Case End
30984>>>>>>>>>
30984>>>>>>>>>        Function_Return ColumnType
30985>>>>>>>>>    End_Function
30986>>>>>>>>>
30986>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
30988>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
30990>>>>>>>>>        Handle hTable
30990>>>>>>>>>        Integer iIndex
30990>>>>>>>>>        String sTableName
30990>>>>>>>>>        Boolean bFlexErrs
30990>>>>>>>>>
30990>>>>>>>>>        // a) Get the exception table array the developer has specified
30990>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
30991>>>>>>>>>
30991>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
30991>>>>>>>>>        Repeat
30991>>>>>>>>>>
30991>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30994>>>>>>>>>            If (hTable <> 0) Begin
30996>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
30999>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
31000>>>>>>>>>                If (bFlexErrs = False) Begin
31002>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
31004>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
31005>>>>>>>>>                        If (iIndex = -1) Begin
31007>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
31008>>>>>>>>>                        End
31008>>>>>>>>>>
31008>>>>>>>>>                    End
31008>>>>>>>>>>
31008>>>>>>>>>                End
31008>>>>>>>>>>
31008>>>>>>>>>            End
31008>>>>>>>>>>
31008>>>>>>>>>        Until (hTable = 0)
31010>>>>>>>>>
31010>>>>>>>>>        Move 0 to hTable
31011>>>>>>>>>
31011>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
31011>>>>>>>>>        Repeat
31011>>>>>>>>>>
31011>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
31014>>>>>>>>>            If (hTable > 0) Begin
31016>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
31019>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
31020>>>>>>>>>                If (bFlexErrs = False) Begin
31022>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
31023>>>>>>>>>                    If (iIndex = -1) Begin
31025>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
31026>>>>>>>>>                    End
31026>>>>>>>>>>
31026>>>>>>>>>                End
31026>>>>>>>>>>
31026>>>>>>>>>            End
31026>>>>>>>>>>
31026>>>>>>>>>        Until (hTable = 0)
31028>>>>>>>>>
31028>>>>>>>>>        Function_Return iTablesArray
31029>>>>>>>>>    End_Function
31030>>>>>>>>>
31030>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
31032>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
31034>>>>>>>>>        Handle hTable
31034>>>>>>>>>        Integer iIndex
31034>>>>>>>>>        String sTableName
31034>>>>>>>>>        Boolean bFlexErrs
31034>>>>>>>>>
31034>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
31035>>>>>>>>>        Move 0 to hTable
31036>>>>>>>>>
31036>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
31036>>>>>>>>>        Repeat
31036>>>>>>>>>>
31036>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
31039>>>>>>>>>            If (hTable > 0) Begin
31041>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
31044>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
31045>>>>>>>>>                If (bFlexErrs = False) Begin
31047>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
31048>>>>>>>>>                    If (iIndex = -1) Begin
31050>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
31051>>>>>>>>>                    End
31051>>>>>>>>>>
31051>>>>>>>>>                End
31051>>>>>>>>>>
31051>>>>>>>>>            End
31051>>>>>>>>>>
31051>>>>>>>>>        Until (hTable = 0)
31053>>>>>>>>>
31053>>>>>>>>>        Function_Return iTablesArray
31054>>>>>>>>>    End_Function
31055>>>>>>>>>
31055>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
31057>>>>>>>>>        tAPIColumn NewAPIColumn
31057>>>>>>>>>        tAPIColumn NewAPIColumn
31057>>>>>>>>>
31057>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
31058>>>>>>>>>        Move iType      to NewAPIColumn.iType
31059>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
31060>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
31061>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
31062>>>>>>>>>
31062>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
31063>>>>>>>>>
31063>>>>>>>>>        Function_Return aCurrent
31064>>>>>>>>>    End_Function
31065>>>>>>>>>
31065>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
31067>>>>>>>>>        String sRetval sFieldName
31067>>>>>>>>>        Integer iCount iSize
31067>>>>>>>>>
31067>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
31068>>>>>>>>>        Decrement iSize
31069>>>>>>>>>        For iCount from 0 to iSize
31075>>>>>>>>>>
31075>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
31076>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
31077>>>>>>>>>        Loop
31078>>>>>>>>>>
31078>>>>>>>>>        Move (Trim(sRetval)) to sRetval
31079>>>>>>>>>
31079>>>>>>>>>        Function_Return sRetval
31080>>>>>>>>>    End_Function
31081>>>>>>>>>
31081>>>>>>>>>    // *** Miscellaneous other functions ***
31081>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
31081>>>>>>>>>    //
31081>>>>>>>>>
31081>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
31081>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
31083>>>>>>>>>        Integer iPerc
31083>>>>>>>>>        Number nReady nTotal
31083>>>>>>>>>
31083>>>>>>>>>        Send DoAdvance of ghoProgressBar
31084>>>>>>>>>
31084>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
31086>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
31087>>>>>>>>>        End
31087>>>>>>>>>>
31087>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
31089>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
31090>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
31091>>>>>>>>>        End
31091>>>>>>>>>>
31091>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
31093>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
31094>>>>>>>>>        End
31094>>>>>>>>>>
31094>>>>>>>>>
31094>>>>>>>>>        Case Begin
31094>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
31096>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31097>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31098>>>>>>>>>                Case Break
31099>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
31102>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31103>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31104>>>>>>>>>                Case Break
31105>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
31108>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31109>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31110>>>>>>>>>                Case Break
31111>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
31114>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31115>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31116>>>>>>>>>                Case Break
31117>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
31120>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31121>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31122>>>>>>>>>                Case Break
31123>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
31126>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31127>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31128>>>>>>>>>                Case Break
31129>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
31132>>>>>>>>>                Send None
31133>>>>>>>>>                Case Break
31134>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
31137>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
31138>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
31139>>>>>>>>>                Case Break
31140>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
31143>>>>>>>>>                //*** Interpret numbers
31143>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
31144>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
31145>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
31146>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
31147>>>>>>>>>                Case Break
31148>>>>>>>>>            Case Else
31148>>>>>>>>>                Set Message_Text to ""
31149>>>>>>>>>                Set Action_Text  to ""
31150>>>>>>>>>        Case End
31150>>>>>>>>>
31150>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
31151>>>>>>>>>        Function_Return False
31152>>>>>>>>>    End_Function
31153>>>>>>>>>
31153>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
31153>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
31155>>>>>>>>>        Function_Return False
31156>>>>>>>>>    End_Function
31157>>>>>>>>>
31157>>>>>>>>>    // *** Helper functions with compiled sql script code ***
31157>>>>>>>>>    //
31157>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
31157>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
31157>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
31157>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
31157>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
31157>>>>>>>>>    //   ALTER TABLE MyTable
31157>>>>>>>>>    //       REBUILD
31157>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
31159>>>>>>>>>        Boolean bOK
31159>>>>>>>>>
31159>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
31161>>>>>>>>>            Function_Return False
31162>>>>>>>>>        End
31162>>>>>>>>>>
31162>>>>>>>>>
31162>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
31162>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
31163>>>>>>>>>
31163>>>>>>>>>        Function_Return (bOK = True)
31164>>>>>>>>>    End_Function
31165>>>>>>>>>
31165>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
31165>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
31165>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
31165>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
31165>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
31165>>>>>>>>>    //   ALTER TABLE MyTable
31165>>>>>>>>>    //       REBUILD
31165>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
31167>>>>>>>>>        tSQLScriptArray SQLScriptArray
31167>>>>>>>>>        tSQLScriptArray SQLScriptArray
31167>>>>>>>>>        String sDriverID
31167>>>>>>>>>        Boolean bOK
31167>>>>>>>>>        Integer iSize iCount
31167>>>>>>>>>
31167>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
31169>>>>>>>>>            Function_Return False
31170>>>>>>>>>        End
31170>>>>>>>>>>
31170>>>>>>>>>
31170>>>>>>>>>        Get psDriverID to sDriverID
31171>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
31172>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
31174>>>>>>>>>            Function_Return False
31175>>>>>>>>>        End
31175>>>>>>>>>>
31175>>>>>>>>>
31175>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
31176>>>>>>>>>        Decrement iSize
31177>>>>>>>>>
31177>>>>>>>>>        For iCount from 0 to iSize
31183>>>>>>>>>>
31183>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
31185>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
31186>>>>>>>>>            End
31186>>>>>>>>>>
31186>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
31188>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
31189>>>>>>>>>            End
31189>>>>>>>>>>
31189>>>>>>>>>        Loop
31190>>>>>>>>>>
31190>>>>>>>>>
31190>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
31191>>>>>>>>>
31191>>>>>>>>>        Function_Return (bOK = True)
31192>>>>>>>>>    End_Function
31193>>>>>>>>>
31193>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
31193>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
31193>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
31193>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
31195>>>>>>>>>        Integer iChannel iArgumentSize iCount
31195>>>>>>>>>        Number nByteCount
31195>>>>>>>>>        String sSQLScript
31195>>>>>>>>>        tSQLScriptArray SqlScriptArray
31195>>>>>>>>>        tSQLScriptArray SqlScriptArray
31195>>>>>>>>>        UChar[] uCharData
31196>>>>>>>>>
31196>>>>>>>>>        Move False to Err
31197>>>>>>>>>        Get Seq_New_Channel to iChannel
31198>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
31200>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
31201>>>>>>>>>>
31201>>>>>>>>>            Move True to SqlScriptArray.bError
31202>>>>>>>>>            Function_Return SqlScriptArray
31203>>>>>>>>>        End
31203>>>>>>>>>>
31203>>>>>>>>>
31203>>>>>>>>>        // First decide the size of the script
31203>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
31205>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
31207>>>>>>>>>        Close_Input channel iChannel
31209>>>>>>>>>
31209>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
31210>>>>>>>>>        If (nByteCount  < 1) Begin
31212>>>>>>>>>            Send Seq_Release_Channel iChannel
31213>>>>>>>>>            Move True to SqlScriptArray.bError
31214>>>>>>>>>            Function_Return SqlScriptArray
31215>>>>>>>>>        End
31215>>>>>>>>>>
31215>>>>>>>>>
31215>>>>>>>>>        // If necessary change the string argument_size
31215>>>>>>>>>        // Read the script file from memory line-by-line
31215>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
31217>>>>>>>>>            Move 0 to iCount
31218>>>>>>>>>            Repeat
31218>>>>>>>>>>
31218>>>>>>>>>                Readln channel iChannel sSQLScript
31220>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
31221>>>>>>>>>                Increment iCount
31222>>>>>>>>>            Until (SeqEof = True)
31224>>>>>>>>>        Close_Input channel iChannel
31226>>>>>>>>>        Send Seq_Release_Channel iChannel
31227>>>>>>>>>
31227>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
31227>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
31228>>>>>>>>>
31228>>>>>>>>>        Function_Return SqlScriptArray
31229>>>>>>>>>    End_Function
31230>>>>>>>>>
31230>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
31232>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
31232>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
31232>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
31232>>>>>>>>>        String[] sMsg aSQLQueryMessages
31234>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
31234>>>>>>>>>        TimeSpan tsQuery
31234>>>>>>>>>        tSqlErrorArray aSqlErrorArray
31234>>>>>>>>>        tSqlErrorArray aSqlErrorArray
31234>>>>>>>>>        tSQLConnection SQLConnection
31234>>>>>>>>>        tSQLConnection SQLConnection
31234>>>>>>>>>        Boolean bShowProgress
31234>>>>>>>>>
31234>>>>>>>>>        If (num_arguments > 4) Begin
31236>>>>>>>>>            Move bShowProgr to bShowProgress
31237>>>>>>>>>        End
31237>>>>>>>>>>
31237>>>>>>>>>        Get phoSQLManager to hoSql
31238>>>>>>>>>
31238>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
31239>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
31239>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
31239>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
31239>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
31239>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
31239>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
31239>>>>>>>>>        Get piChunkMax to iChunkMax
31240>>>>>>>>>        Move 0 to iChunkCounter
31241>>>>>>>>>        Move "" to sStmt
31242>>>>>>>>>
31242>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
31243>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
31244>>>>>>>>>
31244>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
31245>>>>>>>>>
31245>>>>>>>>>        Get phoSQLManager  to hoSQL
31246>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
31248>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
31250>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
31251>>>>>>>>>                If (iPos > 0) Begin
31253>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
31254>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
31255>>>>>>>>>                End
31255>>>>>>>>>>
31255>>>>>>>>>            End
31255>>>>>>>>>>
31255>>>>>>>>>        End
31255>>>>>>>>>>
31255>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
31256>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
31257>>>>>>>>>
31257>>>>>>>>>        If (hoSQLConnect <> 0) Begin
31259>>>>>>>>>            Move False to Err
31260>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
31261>>>>>>>>>            If (hoStmt <> 0) Begin
31263>>>>>>>>>
31263>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
31263>>>>>>>>>                If (bCreateScriptFile = True) Begin
31265>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
31266>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
31267>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
31268>>>>>>>>>                    Get Seq_New_Channel to iOut
31269>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
31271>>>>>>>>>                        Direct_Output channel iOut sExportFile
31273>>>>>>>>>                    End
31273>>>>>>>>>>
31273>>>>>>>>>                End
31273>>>>>>>>>>
31273>>>>>>>>>
31273>>>>>>>>>                // Record starting date/time stamp
31273>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
31274>>>>>>>>>                // Turn on error handling if enabled
31274>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
31276>>>>>>>>>                    Set pbSqlError to False
31277>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
31278>>>>>>>>>                    Move Error_Object_Id to hoError
31279>>>>>>>>>                    Move Self to Error_Object_Id
31280>>>>>>>>>                End
31280>>>>>>>>>>
31280>>>>>>>>>
31280>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
31281>>>>>>>>>                Decrement iRows
31282>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
31284>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
31285>>>>>>>>>                End
31285>>>>>>>>>>
31285>>>>>>>>>
31285>>>>>>>>>                for iCount from 0 to iRows
31291>>>>>>>>>>
31291>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
31292>>>>>>>>>
31292>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
31294>>>>>>>>>                        If (sSQLVal <> "") Begin
31296>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
31297>>>>>>>>>                        End
31297>>>>>>>>>>
31297>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
31298>>>>>>>>>                    End
31298>>>>>>>>>>
31298>>>>>>>>>
31298>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
31298>>>>>>>>>                    // or if at the very end of the script.
31298>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
31300>>>>>>>>>
31300>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
31300>>>>>>>>>                        // instead of all in one go.
31300>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
31301>>>>>>>>>
31301>>>>>>>>>                        If (bCreateScriptFile = True) Begin
31303>>>>>>>>>                            Write channel iOut sStmt
31305>>>>>>>>>                        End
31305>>>>>>>>>>
31305>>>>>>>>>                        Move "" to sStmt
31306>>>>>>>>>                        Move 0 to iChunkCounter
31307>>>>>>>>>                    End
31307>>>>>>>>>>
31307>>>>>>>>>                    Increment iChunkCounter
31308>>>>>>>>>                Loop
31309>>>>>>>>>>
31309>>>>>>>>>
31309>>>>>>>>>                Repeat
31309>>>>>>>>>>
31309>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
31311>>>>>>>>>                        Move hoError to Error_Object_Id
31312>>>>>>>>>                    End
31312>>>>>>>>>>
31312>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
31313>>>>>>>>>
31313>>>>>>>>>                    Send _SqlColumnInfo hoStmt
31314>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
31315>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
31316>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
31317>>>>>>>>>                    Set piRows    to iRows
31318>>>>>>>>>                    Set piRowType to iRowType
31319>>>>>>>>>
31319>>>>>>>>>                    If (iMsgs <> 0) Begin
31321>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
31323>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
31324>>>>>>>>>                        End
31324>>>>>>>>>>
31324>>>>>>>>>                        for i from 1 to iMsgs
31330>>>>>>>>>>
31330>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
31331>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
31332>>>>>>>>>                            If (bShowProgress = True) Begin
31334>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
31336>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
31337>>>>>>>>>                                End
31337>>>>>>>>>>
31337>>>>>>>>>                                Else Begin
31338>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
31340>>>>>>>>>                                End
31340>>>>>>>>>>
31340>>>>>>>>>                            End
31340>>>>>>>>>>
31340>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
31341>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
31342>>>>>>>>>                        Loop
31343>>>>>>>>>>
31343>>>>>>>>>
31343>>>>>>>>>
31343>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
31345>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
31346>>>>>>>>>                        End
31346>>>>>>>>>>
31346>>>>>>>>>                        Set paQueryMessages to sMsg
31347>>>>>>>>>                    End
31347>>>>>>>>>>
31347>>>>>>>>>
31347>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
31348>>>>>>>>>                Until (iNextSet = 0)
31350>>>>>>>>>
31350>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
31351>>>>>>>>>            End
31351>>>>>>>>>>
31351>>>>>>>>>
31351>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
31352>>>>>>>>>            Set ptsQueryExec to tsQuery
31353>>>>>>>>>            Send SqlClose of hoStmt
31354>>>>>>>>>
31354>>>>>>>>>            If (bCreateScriptFile = True) Begin
31356>>>>>>>>>                Close_Output channel iOut
31358>>>>>>>>>                Send Seq_Release_Channel iOut
31359>>>>>>>>>            End
31359>>>>>>>>>>
31359>>>>>>>>>        End
31359>>>>>>>>>>
31359>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
31360>>>>>>>>>
31360>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
31361>>>>>>>>>    End_Function
31362>>>>>>>>>
31362>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
31364>>>>>>>>>        tSQLScriptArray SQLScriptArray
31364>>>>>>>>>        tSQLScriptArray SQLScriptArray
31364>>>>>>>>>        String sDriverID sCollation
31364>>>>>>>>>        Boolean bOK
31364>>>>>>>>>        Integer iSize iCount
31364>>>>>>>>>
31364>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
31366>>>>>>>>>            Function_Return False
31367>>>>>>>>>        End
31367>>>>>>>>>>
31367>>>>>>>>>
31367>>>>>>>>>        Get psDriverID  to sDriverID
31368>>>>>>>>>        Get psCollation to sCollation
31369>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
31370>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
31372>>>>>>>>>            Function_Return False
31373>>>>>>>>>        End
31373>>>>>>>>>>
31373>>>>>>>>>
31373>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
31374>>>>>>>>>        Decrement iSize
31375>>>>>>>>>
31375>>>>>>>>>        For iCount from 0 to iSize
31381>>>>>>>>>>
31381>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
31383>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
31384>>>>>>>>>            End
31384>>>>>>>>>>
31384>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
31386>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
31387>>>>>>>>>            End
31387>>>>>>>>>>
31387>>>>>>>>>        Loop
31388>>>>>>>>>>
31388>>>>>>>>>
31388>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
31389>>>>>>>>>
31389>>>>>>>>>        Function_Return (bOK = True)
31390>>>>>>>>>    End_Function
31391>>>>>>>>>
31391>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
31393>>>>>>>>>        tSQLScriptArray SQLScriptArray
31393>>>>>>>>>        tSQLScriptArray SQLScriptArray
31393>>>>>>>>>        String sDriverID sCollation
31393>>>>>>>>>        Boolean bOK
31393>>>>>>>>>        Integer iSize iCount
31393>>>>>>>>>
31393>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
31395>>>>>>>>>            Function_Return False
31396>>>>>>>>>        End
31396>>>>>>>>>>
31396>>>>>>>>>
31396>>>>>>>>>        Get psDriverID  to sDriverID
31397>>>>>>>>>        Get psCollation to sCollation
31398>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
31399>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
31401>>>>>>>>>            Function_Return False
31402>>>>>>>>>        End
31402>>>>>>>>>>
31402>>>>>>>>>
31402>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
31403>>>>>>>>>        Decrement iSize
31404>>>>>>>>>
31404>>>>>>>>>        For iCount from 0 to iSize
31410>>>>>>>>>>
31410>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
31412>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
31413>>>>>>>>>            End
31413>>>>>>>>>>
31413>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
31415>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
31416>>>>>>>>>            End
31416>>>>>>>>>>
31416>>>>>>>>>        Loop
31417>>>>>>>>>>
31417>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
31417>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
31418>>>>>>>>>
31418>>>>>>>>>        Function_Return (bOK = True)
31419>>>>>>>>>    End_Function
31420>>>>>>>>>
31420>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
31422>>>>>>>>>        Integer iMax iPos
31422>>>>>>>>>        String sName
31422>>>>>>>>>
31422>>>>>>>>>        Move (Lowercase(sField)) to sField
31423>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
31426>>>>>>>>>        For iPos from 0 to iMax
31432>>>>>>>>>>
31432>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
31435>>>>>>>>>            Move (Lowercase(sName)) to sName
31436>>>>>>>>>            If (sName = sField) Begin
31438>>>>>>>>>                Function_Return iPos
31439>>>>>>>>>            End
31439>>>>>>>>>>
31439>>>>>>>>>        Loop
31440>>>>>>>>>>
31440>>>>>>>>>        Function_Return -1
31441>>>>>>>>>    End_Function
31442>>>>>>>>>
31442>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
31442>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
31442>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
31442>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
31442>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
31444>>>>>>>>>        String sID sConnString
31444>>>>>>>>>        Integer iDriver iNumConn iCount
31444>>>>>>>>>        Handle hoCLI
31444>>>>>>>>>        Boolean bOK
31444>>>>>>>>>
31444>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
31445>>>>>>>>>        If (bOK = False) Begin
31447>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
31448>>>>>>>>>>
31448>>>>>>>>>            Function_Return False
31449>>>>>>>>>        End
31449>>>>>>>>>>
31449>>>>>>>>>
31449>>>>>>>>>        Move False to bOK
31450>>>>>>>>>        Get phoCLIHandler to hoCLI
31451>>>>>>>>>        If (hoCLI <> 0) Begin
31453>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
31454>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
31455>>>>>>>>>
31455>>>>>>>>>            // If driver not loaded; load it.
31455>>>>>>>>>            If (iDriver = 0) Begin
31457>>>>>>>>>                Load_Driver sDriverID
31458>>>>>>>>>                Get DriverIndex sDriverID to iDriver
31459>>>>>>>>>            End
31459>>>>>>>>>>
31459>>>>>>>>>            If (iDriver <> 0) Begin
31461>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
31464>>>>>>>>>                Decrement iNumConn
31465>>>>>>>>>                For iCount from 0 to iNumConn
31471>>>>>>>>>>
31471>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
31474>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
31477>>>>>>>>>                    If (sID = sConnectionID) Begin
31479>>>>>>>>>                        Move True to bOK
31480>>>>>>>>>                    End
31480>>>>>>>>>>
31480>>>>>>>>>                Loop
31481>>>>>>>>>>
31481>>>>>>>>>            End
31481>>>>>>>>>>
31481>>>>>>>>>        End
31481>>>>>>>>>>
31481>>>>>>>>>
31481>>>>>>>>>        Function_Return bOK
31482>>>>>>>>>    End_Function
31483>>>>>>>>>
31483>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
31485>>>>>>>>>        Boolean bOK
31485>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
31486>>>>>>>>>        Function_Return bOK
31487>>>>>>>>>    End_Function
31488>>>>>>>>>
31488>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
31490>>>>>>>>>        Integer iDriverIndex
31490>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
31491>>>>>>>>>        Function_Return (iDriverIndex <> 0)
31492>>>>>>>>>    End_Function
31493>>>>>>>>>
31493>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
31493>>>>>>>>>    // attempt to load the driver.
31493>>>>>>>>>    // Returns true if the passed driver is SQL based.
31493>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
31495>>>>>>>>>        Boolean bOK
31495>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
31496>>>>>>>>>        Function_Return bOK
31497>>>>>>>>>    End_Function
31498>>>>>>>>>
31498>>>>>>>>>    // *** Error Handler ***
31498>>>>>>>>>    //
31498>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
31498>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
31498>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
31500>>>>>>>>>        Integer iSize iErrorMode
31500>>>>>>>>>        tSqlErrorArray aSqlErrorArray
31500>>>>>>>>>        tSqlErrorArray aSqlErrorArray
31500>>>>>>>>>
31500>>>>>>>>>        If (pbProcessingError(Self)) Begin
31502>>>>>>>>>            Procedure_Return
31503>>>>>>>>>        End
31503>>>>>>>>>>
31503>>>>>>>>>
31503>>>>>>>>>        Get Error_Report_Mode to iErrorMode
31504>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
31506>>>>>>>>>            Procedure_Return
31507>>>>>>>>>        End
31507>>>>>>>>>>
31507>>>>>>>>>
31507>>>>>>>>>        Set pbProcessingError to True
31508>>>>>>>>>        Set pbSqlError to True
31509>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
31510>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
31511>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
31512>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
31513>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
31514>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
31515>>>>>>>>>        Set pbProcessingError to False
31516>>>>>>>>>    End_Procedure
31517>>>>>>>>>
31517>>>>>>>>>    // *** Miscellanous Helper Functions ***
31517>>>>>>>>>    //
31517>>>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
31517>>>>>>>>>    // returns the table name only; stripped of any path or filename extension.
31517>>>>>>>>>    Function _TableNameOnly String sName Returns String
31519>>>>>>>>>        String sPath sExt
31519>>>>>>>>>
31519>>>>>>>>>        Get ParseFolderName sName to sPath
31520>>>>>>>>>        If (sPath <> "") Begin
31522>>>>>>>>>            Move (Replace(sPath, sName, "")) to sName
31523>>>>>>>>>        End
31523>>>>>>>>>>
31523>>>>>>>>>        Get ParseFileExtension sName to sExt
31524>>>>>>>>>        If (sExt <> "") Begin
31526>>>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
31527>>>>>>>>>        End
31527>>>>>>>>>>
31527>>>>>>>>>
31527>>>>>>>>>        Function_Return sName
31528>>>>>>>>>    End_Function
31529>>>>>>>>>
31529>>>>>>>>>    // Removes any prefix to a table name.
31529>>>>>>>>>    // Example mssqldrv:mytable returns mytable
31529>>>>>>>>>    //         dbo.mytable returns mytable
31529>>>>>>>>>    Function _TableNoPrefix String sName Returns String
31531>>>>>>>>>        Integer iPos
31531>>>>>>>>>
31531>>>>>>>>>        Move (Pos(":", sName)) to iPos
31532>>>>>>>>>        If (iPos <> 0) Begin
31534>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
31535>>>>>>>>>        End
31535>>>>>>>>>>
31535>>>>>>>>>        Move (Pos(".", sName)) to iPos
31536>>>>>>>>>        If (iPos <> 0) Begin
31538>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
31539>>>>>>>>>        End
31539>>>>>>>>>>
31539>>>>>>>>>
31539>>>>>>>>>        Function_Return sName
31540>>>>>>>>>    End_Function
31541>>>>>>>>>
31541>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
31541>>>>>>>>>    // The returned path always ends with a "\"
31541>>>>>>>>>    Function psDataPathFirstPart Returns String
31543>>>>>>>>>        String sDataPath
31543>>>>>>>>>        Integer iCount
31543>>>>>>>>>
31543>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
31544>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
31545>>>>>>>>>        If (iCount > 1) Begin
31547>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
31548>>>>>>>>>        End
31548>>>>>>>>>>
31548>>>>>>>>>        If (sDataPath <> "") Begin
31550>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
31551>>>>>>>>>        End
31551>>>>>>>>>>
31551>>>>>>>>>
31551>>>>>>>>>        Function_Return sDataPath
31552>>>>>>>>>    End_Function
31553>>>>>>>>>
31553>>>>>>>>>    Function psLogTextFileWithPath Returns String
31555>>>>>>>>>        String sFileName
31555>>>>>>>>>        Handle hoLogFile
31555>>>>>>>>>        Get phoLogFile to hoLogFile
31556>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
31557>>>>>>>>>        Function_Return sFileName
31558>>>>>>>>>    End_Function
31559>>>>>>>>>
31559>>>>>>>>>    Function phoLogFile Returns Handle
31561>>>>>>>>>        Handle hoLogFile   
31561>>>>>>>>>        Boolean bErr
31561>>>>>>>>>        
31561>>>>>>>>>        Move Err to bErr
31562>>>>>>>>>        Move 0 to hoLogFile
31563>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
31564>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
31565>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
31567>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
31568>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
31569>>>>>>>>>        Move bErr to Err
31570>>>>>>>>>        
31570>>>>>>>>>        Function_Return hoLogFile
31571>>>>>>>>>    End_Function
31572>>>>>>>>>
31572>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
31574>>>>>>>>>        Number nCurrentVersionUpdate
31574>>>>>>>>>
31574>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
31575>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
31577>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
31578>>>>>>>>>
31578>>>>>>>>>        Function_Return nCurrentVersionUpdate
31579>>>>>>>>>    End_Function
31580>>>>>>>>>
31580>>>>>>>>>    Procedure LogError String sText Boolean bError
31582>>>>>>>>>        Handle hoLogFile
31582>>>>>>>>>        Number nCurrentVersionUpdate
31582>>>>>>>>>
31582>>>>>>>>>        Get phoLogFile to hoLogFile
31583>>>>>>>>>        If (hoLogFile = 0) Begin
31585>>>>>>>>>            Procedure_Return
31586>>>>>>>>>        End
31586>>>>>>>>>>
31586>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
31587>>>>>>>>>
31587>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
31588>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
31589>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
31590>>>>>>>>>    End_Procedure
31591>>>>>>>>>
31591>>>>>>>>>    Function pbContinueOnError Returns Boolean
31593>>>>>>>>>        Boolean bContinueOnError
31593>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
31595>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
31596>>>>>>>>>        End
31596>>>>>>>>>>
31596>>>>>>>>>        Function_Return bContinueOnError
31597>>>>>>>>>    End_Function
31598>>>>>>>>>
31598>>>>>>>>>
31598>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
31600>>>>>>>>>        Integer iChIn iChOut // iCount
31600>>>>>>>>>        Boolean bExists
31600>>>>>>>>>        String sExistingColumn
31600>>>>>>>>>
31600>>>>>>>>>        Move False to bExists
31601>>>>>>>>>        Get Seq_New_Channel to iChIn
31602>>>>>>>>>        Get Seq_New_Channel to iChOut
31603>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
31605>>>>>>>>>            Function_Return True
31606>>>>>>>>>        End
31606>>>>>>>>>>
31606>>>>>>>>>
31606>>>>>>>>>        Move False to Err
31607>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
31607>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
31609>>>>>>>>>        While (not(SeqEof))
31613>>>>>>>>>            Readln channel iChIn sExistingColumn
31615>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
31617>>>>>>>>>                Move True to bExists
31618>>>>>>>>>            End
31618>>>>>>>>>>
31618>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
31620>>>>>>>>>                Move True to SeqEof
31621>>>>>>>>>            End
31621>>>>>>>>>>
31621>>>>>>>>>        Loop
31622>>>>>>>>>>
31622>>>>>>>>>        Close_Input channel iChIn
31624>>>>>>>>>        Send Seq_Release_Channel iChIn
31625>>>>>>>>>
31625>>>>>>>>>        If (bExists = False) Begin
31627>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
31629>>>>>>>>>            Writeln channel iChOut sColumnName
31632>>>>>>>>>            Close_Output channel iChOut
31634>>>>>>>>>            Send Seq_Release_Channel iChOut
31635>>>>>>>>>        End
31635>>>>>>>>>>
31635>>>>>>>>>
31635>>>>>>>>>        Function_Return (Err = False)
31636>>>>>>>>>    End_Function
31637>>>>>>>>>
31637>>>>>>>>>    // Changes source code files.
31637>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
31637>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
31637>>>>>>>>>    // to use a Connection ID.
31637>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
31637>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
31637>>>>>>>>>    // Returns True if no errors occured.
31637>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
31639>>>>>>>>>        Integer iCh iRow iItems iCount
31639>>>>>>>>>        String sValue sRow
31639>>>>>>>>>        String[] sFileArray
31640>>>>>>>>>        Boolean bExists bIsActive
31640>>>>>>>>>
31640>>>>>>>>>        Move False to Err
31641>>>>>>>>>        Move 0 to iRow
31642>>>>>>>>>
31642>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
31644>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
31645>>>>>>>>>        End
31645>>>>>>>>>>
31645>>>>>>>>>
31645>>>>>>>>>        Get vFilePathExists sFileName to bExists
31646>>>>>>>>>        If (bExists = False) Begin
31648>>>>>>>>>            If (bShowResult = True) Begin
31650>>>>>>>>>                If (bIsActive = True) Begin
31652>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
31653>>>>>>>>>                End
31653>>>>>>>>>>
31653>>>>>>>>>                Else Begin
31654>>>>>>>>>                    Showln "File does not exist: " sFileName
31657>>>>>>>>>                End
31657>>>>>>>>>>
31657>>>>>>>>>            End
31657>>>>>>>>>>
31657>>>>>>>>>            Function_Return False
31658>>>>>>>>>        End
31658>>>>>>>>>>
31658>>>>>>>>>
31658>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
31659>>>>>>>>>        If (iCh < 1) Begin
31661>>>>>>>>>            Function_Return False
31662>>>>>>>>>        End
31662>>>>>>>>>>
31662>>>>>>>>>
31662>>>>>>>>>        If (bShowResult = True) Begin
31664>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
31666>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
31667>>>>>>>>>                If (bIsActive = True) Begin
31669>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
31670>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
31671>>>>>>>>>                    Send DoAdvance of ghoProgressBar
31672>>>>>>>>>                End
31672>>>>>>>>>>
31672>>>>>>>>>            End
31672>>>>>>>>>>
31672>>>>>>>>>            Else Begin
31673>>>>>>>>>                Showln ""
31675>>>>>>>>>                Showln "sFileName = " sFileName
31678>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
31683>>>>>>>>>            End
31683>>>>>>>>>>
31683>>>>>>>>>        End
31683>>>>>>>>>>
31683>>>>>>>>>
31683>>>>>>>>>        While (not(SeqEof))
31687>>>>>>>>>            Readln channel iCh sRow
31689>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
31691>>>>>>>>>//                If (bShowResult = True) Begin
31691>>>>>>>>>//                    If (bIsActive = True) Begin
31691>>>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
31691>>>>>>>>>//                    End
31691>>>>>>>>>//                    Else Begin
31691>>>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
31691>>>>>>>>>//                    End
31691>>>>>>>>>//                End
31691>>>>>>>>>                // Change the whole line to the new connection id:
31691>>>>>>>>>                Move sChangeTo to sRow
31692>>>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
31692>>>>>>>>>            End
31692>>>>>>>>>>
31692>>>>>>>>>            Move sRow to sFileArray[iRow]
31693>>>>>>>>>            Increment iRow
31694>>>>>>>>>        Loop
31695>>>>>>>>>>
31695>>>>>>>>>        Send Seq_Close_Channel iCh
31696>>>>>>>>>
31696>>>>>>>>>        Sleep 1 // Wait for Windows to close the file
31697>>>>>>>>>
31697>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
31698>>>>>>>>>        If (iCh < 1) Begin
31700>>>>>>>>>            Function_Return False
31701>>>>>>>>>        End
31701>>>>>>>>>>
31701>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
31702>>>>>>>>>        Decrement iItems
31703>>>>>>>>>
31703>>>>>>>>>        for iCount from 0 to iItems
31709>>>>>>>>>>
31709>>>>>>>>>            Move sFileArray[iCount] to sValue
31710>>>>>>>>>            Writeln channel iCh sValue
31713>>>>>>>>>        Loop
31714>>>>>>>>>>
31714>>>>>>>>>        Send Seq_Close_Channel iCh
31715>>>>>>>>>
31715>>>>>>>>>        Function_Return (Err = False)
31716>>>>>>>>>    End_Function
31717>>>>>>>>>
31717>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
31717>>>>>>>>>    // and opens it in "notepad.exe".
31717>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
31717>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
31717>>>>>>>>>    Procedure _UtilShowErrorList
31719>>>>>>>>>        tSqlErrorArray aSqlErrorArray
31719>>>>>>>>>        tSqlErrorArray aSqlErrorArray
31719>>>>>>>>>        Integer iRows iCount iCh iErrorNum
31719>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
31719>>>>>>>>>
31719>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
31720>>>>>>>>>        Get vFolderFormat sPath to sPath
31721>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
31722>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
31723>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
31724>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
31725>>>>>>>>>            If (iRows > 0) Begin
31727>>>>>>>>>                Decrement iRows
31728>>>>>>>>>                for iCount from 0 to iRows
31734>>>>>>>>>>
31734>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
31735>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
31736>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
31737>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
31743>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
31747>>>>>>>>>                Loop
31748>>>>>>>>>>
31748>>>>>>>>>            End
31748>>>>>>>>>>
31748>>>>>>>>>        Send Seq_Close_Channel iCh
31749>>>>>>>>>
31749>>>>>>>>>        If (iRows > 0) Begin
31751>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
31752>>>>>>>>>        End
31752>>>>>>>>>>
31752>>>>>>>>>    End_Procedure
31753>>>>>>>>>
31753>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
31753>>>>>>>>>    // and the table needs to exist as an SQL table.
31753>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
31755>>>>>>>>>        String sRootName sDriverID
31755>>>>>>>>>        Boolean bIsSQL
31755>>>>>>>>>
31755>>>>>>>>>        Move False to bIsSQL
31756>>>>>>>>>        If (hTable > 0) Begin
31758>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
31761>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
31762>>>>>>>>>            If (bIsSQL = True) Begin
31764>>>>>>>>>                Get psDriverID to sDriverID
31765>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
31766>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
31767>>>>>>>>>            End
31767>>>>>>>>>>
31767>>>>>>>>>        End
31767>>>>>>>>>>
31767>>>>>>>>>
31767>>>>>>>>>        Function_Return bIsSQL
31768>>>>>>>>>    End_Function
31769>>>>>>>>>
31769>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
31771>>>>>>>>>        Boolean bIsSQL
31771>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
31772>>>>>>>>>        Function_Return bIsSQL
31773>>>>>>>>>    End_Function
31774>>>>>>>>>
31774>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
31774>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
31776>>>>>>>>>        String sDatabase sSchema sVal
31776>>>>>>>>>        Boolean bExists
31776>>>>>>>>>        String[] sTablesArray
31777>>>>>>>>>        Integer iSize iCount
31777>>>>>>>>>
31777>>>>>>>>>        Move False to bExists
31778>>>>>>>>>        Get psDatabase to sDatabase
31779>>>>>>>>>        Get psSchema   to sSchema
31780>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
31781>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
31782>>>>>>>>>        Decrement iSize
31783>>>>>>>>>        for iCount from 0 to iSize
31789>>>>>>>>>>
31789>>>>>>>>>            Move sTablesArray[iCount] to sVal
31790>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
31792>>>>>>>>>                Move True to bExists
31793>>>>>>>>>                Move iSize to iCount // We're done!
31794>>>>>>>>>            End
31794>>>>>>>>>>
31794>>>>>>>>>        Loop
31795>>>>>>>>>>
31795>>>>>>>>>
31795>>>>>>>>>        Function_Return bExists
31796>>>>>>>>>    End_Function
31797>>>>>>>>>
31797>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
31797>>>>>>>>>    // that the embedded .dat file exists on disk.
31797>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
31799>>>>>>>>>        Boolean bExists bIsEmbedded
31799>>>>>>>>>        String sDataPath sRootName
31799>>>>>>>>>
31799>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
31800>>>>>>>>>        If (bExists = False) Begin
31802>>>>>>>>>            Function_Return False
31803>>>>>>>>>        End
31803>>>>>>>>>>
31803>>>>>>>>>
31803>>>>>>>>>        Move False to bIsEmbedded
31804>>>>>>>>>        If (hTable > 0) Begin
31806>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
31809>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
31810>>>>>>>>>        End
31810>>>>>>>>>>
31810>>>>>>>>>        If (bIsEmbedded = True) Begin
31812>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
31813>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
31814>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
31815>>>>>>>>>        End
31815>>>>>>>>>>
31815>>>>>>>>>
31815>>>>>>>>>        Function_Return bIsEmbedded
31816>>>>>>>>>    End_Function
31817>>>>>>>>>
31817>>>>>>>>>End_Class
31818>>>>>>>
31818>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
31819>>>>>>>
31819>>>>>>>    Procedure Construct_Object
31821>>>>>>>        Forward Send Construct_Object
31823>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
31824>>>>>>>    End_Procedure
31825>>>>>>>
31825>>>>>>>    Procedure End_Construct_Object
31827>>>>>>>        Forward Send End_Construct_Object
31829>>>>>>>    End_Procedure
31830>>>>>>>
31830>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
31830>>>>>>>    //
31830>>>>>>>    // * Dummy function for the Studio's Code Explorer *
31830>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
31832>>>>>>>        Function_Return False
31833>>>>>>>    End_Function
31834>>>>>>>
31834>>>>>>>    // Function for creating a new *Database*.
31834>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
31834>>>>>>>    // Returns True if successful.
31834>>>>>>>    // ToDo: Currently only works for MS-SQL...
31834>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
31836>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
31836>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
31836>>>>>>>        Handle hConnection hStmt hoSQLManager
31836>>>>>>>        Integer iFetchResult iDbType
31836>>>>>>>        Boolean bOK bExists
31836>>>>>>>
31836>>>>>>>        Get piDbType to iDbType
31837>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
31839>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
31840>>>>>>>>
31840>>>>>>>            Function_Return False
31841>>>>>>>        End
31841>>>>>>>>
31841>>>>>>>
31841>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
31842>>>>>>>        If (bExists = True) Begin
31844>>>>>>>            Function_Return True
31845>>>>>>>        End
31845>>>>>>>>
31845>>>>>>>
31845>>>>>>>        Get phoSQLManager to hoSQLManager
31846>>>>>>>
31846>>>>>>>        Get psConnectionID     to sConnectionID
31847>>>>>>>        Get psConnectionString to sConnectionString
31848>>>>>>>        Move 0 to LastErr
31849>>>>>>>
31849>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
31851>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
31851>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
31851>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
31851>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
31851>>>>>>>//                If (iPos > 0) Begin
31851>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
31851>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
31851>>>>>>>//                End
31851>>>>>>>//            End
31851>>>>>>>        End
31851>>>>>>>>
31851>>>>>>>
31851>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
31852>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
31853>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
31854>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
31856>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
31857>>>>>>>>
31857>>>>>>>            Function_Return False
31858>>>>>>>        End
31858>>>>>>>>
31858>>>>>>>
31858>>>>>>>        Get SqlOpen of hConnection to hStmt
31859>>>>>>>
31859>>>>>>>        If (hStmt = 0) Begin
31861>>>>>>>            Send SqlDisconnect of hoSQLManager
31862>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
31863>>>>>>>>
31863>>>>>>>            Function_Return False
31864>>>>>>>        End
31864>>>>>>>>
31864>>>>>>>
31864>>>>>>>        Get psCollation to sCollation
31865>>>>>>>
31865>>>>>>>        Case Begin
31865>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
31867>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
31868>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
31869>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
31870>>>>>>>
31870>>>>>>>                // Check if database exists
31870>>>>>>>                Send SqlExecDirect of hStmt sSQL
31871>>>>>>>                Get SqlFetch of hStmt to iFetchResult
31872>>>>>>>                Send SqlClose of hStmt
31873>>>>>>>                Send SqlDisconnect of hConnection
31874>>>>>>>                // If database already exists we're out of here!
31874>>>>>>>                // Note that we return True as this is not an error.
31874>>>>>>>                If (iFetchResult > 0) Begin
31876>>>>>>>                    Function_Return True
31877>>>>>>>                End
31877>>>>>>>>
31877>>>>>>>                // Database doesn't exist, create it.
31877>>>>>>>                If (iFetchResult = 0) Begin
31879>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
31880>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
31881>>>>>>>                    If (sCollation <> "") Begin
31883>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
31884>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
31885>>>>>>>                    End
31885>>>>>>>>
31885>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
31886>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
31887>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
31889>>>>>>>                        Function_Return False
31890>>>>>>>                    End
31890>>>>>>>>
31890>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
31890>>>>>>>                    Sleep 1
31891>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
31892>>>>>>>                End
31892>>>>>>>>
31892>>>>>>>                Case Break
31893>>>>>>>
31893>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
31896>>>>>>>                // ToDo: How should this be set/checked?
31896>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
31896>>>>>>>//                    Set psCollation to "utf8"
31896>>>>>>>//                End
31896>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
31896>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
31897>>>>>>>                Case Break
31898>>>>>>>
31898>>>>>>>            Case Else
31898>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
31899>>>>>>>>
31899>>>>>>>        Case End
31899>>>>>>>
31899>>>>>>>        If (Err = False) Begin
31901>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
31902>>>>>>>        End
31902>>>>>>>>
31902>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
31902>>>>>>>        // the one we just created.
31902>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
31904>>>>>>>            Set psDatabase to sDatabase
31905>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
31905>>>>>>>            If (bPermanantly = True) Begin
31907>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
31909>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
31910>>>>>>>                End
31910>>>>>>>>
31910>>>>>>>            End
31910>>>>>>>>
31910>>>>>>>        End
31910>>>>>>>>
31910>>>>>>>
31910>>>>>>>        Function_Return (Err = False)
31911>>>>>>>    End_Function
31912>>>>>>>
31912>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
31912>>>>>>>    // will be used.
31912>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
31914>>>>>>>        Boolean bOK bExists bShowProgress bErr
31914>>>>>>>        String sStatement sDriverID
31914>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
31914>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
31914>>>>>>>        Integer iDbType
31914>>>>>>>
31914>>>>>>>        If (sDatabase = "") Begin
31916>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
31917>>>>>>>>
31917>>>>>>>            Function_Return False
31918>>>>>>>        End
31918>>>>>>>>
31918>>>>>>>        If (sBackupName = "") Begin
31920>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
31921>>>>>>>>
31921>>>>>>>            Function_Return False
31922>>>>>>>        End
31922>>>>>>>>
31922>>>>>>>
31922>>>>>>>        // Create backup-folder if it doesn't exist
31922>>>>>>>        Get vFolderExists sPath to bExists
31923>>>>>>>        If (bExists = False) Begin
31925>>>>>>>            Get vCreateDirectory sPath to bErr
31926>>>>>>>            If (bErr = True) Begin
31928>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
31929>>>>>>>>
31929>>>>>>>                Function_Return False
31930>>>>>>>            End
31930>>>>>>>>
31930>>>>>>>        End
31930>>>>>>>>
31930>>>>>>>        // Make sure the path ends with a back-slash
31930>>>>>>>        If (sPath <> "") Begin
31932>>>>>>>            Get vFolderFormat sPath to sPath
31933>>>>>>>        End
31933>>>>>>>>
31933>>>>>>>
31933>>>>>>>        Get psDriverID to sDriverID
31934>>>>>>>        Get piDbType   to iDbType
31935>>>>>>>        If (num_arguments > 3) Begin
31937>>>>>>>            Move bShowProg to bShowProgress
31938>>>>>>>        End
31938>>>>>>>>
31938>>>>>>>
31938>>>>>>>        Case Begin
31938>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
31940>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
31940>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
31940>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
31941>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
31942>>>>>>>
31942>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
31943>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
31944>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
31945>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
31946>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
31947>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
31948>>>>>>>                Case Break
31949>>>>>>>            Case Else
31949>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
31950>>>>>>>        Case End
31950>>>>>>>
31950>>>>>>>        Function_Return bOK
31951>>>>>>>    End_Function
31952>>>>>>>
31952>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
31954>>>>>>>        String sStatement sDriverID sRetval //sPrevious
31954>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
31954>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
31954>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
31954>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
31954>>>>>>>        tSQLConnection SQLConnection
31954>>>>>>>        tSQLConnection SQLConnection
31954>>>>>>>
31954>>>>>>>        If (sDatabase = "") Begin
31956>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
31957>>>>>>>>
31957>>>>>>>            Function_Return ""
31958>>>>>>>        End
31958>>>>>>>>
31958>>>>>>>
31958>>>>>>>        Move "" to sRetval
31959>>>>>>>        Get psDriverID to sDriverID
31960>>>>>>>        Get piDbType   to iDbType
31961>>>>>>>
31961>>>>>>>        Case Begin
31961>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
31963>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
31963>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
31964>>>>>>>
31964>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
31965>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
31966>>>>>>>                Get phoSQLManager to hoSQLHandler
31967>>>>>>>
31967>>>>>>>                If (hoSQLHandler <> 0) Begin
31969>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
31970>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
31971>>>>>>>
31971>>>>>>>                    If (hoSQLConnect <> 0) Begin
31973>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
31974>>>>>>>                        If (hstmt <> 0) Begin
31976>>>>>>>                            Send SqlExecDirect of hstmt sStatement
31977>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
31978>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
31979>>>>>>>                            If (iFetchResult <> 0) Begin
31981>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
31982>>>>>>>                            End
31982>>>>>>>>
31982>>>>>>>                            Send SQLClose of hstmt
31983>>>>>>>                        End
31983>>>>>>>>
31983>>>>>>>                        Send SQLDisconnect of hoSQLConnect
31984>>>>>>>                    End
31984>>>>>>>>
31984>>>>>>>                End
31984>>>>>>>>
31984>>>>>>>                Case Break
31985>>>>>>>            Case Else
31985>>>>>>>                If (bSilent = False) Begin
31987>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
31988>>>>>>>                End
31988>>>>>>>>
31988>>>>>>>        Case End
31988>>>>>>>
31988>>>>>>>        Function_Return sRetval
31989>>>>>>>    End_Function
31990>>>>>>>
31990>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
31992>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
31992>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
31992>>>>>>>        Handle hConnection hStmt hoSQLManager
31992>>>>>>>        Integer iDbType // iFetchResult
31992>>>>>>>
31992>>>>>>>        If (sDatabase = "") Begin
31994>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
31995>>>>>>>>
31995>>>>>>>            Function_Return False
31996>>>>>>>        End
31996>>>>>>>>
31996>>>>>>>
31996>>>>>>>        If (sSQLCollation = "") Begin
31998>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
31999>>>>>>>>
31999>>>>>>>            Function_Return False
32000>>>>>>>        End
32000>>>>>>>>
32000>>>>>>>
32000>>>>>>>        Get psDriverID to sDriverID
32001>>>>>>>        Get piDbType   to iDbType
32002>>>>>>>
32002>>>>>>>        Get phoSQLManager to hoSQLManager
32003>>>>>>>        Get psConnectionID     to sConnectionID
32004>>>>>>>        Get psConnectionString to sConnectionString
32005>>>>>>>        Move 0 to LastErr
32006>>>>>>>
32006>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
32007>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
32008>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
32009>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
32011>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
32012>>>>>>>>
32012>>>>>>>            Function_Return False
32013>>>>>>>        End
32013>>>>>>>>
32013>>>>>>>
32013>>>>>>>        Get SqlOpen of hConnection to hStmt
32014>>>>>>>
32014>>>>>>>        If (hStmt = 0) Begin
32016>>>>>>>            Send SqlDisconnect of hoSQLManager
32017>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
32018>>>>>>>>
32018>>>>>>>            Function_Return False
32019>>>>>>>        End
32019>>>>>>>>
32019>>>>>>>
32019>>>>>>>        // Check if collation already exists
32019>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
32020>>>>>>>        // If the current collate is the same as the new; do nothing.
32020>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
32022>>>>>>>            Function_Return True
32023>>>>>>>        End
32023>>>>>>>>
32023>>>>>>>
32023>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
32024>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
32025>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
32026>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
32027>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
32028>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
32029>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
32030>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
32031>>>>>>>
32031>>>>>>>        // MS-SQL Syntax:
32031>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
32031>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
32031>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
32031>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
32032>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
32033>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
32034>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
32034>>>>>>>
32034>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
32035>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
32036>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
32037>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
32039>>>>>>>           Function_Return False
32040>>>>>>>        End
32040>>>>>>>>
32040>>>>>>>
32040>>>>>>>        Function_Return (Err = False)
32041>>>>>>>    End_Function
32042>>>>>>>
32042>>>>>>>
32042>>>>>>>    // * Dummy function for the Studio's Code Explorer *
32042>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
32044>>>>>>>        Function_Return False
32045>>>>>>>    End_Function
32046>>>>>>>
32046>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
32046>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
32046>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
32046>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
32046>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
32046>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
32048>>>>>>>        Handle hToTable
32048>>>>>>>        Boolean bOK bExists bOpened bCopyData
32048>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
32048>>>>>>>        tSQLConnection SQLConnection
32048>>>>>>>        tSQLConnection SQLConnection
32048>>>>>>>        Integer iPos iMaxRecords
32048>>>>>>>
32048>>>>>>>        Get psDriverID to sDriverID
32049>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
32050>>>>>>>        If (bExists = False) Begin
32052>>>>>>>            Function_Return False
32053>>>>>>>        End
32053>>>>>>>>
32053>>>>>>>
32053>>>>>>>        If (num_arguments > 1) Begin
32055>>>>>>>            Move bCpyDat to bCopyData
32056>>>>>>>        End
32056>>>>>>>>
32056>>>>>>>        Else Begin
32057>>>>>>>            Move False to bCopyData
32058>>>>>>>        End
32058>>>>>>>>
32058>>>>>>>
32058>>>>>>>        Open hTable
32060>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
32063>>>>>>>        If (bOpened = False) Begin
32065>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
32066>>>>>>>>
32066>>>>>>>            Function_Return False
32067>>>>>>>        End
32067>>>>>>>>
32067>>>>>>>        Move 0 to hToTable
32068>>>>>>>
32068>>>>>>>        Move 16711679 to iMaxRecords
32069>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
32072>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
32073>>>>>>>        If (iPos > 0) Begin
32075>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
32076>>>>>>>        End
32076>>>>>>>>
32076>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
32079>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
32080>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
32081>>>>>>>
32081>>>>>>>        If (ghoProgressBar <> 0) Begin
32083>>>>>>>            Send DoAdvance of ghoProgressBar
32084>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
32085>>>>>>>        End
32085>>>>>>>>
32085>>>>>>>
32085>>>>>>>        Move False to Err
32086>>>>>>>
32086>>>>>>>        Structure_Start hToTable DATAFLEX_ID
32087>>>>>>>            Structure_Copy hTable to hToTable
32088>>>>>>>
32088>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
32091>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
32094>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
32097>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
32100>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
32103>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
32104>>>>>>>
32104>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32106>>>>>>>
32106>>>>>>>        Set Action_Text of ghoStatusPanel to ""
32107>>>>>>>        Move (not(Err)) to bOK
32108>>>>>>>        If (bOK = True and bCopyData = True) Begin
32110>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
32111>>>>>>>        End
32111>>>>>>>>
32111>>>>>>>
32111>>>>>>>        // This must be after copying data...
32111>>>>>>>        If (Err = False) Begin
32113>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
32116>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
32119>>>>>>>        End
32119>>>>>>>>
32119>>>>>>>        Move (not(Err)) to bOK
32120>>>>>>>
32120>>>>>>>        Function_Return (bOK = True)
32121>>>>>>>    End_Function
32122>>>>>>>
32122>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
32122>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
32122>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
32124>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
32124>>>>>>>        Integer iDbType
32124>>>>>>>        Boolean bExists
32124>>>>>>>
32124>>>>>>>        Get psDriverID to sDriverID
32125>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32126>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
32127>>>>>>>        If (bExists = True) Begin
32129>>>>>>>            Function_Return False
32130>>>>>>>        End
32130>>>>>>>>
32130>>>>>>>
32130>>>>>>>        Get psDataPathFirstPart to sPath
32131>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
32132>>>>>>>
32132>>>>>>>        Get piDbType to iDbType
32133>>>>>>>        Get _SqlProperTableName sTableName to sTableName
32134>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
32135>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
32136>>>>>>>
32136>>>>>>>        Move False to Err
32137>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
32138>>>>>>>
32138>>>>>>>        Function_Return (Err = False)
32139>>>>>>>    End_Function
32140>>>>>>>
32140>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
32140>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
32140>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
32142>>>>>>>        String sSQLString sPath sCreateTable sDriverID
32142>>>>>>>        Integer iDbType
32142>>>>>>>        Boolean bExists
32142>>>>>>>
32142>>>>>>>        Get psDriverID to sDriverID
32143>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
32144>>>>>>>        If (bExists = True) Begin
32146>>>>>>>            Function_Return False
32147>>>>>>>        End
32147>>>>>>>>
32147>>>>>>>
32147>>>>>>>        Get psDataPathFirstPart to sPath
32148>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
32149>>>>>>>        If (bExists = True) Begin
32151>>>>>>>            // ToDo: What should we do if an .int file already exists?
32151>>>>>>>        End
32151>>>>>>>>
32151>>>>>>>
32151>>>>>>>        Get piDbType to iDbType
32152>>>>>>>        Get _SqlProperTableName sTableName to sTableName
32153>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
32154>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
32155>>>>>>>
32155>>>>>>>        Move False to Err
32156>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
32157>>>>>>>
32157>>>>>>>        Function_Return (Err = False)
32158>>>>>>>    End_Function
32159>>>>>>>    
32159>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
32159>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
32159>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
32161>>>>>>>        Boolean bOK                                                            
32161>>>>>>>        String sStatement
32161>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
32162>>>>>>>        Function_Return bOK
32163>>>>>>>    End_Function
32164>>>>>>>    
32164>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
32164>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
32164>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
32164>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
32166>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
32166>>>>>>>        Integer iRetval iDbType
32166>>>>>>>        Boolean bExists bOK
32166>>>>>>>
32166>>>>>>>        Get psDriverID to sDriverID
32167>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32168>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
32169>>>>>>>        If (bExists = False) Begin
32171>>>>>>>            Function_Return False
32172>>>>>>>        End
32172>>>>>>>>
32172>>>>>>>
32172>>>>>>>        Get psDataPathFirstPart to sPath
32173>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
32174>>>>>>>
32174>>>>>>>        Get piDbType to iDbType
32175>>>>>>>        Get _SqlProperTableName sTableName to sTableName
32176>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
32177>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
32178>>>>>>>
32178>>>>>>>        Move False to Err
32179>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
32180>>>>>>>
32180>>>>>>>        // We also need to remove the cache-file since the table has been changed
32180>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32181>>>>>>>
32181>>>>>>>        Function_Return (Err = False)
32182>>>>>>>    End_Function
32183>>>>>>>
32183>>>>>>>    // First deletes the data cache file and then drops the passed data table.
32183>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
32185>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
32185>>>>>>>        Integer iRetval iDbType
32185>>>>>>>        Boolean bOK
32185>>>>>>>
32185>>>>>>>        Get psDriverID to sDriverID
32186>>>>>>>        Get psDataPathFirstPart to sPath
32187>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
32188>>>>>>>
32188>>>>>>>        Get piDbType to iDbType
32189>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
32190>>>>>>>        Get psSchema to sSchema
32191>>>>>>>        If (sSchema = "") Begin
32193>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
32194>>>>>>>        End
32194>>>>>>>>
32194>>>>>>>        Move (Uppercase(sTableName)) to sVal
32195>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
32197>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
32198>>>>>>>        End
32198>>>>>>>>
32198>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
32199>>>>>>>
32199>>>>>>>        Move False to Err
32200>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
32201>>>>>>>
32201>>>>>>>        // We also need to remove the cache-file since the table has been changed
32201>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32202>>>>>>>
32202>>>>>>>        Function_Return (Err = False)
32203>>>>>>>    End_Function
32204>>>>>>>
32204>>>>>>>    // *** Sql View Messages ***
32204>>>>>>>
32204>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
32204>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
32206>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
32206>>>>>>>        Integer iRetval
32206>>>>>>>        Boolean bOK
32206>>>>>>>
32206>>>>>>>        Get psDriverID to sDriverID
32207>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
32208>>>>>>>
32208>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
32209>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
32210>>>>>>>        Set psSQLStatementString to sSQLString
32211>>>>>>>
32211>>>>>>>        // As we don't check if the view exist or not, it might happen
32211>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
32211>>>>>>>        Move False to Err
32212>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32213>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
32214>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32215>>>>>>>        Move 0 to LastErr
32216>>>>>>>
32216>>>>>>>        // We also need to remove the cache-file since the table has been changed
32216>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
32217>>>>>>>
32217>>>>>>>        Function_Return (Err = False)
32218>>>>>>>    End_Function
32219>>>>>>>
32219>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
32221>>>>>>>        Boolean bOK
32221>>>>>>>        Integer iDbType
32221>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
32221>>>>>>>
32221>>>>>>>        Get psDriverID to sDriverID
32222>>>>>>>        Get piDbType   to iDbType
32223>>>>>>>
32223>>>>>>>        Case Begin
32223>>>>>>>            Case (iDbType = EN_DbTypeDB2)
32225>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
32226>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
32227>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
32228>>>>>>>            Break
32229>>>>>>>
32229>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
32232>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
32233>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
32234>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
32235>>>>>>>            Break
32236>>>>>>>
32236>>>>>>>            Case (iDbType = EN_DbTypeOracle)
32239>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
32240>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
32241>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
32242>>>>>>>            Break
32243>>>>>>>
32243>>>>>>>            Case (iDbType = EN_DbTypePostgre)
32246>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
32247>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
32248>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
32249>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
32250>>>>>>>            Break
32251>>>>>>>
32251>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
32254>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
32255>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
32256>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
32257>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
32258>>>>>>>            Break
32259>>>>>>>        Case End
32259>>>>>>>
32259>>>>>>>        Move False to Err
32260>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
32261>>>>>>>        Move (Err = False) to bOK
32262>>>>>>>
32262>>>>>>>        Function_Return bOK
32263>>>>>>>    End_Function
32264>>>>>>>
32264>>>>>>>    // * Dummy function for the Studio's Code Explorer *
32264>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
32266>>>>>>>        Function_Return False
32267>>>>>>>    End_Function
32268>>>>>>>
32268>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
32268>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
32270>>>>>>>        Integer iLength iDecimals
32270>>>>>>>        String sColumnValue
32270>>>>>>>        String sTableName sDriverID
32270>>>>>>>        Boolean bOK bInitializeValue
32270>>>>>>>
32270>>>>>>>        Get psDriverID to sDriverID
32271>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32272>>>>>>>        If (bOK = False) Begin
32274>>>>>>>            Function_Return False
32275>>>>>>>        End
32275>>>>>>>>
32275>>>>>>>
32275>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32276>>>>>>>        If (sTableName = "") Begin
32278>>>>>>>            Function_Return False
32279>>>>>>>        End
32279>>>>>>>>
32279>>>>>>>
32279>>>>>>>        If (num_arguments > 3) Begin
32281>>>>>>>            Move iLen     to iLength
32282>>>>>>>            Move iDec     to iDecimals
32283>>>>>>>            Move bInitVal to bInitializeValue
32284>>>>>>>            Move sColVal  to sColumnValue
32285>>>>>>>        End
32285>>>>>>>>
32285>>>>>>>
32285>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
32286>>>>>>>
32286>>>>>>>        Function_Return (bOK = True)
32287>>>>>>>    End_Function
32288>>>>>>>
32288>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
32288>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
32290>>>>>>>        Integer iDbType iLength iDecimals iDriver
32290>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
32290>>>>>>>        String sDriverID sNotNull
32290>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
32290>>>>>>>        Handle hTable
32290>>>>>>>
32290>>>>>>>        Get psDriverID to sDriverID
32291>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32292>>>>>>>        If (bOK = False) Begin
32294>>>>>>>            Function_Return True
32295>>>>>>>        End
32295>>>>>>>>
32295>>>>>>>
32295>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
32296>>>>>>>        If (hTable = 0) Begin
32298>>>>>>>            Get NextFreeFilelistSlot to hTable
32299>>>>>>>        End
32299>>>>>>>>
32299>>>>>>>
32299>>>>>>>        Get piDbType to iDbType
32300>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
32300>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
32301>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
32303>>>>>>>            Function_Return True
32304>>>>>>>        End
32304>>>>>>>>
32304>>>>>>>
32304>>>>>>>        Get DriverIndex sDriverID to iDriver
32305>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
32308>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
32311>>>>>>>
32311>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
32312>>>>>>>        If (num_arguments > 3) Begin
32314>>>>>>>            Move iLen     to iLength
32315>>>>>>>            Move iDec     to iDecimals
32316>>>>>>>            Move bInitVal to bInitializeValue
32317>>>>>>>            Move sColVal  to sColumnValue
32318>>>>>>>        End
32318>>>>>>>>
32318>>>>>>>
32318>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
32319>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
32320>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
32321>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
32322>>>>>>>
32322>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
32323>>>>>>>        If (bFixed = False) Begin
32325>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
32326>>>>>>>        End
32326>>>>>>>>
32326>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
32327>>>>>>>
32327>>>>>>>        Move False to Err
32328>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
32329>>>>>>>
32329>>>>>>>        If (bInitializeValue = True and Err = False) Begin
32331>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
32332>>>>>>>        End
32332>>>>>>>>
32332>>>>>>>
32332>>>>>>>        If (Err = False) Begin
32334>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
32335>>>>>>>        End
32335>>>>>>>>
32335>>>>>>>
32335>>>>>>>        Move (not(Err)) to bRetval
32336>>>>>>>
32336>>>>>>>        // We also need to remove the cache-file since the table has been changed
32336>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32337>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
32340>>>>>>>
32340>>>>>>>        Function_Return bRetval
32341>>>>>>>    End_Function
32342>>>>>>>
32342>>>>>>>    // To update all current rows for a table column with a common value.
32342>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
32344>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
32344>>>>>>>        Boolean bRetval bSQLDriver
32344>>>>>>>        Integer iCurrErr iDbType
32344>>>>>>>
32344>>>>>>>        Move False to bRetval
32345>>>>>>>        Get piDbType to iDbType
32346>>>>>>>        Get psDriverID to sDriverID
32347>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
32348>>>>>>>        If (bSQLDriver = False) Begin
32350>>>>>>>            Function_Return bRetval
32351>>>>>>>        End
32351>>>>>>>>
32351>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32352>>>>>>>
32352>>>>>>>        Move Err to iCurrErr
32353>>>>>>>        Move False to Err
32354>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
32355>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
32356>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
32357>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
32357>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
32359>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
32360>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
32361>>>>>>>        End
32361>>>>>>>>
32361>>>>>>>        Else Begin
32362>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
32363>>>>>>>        End
32363>>>>>>>>
32363>>>>>>>
32363>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
32364>>>>>>>        Move (Err = False) to bRetval
32365>>>>>>>        Move iCurrErr to Err
32366>>>>>>>
32366>>>>>>>        Function_Return bRetval
32367>>>>>>>    End_Function
32368>>>>>>>
32368>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
32368>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
32368>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
32370>>>>>>>        String sDriverID sTableName
32370>>>>>>>        Boolean bOK
32370>>>>>>>
32370>>>>>>>        Get psDriverID to sDriverID
32371>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32372>>>>>>>        If (bOK = False) Begin
32374>>>>>>>            Function_Return False
32375>>>>>>>        End
32375>>>>>>>>
32375>>>>>>>
32375>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32376>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
32377>>>>>>>
32377>>>>>>>        Function_Return (Err = False)
32378>>>>>>>    End_Function
32379>>>>>>>
32379>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
32379>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
32379>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
32379>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
32381>>>>>>>        Integer iDbType iLength iDecimals
32381>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
32381>>>>>>>        Boolean bExists bOK bFixed
32381>>>>>>>        Handle hTable
32381>>>>>>>
32381>>>>>>>        Get psDriverID to sDriverID
32382>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32383>>>>>>>        If (bOK = False) Begin
32385>>>>>>>            Function_Return False
32386>>>>>>>        End
32386>>>>>>>>
32386>>>>>>>
32386>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
32387>>>>>>>        If (hTable = 0) Begin
32389>>>>>>>            Get NextFreeFilelistSlot to hTable
32390>>>>>>>        End
32390>>>>>>>>
32390>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
32391>>>>>>>        If (bExists = False) Begin
32393>>>>>>>            Function_Return False
32394>>>>>>>        End
32394>>>>>>>>
32394>>>>>>>
32394>>>>>>>        If (num_arguments > 3) Begin
32396>>>>>>>            Move iLen to iLength
32397>>>>>>>        End
32397>>>>>>>>
32397>>>>>>>        If (num_arguments > 4) Begin
32399>>>>>>>            Move iDec to iDecimals
32400>>>>>>>        End
32400>>>>>>>>
32400>>>>>>>
32400>>>>>>>        Get piDbType to iDbType
32401>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
32402>>>>>>>
32402>>>>>>>        Move False to Err
32403>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
32404>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
32405>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
32406>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
32407>>>>>>>
32407>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
32408>>>>>>>        If (bFixed = False) Begin
32410>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
32411>>>>>>>        End
32411>>>>>>>>
32411>>>>>>>
32411>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
32412>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
32413>>>>>>>
32413>>>>>>>        // We also need to remove the cache-file since the table has been changed
32413>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32414>>>>>>>
32414>>>>>>>        Function_Return (Err = False)
32415>>>>>>>    End_Function
32416>>>>>>>
32416>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
32418>>>>>>>        Boolean bOK bErr bIsSQLDriver
32418>>>>>>>        String sDriverID
32418>>>>>>>        Integer iDataType
32418>>>>>>>
32418>>>>>>>        Get psDriverID to sDriverID
32419>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
32420>>>>>>>        If (bIsSQLDriver = False) Begin
32422>>>>>>>            Function_Return False
32423>>>>>>>        End
32423>>>>>>>>
32423>>>>>>>
32423>>>>>>>        Move Err to bErr
32424>>>>>>>        Move False to bErr
32425>>>>>>>
32425>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
32425>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
32425>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
32426>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
32429>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
32431>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
32432>>>>>>>        End
32432>>>>>>>>
32432>>>>>>>
32432>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
32435>>>>>>>        Move (not(Err)) to bOK
32436>>>>>>>        Move bErr to Err
32437>>>>>>>
32437>>>>>>>        Function_Return bOK
32438>>>>>>>    End_Function
32439>>>>>>>
32439>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
32441>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
32441>>>>>>>        String sDriverID
32441>>>>>>>
32441>>>>>>>        Get psDriverID to sDriverID
32442>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
32443>>>>>>>        If (bIsSQLDriver = False) Begin
32445>>>>>>>            Function_Return False
32446>>>>>>>        End
32446>>>>>>>>
32446>>>>>>>
32446>>>>>>>        Move Err to bErr
32447>>>>>>>        Move False to bErr
32448>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
32451>>>>>>>        If (bNullable = bCurrentState) Begin
32453>>>>>>>            Function_Return True
32454>>>>>>>        End
32454>>>>>>>>
32454>>>>>>>
32454>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
32457>>>>>>>        If (bOpen = False) Begin
32459>>>>>>>            Get AutoConnectionIDLogin to bOK
32460>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
32461>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
32462>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
32463>>>>>>>            Open hTable
32465>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
32466>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
32467>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
32468>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
32471>>>>>>>        End
32471>>>>>>>>
32471>>>>>>>        If (bOpen = True) Begin
32473>>>>>>>            Structure_Start hTable sDriverID
32474>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
32477>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
32478>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
32480>>>>>>>            Set Action_Text of ghoStatusPanel to ""
32481>>>>>>>        End
32481>>>>>>>>
32481>>>>>>>
32481>>>>>>>        Move (not(Err)) to bOK
32482>>>>>>>        Move bErr to Err
32483>>>>>>>
32483>>>>>>>        Function_Return bOK
32484>>>>>>>    End_Function
32485>>>>>>>
32485>>>>>>>    // Drop column by its table handle
32485>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
32487>>>>>>>        String sDriverID sTableName
32487>>>>>>>        Boolean bOK
32487>>>>>>>
32487>>>>>>>        Get psDriverID to sDriverID
32488>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32489>>>>>>>        If (bOK = False) Begin
32491>>>>>>>            Function_Return False
32492>>>>>>>        End
32492>>>>>>>>
32492>>>>>>>
32492>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32493>>>>>>>        If (sTableName = "") Begin
32495>>>>>>>            Function_Return False
32496>>>>>>>        End
32496>>>>>>>>
32496>>>>>>>
32496>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
32497>>>>>>>
32497>>>>>>>        Function_Return (bOK = True)
32498>>>>>>>    End_Function
32499>>>>>>>
32499>>>>>>>    // Drop column by its table name as a string.
32499>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
32501>>>>>>>        Integer iDbType iDriver
32501>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
32501>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
32501>>>>>>>        Handle hTable
32501>>>>>>>
32501>>>>>>>        Get psDriverID to sDriverID
32502>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32503>>>>>>>        If (bOK = False) Begin
32505>>>>>>>            Function_Return False
32506>>>>>>>        End
32506>>>>>>>>
32506>>>>>>>
32506>>>>>>>        Get DriverIndex sDriverID to iDriver
32507>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
32510>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
32513>>>>>>>
32513>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
32514>>>>>>>        If (hTable <> 0) Begin
32516>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
32517>>>>>>>            If (bExists = False) Begin
32519>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
32522>>>>>>>                Function_Return False
32523>>>>>>>            End
32523>>>>>>>>
32523>>>>>>>        End
32523>>>>>>>>
32523>>>>>>>
32523>>>>>>>        Get piDbType to iDbType
32524>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
32526>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
32527>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
32528>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
32531>>>>>>>            Function_Return bOK
32532>>>>>>>        End
32532>>>>>>>>
32532>>>>>>>
32532>>>>>>>        Move False to Err
32533>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
32534>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
32535>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
32536>>>>>>>
32536>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
32537>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
32538>>>>>>>        Move (not(Err)) to bRetval
32539>>>>>>>
32539>>>>>>>        // We also need to remove the cache-file since the table has been changed
32539>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32540>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
32543>>>>>>>
32543>>>>>>>        Function_Return bRetval
32544>>>>>>>    End_Function
32545>>>>>>>
32545>>>>>>>    // Rename a field/column by table handle (filelist number)
32545>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
32547>>>>>>>        String sDriverID sTableName
32547>>>>>>>        Boolean bOK
32547>>>>>>>
32547>>>>>>>        Get psDriverID to sDriverID
32548>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32549>>>>>>>        If (bOK = False) Begin
32551>>>>>>>            Function_Return False
32552>>>>>>>        End
32552>>>>>>>>
32552>>>>>>>
32552>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32553>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
32554>>>>>>>
32554>>>>>>>        Function_Return (Err = False)
32555>>>>>>>    End_Function
32556>>>>>>>
32556>>>>>>>    // Rename a field/column by table name.
32556>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
32558>>>>>>>        Integer iDbType iDataType
32558>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
32558>>>>>>>        Boolean bOK bRetval
32558>>>>>>>        Handle hTable
32558>>>>>>>
32558>>>>>>>        Move sTableName to sOrgTableName
32559>>>>>>>        Get psDriverID to sDriverID
32560>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32561>>>>>>>        If (bOK = False) Begin
32563>>>>>>>            Function_Return False
32564>>>>>>>        End
32564>>>>>>>>
32564>>>>>>>
32564>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
32565>>>>>>>        If (sVal = "") Begin
32567>>>>>>>            Function_Return False
32568>>>>>>>        End
32568>>>>>>>>
32568>>>>>>>
32568>>>>>>>        Get piDbType to iDbType
32569>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
32570>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
32571>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
32572>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
32573>>>>>>>
32573>>>>>>>        Case Begin
32573>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
32575>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
32576>>>>>>>                Case Break
32577>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
32577>>>>>>>            Case (iDbType = EN_dbTypeOracle)
32580>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
32581>>>>>>>                Case Break
32582>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
32582>>>>>>>            Case (iDbType = EN_dbTypeDB2)
32585>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
32586>>>>>>>                Case Break
32587>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
32587>>>>>>>            Case (iDbType = EN_dbTypePostgre)
32590>>>>>>>                Move sOrgTableName to sTableName
32591>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
32592>>>>>>>                Case Break
32593>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
32596>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
32596>>>>>>>                Move sOrgTableName to sTableName
32597>>>>>>>                Get psDatabase to sDatabase
32598>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
32599>>>>>>>                If (hTable = 0) Begin
32601>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
32602>>>>>>>                    If (bOK = False) Begin
32604>>>>>>>                        Function_Return False
32605>>>>>>>                    End
32605>>>>>>>>
32605>>>>>>>                    Get NextFreeFilelistSlot to hTable
32606>>>>>>>                End
32606>>>>>>>>
32606>>>>>>>                Else Begin
32607>>>>>>>                    Open hTable
32609>>>>>>>                End
32609>>>>>>>>
32609>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
32610>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
32611>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
32612>>>>>>>                Case Break
32613>>>>>>>            Case Else
32613>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
32614>>>>>>>        Case End
32614>>>>>>>
32614>>>>>>>        Move False to Err
32615>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
32616>>>>>>>        Move (Err = False) to bRetval
32617>>>>>>>        // We also need to remove the cache-file since the table has been changed
32617>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32618>>>>>>>
32618>>>>>>>        Function_Return bRetval
32619>>>>>>>    End_Function
32620>>>>>>>
32620>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
32622>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
32622>>>>>>>        Integer iNumCols iCount iDataType
32622>>>>>>>        String sValue
32622>>>>>>>
32622>>>>>>>        Get phoSQLManager to hoSQLHandler
32623>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
32624>>>>>>>        If (hSQLConnect <> 0) Begin
32626>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
32627>>>>>>>            If (hStmt <> 0) Begin
32629>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
32630>>>>>>>
32630>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
32631>>>>>>>                For iCount from 1 to iNumCols
32637>>>>>>>>
32637>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
32638>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
32640>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
32641>>>>>>>                        Move iNumCols to iCount // We're out of here
32642>>>>>>>                    End
32642>>>>>>>>
32642>>>>>>>                Loop
32643>>>>>>>>
32643>>>>>>>
32643>>>>>>>                Send SQLClose of hStmt
32644>>>>>>>            End
32644>>>>>>>>
32644>>>>>>>            Send SQLDisconnect of hSQLConnect
32645>>>>>>>        End
32645>>>>>>>>
32645>>>>>>>
32645>>>>>>>        Function_Return iDataType
32646>>>>>>>    End_Function
32647>>>>>>>
32647>>>>>>>    // * Dummy function for the Studio's Code Explorer *
32647>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
32649>>>>>>>        Function_Return False
32650>>>>>>>    End_Function
32651>>>>>>>
32651>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
32653>>>>>>>        String sMessage // sConnectionString
32653>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
32653>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
32653>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
32656>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
32656>>>>>>>        TimeSpan tsQuery tsFetch
32656>>>>>>>        tSqlErrorArray aSqlErrorArray
32656>>>>>>>        tSqlErrorArray aSqlErrorArray
32656>>>>>>>        Boolean bOK bShowProgress
32656>>>>>>>        tSQLConnection SQLConnection
32656>>>>>>>        tSQLConnection SQLConnection
32656>>>>>>>
32656>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
32657>>>>>>>        If (bOK = False) Begin
32659>>>>>>>            Procedure_Return
32660>>>>>>>        End
32660>>>>>>>>
32660>>>>>>>
32660>>>>>>>        If (num_arguments > 2) Begin
32662>>>>>>>            Move bShowProgr to bShowProgress
32663>>>>>>>        End
32663>>>>>>>>
32663>>>>>>>
32663>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
32664>>>>>>>        Get phoSQLManager to hoSqlHandler
32665>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
32666>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
32667>>>>>>>
32667>>>>>>>        If (hoSQLConnect <> 0) Begin
32669>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
32670>>>>>>>            If (hoStmt <> 0) Begin
32672>>>>>>>                // record starting date/time stamp
32672>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
32673>>>>>>>                // turn on error handling if enabled
32673>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
32675>>>>>>>                    Set pbSqlError to False
32676>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
32677>>>>>>>                    Move Error_Object_Id to hoError
32678>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
32680>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
32681>>>>>>>                    End
32681>>>>>>>>
32681>>>>>>>                    Else Begin
32682>>>>>>>                        Move Self to Error_Object_Id
32683>>>>>>>                    End
32683>>>>>>>>
32683>>>>>>>                End
32683>>>>>>>>
32683>>>>>>>
32683>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
32683>>>>>>>                Set psSQLStatementString to sStmt
32684>>>>>>>                Send Cursor_Wait of Cursor_Control
32685>>>>>>>                Send SqlExecDirect of hoStmt sStmt
32686>>>>>>>                Send Cursor_Ready of Cursor_Control
32687>>>>>>>
32687>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
32689>>>>>>>                    Move hoError to Error_Object_Id
32690>>>>>>>                End
32690>>>>>>>>
32690>>>>>>>
32690>>>>>>>                Move 0 to iMsgs
32691>>>>>>>                Move Err to iErr
32692>>>>>>>                Move LastErr to iLastErr
32693>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
32694>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
32695>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
32696>>>>>>>                Send _SqlColumnInfo hoStmt
32697>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
32698>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32699>>>>>>>                Repeat
32699>>>>>>>>
32699>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
32700>>>>>>>                    If (iFetchResult <> 0) Begin
32702>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
32703>>>>>>>                    End
32703>>>>>>>>
32703>>>>>>>                Until (iFetchResult = 0)
32705>>>>>>>                Send Trap_Error of Error_Object_Id 12289
32706>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
32707>>>>>>>                Move iErr to Err
32708>>>>>>>                Move iLastErr to LastErr
32709>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
32710>>>>>>>
32710>>>>>>>                Set piRows    to iRows
32711>>>>>>>                Set piRowType to iRowType
32712>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
32713>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
32714>>>>>>>
32714>>>>>>>                If (iMsgs <> 0) Begin
32716>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
32718>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
32719>>>>>>>                    End
32719>>>>>>>>
32719>>>>>>>                    For i from 1 to iMsgs
32725>>>>>>>>
32725>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
32726>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
32727>>>>>>>                        If (bShowProgress = True) Begin
32729>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
32731>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
32732>>>>>>>                            End
32732>>>>>>>>
32732>>>>>>>                            Else Begin
32733>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
32735>>>>>>>                            End
32735>>>>>>>>
32735>>>>>>>                        End
32735>>>>>>>>
32735>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
32736>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
32737>>>>>>>                    Loop
32738>>>>>>>>
32738>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
32740>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
32741>>>>>>>                    End
32741>>>>>>>>
32741>>>>>>>                    Set paQueryMessages to sMsg
32742>>>>>>>                End
32742>>>>>>>>
32742>>>>>>>                Else Begin
32743>>>>>>>                    If (bShowProgress = True) Begin
32745>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
32746>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
32748>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
32749>>>>>>>                            Decrement iMsgs
32750>>>>>>>                            For i from 0 to iMsgs
32756>>>>>>>>
32756>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
32759>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
32762>>>>>>>                            Loop
32763>>>>>>>>
32763>>>>>>>                        End
32763>>>>>>>>
32763>>>>>>>                    End
32763>>>>>>>>
32763>>>>>>>                End
32763>>>>>>>>
32763>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
32764>>>>>>>            End
32764>>>>>>>>
32764>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
32765>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
32766>>>>>>>            Set ptsQueryExec to tsQuery
32767>>>>>>>            Set ptsFetchResults to tsFetch
32768>>>>>>>            Send SqlClose of hoStmt
32769>>>>>>>        End
32769>>>>>>>>
32769>>>>>>>
32769>>>>>>>        Send SqlDisconnect of hoSQLConnect
32770>>>>>>>    End_Procedure
32771>>>>>>>
32771>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
32771>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
32771>>>>>>>    // Returns False if no error occured.
32771>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
32773>>>>>>>        Boolean bOK bShowProgress
32773>>>>>>>        tSQLScriptArray SQLScriptArray
32773>>>>>>>        tSQLScriptArray SQLScriptArray
32773>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
32773>>>>>>>        TimeSpan tsTotalTime
32773>>>>>>>
32773>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
32774>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
32775>>>>>>>        If (SQLScriptArray.bError = True) Begin
32777>>>>>>>            Function_Return False
32778>>>>>>>        End
32778>>>>>>>>
32778>>>>>>>
32778>>>>>>>        If (num_arguments > 3) Begin
32780>>>>>>>            Move bShowProgr to bShowProgress
32781>>>>>>>        End
32781>>>>>>>>
32781>>>>>>>
32781>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
32782>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
32783>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
32784>>>>>>>
32784>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
32785>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
32786>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
32787>>>>>>>
32787>>>>>>>        Function_Return bOK
32788>>>>>>>    End_Function
32789>>>>>>>
32789>>>>>>>    // * Dummy function for the Studio's Code Explorer *
32789>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
32791>>>>>>>        Function_Return False
32792>>>>>>>    End_Function
32793>>>>>>>
32793>>>>>>>    // Does three things with auxilirary files;
32793>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
32793>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
32793>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
32793>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
32795>>>>>>>        String sDataPath sDDSrcPath sDriverID
32795>>>>>>>        Boolean bOK bExists
32795>>>>>>>        Integer iCount iCh iPos
32795>>>>>>>
32795>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
32795>>>>>>>        If (sTableName contains ".") Begin
32797>>>>>>>            Move (Pos(".", sTableName)) to iPos
32798>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
32799>>>>>>>        End
32799>>>>>>>>
32799>>>>>>>
32799>>>>>>>        Get psDriverID to sDriverID
32800>>>>>>>        Get psDataPathFirstPart to sDataPath
32801>>>>>>>        Get vFolderExists sDataPath to bOK
32802>>>>>>>        If (bOK = False) Begin
32804>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
32805>>>>>>>>
32805>>>>>>>            Function_Return False
32806>>>>>>>        End
32806>>>>>>>>
32806>>>>>>>
32806>>>>>>>        // First delete the cache file:
32806>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
32807>>>>>>>
32807>>>>>>>        Get Seq_New_Channel to iCh
32808>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
32810>>>>>>>            Function_Return False
32811>>>>>>>        End
32811>>>>>>>>
32811>>>>>>>
32811>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
32812>>>>>>>        If (bExists = False) Begin
32814>>>>>>>            Function_Return False
32815>>>>>>>        End
32815>>>>>>>>
32815>>>>>>>
32815>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
32816>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
32816>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
32817>>>>>>>
32817>>>>>>>        // If in development environment; output new .fd file:
32817>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
32818>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
32819>>>>>>>        If (iCount > 1) Begin
32821>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
32822>>>>>>>        End
32822>>>>>>>>
32822>>>>>>>        Get vFolderExists sDDSrcPath to bExists
32823>>>>>>>        If (bExists = True) Begin
32825>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
32826>>>>>>>            Move False to Err
32827>>>>>>>            Get AutoConnectionIDLogin to bOK
32828>>>>>>>            If (hTable <> 0) Begin
32830>>>>>>>                Open hTable
32832>>>>>>>            End
32832>>>>>>>>
32832>>>>>>>            Else Begin
32833>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
32834>>>>>>>            End
32834>>>>>>>>
32834>>>>>>>
32834>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
32837>>>>>>>            If (bOK = True) Begin
32839>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
32841>>>>>>>            End
32841>>>>>>>>
32841>>>>>>>            If (Err = True) Begin
32843>>>>>>>                Move False to bOK
32844>>>>>>>            End
32844>>>>>>>>
32844>>>>>>>        End
32844>>>>>>>>
32844>>>>>>>
32844>>>>>>>        Function_Return (bOK = True)
32845>>>>>>>    End_Function
32846>>>>>>>
32846>>>>>>>    // Message for changing .int files to use connection ID's
32846>>>>>>>    //
32846>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
32846>>>>>>>    // OR changes an existing connection id to a new id.
32846>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
32846>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
32846>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
32848>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
32848>>>>>>>        String[] sFilesData
32849>>>>>>>        Boolean bOK bCancel
32849>>>>>>>        Integer iSize iCount
32849>>>>>>>
32849>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
32850>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
32851>>>>>>>        If (iSize = 0) Begin
32853>>>>>>>            If (ghoStatusPanel <> 0) Begin
32855>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
32857>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
32858>>>>>>>                End
32858>>>>>>>>
32858>>>>>>>            End
32858>>>>>>>>
32858>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
32859>>>>>>>            Procedure_Return
32860>>>>>>>        End
32860>>>>>>>>
32860>>>>>>>
32860>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
32861>>>>>>>        Get vFolderFormat sDataPath to sDataPath
32862>>>>>>>        Decrement iSize
32863>>>>>>>        For iCount from 0 to iSize
32869>>>>>>>>
32869>>>>>>>            Move sFilesData[iCount] to sFileName
32870>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
32870>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
32871>>>>>>>            If (ghoStatusPanel <> 0) Begin
32873>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
32875>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
32876>>>>>>>                    If (bCancel = True) Begin
32878>>>>>>>                        Send Deactivate of ghoStatusPanel
32879>>>>>>>                        Procedure_Return
32880>>>>>>>                    End
32880>>>>>>>>
32880>>>>>>>                End
32880>>>>>>>>
32880>>>>>>>            End
32880>>>>>>>>
32880>>>>>>>        Loop
32881>>>>>>>>
32881>>>>>>>
32881>>>>>>>        Get psDriverID to sDriverID
32882>>>>>>>
32882>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
32882>>>>>>>        Move "" to sFileName
32883>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
32885>>>>>>>            Move "MSSQLDrv.int" to sFileName
32886>>>>>>>        End
32886>>>>>>>>
32886>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
32888>>>>>>>            Move "DB2_Drv.int" to sFileName
32889>>>>>>>        End
32889>>>>>>>>
32889>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
32891>>>>>>>            Move "ODBC_Drv.int" to sFileName
32892>>>>>>>        End
32892>>>>>>>>
32892>>>>>>>        If (sFileName <> "") Begin
32894>>>>>>>            Move "" to sDriverFile
32895>>>>>>>            Get_File_Path sFileName to sDriverFile
32896>>>>>>>            If (sDriverFile <> "") Begin
32898>>>>>>>                Get psConnectionString to sConnectionString
32899>>>>>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
32900>>>>>>>            End
32900>>>>>>>>
32900>>>>>>>        End
32900>>>>>>>>
32900>>>>>>>    End_Procedure
32901>>>>>>>
32901>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
32901>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
32903>>>>>>>        String[] sDatabaseArray
32904>>>>>>>        String sVal sServer sDriverID
32904>>>>>>>        Integer iCount iSize iPos
32904>>>>>>>        Boolean bExists
32904>>>>>>>        tSQLConnection SQLConnection
32904>>>>>>>        tSQLConnection SQLConnection
32904>>>>>>>
32904>>>>>>>        Move False to bExists
32905>>>>>>>        Get psDriverID to sDriverID
32906>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
32906>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
32908>>>>>>>            Function_Return bExists
32909>>>>>>>        End
32909>>>>>>>>
32909>>>>>>>
32909>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
32910>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
32912>>>>>>>            Function_Return False
32913>>>>>>>        End
32913>>>>>>>>
32913>>>>>>>
32913>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
32914>>>>>>>        Move SQLConnection.sServer to sServer
32915>>>>>>>
32915>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
32915>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
32917>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
32918>>>>>>>        End
32918>>>>>>>>
32918>>>>>>>        Else If (sServer contains "/") Begin
32921>>>>>>>            Move (Pos("/", sServer)) to iPos
32922>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
32923>>>>>>>        End
32923>>>>>>>>
32923>>>>>>>
32923>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
32924>>>>>>>        Decrement iSize
32925>>>>>>>        For iCount from 0 to iSize
32931>>>>>>>>
32931>>>>>>>            Move sDatabaseArray[iCount] to sVal
32932>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
32934>>>>>>>                Move True to bExists
32935>>>>>>>                If (bExists = True) Begin
32937>>>>>>>                    Move iSize to iCount // We're done.
32938>>>>>>>                End
32938>>>>>>>>
32938>>>>>>>            End
32938>>>>>>>>
32938>>>>>>>        Loop
32939>>>>>>>>
32939>>>>>>>
32939>>>>>>>        Function_Return bExists
32940>>>>>>>    End_Function
32941>>>>>>>
32941>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
32941>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
32943>>>>>>>        String sDatabase sSchema sTableName sVal
32943>>>>>>>        Boolean bExists
32943>>>>>>>        String[] sTablesArray
32944>>>>>>>        Integer iSize iCount
32944>>>>>>>
32944>>>>>>>        Move False to bExists
32945>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32946>>>>>>>        Get psDatabase to sDatabase
32947>>>>>>>        Get psSchema   to sSchema
32948>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
32949>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
32950>>>>>>>        Decrement iSize
32951>>>>>>>        For iCount from 0 to iSize
32957>>>>>>>>
32957>>>>>>>            Move sTablesArray[iCount] to sVal
32958>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
32960>>>>>>>                Move True to bExists
32961>>>>>>>                Move iSize to iCount // We're done!
32962>>>>>>>            End
32962>>>>>>>>
32962>>>>>>>        Loop
32963>>>>>>>>
32963>>>>>>>
32963>>>>>>>        Function_Return bExists
32964>>>>>>>    End_Function
32965>>>>>>>
32965>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
32967>>>>>>>        String sVal sTableSpelledCorrectly
32967>>>>>>>        Boolean bExists
32967>>>>>>>        String[] sTablesArray
32968>>>>>>>        Integer iSize iCount
32968>>>>>>>
32968>>>>>>>        Move False to bExists
32969>>>>>>>        Move sTableName to sTableSpelledCorrectly
32970>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
32971>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
32972>>>>>>>        Decrement iSize
32973>>>>>>>        For iCount from 0 to iSize
32979>>>>>>>>
32979>>>>>>>            Move sTablesArray[iCount] to sVal
32980>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
32982>>>>>>>                Move sVal to sTableSpelledCorrectly
32983>>>>>>>                Move iSize to iCount // We're done!
32984>>>>>>>            End
32984>>>>>>>>
32984>>>>>>>        Loop
32985>>>>>>>>
32985>>>>>>>
32985>>>>>>>        Function_Return sTableSpelledCorrectly
32986>>>>>>>    End_Function
32987>>>>>>>
32987>>>>>>>    // ToDo: This index name function needs to be finished...
32987>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
32989>>>>>>>        String sSchema sTableName sDriverID
32989>>>>>>>        Boolean bExists
32989>>>>>>>
32989>>>>>>>        Get psDriverID to sDriverID
32990>>>>>>>        Get psSchema to sSchema
32991>>>>>>>        Get UtilTableHandleToString hTable to sTableName
32992>>>>>>>
32992>>>>>>>        Function_Return bExists
32993>>>>>>>    End_Function
32994>>>>>>>
32994>>>>>>>    // Checks if a column/field name exists in a SQL table definition
32994>>>>>>>    // Returns True if it does
32994>>>>>>>    // Sample:
32994>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
32994>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
32996>>>>>>>        Integer iNumColumns iColumn
32996>>>>>>>        String sColumn sDriverID
32996>>>>>>>        String[] sColumnsArray
32997>>>>>>>        Boolean bExists bOK
32997>>>>>>>
32997>>>>>>>        Move False to bExists
32998>>>>>>>        Get AutoConnectionIDLogin to bOK
32999>>>>>>>        Get psDriverID to sDriverID
33000>>>>>>>
33000>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
33001>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
33002>>>>>>>        Decrement iNumColumns
33003>>>>>>>        For iColumn from 0 to iNumColumns
33009>>>>>>>>
33009>>>>>>>            Move sColumnsArray[iColumn] to sColumn
33010>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
33012>>>>>>>                Move True to bExists
33013>>>>>>>                Move iNumColumns to iColumn // We're out of here
33014>>>>>>>            End
33014>>>>>>>>
33014>>>>>>>        Loop
33015>>>>>>>>
33015>>>>>>>
33015>>>>>>>        Function_Return bExists
33016>>>>>>>    End_Function
33017>>>>>>>
33017>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
33019>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
33019>>>>>>>        Boolean bOpened bOK
33019>>>>>>>        String sColumnName sNativeTypeName
33019>>>>>>>
33019>>>>>>>        Get AutoConnectionIDLogin to bOK
33020>>>>>>>        Get OpenTableExclusive hTable to bOK
33021>>>>>>>        If (bOK = False) Begin
33023>>>>>>>            Function_Return False
33024>>>>>>>        End
33024>>>>>>>>
33024>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
33027>>>>>>>        If (bOpened = False) Begin
33029>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
33030>>>>>>>>
33030>>>>>>>            Function_Return False
33031>>>>>>>        End
33031>>>>>>>>
33031>>>>>>>
33031>>>>>>>        Move False to Err
33032>>>>>>>
33032>>>>>>>        Structure_Start hTable
33033>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
33036>>>>>>>
33036>>>>>>>            For iColumn from 1 to iNumColumns
33042>>>>>>>>
33042>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
33045>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
33048>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
33051>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
33054>>>>>>>
33054>>>>>>>                Case Begin
33054>>>>>>>                    Case (iDFType = DF_DATE)
33056>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
33058>>>>>>>                            // Convert datetime to date
33058>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
33061>>>>>>>                        End
33061>>>>>>>>
33061>>>>>>>                        Case Break
33062>>>>>>>                    Case (iDFType = DF_DATETIME)
33065>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
33067>>>>>>>                            // Convert datetime to datetime2
33067>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
33070>>>>>>>                        End
33070>>>>>>>>
33070>>>>>>>                        Case Break
33071>>>>>>>                    Case (iDFType = DF_ASCII)
33074>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
33076>>>>>>>                            // Convert char to varchar
33076>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
33079>>>>>>>                        End
33079>>>>>>>>
33079>>>>>>>                        Case Break
33080>>>>>>>                    Case (iDFType = DF_TEXT)
33083>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
33085>>>>>>>                            // Convert text to varchar(max)
33085>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
33088>>>>>>>                        End
33088>>>>>>>>
33088>>>>>>>                        Case Break
33089>>>>>>>                    Case (iDFType = DF_BINARY)
33092>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
33094>>>>>>>                            // Convert image to varbinary(max)
33094>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
33097>>>>>>>                        End
33097>>>>>>>>
33097>>>>>>>                        Case Break
33098>>>>>>>                Case End
33098>>>>>>>            Loop
33099>>>>>>>>
33099>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33100>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33102>>>>>>>
33102>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33103>>>>>>>        Function_Return (Err = False)
33104>>>>>>>    End_Function
33105>>>>>>>
33105>>>>>>>
33105>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
33105>>>>>>>    // the DbUpdateVersion database revision in.
33105>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
33105>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
33105>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
33107>>>>>>>        Boolean bOK bOpened
33107>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
33107>>>>>>>
33107>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
33110>>>>>>>        Get _TableNameOnly sTableName to sTableName
33111>>>>>>>        If (sTableName = "") Begin
33113>>>>>>>            Function_Return False
33114>>>>>>>        End
33114>>>>>>>>
33114>>>>>>>
33114>>>>>>>        // This just creates the table and a "dummy" column.
33114>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
33115>>>>>>>        If (bOK = False) Begin
33117>>>>>>>            Function_Return False
33118>>>>>>>        End
33118>>>>>>>>
33118>>>>>>>
33118>>>>>>>        Close hTable
33119>>>>>>>        Move False to Err
33120>>>>>>>
33120>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
33121>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
33122>>>>>>>        Move "Decimal" to sDataType
33123>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
33124>>>>>>>
33124>>>>>>>        // Adds the "sColumnName" passed to the function
33124>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
33125>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
33126>>>>>>>
33126>>>>>>>        // Now we can delete the dummy column:
33126>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
33127>>>>>>>
33127>>>>>>>        // Finally, we attach to the newly created table.
33127>>>>>>>        If (Err = False) Begin
33129>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
33130>>>>>>>        End
33130>>>>>>>>
33130>>>>>>>        Open hTable
33132>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
33135>>>>>>>
33135>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
33136>>>>>>>    End_Function
33137>>>>>>>
33137>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
33137>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
33137>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
33137>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
33137>>>>>>>    // column types.
33137>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
33139>>>>>>>        Handle hDatabase
33139>>>>>>>        Integer iDriver iServers iCount
33139>>>>>>>        String sValue
33139>>>>>>>
33139>>>>>>>        If (sServer = "") Begin
33141>>>>>>>            Function_Return 0
33142>>>>>>>        End
33142>>>>>>>>
33142>>>>>>>
33142>>>>>>>        Get DriverIndex sDriverID to iDriver
33143>>>>>>>        If (iDriver = 0) Begin
33145>>>>>>>            Function_Return 0
33146>>>>>>>        End
33146>>>>>>>>
33146>>>>>>>
33146>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
33149>>>>>>>        For iCount from 1 to iServers
33155>>>>>>>>
33155>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
33158>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
33160>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
33163>>>>>>>            End
33163>>>>>>>>
33163>>>>>>>        Loop
33164>>>>>>>>
33164>>>>>>>
33164>>>>>>>        Function_Return hDatabase
33165>>>>>>>    End_Function
33166>>>>>>>
33166>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
33166>>>>>>>//        String sRootName
33166>>>>>>>//        Boolean bOK
33166>>>>>>>//
33166>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
33166>>>>>>>//        Move (sRootName contains sDriverID) to bOK
33166>>>>>>>//
33166>>>>>>>//        Function_Return bOK
33166>>>>>>>//    End_Function
33166>>>>>>>
33166>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
33166>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
33166>>>>>>>//        Integer iDbType
33166>>>>>>>//        Boolean bOK
33166>>>>>>>//
33166>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
33166>>>>>>>//        If (bOK = True) Begin
33166>>>>>>>//            Function_Return False
33166>>>>>>>//        End
33166>>>>>>>//
33166>>>>>>>//        Get psDriverID to sDriverID
33166>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
33166>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
33166>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
33166>>>>>>>//
33166>>>>>>>//        Get psDriverID to sDriverID
33166>>>>>>>//        Get piDbType   to iDbType
33166>>>>>>>//        Get psSchema   to sSchema
33166>>>>>>>//        If (sSchema = "") Begin
33166>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
33166>>>>>>>//        End
33166>>>>>>>//
33166>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
33166>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
33166>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
33166>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
33166>>>>>>>//            End
33166>>>>>>>//            Else Begin
33166>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
33166>>>>>>>//            End
33166>>>>>>>//        End
33166>>>>>>>//
33166>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
33166>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
33166>>>>>>>//
33166>>>>>>>//        Function_Return True
33166>>>>>>>//    End_Function
33166>>>>>>>
33166>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
33166>>>>>>>    // from the passed filelist.
33166>>>>>>>    // Returns the number of tables affected.
33166>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
33168>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
33168>>>>>>>        Integer iRetval
33168>>>>>>>        Handle hTable
33168>>>>>>>
33168>>>>>>>        // We first save the current filelist as the passed filelist name
33168>>>>>>>        // may come from another workspace, to restore it when we're ready.
33168>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
33171>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
33174>>>>>>>        Move 0 to hTable
33175>>>>>>>        Move 0 to iRetval
33176>>>>>>>
33176>>>>>>>        Repeat
33176>>>>>>>>
33176>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33179>>>>>>>            If (hTable <> 0) Begin
33181>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
33184>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
33187>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
33190>>>>>>>                Move (Uppercase(sRootName)) to sVal
33191>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
33193>>>>>>>                    // Prefixes:
33193>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
33194>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
33195>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
33196>>>>>>>                    // Suffixes:
33196>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
33197>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
33198>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
33199>>>>>>>
33199>>>>>>>                    // Change Filelist entry:
33199>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
33202>>>>>>>
33202>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
33203>>>>>>>                    If (sVal contains "dbo.") Begin
33205>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
33206>>>>>>>
33206>>>>>>>                        // Change Filelist entry:
33206>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
33209>>>>>>>                    End
33209>>>>>>>>
33209>>>>>>>                    Increment iRetval
33210>>>>>>>                End
33210>>>>>>>>
33210>>>>>>>            End
33210>>>>>>>>
33210>>>>>>>        Until (hTable = 0)
33212>>>>>>>
33212>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
33215>>>>>>>
33215>>>>>>>        Function_Return iRetval
33216>>>>>>>    End_Function
33217>>>>>>>
33217>>>>>>>    // To open all Sql based tables in Filelist.cfg
33217>>>>>>>    Procedure SqlUtilOpenAllTables
33219>>>>>>>        Handle hTable
33219>>>>>>>        String sRoot sDriverID
33219>>>>>>>        Boolean bOK
33219>>>>>>>
33219>>>>>>>        Move 0 to hTable
33220>>>>>>>        Move "" to sDriverID
33221>>>>>>>        Get AutoConnectionIDLogin to bOK
33222>>>>>>>
33222>>>>>>>        Repeat
33222>>>>>>>>
33222>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33225>>>>>>>            If (hTable > 0) Begin
33227>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
33230>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
33232>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
33235>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
33237>>>>>>>                        Open hTable
33239>>>>>>>                    End
33239>>>>>>>>
33239>>>>>>>                End
33239>>>>>>>>
33239>>>>>>>            End
33239>>>>>>>>
33239>>>>>>>
33239>>>>>>>        Until (hTable = 0)
33241>>>>>>>    End_Procedure
33242>>>>>>>
33242>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
33242>>>>>>>//        String sRetval sDriverID
33242>>>>>>>//        String sTableName
33242>>>>>>>//        Integer iDbType iIndex
33242>>>>>>>//        Boolean bOK
33242>>>>>>>//
33242>>>>>>>//        Get psDriverID to sDriverID
33242>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
33242>>>>>>>//        If (hTable = 0 or bOK = False) Begin
33242>>>>>>>//            Function_Return ""
33242>>>>>>>//        End
33242>>>>>>>//
33242>>>>>>>//        Move False to Err
33242>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
33242>>>>>>>//        Get piDbType to iDbType
33242>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
33242>>>>>>>//        If (iIndex = -1) Begin
33242>>>>>>>//            Function_Return ""
33242>>>>>>>//        End
33242>>>>>>>//
33242>>>>>>>//        Function_Return sRetval
33242>>>>>>>//    End_Function
33242>>>>>>>
33242>>>>>>>    // Checks if the passed Table;
33242>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
33242>>>>>>>    // 2) It has an .int file.
33242>>>>>>>    // If both is True it should already be connected to SQL
33242>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
33244>>>>>>>        Boolean bExists bRootName
33244>>>>>>>        String sRootName sDataPath
33244>>>>>>>
33244>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
33247>>>>>>>        Move (sRootName contains sDriverID) to bRootName
33248>>>>>>>
33248>>>>>>>        Get psDataPathFirstPart to sDataPath
33249>>>>>>>        Get vFolderExists sDataPath to bExists
33250>>>>>>>        If (bExists = False) Begin
33252>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
33252>>>>>>>            Function_Return False
33253>>>>>>>        End
33253>>>>>>>>
33253>>>>>>>
33253>>>>>>>        Get vFolderFormat sDataPath to sDataPath
33254>>>>>>>        Get _TableNameOnly sRootName to sRootName
33255>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
33256>>>>>>>
33256>>>>>>>        Function_Return (bRootName = True and bExists = True)
33257>>>>>>>    End_Function
33258>>>>>>>
33258>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
33260>>>>>>>        Boolean bViewTableType bOpen bOK
33260>>>>>>>        Integer iTableCount iNumTables
33260>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
33260>>>>>>>        Handle hoCliHandler
33260>>>>>>>        tSQLConnection SQLConnection
33260>>>>>>>        tSQLConnection SQLConnection
33260>>>>>>>
33260>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
33263>>>>>>>        If (bOpen = False) Begin
33265>>>>>>>            Get AutoConnectionIDLogin to bOK
33266>>>>>>>            Open hTable
33268>>>>>>>        End
33268>>>>>>>>
33268>>>>>>>
33268>>>>>>>        Get pSQLConnection to SQLConnection
33269>>>>>>>        Get phoCLIHandler to hoCliHandler
33270>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
33271>>>>>>>
33271>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
33274>>>>>>>        Get _TableNameOnly sTableName to sTableName
33275>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
33278>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
33279>>>>>>>
33279>>>>>>>        For iTableCount from 1 to iNumTables
33285>>>>>>>>
33285>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
33286>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
33287>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
33289>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
33290>>>>>>>                Move iNumTables to iTableCount // We're done.
33291>>>>>>>            End
33291>>>>>>>>
33291>>>>>>>        Loop
33292>>>>>>>>
33292>>>>>>>
33292>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
33293>>>>>>>        If (bOpen = False) Begin
33295>>>>>>>            Close hTable
33296>>>>>>>        End
33296>>>>>>>>
33296>>>>>>>
33296>>>>>>>        Function_Return bViewTableType
33297>>>>>>>    End_Function
33298>>>>>>>
33298>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
33298>>>>>>>    //
33298>>>>>>>    // SQL utility function that returns a database type (string) constant
33298>>>>>>>    // corresponding to the passed iDbType.
33298>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
33300>>>>>>>        String sRetval
33300>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
33301>>>>>>>        Function_Return sRetval
33302>>>>>>>    End_Function
33303>>>>>>>
33303>>>>>>>    // SQL utility function that returns a database type constant (integer)
33303>>>>>>>    // corresponding to the passed sDbType string constant.
33303>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
33305>>>>>>>        Integer iRetval
33305>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
33306>>>>>>>        Function_Return iRetval
33307>>>>>>>    End_Function
33308>>>>>>>
33308>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
33308>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
33308>>>>>>>    // the SQL Connection program's grid.
33308>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
33310>>>>>>>        String sRetval
33310>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
33311>>>>>>>        Function_Return sRetval
33312>>>>>>>    End_Function
33313>>>>>>>
33313>>>>>>>    // Pass a driver name as a string and the function will return
33313>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
33313>>>>>>>    // quite work and always returns "MS SQL Server"
33313>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
33315>>>>>>>        Integer iRetval
33315>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
33316>>>>>>>        Function_Return iRetval
33317>>>>>>>    End_Function
33318>>>>>>>
33318>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
33318>>>>>>>    // that "fits" in the max allowed length for table names.
33318>>>>>>>    // Max number of characters allowed for table names;
33318>>>>>>>    // IBM DB2      = 128
33318>>>>>>>    // MS-SQL       = 128
33318>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
33318>>>>>>>    // MySQL        = 64
33318>>>>>>>    // PostgreSQL   = 64
33318>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
33320>>>>>>>        String sGUIDName
33320>>>>>>>        Integer iDbType iLength
33320>>>>>>>
33320>>>>>>>        Get piDbType to iDbType
33321>>>>>>>        Move (RandomHexUUID()) to sGUIDName
33322>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
33323>>>>>>>        Move (Length(sGUIDName)) to iLength
33324>>>>>>>
33324>>>>>>>        Case Begin
33324>>>>>>>            Case (iDbType = EN_DbTypeDB2)
33326>>>>>>>            If (iLength > 128) Begin
33328>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
33329>>>>>>>            End
33329>>>>>>>>
33329>>>>>>>            Case Break
33330>>>>>>>
33330>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
33333>>>>>>>            If (iLength > 128) Begin
33335>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
33336>>>>>>>            End
33336>>>>>>>>
33336>>>>>>>            Case Break
33337>>>>>>>
33337>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
33340>>>>>>>            If (iLength > 128) Begin
33342>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
33343>>>>>>>            End
33343>>>>>>>>
33343>>>>>>>            Case Break
33344>>>>>>>
33344>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
33347>>>>>>>            If (iLength > 64) Begin
33349>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
33350>>>>>>>            End
33350>>>>>>>>
33350>>>>>>>            Case Break
33351>>>>>>>
33351>>>>>>>            Case (iDbType = EN_DbTypePostgre)
33354>>>>>>>            If (iLength > 64) Begin
33356>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
33357>>>>>>>            End
33357>>>>>>>>
33357>>>>>>>        Case End
33357>>>>>>>
33357>>>>>>>        Function_Return sGUIDName
33358>>>>>>>    End_Function
33359>>>>>>>
33359>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
33359>>>>>>>    // Pass the memory resource file reference and the filename to be created,
33359>>>>>>>    // including full path.
33359>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
33361>>>>>>>        String sText
33361>>>>>>>        Integer iCh iSize iArgSize
33361>>>>>>>
33361>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
33362>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
33363>>>>>>>        Get_Channel_Size iCh to iSize
33364>>>>>>>        Read_Block channel iCh sText iSize
33366>>>>>>>        Send Seq_Close_Channel iCh
33367>>>>>>>
33367>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
33368>>>>>>>            Write channel iCh sText
33370>>>>>>>        Send Seq_Close_Channel iCh
33371>>>>>>>
33371>>>>>>>        // Wait for file to be written to disk.
33371>>>>>>>        Sleep 2
33372>>>>>>>    End_Procedure
33373>>>>>>>
33373>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
33375>>>>>>>        String sNotNull sRetval sDefaultValue
33375>>>>>>>        Boolean bOK
33375>>>>>>>
33375>>>>>>>        Get IsSQLDriver sDriverID to bOK
33376>>>>>>>        If (bOK = False) Begin
33378>>>>>>>            Function_Return ""
33379>>>>>>>        End
33379>>>>>>>>
33379>>>>>>>
33379>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
33380>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
33381>>>>>>>
33381>>>>>>>        Case Begin
33381>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
33383>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
33384>>>>>>>                Case Break
33385>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
33388>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
33389>>>>>>>                Case Break
33390>>>>>>>            Case (iDbType = EN_dbTypePostgre)
33393>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
33394>>>>>>>                Case Break
33395>>>>>>>            Case (iDbType = EN_dbTypeDB2)
33398>>>>>>>                Move (String(sNotNull))                                     to sRetval
33399>>>>>>>                Case Break
33400>>>>>>>
33400>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
33400>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
33400>>>>>>>            Case (iDbType = EN_dbTypeOracle)
33403>>>>>>>                Move  ""                                                    to sRetval
33404>>>>>>>                Case Break
33405>>>>>>>
33405>>>>>>>            Case Else
33405>>>>>>>                Move  ""                                                    to sRetval
33406>>>>>>>        Case End
33406>>>>>>>
33406>>>>>>>        Function_Return sRetval
33407>>>>>>>    End_Function
33408>>>>>>>
33408>>>>>>>    // * Dummy function for the Studio's Code Explorer *
33408>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
33410>>>>>>>        Function_Return False
33411>>>>>>>    End_Function
33412>>>>>>>
33412>>>>>>>    // Enumerate SQL Servers.
33412>>>>>>>    // Pass a driver id. Returns a string array.
33412>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
33412>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
33412>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
33414>>>>>>>        String[] sReturnArray
33415>>>>>>>        Handle hoSQLHandler
33415>>>>>>>        String sServer
33415>>>>>>>        Integer iCount iNumItems iDataSourceType
33415>>>>>>>
33415>>>>>>>        If (num_arguments > 1) Begin
33417>>>>>>>            Move iDatSrcType to iDataSourceType
33418>>>>>>>        End
33418>>>>>>>>
33418>>>>>>>
33418>>>>>>>        Case Begin
33418>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
33420>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
33421>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
33422>>>>>>>                For iCount from 0 to (iNumItems - 1)
33428>>>>>>>>
33428>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
33429>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
33430>>>>>>>                Loop
33431>>>>>>>>
33431>>>>>>>                Case Break
33432>>>>>>>
33432>>>>>>>            Case (sDriverID = DB2_DRV_ID)
33435>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
33436>>>>>>>                Send SeedDataSources of hoSQLHandler
33437>>>>>>>                Move 0 to iCount
33438>>>>>>>                Repeat
33438>>>>>>>>
33438>>>>>>>                    Get DataSources of hoSQLHandler to sServer
33439>>>>>>>                    If (sServer <> "") Begin
33441>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
33442>>>>>>>                        Move sServer to sReturnArray[iCount]
33443>>>>>>>                    End
33443>>>>>>>>
33443>>>>>>>                    Increment iCount
33444>>>>>>>                Until (sServer = "")
33446>>>>>>>                Case Break
33447>>>>>>>
33447>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
33450>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
33451>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
33452>>>>>>>                Move 0 to iCount
33453>>>>>>>                Repeat
33453>>>>>>>>
33453>>>>>>>                    Get DataSources of hoSQLHandler to sServer
33454>>>>>>>                    If (sServer <> "") Begin
33456>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
33457>>>>>>>                        Move sServer to sReturnArray[iCount]
33458>>>>>>>                    End
33458>>>>>>>>
33458>>>>>>>                    Increment iCount
33459>>>>>>>                Until (sServer = "")
33461>>>>>>>                Case Break
33462>>>>>>>
33462>>>>>>>            Case Else
33462>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
33463>>>>>>>>
33463>>>>>>>        Case End
33463>>>>>>>
33463>>>>>>>        Function_Return sReturnArray
33464>>>>>>>    End_Function
33465>>>>>>>
33465>>>>>>>    // Returns all databases as a string array for the passed driver id.
33465>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
33467>>>>>>>        String[] sReturnArray
33468>>>>>>>        String sServer sVal
33468>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
33468>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
33469>>>>>>>        tSQLConnection SQLConnection
33469>>>>>>>        tSQLConnection SQLConnection
33469>>>>>>>        Boolean bOK
33469>>>>>>>        Integer iCount iSize
33469>>>>>>>
33469>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
33470>>>>>>>        If (bOK = False) Begin
33472>>>>>>>            Function_Return sReturnArray
33473>>>>>>>        End
33473>>>>>>>>
33473>>>>>>>
33473>>>>>>>        Case Begin
33473>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
33475>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
33476>>>>>>>                Case Break
33477>>>>>>>            Case (sDriverID = DB2_DRV_ID)
33480>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
33481>>>>>>>                Case Break
33482>>>>>>>
33482>>>>>>>            // This is needed to be able to check if a database exists or not.
33482>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
33485>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
33486>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
33488>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
33490>>>>>>>                        // If a FILEDSN: (can only be one database name)
33490>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
33491>>>>>>>                    End
33491>>>>>>>>
33491>>>>>>>                    Else Begin
33492>>>>>>>                        // Else the DSN's were read from the registry.
33492>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
33493>>>>>>>                        Move SQLConnection.sServer to sServer
33494>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
33495>>>>>>>                        Decrement iSize
33496>>>>>>>                        for iCount from 0 to iSize
33502>>>>>>>>
33502>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
33503>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
33505>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
33506>>>>>>>                                Move iSize to iCount // We're done.
33507>>>>>>>                            End
33507>>>>>>>>
33507>>>>>>>                        Loop
33508>>>>>>>>
33508>>>>>>>                    End
33508>>>>>>>>
33508>>>>>>>                End
33508>>>>>>>>
33508>>>>>>>                Case Break
33509>>>>>>>
33509>>>>>>>            Case Else
33509>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
33509>>>>>>>        Case End
33509>>>>>>>
33509>>>>>>>        Function_Return sReturnArray
33510>>>>>>>    End_Function
33511>>>>>>>
33511>>>>>>>    
33511>>>>>>>    // *** Database API Functions: ***
33511>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
33511>>>>>>>    // make changes/updates to the database.
33511>>>>>>>
33511>>>>>>>    // * Dummy function for the Studio's Code Explorer *
33511>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
33513>>>>>>>        Function_Return False
33514>>>>>>>    End_Function
33515>>>>>>>
33515>>>>>>>    // This might not do what you think - Here's what it does:
33515>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
33515>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
33515>>>>>>>    // to the SQL table.
33515>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
33515>>>>>>>    // already exists in SQL.
33515>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
33515>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
33515>>>>>>>    // restructuring an existing table.
33515>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
33517>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
33517>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
33517>>>>>>>        Handle hToTable
33517>>>>>>>
33517>>>>>>>        Move True to bUseConnectionID
33518>>>>>>>        If (num_arguments > 1) Begin
33520>>>>>>>            Move bUseConnID to bUseConnectionID
33521>>>>>>>        End
33521>>>>>>>>
33521>>>>>>>
33521>>>>>>>        Get psDriverID to sDriverID
33522>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
33522>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
33523>>>>>>>        If (bExists = False) Begin
33525>>>>>>>            Function_Return False
33526>>>>>>>        End
33526>>>>>>>>
33526>>>>>>>
33526>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
33527>>>>>>>
33527>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
33528>>>>>>>        If (bOK = False) Begin
33530>>>>>>>            Function_Return False
33531>>>>>>>        End
33531>>>>>>>>
33531>>>>>>>
33531>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
33531>>>>>>>        // we do nothing
33531>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
33532>>>>>>>        If (bExists = True) Begin
33534>>>>>>>            Function_Return False
33535>>>>>>>        End
33535>>>>>>>>
33535>>>>>>>
33535>>>>>>>        Get psConnectionID     to sConnectionID
33536>>>>>>>        Get psConnectionString to sConnectionString
33537>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
33539>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
33540>>>>>>>>
33540>>>>>>>            Function_Return False
33541>>>>>>>        End
33541>>>>>>>>
33541>>>>>>>
33541>>>>>>>        Set Private.phCurrentTable to hTable
33542>>>>>>>        Get psSchema to sSchema
33543>>>>>>>        If (sSchema = "") Begin
33545>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
33546>>>>>>>        End
33546>>>>>>>>
33546>>>>>>>
33546>>>>>>>        // If we should use a connection id we need to check it exists;
33546>>>>>>>        // else we create it before attempting creating the table
33546>>>>>>>        If (bUseConnectionID = True) Begin
33548>>>>>>>            Get AutoConnectionIDLogin to bOK
33549>>>>>>>            If (bOk = False) Begin
33551>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
33552>>>>>>>>
33552>>>>>>>                Function_Return False
33553>>>>>>>            End
33553>>>>>>>>
33553>>>>>>>        End
33553>>>>>>>>
33553>>>>>>>
33553>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
33556>>>>>>>        Get _TableNameOnly sRootName to sRootName
33557>>>>>>>        If (sRootName = "") Begin
33559>>>>>>>            Function_Return False
33560>>>>>>>        End
33560>>>>>>>>
33560>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
33561>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
33564>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
33567>>>>>>>
33567>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
33567>>>>>>>        //
33567>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
33567>>>>>>>        // because then the table should not be visible to users.
33567>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
33567>>>>>>>//        If (iPos <> 1) Begin
33567>>>>>>>//            If (sDisplayName contains ".") Begin
33567>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
33567>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
33567>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
33567>>>>>>>//            End
33567>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
33567>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
33567>>>>>>>//            End
33567>>>>>>>//        End
33567>>>>>>>
33567>>>>>>>        If (bIsAlias = False) Begin
33569>>>>>>>            Get OpenTableExclusive hTable to bOpened
33570>>>>>>>            If (bOpened = False) Begin
33572>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
33573>>>>>>>>
33573>>>>>>>                Function_Return False
33574>>>>>>>            End
33574>>>>>>>>
33574>>>>>>>        End
33574>>>>>>>>
33574>>>>>>>
33574>>>>>>>        If (ghoProgressBar <> 0) Begin
33576>>>>>>>            Send DoAdvance of ghoProgressBar
33577>>>>>>>            Set Message_Text of ghoStatusPanel to ""
33578>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
33579>>>>>>>        End
33579>>>>>>>>
33579>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
33579>>>>>>>        Move hTable to hToTable
33580>>>>>>>        Move False to Err
33581>>>>>>>
33581>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
33581>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
33581>>>>>>>        // a proper and updated .int file.
33581>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
33584>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
33585>>>>>>>
33585>>>>>>>        If (bIsAlias = False) Begin
33587>>>>>>>            Structure_Start hToTable sDriverID
33588>>>>>>>                Set Private.phCurrentTable to hTable
33589>>>>>>>                If (bUseConnectionID = True) Begin
33591>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
33594>>>>>>>                End
33594>>>>>>>>
33594>>>>>>>                Else Begin
33595>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
33598>>>>>>>                End
33598>>>>>>>>
33598>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
33601>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
33601>>>>>>>                Move False to Err
33602>>>>>>>                Move 0 to LastErr
33603>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
33604>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33606>>>>>>>            Set Action_Text of ghoStatusPanel to ""
33607>>>>>>>        End
33607>>>>>>>>
33607>>>>>>>
33607>>>>>>>        Move (not(Err)) to bOK
33608>>>>>>>        If (bOK = True) Begin
33610>>>>>>>            // The attributes set above will always trigger an error
33610>>>>>>>            // We also adjust the Filelist entries
33610>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
33613>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
33616>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
33619>>>>>>>
33619>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
33619>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
33620>>>>>>>        End
33620>>>>>>>>
33620>>>>>>>
33620>>>>>>>        Function_Return (bOK = True)
33621>>>>>>>    End_Function
33622>>>>>>>
33622>>>>>>>    // Sample usage:
33622>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
33622>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
33622>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
33624>>>>>>>        Boolean bOK bIsSQLTable
33624>>>>>>>
33624>>>>>>>        Get AutoConnectionIDLogin to bOK
33625>>>>>>>        Move False to Err
33626>>>>>>>        Get OpenTableExclusive hTable to bOK
33627>>>>>>>        If (bOK = False) Begin
33629>>>>>>>            Function_Return False
33630>>>>>>>        End
33630>>>>>>>>
33630>>>>>>>
33630>>>>>>>        // ToDo: Add to all table change functions!
33630>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
33631>>>>>>>            If (bIsSQLTable = True) Begin
33633>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33636>>>>>>>            End
33636>>>>>>>>
33636>>>>>>>
33636>>>>>>>        Set Private.phCurrentTable to hTable
33637>>>>>>>        Structure_Start hTable
33638>>>>>>>            Set_Attribute iAttribute of hTable to iValue
33641>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33642>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33644>>>>>>>
33644>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33645>>>>>>>        Function_Return (Err = False)
33646>>>>>>>    End_Function
33647>>>>>>>
33647>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
33649>>>>>>>        Boolean bOK
33649>>>>>>>        
33649>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
33650>>>>>>>        If (bOK = True) Begin
33652>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
33653>>>>>>>        End
33653>>>>>>>>
33653>>>>>>>        
33653>>>>>>>        Function_Return (bOK = True)
33654>>>>>>>    End_Function
33655>>>>>>>    
33655>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
33655>>>>>>>    // or to change the filelist slot names.
33655>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
33657>>>>>>>        String sFileListName
33657>>>>>>>        
33657>>>>>>>        Move False to Err
33658>>>>>>>
33658>>>>>>>        If (ghoProgressBar <> 0) Begin
33660>>>>>>>            Send DoAdvance of ghoProgressBar
33661>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
33662>>>>>>>        End
33662>>>>>>>>
33662>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
33662>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
33664>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
33667>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
33670>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
33673>>>>>>>            Function_Return (Err = False) // And we're done.
33674>>>>>>>        End
33674>>>>>>>>
33674>>>>>>>
33674>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
33676>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
33676>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
33677>>>>>>>        End
33677>>>>>>>>
33677>>>>>>>//        Else Begin
33677>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
33677>>>>>>>//        End
33677>>>>>>>//
33677>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
33677>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
33677>>>>>>>
33677>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
33680>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
33683>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
33686>>>>>>>        
33686>>>>>>>        Function_Return (Err = False)
33687>>>>>>>    End_Function
33688>>>>>>>
33688>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
33690>>>>>>>        Boolean bOK
33690>>>>>>>
33690>>>>>>>        Get AutoConnectionIDLogin to bOK
33691>>>>>>>        Move False to Err
33692>>>>>>>        Get OpenTableExclusive hTable to bOK
33693>>>>>>>        If (bOK = False) Begin
33695>>>>>>>            Function_Return False
33696>>>>>>>        End
33696>>>>>>>>
33696>>>>>>>
33696>>>>>>>        Set Private.phCurrentTable to hTable
33697>>>>>>>        Structure_Start hTable
33698>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
33701>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33702>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33704>>>>>>>
33704>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33705>>>>>>>        Function_Return (Err = False)
33706>>>>>>>    End_Function
33707>>>>>>>
33707>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
33709>>>>>>>        Boolean bOK bIsSQLTable
33709>>>>>>>
33709>>>>>>>        Move False to Err
33710>>>>>>>        Get AutoConnectionIDLogin to bOK
33711>>>>>>>        Open hToTable
33713>>>>>>>        Get OpenTableExclusive hTable to bOK
33714>>>>>>>        If (bOK = False) Begin
33716>>>>>>>            Function_Return False
33717>>>>>>>        End
33717>>>>>>>>
33717>>>>>>>
33717>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
33718>>>>>>>            If (bIsSQLTable = True) Begin
33720>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
33723>>>>>>>            End
33723>>>>>>>>
33723>>>>>>>
33723>>>>>>>        Set Private.phCurrentTable to hTable
33724>>>>>>>        Structure_Start hTable
33725>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
33728>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
33731>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33732>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33734>>>>>>>
33734>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33735>>>>>>>        Function_Return (Err = False)
33736>>>>>>>    End_Function
33737>>>>>>>
33737>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
33739>>>>>>>        Integer[] aTableConvertExceptions
33740>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
33741>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
33742>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
33743>>>>>>>    End_Procedure
33744>>>>>>>
33744>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
33746>>>>>>>        Integer[] aTableDateCorrectionExceptions
33747>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
33748>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
33749>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
33750>>>>>>>    End_Procedure
33751>>>>>>>
33751>>>>>>>    Procedure ApiTableConvertALLToSql
33753>>>>>>>        Integer[] iTablesArray
33754>>>>>>>        Integer iSize iCount
33754>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
33754>>>>>>>        String sDriverID
33754>>>>>>>
33754>>>>>>>        Get psDriverID to sDriverID
33755>>>>>>>        Get pbUseConnectionID to bUseConnectionID
33756>>>>>>>        Get pbToANSI          to bToANSI
33757>>>>>>>        Get pbRecnum          to bRecnum
33758>>>>>>>        Get pbCopyData        to bCopyData
33759>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
33761>>>>>>>            Get pbContinueOnError to bContinueOnError
33762>>>>>>>        End
33762>>>>>>>>
33762>>>>>>>
33762>>>>>>>        Get _AllTablesToConvert to iTablesArray
33763>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
33764>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
33765>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
33766>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
33767>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
33768>>>>>>>
33768>>>>>>>        Decrement iSize
33769>>>>>>>        For iCount from 0 to iSize
33775>>>>>>>>
33775>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
33776>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
33777>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
33777>>>>>>>            // if there was an error converting one table...
33777>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
33777>>>>>>>        Loop
33778>>>>>>>>
33778>>>>>>>
33778>>>>>>>    End_Procedure
33779>>>>>>>
33779>>>>>>>    Procedure ApiTableAttachALLToSql
33781>>>>>>>        Integer[] iTablesArray
33782>>>>>>>        Integer iSize iCount
33782>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
33782>>>>>>>        String sDriverID
33782>>>>>>>
33782>>>>>>>        Get psDriverID to sDriverID
33783>>>>>>>        Get pbUseConnectionID to bUseConnectionID
33784>>>>>>>        Get pbToANSI          to bToANSI
33785>>>>>>>        Get pbRecnum          to bRecnum
33786>>>>>>>        Get pbCopyData        to bCopyData
33787>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
33789>>>>>>>            Get pbContinueOnError to bContinueOnError
33790>>>>>>>        End
33790>>>>>>>>
33790>>>>>>>
33790>>>>>>>        Get _AllTablesToConvert to iTablesArray
33791>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
33792>>>>>>>        Decrement iSize
33793>>>>>>>        For iCount from 0 to iSize
33799>>>>>>>>
33799>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
33800>>>>>>>        Loop
33801>>>>>>>>
33801>>>>>>>
33801>>>>>>>    End_Procedure
33802>>>>>>>
33802>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
33804>>>>>>>        Handle hToTable hoLogFile
33804>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
33804>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
33804>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
33804>>>>>>>        tSQLConnection SQLConnection
33804>>>>>>>        tSQLConnection SQLConnection
33804>>>>>>>
33804>>>>>>>        Get _UtilTableExists hTable to bExists
33805>>>>>>>        If (bExists = False) Begin
33807>>>>>>>            Set Private.phCurrentTable to hTable
33808>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
33809>>>>>>>>
33809>>>>>>>            Function_Return False
33810>>>>>>>        End
33810>>>>>>>>
33810>>>>>>>
33810>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
33811>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
33811>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
33811>>>>>>>        If (bIsAlias = True) Begin
33813>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
33816>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
33818>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
33821>>>>>>>                Get psConnectionID to sConnectionID
33822>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
33823>>>>>>>            End
33823>>>>>>>>
33823>>>>>>>            Function_Return True
33824>>>>>>>        End
33824>>>>>>>>
33824>>>>>>>
33824>>>>>>>        Set Private.phCurrentTable to hTable
33825>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
33828>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
33831>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
33834>>>>>>>
33834>>>>>>>        If (ghoProgressBar <> 0) Begin
33836>>>>>>>            Send DoAdvance of ghoProgressBar
33837>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
33838>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
33839>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
33840>>>>>>>        End
33840>>>>>>>>
33840>>>>>>>
33840>>>>>>>        // Marco Kuipers suggestion;
33840>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
33840>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
33840>>>>>>>        // SQL table.
33840>>>>>>>        Get _UtilTableIsSql hTable to bOK
33841>>>>>>>        If (bOK = False) Begin
33843>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
33844>>>>>>>            If (bExists = True) Begin
33846>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
33846>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
33846>>>>>>>                Get phoLogFile to hoLogFile
33847>>>>>>>                If (hoLogFile <> 0) Begin          
33849>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
33850>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
33850>>>>>>>                    Send LogError sWarning False
33851>>>>>>>                End
33851>>>>>>>>
33851>>>>>>>                Else Begin
33852>>>>>>>                    Error DFERR_PROGRAM sWarning
33853>>>>>>>>
33853>>>>>>>                End                                                       
33853>>>>>>>>
33853>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
33854>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
33855>>>>>>>            End
33855>>>>>>>>
33855>>>>>>>        End
33855>>>>>>>>
33855>>>>>>>
33855>>>>>>>        // Does the rootname contain a driver?
33855>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
33857>>>>>>>            // Does the table already exist as an SQL table?
33857>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
33858>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
33858>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
33858>>>>>>>            If (bExists = False) Begin
33860>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
33861>>>>>>>            End
33861>>>>>>>>
33861>>>>>>>            If (bExists = True) Begin
33863>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
33864>>>>>>>                Function_Return False
33865>>>>>>>            End
33865>>>>>>>>
33865>>>>>>>        End
33865>>>>>>>>
33865>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
33866>>>>>>>
33866>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
33867>>>>>>>        If (bUseConnectionID = True) Begin
33869>>>>>>>            Move False to bUseConnectionID
33870>>>>>>>        End
33870>>>>>>>>
33870>>>>>>>
33870>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
33871>>>>>>>        Move SQLConnection.sSchema           to sSchema
33872>>>>>>>        If (sSchema = "") Begin
33874>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
33875>>>>>>>            Move (Lowercase(sSchema))        to sSchema
33876>>>>>>>        End
33876>>>>>>>>
33876>>>>>>>
33876>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
33877>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
33878>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
33879>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
33881>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
33882>>>>>>>>
33882>>>>>>>            Function_Return False
33883>>>>>>>        End
33883>>>>>>>>
33883>>>>>>>
33883>>>>>>>        Get AutoConnectionIDLogin to bOK
33884>>>>>>>        Open hTable
33886>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
33889>>>>>>>        If (bOpened = False) Begin
33891>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
33892>>>>>>>>
33892>>>>>>>            Function_Return False
33893>>>>>>>        End
33893>>>>>>>>
33893>>>>>>>
33893>>>>>>>        If (ghoProgressBar <> 0) Begin
33895>>>>>>>            Send DoAdvance of ghoProgressBar
33896>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
33897>>>>>>>        End
33897>>>>>>>>
33897>>>>>>>
33897>>>>>>>        Move 0 to hToTable
33898>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
33899>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
33900>>>>>>>
33900>>>>>>>        Case Begin
33900>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
33902>>>>>>>                Case Break
33903>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
33906>>>>>>>                Case Break
33907>>>>>>>            Case (sDriverID = DB2_DRV_ID)
33910>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
33911>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
33912>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
33913>>>>>>>                Case Break
33914>>>>>>>            Case (sDriverID = DATAFLEX_ID)
33917>>>>>>>                Case Break
33918>>>>>>>            Case Else
33918>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
33919>>>>>>>>
33919>>>>>>>                Case Break
33920>>>>>>>        Case End
33920>>>>>>>
33920>>>>>>>        Move False to Err
33921>>>>>>>
33921>>>>>>>        Structure_Start hToTable sDriverID
33922>>>>>>>            Structure_Copy hTable to hToTable
33923>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
33926>>>>>>>
33926>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
33928>>>>>>>                If (bUseConnectionID = True) Begin
33930>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
33933>>>>>>>                End
33933>>>>>>>>
33933>>>>>>>                Else Begin
33934>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
33937>>>>>>>                End
33937>>>>>>>>
33937>>>>>>>
33937>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
33940>>>>>>>
33940>>>>>>>                If (sSchema <> "") Begin
33942>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
33945>>>>>>>                End
33945>>>>>>>>
33945>>>>>>>
33945>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
33947>>>>>>>                    If (sLongTableSpace <> "") Begin
33949>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
33952>>>>>>>                    End
33952>>>>>>>>
33952>>>>>>>                    If (sBaseTableSpace <> "") Begin
33954>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
33957>>>>>>>                    End
33957>>>>>>>>
33957>>>>>>>                    If (sIndexTableSpace <> "") Begin
33959>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
33962>>>>>>>                    End
33962>>>>>>>>
33962>>>>>>>                End
33962>>>>>>>>
33962>>>>>>>            End
33962>>>>>>>>
33962>>>>>>>
33962>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
33963>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33965>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33966>>>>>>>
33966>>>>>>>        Move (not(Err)) to bOK
33967>>>>>>>
33967>>>>>>>        If (bOK = True and bCopyData = True) Begin
33969>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
33970>>>>>>>
33970>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
33972>>>>>>>                Get pbContinueOnError to bContinueOnError
33973>>>>>>>            End
33973>>>>>>>>
33973>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
33973>>>>>>>            // rename it by adding a GUID to the end of the table name
33973>>>>>>>            // - or as much as "fit" because different SQL back-ends have
33973>>>>>>>            // different rules how long a table name can be.
33973>>>>>>>            // The new table will probably contain data but something went
33973>>>>>>>            // wrong while converting the data from embedded to SQL.
33973>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
33975>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
33976>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
33977>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
33978>>>>>>>>
33978>>>>>>>            End
33978>>>>>>>>
33978>>>>>>>        End
33978>>>>>>>>
33978>>>>>>>
33978>>>>>>>        // This must be after copying data...
33978>>>>>>>        If (Err = False) Begin
33980>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
33983>>>>>>>            // It seems the Studio does not do this any more, so commented out.
33983>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
33983>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
33983>>>>>>>            //                // The max length for the display_name is 31 characters...
33983>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
33983>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
33983>>>>>>>            //                End
33983>>>>>>>            //            End
33983>>>>>>>        End
33983>>>>>>>>
33983>>>>>>>
33983>>>>>>>        Close hTable
33984>>>>>>>        Move (not(Err)) to bOK
33985>>>>>>>        Function_Return bOK
33986>>>>>>>    End_Function
33987>>>>>>>
33987>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
33987>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
33987>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
33987>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
33989>>>>>>>        Boolean bOpened bOK
33989>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
33989>>>>>>>        String sErrorFile sEmpty sPath
33989>>>>>>>
33989>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
33992>>>>>>>        Get AutoConnectionIDLogin to bOK
33993>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
33995>>>>>>>            Send IncreaseSortBufferSize
33996>>>>>>>//            Send SetAllIndexesToBatch hToTable
33996>>>>>>>        End
33996>>>>>>>>
33996>>>>>>>
33996>>>>>>>        Move False to Err
33997>>>>>>>        Open sPhysicalName as hToTable
33999>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
34002>>>>>>>        If (bOpened = False) Begin
34004>>>>>>>            Function_Return False
34005>>>>>>>        End
34005>>>>>>>>
34005>>>>>>>
34005>>>>>>>        If (ghoStatusPanel <> 0) Begin
34007>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
34008>>>>>>>            Set piMinimum of ghoProgressBar to 0
34009>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
34010>>>>>>>        End
34010>>>>>>>>
34010>>>>>>>
34010>>>>>>>        Move "" to sEmpty
34011>>>>>>>        Move False to Err
34012>>>>>>>        Move True to bOK
34013>>>>>>>        Set Private.phCurrentTable to hToTable
34014>>>>>>>
34014>>>>>>>        // No need to get the record identifier
34014>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
34017>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
34020>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
34022>>>>>>>            // Remove all indices to speed up copying of data:
34022>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
34027>>>>>>>            If (iRetval <> 0) Begin       
34029>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
34030>>>>>>>>
34030>>>>>>>                Close hToTable
34031>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
34034>>>>>>>                Function_Return False
34035>>>>>>>            End
34035>>>>>>>>
34035>>>>>>>        End
34035>>>>>>>>
34035>>>>>>>
34035>>>>>>>        Move (sRootName + ".err") to sErrorFile
34036>>>>>>>        Move 0 to iIndex
34037>>>>>>>        Move False to Err
34038>>>>>>>
34038>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
34040>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
34043>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
34048>>>>>>>            If (iRetval <> 0) Begin
34050>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
34051>>>>>>>>
34051>>>>>>>                Close hToTable
34052>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
34055>>>>>>>                Function_Return False
34056>>>>>>>            End
34056>>>>>>>>
34056>>>>>>>        End
34056>>>>>>>>
34056>>>>>>>        Else Begin
34057>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
34060>>>>>>>        End
34060>>>>>>>>
34060>>>>>>>
34060>>>>>>>        If (Err = False) Begin
34062>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
34063>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
34064>>>>>>>        End
34064>>>>>>>>
34064>>>>>>>
34064>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
34066>>>>>>>            // Recreate indices:
34066>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
34071>>>>>>>            If (iRetval <> 0) Begin
34073>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
34074>>>>>>>>
34074>>>>>>>                Close hToTable
34075>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
34078>>>>>>>                Function_Return False
34079>>>>>>>            End
34079>>>>>>>>
34079>>>>>>>        End
34079>>>>>>>>
34079>>>>>>>
34079>>>>>>>        Close hToTable
34080>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
34083>>>>>>>
34083>>>>>>>        If (bOK = True) Begin
34085>>>>>>>            Move (not(Err)) to bOK
34086>>>>>>>        End
34086>>>>>>>>
34086>>>>>>>
34086>>>>>>>        If (ghoStatusPanel <> 0) Begin
34088>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
34089>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
34090>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
34091>>>>>>>        End
34091>>>>>>>>
34091>>>>>>>
34091>>>>>>>        Function_Return (bOK = True)
34092>>>>>>>    End_Function
34093>>>>>>>
34093>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
34093>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
34093>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
34095>>>>>>>        Handle hFile
34095>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
34095>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
34095>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
34095>>>>>>>        tSQLConnection SQLConnection
34095>>>>>>>        tSQLConnection SQLConnection
34095>>>>>>>        tAPIColumn[] aColumns
34095>>>>>>>        tAPIColumn[] aColumns
34096>>>>>>>        tColumnType ColumnType
34096>>>>>>>        tColumnType ColumnType
34096>>>>>>>
34096>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
34096>>>>>>>        Get _UtilTableExists hTable to bOk
34097>>>>>>>        If (bOk = True) Begin
34099>>>>>>>            Function_Return False
34100>>>>>>>        End
34100>>>>>>>>
34100>>>>>>>
34100>>>>>>>        Set Private.phCurrentTable to hTable
34101>>>>>>>        Move sLogicalName to sTableName
34102>>>>>>>        If (ghoProgressBar <> 0) Begin
34104>>>>>>>            Send DoAdvance of ghoProgressBar
34105>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
34106>>>>>>>        End
34106>>>>>>>>
34106>>>>>>>
34106>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
34107>>>>>>>        Get psDriverID to sDriverID
34108>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
34109>>>>>>>        Get piDbType to iDbType
34110>>>>>>>
34110>>>>>>>        // If no columns passed in, we need to create a "dummy" column
34110>>>>>>>        Move False to bDeleteDummy
34111>>>>>>>        If (Num_Arguments = 8) Begin
34113>>>>>>>            Move aColumnIn to aColumns
34114>>>>>>>        End
34114>>>>>>>>
34114>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
34116>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
34117>>>>>>>            Move ColumnType.iSQLType to iDataType
34118>>>>>>>            If (bRecnum = False) Begin
34120>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
34121>>>>>>>            End
34121>>>>>>>>
34121>>>>>>>            Else Begin
34122>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
34123>>>>>>>            End
34123>>>>>>>>
34123>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
34124>>>>>>>            Move True to bDeleteDummy
34125>>>>>>>        End
34125>>>>>>>>
34125>>>>>>>
34125>>>>>>>        // If columns have been passed as an array we need to check if an identity column
34125>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
34125>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
34125>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
34125>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
34127>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
34128>>>>>>>            Decrement iSize
34129>>>>>>>            for iCount from 0 to iSize
34135>>>>>>>>
34135>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
34137>>>>>>>                    Move False to bRecnum
34138>>>>>>>                    Move iSize to iCount
34139>>>>>>>                End
34139>>>>>>>>
34139>>>>>>>            Loop
34140>>>>>>>>
34140>>>>>>>        End
34140>>>>>>>>
34140>>>>>>>
34140>>>>>>>        // If this is a SQL based driver we also check if the table exists
34140>>>>>>>        // in the SQL back end; in case we do nothing.
34140>>>>>>>        If (bSqlDriver = True) Begin
34142>>>>>>>            // Get all connection properties
34142>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
34143>>>>>>>            Move SQLConnection.sSchema to sSchema
34144>>>>>>>            If (sSchema = "") Begin
34146>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
34147>>>>>>>            End
34147>>>>>>>>
34147>>>>>>>
34147>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
34148>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
34148>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
34148>>>>>>>            If (bExists = False) Begin
34150>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
34151>>>>>>>            End
34151>>>>>>>>
34151>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
34151>>>>>>>            // we will just add it to Filelist.cfg
34151>>>>>>>            If (bExists = True) Begin
34153>>>>>>>                If (bExistsInFilelist = False) Begin
34155>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
34157>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
34158>>>>>>>                    End
34158>>>>>>>>
34158>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
34161>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
34164>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
34167>>>>>>>                    Move False to bSysFile
34168>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
34169>>>>>>>                End
34169>>>>>>>>
34169>>>>>>>                Function_Return False
34170>>>>>>>            End
34170>>>>>>>>
34170>>>>>>>        End
34170>>>>>>>>
34170>>>>>>>
34170>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
34171>>>>>>>        If (num_arguments > 6) Begin
34173>>>>>>>            If (bANSI = False) Begin
34175>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
34176>>>>>>>            End
34176>>>>>>>>
34176>>>>>>>        End
34176>>>>>>>>
34176>>>>>>>
34176>>>>>>>        Move False to Err
34177>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
34179>>>>>>>            Move sRootName to sPhysicalFile
34180>>>>>>>        End
34180>>>>>>>>
34180>>>>>>>
34180>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
34182>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
34183>>>>>>>
34183>>>>>>>            // If DAW driver and we should use a connection id we need to
34183>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
34183>>>>>>>            If (bUseConnectionID = True) Begin
34185>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
34186>>>>>>>                If (bExists = False) Begin
34188>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
34189>>>>>>>                    If (bOk = False) Begin
34191>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
34192>>>>>>>>
34192>>>>>>>                        Function_Return False
34193>>>>>>>                    End
34193>>>>>>>>
34193>>>>>>>                End
34193>>>>>>>>
34193>>>>>>>            End
34193>>>>>>>>
34193>>>>>>>
34193>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
34195>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
34196>>>>>>>            End
34196>>>>>>>>
34196>>>>>>>            Else Begin
34197>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
34198>>>>>>>            End
34198>>>>>>>>
34198>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
34199>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
34199>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
34199>>>>>>>//            End
34199>>>>>>>        End
34199>>>>>>>>
34199>>>>>>>        Move False to Err
34200>>>>>>>        Move 0 to hFile
34201>>>>>>>
34201>>>>>>>        Structure_Start hFile sDriverID
34202>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
34204>>>>>>>                If (bUseConnectionID = True) Begin
34206>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
34209>>>>>>>                End
34209>>>>>>>>
34209>>>>>>>                Else Begin
34210>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
34213>>>>>>>                End
34213>>>>>>>>
34213>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
34216>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
34219>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
34222>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
34225>>>>>>>
34225>>>>>>>                If (sSchema <> "") Begin
34227>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
34230>>>>>>>                End
34230>>>>>>>>
34230>>>>>>>
34230>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
34232>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
34234>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
34237>>>>>>>                    End
34237>>>>>>>>
34237>>>>>>>                End
34237>>>>>>>>
34237>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
34239>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
34241>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
34244>>>>>>>                    End
34244>>>>>>>>
34244>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
34246>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
34249>>>>>>>                    End
34249>>>>>>>>
34249>>>>>>>                End
34249>>>>>>>>
34249>>>>>>>            End
34249>>>>>>>>
34249>>>>>>>
34249>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
34252>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
34253>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34254>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34256>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34257>>>>>>>
34257>>>>>>>        Move (not(Err)) to bOK
34258>>>>>>>        If (bOk = True) Begin
34260>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
34262>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
34263>>>>>>>            End
34263>>>>>>>>
34263>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
34266>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
34269>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
34272>>>>>>>
34272>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
34272>>>>>>>            If (bDeleteDummy) Begin
34274>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
34275>>>>>>>            End
34275>>>>>>>>
34275>>>>>>>        End
34275>>>>>>>>
34275>>>>>>>
34275>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
34276>>>>>>>        Close hTable
34277>>>>>>>        Function_Return (bOK = True)
34278>>>>>>>    End_Function
34279>>>>>>>
34279>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
34281>>>>>>>        Move False to Err
34282>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
34285>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
34288>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
34291>>>>>>>
34291>>>>>>>        Function_Return (Err = False)
34292>>>>>>>    End_Function
34293>>>>>>>
34293>>>>>>>    // ToDo: Needs to be revised
34293>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
34295>>>>>>>        Handle hTable
34295>>>>>>>        String sDEFName sDataPath
34295>>>>>>>        Boolean bExists
34295>>>>>>>
34295>>>>>>>        // Do nothing if MSSQL Driver.
34295>>>>>>>//        Get IsMSSQLDriver to bExists
34295>>>>>>>//        If (bExists = True) Begin
34295>>>>>>>//            Procedure_Return
34295>>>>>>>//        End
34295>>>>>>>
34295>>>>>>>        Get psDataPathFirstPart to sDataPath
34296>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
34297>>>>>>>        If (bExists = True) Begin
34299>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
34299>>>>>>>            // still be missing from the filelist and needs to be added.
34299>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
34300>>>>>>>            If (bExists = True) Begin
34302>>>>>>>                Procedure_Return
34303>>>>>>>            End
34303>>>>>>>>
34303>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
34303>>>>>>>            Else Begin
34304>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
34307>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
34310>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
34313>>>>>>>                Procedure_Return
34314>>>>>>>            End
34314>>>>>>>>
34314>>>>>>>        End
34314>>>>>>>>
34314>>>>>>>
34314>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
34315>>>>>>>        Move 0 to hTable
34316>>>>>>>        Move False to Err
34317>>>>>>>
34317>>>>>>>        Structure_Start hTable DATAFLEX_ID
34318>>>>>>>            Load_Def sDEFName Onto hTable
34319>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
34322>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34323>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34325>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34326>>>>>>>
34326>>>>>>>        Move iFilelistSlot to hTable
34327>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
34330>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
34333>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
34336>>>>>>>
34336>>>>>>>    End_Procedure
34337>>>>>>>
34337>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
34339>>>>>>>        Boolean bTmp bErr bOK
34339>>>>>>>        String sTableName sDisplayName sFileName
34339>>>>>>>
34339>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
34339>>>>>>>        Move Err to bTmp
34340>>>>>>>        Move False to Err
34341>>>>>>>
34341>>>>>>>        Get AutoConnectionIDLogin to bOK
34342>>>>>>>        // First get the info for the current filelist slot:
34342>>>>>>>        Open iFromFileSlot
34344>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
34347>>>>>>>        If (bOK = True) Begin
34349>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
34352>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
34355>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
34358>>>>>>>
34358>>>>>>>            //...then move it.
34358>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
34361>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
34364>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
34367>>>>>>>
34367>>>>>>>            //...and finally remove the old filelist values.
34367>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
34370>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
34373>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
34376>>>>>>>        End
34376>>>>>>>>
34376>>>>>>>        Close iFromFileSlot
34377>>>>>>>
34377>>>>>>>        Move Err to bErr
34378>>>>>>>        Move bTmp to Err
34379>>>>>>>        Function_Return (bErr = False)
34380>>>>>>>    End_Function
34381>>>>>>>
34381>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
34383>>>>>>>        Handle hTable
34383>>>>>>>        Boolean bOK
34383>>>>>>>        String sDriverID
34383>>>>>>>
34383>>>>>>>        Get _UtilTableExists hTableFrom to bOK
34384>>>>>>>        If (bOK = False) Begin
34386>>>>>>>            Set Private.phCurrentTable to hTableFrom
34387>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
34388>>>>>>>>
34388>>>>>>>            Function_Return False
34389>>>>>>>        End
34389>>>>>>>>
34389>>>>>>>
34389>>>>>>>        Get _UtilTableExists hTableTo to bOK
34390>>>>>>>        If (bOK = False) Begin
34392>>>>>>>            Set Private.phCurrentTable to hTableTo
34393>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
34394>>>>>>>>
34394>>>>>>>            Function_Return False
34395>>>>>>>        End
34395>>>>>>>>
34395>>>>>>>
34395>>>>>>>        Get AutoConnectionIDLogin to bOK
34396>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
34397>>>>>>>        If (bOK = False) Begin
34399>>>>>>>            Function_Return False
34400>>>>>>>        End
34400>>>>>>>>
34400>>>>>>>
34400>>>>>>>        Move False to Err
34401>>>>>>>        Open hTableTo
34403>>>>>>>
34403>>>>>>>        Move hTableFrom to hTable
34404>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
34407>>>>>>>        Set Private.phCurrentTable to hTable
34408>>>>>>>
34408>>>>>>>        Structure_Start hTable sDriverID
34409>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
34412>>>>>>>            If (iColumnTo <> 0) Begin
34414>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
34417>>>>>>>            End
34417>>>>>>>>
34417>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34418>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34420>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34421>>>>>>>
34421>>>>>>>        If (hTableTo > 0) Begin
34423>>>>>>>            Close hTableTo
34424>>>>>>>        End
34424>>>>>>>>
34424>>>>>>>
34424>>>>>>>        Function_Return (Err = False)
34425>>>>>>>    End_Function
34426>>>>>>>
34426>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
34426>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
34428>>>>>>>        String sTableName sDriverID
34428>>>>>>>        Boolean bOk
34428>>>>>>>        String sDataPath
34428>>>>>>>
34428>>>>>>>        Get AutoConnectionIDLogin to bOK
34429>>>>>>>        Move False to Err
34430>>>>>>>        Get psDriverID to sDriverID
34431>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
34432>>>>>>>        If (sTableName = "") Begin
34434>>>>>>>            Function_Return False
34435>>>>>>>        End
34435>>>>>>>>
34435>>>>>>>
34435>>>>>>>        Set Private.phCurrentTable to hTable
34436>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
34437>>>>>>>        Delete_db sTableName
34438>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
34439>>>>>>>
34439>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
34441>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
34441>>>>>>>            Get psDataPathFirstPart to sDataPath
34442>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
34443>>>>>>>        End
34443>>>>>>>>
34443>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
34443>>>>>>>        If (hTable <> 0) Begin
34445>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
34448>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
34451>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
34454>>>>>>>        End
34454>>>>>>>>
34454>>>>>>>
34454>>>>>>>        Close hTable
34455>>>>>>>        Function_Return (hTable <> 0)
34456>>>>>>>    End_Function
34457>>>>>>>
34457>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
34459>>>>>>>        Handle hTable
34459>>>>>>>        Boolean bOK
34459>>>>>>>
34459>>>>>>>        Get AutoConnectionIDLogin to bOK
34460>>>>>>>        Move False to Err
34461>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
34463>>>>>>>        Move hTableFrom to hTable
34464>>>>>>>
34464>>>>>>>        Structure_Start hTable
34465>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
34468>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34469>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34471>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34472>>>>>>>
34472>>>>>>>        Close hTableFrom
34473>>>>>>>        Function_Return (Err = False)
34474>>>>>>>    End_Function
34475>>>>>>>
34475>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
34477>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
34477>>>>>>>        Boolean bOK bExists bOpened
34477>>>>>>>        tAPITableNameInfo APITableNameInfo
34477>>>>>>>        tAPITableNameInfo APITableNameInfo
34477>>>>>>>
34477>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
34480>>>>>>>        If (bOpened = False) Begin
34482>>>>>>>            Get OpenTableExclusive hTable to bOpened
34483>>>>>>>            If (bOpened = False) Begin
34485>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
34486>>>>>>>                Function_Return False
34487>>>>>>>            End
34487>>>>>>>>
34487>>>>>>>        End
34487>>>>>>>>
34487>>>>>>>
34487>>>>>>>        Set Private.phCurrentTable to hTable
34488>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
34489>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
34490>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
34491>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
34492>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
34493>>>>>>>        If (bExists = True) Begin
34495>>>>>>>            Function_Return True
34496>>>>>>>        End
34496>>>>>>>>
34496>>>>>>>
34496>>>>>>>        Set Private.phCurrentTable to hTable
34497>>>>>>>        Move False to Err
34498>>>>>>>        Get psDataPathFirstPart to sDataPath
34499>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
34502>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
34505>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
34508>>>>>>>
34508>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
34511>>>>>>>        Close hTable
34512>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
34514>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
34515>>>>>>>            If (bExists = True) Begin
34517>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
34519>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
34522>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
34522>>>>>>>                    // might report "File in use..." and the deletion will fail.
34522>>>>>>>                    Sleep 2
34523>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
34524>>>>>>>                End
34524>>>>>>>>
34524>>>>>>>            End
34524>>>>>>>>
34524>>>>>>>        End
34524>>>>>>>>
34524>>>>>>>
34524>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
34526>>>>>>>            If (not(sPhysicalName contains ".")) Begin
34528>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
34529>>>>>>>            End
34529>>>>>>>>
34529>>>>>>>
34529>>>>>>>            // Change the table name in the .int file to the new table new:
34529>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
34530>>>>>>>            If (bOK = False) Begin
34532>>>>>>>                Function_Return False
34533>>>>>>>            End
34533>>>>>>>>
34533>>>>>>>
34533>>>>>>>            // Change table name at the SQL side:
34533>>>>>>>            Get psSchema to sSchema
34534>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
34535>>>>>>>
34535>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
34536>>>>>>>            // Remove cache file and Rename the physical file names:
34536>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
34537>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
34538>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
34539>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
34540>>>>>>>
34540>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
34540>>>>>>>//            If (not(sDisplayName contains ".")) Begin
34540>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
34540>>>>>>>//            End
34540>>>>>>>        End
34540>>>>>>>>
34540>>>>>>>
34540>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
34543>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
34546>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
34549>>>>>>>
34549>>>>>>>        Function_Return (Err = False)
34550>>>>>>>    End_Function
34551>>>>>>>
34551>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
34553>>>>>>>        Move False to Err
34554>>>>>>>        Set Private.phCurrentTable to hTable
34555>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
34558>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
34561>>>>>>>
34561>>>>>>>        Function_Return (Err = False)
34562>>>>>>>    End_Function
34563>>>>>>>
34563>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
34563>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
34565>>>>>>>        Handle hTable
34565>>>>>>>        String sTableName
34565>>>>>>>        String sDriverIDFrom sDriverIDTo
34565>>>>>>>        Integer iDbType
34565>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto
34565>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
34565>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
34565>>>>>>>        tSQLConnection SQLConnection
34565>>>>>>>        tSQLConnection SQLConnection
34565>>>>>>>        tAPITable      APITableFrom APITableTo
34565>>>>>>>        tAPITable      APITableFrom APITableTo
34565>>>>>>>        tColumnType    ColumnType
34565>>>>>>>        tColumnType    ColumnType
34565>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34565>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
34566>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34566>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
34567>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34567>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
34568>>>>>>>
34568>>>>>>>        // We don't allow changes to the framework's DbVersion table.
34568>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
34570>>>>>>>            Function_Return False
34571>>>>>>>        End
34571>>>>>>>>
34571>>>>>>>
34571>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
34572>>>>>>>        Get piDbType                            to iDbType
34573>>>>>>>        Get pbRecnum                            to bRecnum
34574>>>>>>>        Get pbToANSI                            to bToANSI
34575>>>>>>>        Get pbCopyData                          to bCopyData
34576>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
34577>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
34578>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
34579>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
34580>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
34581>>>>>>>
34581>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
34582>>>>>>>        Set Private.phCurrentTable              to hTable
34583>>>>>>>        Get _UtilTableExists  hTable             to bTableExists
34584>>>>>>>
34584>>>>>>>        If (ghoProgressBar <> 0) Begin
34586>>>>>>>            Send DoAdvance of ghoProgressBar
34587>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
34588>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
34589>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
34590>>>>>>>        End
34590>>>>>>>>
34590>>>>>>>
34590>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
34591>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
34592>>>>>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
34593>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
34594>>>>>>>        Move True                               to APITableFrom.bFromTable
34595>>>>>>>        Move hTable                             to APITableFrom.hTable
34596>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
34597>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
34598>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
34599>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
34600>>>>>>>
34600>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
34602>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
34603>>>>>>>            If (bOk = True) Begin
34605>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
34606>>>>>>>                Function_Return bOk
34607>>>>>>>            End 
34607>>>>>>>>
34607>>>>>>>        End
34607>>>>>>>>
34607>>>>>>>
34607>>>>>>>        If (bTableExists = True) Begin
34609>>>>>>>            If (bIsSQLTableTo = True) Begin
34611>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
34612>>>>>>>            End
34612>>>>>>>>
34612>>>>>>>
34612>>>>>>>            Get OpenTableExclusive hTable to bOpened
34613>>>>>>>            If (bOpened = False) Begin
34615>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
34616>>>>>>>                Function_Return False
34617>>>>>>>            End
34617>>>>>>>>
34617>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
34618>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
34619>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
34620>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
34621>>>>>>>        End
34621>>>>>>>>
34621>>>>>>>
34621>>>>>>>        Move False to Err
34622>>>>>>>        Case Begin
34622>>>>>>>            // Alias table:
34622>>>>>>>            Case (bIsAliasFrom = True)
34624>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
34625>>>>>>>                Case Break
34626>>>>>>>
34626>>>>>>>            // New Table:
34626>>>>>>>            Case (bTableExists = False)
34629>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
34630>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
34630>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
34632>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
34633>>>>>>>                End                                                                 
34633>>>>>>>>
34633>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
34634>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
34635>>>>>>>                Case Break
34636>>>>>>>
34636>>>>>>>            // Update table:
34636>>>>>>>            Case (bTableExists = True)
34639>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
34640>>>>>>>                If (bIsSame = True) Begin
34642>>>>>>>                    Case Break
34643>>>>>>>                End
34643>>>>>>>>
34643>>>>>>>                If (bFilelistError = True) Begin
34645>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
34646>>>>>>>                    If (bOk = False) Begin
34648>>>>>>>                        Case Break
34649>>>>>>>                    End
34649>>>>>>>>
34649>>>>>>>                End
34649>>>>>>>>
34649>>>>>>>
34649>>>>>>>                If (ghoProgressBar <> 0) Begin
34651>>>>>>>                    Send DoAdvance of ghoProgressBar
34652>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
34653>>>>>>>                End
34653>>>>>>>>
34653>>>>>>>
34653>>>>>>>                // Columns:
34653>>>>>>>                Move True to bOk
34654>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
34655>>>>>>>                If (bIsSame = False) Begin
34657>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
34658>>>>>>>                End
34658>>>>>>>>
34658>>>>>>>                If (bOk = False) Begin
34660>>>>>>>                    Case Break
34661>>>>>>>                End
34661>>>>>>>>
34661>>>>>>>
34661>>>>>>>                // Indexes:
34661>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
34662>>>>>>>                If (bIsSame = False) Begin
34664>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
34665>>>>>>>                End
34665>>>>>>>>
34665>>>>>>>
34665>>>>>>>                // Relations:
34665>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
34666>>>>>>>                If (bIsSame = False) Begin
34668>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
34669>>>>>>>                    If (bOk = False) Begin
34671>>>>>>>                        Case Break
34672>>>>>>>                    End
34672>>>>>>>>
34672>>>>>>>                End
34672>>>>>>>>
34672>>>>>>>
34672>>>>>>>                Case Break
34673>>>>>>>
34673>>>>>>>            Case Else
34673>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
34674>>>>>>>>
34674>>>>>>>                Move False to bOk
34675>>>>>>>        Case End
34675>>>>>>>        
34675>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
34675>>>>>>>        // or convert an embedded table to SQL
34675>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
34677>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
34678>>>>>>>            If (bOk = False) Begin
34680>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
34681>>>>>>>            End
34681>>>>>>>>
34681>>>>>>>        End
34681>>>>>>>>
34681>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
34684>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
34685>>>>>>>        End
34685>>>>>>>>
34685>>>>>>>        
34685>>>>>>>        // Filelist Names:
34685>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
34686>>>>>>>        Close hTable
34687>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
34688>>>>>>>
34688>>>>>>>        Function_Return (bOK = True)
34689>>>>>>>    End_Function
34690>>>>>>>
34690>>>>>>>    // * Dummy function for the Studio's Code Explorer *
34690>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
34692>>>>>>>        Function_Return False
34693>>>>>>>    End_Function
34694>>>>>>>
34694>>>>>>>    // Adds a column name to the passed table number.
34694>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
34696>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
34696>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
34696>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
34696>>>>>>>
34696>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
34697>>>>>>>        If (bExists = True) Begin
34699>>>>>>>            Function_Return False
34700>>>>>>>        End
34700>>>>>>>>
34700>>>>>>>
34700>>>>>>>        Move False to Err
34701>>>>>>>        If (num_arguments > 4) Begin
34703>>>>>>>            Move iPrec to iPrecision
34704>>>>>>>        End
34704>>>>>>>>
34704>>>>>>>        If (num_arguments > 6) Begin
34706>>>>>>>            Move bInitVal to bInitializeValue
34707>>>>>>>            Move sColVal  to sColumnValue
34708>>>>>>>        End
34708>>>>>>>>
34708>>>>>>>        If (iType < -1490) Begin
34710>>>>>>>            Move (iType + 1500) to iType
34711>>>>>>>        End
34711>>>>>>>>
34711>>>>>>>
34711>>>>>>>        Move hTable to iFile
34712>>>>>>>        Get psDriverID to sDriverID
34713>>>>>>>        Get AutoConnectionIDLogin to bOK
34714>>>>>>>        Move False to Err
34715>>>>>>>        Move LastErr to iLastErr
34716>>>>>>>        Get OpenTableExclusive iFile to bOK
34717>>>>>>>        Set Private.phCurrentTable to hTable
34718>>>>>>>
34718>>>>>>>        Structure_Start iFile sDriverID
34719>>>>>>>            Move 0 to iColumn
34720>>>>>>>            Set Private.piCurrentField to iColumn
34721>>>>>>>            Create_Field hTable At iColumn
34722>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
34725>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
34728>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
34731>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
34734>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34735>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34737>>>>>>>
34737>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34738>>>>>>>
34738>>>>>>>        // If in development environment; create .fd file:
34738>>>>>>>        Open hTable
34740>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
34741>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
34742>>>>>>>        If (iCount > 1) Begin
34744>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
34745>>>>>>>        End
34745>>>>>>>>
34745>>>>>>>        Get vFolderExists sDDSrcPath to bExists
34746>>>>>>>        If (bExists = True) Begin
34748>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
34749>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
34752>>>>>>>            Get _TableNameOnly sTableName to sTableName
34753>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
34755>>>>>>>        End
34755>>>>>>>>
34755>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
34757>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
34758>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
34759>>>>>>>            If (iCount > 1) Begin
34761>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
34762>>>>>>>            End
34762>>>>>>>>
34762>>>>>>>            Get vFolderFormat sDataPath to sDataPath
34763>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
34763>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
34763>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
34763>>>>>>>        End
34763>>>>>>>>
34763>>>>>>>        // Check for a default value
34763>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
34765>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
34766>>>>>>>        End
34766>>>>>>>>
34766>>>>>>>        Close hTable
34767>>>>>>>
34767>>>>>>>        Function_Return (Err = False)
34768>>>>>>>    End_Function
34769>>>>>>>
34769>>>>>>>    // Adds a column name to the passed table number.
34769>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
34771>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
34771>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
34771>>>>>>>        String sDdSrcPath sTableName
34771>>>>>>>
34771>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
34772>>>>>>>        Move False to Err
34773>>>>>>>        If (bExists = True) Begin
34775>>>>>>>            Function_Return False
34776>>>>>>>        End
34776>>>>>>>>
34776>>>>>>>        If (num_arguments > 4) Begin
34778>>>>>>>            Move iPrec to iPrecision
34779>>>>>>>        End
34779>>>>>>>>
34779>>>>>>>        If (iType < -1490) Begin
34781>>>>>>>            Move (iType + 1500) to iType
34782>>>>>>>        End
34782>>>>>>>>
34782>>>>>>>
34782>>>>>>>        Get AutoConnectionIDLogin to bOK
34783>>>>>>>        Move False to Err
34784>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
34785>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
34785>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
34785>>>>>>>        Get piDbType to iDbType
34786>>>>>>>        If (bIsSQLTypeTo = False) Begin
34788>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
34789>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
34791>>>>>>>                Move DF_DATE to iType
34792>>>>>>>            End
34792>>>>>>>>
34792>>>>>>>        End
34792>>>>>>>>
34792>>>>>>>
34792>>>>>>>        // Structure_start will change the value of hTable...
34792>>>>>>>        Move hTable to iFile
34793>>>>>>>        Get OpenTableExclusive iFile to bOK
34794>>>>>>>        If (bOK = False) Begin
34796>>>>>>>            Function_Return False
34797>>>>>>>        End
34797>>>>>>>>
34797>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
34800>>>>>>>
34800>>>>>>>        // If the passed column number is higher than the current number of fields
34800>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
34800>>>>>>>        // a new field to the end:
34800>>>>>>>        If (iColumn > iNumberOfFields) Begin
34802>>>>>>>            Move 0 to iColumn
34803>>>>>>>        End
34803>>>>>>>>
34803>>>>>>>
34803>>>>>>>        Set Private.phCurrentTable to hTable
34804>>>>>>>        Set Private.piCurrentField to iColumn
34805>>>>>>>
34805>>>>>>>        Structure_Start iFile
34806>>>>>>>            Create_Field iFile At iColumn
34807>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
34810>>>>>>>            If (bIsSQLTypeTo = False) Begin
34812>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
34815>>>>>>>            End
34815>>>>>>>>
34815>>>>>>>            Else Begin
34816>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
34819>>>>>>>            End
34819>>>>>>>>
34819>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
34820>>>>>>>            If (bIsDateType = False) Begin
34822>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
34825>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
34828>>>>>>>            End
34828>>>>>>>>
34828>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
34829>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
34831>>>>>>>
34831>>>>>>>        Set Action_Text of ghoStatusPanel to ""
34832>>>>>>>        // If in development environment; create .fd file:
34832>>>>>>>        Open hTable
34834>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
34835>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
34836>>>>>>>        If (iCount > 1) Begin
34838>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
34839>>>>>>>        End
34839>>>>>>>>
34839>>>>>>>        Get vFolderExists sDDSrcPath to bExists
34840>>>>>>>        If (bExists = True) Begin
34842>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
34843>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
34846>>>>>>>            Get _TableNameOnly sTableName to sTableName
34847>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
34849>>>>>>>        End
34849>>>>>>>>
34849>>>>>>>
34849>>>>>>>        // Check for a default value
34849>>>>>>>        Close hTable
34850>>>>>>>
34850>>>>>>>        Function_Return (Err = False)
34851>>>>>>>    End_Function
34852>>>>>>>
34852>>>>>>>    // To update all records for a table column with a fixed value.
34852>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
34854>>>>>>>        Integer iRecs iCurrErr iField iRecord
34854>>>>>>>        Boolean bRetval bOpen
34854>>>>>>>
34854>>>>>>>        Move 0 to iRecs
34855>>>>>>>        Move False to bRetval
34856>>>>>>>        Move Err to iCurrErr
34857>>>>>>>        Move False to Err
34858>>>>>>>
34858>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
34861>>>>>>>        If (bOpen = False) Begin
34863>>>>>>>            Open hTable
34865>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
34868>>>>>>>            If (bOpen = False) Begin
34870>>>>>>>                Function_Return bRetval
34871>>>>>>>            End
34871>>>>>>>>
34871>>>>>>>        End
34871>>>>>>>>
34871>>>>>>>
34871>>>>>>>        Field_Map hTable sFieldName to iField
34873>>>>>>>        If (iField <> 0) Begin
34875>>>>>>>            Set Private.phCurrentTable to hTable
34876>>>>>>>            Set Private.piCurrentField to iField
34877>>>>>>>            Clear hTable
34878>>>>>>>            Repeat
34878>>>>>>>>
34878>>>>>>>                Vfind hTable 0 GT
34880>>>>>>>                If (Found) Begin
34882>>>>>>>                    If (ghoStatusPanel <> 0) Begin
34884>>>>>>>                        Get_Field_Value hTable 0 to iRecord
34887>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
34888>>>>>>>                    End
34888>>>>>>>>
34888>>>>>>>                    Reread hTable
34892>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
34895>>>>>>>                        SaveRecord hTable
34896>>>>>>>                    Unlock
34897>>>>>>>>
34897>>>>>>>                End
34897>>>>>>>>
34897>>>>>>>           Until (not(Found))
34899>>>>>>>        End
34899>>>>>>>>
34899>>>>>>>
34899>>>>>>>        Move (Err = False) to bRetval
34900>>>>>>>        Move iCurrErr to Err
34901>>>>>>>
34901>>>>>>>        Function_Return bRetval
34902>>>>>>>    End_Function
34903>>>>>>>
34903>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
34903>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
34905>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
34905>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
34905>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
34905>>>>>>>
34905>>>>>>>        Get psDriverID to sDriverID
34906>>>>>>>        Get piDbType to iDbType
34907>>>>>>>        Get UtilTableHandleToString hTable to sTableName
34908>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
34909>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
34910>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
34911>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
34913>>>>>>>            Move True to bIsSqlTable
34914>>>>>>>        End
34914>>>>>>>>
34914>>>>>>>        Move False to bIsOpen
34915>>>>>>>        If (hTable > 0) Begin
34917>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
34920>>>>>>>        End
34920>>>>>>>>
34920>>>>>>>        If (bIsOpen = True) Begin
34922>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
34925>>>>>>>        End
34925>>>>>>>>
34925>>>>>>>        Else Begin
34926>>>>>>>            Get pbRecnum to bRecnumTable
34927>>>>>>>        End
34927>>>>>>>>
34927>>>>>>>
34927>>>>>>>        Move False to Err
34928>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
34929>>>>>>>        Decrement iSize
34930>>>>>>>        for iCount from 0 to iSize
34936>>>>>>>>
34936>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
34937>>>>>>>            If (hTable > 0) Begin
34939>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34940>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
34941>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
34944>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
34945>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
34946>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
34947>>>>>>>            End
34947>>>>>>>>
34947>>>>>>>            Else Begin
34948>>>>>>>                Move False to bFieldExists
34949>>>>>>>            End
34949>>>>>>>>
34949>>>>>>>
34949>>>>>>>            If (bFieldExists = False) Begin
34951>>>>>>>                Move 0 to iColumn
34952>>>>>>>                Create_Field hTable At iColumn
34953>>>>>>>            End
34953>>>>>>>>
34953>>>>>>>            Else Begin
34954>>>>>>>                Move iCount to iColumn
34955>>>>>>>            End
34955>>>>>>>>
34955>>>>>>>
34955>>>>>>>            Set Private.piCurrentField to iColumn
34956>>>>>>>
34956>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
34957>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
34960>>>>>>>
34960>>>>>>>            Move aColumns[iCount].iType to iType
34961>>>>>>>            Move (not(iType < -1490)) to bNativeType
34962>>>>>>>            If (iType < -1490) Begin
34964>>>>>>>                Move (iType + 1500) to iType
34965>>>>>>>            End
34965>>>>>>>>
34965>>>>>>>
34965>>>>>>>            If (bIsSqlTable = True) Begin
34967>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
34969>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
34970>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
34973>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
34976>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
34979>>>>>>>
34979>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
34980>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
34982>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
34983>>>>>>>                    End
34983>>>>>>>>
34983>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
34986>>>>>>>
34986>>>>>>>                End
34986>>>>>>>>
34986>>>>>>>                Else Begin
34987>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
34990>>>>>>>                End
34990>>>>>>>>
34990>>>>>>>            End
34990>>>>>>>>
34990>>>>>>>            Else Begin
34991>>>>>>>                If (bCreating = False) Begin
34993>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
34994>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
34996>>>>>>>                        Move DF_DATE to iType
34997>>>>>>>                    End
34997>>>>>>>>
34997>>>>>>>                End
34997>>>>>>>>
34997>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
35000>>>>>>>            End
35000>>>>>>>>
35000>>>>>>>
35000>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
35001>>>>>>>            If (bIsDateType = False) Begin
35003>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
35006>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
35009>>>>>>>            End
35009>>>>>>>>
35009>>>>>>>
35009>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
35011>>>>>>>                Move 0 to iIndex
35012>>>>>>>                Create_Index hTable at iIndex
35013>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
35016>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
35019>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
35022>>>>>>>
35022>>>>>>>                // If we have an identity table - we must create a primary_key table.
35022>>>>>>>                If (bIsSqlTable = True) Begin
35024>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
35027>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
35030>>>>>>>                End
35030>>>>>>>>
35030>>>>>>>            End
35030>>>>>>>>
35030>>>>>>>        Loop
35031>>>>>>>>
35031>>>>>>>
35031>>>>>>>        Function_Return (Err = False)
35032>>>>>>>    End_Function
35033>>>>>>>
35033>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
35033>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
35035>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
35035>>>>>>>        Boolean bOK bIsSqlTable
35035>>>>>>>        String sFieldNameTo
35035>>>>>>>
35035>>>>>>>        If (num_arguments > 4) Begin
35037>>>>>>>            Move iPrec to iPrecFrom
35038>>>>>>>        End
35038>>>>>>>>
35038>>>>>>>        If (iTypeFrom < -1490) Begin
35040>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
35041>>>>>>>        End
35041>>>>>>>>
35041>>>>>>>
35041>>>>>>>        Get AutoConnectionIDLogin to bOK
35042>>>>>>>        Move False to Err
35043>>>>>>>        Get OpenTableExclusive hTable to bOK
35044>>>>>>>        If (bOK = False) Begin
35046>>>>>>>            Function_Return False
35047>>>>>>>        End
35047>>>>>>>>
35047>>>>>>>
35047>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35048>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35049>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
35051>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35052>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35053>>>>>>>        If (Err = True) Begin
35055>>>>>>>            Function_Return False
35056>>>>>>>        End
35056>>>>>>>>
35056>>>>>>>
35056>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
35059>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
35060>>>>>>>        If (bIsSqlTable = False) Begin
35062>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
35065>>>>>>>        End
35065>>>>>>>>
35065>>>>>>>        Else Begin
35066>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
35069>>>>>>>        End
35069>>>>>>>>
35069>>>>>>>        // Let the driver decide the other values;
35069>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
35072>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
35075>>>>>>>
35075>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
35077>>>>>>>            Function_Return False
35078>>>>>>>        End
35078>>>>>>>>
35078>>>>>>>
35078>>>>>>>        Set Private.phCurrentTable to hTable
35079>>>>>>>        Set Private.piCurrentField to iColumn
35080>>>>>>>
35080>>>>>>>        Structure_Start hTable
35081>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
35084>>>>>>>//            If (bIsSqlTable = False) Begin
35084>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
35087>>>>>>>//            End
35087>>>>>>>//            Else Begin
35087>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
35087>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
35087>>>>>>>//            End
35087>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
35090>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
35093>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
35094>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35096>>>>>>>
35096>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35097>>>>>>>        Function_Return (Err = False)
35098>>>>>>>    End_Function
35099>>>>>>>
35099>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
35099>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
35101>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
35101>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
35101>>>>>>>        String sFieldNameTo sDriverIDTo
35101>>>>>>>        tColumnType ColumnType
35101>>>>>>>        tColumnType ColumnType
35101>>>>>>>
35101>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
35102>>>>>>>        Get piDbType to iDbType
35103>>>>>>>        If (num_arguments > 4) Begin
35105>>>>>>>            Move iPrec to iPrecFrom
35106>>>>>>>            Move iOpt  to iOptionFrom
35107>>>>>>>        End
35107>>>>>>>>
35107>>>>>>>        If (iTypeFrom < -1490) Begin
35109>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
35110>>>>>>>        End
35110>>>>>>>>
35110>>>>>>>
35110>>>>>>>        Get AutoConnectionIDLogin to bOK
35111>>>>>>>        Move False to Err
35112>>>>>>>        Close hTable
35113>>>>>>>        Get OpenTableExclusive hTable to bOK
35114>>>>>>>        If (bOK = False) Begin
35116>>>>>>>            Function_Return False
35117>>>>>>>        End
35117>>>>>>>>
35117>>>>>>>
35117>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
35120>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
35123>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
35124>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
35126>>>>>>>            Move DF_DATE to iDataFlexType
35127>>>>>>>        End
35127>>>>>>>>
35127>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
35130>>>>>>>
35130>>>>>>>        If (bIsSQLTableTo = True) Begin
35132>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
35135>>>>>>>        End
35135>>>>>>>>
35135>>>>>>>        Else Begin
35136>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
35139>>>>>>>        End
35139>>>>>>>>
35139>>>>>>>
35139>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
35142>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
35145>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
35148>>>>>>>
35148>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
35148>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
35148>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
35150>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
35151>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
35153>>>>>>>                Move DF_DATE to iTypeTo  
35154>>>>>>>            End
35154>>>>>>>>
35154>>>>>>>        End
35154>>>>>>>>
35154>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
35157>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
35158>>>>>>>        End
35158>>>>>>>>
35158>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
35159>>>>>>>
35159>>>>>>>        If (bCompareDate_DateTime = False) Begin
35161>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
35162>>>>>>>            If (bSkip = True) Begin
35164>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
35166>>>>>>>                    Function_Return True
35167>>>>>>>                End
35167>>>>>>>>
35167>>>>>>>            End
35167>>>>>>>>
35167>>>>>>>        End
35167>>>>>>>>
35167>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
35170>>>>>>>            Function_Return True
35171>>>>>>>        End
35171>>>>>>>>
35171>>>>>>>
35171>>>>>>>        Set Private.phCurrentTable to hTable
35172>>>>>>>        Set Private.piCurrentField to iColumn
35173>>>>>>>
35173>>>>>>>        Structure_Start hTable
35174>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
35176>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
35179>>>>>>>            End
35179>>>>>>>>
35179>>>>>>>
35179>>>>>>>            If (bIsSameDataType = False) Begin
35181>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
35184>>>>>>>                If (bIsSQLTableTo = True) Begin
35186>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
35189>>>>>>>                End
35189>>>>>>>>
35189>>>>>>>            End
35189>>>>>>>>
35189>>>>>>>
35189>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
35191>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
35194>>>>>>>            End
35194>>>>>>>>
35194>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
35196>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
35199>>>>>>>            End
35199>>>>>>>>
35199>>>>>>>
35199>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
35201>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
35201>>>>>>>                If (bRecnumTable = True) Begin
35203>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
35206>>>>>>>                End
35206>>>>>>>>
35206>>>>>>>
35206>>>>>>>                // We might need to create an index here.
35206>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
35206>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
35206>>>>>>>                // index update checking logic.
35206>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
35209>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
35211>>>>>>>                    Create_Index hTable At iIndex
35212>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
35215>>>>>>>                End
35215>>>>>>>>
35215>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
35218>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
35221>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
35224>>>>>>>                If (bIsSQLTableTo = True) Begin
35226>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
35229>>>>>>>                End
35229>>>>>>>>
35229>>>>>>>            End
35229>>>>>>>>
35229>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
35230>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35232>>>>>>>
35232>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35233>>>>>>>        Function_Return (Err = False)
35234>>>>>>>    End_Function
35235>>>>>>>
35235>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
35237>>>>>>>        Boolean bOK
35237>>>>>>>
35237>>>>>>>        Get AutoConnectionIDLogin to bOK
35238>>>>>>>        Move False to Err
35239>>>>>>>        Get OpenTableExclusive hTable to bOK
35240>>>>>>>        If (bOK = False) Begin
35242>>>>>>>            Function_Return False
35243>>>>>>>        End
35243>>>>>>>>
35243>>>>>>>
35243>>>>>>>        Structure_Start hTable
35244>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
35247>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
35248>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35250>>>>>>>
35250>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35251>>>>>>>        Function_Return (Err = False)
35252>>>>>>>    End_Function
35253>>>>>>>
35253>>>>>>>    // To move an existing field to another position in a table.
35253>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
35255>>>>>>>        String sColumn sDriverID
35255>>>>>>>        Integer iType
35255>>>>>>>        Boolean bOK bIsDate
35255>>>>>>>
35255>>>>>>>        Close hTable
35256>>>>>>>        Get AutoConnectionIDLogin to bOK
35257>>>>>>>        Get OpenTableExclusive hTable to bOK
35258>>>>>>>        If (bOK = False) Begin
35260>>>>>>>            Function_Return False
35261>>>>>>>        End
35261>>>>>>>>
35261>>>>>>>
35261>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35264>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
35266>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
35267>>>>>>>>
35267>>>>>>>            Function_Return False
35268>>>>>>>        End
35268>>>>>>>>
35268>>>>>>>
35268>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
35271>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
35274>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
35275>>>>>>>
35275>>>>>>>        Set Private.phCurrentTable to hTable
35276>>>>>>>        Set Private.piCurrentField to iOld
35277>>>>>>>
35277>>>>>>>//        If (bIsDate = False) Begin
35277>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
35277>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
35277>>>>>>>//        End
35277>>>>>>>//        Else Begin
35277>>>>>>>//            Move 6 to iLength
35277>>>>>>>//            Move 0 to iPrecision
35277>>>>>>>//        End
35277>>>>>>>
35277>>>>>>>        Move False to Err
35278>>>>>>>
35278>>>>>>>        Structure_Start hTable
35279>>>>>>>            Delete_Field hTable iOld
35280>>>>>>>            Create_Field hTable At iNew
35281>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
35284>>>>>>>
35284>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
35287>>>>>>>            If (bIsSQLType = False) Begin
35289>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
35292>>>>>>>            End
35292>>>>>>>>
35292>>>>>>>            Else Begin
35293>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
35296>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
35296>>>>>>>            End
35296>>>>>>>>
35296>>>>>>>
35296>>>>>>>            If (bIsDate = False) Begin
35298>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
35301>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
35304>>>>>>>            End
35304>>>>>>>>
35304>>>>>>>
35304>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
35305>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35307>>>>>>>
35307>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35308>>>>>>>        Function_Return (Err = False)
35309>>>>>>>    End_Function
35310>>>>>>>
35310>>>>>>>    // Deletes a column name for the passed table number (and column number).
35310>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
35312>>>>>>>        Integer iColumn
35312>>>>>>>        Boolean bOK
35312>>>>>>>
35312>>>>>>>        Get AutoConnectionIDLogin to bOK
35313>>>>>>>        Move False to Err
35314>>>>>>>        Close hTable
35315>>>>>>>        Get OpenTableExclusive hTable to bOK
35316>>>>>>>        If (bOK = False) Begin
35318>>>>>>>            Function_Return False
35319>>>>>>>        End
35319>>>>>>>>
35319>>>>>>>
35319>>>>>>>        If (not(Err)) Begin
35321>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35322>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35323>>>>>>>            Field_Map hTable sFieldName to iColumn
35325>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
35326>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35327>>>>>>>            If (iColumn = 0) Begin
35329>>>>>>>                Move 0 to LastErr
35330>>>>>>>                Function_Return False
35331>>>>>>>            End
35331>>>>>>>>
35331>>>>>>>            Move False to Err
35332>>>>>>>
35332>>>>>>>            Set Private.phCurrentTable to hTable
35333>>>>>>>            Set Private.piCurrentField to iColumn
35334>>>>>>>
35334>>>>>>>            Structure_Start hTable
35335>>>>>>>                Delete_Field hTable iColumn
35336>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
35337>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35339>>>>>>>            Set Action_Text of ghoStatusPanel to ""
35340>>>>>>>        End
35340>>>>>>>>
35340>>>>>>>        Else Begin
35341>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
35342>>>>>>>>
35342>>>>>>>        End
35342>>>>>>>>
35342>>>>>>>
35342>>>>>>>        Function_Return (Err = False)
35343>>>>>>>    End_Function
35344>>>>>>>
35344>>>>>>>    // Renames a field for the passed table number & old field name & new field name
35344>>>>>>>    // Returns True if no errors occured.
35344>>>>>>>    // Sample usage:
35344>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
35344>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
35346>>>>>>>        Integer iField
35346>>>>>>>        Boolean bOK bExists bIsOpen
35346>>>>>>>
35346>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
35347>>>>>>>        If (bExists = True) Begin
35349>>>>>>>            Function_Return False
35350>>>>>>>        End
35350>>>>>>>>
35350>>>>>>>
35350>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
35350>>>>>>>        //       opened exclusively, so we first open it in normal mode.
35350>>>>>>>        Close hTable
35351>>>>>>>        Open hTable
35353>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
35356>>>>>>>        If (bIsOpen = False) Begin
35358>>>>>>>            Function_Return False
35359>>>>>>>        End
35359>>>>>>>>
35359>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35360>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35361>>>>>>>        Field_Map hTable sOldFieldName to iField
35363>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35364>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35365>>>>>>>
35365>>>>>>>        Get AutoConnectionIDLogin to bOK
35366>>>>>>>        Get OpenTableExclusive hTable to bOK
35367>>>>>>>        If (bOK = False) Begin
35369>>>>>>>            Function_Return False
35370>>>>>>>        End
35370>>>>>>>>
35370>>>>>>>
35370>>>>>>>        Move False to Err
35371>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
35372>>>>>>>        Set Private.phCurrentTable to hTable
35373>>>>>>>        Set Private.piCurrentField to iField
35374>>>>>>>
35374>>>>>>>        If (iField > 0) Begin
35376>>>>>>>            Structure_Start hTable
35377>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
35380>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
35381>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35383>>>>>>>        End
35383>>>>>>>>
35383>>>>>>>        Else Begin
35384>>>>>>>            Move 0 to LastErr
35385>>>>>>>            Move False to Err
35386>>>>>>>        End
35386>>>>>>>>
35386>>>>>>>
35386>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35387>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
35388>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35389>>>>>>>
35389>>>>>>>        Function_Return (Err = False)
35390>>>>>>>    End_Function
35391>>>>>>>
35391>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
35393>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
35393>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
35394>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
35394>>>>>>>        Boolean bRenameField
35394>>>>>>>
35394>>>>>>>        Open hTable
35396>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35397>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35398>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
35399>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
35402>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
35403>>>>>>>        Decrement iSize
35404>>>>>>>        for iCount from 0 to iSize
35410>>>>>>>>
35410>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
35412>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35413>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35414>>>>>>>
35414>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
35416>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
35418>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
35419>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
35420>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
35422>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
35423>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
35424>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
35425>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
35426>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
35427>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
35428>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
35429>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
35430>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
35431>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
35432>>>>>>>                        Increment iItem
35433>>>>>>>                    End
35433>>>>>>>>
35433>>>>>>>                End
35433>>>>>>>>
35433>>>>>>>            End
35433>>>>>>>>
35433>>>>>>>        Loop
35434>>>>>>>>
35434>>>>>>>
35434>>>>>>>        Move False to Err
35435>>>>>>>        Move 0 to LastErr
35436>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35437>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
35438>>>>>>>        Function_Return aAPIColumnsToInsert
35439>>>>>>>    End_Function
35440>>>>>>>
35440>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
35442>>>>>>>        Integer iSize iCount
35442>>>>>>>        Boolean bOK
35442>>>>>>>        tAPIColumn[] aColumnsTo
35442>>>>>>>        tAPIColumn[] aColumnsTo
35443>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35443>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35444>>>>>>>
35444>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
35445>>>>>>>        If (iSize = 0) Begin
35447>>>>>>>            Function_Return True
35448>>>>>>>        End
35448>>>>>>>>
35448>>>>>>>
35448>>>>>>>        Move False to Err
35449>>>>>>>        Decrement iSize
35450>>>>>>>        for iCount from 0 to iSize
35456>>>>>>>>
35456>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
35457>>>>>>>        Loop
35458>>>>>>>>
35458>>>>>>>
35458>>>>>>>        Function_Return bOK
35459>>>>>>>    End_Function
35460>>>>>>>
35460>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
35460>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
35462>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
35462>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
35463>>>>>>>        Integer iSize iCount iItem iShouldMove
35463>>>>>>>
35463>>>>>>>        Move 0 to iItem
35464>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
35465>>>>>>>        Decrement iSize
35466>>>>>>>        for iCount from 0 to iSize
35472>>>>>>>>
35472>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
35474>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
35475>>>>>>>                If (iShouldMove <> -1) Begin
35477>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
35478>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
35479>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
35480>>>>>>>                    Increment iItem
35481>>>>>>>                End
35481>>>>>>>>
35481>>>>>>>            End
35481>>>>>>>>
35481>>>>>>>        Loop
35482>>>>>>>>
35482>>>>>>>
35482>>>>>>>        Move False to Err
35483>>>>>>>        Move 0 to LastErr
35484>>>>>>>        Function_Return aAPIColumnsToMove
35485>>>>>>>    End_Function
35486>>>>>>>
35486>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
35488>>>>>>>        Integer iSize iCount
35488>>>>>>>        Boolean bOK
35488>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35488>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35489>>>>>>>
35489>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
35490>>>>>>>        If (iSize = 0) Begin
35492>>>>>>>            Function_Return True
35493>>>>>>>        End
35493>>>>>>>>
35493>>>>>>>
35493>>>>>>>        Move False to Err
35494>>>>>>>        Decrement iSize
35495>>>>>>>        for iCount from 0 to iSize
35501>>>>>>>>
35501>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35502>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35503>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
35505>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
35506>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
35507>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35508>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
35509>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
35511>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
35512>>>>>>>                    Decrement iSize
35513>>>>>>>                    Move 0 to iCount
35514>>>>>>>                End
35514>>>>>>>>
35514>>>>>>>            End
35514>>>>>>>>
35514>>>>>>>        Loop
35515>>>>>>>>
35515>>>>>>>
35515>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35516>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
35517>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
35519>>>>>>>            Move 0 to LastErr
35520>>>>>>>        End
35520>>>>>>>>
35520>>>>>>>        Function_Return bOK
35521>>>>>>>    End_Function
35522>>>>>>>
35522>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
35522>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
35522>>>>>>>    // - The "FROM" field name is <> "TO" field name
35522>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
35522>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
35522>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
35524>>>>>>>        Boolean bShouldRename
35524>>>>>>>        String sFieldNameFrom sFieldNameTo
35524>>>>>>>
35524>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
35525>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
35526>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
35528>>>>>>>            Function_Return False
35529>>>>>>>        End
35529>>>>>>>>
35529>>>>>>>
35529>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
35530>>>>>>>//        If (bShouldRename = False) Begin
35530>>>>>>>//            Function_Return False
35530>>>>>>>//        End
35530>>>>>>>//
35530>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
35530>>>>>>>//            Function_Return True
35530>>>>>>>//        End
35530>>>>>>>
35530>>>>>>>        Function_Return bShouldRename
35531>>>>>>>    End_Function
35532>>>>>>>
35532>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
35532>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
35532>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
35534>>>>>>>        Integer iCount iSize iRetval
35534>>>>>>>        String sFieldNameFrom
35534>>>>>>>
35534>>>>>>>        Move -1 to iRetval
35535>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
35537>>>>>>>            Function_Return iRetval
35538>>>>>>>        End
35538>>>>>>>>
35538>>>>>>>
35538>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
35539>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
35540>>>>>>>        Decrement iSize
35541>>>>>>>        for iCount from 0 to iSize
35547>>>>>>>>
35547>>>>>>>            // We're only interested in fields other than the passed field/column number:
35547>>>>>>>            If (iCount <> iColumn) Begin
35549>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
35551>>>>>>>                    Move (iCount + 1) to iRetval
35552>>>>>>>                End
35552>>>>>>>>
35552>>>>>>>            End
35552>>>>>>>>
35552>>>>>>>        Loop
35553>>>>>>>>
35553>>>>>>>
35553>>>>>>>        Move 0 to LastErr
35554>>>>>>>        Function_Return iRetval
35555>>>>>>>    End_Function
35556>>>>>>>
35556>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
35558>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
35558>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
35559>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
35559>>>>>>>        Boolean bRenameField
35559>>>>>>>
35559>>>>>>>        Open hTable
35561>>>>>>>        Move 0 to iItem
35562>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
35563>>>>>>>        Decrement iSize
35564>>>>>>>        for iCount from 0 to iSize
35570>>>>>>>>
35570>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
35572>>>>>>>                // Check if the field exists in another position (other field number)
35572>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
35573>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
35574>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
35576>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
35577>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
35578>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
35579>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
35580>>>>>>>                    Increment iItem
35581>>>>>>>                End
35581>>>>>>>>
35581>>>>>>>            End
35581>>>>>>>>
35581>>>>>>>        Loop
35582>>>>>>>>
35582>>>>>>>
35582>>>>>>>        Move False to Err
35583>>>>>>>        Move 0 to LastErr
35584>>>>>>>        Function_Return aAPIColumnsToRename
35585>>>>>>>    End_Function
35586>>>>>>>
35586>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
35588>>>>>>>        Integer iSize iCount
35588>>>>>>>        Boolean bOK
35588>>>>>>>        tAPIColumn[] aColumnsTo
35588>>>>>>>        tAPIColumn[] aColumnsTo
35589>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35589>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
35590>>>>>>>
35590>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
35591>>>>>>>        If (iSize = 0) Begin
35593>>>>>>>            Function_Return True
35594>>>>>>>        End
35594>>>>>>>>
35594>>>>>>>
35594>>>>>>>        Move False to Err
35595>>>>>>>        Decrement iSize
35596>>>>>>>        For iCount from 0 to iSize
35602>>>>>>>>
35602>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35603>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
35604>>>>>>>        Loop
35605>>>>>>>>
35605>>>>>>>
35605>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35606>>>>>>>        Function_Return bOK
35607>>>>>>>    End_Function
35608>>>>>>>
35608>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
35610>>>>>>>        Boolean bDateType
35610>>>>>>>
35610>>>>>>>        If (bIsSQLTableTo = True) Begin
35612>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
35613>>>>>>>        End
35613>>>>>>>>
35613>>>>>>>        Else Begin
35614>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
35615>>>>>>>        End
35615>>>>>>>>
35615>>>>>>>
35615>>>>>>>        Function_Return bDateType
35616>>>>>>>    End_Function
35617>>>>>>>
35617>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
35619>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
35619>>>>>>>        Integer iCount2 iColumn2
35619>>>>>>>        Handle hFile
35619>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
35619>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
35619>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
35619>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
35619>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
35624>>>>>>>        tColumnType ColumnType
35624>>>>>>>        tColumnType ColumnType
35624>>>>>>>
35624>>>>>>>        Move False to Err
35625>>>>>>>        Close hTable
35626>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
35627>>>>>>>        If (bIsOpen = False) Begin
35629>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
35630>>>>>>>>
35630>>>>>>>            Function_Return False
35631>>>>>>>        End 
35631>>>>>>>>
35631>>>>>>>        
35631>>>>>>>        Get piDbType to iDbType
35632>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
35635>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
35636>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
35637>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
35640>>>>>>>
35640>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35641>>>>>>>
35641>>>>>>>        // Before we start to change the table we need to do three things;
35641>>>>>>>        // 1) Insert any new fields
35641>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
35642>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
35644>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
35645>>>>>>>            If (bOK = False) Begin
35647>>>>>>>                Function_Return False
35648>>>>>>>            End
35648>>>>>>>>
35648>>>>>>>            // Update info with changes made.
35648>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
35649>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35650>>>>>>>        End
35650>>>>>>>>
35650>>>>>>>
35650>>>>>>>        // 2) Move fields with same names
35650>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
35651>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
35653>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
35654>>>>>>>            If (bOK = False) Begin
35656>>>>>>>                Function_Return False
35657>>>>>>>            End
35657>>>>>>>>
35657>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
35658>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35659>>>>>>>        End
35659>>>>>>>>
35659>>>>>>>        
35659>>>>>>>        // 3) Rename fields
35659>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
35660>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
35662>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
35663>>>>>>>            If (bOK = False) Begin
35665>>>>>>>                Function_Return False
35666>>>>>>>            End
35666>>>>>>>>
35666>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
35667>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35668>>>>>>>        End
35668>>>>>>>>
35668>>>>>>>
35668>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
35668>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
35668>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
35668>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
35668>>>>>>>//            If (bOK = False) Begin
35668>>>>>>>//                Function_Return False
35668>>>>>>>//            End
35668>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
35668>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35668>>>>>>>//        End
35668>>>>>>>
35668>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
35668>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
35670>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
35671>>>>>>>            If (bIsSame = True) Begin
35673>>>>>>>                Function_Return True
35674>>>>>>>            End
35674>>>>>>>>
35674>>>>>>>        End
35674>>>>>>>>
35674>>>>>>>
35674>>>>>>>        // We can now continue to make standard field changes:
35674>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
35675>>>>>>>        Set Private.phCurrentTable to hTable
35676>>>>>>>        Move hTable to hFile
35677>>>>>>>        Structure_Start hFile sDriverIDTo
35678>>>>>>>
35678>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
35679>>>>>>>            Decrement iColumns
35680>>>>>>>            for iCount from 0 to iColumns
35686>>>>>>>>
35686>>>>>>>                Send DoAdvance of ghoProgressBar
35687>>>>>>>
35687>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
35688>>>>>>>                Set Private.piCurrentField                  to iColumn
35689>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
35690>>>>>>>                If (bIsSame = False) Begin
35692>>>>>>>
35692>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
35693>>>>>>>                    If (bFieldExistsFrom = True) Begin
35695>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
35696>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
35697>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
35698>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
35699>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
35700>>>>>>>
35700>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
35701>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
35702>>>>>>>                        If (iTypeFrom < -1490) Begin
35704>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
35705>>>>>>>                        End
35705>>>>>>>>
35705>>>>>>>
35705>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
35705>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
35705>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
35707>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
35708>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
35710>>>>>>>                                Move DF_DATE to iTypeFrom
35711>>>>>>>                            End
35711>>>>>>>>
35711>>>>>>>                        End
35711>>>>>>>>
35711>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
35714>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
35715>>>>>>>                        End
35715>>>>>>>>
35715>>>>>>>
35715>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
35716>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
35717>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
35718>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
35719>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
35720>>>>>>>
35720>>>>>>>                        Move False to bSkipTypeChange
35721>>>>>>>                        If (bCompareDate_DateTime = False) Begin
35723>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
35724>>>>>>>                        End
35724>>>>>>>>
35724>>>>>>>
35724>>>>>>>                        If (bFieldExistsTo = False) Begin
35726>>>>>>>                            Move 0 to iColumn
35727>>>>>>>                            Create_Field hFile At iColumn
35728>>>>>>>                            Set Private.piCurrentField to iColumn
35729>>>>>>>                        End
35729>>>>>>>>
35729>>>>>>>
35729>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
35731>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
35734>>>>>>>                        End
35734>>>>>>>>
35734>>>>>>>
35734>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
35736>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
35739>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
35740>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
35742>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
35743>>>>>>>                            End
35743>>>>>>>>
35743>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
35746>>>>>>>                        End
35746>>>>>>>>
35746>>>>>>>
35746>>>>>>>                        If (bSkipTypeChange = False) Begin
35748>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
35750>>>>>>>                                If (bIsSQLTableTo = True) Begin
35752>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
35755>>>>>>>                                End
35755>>>>>>>>
35755>>>>>>>                                Else Begin                                                   
35756>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
35758>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
35759>>>>>>>                                    End
35759>>>>>>>>
35759>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
35762>>>>>>>                                End
35762>>>>>>>>
35762>>>>>>>                            End
35762>>>>>>>>
35762>>>>>>>                        End
35762>>>>>>>>
35762>>>>>>>
35762>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
35763>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
35763>>>>>>>                        If (bIsDateType = False) Begin
35765>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
35767>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
35770>>>>>>>                            End
35770>>>>>>>>
35770>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
35772>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
35775>>>>>>>                            End
35775>>>>>>>>
35775>>>>>>>                        End
35775>>>>>>>>
35775>>>>>>>
35775>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
35777>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
35777>>>>>>>                            If (bRecnumTable = True) Begin
35779>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
35782>>>>>>>                            End
35782>>>>>>>>
35782>>>>>>>
35782>>>>>>>                            // We might need to create an index here.
35782>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
35782>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
35782>>>>>>>                            // index update checking logic.
35782>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
35785>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
35787>>>>>>>                                Create_Index hFile at iIndex
35788>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
35791>>>>>>>                            End
35791>>>>>>>>
35791>>>>>>>
35791>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
35794>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
35797>>>>>>>                                // Note: The order here is crucial!
35797>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
35800>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
35803>>>>>>>                        End
35803>>>>>>>>
35803>>>>>>>                    End
35803>>>>>>>>
35803>>>>>>>                    Else Begin
35804>>>>>>>                        Delete_Field hFile iColumn
35805>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
35806>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
35807>>>>>>>                        Decrement iCount2
35808>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
35808>>>>>>>                        // starting with the array number we just deleted the field for.
35808>>>>>>>                        for iColumn2 from iCount to iCount2
35814>>>>>>>>
35814>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
35815>>>>>>>                        Loop
35816>>>>>>>>
35816>>>>>>>                        Decrement iCount
35817>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
35818>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
35819>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
35821>>>>>>>                            Move iColumns to iCount 
35822>>>>>>>                        End
35822>>>>>>>>
35822>>>>>>>                    End
35822>>>>>>>>
35822>>>>>>>                End
35822>>>>>>>>
35822>>>>>>>            Loop
35823>>>>>>>>
35823>>>>>>>
35823>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
35824>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35826>>>>>>>
35826>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35827>>>>>>>        Function_Return (Err = False)
35828>>>>>>>    End_Function
35829>>>>>>>
35829>>>>>>>    // * Dummy function for the Studio's Code Explorer *
35829>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
35831>>>>>>>        Function_Return False
35832>>>>>>>    End_Function
35833>>>>>>>
35833>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
35833>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
35833>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
35833>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
35835>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
35835>>>>>>>        String sDriverID
35835>>>>>>>        Boolean bOK bExists bIsSQLTable
35835>>>>>>>
35835>>>>>>>        Get AutoConnectionIDLogin to bOK
35836>>>>>>>        Get OpenTableExclusive hTable to bOK
35837>>>>>>>        If (bOK = False) Begin
35839>>>>>>>            Function_Return False
35840>>>>>>>        End
35840>>>>>>>>
35840>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35843>>>>>>>
35843>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
35844>>>>>>>            If (bIsSQLTable = True) Begin
35846>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
35849>>>>>>>            End
35849>>>>>>>>
35849>>>>>>>
35849>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
35852>>>>>>>        Move (iIndexSegments > 0) to bExists
35853>>>>>>>        If (bExists = True) Begin
35855>>>>>>>            Function_Return True
35856>>>>>>>        End
35856>>>>>>>>
35856>>>>>>>
35856>>>>>>>        Move -1 to iSegment1
35857>>>>>>>        Move -1 to iSegment2
35858>>>>>>>        Move -1 to iSegment3
35859>>>>>>>        Move -1 to iSegment4
35860>>>>>>>        Move -1 to iSegment5
35861>>>>>>>        Move -1 to iSegment6
35862>>>>>>>        Move -1 to iSegment7
35863>>>>>>>        Move -1 to iSegment8
35864>>>>>>>        Move -1 to iSegment9
35865>>>>>>>        Move -1 to iSegment10
35866>>>>>>>
35866>>>>>>>        If (num_arguments > 3) Begin
35868>>>>>>>            Move iSgmnt1 to iSegment1
35869>>>>>>>        End
35869>>>>>>>>
35869>>>>>>>        If (num_arguments > 4) Begin
35871>>>>>>>            Move iSgmnt2 to iSegment2
35872>>>>>>>        End
35872>>>>>>>>
35872>>>>>>>        If (num_arguments > 5) Begin
35874>>>>>>>            Move iSgmnt3 to iSegment3
35875>>>>>>>        End
35875>>>>>>>>
35875>>>>>>>        If (num_arguments > 6) Begin
35877>>>>>>>            Move iSgmnt4 to iSegment4
35878>>>>>>>        End
35878>>>>>>>>
35878>>>>>>>        If (num_arguments > 7) Begin
35880>>>>>>>            Move iSgmnt5 to iSegment5
35881>>>>>>>        End
35881>>>>>>>>
35881>>>>>>>        If (num_arguments > 8) Begin
35883>>>>>>>            Move iSgmnt6 to iSegment6
35884>>>>>>>        End
35884>>>>>>>>
35884>>>>>>>        If (num_arguments > 9) Begin
35886>>>>>>>            Move iSgmnt7 to iSegment7
35887>>>>>>>        End
35887>>>>>>>>
35887>>>>>>>        If (num_arguments > 10) Begin
35889>>>>>>>            Move iSgmnt8 to iSegment8
35890>>>>>>>        End
35890>>>>>>>>
35890>>>>>>>        If (num_arguments > 11) Begin
35892>>>>>>>            Move iSgmnt9 to iSegment9
35893>>>>>>>        End
35893>>>>>>>>
35893>>>>>>>        If (num_arguments > 12) Begin
35895>>>>>>>            Move iSgmnt10 to iSegment10
35896>>>>>>>        End
35896>>>>>>>>
35896>>>>>>>
35896>>>>>>>        Move False to Err
35897>>>>>>>        Move hTable to iTableNo
35898>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
35899>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
35900>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
35901>>>>>>>
35901>>>>>>>        // We start by deleting the index, if it exists.
35901>>>>>>>        If (bExists = True) Begin
35903>>>>>>>            Structure_Start hTable sDriverID
35904>>>>>>>                Delete_Index iTableNo iIndex
35905>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
35906>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35908>>>>>>>        End
35908>>>>>>>>
35908>>>>>>>
35908>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
35909>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
35910>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
35911>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35912>>>>>>>        Move False to Err
35913>>>>>>>        Move 0 to LastErr
35914>>>>>>>
35914>>>>>>>        // Need to re-open if index deleted.
35914>>>>>>>        Move iTableNo to hTable
35915>>>>>>>        Get OpenTableExclusive hTable to bOK
35916>>>>>>>        If (bOK = False) Begin
35918>>>>>>>            Function_Return False
35919>>>>>>>        End
35919>>>>>>>>
35919>>>>>>>
35919>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
35920>>>>>>>        Structure_Start hTable sDriverID
35921>>>>>>>            Create_Index hTable At iIndex
35922>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
35925>>>>>>>
35925>>>>>>>            If (iSgmnt1 <> -1) Begin
35927>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
35930>>>>>>>            End
35930>>>>>>>>
35930>>>>>>>            If (iSegment2 <> -1) Begin
35932>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
35935>>>>>>>            End
35935>>>>>>>>
35935>>>>>>>            If (iSegment3 <> -1) Begin
35937>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
35940>>>>>>>            End
35940>>>>>>>>
35940>>>>>>>            If (iSegment4 <> -1) Begin
35942>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
35945>>>>>>>            End
35945>>>>>>>>
35945>>>>>>>            If (iSegment5 <> -1) Begin
35947>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
35950>>>>>>>            End
35950>>>>>>>>
35950>>>>>>>            If (iSegment6 <> -1) Begin
35952>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
35955>>>>>>>            End
35955>>>>>>>>
35955>>>>>>>            If (iSegment7 <> -1) Begin
35957>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
35960>>>>>>>            End
35960>>>>>>>>
35960>>>>>>>            If (iSegment8 <> -1) Begin
35962>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
35965>>>>>>>            End
35965>>>>>>>>
35965>>>>>>>            If (iSegment9 <> -1) Begin
35967>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
35970>>>>>>>            End
35970>>>>>>>>
35970>>>>>>>            If (iSegment10 <> -1) Begin
35972>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
35975>>>>>>>            End
35975>>>>>>>>
35975>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
35976>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
35978>>>>>>>
35978>>>>>>>        Set Action_Text of ghoStatusPanel to ""
35979>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
35980>>>>>>>
35980>>>>>>>        Function_Return (Err = False)
35981>>>>>>>    End_Function
35982>>>>>>>
35982>>>>>>>    // Example:
35982>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
35982>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
35982>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
35984>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
35984>>>>>>>        String sDriverID
35984>>>>>>>        Boolean bOK bIsSQLTable
35984>>>>>>>
35984>>>>>>>        Get AutoConnectionIDLogin to bOK
35985>>>>>>>
35985>>>>>>>        Move False to Err
35986>>>>>>>        Move hTable to iTableNo
35987>>>>>>>        Get OpenTableExclusive hTable to bOK
35988>>>>>>>        If (bOK = False) Begin
35990>>>>>>>            Function_Return False
35991>>>>>>>        End
35991>>>>>>>>
35991>>>>>>>
35991>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
35994>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
35995>>>>>>>            If (bIsSQLTable = True) Begin
35997>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36000>>>>>>>            End
36000>>>>>>>>
36000>>>>>>>
36000>>>>>>>        // We start by deleting the index
36000>>>>>>>        Structure_Start hTable sDriverID
36001>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
36002>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
36003>>>>>>>            Delete_Index iTableNo iIndex
36004>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
36005>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
36006>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
36008>>>>>>>
36008>>>>>>>        Move False to Err
36009>>>>>>>        Move iTableNo to hTable
36010>>>>>>>        Get OpenTableExclusive hTable to bOK
36011>>>>>>>        If (bOK = False) Begin
36013>>>>>>>            Function_Return False
36014>>>>>>>        End
36014>>>>>>>>
36014>>>>>>>
36014>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
36015>>>>>>>        Structure_Start hTable sDriverID
36016>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
36017>>>>>>>
36017>>>>>>>            Create_Index hTable at iIndex
36018>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
36021>>>>>>>
36021>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
36027>>>>>>>>
36027>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
36030>>>>>>>            Loop
36031>>>>>>>>
36031>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
36033>>>>>>>
36033>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
36034>>>>>>>
36034>>>>>>>        Function_Return (Err = False)
36035>>>>>>>    End_Function
36036>>>>>>>
36036>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
36038>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
36038>>>>>>>        String sDriverID sSQLIndexName
36038>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
36038>>>>>>>
36038>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
36039>>>>>>>        If (iSegmentsFrom = 0) Begin
36041>>>>>>>            Function_Return False
36042>>>>>>>        End
36042>>>>>>>>
36042>>>>>>>
36042>>>>>>>        Get AutoConnectionIDLogin to bOK
36043>>>>>>>        Move False to Err
36044>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
36045>>>>>>>        If (bIsOpen = False) Begin
36047>>>>>>>            Function_Return False
36048>>>>>>>        End
36048>>>>>>>>
36048>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
36051>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
36052>>>>>>>            If (bIsSQLTable = True) Begin
36054>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36057>>>>>>>            End
36057>>>>>>>>
36057>>>>>>>
36057>>>>>>>        Move 0     to iSegmentsTo
36058>>>>>>>        Move 0     to iSQLIndexType
36059>>>>>>>        Move ""    to sSQLIndexName
36060>>>>>>>        Move False to bIsSQLTemporaryIndex
36061>>>>>>>        Move False to bIsSQLPrimaryKey
36062>>>>>>>        Move False to bIsSQLClustered
36063>>>>>>>
36063>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
36064>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
36067>>>>>>>        Move (iSegmentsTo > 0) to bExists
36068>>>>>>>        If (bExists = True) Begin
36070>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
36072>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
36075>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
36078>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
36079>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
36082>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
36085>>>>>>>            End
36085>>>>>>>>
36085>>>>>>>        End
36085>>>>>>>>
36085>>>>>>>
36085>>>>>>>        Move hTable to iTableNo
36086>>>>>>>        Move False to Err
36087>>>>>>>        Move 0 to LastErr
36088>>>>>>>
36088>>>>>>>        Structure_Start hTable sDriverID
36089>>>>>>>            If (bExists = True) Begin
36091>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
36092>>>>>>>            End
36092>>>>>>>>
36092>>>>>>>
36092>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
36093>>>>>>>
36093>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
36095>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
36098>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
36101>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
36104>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
36107>>>>>>>                End
36107>>>>>>>>
36107>>>>>>>
36107>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
36110>>>>>>>
36110>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
36116>>>>>>>>
36116>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
36117>>>>>>>                If (iFieldFrom <> -1 ) Begin
36119>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
36122>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
36125>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
36128>>>>>>>                End
36128>>>>>>>>
36128>>>>>>>            Loop
36129>>>>>>>>
36129>>>>>>>
36129>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
36130>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36132>>>>>>>
36132>>>>>>>        Set Action_Text of ghoStatusPanel to ""
36133>>>>>>>
36133>>>>>>>        Function_Return (Err = False)
36134>>>>>>>    End_Function
36135>>>>>>>
36135>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
36135>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
36135>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
36137>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
36137>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
36137>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
36137>>>>>>>
36137>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
36138>>>>>>>        
36138>>>>>>>        If (bIsSQLDriver = False) Begin
36140>>>>>>>            Function_Return False
36141>>>>>>>        End
36141>>>>>>>>
36141>>>>>>>
36141>>>>>>>        Move False to Err
36142>>>>>>>        Move hTable to iTableNo
36143>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
36146>>>>>>>        for iCount from 0 to iLastIndex
36152>>>>>>>>
36152>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
36155>>>>>>>            Move (iSegments > 0) to bExists
36156>>>>>>>            If (bExists = True) Begin
36158>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
36161>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
36163>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
36164>>>>>>>                    Structure_Start iTableNo sDriverID
36165>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
36168>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36170>>>>>>>                    Open hTable
36172>>>>>>>                End
36172>>>>>>>>
36172>>>>>>>            End
36172>>>>>>>>
36172>>>>>>>        Loop
36173>>>>>>>>
36173>>>>>>>
36173>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
36176>>>>>>>        If (bIsOpen = False) Begin
36178>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
36179>>>>>>>        End
36179>>>>>>>>
36179>>>>>>>        If (bIsOpen = False) Begin
36181>>>>>>>            Function_Return False
36182>>>>>>>        End
36182>>>>>>>>
36182>>>>>>>
36182>>>>>>>        Function_Return (Err = False)
36183>>>>>>>    End_Function
36184>>>>>>>
36184>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
36184>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
36184>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
36186>>>>>>>        Integer iSize iCount
36186>>>>>>>        Integer iRetVal
36186>>>>>>>
36186>>>>>>>        Move 0 to iRetVal
36187>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
36190>>>>>>>        If (iRetVal = 0) Begin
36192>>>>>>>            Function_Return 0
36193>>>>>>>        End
36193>>>>>>>>
36193>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
36194>>>>>>>        Decrement iSize
36195>>>>>>>        for iCount from 0 to iSize
36201>>>>>>>>
36201>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
36203>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
36205>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
36206>>>>>>>                End
36206>>>>>>>>
36206>>>>>>>            End
36206>>>>>>>>
36206>>>>>>>        Loop
36207>>>>>>>>
36207>>>>>>>
36207>>>>>>>        Function_Return iRetVal
36208>>>>>>>    End_Function
36209>>>>>>>
36209>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
36211>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
36211>>>>>>>        Boolean bIsSQLTable
36211>>>>>>>        
36211>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
36212>>>>>>>            If (bIsSQLTable = True) Begin
36214>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36217>>>>>>>            End
36217>>>>>>>>
36217>>>>>>>
36217>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36220>>>>>>>        If (iSegment = iNumSegments) Begin
36222>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
36222>>>>>>>        End
36222>>>>>>>>
36222>>>>>>>
36222>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
36225>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
36231>>>>>>>>
36231>>>>>>>                //*** Move index segment attributes
36231>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
36234>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
36237>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
36240>>>>>>>
36240>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
36243>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
36246>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
36249>>>>>>>            Loop
36250>>>>>>>>
36250>>>>>>>
36250>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
36253>>>>>>>        End
36253>>>>>>>>
36253>>>>>>>
36253>>>>>>>        Function_Return (Err = False)
36254>>>>>>>    End_Function
36255>>>>>>>
36255>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
36257>>>>>>>        Integer iCount iSize iIndex
36257>>>>>>>        String sDriverID
36257>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
36257>>>>>>>
36257>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
36258>>>>>>>        If (iSize = 0) Begin
36260>>>>>>>            Function_Return True
36261>>>>>>>        End
36261>>>>>>>>
36261>>>>>>>
36261>>>>>>>        Get AutoConnectionIDLogin to bOK
36262>>>>>>>        Move False to Err
36263>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
36266>>>>>>>        If (bIsOpen = False) Begin
36268>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
36269>>>>>>>            If (bIsOpen = False) Begin
36271>>>>>>>                Function_Return False
36272>>>>>>>            End
36272>>>>>>>>
36272>>>>>>>        End
36272>>>>>>>>
36272>>>>>>>
36272>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
36275>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
36276>>>>>>>            If (bIsSQLTable = True) Begin
36278>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36281>>>>>>>            End
36281>>>>>>>>
36281>>>>>>>
36281>>>>>>>        Move False to Err
36282>>>>>>>        Move 0 to LastErr
36283>>>>>>>        Decrement iSize
36284>>>>>>>
36284>>>>>>>        Structure_Start hTable sDriverID
36285>>>>>>>            for iCount from 0 to iSize
36291>>>>>>>>
36291>>>>>>>//                Move False to bIsSQLPrimaryKey
36291>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
36291>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
36291>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
36291>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
36291>>>>>>>//                #ENDIF
36291>>>>>>>                // We can't delete if this is a primary key index:
36291>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
36291>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
36292>>>>>>>                    Delete_Index hTable iIndex
36293>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
36293>>>>>>>//                End
36293>>>>>>>            Loop
36294>>>>>>>>
36294>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
36295>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36297>>>>>>>//        Move False to Err
36297>>>>>>>        Move 0 to LastErr
36298>>>>>>>
36298>>>>>>>        Set Action_Text of ghoStatusPanel to ""
36299>>>>>>>        Function_Return (Err = False)
36300>>>>>>>    End_Function
36301>>>>>>>
36301>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
36303>>>>>>>        Boolean bOK
36303>>>>>>>
36303>>>>>>>        Get AutoConnectionIDLogin to bOK
36304>>>>>>>        Move False to Err
36305>>>>>>>        Get OpenTableExclusive hTable to bOK
36306>>>>>>>        If (bOK = False) Begin
36308>>>>>>>            Function_Return False
36309>>>>>>>        End
36309>>>>>>>>
36309>>>>>>>        Structure_Start hTable
36310>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
36313>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
36314>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36316>>>>>>>
36316>>>>>>>        Set Action_Text of ghoStatusPanel to ""
36317>>>>>>>        Function_Return (Err = False)
36318>>>>>>>    End_Function
36319>>>>>>>
36319>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
36321>>>>>>>        Integer iCase
36321>>>>>>>        Boolean bOK
36321>>>>>>>
36321>>>>>>>        If (bUppercase = True) Begin
36323>>>>>>>            Move DF_CASE_IGNORED to iCase
36324>>>>>>>        End
36324>>>>>>>>
36324>>>>>>>        Else Begin
36325>>>>>>>            Move DF_CASE_USED to iCase
36326>>>>>>>        End
36326>>>>>>>>
36326>>>>>>>
36326>>>>>>>        Get AutoConnectionIDLogin to bOK
36327>>>>>>>        Move False to Err
36328>>>>>>>        Get OpenTableExclusive hTable to bOK
36329>>>>>>>        If (bOK = False) Begin
36331>>>>>>>            Function_Return False
36332>>>>>>>        End
36332>>>>>>>>
36332>>>>>>>        Structure_Start hTable
36333>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
36336>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
36337>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36339>>>>>>>
36339>>>>>>>        Set Action_Text of ghoStatusPanel to ""
36340>>>>>>>        Function_Return (Err = False)
36341>>>>>>>    End_Function
36342>>>>>>>
36342>>>>>>>    // To delete an index
36342>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
36344>>>>>>>        Integer iTableNo iNumSegments
36344>>>>>>>        String sDriverID
36344>>>>>>>        Boolean bOK bIsSQLTable
36344>>>>>>>
36344>>>>>>>        Get AutoConnectionIDLogin to bOK
36345>>>>>>>        Move False to Err
36346>>>>>>>        Move hTable to iTableNo
36347>>>>>>>        Get OpenTableExclusive hTable to bOK
36348>>>>>>>        If (bOK = False) Begin
36350>>>>>>>            Function_Return False
36351>>>>>>>        End
36351>>>>>>>>
36351>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
36354>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
36355>>>>>>>            If (bIsSQLTable = True) Begin
36357>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36360>>>>>>>            End
36360>>>>>>>>
36360>>>>>>>
36360>>>>>>>        // Check to see if the index exists or not...
36360>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36363>>>>>>>        If (iNumSegments = 0) Begin
36365>>>>>>>            Function_Return True // Then nothing to do.
36366>>>>>>>        End
36366>>>>>>>>
36366>>>>>>>
36366>>>>>>>        Structure_Start hTable sDriverID
36367>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
36368>>>>>>>            Delete_Index iTableNo iIndex
36369>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
36370>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
36371>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36373>>>>>>>
36373>>>>>>>        Set Action_Text of ghoStatusPanel to ""
36374>>>>>>>        Function_Return (Err = False)
36375>>>>>>>    End_Function
36376>>>>>>>
36376>>>>>>>    // Delete an Index Segment
36376>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
36378>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
36378>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
36378>>>>>>>        Integer iIndexType
36378>>>>>>>        String sDriverID
36378>>>>>>>
36378>>>>>>>        Get AutoConnectionIDLogin to bOK
36379>>>>>>>        Move False to Err
36380>>>>>>>
36380>>>>>>>        Get OpenTableExclusive hTable to bOK
36381>>>>>>>        If (bOK = False) Begin
36383>>>>>>>            Function_Return False
36384>>>>>>>        End
36384>>>>>>>>
36384>>>>>>>
36384>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
36385>>>>>>>            If (bIsSQLTable = True) Begin
36387>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36390>>>>>>>            End
36390>>>>>>>>
36390>>>>>>>
36390>>>>>>>        // Check to see if the index exists or not...
36390>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36393>>>>>>>        If (iNumSegments = 0) Begin
36395>>>>>>>            Function_Return False
36396>>>>>>>        End
36396>>>>>>>>
36396>>>>>>>
36396>>>>>>>        Move False to bIndexTemporary
36397>>>>>>>        Get psDriverID to sDriverID
36398>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
36399>>>>>>>        If (bSQLDriver) Begin
36401>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
36404>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
36407>>>>>>>                Move True to bIndexTemporary
36408>>>>>>>        End
36408>>>>>>>>
36408>>>>>>>
36408>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
36408>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
36410>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36413>>>>>>>            If (iSegment = iNumSegments) Begin
36415>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
36418>>>>>>>            End
36418>>>>>>>>
36418>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
36421>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
36427>>>>>>>>
36427>>>>>>>                    //*** Move index segment attributes
36427>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
36430>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
36433>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
36436>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
36439>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
36442>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
36445>>>>>>>                Loop
36446>>>>>>>>
36446>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
36449>>>>>>>            End
36449>>>>>>>>
36449>>>>>>>        End
36449>>>>>>>>
36449>>>>>>>
36449>>>>>>>        Else Begin
36450>>>>>>>           Structure_Start hTable
36451>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36454>>>>>>>               If (iSegment = iNumSegments) Begin
36456>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
36459>>>>>>>               End
36459>>>>>>>>
36459>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
36462>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
36468>>>>>>>>
36468>>>>>>>                       //*** Move index segment attributes
36468>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
36471>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
36474>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
36477>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
36480>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
36483>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
36486>>>>>>>                   Loop
36487>>>>>>>>
36487>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
36490>>>>>>>               End
36490>>>>>>>>
36490>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
36491>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36493>>>>>>>            Set Action_Text of ghoStatusPanel to ""
36494>>>>>>>        End
36494>>>>>>>>
36494>>>>>>>
36494>>>>>>>        Function_Return (Err = False)
36495>>>>>>>    End_Function
36496>>>>>>>
36496>>>>>>>    // Add/Insert an Index Segment
36496>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
36498>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
36498>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
36498>>>>>>>        Integer iIndexType
36498>>>>>>>        String sDriverId
36498>>>>>>>
36498>>>>>>>        Get AutoConnectionIDLogin to bOK
36499>>>>>>>        Move False to Err
36500>>>>>>>
36500>>>>>>>        Get OpenTableExclusive hTable to bOK
36501>>>>>>>        If (bOK = False) Begin
36503>>>>>>>            Function_Return False
36504>>>>>>>        End
36504>>>>>>>>
36504>>>>>>>
36504>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
36505>>>>>>>            If (bIsSQLTable = True) Begin
36507>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
36510>>>>>>>            End
36510>>>>>>>>
36510>>>>>>>
36510>>>>>>>        Move False to bIndexTemporary
36511>>>>>>>        // Check to see if the index exists or not...
36511>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36514>>>>>>>        If (iNumSegments = 0) Begin
36516>>>>>>>            Function_Return False
36517>>>>>>>        End
36517>>>>>>>>
36517>>>>>>>
36517>>>>>>>        Get psDriverID to sDriverID
36518>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
36519>>>>>>>        If (bSQLDriver) Begin
36521>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
36524>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
36527>>>>>>>                Move True to bIndexTemporary
36528>>>>>>>        End
36528>>>>>>>>
36528>>>>>>>
36528>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
36528>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
36530>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36533>>>>>>>
36533>>>>>>>           If (iSegment > iNumSegments) Begin
36535>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
36538>>>>>>>               Move (iNumSegments + 1) to iCurSegment
36539>>>>>>>           End
36539>>>>>>>>
36539>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
36542>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
36545>>>>>>>               Move iNumSegments to iCurSegment
36546>>>>>>>
36546>>>>>>>               While (iCurSegment > iSegment)
36550>>>>>>>                   //*** Move index segment attributes
36550>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
36553>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
36556>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
36559>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
36562>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
36565>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
36568>>>>>>>                   Decrement iCurSegment
36569>>>>>>>               Loop
36570>>>>>>>>
36570>>>>>>>
36570>>>>>>>               //*** Now set new segment attributes
36570>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
36573>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
36576>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
36579>>>>>>>           End
36579>>>>>>>>
36579>>>>>>>        End
36579>>>>>>>>
36579>>>>>>>
36579>>>>>>>        Else Begin
36580>>>>>>>        Structure_Start hTable
36581>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
36584>>>>>>>
36584>>>>>>>            If (iSegment > iNumSegments) Begin
36586>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
36589>>>>>>>                Move (iNumSegments + 1) to iCurSegment
36590>>>>>>>            End
36590>>>>>>>>
36590>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
36593>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
36596>>>>>>>                Move iNumSegments to iCurSegment
36597>>>>>>>
36597>>>>>>>                While (iCurSegment > iSegment)
36601>>>>>>>                    //*** Move index segment attributes
36601>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
36604>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
36607>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
36610>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
36613>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
36616>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
36619>>>>>>>                    Decrement iCurSegment
36620>>>>>>>                Loop
36621>>>>>>>>
36621>>>>>>>
36621>>>>>>>                //*** Now set new segment attributes
36621>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
36624>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
36627>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
36630>>>>>>>            End
36630>>>>>>>>
36630>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
36631>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
36633>>>>>>>            Set Action_Text of ghoStatusPanel to ""
36634>>>>>>>        End
36634>>>>>>>>
36634>>>>>>>
36634>>>>>>>        Function_Return (Err = False)
36635>>>>>>>    End_Function
36636>>>>>>>
36636>>>>>>>    // * Dummy function for the Studio's Code Explorer *
36636>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
36638>>>>>>>        Function_Return False
36639>>>>>>>    End_Function  
36640>>>>>>>    
36640>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
36640>>>>>>>    // for an SQL conversion.
36640>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
36642>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
36642>>>>>>>        
36642>>>>>>>        Move True to bConvertTo30FormatbOK
36643>>>>>>>        Move True to bRepairAndReindexOK
36644>>>>>>>        Move True to bFixBogusDatesOK
36645>>>>>>>        Move True to bMoveMiscFilesToBackupOK
36646>>>>>>>        
36646>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
36648>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
36649>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
36650>>>>>>>        End                                                                                
36650>>>>>>>>
36650>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
36652>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
36653>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
36654>>>>>>>        End
36654>>>>>>>>
36654>>>>>>>        If (bConvertTo30Format = True) Begin
36656>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
36657>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
36658>>>>>>>        End                                                 
36658>>>>>>>>
36658>>>>>>>        If (bRepairAndReindex = True) Begin
36660>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
36661>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
36662>>>>>>>        End  
36662>>>>>>>>
36662>>>>>>>        If (bFixBogusDates = True) Begin
36664>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
36665>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
36666>>>>>>>        End                                    
36666>>>>>>>>
36666>>>>>>>        
36666>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
36667>>>>>>>    End_Function
36668>>>>>>>
36668>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
36670>>>>>>>        Boolean bOK bFlexErrs bTemp
36670>>>>>>>        Handle hTable
36670>>>>>>>        String sTableName
36670>>>>>>>        Integer iCount iSize
36670>>>>>>>        
36670>>>>>>>        Move True to bOK
36671>>>>>>>        Move 0 to hTable    
36672>>>>>>>
36672>>>>>>>        Get UtilFilelistNoOfTables to iSize
36673>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
36674>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
36675>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
36676>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
36677>>>>>>>
36677>>>>>>>        Repeat
36677>>>>>>>>
36677>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
36678>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
36679>>>>>>>            Increment iCount
36680>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
36683>>>>>>>            If (hTable > 0) Begin
36685>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
36688>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
36689>>>>>>>                If (bFlexErrs = False) Begin
36691>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
36692>>>>>>>                    If (bTemp = False) Begin
36694>>>>>>>                        Move False to bOK
36695>>>>>>>                    End
36695>>>>>>>>
36695>>>>>>>                End
36695>>>>>>>>
36695>>>>>>>            End
36695>>>>>>>>
36695>>>>>>>        Until (hTable = 0)
36697>>>>>>>        
36697>>>>>>>        Set Action_Text of ghoStatusPanel to ""
36698>>>>>>>        Function_Return bOK
36699>>>>>>>    End_Function
36700>>>>>>>    
36700>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
36700>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
36700>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
36700>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
36702>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
36702>>>>>>>        String sRevision
36702>>>>>>>        
36702>>>>>>>        Get AutoConnectionIDLogin to bOK
36703>>>>>>>        If (bOK = False) Begin
36705>>>>>>>            Function_Return True
36706>>>>>>>        End
36706>>>>>>>>
36706>>>>>>>        Get OpenTableExclusive hTable to bOK
36707>>>>>>>        If (bOK = False) Begin
36709>>>>>>>            Function_Return True
36710>>>>>>>        End
36710>>>>>>>>
36710>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
36711>>>>>>>        If (bIsEmbedded = False) Begin
36713>>>>>>>            Function_Return True
36714>>>>>>>        End                             
36714>>>>>>>>
36714>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
36715>>>>>>>        If (bIsAlias = True) Begin
36717>>>>>>>            Function_Return True
36718>>>>>>>        End                     
36718>>>>>>>>
36718>>>>>>>        
36718>>>>>>>        Move False to Err
36719>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
36722>>>>>>>        If (sRevision contains "2.3") Begin
36724>>>>>>>            Move False to Err
36725>>>>>>>            Set Private.phCurrentTable to hTable
36726>>>>>>>            Structure_Start hTable    
36727>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
36730>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
36731>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
36733>>>>>>>            Set Action_Text of ghoStatusPanel to ""
36734>>>>>>>        End
36734>>>>>>>>
36734>>>>>>>        
36734>>>>>>>        Function_Return (Err = False)
36735>>>>>>>    End_Function
36736>>>>>>>
36736>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
36738>>>>>>>        Boolean bIgnore bExists bOK bResponse
36738>>>>>>>        Handle hTable   
36738>>>>>>>        String sTableName
36738>>>>>>>        
36738>>>>>>>        Move False to Err 
36739>>>>>>>        Move True to bOK
36740>>>>>>>        Move 0 to hTable
36741>>>>>>>        Repeat
36741>>>>>>>>
36741>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
36744>>>>>>>            If (hTable > 0) Begin
36746>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
36749>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
36750>>>>>>>                If (bIgnore = False) Begin
36752>>>>>>>                    Get _UtilTableExists hTable to bExists
36753>>>>>>>                    If (bExists = False) Begin
36755>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
36756>>>>>>>                        If (bResponse = False) Begin
36758>>>>>>>                            Move False to bOK
36759>>>>>>>                        End
36759>>>>>>>>
36759>>>>>>>                        
36759>>>>>>>                    End
36759>>>>>>>>
36759>>>>>>>                End
36759>>>>>>>>
36759>>>>>>>            End
36759>>>>>>>>
36759>>>>>>>        Until (hTable = 0)                     
36761>>>>>>>        
36761>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
36762>>>>>>>        Function_Return bOK
36763>>>>>>>    End_Function
36764>>>>>>>    
36764>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
36764>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
36764>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
36764>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
36764>>>>>>>    //
36764>>>>>>>    // The root of the problem is the following:
36764>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
36764>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
36764>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
36764>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
36764>>>>>>>    // an SQL error will be thrown;
36764>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
36764>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
36766>>>>>>>        Boolean bOK bIsAlias bIsSQL
36766>>>>>>>        Integer iCount iSize iDateSize
36766>>>>>>>        Handle hTable
36766>>>>>>>        String sLogicalName
36766>>>>>>>        Integer[] aTablesToCheck aDateFields
36768>>>>>>>
36768>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
36769>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
36770>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
36771>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
36772>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
36773>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
36774>>>>>>>
36774>>>>>>>        Move True to bOK
36775>>>>>>>        Decrement iSize
36776>>>>>>>        for iCount from 0 to iSize
36782>>>>>>>>
36782>>>>>>>            Move aTablesToCheck[iCount] to hTable
36783>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
36784>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
36785>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
36786>>>>>>>
36786>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
36789>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
36790>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
36791>>>>>>>
36791>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
36793>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
36794>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
36795>>>>>>>                If (iDateSize > 0) Begin
36797>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
36798>>>>>>>                    Close hTable
36799>>>>>>>                End
36799>>>>>>>>
36799>>>>>>>            End
36799>>>>>>>>
36799>>>>>>>        Loop
36800>>>>>>>>
36800>>>>>>>
36800>>>>>>>        Close DF_ALL
36801>>>>>>>        Function_Return bOK
36802>>>>>>>    End_Function
36803>>>>>>>
36803>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
36803>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
36805>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
36807>>>>>>>        Integer iSize iCount iType
36807>>>>>>>        Boolean bOpen bOK
36807>>>>>>>        
36807>>>>>>>        Get _UtilTableExists hTable to bOK
36808>>>>>>>        If (bOK = False) Begin
36810>>>>>>>            Set Private.phCurrentTable to hTable
36811>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
36812>>>>>>>>
36812>>>>>>>            Function_Return aDateFieldsEmpty
36813>>>>>>>        End
36813>>>>>>>>
36813>>>>>>>        Set Private.phCurrentTable to hTable
36814>>>>>>>        Set Private.piCurrentField to 0
36815>>>>>>>
36815>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
36815>>>>>>>        Open hTable
36817>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
36820>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
36820>>>>>>>        If (bOpen = False) Begin
36822>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
36822>>>>>>>            Function_Return aDateFieldsEmpty
36823>>>>>>>        End
36823>>>>>>>>
36823>>>>>>>
36823>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
36826>>>>>>>        For iCount from 1 to iSize
36832>>>>>>>>
36832>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
36835>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
36837>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
36838>>>>>>>            End
36838>>>>>>>>
36838>>>>>>>        Loop
36839>>>>>>>>
36839>>>>>>>
36839>>>>>>>        Function_Return aDateFields
36840>>>>>>>    End_Function
36841>>>>>>>
36841>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
36841>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
36841>>>>>>>    // and the record is saved
36841>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
36841>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
36841>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
36843>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
36843>>>>>>>        String sDriverID sDateMin
36843>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
36843>>>>>>>        Date dDate dDateMin
36843>>>>>>>        Integer[] iaChangeField
36844>>>>>>>
36844>>>>>>>        Get _UtilTableExists hTable to bOK
36845>>>>>>>        // I believe we should just skip files not found and not report an error.
36845>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
36845>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
36845>>>>>>>        // Especially considering that this call is probably done at the very
36845>>>>>>>        // beginning of a DUF update.
36845>>>>>>>        If (bOK = False) Begin
36847>>>>>>>//            Set Private.phCurrentTable to hTable
36847>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
36847>>>>>>>//            Function_Return False
36847>>>>>>>            Function_Return True
36848>>>>>>>        End
36848>>>>>>>>
36848>>>>>>>
36848>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
36848>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
36848>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
36851>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
36854>>>>>>>
36854>>>>>>>//        Send SetAllIndexesToBatch hTable True
36854>>>>>>>        Open hTable
36856>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
36859>>>>>>>        If (bOpened = False) Begin
36861>>>>>>>            Function_Return False
36862>>>>>>>        End
36862>>>>>>>>
36862>>>>>>>        
36862>>>>>>>        Set Private.phCurrentTable to hTable
36863>>>>>>>        Move 0 to iRecord
36864>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
36865>>>>>>>        Decrement iSize
36866>>>>>>>
36866>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
36869>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
36870>>>>>>>        If (iDriverIndex <> 0) Begin
36872>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
36875>>>>>>>            If (sDateMin = "") Begin
36877>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
36878>>>>>>>            End
36878>>>>>>>>
36878>>>>>>>            Else Begin
36879>>>>>>>                If (IsDate(sDateMin)) Begin
36881>>>>>>>                    Move sDateMin to dDateMin
36882>>>>>>>                End
36882>>>>>>>>
36882>>>>>>>                Else Begin
36883>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
36884>>>>>>>                End
36884>>>>>>>>
36884>>>>>>>            End
36884>>>>>>>>
36884>>>>>>>        End
36884>>>>>>>>
36884>>>>>>>        Else Begin
36885>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
36886>>>>>>>        End
36886>>>>>>>>
36886>>>>>>>
36886>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
36889>>>>>>>        Set piPosition   of ghoProgressBar to 0
36890>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
36891>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
36892>>>>>>>        Move False to Err
36893>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
36894>>>>>>>
36894>>>>>>>        Clear hTable
36895>>>>>>>        Repeat
36895>>>>>>>>
36895>>>>>>>            Vfind hTable 0 GT
36897>>>>>>>            Move Found to bFound
36898>>>>>>>            If (bFound = True) Begin
36900>>>>>>>                Move False to bSaveChanges
36901>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
36902>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
36903>>>>>>>                Decrement iSize
36904>>>>>>>                For iCount from 0 to iSize
36910>>>>>>>>
36910>>>>>>>                    Move aDateFields[iCount] to iField
36911>>>>>>>                    Get_Field_Value hTable iField to dDate
36914>>>>>>>                    If (bFixZeroDates = True) Begin
36916>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
36917>>>>>>>                    End
36917>>>>>>>>
36917>>>>>>>                    Else Begin
36918>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
36919>>>>>>>                    End
36919>>>>>>>>
36919>>>>>>>                    If (bChange = True) Begin
36921>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
36922>>>>>>>                    End
36922>>>>>>>>
36922>>>>>>>                Loop
36923>>>>>>>>
36923>>>>>>>
36923>>>>>>>                // Only change Date fields that needs to be changed.
36923>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
36925>>>>>>>                    Reread hTable
36929>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
36930>>>>>>>                        Decrement iSize
36931>>>>>>>                        For iCount from 0 to iSize
36937>>>>>>>>
36937>>>>>>>                            Move iaChangeField[iCount] to iField
36938>>>>>>>                            Set Private.piCurrentField to iField
36939>>>>>>>                            Set_Field_Value hTable iField to dDateMin
36942>>>>>>>                        Loop
36943>>>>>>>>
36943>>>>>>>                        Move False to Err
36944>>>>>>>                        SaveRecord hTable
36945>>>>>>>                    Unlock
36946>>>>>>>>
36946>>>>>>>                End
36946>>>>>>>>
36946>>>>>>>
36946>>>>>>>                Increment iRecord
36947>>>>>>>                // Increment the StatusPanel counter and check the
36947>>>>>>>                // cancel status every 100 records rather than every
36947>>>>>>>                // record, it's way faster.
36947>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
36949>>>>>>>                    Send DoAdvance of ghoProgressBar
36950>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
36951>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
36952>>>>>>>                End
36952>>>>>>>>
36952>>>>>>>            End
36952>>>>>>>>
36952>>>>>>>        Until (bFound = False)
36954>>>>>>>
36954>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
36957>>>>>>>        If (bResetIndexesToOnLine = True) Begin
36959>>>>>>>            Send SetAllIndexesToBatch hTable False
36960>>>>>>>        End
36960>>>>>>>>
36960>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
36961>>>>>>>
36961>>>>>>>        Function_Return (Err = False)
36962>>>>>>>    End_Function
36963>>>>>>>
36963>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
36963>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
36963>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
36965>>>>>>>        Boolean bIsSame
36965>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
36965>>>>>>>
36965>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
36966>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
36967>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
36968>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
36969>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
36970>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
36971>>>>>>>
36971>>>>>>>        If (bCompareFilelistUppercase = True) Begin
36973>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
36974>>>>>>>        End
36974>>>>>>>>
36974>>>>>>>        Else Begin
36975>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
36976>>>>>>>        End
36976>>>>>>>>
36976>>>>>>>        If (bIsSame = False) Begin
36978>>>>>>>            Function_Return False
36979>>>>>>>        End
36979>>>>>>>>
36979>>>>>>>
36979>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
36980>>>>>>>        If (bIsSame = False) Begin
36982>>>>>>>            Function_Return False
36983>>>>>>>        End
36983>>>>>>>>
36983>>>>>>>
36983>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
36984>>>>>>>        If (bIsSame = False) Begin
36986>>>>>>>            Function_Return False
36987>>>>>>>        End
36987>>>>>>>>
36987>>>>>>>
36987>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
36988>>>>>>>        If (bIsSame = False) Begin
36990>>>>>>>            Function_Return False
36991>>>>>>>        End
36991>>>>>>>>
36991>>>>>>>
36991>>>>>>>        Function_Return bIsSame
36992>>>>>>>    End_Function
36993>>>>>>>
36993>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
36995>>>>>>>        Handle hTableFrom hTableTo
36995>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
36995>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
36995>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
36995>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
36995>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
36996>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
36996>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
36997>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
36997>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
36998>>>>>>>
36998>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
36999>>>>>>>        If (bIsSame = True) Begin
37001>>>>>>>            Function_Return True
37002>>>>>>>        End
37002>>>>>>>>
37002>>>>>>>
37002>>>>>>>        Move False to bFilelistError
37003>>>>>>>        Move True to bIsSame
37004>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
37005>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
37006>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
37007>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
37008>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
37009>>>>>>>
37009>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
37010>>>>>>>        Get _TableNameOnly sRootName             to sRootName
37011>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
37012>>>>>>>
37012>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
37012>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
37012>>>>>>>        If (bCodeGenerateMode = True) Begin
37014>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
37014>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
37016>>>>>>>                Function_Return False
37017>>>>>>>            End
37017>>>>>>>>
37017>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
37018>>>>>>>            If (bIsSame = False) Begin
37020>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
37021>>>>>>>                Move True to bFilelistError
37022>>>>>>>                Function_Return False
37023>>>>>>>            End
37023>>>>>>>>
37023>>>>>>>        End
37023>>>>>>>>
37023>>>>>>>
37023>>>>>>>        If (bCodeGenerateMode = False) Begin
37025>>>>>>>            // Then we want to create this table
37025>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
37027>>>>>>>                Function_Return False
37028>>>>>>>            End
37028>>>>>>>>
37028>>>>>>>
37028>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
37029>>>>>>>            If (bIsSame = False) Begin
37031>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
37032>>>>>>>>
37032>>>>>>>                Move True to bFilelistError
37033>>>>>>>                Function_Return False
37034>>>>>>>            End
37034>>>>>>>>
37034>>>>>>>        End
37034>>>>>>>>
37034>>>>>>>
37034>>>>>>>        // Check columns:
37034>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
37035>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
37036>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
37037>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
37038>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
37039>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
37040>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
37041>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
37042>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
37043>>>>>>>        If (bIsSame = False) Begin
37045>>>>>>>            Function_Return False
37046>>>>>>>        End
37046>>>>>>>>
37046>>>>>>>
37046>>>>>>>        // ...then check indexes:
37046>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
37047>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
37048>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
37049>>>>>>>        If (bIsSame = False) Begin
37051>>>>>>>            Function_Return False
37052>>>>>>>        End
37052>>>>>>>>
37052>>>>>>>
37052>>>>>>>        // ...and finally relationships:
37052>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
37053>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
37054>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
37055>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
37056>>>>>>>
37056>>>>>>>        Function_Return (bIsSame = True)
37057>>>>>>>    End_Function
37058>>>>>>>
37058>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
37058>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
37060>>>>>>>        Handle hTable
37060>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
37060>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
37060>>>>>>>
37060>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
37062>>>>>>>            Move True to bFilelistError
37063>>>>>>>            Function_Return False
37064>>>>>>>        End
37064>>>>>>>>
37064>>>>>>>
37064>>>>>>>        Move APITableCompare.hTable to hTable
37065>>>>>>>        Move True  to bIsSame
37066>>>>>>>        Move False to bFilelistError
37067>>>>>>>
37067>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
37069>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
37070>>>>>>>        End
37070>>>>>>>>
37070>>>>>>>        Else Begin
37071>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
37072>>>>>>>        End
37072>>>>>>>>
37072>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
37073>>>>>>>
37073>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
37074>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
37075>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
37076>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
37077>>>>>>>
37077>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
37077>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
37077>>>>>>>        If (bCodeGenerateMode = True) Begin
37079>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
37079>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
37081>>>>>>>                Function_Return False
37082>>>>>>>            End
37082>>>>>>>>
37082>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
37083>>>>>>>            If (bIsSame = False) Begin
37085>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
37086>>>>>>>                Move True to bFilelistError
37087>>>>>>>                Function_Return False
37088>>>>>>>            End
37088>>>>>>>>
37088>>>>>>>        End
37088>>>>>>>>
37088>>>>>>>
37088>>>>>>>        If (bCodeGenerateMode = False) Begin
37090>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
37092>>>>>>>                // Then we might want to create this table
37092>>>>>>>                Function_Return False
37093>>>>>>>            End
37093>>>>>>>>
37093>>>>>>>
37093>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
37094>>>>>>>            If (bIsSame = False) Begin
37096>>>>>>>                Function_Return False
37097>>>>>>>            End
37097>>>>>>>>
37097>>>>>>>
37097>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
37098>>>>>>>            If (bIsSame = False) Begin
37100>>>>>>>                Function_Return False
37101>>>>>>>            End
37101>>>>>>>>
37101>>>>>>>
37101>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
37102>>>>>>>            If (bIsSame = False) Begin
37104>>>>>>>                Function_Return False
37105>>>>>>>            End
37105>>>>>>>>
37105>>>>>>>
37105>>>>>>>            // Check table names et al.
37105>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
37106>>>>>>>            If (bIsSame = False) Begin
37108>>>>>>>                Function_Return False
37109>>>>>>>            End
37109>>>>>>>>
37109>>>>>>>        End
37109>>>>>>>>
37109>>>>>>>
37109>>>>>>>        // Check Columns:
37109>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
37110>>>>>>>        If (bIsSame = False) Begin
37112>>>>>>>            Function_Return False
37113>>>>>>>        End
37113>>>>>>>>
37113>>>>>>>
37113>>>>>>>        // ...then check Indexes:
37113>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
37114>>>>>>>        If (bIsSame = False) Begin
37116>>>>>>>            Function_Return False
37117>>>>>>>        End
37117>>>>>>>>
37117>>>>>>>
37117>>>>>>>        // ...and finally Relationships:
37117>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
37118>>>>>>>
37118>>>>>>>        Function_Return (bIsSame = True)
37119>>>>>>>    End_Function
37120>>>>>>>
37120>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
37120>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
37120>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
37120>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
37120>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
37122>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37122>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37122>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
37122>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
37124>>>>>>>        tAPIColumn[]    aApiColumns
37124>>>>>>>        tAPIColumn[]    aApiColumns
37125>>>>>>>        tAPIIndex[]     aApiIndexes
37125>>>>>>>        tAPIIndex[]     aApiIndexes
37126>>>>>>>        tAPIRelation[]  aApiRelations
37126>>>>>>>        tAPIRelation[]  aApiRelations
37127>>>>>>>        Handle hTable
37127>>>>>>>        Integer iCount
37127>>>>>>>        Boolean bUserCancel bOK
37127>>>>>>>        String sLogicalName sMessageText
37127>>>>>>>
37127>>>>>>>        Get AutoConnectionIDLogin to bOK
37128>>>>>>>        Move 0 to hTable
37129>>>>>>>        If (bFromTables = True) Begin
37131>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
37132>>>>>>>            If (bCompareUtil = True) Begin
37134>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
37135>>>>>>>            End
37135>>>>>>>>
37135>>>>>>>        End
37135>>>>>>>>
37135>>>>>>>        Else Begin
37136>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
37137>>>>>>>            If (bCompareUtil = True) Begin
37139>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
37140>>>>>>>            End
37140>>>>>>>>
37140>>>>>>>        End
37140>>>>>>>>
37140>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
37141>>>>>>>
37141>>>>>>>        Get UtilFilelistNoOfTables to iCount
37142>>>>>>>        Set piMaximum of ghoProgressBar to iCount
37143>>>>>>>        Move 0 to iCount
37144>>>>>>>
37144>>>>>>>        Repeat
37144>>>>>>>>
37144>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37147>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
37149>>>>>>>
37149>>>>>>>                Open hTable
37151>>>>>>>                // ToDo: Needs to be revised
37151>>>>>>>                // For some reason tables may be reported as "unopened", while in
37151>>>>>>>                // fact the open was successful (!)
37151>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37151>>>>>>>//                If (bIsOpen = False) Begin
37151>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
37151>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
37151>>>>>>>//                    Function_Return aApiTablesEmpty
37151>>>>>>>//                End
37151>>>>>>>
37151>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
37154>>>>>>>                Set piPosition of ghoProgressBar to iCount
37155>>>>>>>                Send DoAdvance of ghoProgressBarOverall
37156>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
37157>>>>>>>
37157>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
37158>>>>>>>//                Close hTable DF_PERMANENT
37158>>>>>>>                Increment iCount
37159>>>>>>>            End
37159>>>>>>>>
37159>>>>>>>
37159>>>>>>>            If (bStatusPanel = True) Begin
37161>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
37162>>>>>>>                If (bUserCancel = True) Begin
37164>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
37165>>>>>>>                    Function_Return aApiTablesEmpty
37166>>>>>>>                End
37166>>>>>>>>
37166>>>>>>>            End
37166>>>>>>>>
37166>>>>>>>
37166>>>>>>>        Until (hTable = 0)
37168>>>>>>>
37168>>>>>>>        Function_Return aApiTables
37169>>>>>>>    End_Function
37170>>>>>>>
37170>>>>>>>    // Returns a 'single' table APITable struct.
37170>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
37172>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37172>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37172>>>>>>>        tAPITable         ApiTable ApiTableEmpty
37172>>>>>>>        tAPITable         ApiTable ApiTableEmpty
37172>>>>>>>        tAPIColumn[]     aApiColumns
37172>>>>>>>        tAPIColumn[]     aApiColumns
37173>>>>>>>        tAPIIndex[]      aApiIndexes
37173>>>>>>>        tAPIIndex[]      aApiIndexes
37174>>>>>>>        tAPIRelation[]   aApiRelations
37174>>>>>>>        tAPIRelation[]   aApiRelations
37175>>>>>>>        Boolean bIsOpen
37175>>>>>>>
37175>>>>>>>        Open hTable
37177>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37180>>>>>>>        If (bIsOpen = False) Begin
37182>>>>>>>            Move True to ApiTableEmpty.bError
37183>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
37184>>>>>>>            Function_Return ApiTableEmpty
37185>>>>>>>        End
37185>>>>>>>>
37185>>>>>>>
37185>>>>>>>        // Fill Table Name Info
37185>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
37186>>>>>>>
37186>>>>>>>        // Fill columns
37186>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
37187>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
37189>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
37191>>>>>>>                Move True to ApiTableEmpty.bError
37192>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
37193>>>>>>>                Function_Return ApiTableEmpty
37194>>>>>>>            End
37194>>>>>>>>
37194>>>>>>>        End
37194>>>>>>>>
37194>>>>>>>
37194>>>>>>>        // Fill indexes
37194>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
37195>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
37197>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
37199>>>>>>>                Move True to ApiTableEmpty.bError
37200>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
37201>>>>>>>                Function_Return ApiTableEmpty
37202>>>>>>>            End
37202>>>>>>>>
37202>>>>>>>        End
37202>>>>>>>>
37202>>>>>>>
37202>>>>>>>        // Fill relationships
37202>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
37203>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
37205>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
37207>>>>>>>                Move True to ApiTableEmpty.bError
37208>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
37209>>>>>>>                Function_Return ApiTableEmpty
37210>>>>>>>            End
37210>>>>>>>>
37210>>>>>>>        End
37210>>>>>>>>
37210>>>>>>>
37210>>>>>>>        Move hTable             to ApiTable.hTable
37211>>>>>>>        Move bFromTables        to ApiTable.bFromTable
37212>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
37213>>>>>>>
37213>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
37214>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
37215>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
37216>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
37217>>>>>>>
37217>>>>>>>        Function_Return ApiTable
37218>>>>>>>    End_Function
37219>>>>>>>
37219>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
37221>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
37221>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
37221>>>>>>>        Boolean bIsOpen
37221>>>>>>>
37221>>>>>>>        Open hTable
37223>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37226>>>>>>>        If (bIsOpen = False) Begin
37228>>>>>>>            Move True   to APITableNameInfoEmpty.bError
37229>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
37230>>>>>>>            Function_Return APITableNameInfoEmpty
37231>>>>>>>        End
37231>>>>>>>>
37231>>>>>>>
37231>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
37232>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
37235>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
37238>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
37241>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
37244>>>>>>>
37244>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
37245>>>>>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
37246>>>>>>>
37246>>>>>>>        Function_Return APITableNameInfo
37247>>>>>>>    End_Function
37248>>>>>>>
37248>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
37250>>>>>>>        Integer iSize iCount iItem
37250>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37250>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37250>>>>>>>
37250>>>>>>>        Move -1 to iItem
37251>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
37252>>>>>>>        Decrement iSize
37253>>>>>>>        for iCount from 0 to iSize
37259>>>>>>>>
37259>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
37260>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
37262>>>>>>>                Move iCount to iItem
37263>>>>>>>                Move iSize  to iCount // We're done.
37264>>>>>>>            End
37264>>>>>>>>
37264>>>>>>>        Loop
37265>>>>>>>>
37265>>>>>>>
37265>>>>>>>        Function_Return iItem
37266>>>>>>>    End_Function
37267>>>>>>>
37267>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
37269>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
37272>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
37275>>>>>>>
37275>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
37278>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
37281>>>>>>>
37281>>>>>>>        Function_Return (EQ)
37282>>>>>>>    End_Function
37283>>>>>>>
37283>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
37285>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
37285>>>>>>>        Handle hTable
37285>>>>>>>        tAPITable[] aAPITableFromAndTo
37285>>>>>>>        tAPITable[] aAPITableFromAndTo
37286>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
37286>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
37286>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
37286>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
37286>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
37286>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
37287>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
37287>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
37288>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
37288>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
37289>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
37289>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
37290>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
37290>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
37290>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
37290>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
37293>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
37293>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
37296>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
37296>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
37299>>>>>>>
37299>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
37300>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
37301>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
37303>>>>>>>            Function_Return aAPITableCompare
37304>>>>>>>        End
37304>>>>>>>>
37304>>>>>>>
37304>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
37305>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
37306>>>>>>>
37306>>>>>>>        Move 0 to iItem
37307>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
37308>>>>>>>        Decrement iSize
37309>>>>>>>        for iCount from 0 to iSize
37315>>>>>>>>
37315>>>>>>>
37315>>>>>>>            Move iCount to iItemFrom
37316>>>>>>>            Move iCount to iItemTo
37317>>>>>>>            Move APITableEmpty to APITableFrom
37318>>>>>>>            Move APITableEmpty to APITableTo
37319>>>>>>>
37319>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
37321>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
37322>>>>>>>            End
37322>>>>>>>>
37322>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
37324>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
37325>>>>>>>            End
37325>>>>>>>>
37325>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
37327>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
37328>>>>>>>                Move (iCount + 1) to iItemTo
37329>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
37330>>>>>>>            End
37330>>>>>>>>
37330>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
37332>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
37333>>>>>>>                If (iItemTo <> -1) Begin
37335>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
37336>>>>>>>                End
37336>>>>>>>>
37336>>>>>>>                Else Begin
37337>>>>>>>                    Move APITableEmpty to APITableTo
37338>>>>>>>                End
37338>>>>>>>>
37338>>>>>>>            End
37338>>>>>>>>
37338>>>>>>>
37338>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
37339>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
37340>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
37341>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
37342>>>>>>>
37342>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
37343>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
37344>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
37345>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
37346>>>>>>>
37346>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
37347>>>>>>>
37347>>>>>>>            If (hTable > 0) Begin
37349>>>>>>>
37349>>>>>>>                // Table info:
37349>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
37350>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
37351>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
37352>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
37353>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
37354>>>>>>>
37354>>>>>>>                // Column info:
37354>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
37355>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
37356>>>>>>>
37356>>>>>>>                // Index info:
37356>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
37357>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
37358>>>>>>>
37358>>>>>>>                // Relation info:
37358>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
37359>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
37360>>>>>>>
37360>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
37361>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
37362>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
37363>>>>>>>                If (iItemTo > iItemFrom) Begin
37365>>>>>>>                    Increment iCount
37366>>>>>>>                End
37366>>>>>>>>
37366>>>>>>>                Increment iItem
37367>>>>>>>            End
37367>>>>>>>>
37367>>>>>>>
37367>>>>>>>        Loop
37368>>>>>>>>
37368>>>>>>>
37368>>>>>>>        Function_Return aAPITableCompare
37369>>>>>>>    End_Function
37370>>>>>>>
37370>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
37372>>>>>>>        Integer iSize iCount iItem
37372>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37372>>>>>>>        tAPITableNameInfo ApiTableNameInfo
37372>>>>>>>
37372>>>>>>>        Move -1 to iItem
37373>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
37374>>>>>>>        Decrement iSize
37375>>>>>>>        For iCount from 0 to iSize
37381>>>>>>>>
37381>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
37382>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
37384>>>>>>>                Move iCount to iItem
37385>>>>>>>                Move iSize  to iCount // We're done.
37386>>>>>>>            End
37386>>>>>>>>
37386>>>>>>>        Loop
37387>>>>>>>>
37387>>>>>>>
37387>>>>>>>        Function_Return iItem
37388>>>>>>>    End_Function
37389>>>>>>>
37389>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
37391>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
37391>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
37391>>>>>>>
37391>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
37393>>>>>>>            Function_Return APITableNameInfoCompare
37394>>>>>>>        End
37394>>>>>>>>
37394>>>>>>>
37394>>>>>>>        // FROM database info:
37394>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
37396>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
37397>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
37398>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
37399>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
37400>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
37401>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
37402>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
37403>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
37404>>>>>>>        End
37404>>>>>>>>
37404>>>>>>>
37404>>>>>>>        // TO database info:
37404>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
37406>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
37407>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
37408>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
37409>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
37410>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
37411>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
37412>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
37413>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
37414>>>>>>>        End
37414>>>>>>>>
37414>>>>>>>
37414>>>>>>>        Function_Return APITableNameInfoCompare
37415>>>>>>>    End_Function
37416>>>>>>>
37416>>>>>>>    // Note:
37416>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
37416>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
37416>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
37416>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
37416>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
37416>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
37418>>>>>>>        String sTableName
37418>>>>>>>        Boolean bOpen bExists bOK
37418>>>>>>>
37418>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
37419>>>>>>>        If (bExists = False) Begin
37421>>>>>>>            Function_Return ""
37422>>>>>>>        End
37422>>>>>>>>
37422>>>>>>>
37422>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
37423>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
37426>>>>>>>        If (bOpen = False) Begin
37428>>>>>>>            Get AutoConnectionIDLogin to bOK
37429>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37430>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
37431>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
37432>>>>>>>            Open hTable
37434>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37435>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
37436>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
37437>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
37440>>>>>>>        End
37440>>>>>>>>
37440>>>>>>>        If (bOpen = True) Begin
37442>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
37443>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
37446>>>>>>>            // If blank it is an embedded table:
37446>>>>>>>            If (sTableName = "") Begin
37448>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
37451>>>>>>>                Move 0 to LastErr
37452>>>>>>>                Move False to Err
37453>>>>>>>            End
37453>>>>>>>>
37453>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
37454>>>>>>>        End
37454>>>>>>>>
37454>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
37455>>>>>>>        Move 0 to LastErr
37456>>>>>>>
37456>>>>>>>        Function_Return sTableName
37457>>>>>>>    End_Function
37458>>>>>>>
37458>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
37458>>>>>>>    // Returns 0 if unsuccessful.
37458>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
37458>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
37460>>>>>>>        String sValue sPrefixTableName sDriverID
37460>>>>>>>        Handle hTable hRetval
37460>>>>>>>
37460>>>>>>>        Get psDriverID to sDriverID
37461>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
37463>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
37464>>>>>>>        End
37464>>>>>>>>
37464>>>>>>>        Move 0 to hTable
37465>>>>>>>        Move 0 to hRetval
37466>>>>>>>        Repeat
37466>>>>>>>>
37466>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37469>>>>>>>            If (hTable <> 0) Begin
37471>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
37474>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
37476>>>>>>>                    Move hTable to hRetval
37477>>>>>>>                    Move 0 to hTable
37478>>>>>>>                End
37478>>>>>>>>
37478>>>>>>>            End
37478>>>>>>>>
37478>>>>>>>        Until (hTable = 0)
37480>>>>>>>
37480>>>>>>>        Function_Return hRetval
37481>>>>>>>    End_Function
37482>>>>>>>
37482>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
37482>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
37482>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
37484>>>>>>>        Boolean bOK bExists
37484>>>>>>>        String sDataPath sBackupFolder
37484>>>>>>>
37484>>>>>>>        Close DF_ALL DF_PERMANENT
37485>>>>>>>        Send DoAdvance of ghoProgressBar
37486>>>>>>>
37486>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
37487>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
37488>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
37489>>>>>>>        Get vFolderFormat sDataPath to sDataPath
37490>>>>>>>
37490>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
37491>>>>>>>        If (bExists = False) Begin
37493>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
37494>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
37495>>>>>>>            If (bExists = False) Begin
37497>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
37498>>>>>>>>
37498>>>>>>>                Function_Return False
37499>>>>>>>            End
37499>>>>>>>>
37499>>>>>>>        End
37499>>>>>>>>
37499>>>>>>>
37499>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
37500>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
37501>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
37502>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
37503>>>>>>>        // We need to wait for Windows before we can copy files back
37503>>>>>>>        Sleep 2  
37504>>>>>>>        
37504>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
37504>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
37505>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
37506>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
37507>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
37508>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
37509>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
37510>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
37510>>>>>>>        
37510>>>>>>>
37510>>>>>>>        Set Message_Text of ghoStatusPanel to ""
37511>>>>>>>        Function_Return True
37512>>>>>>>    End_Function
37513>>>>>>>    
37513>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
37515>>>>>>>        Boolean bOK bRetval
37515>>>>>>>        Handle hTable
37515>>>>>>>        Integer iSize iCount
37515>>>>>>>        
37515>>>>>>>        Move True to bOK
37516>>>>>>>        Get UtilFilelistNoOfTables to iSize
37517>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
37518>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
37519>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
37520>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
37521>>>>>>>
37521>>>>>>>        Repeat
37521>>>>>>>>
37521>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
37522>>>>>>>            Increment iCount
37523>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37526>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
37528>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
37529>>>>>>>                If (bRetval = False) Begin
37531>>>>>>>                    Move False to bOK
37532>>>>>>>                End
37532>>>>>>>>
37532>>>>>>>            End
37532>>>>>>>>
37532>>>>>>>        Until (hTable = 0)
37534>>>>>>>                
37534>>>>>>>        Function_Return bOK
37535>>>>>>>    End_Function           
37536>>>>>>>    
37536>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
37536>>>>>>>    // After the header has been repaired - also makes a re-index.  
37536>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
37536>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
37538>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
37538>>>>>>>        Integer iRetval
37538>>>>>>>        String sRootName sFileName sDataPath
37538>>>>>>>        
37538>>>>>>>        Move False to Err
37539>>>>>>>        Move 0 to LastErr 
37540>>>>>>>        Move True to bOK
37541>>>>>>>        
37541>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
37542>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
37544>>>>>>>            Function_Return True
37545>>>>>>>        End
37545>>>>>>>>
37545>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
37546>>>>>>>        If (bIsAlias = True) Begin
37548>>>>>>>            Function_Return True
37549>>>>>>>        End
37549>>>>>>>>
37549>>>>>>>        
37549>>>>>>>        // Check for bad file and remove if exists
37549>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
37552>>>>>>>        Set private.phCurrentTable to hTable  
37553>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
37554>>>>>>>        
37554>>>>>>>        // This is important! Else it can happen that the table can't be opened,
37554>>>>>>>        // with a "4077 - File in use" error.
37554>>>>>>>        Close DF_ALL DF_PERMANENT    
37555>>>>>>>        Open hTable
37557>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37560>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
37561>>>>>>>        If (bIsOpen = False) Begin
37563>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
37564>>>>>>>>
37564>>>>>>>            Function_Return False        
37565>>>>>>>        End
37565>>>>>>>>
37565>>>>>>>
37565>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
37566>>>>>>>        If (bBadExists = True) Begin
37568>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
37569>>>>>>>            Get vDeleteFile sFileName to iRetval
37570>>>>>>>        End
37570>>>>>>>>
37570>>>>>>>        
37570>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
37571>>>>>>>        
37571>>>>>>>        Move False to Err
37572>>>>>>>        // **** Repair and reindex the table. ****
37572>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
37573>>>>>>>
37573>>>>>>>        // Check for bad file: if it exists, something went wrong
37573>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
37574>>>>>>>        Get vFolderFormat sDataPath to sDataPath
37575>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
37576>>>>>>>        If (bBadExists = True) Begin
37578>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
37579>>>>>>>>
37579>>>>>>>            Move False to bOK
37580>>>>>>>        End
37580>>>>>>>>
37580>>>>>>>        Close hTable
37581>>>>>>>
37581>>>>>>>        Function_Return bOK
37582>>>>>>>    End_Function
37583>>>>>>>
37583>>>>>>>    // Repair and reindex the named DataFlex data-table.
37583>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
37583>>>>>>>    // so use with care (make sure you only pass embedded table names).
37583>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
37585>>>>>>>        String sMode
37585>>>>>>>        Integer iVoid
37585>>>>>>>
37585>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
37586>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
37587>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
37588>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
37593>>>>>>>        Set Message_Text of ghoStatusPanel to ""
37594>>>>>>>        Function_Return (iVoid = 0)
37595>>>>>>>    End_Function
37596>>>>>>>
37596>>>>>>>    // Returns _two_ arrays.
37596>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
37596>>>>>>>    // Also returns all files that are Alias files in a second array.
37596>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
37596>>>>>>>    //            the DoSetAllMasterAndAlias message.
37596>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
37598>>>>>>>        Integer[] iaFileIsAlias
37599>>>>>>>        Integer hTable iFileAlias iSize
37599>>>>>>>        Boolean bOpen
37599>>>>>>>
37599>>>>>>>        Move 0 to hTable
37600>>>>>>>        Repeat
37600>>>>>>>>
37600>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
37603>>>>>>>            If (hTable <> 0) Begin
37605>>>>>>>                Open hTable
37607>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
37610>>>>>>>                If (bOpen = True) Begin
37612>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
37615>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
37617>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
37618>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
37619>>>>>>>                    End
37619>>>>>>>>
37619>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
37622>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
37623>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
37624>>>>>>>                    End
37624>>>>>>>>
37624>>>>>>>                End
37624>>>>>>>>
37624>>>>>>>            End
37624>>>>>>>>
37624>>>>>>>        Until (hTable = 0)
37626>>>>>>>
37626>>>>>>>        Function_Return iaFileIsAlias
37627>>>>>>>    End_Function  
37628>>>>>>>    
37628>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
37628>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
37630>>>>>>>        String sMode
37630>>>>>>>        Integer iRepairNeeded bIsOpen
37630>>>>>>>
37630>>>>>>>        Move "0" to sMode
37631>>>>>>>        Set private.phCurrentTable to hTable 
37632>>>>>>>        Close hTable
37633>>>>>>>        Open hTable
37635>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37638>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
37643>>>>>>>
37643>>>>>>>        Function_Return iRepairNeeded
37644>>>>>>>    End_Function
37645>>>>>>>
37645>>>>>>>    // Helper function
37645>>>>>>>    // Takes two params:
37645>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
37645>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
37645>>>>>>>    // Returns:
37645>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
37645>>>>>>>    //  DF_FILE_IS_MASTER if master
37645>>>>>>>    //  DF_FILE_IS_ALIAS if alias
37645>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
37647>>>>>>>        Integer i iSize
37647>>>>>>>
37647>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
37648>>>>>>>        Decrement iSize
37649>>>>>>>        for i from 0 to iSize
37655>>>>>>>>
37655>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
37657>>>>>>>                Function_Return DF_FILE_IS_MASTER
37658>>>>>>>            End
37658>>>>>>>>
37658>>>>>>>        Loop
37659>>>>>>>>
37659>>>>>>>
37659>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
37660>>>>>>>        Decrement iSize
37661>>>>>>>        for i from 0 to iSize
37667>>>>>>>>
37667>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
37669>>>>>>>                Function_Return DF_FILE_IS_ALIAS
37670>>>>>>>            End
37670>>>>>>>>
37670>>>>>>>        Loop
37671>>>>>>>>
37671>>>>>>>
37671>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
37672>>>>>>>    End_Function
37673>>>>>>>
37673>>>>>>>    // Determine the available indexes of a table.
37673>>>>>>>    //
37673>>>>>>>    // Arguments:
37673>>>>>>>    //   Handle hTable - The number of the table
37673>>>>>>>    //
37673>>>>>>>    // Returns:
37673>>>>>>>    //   String - A string to be used with the sort command
37673>>>>>>>    //   to re-index all indexes of a table.
37673>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
37675>>>>>>>        String  sSortString
37675>>>>>>>        Integer iLastIndex iNumSegments iCount
37675>>>>>>>
37675>>>>>>>        Move "" to sSortString
37676>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
37679>>>>>>>
37679>>>>>>>        for iCount from 1 to iLastIndex
37685>>>>>>>>
37685>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
37688>>>>>>>            If iNumSegments Begin
37690>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
37693>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
37694>>>>>>>            End
37694>>>>>>>>
37694>>>>>>>        Loop
37695>>>>>>>>
37695>>>>>>>
37695>>>>>>>        Function_Return sSortString
37696>>>>>>>    End_Function
37697>>>>>>>
37697>>>>>>>    
37697>>>>>>>    // * Dummy function for the Studio's Code Explorer *
37697>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
37699>>>>>>>        Function_Return False
37700>>>>>>>    End_Function
37701>>>>>>>
37701>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
37701>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
37703>>>>>>>        Boolean bIsSame
37703>>>>>>>        Integer iCount iColumns iColumn
37703>>>>>>>
37703>>>>>>>        Move True to bIsSame
37704>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
37705>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
37706>>>>>>>        Decrement iColumns
37707>>>>>>>
37707>>>>>>>        for iCount from 0 to iColumns
37713>>>>>>>>
37713>>>>>>>            Set piPosition of ghoProgressBar to iCount
37714>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
37715>>>>>>>            If (bIsSame = False) Begin
37717>>>>>>>                Function_Return False
37718>>>>>>>            End
37718>>>>>>>>
37718>>>>>>>        Loop
37719>>>>>>>>
37719>>>>>>>
37719>>>>>>>        Function_Return (bIsSame = True)
37720>>>>>>>    End_Function
37721>>>>>>>
37721>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
37721>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
37723>>>>>>>        Integer iFromType iToType iDbType
37723>>>>>>>        tColumnType ColumnType
37723>>>>>>>        tColumnType ColumnType
37723>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
37723>>>>>>>
37723>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
37725>>>>>>>            Function_Return False
37726>>>>>>>        End
37726>>>>>>>>
37726>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
37728>>>>>>>            Function_Return False
37729>>>>>>>        End
37729>>>>>>>>
37729>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
37731>>>>>>>            Function_Return False
37732>>>>>>>        End                                                                
37732>>>>>>>>
37732>>>>>>>
37732>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
37734>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
37736>>>>>>>                Function_Return False
37737>>>>>>>            End
37737>>>>>>>>
37737>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
37739>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
37741>>>>>>>                    End
37741>>>>>>>>
37741>>>>>>>                Else Begin
37742>>>>>>>                    Function_Return False
37743>>>>>>>                End
37743>>>>>>>>
37743>>>>>>>            End
37743>>>>>>>>
37743>>>>>>>        End
37743>>>>>>>>
37743>>>>>>>
37743>>>>>>>        Get piDbType                       to iDbType
37744>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
37745>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
37746>>>>>>>
37746>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
37746>>>>>>>        // data types between Embedded and SQL.
37746>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
37748>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
37749>>>>>>>        End
37749>>>>>>>>
37749>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
37751>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
37752>>>>>>>        End
37752>>>>>>>>
37752>>>>>>>
37752>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
37753>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
37754>>>>>>>
37754>>>>>>>        // Make Date and DateTime comparison?
37754>>>>>>>        If (bCompareDate_DataTime = True) Begin
37756>>>>>>>            If (iFromType <> iToType) Begin
37758>>>>>>>                Function_Return False
37759>>>>>>>            End
37759>>>>>>>>
37759>>>>>>>        End
37759>>>>>>>>
37759>>>>>>>
37759>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
37759>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
37761>>>>>>>            If (iFromType <> iToType) Begin
37763>>>>>>>                Function_Return False
37764>>>>>>>            End
37764>>>>>>>>
37764>>>>>>>        End
37764>>>>>>>>
37764>>>>>>>
37764>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
37764>>>>>>>        If (bIsDateTypeFrom = False) Begin
37766>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
37768>>>>>>>                Function_Return False
37769>>>>>>>            End
37769>>>>>>>>
37769>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
37771>>>>>>>                Function_Return False
37772>>>>>>>            End
37772>>>>>>>>
37772>>>>>>>        End
37772>>>>>>>>
37772>>>>>>>
37772>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
37774>>>>>>>            Function_Return False
37775>>>>>>>        End
37775>>>>>>>>
37775>>>>>>>
37775>>>>>>>        Function_Return True
37776>>>>>>>    End_Function
37777>>>>>>>
37777>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
37779>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
37779>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
37779>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
37779>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
37781>>>>>>>        String sDriverID sRootName sLogicalName
37781>>>>>>>
37781>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
37782>>>>>>>        Get piDbType to iDbType
37783>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
37786>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
37789>>>>>>>
37789>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37792>>>>>>>        If (bIsOpen = False) Begin
37794>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37795>>>>>>>            Open hTable
37797>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37798>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
37801>>>>>>>            If (bIsOpen = False) Begin
37803>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
37804>>>>>>>                Move True to APIColumnsEmpty[0].bError
37805>>>>>>>                Function_Return APIColumnsEmpty
37806>>>>>>>            End
37806>>>>>>>>
37806>>>>>>>        End
37806>>>>>>>>
37806>>>>>>>
37806>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
37809>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
37810>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
37811>>>>>>>
37811>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
37812>>>>>>>        If (bIsSqlTable = True) Begin
37814>>>>>>>            Get _UtilTableExists hTable to bExists
37815>>>>>>>            If (bExists = False) Begin
37817>>>>>>>                Move True to APIColumnsEmpty[0].bError
37818>>>>>>>                Function_Return APIColumnsEmpty
37819>>>>>>>            End
37819>>>>>>>>
37819>>>>>>>        End
37819>>>>>>>>
37819>>>>>>>
37819>>>>>>>        Move 0 to iCount
37820>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
37823>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
37824>>>>>>>
37824>>>>>>>        for iColumn from 1 to iNumColumns
37830>>>>>>>>
37830>>>>>>>            Move 0 to iOptions
37831>>>>>>>            Move False to bIdentityKey
37832>>>>>>>            Move False to Err
37833>>>>>>>            Move 0     to LastErr
37834>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
37835>>>>>>>            Set piPosition of ghoProgressBar to iColumn
37836>>>>>>>            If (bDawSqlDriver = True) Begin
37838>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
37839>>>>>>>                If (bIsSqlTable = True) Begin
37841>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
37844>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
37845>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
37848>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
37851>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
37854>>>>>>>                End
37854>>>>>>>>
37854>>>>>>>                Else Begin
37855>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
37858>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
37859>>>>>>>                End
37859>>>>>>>>
37859>>>>>>>
37859>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
37859>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
37862>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
37863>>>>>>>                If (bExists = False) Begin
37865>>>>>>>                    Move 0 to APIColumns[iCount].iType
37866>>>>>>>                End
37866>>>>>>>>
37866>>>>>>>                If (bExists = True) Begin
37868>>>>>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
37871>>>>>>>                End
37871>>>>>>>>
37871>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
37872>>>>>>>                If (bIdentityKey = True) Begin
37874>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
37875>>>>>>>                End
37875>>>>>>>>
37875>>>>>>>            End
37875>>>>>>>>
37875>>>>>>>            Else Begin
37876>>>>>>>                Move False to Err
37877>>>>>>>                Move 0     to LastErr
37878>>>>>>>                If (bIsSqlTable = True) Begin
37880>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
37883>>>>>>>                End
37883>>>>>>>>
37883>>>>>>>                Else Begin
37884>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
37887>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
37888>>>>>>>                End
37888>>>>>>>>
37888>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
37888>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
37889>>>>>>>                If (bExists = False) Begin
37891>>>>>>>                    Move 0 to APIColumns[iCount].iType
37892>>>>>>>                End
37892>>>>>>>>
37892>>>>>>>            End
37892>>>>>>>>
37892>>>>>>>
37892>>>>>>>            If (bExists = True) Begin
37894>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
37895>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
37898>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
37898>>>>>>>//                If (bIsSqlTable = True) Begin
37898>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
37898>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
37898>>>>>>>//                End
37898>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
37901>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
37904>>>>>>>
37904>>>>>>>                // If the length was zero we might have an Overlap(!) field.
37904>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
37904>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
37906>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
37909>>>>>>>                    If (iType = DF_OVERLAP) Begin
37911>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
37912>>>>>>>                        Move 0 to APIColumns[iCount].iLength
37913>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
37914>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
37915>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
37916>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
37917>>>>>>>                        Decrement iCount
37918>>>>>>>                    End
37918>>>>>>>>
37918>>>>>>>                End
37918>>>>>>>>
37918>>>>>>>            End
37918>>>>>>>>
37918>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
37919>>>>>>>            If (bUserCancel = True) Begin
37921>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
37922>>>>>>>                Function_Return APIColumnsEmpty
37923>>>>>>>            End
37923>>>>>>>>
37923>>>>>>>            Increment iCount
37924>>>>>>>        Loop
37925>>>>>>>>
37925>>>>>>>
37925>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
37926>>>>>>>        Function_Return APIColumns
37927>>>>>>>    End_Function
37928>>>>>>>
37928>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
37928>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
37928>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
37928>>>>>>>    // have "holes" in the series of index numbers.
37928>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
37930>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
37930>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
37931>>>>>>>        tAPIColumnCompare   APIColumnCompare
37931>>>>>>>        tAPIColumnCompare   APIColumnCompare
37931>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
37931>>>>>>>
37931>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
37932>>>>>>>        Decrement iSizeFrom
37933>>>>>>>        for iCount from 0 to iSizeFrom
37939>>>>>>>>
37939>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
37940>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
37941>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
37942>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
37943>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
37944>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
37945>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
37946>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
37947>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
37948>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
37949>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
37950>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
37951>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
37952>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
37953>>>>>>>        Loop
37954>>>>>>>>
37954>>>>>>>
37954>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
37955>>>>>>>        Decrement iSizeTo
37956>>>>>>>        for iCount from 0 to iSizeTo
37962>>>>>>>>
37962>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
37963>>>>>>>            // Search if the field number already exists in the array; else add it.
37963>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
37964>>>>>>>            If (iItem = -1) Begin
37966>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
37967>>>>>>>            End
37967>>>>>>>>
37967>>>>>>>
37967>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
37968>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
37969>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
37970>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
37971>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
37972>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
37973>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
37974>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
37975>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
37976>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
37977>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
37978>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
37979>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
37980>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
37981>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
37982>>>>>>>        Loop
37983>>>>>>>>
37983>>>>>>>
37983>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
37984>>>>>>>
37984>>>>>>>        Function_Return aAPIColumnCompare
37985>>>>>>>    End_Function
37986>>>>>>>
37986>>>>>>>    // Checks if a field name exists in a table definition
37986>>>>>>>    // Returns True if it does
37986>>>>>>>    // Sample:
37986>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
37986>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
37988>>>>>>>        Integer iNumColumns iColumn
37988>>>>>>>        String sColumn
37988>>>>>>>        Boolean bExists bOK bOpen
37988>>>>>>>
37988>>>>>>>        Get AutoConnectionIDLogin to bOK
37989>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37990>>>>>>>        Open hTable
37992>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
37993>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
37996>>>>>>>        If (bOpen = False) Begin
37998>>>>>>>            Function_Return False
37999>>>>>>>        End
37999>>>>>>>>
37999>>>>>>>
37999>>>>>>>        Move False to bExists
38000>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
38003>>>>>>>        for iColumn from 1 to iNumColumns
38009>>>>>>>>
38009>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
38012>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
38014>>>>>>>                Move iNumColumns to iColumn
38015>>>>>>>                Move True to bExists
38016>>>>>>>            End
38016>>>>>>>>
38016>>>>>>>        Loop
38017>>>>>>>>
38017>>>>>>>        Close hTable
38018>>>>>>>
38018>>>>>>>        Function_Return bExists
38019>>>>>>>    End_Function
38020>>>>>>>
38020>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
38020>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
38022>>>>>>>        Integer iNumColumns iColumn iRetval
38022>>>>>>>        String sColumn
38022>>>>>>>        Boolean bOK bOpen
38022>>>>>>>
38022>>>>>>>        Get AutoConnectionIDLogin to bOK
38023>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
38024>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
38025>>>>>>>        Open hTable
38027>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
38028>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
38031>>>>>>>        If (bOpen = False) Begin
38033>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
38034>>>>>>>            Function_Return False
38035>>>>>>>        End
38035>>>>>>>>
38035>>>>>>>
38035>>>>>>>        Move 0 to iColumn
38036>>>>>>>        Move 0 to iRetval
38037>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
38040>>>>>>>        for iColumn from 1 to iNumColumns
38046>>>>>>>>
38046>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
38049>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
38051>>>>>>>                Move iColumn to iRetval
38052>>>>>>>                Move iNumColumns to iColumn
38053>>>>>>>            End
38053>>>>>>>>
38053>>>>>>>        Loop
38054>>>>>>>>
38054>>>>>>>        Close hTable
38055>>>>>>>
38055>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
38056>>>>>>>        Function_Return iRetval
38057>>>>>>>    End_Function
38058>>>>>>>
38058>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
38058>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
38058>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
38060>>>>>>>        tColumnType RetvalType
38060>>>>>>>        tColumnType RetvalType
38060>>>>>>>
38060>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
38061>>>>>>>        Function_Return RetvalType.iSQLType
38062>>>>>>>    End_Function
38063>>>>>>>
38063>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
38063>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
38063>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
38065>>>>>>>        tColumnType RetvalType
38065>>>>>>>        tColumnType RetvalType
38065>>>>>>>
38065>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38066>>>>>>>        Function_Return RetvalType.sSQLType
38067>>>>>>>    End_Function
38068>>>>>>>
38068>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
38070>>>>>>>        tColumnType RetvalType
38070>>>>>>>        tColumnType RetvalType
38070>>>>>>>
38070>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38071>>>>>>>        Function_Return RetvalType.sPrecision
38072>>>>>>>    End_Function
38073>>>>>>>
38073>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
38075>>>>>>>        tColumnType RetvalType
38075>>>>>>>        tColumnType RetvalType
38075>>>>>>>
38075>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38076>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
38076>>>>>>>        // if the column type length is _not_ fixed.
38076>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
38077>>>>>>>    End_Function
38078>>>>>>>
38078>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
38080>>>>>>>        tColumnType RetvalType
38080>>>>>>>        tColumnType RetvalType
38080>>>>>>>        String sValue
38080>>>>>>>        Integer iRetval iPos
38080>>>>>>>
38080>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38081>>>>>>>        Move RetvalType.sPrecision to sValue
38082>>>>>>>        Move (Pos(".", sValue)) to iPos
38083>>>>>>>        If (iPos <> 0) Begin
38085>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
38086>>>>>>>        End
38086>>>>>>>>
38086>>>>>>>        Else Begin
38087>>>>>>>            Move sValue to iRetval
38088>>>>>>>        End
38088>>>>>>>>
38088>>>>>>>        Function_Return iRetval
38089>>>>>>>    End_Function
38090>>>>>>>
38090>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
38092>>>>>>>        tColumnType RetvalType
38092>>>>>>>        tColumnType RetvalType
38092>>>>>>>        String sValue
38092>>>>>>>        Integer iRetval iPos
38092>>>>>>>
38092>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38093>>>>>>>        Move RetvalType.sPrecision to sValue
38094>>>>>>>        Move (Pos(".", sValue)) to iPos
38095>>>>>>>        If (iPos = 0) Begin
38097>>>>>>>            Function_Return 0
38098>>>>>>>        End
38098>>>>>>>>
38098>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
38099>>>>>>>
38099>>>>>>>        Function_Return iRetval
38100>>>>>>>    End_Function
38101>>>>>>>
38101>>>>>>>    // * Dummy function for the Studio's Code Explorer *
38101>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
38103>>>>>>>        Function_Return False
38104>>>>>>>    End_Function
38105>>>>>>>
38105>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
38105>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
38107>>>>>>>        Boolean bIsSame
38107>>>>>>>        Integer iCount iSize
38107>>>>>>>
38107>>>>>>>        Move True to bIsSame
38108>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
38109>>>>>>>        Decrement iSize
38110>>>>>>>        For iCount from 0 to iSize
38116>>>>>>>>
38116>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
38117>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
38118>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
38119>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
38120>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
38121>>>>>>>            If (bIsSame = False) Begin
38123>>>>>>>                Function_Return False
38124>>>>>>>            End
38124>>>>>>>>
38124>>>>>>>        Loop
38125>>>>>>>>
38125>>>>>>>
38125>>>>>>>        Function_Return bIsSame
38126>>>>>>>    End_Function
38127>>>>>>>
38127>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
38127>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
38129>>>>>>>        Boolean bIsSame
38129>>>>>>>        Integer iSegment
38129>>>>>>>
38129>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
38130>>>>>>>        If (bIsSame = False) Begin
38132>>>>>>>            Function_Return False
38133>>>>>>>        End
38133>>>>>>>>
38133>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
38134>>>>>>>        If (bIsSame = False) Begin
38136>>>>>>>            Function_Return False
38137>>>>>>>        End
38137>>>>>>>>
38137>>>>>>>
38137>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
38139>>>>>>>            // * We should probably not compare SQL index names?
38139>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
38139>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
38139>>>>>>>            //     Function_Return False
38139>>>>>>>            // End
38139>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
38140>>>>>>>            If (bIsSame = False) Begin
38142>>>>>>>                Function_Return False
38143>>>>>>>            End
38143>>>>>>>>
38143>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
38144>>>>>>>            If (bIsSame = False) Begin
38146>>>>>>>                Function_Return False
38147>>>>>>>            End
38147>>>>>>>>
38147>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
38148>>>>>>>            If (bIsSame = False) Begin
38150>>>>>>>                Function_Return False
38151>>>>>>>            End
38151>>>>>>>>
38151>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
38152>>>>>>>            If (bIsSame = False) Begin
38154>>>>>>>                Function_Return False
38155>>>>>>>            End
38155>>>>>>>>
38155>>>>>>>        End
38155>>>>>>>>
38155>>>>>>>
38155>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
38156>>>>>>>        Move (iSegment = -1) to bIsSame
38157>>>>>>>
38157>>>>>>>        Function_Return (bIsSame = True)
38158>>>>>>>    End_Function
38159>>>>>>>
38159>>>>>>>    // Compares each segment for the passed index.
38159>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
38159>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
38161>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
38161>>>>>>>        Boolean bIsSame
38161>>>>>>>
38161>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
38162>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
38163>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
38164>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
38165>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
38166>>>>>>>
38166>>>>>>>        Decrement iNumSegments
38167>>>>>>>        for iSegment from 0 to iNumSegments
38173>>>>>>>>
38173>>>>>>>            Move False to bIsSame
38174>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
38176>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
38177>>>>>>>            End
38177>>>>>>>>
38177>>>>>>>            If (bIsSame = False) Begin
38179>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
38180>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
38181>>>>>>>                Function_Return iSegment
38182>>>>>>>            End
38182>>>>>>>>
38182>>>>>>>        Loop
38183>>>>>>>>
38183>>>>>>>
38183>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
38184>>>>>>>        Function_Return -1 // This means bIsSame = True
38185>>>>>>>    End_Function
38186>>>>>>>
38186>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
38188>>>>>>>        Boolean bIsSame
38188>>>>>>>
38188>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
38189>>>>>>>        If (bIsSame = False) Begin
38191>>>>>>>            Function_Return False
38192>>>>>>>        End
38192>>>>>>>>
38192>>>>>>>        If (bCompareIndexUppercase = True) Begin
38194>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
38195>>>>>>>            If (bIsSame = False) Begin
38197>>>>>>>                Function_Return False
38198>>>>>>>            End
38198>>>>>>>>
38198>>>>>>>        End
38198>>>>>>>>
38198>>>>>>>        If (bCompareIndexAscending = True) Begin
38200>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
38201>>>>>>>            If (bIsSame = False) Begin
38203>>>>>>>                Function_Return False
38204>>>>>>>            End
38204>>>>>>>>
38204>>>>>>>        End
38204>>>>>>>>
38204>>>>>>>
38204>>>>>>>        Function_Return True
38205>>>>>>>    End_Function
38206>>>>>>>
38206>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
38208>>>>>>>        Boolean bIsSame bOK
38208>>>>>>>        Integer iSize iSizeTo iCount
38208>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
38208>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
38209>>>>>>>
38209>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
38210>>>>>>>        If (iSize = 0) Begin
38212>>>>>>>            Function_Return True
38213>>>>>>>        End
38213>>>>>>>>
38213>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
38214>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
38215>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
38216>>>>>>>
38216>>>>>>>        for iCount from 0 to (iSize - 1)
38222>>>>>>>>
38222>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
38223>>>>>>>            If (bIsSame = False) Begin
38225>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
38226>>>>>>>            End
38226>>>>>>>>
38226>>>>>>>        Loop
38227>>>>>>>>
38227>>>>>>>
38227>>>>>>>        // We probably should delete other indexes if they exists.
38227>>>>>>>        for iCount from (iSize +1) to iSizeTo
38233>>>>>>>>
38233>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
38234>>>>>>>        Loop
38235>>>>>>>>
38235>>>>>>>
38235>>>>>>>        Function_Return bOK
38236>>>>>>>    End_Function
38237>>>>>>>
38237>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
38239>>>>>>>        tAPIIndex[] APIIndexes
38239>>>>>>>        tAPIIndex[] APIIndexes
38240>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
38240>>>>>>>        String sDriverID
38240>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
38240>>>>>>>
38240>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
38241>>>>>>>        Get psDriverID to sDriverID
38242>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
38243>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
38244>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
38247>>>>>>>        If (bIsOpen = False) Begin
38249>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
38250>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
38251>>>>>>>            Open hTable
38253>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
38254>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
38255>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
38258>>>>>>>            If (bIsOpen = False) Begin
38260>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
38261>>>>>>>                Move True to APIIndexes[0].bError
38262>>>>>>>                Function_Return APIIndexes
38263>>>>>>>            End
38263>>>>>>>>
38263>>>>>>>        End
38263>>>>>>>>
38263>>>>>>>
38263>>>>>>>        Move 0 to iCount
38264>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
38267>>>>>>>        for iIndex from 1 to iIndexes
38273>>>>>>>>
38273>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
38273>>>>>>>            // numbers doesn't not need to be consequitive:
38273>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
38276>>>>>>>            If (iNumSegments > 0) Begin
38278>>>>>>>
38278>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
38279>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
38282>>>>>>>                If (bIsSQLTable = True) Begin
38284>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
38287>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
38290>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
38293>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
38296>>>>>>>                End
38296>>>>>>>>
38296>>>>>>>
38296>>>>>>>                Move 0 to iSegmentCount
38297>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
38300>>>>>>>                For iSegment from 1 to iNumSegments
38306>>>>>>>>
38306>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
38309>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
38310>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
38313>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
38316>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
38319>>>>>>>                    Increment iSegmentCount
38320>>>>>>>                Loop
38321>>>>>>>>
38321>>>>>>>                Increment iCount
38322>>>>>>>            End
38322>>>>>>>>
38322>>>>>>>        Loop
38323>>>>>>>>
38323>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
38324>>>>>>>
38324>>>>>>>        Function_Return APIIndexes
38325>>>>>>>    End_Function
38326>>>>>>>
38326>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
38326>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
38326>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
38326>>>>>>>    // have "holes" in the series of index numbers.
38326>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
38328>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
38328>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
38329>>>>>>>        tAPIIndexCompare   APIIndexCompare
38329>>>>>>>        tAPIIndexCompare   APIIndexCompare
38329>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
38329>>>>>>>
38329>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
38330>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
38331>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
38333>>>>>>>            Function_Return aAPIIndexCompare
38334>>>>>>>        End
38334>>>>>>>>
38334>>>>>>>
38334>>>>>>>        Decrement iSizeFrom
38335>>>>>>>        for iCount from 0 to iSizeFrom
38341>>>>>>>>
38341>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
38342>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
38343>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
38344>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
38345>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
38346>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
38347>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
38348>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
38349>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
38350>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
38351>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
38352>>>>>>>        Loop
38353>>>>>>>>
38353>>>>>>>
38353>>>>>>>        Decrement iSizeTo
38354>>>>>>>        for iCount from 0 to iSizeTo
38360>>>>>>>>
38360>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
38361>>>>>>>            // Search if the Index number already exists in the array; else add it.
38361>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
38362>>>>>>>            If (iItem = -1) Begin
38364>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
38365>>>>>>>            End
38365>>>>>>>>
38365>>>>>>>
38365>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
38366>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
38367>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
38368>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
38369>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
38370>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
38371>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
38372>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
38373>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
38374>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
38375>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
38376>>>>>>>        Loop
38377>>>>>>>>
38377>>>>>>>
38377>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
38378>>>>>>>
38378>>>>>>>        Function_Return aAPIIndexCompare
38379>>>>>>>    End_Function
38380>>>>>>>
38380>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
38380>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
38382>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
38382>>>>>>>        String sDriverID
38382>>>>>>>
38382>>>>>>>        Get psDriverID to sDriverID
38383>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
38384>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
38385>>>>>>>        If (bIsSqlTable = True) Begin
38387>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
38388>>>>>>>        End
38388>>>>>>>>
38388>>>>>>>
38388>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
38389>>>>>>>        If (bIsSame = False) Begin
38391>>>>>>>            Function_Return False
38392>>>>>>>        End
38392>>>>>>>>
38392>>>>>>>
38392>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
38394>>>>>>>            // Don't think we should do this. Or should we?
38394>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
38394>>>>>>>
38394>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
38395>>>>>>>            If (bIsSame = False) Begin
38397>>>>>>>                Function_Return False
38398>>>>>>>            End
38398>>>>>>>>
38398>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
38399>>>>>>>            If (bIsSame = False) Begin
38401>>>>>>>                Function_Return False
38402>>>>>>>            End
38402>>>>>>>>
38402>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
38403>>>>>>>            If (bIsSame = False) Begin
38405>>>>>>>                Function_Return False
38406>>>>>>>            End
38406>>>>>>>>
38406>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
38407>>>>>>>            If (bIsSame = False) Begin
38409>>>>>>>                Function_Return False
38410>>>>>>>            End
38410>>>>>>>>
38410>>>>>>>        End
38410>>>>>>>>
38410>>>>>>>
38410>>>>>>>        Function_Return bIsSame
38411>>>>>>>    End_Function
38412>>>>>>>
38412>>>>>>>    // DF_INDEX_SQL_TYPE values
38412>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
38412>>>>>>>    // returns a string with the name.
38412>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
38414>>>>>>>        String sRetval
38414>>>>>>>            Case Begin
38414>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
38416>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
38417>>>>>>>                    Case Break
38418>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
38421>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
38422>>>>>>>                    Case Break
38423>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
38426>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
38427>>>>>>>                    Case Break
38428>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
38431>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
38432>>>>>>>                    Case Break
38433>>>>>>>                Case Else
38433>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
38434>>>>>>>            Case End
38434>>>>>>>        Function_Return sRetval
38435>>>>>>>    End_Function
38436>>>>>>>
38436>>>>>>>    // * Dummy function for the Studio's Code Explorer *
38436>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
38438>>>>>>>        Function_Return False
38439>>>>>>>    End_Function
38440>>>>>>>
38440>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
38440>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
38442>>>>>>>        Boolean bIsSame
38442>>>>>>>        Integer iSize iCount
38442>>>>>>>
38442>>>>>>>        Move True to bIsSame
38443>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
38444>>>>>>>        Decrement iSize
38445>>>>>>>        For iCount from 0 to iSize
38451>>>>>>>>
38451>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
38452>>>>>>>            If (bIsSame = False) Begin
38454>>>>>>>                Function_Return False
38455>>>>>>>            End
38455>>>>>>>>
38455>>>>>>>        Loop
38456>>>>>>>>
38456>>>>>>>
38456>>>>>>>        Function_Return bIsSame
38457>>>>>>>    End_Function
38458>>>>>>>
38458>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
38458>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
38460>>>>>>>        Boolean bIsSame
38460>>>>>>>
38460>>>>>>>        Move True to bIsSame
38461>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
38463>>>>>>>            Function_Return False
38464>>>>>>>        End
38464>>>>>>>>
38464>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
38466>>>>>>>            Function_Return False
38467>>>>>>>        End
38467>>>>>>>>
38467>>>>>>>
38467>>>>>>>        // We could also compare field names, but I don't think that is necessary...
38467>>>>>>>
38467>>>>>>>        Function_Return bIsSame
38468>>>>>>>    End_Function
38469>>>>>>>
38469>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
38469>>>>>>>    // already exists.
38469>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
38471>>>>>>>        Boolean bOK
38471>>>>>>>        Integer iSizeTo iSize iCount iColumn
38471>>>>>>>        String sDriverID
38471>>>>>>>
38471>>>>>>>        Move True to bOK
38472>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
38473>>>>>>>        If (iSizeTo > 0) Begin
38475>>>>>>>            Get AutoConnectionIDLogin to bOK
38476>>>>>>>            Move False to Err
38477>>>>>>>            Open hTable Mode DF_EXCLUSIVE
38479>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
38482>>>>>>>            Decrement iSizeTo
38483>>>>>>>
38483>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
38483>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
38483>>>>>>>            Structure_Start hTable sDriverID
38484>>>>>>>                for iCount from 0 to iSizeTo
38490>>>>>>>>
38490>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
38491>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
38494>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
38497>>>>>>>                Loop
38498>>>>>>>>
38498>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
38499>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
38501>>>>>>>            Set Action_Text of ghoStatusPanel to ""
38502>>>>>>>        End
38502>>>>>>>>
38502>>>>>>>
38502>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
38503>>>>>>>        Decrement iSize
38504>>>>>>>        for iCount from 0 to iSize
38510>>>>>>>>
38510>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
38511>>>>>>>        Loop
38512>>>>>>>>
38512>>>>>>>
38512>>>>>>>        Function_Return bOK
38513>>>>>>>    End_Function
38514>>>>>>>
38514>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
38516>>>>>>>        tAPIRelation[] APIRelations
38516>>>>>>>        tAPIRelation[] APIRelations
38517>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
38517>>>>>>>        Handle hParent
38517>>>>>>>        Boolean bIsOpen
38517>>>>>>>
38517>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
38518>>>>>>>        Move 0 to iCount
38519>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
38522>>>>>>>        If (bIsOpen = False) Begin
38524>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
38525>>>>>>>            Open hTable
38527>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
38528>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
38531>>>>>>>            If (bIsOpen = False) Begin
38533>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
38534>>>>>>>                Move True to APIRelations[0].bError
38535>>>>>>>                Function_Return APIRelations
38536>>>>>>>            End
38536>>>>>>>>
38536>>>>>>>        End
38536>>>>>>>>
38536>>>>>>>
38536>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
38539>>>>>>>        For iColumn from 1 to iNumColumns
38545>>>>>>>>
38545>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
38548>>>>>>>            If (hParent <> 0) Begin
38550>>>>>>>                Open hParent
38552>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
38553>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
38556>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
38557>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
38560>>>>>>>
38560>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
38561>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
38564>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
38567>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
38568>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
38571>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
38572>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
38573>>>>>>>                Move False                                              to APIRelations[iCount].bError
38574>>>>>>>                Close hParent
38575>>>>>>>                Increment iCount
38576>>>>>>>            End
38576>>>>>>>>
38576>>>>>>>        Loop
38577>>>>>>>>
38577>>>>>>>
38577>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
38578>>>>>>>        Function_Return APIRelations
38579>>>>>>>    End_Function
38580>>>>>>>
38580>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
38580>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
38580>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
38582>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
38582>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
38583>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
38583>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
38584>>>>>>>        tAPIRelationCompare   APIRelationCompare
38584>>>>>>>        tAPIRelationCompare   APIRelationCompare
38584>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
38584>>>>>>>
38584>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
38585>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
38586>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
38588>>>>>>>            Function_Return aAPIRelationCompare
38589>>>>>>>        End
38589>>>>>>>>
38589>>>>>>>
38589>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
38590>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
38591>>>>>>>
38591>>>>>>>        Decrement iSizeFrom
38592>>>>>>>        for iCount from 0 to iSizeFrom
38598>>>>>>>>
38598>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
38599>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
38600>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
38601>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
38602>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
38603>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
38604>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
38605>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
38606>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
38607>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
38608>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
38609>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
38610>>>>>>>        Loop
38611>>>>>>>>
38611>>>>>>>
38611>>>>>>>        Decrement iSizeTo
38612>>>>>>>        for iCount from 0 to iSizeTo
38618>>>>>>>>
38618>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
38619>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
38620>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
38621>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
38622>>>>>>>
38622>>>>>>>            // Search if the relation already exists in the array; else add it.
38622>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
38623>>>>>>>            If (iItem = -1) Begin
38625>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
38626>>>>>>>            End
38626>>>>>>>>
38626>>>>>>>
38626>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
38627>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
38628>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
38629>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
38630>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
38631>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
38632>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
38633>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
38634>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
38635>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
38636>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
38637>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
38638>>>>>>>        Loop
38639>>>>>>>>
38639>>>>>>>
38639>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
38640>>>>>>>
38640>>>>>>>        Function_Return aAPIRelationCompare
38641>>>>>>>    End_Function
38642>>>>>>>
38642>>>>>>>    // * Dummy function for the Studio's Code Explorer *
38642>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
38644>>>>>>>        Function_Return False
38645>>>>>>>    End_Function
38646>>>>>>>
38646>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
38646>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
38646>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
38646>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
38648>>>>>>>        Boolean bFound
38648>>>>>>>
38648>>>>>>>        Move False to Err
38649>>>>>>>        Open CodeMast
38651>>>>>>>        Open CodeType
38653>>>>>>>
38653>>>>>>>        If (bCodeType = True) Begin
38655>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
38656>>>>>>>            Clear CodeType
38657>>>>>>>            Move sTypeValue to CODETYPE.Type
38658>>>>>>>            Find eq CODETYPE by 1
38659>>>>>>>>
38659>>>>>>>            Move Found to bFound
38660>>>>>>>            If (bFound = True) Begin
38662>>>>>>>                Reread CodeType
38666>>>>>>>            End
38666>>>>>>>>
38666>>>>>>>            Else Begin
38667>>>>>>>                Clear CodeType
38668>>>>>>>            End
38668>>>>>>>>
38668>>>>>>>
38668>>>>>>>            Move sTypeValue to CODETYPE.Type
38669>>>>>>>            Move sValue2    to CODETYPE.Description
38670>>>>>>>            Move sValue3    to CODETYPE.Comment
38671>>>>>>>            SaveRecord CODETYPE
38672>>>>>>>
38672>>>>>>>            If (bFound = True) Begin
38674>>>>>>>                Unlock
38675>>>>>>>>
38675>>>>>>>            End
38675>>>>>>>>
38675>>>>>>>        End
38675>>>>>>>>
38675>>>>>>>
38675>>>>>>>        If (bCodeType = False) Begin
38677>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
38678>>>>>>>            Clear CODEMAST
38679>>>>>>>            Move sTypeValue to CODEMAST.Type
38680>>>>>>>            Move sValue2    to CODEMAST.Code
38681>>>>>>>            Find eq CODEMAST by 1
38682>>>>>>>>
38682>>>>>>>            Move Found to bFound
38683>>>>>>>            If (bFound = True) Begin
38685>>>>>>>                Reread CODEMAST
38689>>>>>>>            End
38689>>>>>>>>
38689>>>>>>>            Else Begin
38690>>>>>>>                Clear CODEMAST
38691>>>>>>>            End
38691>>>>>>>>
38691>>>>>>>
38691>>>>>>>            Move sTypeValue to CODEMAST.Type
38692>>>>>>>            Move sValue2    to CODEMAST.Code
38693>>>>>>>            Move sValue3    to CODEMAST.Description
38694>>>>>>>            SaveRecord CODEMAST
38695>>>>>>>
38695>>>>>>>            If (bFound = True) Begin
38697>>>>>>>                Unlock
38698>>>>>>>>
38698>>>>>>>            End
38698>>>>>>>>
38698>>>>>>>        End
38698>>>>>>>>
38698>>>>>>>
38698>>>>>>>        Close CodeMast
38699>>>>>>>        Close CodeType
38700>>>>>>>
38700>>>>>>>        Function_Return (Err = False)
38701>>>>>>>    End_Function
38702>>>>>>>
38702>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
38702>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
38702>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
38704>>>>>>>        Boolean bFound
38704>>>>>>>
38704>>>>>>>        Move False to Err
38705>>>>>>>        Open CodeMast
38707>>>>>>>        Open CodeType
38709>>>>>>>
38709>>>>>>>        Clear CodeType
38710>>>>>>>        Move sFromValue to CODETYPE.Type
38711>>>>>>>        Find eq CODETYPE.Type
38712>>>>>>>>
38712>>>>>>>        If (Found = True) Begin
38714>>>>>>>            Reread CODETYPE
38718>>>>>>>                Move sToValue to CODETYPE.Type
38719>>>>>>>                SaveRecord CODETYPE
38720>>>>>>>            Unlock
38721>>>>>>>>
38721>>>>>>>        End
38721>>>>>>>>
38721>>>>>>>
38721>>>>>>>        Clear CODEMAST
38722>>>>>>>        Find gt CODEMAST by Recnum
38723>>>>>>>>
38723>>>>>>>        While (Found = True)
38727>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
38728>>>>>>>            If (bFound = True) Begin
38730>>>>>>>                Reread CODEMAST
38734>>>>>>>                    Move sToValue to CODEMAST.Type
38735>>>>>>>                    SaveRecord CODEMAST
38736>>>>>>>                Unlock
38737>>>>>>>>
38737>>>>>>>            End
38737>>>>>>>>
38737>>>>>>>            Find gt CODEMAST by Recnum
38738>>>>>>>>
38738>>>>>>>        Loop
38739>>>>>>>>
38739>>>>>>>
38739>>>>>>>        Close CodeMast
38740>>>>>>>        Close CodeType
38741>>>>>>>
38741>>>>>>>        Function_Return (Err = False)
38742>>>>>>>    End_Function
38743>>>>>>>
38743>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
38743>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
38745>>>>>>>        Boolean bFound
38745>>>>>>>
38745>>>>>>>        Move False to Err
38746>>>>>>>        Open CodeMast
38748>>>>>>>
38748>>>>>>>        Clear CODEMAST
38749>>>>>>>        Move sTypeValue to CODEMAST.Type
38750>>>>>>>        Move sValue2    to CODEMAST.Code
38751>>>>>>>        Find eq CODEMAST.Code
38752>>>>>>>>
38752>>>>>>>        Move Found to bFound
38753>>>>>>>        If (bFound = True) Begin
38755>>>>>>>            Delete CODEMAST
38756>>>>>>>        End
38756>>>>>>>>
38756>>>>>>>
38756>>>>>>>        Close CodeMast
38757>>>>>>>
38757>>>>>>>        Function_Return (Err = False)
38758>>>>>>>    End_Function
38759>>>>>>>
38759>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
38761>>>>>>>        Boolean bRecnum bToAnsi
38761>>>>>>>        Integer iCh
38761>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
38761>>>>>>>
38761>>>>>>>        If (Trim(sDataPath) = "") Begin
38763>>>>>>>            Function_Return False
38764>>>>>>>        End
38764>>>>>>>>
38764>>>>>>>
38764>>>>>>>        Move False to Err
38765>>>>>>>        Get psDriverID     to sDriverID
38766>>>>>>>        Get psConnectionID to sConnectionID
38767>>>>>>>        Get psSchema       to sSchemaName
38768>>>>>>>        Get True           to bRecnum
38769>>>>>>>        Get pbToANSI       to bToAnsi
38770>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
38771>>>>>>>        If (bToAnsi = False) Begin
38773>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
38774>>>>>>>        End
38774>>>>>>>>
38774>>>>>>>
38774>>>>>>>        Get vFolderFormat sDataPath to sDataPath
38775>>>>>>>        Move "CodeMast.int"         to sFileName
38776>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
38777>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
38780>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
38783>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
38786>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
38789>>>>>>>            Writeln channel iCh ("")
38792>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
38795>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
38798>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
38801>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
38804>>>>>>>            Writeln channel iCh ("")
38807>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
38810>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
38813>>>>>>>            Writeln channel iCh ("")
38816>>>>>>>        Send Seq_Close_Channel iCh
38817>>>>>>>
38817>>>>>>>        Get vFolderFormat sDataPath to sDataPath
38818>>>>>>>        Move "CodeType.int"         to sFileName
38819>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
38820>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
38823>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
38826>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
38829>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
38832>>>>>>>            Writeln channel iCh ("")
38835>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
38838>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
38841>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
38844>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
38847>>>>>>>            Writeln channel iCh ("")
38850>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
38853>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
38856>>>>>>>            Writeln channel iCh ("")
38859>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
38862>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
38865>>>>>>>            Writeln channel iCh ("")
38868>>>>>>>        Send Seq_Close_Channel iCh
38869>>>>>>>
38869>>>>>>>        Function_Return (Err = False)
38870>>>>>>>    End_Function
38871>>>>>>>
38871>>>>>>>    // * Dummy function for the Studio's Code Explorer *
38871>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
38873>>>>>>>        Function_Return False
38874>>>>>>>    End_Function
38875>>>>>>>
38875>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
38875>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
38875>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
38877>>>>>>>        Boolean bOK bExists
38877>>>>>>>        String sDataPath sBackupFolder
38877>>>>>>>
38877>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
38878>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
38879>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
38880>>>>>>>        Get vFolderFormat sDataPath to sDataPath
38881>>>>>>>
38881>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
38882>>>>>>>        If (bExists = False) Begin
38884>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
38885>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
38886>>>>>>>            If (bExists = False) Begin
38888>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
38889>>>>>>>>
38889>>>>>>>                Function_Return False
38890>>>>>>>            End
38890>>>>>>>>
38890>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
38891>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
38892>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
38893>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
38894>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
38895>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
38896>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
38897>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
38898>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
38899>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
38900>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
38901>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
38902>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
38903>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
38904>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
38905>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
38906>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
38907>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
38908>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
38909>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
38910>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
38911>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
38912>>>>>>>        End
38912>>>>>>>>
38912>>>>>>>
38912>>>>>>>        Set Message_Text of ghoStatusPanel to ""
38913>>>>>>>        Function_Return True
38914>>>>>>>    End_Function
38915>>>>>>>    
38915>>>>>>>    // Check if the file exists in the Data folder,
38915>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
38915>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
38917>>>>>>>        String sPath
38917>>>>>>>        Boolean bExists
38917>>>>>>>
38917>>>>>>>        Get psDataPathFirstPart to sPath
38918>>>>>>>        Move (sPath + sFileName) to sFileName
38919>>>>>>>        Get vFilePathExists sFileName to bExists
38920>>>>>>>
38920>>>>>>>        If (bExists = False) Begin
38922>>>>>>>            // Read from memory & create file on disk.
38922>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
38923>>>>>>>            Get vFilePathExists sFileName to bExists
38924>>>>>>>        End
38924>>>>>>>>
38924>>>>>>>        Function_Return bExists
38925>>>>>>>    End_Function
38926>>>>>>>
38926>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
38928>>>>>>>        tColumnType RetvalType
38928>>>>>>>        tColumnType RetvalType
38928>>>>>>>        Integer iRetval
38928>>>>>>>
38928>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38929>>>>>>>        Move RetvalType.iDataFlexType to iRetval
38930>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
38932>>>>>>>            If (iLength <= 255) Begin
38934>>>>>>>                Move DF_ASCII to iRetval
38935>>>>>>>            End
38935>>>>>>>>
38935>>>>>>>        End
38935>>>>>>>>
38935>>>>>>>        Function_Return iRetval
38936>>>>>>>    End_Function
38937>>>>>>>
38937>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
38939>>>>>>>        String sRetval
38939>>>>>>>
38939>>>>>>>        Case Begin
38939>>>>>>>            Case (iDataType = DF_ASCII)
38941>>>>>>>                Move "DF_ASCII" to sRetval
38942>>>>>>>                Case Break
38943>>>>>>>            Case (iDataType = DF_BCD)
38946>>>>>>>                Move "DF_BCD" to sRetval
38947>>>>>>>                Case Break
38948>>>>>>>            Case (iDataType = DF_BINARY)
38951>>>>>>>                Move "DF_BINARY" to sRetval
38952>>>>>>>                Case Break
38953>>>>>>>            Case (iDataType = DF_DATE)
38956>>>>>>>                Move "DF_DATE" to sRetval
38957>>>>>>>                Case Break
38958>>>>>>>            Case (iDataType = DF_DATETIME)
38961>>>>>>>                Move "DF_DATETIME" to sRetval
38962>>>>>>>                Case Break
38963>>>>>>>            Case (iDataType = DF_TEXT)
38966>>>>>>>                Move "DF_TEXT" to sRetval
38967>>>>>>>                Case Break
38968>>>>>>>            Case Else
38968>>>>>>>                Move "" to sRetval
38969>>>>>>>        Case End
38969>>>>>>>
38969>>>>>>>        Function_Return sRetval
38970>>>>>>>    End_Function
38971>>>>>>>
38971>>>>>>>    // The default value used for a datatype as specified in the driver int file.
38971>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
38973>>>>>>>        String sRetval sServer
38973>>>>>>>        tColumnType RetvalType
38973>>>>>>>        tColumnType RetvalType
38973>>>>>>>        Integer iDriver iDataFlexType
38973>>>>>>>        Handle hDatabase
38973>>>>>>>
38973>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
38974>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
38975>>>>>>>        Get DriverIndex sDriverID to iDriver
38976>>>>>>>        Get psServer to sServer
38977>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
38978>>>>>>>        If (hDatabase = 0) Begin
38980>>>>>>>            Function_Return ""
38981>>>>>>>        End
38981>>>>>>>>
38981>>>>>>>
38981>>>>>>>        Case Begin
38981>>>>>>>            Case (iDataFlexType = DF_ASCII)
38983>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
38986>>>>>>>                Case Break
38987>>>>>>>            Case (iDataFlexType = DF_BCD)
38990>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
38993>>>>>>>                Case Break
38994>>>>>>>            Case (iDataFlexType = DF_BINARY)
38997>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
39000>>>>>>>                Case Break
39001>>>>>>>            Case (iDataFlexType = DF_DATE)
39004>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
39007>>>>>>>                Case Break
39008>>>>>>>            Case (iDataFlexType = DF_DATETIME)
39011>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
39014>>>>>>>                Case Break
39015>>>>>>>            Case (iDataFlexType = DF_TEXT)
39018>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
39021>>>>>>>                Case Break
39022>>>>>>>            Case Else
39022>>>>>>>                Move "" to sRetval
39023>>>>>>>        Case End
39023>>>>>>>
39023>>>>>>>        Function_Return sRetval
39024>>>>>>>    End_Function
39025>>>>>>>
39025>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
39027>>>>>>>        String sDriverID sServer
39027>>>>>>>        tColumnType RetvalType
39027>>>>>>>        tColumnType RetvalType
39027>>>>>>>        Integer iDbType iDriver
39027>>>>>>>        Handle hDatabase
39027>>>>>>>
39027>>>>>>>        Get psDriverID to sDriverID
39028>>>>>>>        Get piDbType   to iDbType
39029>>>>>>>        Get DriverIndex sDriverID to iDriver
39030>>>>>>>        Get psServer to sServer
39031>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
39032>>>>>>>        If (hDatabase = 0) Begin
39034>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
39035>>>>>>>>
39035>>>>>>>            Procedure_Return
39036>>>>>>>        End
39036>>>>>>>>
39036>>>>>>>
39036>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
39039>>>>>>>
39039>>>>>>>    End_Procedure
39040>>>>>>>
39040>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
39042>>>>>>>        String sDriverID sServer
39042>>>>>>>        tColumnType RetvalType
39042>>>>>>>        tColumnType RetvalType
39042>>>>>>>        Integer iDbType iDriver
39042>>>>>>>        Handle hDatabase
39042>>>>>>>
39042>>>>>>>        Get psDriverID to sDriverID
39043>>>>>>>        Get piDbType   to iDbType
39044>>>>>>>        Get DriverIndex sDriverID to iDriver
39045>>>>>>>        Get psServer to sServer
39046>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
39047>>>>>>>        If (hDatabase = 0) Begin
39049>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
39050>>>>>>>>
39050>>>>>>>            Procedure_Return
39051>>>>>>>        End
39051>>>>>>>>
39051>>>>>>>
39051>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
39054>>>>>>>
39054>>>>>>>    End_Procedure
39055>>>>>>>
39055>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
39055>>>>>>>    // are mapped to the standard DataFlex data types.
39055>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
39055>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
39057>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
39057>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
39059>>>>>>>        String sDataType
39059>>>>>>>        Integer iDataType iDriverID iCount
39059>>>>>>>        Boolean bSQLDriver
39059>>>>>>>
39059>>>>>>>        Move 0 to iCount
39060>>>>>>>        Get DriverIndex sDriverID to iDriverID
39061>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
39062>>>>>>>        If (bSQLDriver = False) Begin
39064>>>>>>>            Function_Return EmptyArray
39065>>>>>>>        End
39065>>>>>>>>
39065>>>>>>>
39065>>>>>>>        // DF_ASCII
39065>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
39067>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
39070>>>>>>>        End
39070>>>>>>>>
39070>>>>>>>        Else Begin
39071>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
39074>>>>>>>        End
39074>>>>>>>>
39074>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
39075>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
39076>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
39077>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
39078>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
39079>>>>>>>        Increment iCount
39080>>>>>>>
39080>>>>>>>        // DF_BINARY
39080>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
39082>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
39085>>>>>>>        End
39085>>>>>>>>
39085>>>>>>>        Else Begin
39086>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
39089>>>>>>>        End
39089>>>>>>>>
39089>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
39090>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
39091>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
39092>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
39093>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
39094>>>>>>>        Increment iCount
39095>>>>>>>
39095>>>>>>>        // DF_DATE
39095>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
39097>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
39100>>>>>>>        End
39100>>>>>>>>
39100>>>>>>>        Else Begin
39101>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
39104>>>>>>>        End
39104>>>>>>>>
39104>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
39105>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
39106>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
39107>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
39108>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
39109>>>>>>>        Increment iCount
39110>>>>>>>
39110>>>>>>>        // DF_DATETIME
39110>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
39112>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
39115>>>>>>>        End
39115>>>>>>>>
39115>>>>>>>        Else Begin
39116>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
39119>>>>>>>        End
39119>>>>>>>>
39119>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
39120>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
39121>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
39122>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
39123>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
39124>>>>>>>        Increment iCount
39125>>>>>>>
39125>>>>>>>        // DF_NUMERIC
39125>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
39125>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
39125>>>>>>>        // we make them here all "Numeric"...
39125>>>>>>>        Case Begin
39125>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
39127>>>>>>>                Move SQL_NUMERIC to iDataType
39128>>>>>>>                Move "numeric"   to sDataType
39129>>>>>>>                Case Break
39130>>>>>>>            Case (sDriverID = DB2_DRV_ID)
39133>>>>>>>                Move SQL_NUMERIC to iDataType
39134>>>>>>>                Move "NUMERIC"   to sDataType
39135>>>>>>>                Case Break
39136>>>>>>>            Case Else
39136>>>>>>>                Move DF_BCD      to iDataType
39137>>>>>>>                Move "Numeric"   to sDataType
39138>>>>>>>        Case End
39138>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
39139>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
39140>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
39141>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
39142>>>>>>>        Increment iCount
39143>>>>>>>
39143>>>>>>>        // DF_TEXT
39143>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
39145>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
39148>>>>>>>        End
39148>>>>>>>>
39148>>>>>>>        Else Begin
39149>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
39152>>>>>>>        End
39152>>>>>>>>
39152>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
39153>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
39154>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
39155>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
39156>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
39157>>>>>>>
39157>>>>>>>        Function_Return ColumnTypeArray
39158>>>>>>>    End_Function
39159>>>>>>>
39159>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
39161>>>>>>>        tColumnType[] ColumnTypeArray
39161>>>>>>>        tColumnType[] ColumnTypeArray
39162>>>>>>>        tColumnType   ColumnType
39162>>>>>>>        tColumnType   ColumnType
39162>>>>>>>        Integer iCount iSize
39162>>>>>>>
39162>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
39163>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
39164>>>>>>>        Decrement iSize
39165>>>>>>>
39165>>>>>>>        for iCount from 0 to iSize
39171>>>>>>>>
39171>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
39173>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
39174>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
39175>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
39176>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
39177>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
39178>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
39179>>>>>>>                Move iSize to iCount
39180>>>>>>>            End
39180>>>>>>>>
39180>>>>>>>        Loop
39181>>>>>>>>
39181>>>>>>>
39181>>>>>>>        Function_Return ColumnType
39182>>>>>>>    End_Function
39183>>>>>>>
39183>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
39183>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
39183>>>>>>>    // but the Logical name is different.
39183>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
39183>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
39185>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
39185>>>>>>>        Handle hInTable hMasterTable 
39185>>>>>>>        Boolean bIsAlias
39185>>>>>>>        
39185>>>>>>>        Move hTable to hInTable
39186>>>>>>>        Move False to bIsAlias
39187>>>>>>>        Move 0 to hMasterTable
39188>>>>>>>        
39188>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
39191>>>>>>>        // Remove any prefix with a driver name.
39191>>>>>>>        Get _TableNameOnly sRootName to sRootName     
39192>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
39195>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
39196>>>>>>>        
39196>>>>>>>        // If the table has the same root and logical name it can't be an alias,
39196>>>>>>>        // so we can safely return a "False".
39196>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
39198>>>>>>>            Function_Return False
39199>>>>>>>        End
39199>>>>>>>>
39199>>>>>>>        
39199>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
39199>>>>>>>        // as the passed hTable root name.
39199>>>>>>>        // A master table always has the same root and logical name.
39199>>>>>>>        Move 0 to hTable
39200>>>>>>>        Repeat
39200>>>>>>>>
39200>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39203>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
39205>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
39208>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
39209>>>>>>>                // If we found another table with the same root and logical name
39209>>>>>>>                // we have found a master table.
39209>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
39211>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
39214>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
39215>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
39217>>>>>>>                        Move hTable to hMasterTable   
39218>>>>>>>                        Move 0 to hTable // To end the loop.
39219>>>>>>>                    End
39219>>>>>>>>
39219>>>>>>>                End
39219>>>>>>>>
39219>>>>>>>            End
39219>>>>>>>>
39219>>>>>>>        Until (hTable = 0)
39221>>>>>>>        
39221>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
39223>>>>>>>            Move True to bIsAlias
39224>>>>>>>        End
39224>>>>>>>>
39224>>>>>>>        
39224>>>>>>>        Function_Return bIsAlias
39225>>>>>>>    End_Function
39226>>>>>>>
39226>>>>>>>    // To Open a table with any driver.
39226>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
39226>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
39226>>>>>>>    //
39226>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
39226>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
39226>>>>>>>    // returns a True if successful (table could be opened).
39226>>>>>>>    //
39226>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
39226>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
39226>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
39226>>>>>>>    // set properly we can open the table.
39226>>>>>>>    //
39226>>>>>>>    // DAW Driver Syntax:
39226>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
39226>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
39226>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
39226>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
39226>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
39226>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
39226>>>>>>>    //
39226>>>>>>>    // DAW Driver Sample:
39226>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
39226>>>>>>>    //
39226>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
39228>>>>>>>        String sTableNameOrg
39228>>>>>>>        Boolean bOpen bOK
39228>>>>>>>        tSQLConnection SQLConnection
39228>>>>>>>        tSQLConnection SQLConnection
39228>>>>>>>        
39228>>>>>>>        Move False to bOpen
39229>>>>>>>        Move sTableName to sTableNameOrg
39230>>>>>>>        If (hTable > 0) Begin
39232>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
39233>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
39234>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
39235>>>>>>>            Send Ignore_Error of Error_Object_Id 10
39236>>>>>>>            Open hTable Mode iMode
39238>>>>>>>            Send Trap_Error of Error_Object_Id 20529
39239>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
39240>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
39241>>>>>>>            Send Trap_Error of Error_Object_Id 10
39242>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
39245>>>>>>>            If (bOpen = True) Begin
39247>>>>>>>                Function_Return True
39248>>>>>>>            End
39248>>>>>>>>
39248>>>>>>>        End
39248>>>>>>>>
39248>>>>>>>
39248>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
39249>>>>>>>        If (hTable > 0) Begin
39251>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
39254>>>>>>>        End
39254>>>>>>>>
39254>>>>>>>
39254>>>>>>>        Function_Return bOpen
39255>>>>>>>    End_Function
39256>>>>>>>
39256>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
39258>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
39258>>>>>>>        Boolean bOpen bOK
39258>>>>>>>        tSQLConnection SQLConnection
39258>>>>>>>        tSQLConnection SQLConnection
39258>>>>>>>
39258>>>>>>>        If (hTable < 1) Begin
39260>>>>>>>            Function_Return False
39261>>>>>>>        End
39261>>>>>>>>
39261>>>>>>>
39261>>>>>>>        Move sTableName to sTableNameOrg
39262>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
39263>>>>>>>        Move SQLConnection.sDriverID to sDriverID
39264>>>>>>>        Move SQLConnection.sConnectionString to sConnection
39265>>>>>>>        Move SQLConnection.sSchema to sSchema
39266>>>>>>>        If (sSchema = "") Begin
39268>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
39269>>>>>>>        End
39269>>>>>>>>
39269>>>>>>>
39269>>>>>>>        // We need to remove the ".int" part of the table name because
39269>>>>>>>        // the table name after the "#" in the connection syntax below wants the
39269>>>>>>>        // "bare" table name without any extension.
39269>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
39271>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
39273>>>>>>>                Get ParseFileExtension sTableName to sExt
39274>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
39275>>>>>>>            End
39275>>>>>>>>
39275>>>>>>>            Else Begin
39276>>>>>>>                Move sTableName to sTableNameShort
39277>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
39278>>>>>>>            End
39278>>>>>>>>
39278>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
39279>>>>>>>            Move sConnection to sTableName
39280>>>>>>>        End
39280>>>>>>>>
39280>>>>>>>
39280>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
39281>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
39282>>>>>>>        If (hTable = 0) Begin
39284>>>>>>>            Get NextFreeFilelistSlot to hTable
39285>>>>>>>        End
39285>>>>>>>>
39285>>>>>>>
39285>>>>>>>        Case Begin
39285>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
39287>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
39287>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
39289>>>>>>>                    Close hTable
39290>>>>>>>                    Open sTableName as hTable
39292>>>>>>>                End
39292>>>>>>>>
39292>>>>>>>                Else Begin
39293>>>>>>>                    Get OpenTableExclusive hTable to bOK
39294>>>>>>>                    If (bOK = False) Begin
39296>>>>>>>                        Function_Return False
39297>>>>>>>                    End
39297>>>>>>>>
39297>>>>>>>                End
39297>>>>>>>>
39297>>>>>>>                Case Break
39298>>>>>>>
39298>>>>>>>            Case (sDriverID = DB2_DRV_ID)
39301>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
39301>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
39303>>>>>>>                    Close hTable
39304>>>>>>>                    Open sTableName as hTable
39306>>>>>>>                End
39306>>>>>>>>
39306>>>>>>>                Else Begin
39307>>>>>>>                    Get OpenTableExclusive hTable to bOK
39308>>>>>>>                    If (bOK = False) Begin
39310>>>>>>>                        Function_Return False
39311>>>>>>>                    End
39311>>>>>>>>
39311>>>>>>>                End
39311>>>>>>>>
39311>>>>>>>                Case Break
39312>>>>>>>
39312>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
39315>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
39315>>>>>>>                If (iMode = DF_SHARE) Begin
39317>>>>>>>                    Close hTable
39318>>>>>>>                    Open sTableName as hTable
39320>>>>>>>                End
39320>>>>>>>>
39320>>>>>>>                Else Begin
39321>>>>>>>                    Get OpenTableExclusive hTable to bOK
39322>>>>>>>                    If (bOK = False) Begin
39324>>>>>>>                        Function_Return False
39325>>>>>>>                    End
39325>>>>>>>>
39325>>>>>>>                End
39325>>>>>>>>
39325>>>>>>>                Case Break
39326>>>>>>>
39326>>>>>>>            Case (sDriverID = DATAFLEX_ID)
39329>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
39331>>>>>>>                    Close hTable
39332>>>>>>>                    Open sTableName as hTable
39334>>>>>>>                End
39334>>>>>>>>
39334>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
39337>>>>>>>                    Get OpenTableExclusive hTable to bOK
39338>>>>>>>                    If (bOK = False) Begin
39340>>>>>>>                        Function_Return False
39341>>>>>>>                    End
39341>>>>>>>>
39341>>>>>>>                End
39341>>>>>>>>
39341>>>>>>>                Else Begin
39342>>>>>>>                    Open hTable
39344>>>>>>>                End
39344>>>>>>>>
39344>>>>>>>                Case Break
39345>>>>>>>
39345>>>>>>>            Case Else
39345>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
39346>>>>>>>>
39346>>>>>>>        Case End
39346>>>>>>>
39346>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
39347>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
39348>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
39350>>>>>>>            Move False to Found
39351>>>>>>>        End
39351>>>>>>>>
39351>>>>>>>        // If open failed, the Err is set to true,
39351>>>>>>>        // but we don't want that because it could end our loop.
39351>>>>>>>        Move False to Err
39352>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
39355>>>>>>>
39355>>>>>>>        Function_Return bOpen
39356>>>>>>>    End_Function
39357>>>>>>>
39357>>>>>>>    // Pass a table's logical name
39357>>>>>>>    // Returns True if the table exists in filelist.cfg.
39357>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
39359>>>>>>>        Handle hTable
39359>>>>>>>        Boolean bFound
39359>>>>>>>        String sCompareTable
39359>>>>>>>
39359>>>>>>>        Move False to bFound
39360>>>>>>>        Move 0 to hTable
39361>>>>>>>        Repeat
39361>>>>>>>>
39361>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39364>>>>>>>            If (hTable > 0) Begin
39366>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
39369>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
39371>>>>>>>                    Move True to bFound
39372>>>>>>>                End
39372>>>>>>>>
39372>>>>>>>            End
39372>>>>>>>>
39372>>>>>>>            If (bFound = True) ;                Break
39375>>>>>>>        Until (hTable = 0)
39377>>>>>>>
39377>>>>>>>        Function_Return (bFound = True)
39378>>>>>>>    End_Function
39379>>>>>>>
39379>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
39379>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
39381>>>>>>>        Boolean bOK bExists
39381>>>>>>>        String sDriverID
39381>>>>>>>
39381>>>>>>>        Get _UtilTableExists hTable to bExists
39382>>>>>>>        If (bExists = False) Begin
39384>>>>>>>            Function_Return DATAFLEX_ID
39385>>>>>>>        End
39385>>>>>>>>
39385>>>>>>>        Get OpenTableExclusive hTable to bOK
39386>>>>>>>        If (bOK = False) Begin
39388>>>>>>>            Function_Return DATAFLEX_ID
39389>>>>>>>        End
39389>>>>>>>>
39389>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
39392>>>>>>>        Function_Return sDriverID
39393>>>>>>>    End_Function
39394>>>>>>>
39394>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
39394>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
39396>>>>>>>        Handle hTable
39396>>>>>>>        Integer iRetval
39396>>>>>>>
39396>>>>>>>        Move 0 to hTable
39397>>>>>>>        Move 0 to iRetval
39398>>>>>>>
39398>>>>>>>        Repeat
39398>>>>>>>>
39398>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39401>>>>>>>            If (hTable > 0) Begin
39403>>>>>>>                Increment iRetval
39404>>>>>>>            End
39404>>>>>>>>
39404>>>>>>>        Until (hTable = 0)
39406>>>>>>>
39406>>>>>>>        Function_Return iRetval
39407>>>>>>>    End_Function
39408>>>>>>>
39408>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
39408>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
39410>>>>>>>        Handle hTable
39410>>>>>>>        String sRoot sDriverID
39410>>>>>>>        Boolean bIsSQLTable
39410>>>>>>>        Integer iPos
39410>>>>>>>
39410>>>>>>>        Move 0 to hTable
39411>>>>>>>        Move "" to sDriverID
39412>>>>>>>        Move False to bIsSQLTable
39413>>>>>>>
39413>>>>>>>        Repeat
39413>>>>>>>>
39413>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39416>>>>>>>            If (hTable > 0) Begin
39418>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
39421>>>>>>>                If (sRoot contains ":") Begin
39423>>>>>>>                    Move (Pos(":", sRoot)) to iPos
39424>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
39425>>>>>>>                End
39425>>>>>>>>
39425>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
39426>>>>>>>            End
39426>>>>>>>>
39426>>>>>>>
39426>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
39428>>>>>>>
39428>>>>>>>        Function_Return sDriverID
39429>>>>>>>    End_Function
39430>>>>>>>
39430>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
39432>>>>>>>        String sRootName
39432>>>>>>>        Boolean bIsSQL
39432>>>>>>>        Handle hTable
39432>>>>>>>
39432>>>>>>>        Move False to bIsSQL
39433>>>>>>>        Move 0 to hTable
39434>>>>>>>        Repeat
39434>>>>>>>>
39434>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39437>>>>>>>            If (hTable > 0) Begin
39439>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
39442>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
39443>>>>>>>                If (bIsSQL = True) Begin
39445>>>>>>>                    Move 0 to hTable
39446>>>>>>>                End
39446>>>>>>>>
39446>>>>>>>            End
39446>>>>>>>>
39446>>>>>>>        Until (hTable = 0)
39448>>>>>>>
39448>>>>>>>        Function_Return (bIsSQL = False)
39449>>>>>>>    End_Function
39450>>>>>>>
39450>>>>>>>    // * Dummy function for the Studio's Code Explorer *
39450>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
39452>>>>>>>        Function_Return False
39453>>>>>>>    End_Function
39454>>>>>>>
39454>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
39456>>>>>>>        String  sRetval
39456>>>>>>>        String[] sOverlapFieldsArray
39457>>>>>>>        Integer iType iColumn iColumns
39457>>>>>>>        Boolean bOpen bOverlap
39457>>>>>>>
39457>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
39460>>>>>>>        If (bOpen = False) Begin
39462>>>>>>>            Open hTable
39464>>>>>>>        End
39464>>>>>>>>
39464>>>>>>>
39464>>>>>>>        Move "" to sRetval
39465>>>>>>>
39465>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
39468>>>>>>>
39468>>>>>>>        for iColumn from 0 to iColumns
39474>>>>>>>>
39474>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
39477>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
39479>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
39482>>>>>>>                If (bOverlap) Begin
39484>>>>>>>                    If (sRetval <> "") Begin
39486>>>>>>>                        Append sRetval ","
39487>>>>>>>                    End
39487>>>>>>>>
39487>>>>>>>                    Append sRetval iColumn
39488>>>>>>>                End
39488>>>>>>>>
39488>>>>>>>            End
39488>>>>>>>>
39488>>>>>>>        Loop
39489>>>>>>>>
39489>>>>>>>
39489>>>>>>>        If (bOpen = False) Begin
39491>>>>>>>            Close hTable
39492>>>>>>>        End
39492>>>>>>>>
39492>>>>>>>
39492>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
39493>>>>>>>
39493>>>>>>>        Function_Return sOverlapFieldsArray
39494>>>>>>>    End_Function
39495>>>>>>>
39495>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
39497>>>>>>>        Handle hoRegistry hoODBCDriverNames
39497>>>>>>>        Boolean bExists bKeyOpened
39497>>>>>>>        String sKey
39497>>>>>>>        String[] sDrivers
39498>>>>>>>        Integer iDriverNames iDriverName
39498>>>>>>>
39498>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
39499>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
39500>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
39501>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
39502>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
39503>>>>>>>        If (bExists) Begin
39505>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
39506>>>>>>>            If (bKeyOpened) Begin
39508>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
39509>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
39510>>>>>>>                If (iDriverNames > 0) Begin
39512>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
39513>>>>>>>                    Decrement iDriverNames
39514>>>>>>>                    for iDriverName from 0 to iDriverNames
39520>>>>>>>>
39520>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
39521>>>>>>>                    Loop
39522>>>>>>>>
39522>>>>>>>                End
39522>>>>>>>>
39522>>>>>>>                Send CloseKey of hoRegistry
39523>>>>>>>            End
39523>>>>>>>>
39523>>>>>>>        End
39523>>>>>>>>
39523>>>>>>>        Send Destroy of hoRegistry
39524>>>>>>>
39524>>>>>>>        Function_Return sDrivers
39525>>>>>>>    End_Function
39526>>>>>>>
39526>>>>>>>    Procedure IncreaseSortBufferSize
39528>>>>>>>        String sNull
39528>>>>>>>        Integer iSortBufferSize
39528>>>>>>>        Boolean bBufferSet
39528>>>>>>>
39528>>>>>>>        Move "" to sNull
39529>>>>>>>        Move (1024 * 128) to iSortBufferSize
39530>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
39535>>>>>>>
39535>>>>>>>    End_Procedure
39536>>>>>>>
39536>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
39538>>>>>>>        Integer iLastIndex iIndex iNumSegments
39538>>>>>>>        Boolean bOK
39538>>>>>>>        String sDriverID
39538>>>>>>>
39538>>>>>>>        If (hTable > 0) Begin
39540>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
39541>>>>>>>            Close hTable
39542>>>>>>>            Get OpenTableExclusive hTable to bOK
39543>>>>>>>            If (bOK = False) Begin
39545>>>>>>>                Procedure_Return
39546>>>>>>>            End
39546>>>>>>>>
39546>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
39549>>>>>>>            Structure_Start hTable sDriverID
39550>>>>>>>                for iIndex from 1 to iLastIndex
39556>>>>>>>>
39556>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
39559>>>>>>>                    If (iNumSegments > 0) Begin
39561>>>>>>>                        If (bSetToBatch = True) Begin
39563>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
39566>>>>>>>                        End
39566>>>>>>>>
39566>>>>>>>                        Else Begin
39567>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
39570>>>>>>>                        End
39570>>>>>>>>
39570>>>>>>>                    End
39570>>>>>>>>
39570>>>>>>>                Loop
39571>>>>>>>>
39571>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
39573>>>>>>>        End
39573>>>>>>>>
39573>>>>>>>    End_Procedure
39574>>>>>>>
39574>>>>>>>    Function NextFreeFilelistSlot Returns Handle
39576>>>>>>>        Handle hTable
39576>>>>>>>
39576>>>>>>>        Move 0 to hTable
39577>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
39580>>>>>>>
39580>>>>>>>        Function_Return hTable
39581>>>>>>>    End_Function
39582>>>>>>>
39582>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
39582>>>>>>>    Procedure DebugPrint String sStmt String sFileName
39584>>>>>>>        Integer iCh
39584>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
39585>>>>>>>            Write channel iCh sStmt
39587>>>>>>>        Send Seq_Close_Channel iCh
39588>>>>>>>    End_Procedure
39589>>>>>>>
39589>>>>>>>    // Returns the integer number for the passed Driver ID that is
39589>>>>>>>    // needed by some database API calls.
39589>>>>>>>    Function DriverIndex String sDriverID Returns Integer
39591>>>>>>>        String  sCurrentDriver
39591>>>>>>>        Integer iNumberOfDrivers iDriver iCount
39591>>>>>>>
39591>>>>>>>        Move 0 to iDriver
39592>>>>>>>
39592>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
39595>>>>>>>        for iCount from 1 to iNumberOfDrivers
39601>>>>>>>>
39601>>>>>>>
39601>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
39604>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
39606>>>>>>>                Move iCount to iDriver
39607>>>>>>>            End
39607>>>>>>>>
39607>>>>>>>        Loop
39608>>>>>>>>
39608>>>>>>>
39608>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
39608>>>>>>>        If (iDriver = 0) Begin
39610>>>>>>>            Move False to Err
39611>>>>>>>            Load_Driver sDriverID
39612>>>>>>>            If (Err = False) Begin
39614>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
39617>>>>>>>            End
39617>>>>>>>>
39617>>>>>>>        End
39617>>>>>>>>
39617>>>>>>>
39617>>>>>>>        Function_Return iDriver
39618>>>>>>>    End_Function
39619>>>>>>>
39619>>>>>>>
39619>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
39621>>>>>>>        String  sSqlServerClientVersionName
39621>>>>>>>        
39621>>>>>>>        Case Begin
39621>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
39623>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
39624>>>>>>>                Case Break
39625>>>>>>>
39625>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
39628>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
39629>>>>>>>                Case Break
39630>>>>>>>                
39630>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
39633>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
39634>>>>>>>                Case Break
39635>>>>>>>            
39635>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
39638>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
39639>>>>>>>                Case Break
39640>>>>>>>            
39640>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
39643>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
39644>>>>>>>                Case Break
39645>>>>>>>            
39645>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
39648>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
39649>>>>>>>                Case Break
39650>>>>>>>            
39650>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
39653>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
39654>>>>>>>                Case Break
39655>>>>>>>            
39655>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
39658>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
39659>>>>>>>                Case Break
39660>>>>>>>            
39660>>>>>>>            Case Else
39660>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
39661>>>>>>>        Case End
39661>>>>>>>        
39661>>>>>>>        Function_Return sSqlServerClientVersionName
39662>>>>>>>    End_Function
39663>>>>>>>
39663>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
39665>>>>>>>        String  sSqlServerClientDriverName
39665>>>>>>>        
39665>>>>>>>        Case Begin
39665>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
39667>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
39668>>>>>>>                Case Break
39669>>>>>>>
39669>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
39672>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
39673>>>>>>>                Case Break
39674>>>>>>>                
39674>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
39677>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
39678>>>>>>>                Case Break
39679>>>>>>>            
39679>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
39682>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
39683>>>>>>>                Case Break
39684>>>>>>>            
39684>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
39687>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
39688>>>>>>>                Case Break
39689>>>>>>>            
39689>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
39692>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
39693>>>>>>>                Case Break
39694>>>>>>>            
39694>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
39697>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
39698>>>>>>>                Case Break
39699>>>>>>>            
39699>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
39702>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
39703>>>>>>>                Case Break
39704>>>>>>>            
39704>>>>>>>            Case Else
39704>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
39705>>>>>>>        Case End
39705>>>>>>>        
39705>>>>>>>        Function_Return sSqlServerClientDriverName
39706>>>>>>>    End_Function
39707>>>>>>>    
39707>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
39709>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
39709>>>>>>>        Integer iNumberOfDrivers iDriver iClient
39709>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
39709>>>>>>>        Boolean bOK
39709>>>>>>>        
39709>>>>>>>        Move "" to sRetval
39710>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
39711>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
39712>>>>>>>        Load_Driver MSSQLDRV_ID
39713>>>>>>>
39713>>>>>>>        // Loop through all loaded drivers.
39713>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
39716>>>>>>>        For iDriver from 1 to iNumberOfDrivers
39722>>>>>>>>
39722>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
39725>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
39727>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
39728>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
39731>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
39732>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
39733>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
39734>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
39735>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
39737>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
39738>>>>>>>                End                                
39738>>>>>>>>
39738>>>>>>>                Else Begin
39739>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
39740>>>>>>>                End
39740>>>>>>>>
39740>>>>>>>            End
39740>>>>>>>>
39740>>>>>>>        Loop
39741>>>>>>>>
39741>>>>>>>        Send Destroy of hoCLIHandler  
39742>>>>>>>        Send Destroy of hoMSSQLHandler  
39743>>>>>>>        If (bShowErrorDialog = True) Begin
39745>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
39746>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
39748>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
39749>>>>>>>                If (bExitProgram = True) Begin
39751>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
39752>>>>>>>                End
39752>>>>>>>>
39752>>>>>>>                Send Stop_Box sRetval  
39753>>>>>>>                If (bExitProgram = True) Begin
39755>>>>>>>                    Send Exit_Application
39756>>>>>>>                End
39756>>>>>>>>
39756>>>>>>>            End
39756>>>>>>>>
39756>>>>>>>        End
39756>>>>>>>>
39756>>>>>>>        
39756>>>>>>>        Function_Return sRetval
39757>>>>>>>    End_Function  
39758>>>>>>>    
39758>>>>>>>    // Returns True if first "." separated string is greater than the second.
39758>>>>>>>    // It checks from left to right, one part of the string at a time.
39758>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
39758>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
39760>>>>>>>        String[] asVersion asSQLVersion          
39762>>>>>>>        Integer iSize iCount iVersion iSQLVersion
39762>>>>>>>        
39762>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
39763>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
39764>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
39765>>>>>>>        // Make sure the two arrays are of the same size:
39765>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
39767>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
39768>>>>>>>        End
39768>>>>>>>>
39768>>>>>>>        Decrement iSize
39769>>>>>>>        for iCount from 0 to iSize
39775>>>>>>>>
39775>>>>>>>            Move asVersion[iCount]    to iVersion
39776>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
39777>>>>>>>            CompilerWarnings Off
39777>>>>>>>            If (iVersion > iSQLVersion) Break
39780>>>>>>>            CompilerWarnings On
39780>>>>>>>        Loop
39781>>>>>>>>
39781>>>>>>>        
39781>>>>>>>        Function_Return (iVersion > iSQLVersion)
39782>>>>>>>    End_Function
39783>>>>>>>
39783>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
39783>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
39783>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
39783>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
39785>>>>>>>        Integer iMode iErrorObject
39785>>>>>>>        Boolean bOpened
39785>>>>>>>        String sTableName 
39785>>>>>>>        Handle hoCurrentErrorHandler
39785>>>>>>>
39785>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
39786>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
39786>>>>>>>        // so we generate an error here:
39786>>>>>>>        If (IsDebuggerPresent()) Begin
39788>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
39789>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
39790>>>>>>>            If (iErrorObject <> 0) Begin
39792>>>>>>>                Move iErrorObject to Error_Object_Id
39793>>>>>>>            End
39793>>>>>>>>
39793>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
39794>>>>>>>>
39794>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
39795>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
39796>>>>>>>            Function_Return False
39797>>>>>>>        End
39797>>>>>>>>
39797>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
39800>>>>>>>        If (bOpened) Begin
39802>>>>>>>//            If (IsDebuggerPresent()) Begin
39802>>>>>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39802>>>>>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
39802>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
39802>>>>>>>//                    Function_Return True
39802>>>>>>>//                End
39802>>>>>>>//            End
39802>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
39805>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
39807>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39808>>>>>>>                Function_Return True
39809>>>>>>>            End
39809>>>>>>>>
39809>>>>>>>            Close hTable
39810>>>>>>>        End
39810>>>>>>>>
39810>>>>>>>        Else Begin
39811>>>>>>>            Open hTable
39813>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
39816>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
39818>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
39821>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
39823>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
39824>>>>>>>                    Function_Return True
39825>>>>>>>                End
39825>>>>>>>>
39825>>>>>>>            End
39825>>>>>>>>
39825>>>>>>>
39825>>>>>>>        End
39825>>>>>>>>
39825>>>>>>>
39825>>>>>>>        Close hTable
39826>>>>>>>        Open hTable Mode DF_EXCLUSIVE
39828>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
39831>>>>>>>
39831>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
39832>>>>>>>        Function_Return bOpened
39833>>>>>>>    End_Function
39834>>>>>>>
39834>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
39836>>>>>>>        String sConnectionID sConnectionString sDriverID
39836>>>>>>>        Boolean bExists bOK bSQLDriver
39836>>>>>>>        Handle hoCLI hoDriver
39836>>>>>>>        Integer iRetval
39836>>>>>>>        tSQLConnection SQLConnection
39836>>>>>>>        tSQLConnection SQLConnection
39836>>>>>>>
39836>>>>>>>        Get psDriverID to sDriverID
39837>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
39838>>>>>>>        If (bSQLDriver = False) Begin
39840>>>>>>>            Function_Return True
39841>>>>>>>        End
39841>>>>>>>>
39841>>>>>>>
39841>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
39842>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
39843>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
39844>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
39845>>>>>>>
39845>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
39846>>>>>>>        If (bExists = False) Begin
39848>>>>>>>            // We always start by deleting the current connection - if any - because the
39848>>>>>>>            // login details my have changed.
39848>>>>>>>            Get phoCLIHandler to hoCLI
39849>>>>>>>            Set psDriverID    of hoCLI to sDriverID
39850>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
39851>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
39852>>>>>>>            If (bOk = False) Begin
39854>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
39855>>>>>>>>
39855>>>>>>>                Function_Return False
39856>>>>>>>            End
39856>>>>>>>>
39856>>>>>>>            Move bOK to bExists
39857>>>>>>>        End
39857>>>>>>>>
39857>>>>>>>
39857>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
39858>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
39859>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
39860>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
39861>>>>>>>        Send Destroy of hoDriver
39862>>>>>>>
39862>>>>>>>        Function_Return (bExists = True)
39863>>>>>>>    End_Function
39864>>>>>>>
39864>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
39864>>>>>>>    // Returns: False if nobody else is running
39864>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
39864>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
39864>>>>>>>    //      tables are not locked as DataFlex tables are.
39864>>>>>>>    Function IsDatabaseInUse Returns Boolean
39866>>>>>>>        Handle  hTable
39866>>>>>>>        String  sRootName
39866>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
39866>>>>>>>        Integer iCount iTables
39866>>>>>>>
39866>>>>>>>        Move 0 to iTables
39867>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
39868>>>>>>>        Get AutoConnectionIDLogin to bOK
39869>>>>>>>        Get UtilFilelistNoOfTables to iTables
39870>>>>>>>        Set piPosition   of ghoProgressBar to 0
39871>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
39872>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
39873>>>>>>>        Close DF_ALL
39874>>>>>>>        Move 0 to hTable
39875>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39878>>>>>>>        Move False to bErr
39879>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
39880>>>>>>>
39880>>>>>>>        Repeat
39880>>>>>>>>
39880>>>>>>>            Set piPosition of ghoProgressBar to iCount
39881>>>>>>>            Increment iCount
39882>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
39885>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
39886>>>>>>>
39886>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
39886>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
39887>>>>>>>            Move False to bOpen
39888>>>>>>>            Get _UtilTableExists hTable to bExists
39889>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
39889>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
39891>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
39892>>>>>>>                Open hTable
39894>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
39897>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
39898>>>>>>>                If (bOpen = True) Begin
39900>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
39900>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
39901>>>>>>>                    If (bAlias = False) Begin
39903>>>>>>>                        Close hTable
39904>>>>>>>                        Get OpenTableExclusive hTable to bOpen
39905>>>>>>>                        If (bOpen = False) Begin
39907>>>>>>>                            Move True to bErr
39908>>>>>>>                        End
39908>>>>>>>>
39908>>>>>>>                    End
39908>>>>>>>>
39908>>>>>>>                End
39908>>>>>>>>
39908>>>>>>>                Close hTable
39909>>>>>>>            End
39909>>>>>>>>
39909>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
39912>>>>>>>            If (bErr = True ) ;                Break
39915>>>>>>>        Until (not(hTable))
39917>>>>>>>
39917>>>>>>>        Set Action_Text of ghoStatusPanel to ""
39918>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
39919>>>>>>>        Move False to Err
39920>>>>>>>
39920>>>>>>>        Function_Return bErr
39921>>>>>>>    End_Function
39922>>>>>>>
39922>>>>>>>End_Class
39923>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
39923>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
39923>>>>>>>//
39923>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
39923>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
39923>>>>>>>// conjunction with constraint-clauses.
39923>>>>>>>//
39923>>>>>>>// SYNTAX:
39923>>>>>>>//
39923>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
39923>>>>>>>//    <Constraints...>
39923>>>>>>>//    {DO}
39923>>>>>>>//      <loop body>
39923>>>>>>>//  End_For_All
39923>>>>>>>//
39923>>>>>>>// This set of macros implements a constraint-oriented file enumeration
39923>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
39923>>>>>>>//
39923>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
39923>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
39923>>>>>>>//   End_For_All
39923>>>>>>>//
39923>>>>>>>// To list only Customers with a Balance greater than their credit limit:
39923>>>>>>>//
39923>>>>>>>//   For_All Customer BY Index.1
39923>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
39923>>>>>>>//     DO
39923>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
39923>>>>>>>//   End_For_All
39923>>>>>>>//
39923>>>>>>>// Constraint clauses are:
39923>>>>>>>//
39923>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
39923>>>>>>>//   CONSTRAIN <File> AS <Expression>
39923>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
39923>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
39923>>>>>>>//
39923>>>>>>>// For example, to list all customers with a bad status whose names start
39923>>>>>>>// with "A" and which have not made a payment in thirty days:
39923>>>>>>>//
39923>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
39923>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
39923>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
39923>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
39923>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
39923>>>>>>>//      DO
39923>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
39923>>>>>>>//    End_For_All
39923>>>>>>>//
39923>>>>>>>
39923>>>>>>>
39923>>>>>>>//This command starts the loop process body when constraints are used;
39923>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
39923>>>>>>>//command line, and not on a line by itself
39923>>>>>>>//
39923>>>>>>>
39923>>>>>>>//Ends a For_All loop
39923>>>>>>>//
39923>>>>>>>
39923>>>>>>>
39923>>>>>
39923>>>>>
39923>>>>>Class cDbUpdateVersion is a cObject
39924>>>>>
39924>>>>>    Procedure Construct_Object    
39926>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
39926>>>>>        String[] aSQLQueryMessages
39927>>>>>        
39927>>>>>        Forward Send Construct_Object
39929>>>>>
39929>>>>>        // cDbUpdateHandler object event.
39929>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
39931>>>>>        If (bOnCreateExecuted = False) Begin    
39933>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
39935>>>>>            If (bUseCustomDbVersion = False) Begin
39937>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
39939>>>>>            End
39939>>>>>>
39939>>>>>            Delegate Send CheckIntFilesIntegrity
39941>>>>>            Delegate Send OnCreate
39943>>>>>            Delegate Set Private.pbOnCreateExecuted to True
39945>>>>>        End
39945>>>>>>
39945>>>>>
39945>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
39945>>>>>        // event was triggered, thus an actual change of the database was made.
39945>>>>>        Property Boolean pbVersionUpdate False
39946>>>>>
39946>>>>>        // This property must be manually set within each cDbUpdateVersion object
39946>>>>>        // by the programmer, to a consecutive number.
39946>>>>>        Property Number pnVersionNumber
39947>>>>>
39947>>>>>        Property Boolean pbUseConnectionID True
39948>>>>>        Property Boolean private.pbToANSI   True
39949>>>>>        Property Boolean private.pbRecnum   True
39950>>>>>        Property Boolean private.pbCopyData True
39951>>>>>        Property Boolean private.pbApiTableUpdateAuto False
39952>>>>>        Property Boolean private.pbCompareDate_DateTime False
39953>>>>>        Property Boolean private.pbCompareIndexAscending False
39954>>>>>        Property Boolean private.pbCompareIndexUppercase False
39955>>>>>        Property String private.psSchema
39956>>>>>        Property String private.psBaseTableSpace
39957>>>>>        Property String private.psLongTableSpace
39958>>>>>        Property String private.psIndexTableSpace
39959>>>>>
39959>>>>>        // Driver default value settings:
39959>>>>>        Property String private.psDriverDefaultValueASCII    ""
39960>>>>>        Property String private.psDriverDefaultValueBinary   ""
39961>>>>>        Property String private.psDriverDefaultValueDate     ""
39962>>>>>        Property String private.psDriverDefaultValueDateTime ""
39963>>>>>        Property String private.psDriverDefaultValueNumeric  ""
39964>>>>>        Property String private.psDriverDefaultValueText     ""
39965>>>>>
39965>>>>>        // Driver "nullability" settings:
39965>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
39966>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
39967>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
39968>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
39969>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
39970>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
39971>>>>>
39971>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
39971>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
39971>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
39971>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
39971>>>>>        // We reset it here for each cDbUpdateVersion object
39971>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
39973>>>>>    End_Procedure
39974>>>>>
39974>>>>>    // *** Main hook event message ***
39974>>>>>    // Place your database update logic here!
39974>>>>>    Procedure OnUpdate
39976>>>>>    End_Procedure
39977>>>>>
39977>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
39977>>>>>    // imported to the cDbUpdateHandler container class which should be a
39977>>>>>    // parent object to this object. To have the Studio's Property Panel
39977>>>>>    // "behave" aka show these properties we need to duplicate them in this
39977>>>>>    // class and "relay" them to the parent object.
39977>>>>>    Procedure Set pbToANSI Boolean bState
39979>>>>>        Set private.pbToANSI  to bState
39980>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
39981>>>>>        Delegate Set pbToANSI to bState
39983>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
39984>>>>>    End_Procedure
39985>>>>>
39985>>>>>    Function pbToANSI Returns Boolean
39987>>>>>        Function_Return (private.pbToAnsi(Self))
39988>>>>>    End_Function
39989>>>>>
39989>>>>>    Procedure Set pbRecnum Boolean bState
39991>>>>>        Set private.pbRecnum  to bState
39992>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
39993>>>>>        Delegate Set pbRecnum to bState
39995>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
39996>>>>>    End_Procedure
39997>>>>>
39997>>>>>    Function pbRecnum Returns Boolean
39999>>>>>        Function_Return (private.pbRecnum(Self))
40000>>>>>    End_Function
40001>>>>>
40001>>>>>    Procedure Set pbCopyData Boolean bState
40003>>>>>        Set private.pbCopyData  to bState
40004>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40005>>>>>        Delegate Set pbCopyData to bState
40007>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40008>>>>>    End_Procedure
40009>>>>>
40009>>>>>    Function pbCopyData Returns Boolean
40011>>>>>        Function_Return (private.pbCopyData(Self))
40012>>>>>    End_Function
40013>>>>>
40013>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
40013>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
40015>>>>>        Set private.pbApiTableUpdateAuto  to bState
40016>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40017>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
40018>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40019>>>>>    End_Procedure
40020>>>>>
40020>>>>>    Function pbApiTableUpdateAuto Returns Boolean
40022>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
40023>>>>>    End_Function
40024>>>>>
40024>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
40026>>>>>        Set private.pbCompareDate_DateTime  to bState
40027>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40028>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
40029>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40030>>>>>    End_Procedure
40031>>>>>
40031>>>>>    Function pbCompareDate_DateTime Returns Boolean
40033>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
40034>>>>>    End_Function
40035>>>>>
40035>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
40037>>>>>        Set private.pbCompareIndexAscending  to bState
40038>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40039>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
40040>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40041>>>>>    End_Procedure
40042>>>>>
40042>>>>>    Function pbCompareIndexAscending Returns Boolean
40044>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
40045>>>>>    End_Function
40046>>>>>
40046>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
40048>>>>>        Set private.pbCompareIndexUppercase  to bState
40049>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40050>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
40051>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40052>>>>>    End_Procedure
40053>>>>>
40053>>>>>    Function pbCompareIndexUppercase Returns Boolean
40055>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
40056>>>>>    End_Function
40057>>>>>
40057>>>>>    Procedure Set psSchema String sValue
40059>>>>>        Set private.psSchema  to sValue
40060>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40061>>>>>        Delegate Set psSchema to sValue
40063>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40064>>>>>    End_Procedure
40065>>>>>
40065>>>>>    // First retrieve the private value that might have been set in the object.
40065>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40065>>>>>    // it might have been specified in the SQLConnections.ini file.
40065>>>>>    Function psSchema Returns String
40067>>>>>        String sValue
40067>>>>>        Get private.psSchema to sValue
40068>>>>>        If (sValue = "") Begin
40070>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
40071>>>>>        End
40071>>>>>>
40071>>>>>        Function_Return sValue
40072>>>>>    End_Function
40073>>>>>
40073>>>>>    Procedure Set psBaseTableSpace String sValue
40075>>>>>        Set private.psBaseTableSpace  to sValue
40076>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40077>>>>>        Delegate Set psBaseTableSpace to sValue
40079>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40080>>>>>    End_Procedure
40081>>>>>
40081>>>>>    // First retrieve the private value that might have been set in the object.
40081>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40081>>>>>    // it might have been specified in the SQLConnections.ini file.
40081>>>>>    Function psBaseTableSpace Returns String
40083>>>>>        String sValue
40083>>>>>        Get private.psBaseTableSpace to sValue
40084>>>>>        If (sValue = "") Begin
40086>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
40087>>>>>        End
40087>>>>>>
40087>>>>>        Function_Return sValue
40088>>>>>    End_Function
40089>>>>>
40089>>>>>    Procedure Set psLongTableSpace String sValue
40091>>>>>        Set private.psLongTableSpace  to sValue
40092>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40093>>>>>        Delegate Set psLongTableSpace to sValue
40095>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40096>>>>>    End_Procedure
40097>>>>>
40097>>>>>    // First retrieve the private value that might have been set in the object.
40097>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40097>>>>>    // it might have been specified in the SQLConnections.ini file.
40097>>>>>    Function psLongTableSpace Returns String
40099>>>>>        String sValue
40099>>>>>        Get private.psLongTableSpace to sValue
40100>>>>>        If (sValue = "") Begin
40102>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
40103>>>>>        End
40103>>>>>>
40103>>>>>        Function_Return sValue
40104>>>>>    End_Function
40105>>>>>
40105>>>>>    Procedure Set psIndexTableSpace String sValue
40107>>>>>        Set private.psIndexTableSpace  to sValue
40108>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40109>>>>>        Delegate Set psIndexTableSpace to sValue
40111>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40112>>>>>    End_Procedure
40113>>>>>
40113>>>>>    // First retrieve the private value that might have been set in the object.
40113>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
40113>>>>>    // it might have been specified in the SQLConnections.ini file.
40113>>>>>    Function psIndexTableSpace Returns String
40115>>>>>        String sValue
40115>>>>>        Get private.psIndexTableSpace to sValue
40116>>>>>        If (sValue = "") Begin
40118>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
40119>>>>>        End
40119>>>>>>
40119>>>>>        Function_Return sValue
40120>>>>>    End_Function
40121>>>>>
40121>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
40123>>>>>        Set private.psDriverDefaultValueASCII  to sValue
40124>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40125>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
40127>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40128>>>>>    End_Procedure
40129>>>>>
40129>>>>>    // First retrieve the private value that might have been set in the object.
40129>>>>>    // If blank; get it from the parent object
40129>>>>>    Function psDriverDefaultValueASCII Returns String
40131>>>>>        String sValue
40131>>>>>        Get private.psDriverDefaultValueASCII to sValue
40132>>>>>        If (sValue = "") Begin
40134>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
40136>>>>>        End
40136>>>>>>
40136>>>>>        Function_Return sValue
40137>>>>>    End_Function
40138>>>>>
40138>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
40140>>>>>        Set private.psDriverDefaultValueBinary  to sValue
40141>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40142>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
40144>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40145>>>>>    End_Procedure
40146>>>>>
40146>>>>>    // First retrieve the private value that might have been set in the object.
40146>>>>>    // If blank; get it from the parent object
40146>>>>>    Function psDriverDefaultValueBinary Returns String
40148>>>>>        String sValue
40148>>>>>        Get private.psDriverDefaultValueBinary to sValue
40149>>>>>        If (sValue = "") Begin
40151>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
40153>>>>>        End
40153>>>>>>
40153>>>>>        Function_Return sValue
40154>>>>>    End_Function
40155>>>>>
40155>>>>>    Procedure Set psDriverDefaultValueDate String sValue
40157>>>>>        Set private.psDriverDefaultValueDate  to sValue
40158>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40159>>>>>        Delegate Set psDriverDefaultValueDate to sValue
40161>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40162>>>>>    End_Procedure
40163>>>>>
40163>>>>>    // First retrieve the private value that might have been set in the object.
40163>>>>>    // If blank; get it from the parent object
40163>>>>>    Function psDriverDefaultValueDate Returns String
40165>>>>>        String sValue
40165>>>>>        Get private.psDriverDefaultValueDate to sValue
40166>>>>>        If (sValue = "") Begin
40168>>>>>            Delegate Get psDriverDefaultValueDate to sValue
40170>>>>>        End
40170>>>>>>
40170>>>>>        Function_Return sValue
40171>>>>>    End_Function
40172>>>>>
40172>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
40174>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
40175>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40176>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
40178>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40179>>>>>    End_Procedure
40180>>>>>
40180>>>>>    // First retrieve the private value that might have been set in the object.
40180>>>>>    // If blank; get it from the parent object
40180>>>>>    Function psDriverDefaultValueDateTime Returns String
40182>>>>>        String sValue
40182>>>>>        Get private.psDriverDefaultValueDateTime to sValue
40183>>>>>        If (sValue = "") Begin
40185>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
40187>>>>>        End
40187>>>>>>
40187>>>>>        Function_Return sValue
40188>>>>>    End_Function
40189>>>>>
40189>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
40191>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
40192>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40193>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
40195>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40196>>>>>    End_Procedure
40197>>>>>
40197>>>>>    // First retrieve the private value that might have been set in the object.
40197>>>>>    // If blank; get it from the parent object
40197>>>>>    Function psDriverDefaultValueNumeric Returns String
40199>>>>>        String sValue
40199>>>>>        Get private.psDriverDefaultValueNumeric to sValue
40200>>>>>        If (sValue = "") Begin
40202>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
40204>>>>>        End
40204>>>>>>
40204>>>>>        Function_Return sValue
40205>>>>>    End_Function
40206>>>>>
40206>>>>>    Procedure Set psDriverDefaultValueText String sValue
40208>>>>>        Set private.psDriverDefaultValueText  to sValue
40209>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40210>>>>>        Delegate Set psDriverDefaultValueText to sValue
40212>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40213>>>>>    End_Procedure
40214>>>>>
40214>>>>>    // First retrieve the private value that might have been set in the object.
40214>>>>>    // If blank; get it from the parent object
40214>>>>>    Function psDriverDefaultValueText Returns String
40216>>>>>        String sValue
40216>>>>>        Get private.psDriverDefaultValueText to sValue
40217>>>>>        If (sValue = "") Begin
40219>>>>>            Delegate Get psDriverDefaultValueText to sValue
40221>>>>>        End
40221>>>>>>
40221>>>>>        Function_Return sValue
40222>>>>>    End_Function
40223>>>>>
40223>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
40225>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
40226>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40227>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
40229>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40230>>>>>    End_Procedure
40231>>>>>
40231>>>>>    // First retrieve the private value that might have been set in the object.
40231>>>>>    // If blank; get it from the parent object
40231>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
40233>>>>>        Boolean bState
40233>>>>>        Get private.pbDriverDefaultNullableASCII to bState
40234>>>>>        If (bState = False) Begin
40236>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
40238>>>>>        End
40238>>>>>>
40238>>>>>        Function_Return bState
40239>>>>>    End_Function
40240>>>>>
40240>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
40242>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
40243>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40244>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
40246>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40247>>>>>    End_Procedure
40248>>>>>
40248>>>>>    // First retrieve the private value that might have been set in the object.
40248>>>>>    // If blank; get it from the parent object
40248>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
40250>>>>>        Boolean bState
40250>>>>>        Get private.pbDriverDefaultNullableBinary to bState
40251>>>>>        If (bState = False) Begin
40253>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
40255>>>>>        End
40255>>>>>>
40255>>>>>        Function_Return bState
40256>>>>>    End_Function
40257>>>>>
40257>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
40259>>>>>        Set private.pbDriverDefaultNullableDate  to bState
40260>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40261>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
40263>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40264>>>>>    End_Procedure
40265>>>>>
40265>>>>>    // First retrieve the private value that might have been set in the object.
40265>>>>>    // If blank; get it from the parent object
40265>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
40267>>>>>        Boolean bState
40267>>>>>        Get private.pbDriverDefaultNullableDate to bState
40268>>>>>        If (bState = False) Begin
40270>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
40272>>>>>        End
40272>>>>>>
40272>>>>>        Function_Return bState
40273>>>>>    End_Function
40274>>>>>
40274>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
40276>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
40277>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40278>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
40280>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40281>>>>>    End_Procedure
40282>>>>>
40282>>>>>    // First retrieve the private value that might have been set in the object.
40282>>>>>    // If blank; get it from the parent object
40282>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
40284>>>>>        Boolean bState
40284>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
40285>>>>>        If (bState = False) Begin
40287>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
40289>>>>>        End
40289>>>>>>
40289>>>>>        Function_Return bState
40290>>>>>    End_Function
40291>>>>>
40291>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
40293>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
40294>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40295>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
40297>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40298>>>>>    End_Procedure
40299>>>>>
40299>>>>>    // First retrieve the private value that might have been set in the object.
40299>>>>>    // If blank; get it from the parent object
40299>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
40301>>>>>        Boolean bState
40301>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
40302>>>>>        If (bState = False) Begin
40304>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
40306>>>>>        End
40306>>>>>>
40306>>>>>        Function_Return bState
40307>>>>>    End_Function
40308>>>>>
40308>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
40310>>>>>        Set private.pbDriverDefaultNullableText  to bState
40311>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40312>>>>>        Delegate Set pbDriverDefaultNullableText to bState
40314>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40315>>>>>    End_Procedure
40316>>>>>
40316>>>>>    // First retrieve the private value that might have been set in the object.
40316>>>>>    // If blank; get it from the parent object
40316>>>>>    Function pbDriverDefaultNullableText Returns Boolean
40318>>>>>        Boolean bState
40318>>>>>        Get private.pbDriverDefaultNullableText to bState
40319>>>>>        If (bState = False) Begin
40321>>>>>            Delegate Get pbDriverDefaultNullableText to bState
40323>>>>>        End
40323>>>>>>
40323>>>>>        Function_Return bState
40324>>>>>    End_Function
40325>>>>>
40325>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
40327>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
40327>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
40327>>>>>
40327>>>>>        Get psDriverID to sDriverID
40328>>>>>        Get psSchema to sSchema
40329>>>>>
40329>>>>>        Get psBaseTableSpace to sBaseTableSpace
40330>>>>>        If (sBaseTableSpace <> "") Begin
40332>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40333>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
40335>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40336>>>>>        End
40336>>>>>>
40336>>>>>
40336>>>>>        Get psLongTableSpace to sLongTableSpace
40337>>>>>        If (sLongTableSpace <> "") Begin
40339>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40340>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
40342>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40343>>>>>        End
40343>>>>>>
40343>>>>>
40343>>>>>        Get psIndexTableSpace to sIndexTableSpace
40344>>>>>        If (sIndexTableSpace <> "") Begin
40346>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
40347>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
40349>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
40350>>>>>        End
40350>>>>>>
40350>>>>>
40350>>>>>        Get pbUseConnectionID to bUseConnectionID
40351>>>>>        Get pbToANSI          to bToANSI
40352>>>>>        Get pbRecnum          to bRecnum
40353>>>>>        Get pbCopyData        to bCopyData
40354>>>>>
40354>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
40355>>>>>
40355>>>>>        Function_Return bOK
40356>>>>>    End_Function
40357>>>>>
40357>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
40357>>>>>//        Boolean bOK bExists
40357>>>>>//        String sDataPath sBackupFolder
40357>>>>>//        
40357>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
40357>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
40357>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
40357>>>>>//        Get vFolderFormat sDataPath to sDataPath
40357>>>>>//        
40357>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
40357>>>>>//        If (bExists = False) Begin
40357>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
40357>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
40357>>>>>//            If (bExists = False) Begin
40357>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
40357>>>>>//                Function_Return False
40357>>>>>//            End                                                                                                                                            
40357>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
40357>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
40357>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
40357>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
40357>>>>>//        End
40357>>>>>//        
40357>>>>>//        Set Message_Text of ghoStatusPanel to ""
40357>>>>>//        Function_Return bOK
40357>>>>>//    End_Function
40357>>>>>//
40357>>>>>    // This is automatically called after the OnUpdate
40357>>>>>    // event has been executed. It will automatically update the
40357>>>>>    // version database field/column with the "pnVersionNumber"
40357>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
40357>>>>>    Procedure UpdateVersionColumnValue
40359>>>>>        Number nVersion nCurrentValue
40359>>>>>        Integer hTable iColumn
40359>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
40359>>>>>
40359>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
40359>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
40359>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
40361>>>>>        Get pbVersionUpdate to bVersionUpdate
40362>>>>>
40362>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
40364>>>>>            Get pnVersionNumber to nVersion
40365>>>>>            Delegate Get piDbVersionFileNumber  to hTable
40367>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
40369>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
40369>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
40369>>>>>            Close DF_ALL DF_PERMANENT
40370>>>>>
40370>>>>>            Open hTable
40372>>>>>
40372>>>>>            // It is then the developer responsibility to take care of finding
40372>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
40372>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
40374>>>>>            If (bUseCustomDbVersion = True) Begin
40376>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
40378>>>>>            End
40378>>>>>>
40378>>>>>
40378>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
40381>>>>>            If (nCurrentValue < nVersion) Begin
40383>>>>>                Lock
40384>>>>>>
40384>>>>>                    If (bUseCustomDbVersion = False) Begin
40386>>>>>                        Vfind hTable Recnum GE                            
40388>>>>>                    End
40388>>>>>>
40388>>>>>                    Set_Field_Value hTable iColumn to nVersion
40391>>>>>                    SaveRecord hTable
40392>>>>>                Unlock
40393>>>>>>
40393>>>>>            End
40393>>>>>>
40393>>>>>            Close hTable
40394>>>>>        End
40394>>>>>>
40394>>>>>    End_Procedure
40395>>>>>
40395>>>>>// Property of the container object (cDbUpdateHandler)
40395>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
40395>>>>>
40395>>>>>    Procedure End_Construct_Object
40397>>>>>        Forward Send End_Construct_Object
40399>>>>>        Send ProcessUpdate True
40400>>>>>    End_Procedure
40401>>>>>    
40401>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
40403>>>>>        Number nVersion nCurrentValue
40403>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
40403>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
40403>>>>>        String sObjectName
40403>>>>>        tDbVersionInfo[] dbVersionInfoArray
40403>>>>>        tDbVersionInfo[] dbVersionInfoArray
40404>>>>>
40404>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
40406>>>>>
40406>>>>>        // If the programmer forgot to set the version number we do not allow for the application
40406>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
40406>>>>>        // one database update is depended on an earlier update and that earlier version
40406>>>>>        // update was never executed it could lead to disastrous results.
40406>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
40406>>>>>        Get pnVersionNumber to nVersion
40407>>>>>        If (nVersion = 0) Begin
40409>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
40410>>>>>            Move (Name(Self)) to sObjectName
40411>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
40412>>>>>>
40412>>>>>            Send Exit_Application
40413>>>>>        End
40413>>>>>>
40413>>>>>
40413>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
40413>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
40413>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
40415>>>>>        If (bOnPreUpdateExecuted = False) Begin
40417>>>>>            Delegate Send OnPreUpdate
40419>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
40421>>>>>        End
40421>>>>>>
40421>>>>>        
40421>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
40423>>>>>        
40423>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
40425>>>>>        If (bUseCustomDbVersion = False) Begin
40427>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
40427>>>>>        End
40427>>>>>>
40427>>>>>        Else Begin
40428>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
40429>>>>>            If (bTableExists = False) Begin
40431>>>>>                Delegate Send OnCreateCustomDbVersionTable
40433>>>>>            End
40433>>>>>>
40433>>>>>        End
40433>>>>>>
40433>>>>>        
40433>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
40433>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
40433>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
40435>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
40437>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
40438>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
40439>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
40440>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
40442>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
40444>>>>>        End
40444>>>>>>
40444>>>>>
40444>>>>>        Delegate Get piDbVersionFileNumber  to hTable
40446>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
40448>>>>>
40448>>>>>        Open hTable
40450>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
40453>>>>>        If (bOpened = False) Begin
40455>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
40456>>>>>            Send Exit_Application
40457>>>>>        End
40457>>>>>>
40457>>>>>        
40457>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
40457>>>>>        // in case we take care of it here.
40457>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
40460>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
40462>>>>>            Vfind hTable 0 GT
40464>>>>>        End
40464>>>>>>
40464>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
40467>>>>>        If (bSystemTable = True) Begin
40469>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
40472>>>>>        End
40472>>>>>>
40472>>>>>        Else Begin
40473>>>>>            If (bUseCustomDbVersion = True) Begin
40475>>>>>                Send OnFindVersionRecord
40476>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
40479>>>>>            End
40479>>>>>>
40479>>>>>        End
40479>>>>>>
40479>>>>>
40479>>>>>        Close hTable
40480>>>>>
40480>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
40480>>>>>        // If not set we do nothing.
40480>>>>>        If (nCurrentValue < nVersion) Begin
40482>>>>>
40482>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
40482>>>>>            // execution of database update code. So if true _and_ one error
40482>>>>>            // has already occured; we're out of here.
40482>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
40484>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
40486>>>>>            If (bStopOnFirstError = True) Begin
40488>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
40490>>>>>                    Procedure_Return
40491>>>>>                End
40491>>>>>>
40491>>>>>            End
40491>>>>>>
40491>>>>>
40491>>>>>            // This is send to the parent container object (cDbUpdateHandler)
40491>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
40493>>>>>
40493>>>>>            // If the parent property pbContinueOnError = False, an update
40493>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
40493>>>>>            Delegate Get pbContinueOnError to bContinueOnError
40495>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
40497>>>>>                Procedure_Return
40498>>>>>            End
40498>>>>>>
40498>>>>>
40498>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
40500>>>>>
40500>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
40501>>>>>
40501>>>>>            // *** Programmer's main hook event for database update functions:
40501>>>>>            Send OnUpdate
40502>>>>>
40502>>>>>            Set pbVersionUpdate to True
40503>>>>>            Send UpdateVersionColumnValue
40504>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
40506>>>>>        End
40506>>>>>>
40506>>>>>
40506>>>>>    End_Procedure
40507>>>>>
40507>>>>>End_Class
40508>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
40508>>>>>//****************************************************************************
40508>>>>>// $Module type: Class
40508>>>>>// $Module name: cDbUpdateUserCount.pkg
40508>>>>>// $Author     : Emil Stojanov Quantaris B.V.
40508>>>>>//
40508>>>>>//               Collected from DAW's newsgroups.
40508>>>>>//
40508>>>>>// Description : It uses the windows API to lock bytes in a file.
40508>>>>>//               If the application or PC craches it will release the lock
40508>>>>>//               automatically.
40508>>>>>//
40508>>>>>// Note 1      : It will count the number of running app's, so if a
40508>>>>>//               user starts the app twice on one machine it will count as two users.
40508>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
40508>>>>>//               However, to not conflict with any other usage of this class it was
40508>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
40508>>>>>//               and cDbUpdateVersion classes)
40508>>>>>//
40508>>>>>// $Rev History:
40508>>>>>//    2008-10-17  Module header created (Militaty data format)
40508>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
40508>>>>>//                for easy translation to other languages.
40508>>>>>//                Added the tUserCount struct for easier passing of parameters.
40508>>>>>//                Added the ApplicationPath message.
40508>>>>>//****************************************************************************
40508>>>>>Use LanguageText.pkg
40508>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
40508>>>>>>>Use GlobalFunctionsProcedures.pkg
40508>>>>>>>// Sample:
40508>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
40508>>>>>>>
40508>>>>>>>
40508>>>>>>>// Symbols used by UserCounting
40508>>>>>>>    Define GENERIC_READ         for |CI$80000000
40508>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
40508>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
40508>>>>>>>    Define GENERIC_ALL          for |CI$10000000
40508>>>>>>>    Define CREATE_NEW           for 1
40508>>>>>>>    Define CREATE_ALWAYS        for 2
40508>>>>>>>    Define OPEN_EXISTING        for 3
40508>>>>>>>    Define OPEN_ALWAYS          for 4
40508>>>>>>>    Define TRUNCATE_EXISTING    for 5
40508>>>>>>>    Define FILE_BEGIN           for 0
40508>>>>>>>    Define FILE_CURRENT         for 1
40508>>>>>>>    Define FILE_END             for 2
40508>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
40508>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
40508>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
40508>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
40508>>>>>>>    Define _MAX_PATH  for 260
40508>>>>>>>    Define _MAX_DRIVE for 3
40508>>>>>>>    Define _MAX_DIR   for 256
40508>>>>>>>    Define _MAX_FNAME for 256
40508>>>>>>>    Define _MAX_EXT   for 256
40508>>>>>>>
40508>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
40509>>>>>>>
40509>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
40510>>>>>>>
40510>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
40511>>>>>>>
40511>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
40512>>>>>>>
40512>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
40513>>>>>>>
40513>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
40514>>>>>>>
40514>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
40515>>>>>>>
40515>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
40516>>>>>>>// Sample:
40516>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
40516>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
40518>>>>>>>    Boolean bReturn
40518>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
40519>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
40520>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
40521>>>>>>>    Function_Return bReturn
40522>>>>>>>End_Function
40523>>>>>Use vWin32fh.pkg
40523>>>>>Use seq_chnl.pkg
40523>>>>>
40523>>>>>// User interface constant strings:
40523>>>>>    Define CS_UserCountError            for "User count error:"
40523>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
40523>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
40523>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
40523>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>
40523>>>>>    Struct tUserCount
40523>>>>>        Integer iUserCount
40523>>>>>        Integer iError
40523>>>>>        String  sErrorTxt
40523>>>>>    End_Struct
40523>>>>>
40523>>>>>    Define CI_UserCountMaxUsers for 9999
40523>>>>>
40523>>>>>Class cDbUpdateUserCount is a cObject
40524>>>>>    Procedure Construct_Object
40526>>>>>        Forward Send Construct_Object
40528>>>>>
40528>>>>>        Property String  psLockFileName
40529>>>>>        Property Integer piMaxUsers
40530>>>>>        Property Boolean pbCheckDataFlexUserCount True
40531>>>>>
40531>>>>>        Property Handle  phUserCountFile
40532>>>>>        Property Integer pdwLockPosition
40533>>>>>    End_Procedure
40534>>>>>
40534>>>>>    Function IsProgramRunning Returns Boolean
40536>>>>>        tUserCount UserCount
40536>>>>>        tUserCount UserCount
40536>>>>>
40536>>>>>        Get CheckUserCount to UserCount
40537>>>>>
40537>>>>>        Function_Return (UserCount.iUserCount > 1)
40538>>>>>    End_Function
40539>>>>>
40539>>>>>    // Returns the full path of the Application (no trailing "\")
40539>>>>>    Function ApplicationPath Returns String
40541>>>>>        String sApplicationFileName sPath
40541>>>>>        Integer iNumChars iRetval
40541>>>>>
40541>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
40542>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
40543>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
40544>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
40545>>>>>        Move (CString(sApplicationFileName)) to sPath
40546>>>>>
40546>>>>>        Function_Return sPath
40547>>>>>    End_Function
40548>>>>>
40548>>>>>    Function OpenUserCountFile String sFileName Returns Handle
40550>>>>>        Handle  hFile
40550>>>>>        Pointer pFileName
40550>>>>>        String sPath sFile
40550>>>>>        Integer iCh
40550>>>>>
40550>>>>>        Move (Addressof(sFileName)) to pFileName
40551>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
40552>>>>>
40552>>>>>        // If lock file doesn't exist, create it.
40552>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
40554>>>>>            Get ApplicationPath to sPath
40555>>>>>            Get vFolderFormat sPath to sPath
40556>>>>>            Move (sPath + psLockFileName(Self)) to sFile
40557>>>>>            Get Seq_Open_Output_Channel sFile to iCh
40558>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
40560>>>>>                Function_Return 0
40561>>>>>            End
40561>>>>>>
40561>>>>>            Direct_Output channel iCh sFile
40563>>>>>                Write channel iCh ""
40565>>>>>            Send Seq_Close_Channel iCh
40566>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
40567>>>>>        End
40567>>>>>>
40567>>>>>
40567>>>>>        Function_Return hFile
40568>>>>>    End_Function
40569>>>>>
40569>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
40571>>>>>        Integer iReturnValue 
40571>>>>>        Boolean bOK
40571>>>>>
40571>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
40572>>>>>        If (iReturnValue = 0) Begin
40574>>>>>            Move False to bOK
40575>>>>>        End
40575>>>>>>
40575>>>>>        Else Begin
40576>>>>>            Move True to bOK
40577>>>>>        End
40577>>>>>>
40577>>>>>        Function_Return bOK
40578>>>>>    End_Function
40579>>>>>
40579>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
40581>>>>>        Integer iReturnValue
40581>>>>>        Boolean bOK
40581>>>>>
40581>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
40582>>>>>        If (iReturnValue = 0) Begin
40584>>>>>            Move False to bOK
40585>>>>>        End
40585>>>>>>
40585>>>>>        Else Begin
40586>>>>>            Move True to bOK
40587>>>>>        End           
40587>>>>>>
40587>>>>>        Function_Return bOK
40588>>>>>    End_Function
40589>>>>>
40589>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
40591>>>>>        dWord dwCurrPos
40591>>>>>
40591>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
40592>>>>>        Function_Return dwCurrPos
40593>>>>>    End_Function
40594>>>>>
40594>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
40596>>>>>        DWord dwCurrPos
40596>>>>>
40596>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
40597>>>>>        Function_Return dwCurrPos
40598>>>>>    End_Function
40599>>>>>
40599>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
40601>>>>>        Integer iReturnValue                               
40601>>>>>        Boolean bOK
40601>>>>>        String  sBuffer
40601>>>>>        Pointer pBuffer
40601>>>>>        String  sSize
40601>>>>>        Pointer pSize
40601>>>>>
40601>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
40602>>>>>        Move (AddressOf(sBuffer)) to pBuffer
40603>>>>>
40603>>>>>        Move (Repeat((Character(0)),4)) to sSize
40604>>>>>        Move (AddressOf(sSize)) to pSize
40605>>>>>
40605>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
40606>>>>>        If (iReturnValue = 0) Begin
40608>>>>>            Move False to bOK
40609>>>>>        End
40609>>>>>>
40609>>>>>        Else Begin
40610>>>>>            Move True to bOK
40611>>>>>        End                 
40611>>>>>>
40611>>>>>        Function_Return bOK
40612>>>>>    End_Function
40613>>>>>
40613>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
40615>>>>>        Integer iReturnValue
40615>>>>>
40615>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
40616>>>>>        Function_Return iReturnValue
40617>>>>>    End_Function
40618>>>>>
40618>>>>>    Procedure DoCheckUserCount
40620>>>>>        tUserCount UserCount
40620>>>>>        tUserCount UserCount
40620>>>>>
40620>>>>>        Get CheckUserCount to UserCount
40621>>>>>        // If all is fine, we're done.
40621>>>>>        If (UserCount.iError = 0) Begin
40623>>>>>            Procedure_Return
40624>>>>>        End
40624>>>>>>
40624>>>>>
40624>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
40625>>>>>
40625>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
40627>>>>>            Abort
40628>>>>>>
40628>>>>>        End
40628>>>>>>
40628>>>>>    End_Procedure
40629>>>>>
40629>>>>>    Function CheckUserCount Returns tUserCount
40631>>>>>        Handle  hFile
40631>>>>>        String  sPath sFile
40631>>>>>        Integer iResult
40631>>>>>        DWord   dwFilePos
40631>>>>>        Integer bLocked
40631>>>>>        Integer iMaxUsers
40631>>>>>        Integer iCurUser
40631>>>>>        tUserCount UserCount
40631>>>>>        tUserCount UserCount
40631>>>>>
40631>>>>>        Move 0 to UserCount.iError
40632>>>>>
40632>>>>>        Get phUserCountFile to hFile
40633>>>>>        If (not(hFile)) Begin
40635>>>>>            Get ApplicationPath to sPath
40636>>>>>            Get vFolderFormat sPath to sPath
40637>>>>>            Move (sPath + psLockFileName(Self)) to sFile
40638>>>>>            Get OpenUserCountFile sFile to hFile
40639>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
40641>>>>>                Move 1 to UserCount.iUserCount
40642>>>>>                Move 1 to UserCount.iError
40643>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
40644>>>>>                Function_Return UserCount
40645>>>>>            End
40645>>>>>>
40645>>>>>            Else Begin
40646>>>>>                Move False to bLocked
40647>>>>>                Set phUserCountFile to hFile
40648>>>>>                Get piMaxUsers to iMaxUsers
40649>>>>>
40649>>>>>                // Set Filepointer to beginning of the file
40649>>>>>                Get ResetUserCountPointer hFile to dwFilePos
40650>>>>>                If (dwFilePos = -1) Begin
40652>>>>>                    Move 1 to UserCount.iUserCount
40653>>>>>                    Move 2 to UserCount.iError
40654>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
40655>>>>>                    Function_Return UserCount
40656>>>>>                End
40656>>>>>>
40656>>>>>                For iCurUser from 1 to iMaxUsers
40662>>>>>>
40662>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
40663>>>>>                    If (not(iResult)) Begin  // byte is locked
40665>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
40666>>>>>                        If (dwFilePos = -1) Begin
40668>>>>>                            Move 1 to UserCount.iUserCount
40669>>>>>                            Move 3 to UserCount.iError
40670>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
40671>>>>>                            Function_Return UserCount
40672>>>>>                        End
40672>>>>>>
40672>>>>>                    End
40672>>>>>>
40672>>>>>                    Else Begin  // byte is not locked
40673>>>>>                        Set pdwLockPosition to dwFilePos
40674>>>>>                        Move True to bLocked
40675>>>>>                        Move iMaxUsers to iCurUser
40676>>>>>                    End
40676>>>>>>
40676>>>>>                Loop
40677>>>>>>
40677>>>>>                If (not(bLocked)) Begin
40679>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
40680>>>>>                    Move 4 to UserCount.iError
40681>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
40682>>>>>                    Function_Return UserCount
40683>>>>>                End
40683>>>>>>
40683>>>>>            End
40683>>>>>>
40683>>>>>        End
40683>>>>>>
40683>>>>>
40683>>>>>        Function_Return UserCount
40684>>>>>    End_Function
40685>>>>>
40685>>>>>
40685>>>>>    Procedure DoReleaseUserCount
40687>>>>>        Integer iResult
40687>>>>>        Handle  hFile
40687>>>>>        DWord   dwLockPos
40687>>>>>
40687>>>>>        Get phUserCountFile to hFile
40688>>>>>        Get pdwLockPosition to dwLockPos
40689>>>>>        If (hFile) Begin
40691>>>>>            If (dwLockPos) Begin
40693>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
40694>>>>>            End
40694>>>>>>
40694>>>>>            Get CloseUserCountFile hFile to iResult
40695>>>>>        End
40695>>>>>>
40695>>>>>    End_Procedure
40696>>>>>
40696>>>>>    Function CurrentNumberOfUsers Returns Integer
40698>>>>>        Handle  hFile
40698>>>>>        Integer iMaxUsers
40698>>>>>        DWord   dwFilePos
40698>>>>>        Integer iCurUser
40698>>>>>        Integer iResult
40698>>>>>        Integer iNumberOfLocks
40698>>>>>        String  sPath sFile
40698>>>>>
40698>>>>>        Move 0 to iNumberOfLocks
40699>>>>>
40699>>>>>        Get ApplicationPath to sPath
40700>>>>>        Get vFolderFormat sPath to sPath
40701>>>>>        Move (sPath + psLockFileName(Self)) to sFile
40702>>>>>        Get OpenUserCountFile sFile to hFile
40703>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
40705>>>>>            Send UserError CS_UnableToInitUserCountSys
40706>>>>>            Abort
40707>>>>>>
40707>>>>>        End
40707>>>>>>
40707>>>>>
40707>>>>>        If (hFile > 0) Begin
40709>>>>>            Get piMaxUsers To iMaxUsers
40710>>>>>
40710>>>>>            // Set Filepointer to beginning of the file
40710>>>>>            Get ResetUserCountPointer hFile to dwFilePos
40711>>>>>            If (dwFilePos = -1) Begin
40713>>>>>                Send UserError CS_UnableResetUserCountSys
40714>>>>>                Abort
40715>>>>>>
40715>>>>>            End
40715>>>>>>
40715>>>>>            For iCurUser from 1 to iMaxUsers
40721>>>>>>
40721>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
40722>>>>>                If (Not(iResult)) Begin  // byte is locked
40724>>>>>                    Increment iNumberOfLocks
40725>>>>>                End
40725>>>>>>
40725>>>>>                Else Begin  // byte is not locked
40726>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
40727>>>>>                End
40727>>>>>>
40727>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
40728>>>>>                If (dwFilePos = -1) Begin
40730>>>>>                    Send UserError CS_ErrorAdvancingPointer
40731>>>>>                    Abort
40732>>>>>>
40732>>>>>                End
40732>>>>>>
40732>>>>>            Loop
40733>>>>>>
40733>>>>>        End
40733>>>>>>
40733>>>>>        Get CloseUserCountFile hFile to iResult
40734>>>>>        Function_Return iNumberOfLocks
40735>>>>>    End_Function
40736>>>>>
40736>>>>>End_Class
40737>>>Use cDbUpdateFunctionLibrary.pkg
40737>>>
40737>>>//{ DataBindable=True }
40737>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
40737>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary // cObject
40738>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary
40738>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
40738>>>
40738>>>    Procedure Construct_Object
40740>>>        tUserCount UserCount
40740>>>        tUserCount UserCount
40740>>>        Integer iUserCount
40740>>>        Handle ho                     
40740>>>
40740>>>        Forward Send Construct_Object
40742>>>        Move Self to ghoDbUpdateHandler  
40743>>>        
40743>>>        // Latin1_General_CI_AS = General Insensitive collation
40743>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
40743>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
40743>>>        // Good read about which collation to select:
40743>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
40743>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
40744>>>
40744>>>        // Struct array that will contain pnVersionNumbers & object id's of
40744>>>        // all child cDbVersion objects.
40744>>>        Property tDbVersionInfo[] paDbVersionInfoArray
40745>>>
40745>>>        Property Integer Error_Processing_State False  // internal usage
40746>>>        
40746>>>        Property Boolean Private.pbDbVersionCheckDone False
40747>>>
40747>>>        Property Boolean pbUseCustomDbVersion False  
40748>>>        
40748>>>        // If this property = True _and_ no DbVersion table exists 
40748>>>        // when the framework is started, a DbVersion table will be created automatically.
40748>>>        Property Boolean pbAutoCreateDbVersionTable True
40749>>>
40749>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
40749>>>        // the Filelist.cfg slot number indicated by this property will be used
40749>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
40749>>>        // an Unhandled Exception Error will be genereted and the program halted. So
40749>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
40749>>>        // to a value that corresponds to a free Filelist.cfg slot number.
40749>>>        Property Integer Private.piDbVersionFileNumber -1
40750>>>        Property Integer Private.piDbVersionFieldNumber 1
40751>>>
40751>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
40751>>>        // that creates all library properties
40751>>>        Send CreateDbUpdateLibraryProperties
40752>>>
40752>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
40753>>>
40753>>>        // Error handling:
40753>>>        Property Boolean Private.pbOnCreateExecuted False
40754>>>        Property Boolean Private.pbOnPreUpdateExecuted False
40755>>>        Property Boolean Private.pbProcessingError False
40756>>>        Property Boolean pbDbUpdateErrorHasOccured False
40757>>>        // Don't touch. It is being used by the cDbUpdateVersion
40757>>>        // subclass to tell if that particular update went OK or not.
40757>>>        Property Boolean Private.pbUpdateVersionObjectError False
40758>>>        Property String[] paSQLQueryMessages
40759>>>
40759>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
40760>>>        Move Self to Error_Object_Id
40761>>>        // Error handling:
40761>>>        // Temporarily redirect all errors to this object so we can silently
40761>>>        // log all errors that might appear while updating the database.
40761>>>        // We temporarily redirect all errors to this object so we can
40761>>>        // log and write errors to the log file. It will be reset after
40761>>>        // the database updates have been finished.
40761>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
40762>>>
40762>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
40763>>>
40763>>>        // Error Reporting Related
40763>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
40763>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
40764>>>
40764>>>        // If the pbContinueOnError = False, an update
40764>>>        // of another cDbUpdateVersion object will _not_ be
40764>>>        // performed if an error occured in a previous
40764>>>        // cDbUpdateVersion object.
40764>>>        Property Boolean pbContinueOnError False
40765>>>        // Stops execution in other cDbUpdateVersion objecs,
40765>>>        // if errors occurred in one cDbUpdateVersion object.
40765>>>        Property Boolean pbStopOnFirstError False
40766>>>        // If True errors that occured while updating the database
40766>>>        // will be shown in the default app for .txt files when done.
40766>>>        // Note: The log file will _always_ be created in the Data folder.
40766>>>        Property Boolean pbShowErrorLogPostRun True
40767>>>
40767>>>        // Be _very_ careful to set this property to true!
40767>>>        // If = True, no question will be asked if the update
40767>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
40767>>>        // the error log won't be shown. The logfile itself will still be created though.
40767>>>        // You have to know what you're doing!
40767>>>        Property Boolean pbSilentMode False
40768>>>        
40768>>>        Property Boolean pbEnableCancelButton False
40769>>>
40769>>>        // Don't touch! Very private. The value is used by the error log to write for which
40769>>>        // cDbUpdateVersion object an error occured.
40769>>>        Property Number pnCurrentVersionUpdate 0
40770>>>
40770>>>        // The user counting logic is used to safe-guard agains anybody else is
40770>>>        // using the application when a database update is to be performed.
40770>>>        // (Garters & suspenders!)
40770>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
40771>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
40772>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
40773>>>
40773>>>        // This lock file is used to guard against somebody else tries to start the
40773>>>        // application while updates are in progress.
40773>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
40774>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
40775>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
40776>>>                                                                                      // Only the current user allowed.
40776>>>        // Properties for the table & column of a system file field/column where
40776>>>        // the database version update number gets saved.
40776>>>        Property Integer Private.Data_File  0
40777>>>        Property Integer Private.Data_Field 0
40778>>>
40778>>>        // Property that is used to indicate that we have already
40778>>>        // started the database update.
40778>>>        Property Boolean Private.pbDatabaseUpdateStarted False
40779>>>
40779>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
40779>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
40779>>>        // change of the database has been made.
40779>>>        Property Boolean Private.pbDatabaseWasUpdated False
40780>>>
40780>>>        // We need to trigger the user counting system so that a bit in the
40780>>>        // user counting file is locked. This is to guard that not more than one user
40780>>>        // is currently runnning the program.
40780>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
40781>>>
40781>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
40782>>>        If (iUserCount > 0) Begin
40784>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
40785>>>            Send Exit_Application
40786>>>        End
40786>>>>
40786>>>
40786>>>        Set pbHandleQueryErrors to False
40787>>>            
40787>>>        Property Handle phoSQLConnectionHandler 0
40788>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
40788>>>        // we will create one as it is used for all ConnectionID, ConnectionString
40788>>>        // etc information.
40788>>>        If (ghoSQLConnectionHandler = 0) Begin
40790>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
40791>>>            Set phoSQLConnectionHandler to ho
40792>>>        End             
40792>>>>
40792>>>        
40792>>>        Property Boolean pbCheckIntFiles False   
40793>>>        Property Handle  phIntFilesTable 2048
40794>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
40795>>>        
40795>>>        Set Icon to "Default.ico"
40796>>>    End_Procedure
40797>>>
40797>>>    Procedure End_Construct_Object
40799>>>        Boolean bCheckIntFiles
40799>>>        
40799>>>        Forward Send End_Construct_Object
40801>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
40803>>>            Send OnCreate
40804>>>            Set Private.pbOnCreateExecuted to True
40805>>>        End
40805>>>>
40805>>>        Send Cleanup
40806>>>    End_Procedure
40807>>>    
40807>>>    // Programmers hook event.
40807>>>    Procedure OnCreate
40809>>>    End_Procedure        
40810>>>                                 
40810>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
40810>>>    //                                                
40810>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
40810>>>    // cDbUpdateHandler object.
40810>>>    //
40810>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
40810>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
40810>>>    //
40810>>>    // If not done previously the phIntFilesTable will be created and filled with data
40810>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
40810>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
40810>>>    // of Filelist.cfg is made for backup purposes.
40810>>>    //
40810>>>    // Note: If an error occurrs the application will exit, as it means that at least one
40810>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
40810>>>    Procedure CheckIntFilesIntegrity
40812>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
40812>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
40812>>>        String sFileListZipFile sParam sProgram sFile 
40812>>>        Integer iDataPaths iCount
40812>>>        Handle hTable hIntFilesTable                    
40812>>>        UChar[] asFileListArray 
40813>>>        String[] asSavedIntFile
40814>>>        tDUFIntFile[] DUFIntFiles
40814>>>        tDUFIntFile[] DUFIntFiles
40815>>>        
40815>>>        Get pbCheckIntFiles to bCheckIntFiles
40816>>>        If (bCheckIntFiles = False) Begin
40818>>>            Procedure_Return
40819>>>        End
40819>>>>
40819>>>        
40819>>>        Move True to bResult        
40820>>>        
40820>>>        // Note: Include_Resource is a compiler directive!
40820>>>        // It will embedd the Filelist.cfg from the developers machine
40820>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
40820>>>        // need to change the next code line.         
40820>>>        //
40820>>>        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
40820>>>        // when we get here and then the compiler can't embedd it!        
40820>>>        // ToDo: Change compiler directives in Project properties (?)
40820>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
40820>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
40820>>>        
40820>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
40821>>>        Get vFilePathExists sFileListName to bExists 
40822>>>        If (bExists = True) Begin
40824>>>            Get ParseFolderName sFileListName to sDataPath    
40825>>>            Get vFolderFormat sDataPath to sDataPath                              
40826>>>            Get ParseFileName sFileListName to sFile
40827>>>            // We need to create a backup copy of Filelist.cfg.
40827>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
40828>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
40829>>>            If (bOK = False) Begin
40831>>>                Move False to bResult
40832>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
40833>>>>
40833>>>            End
40833>>>>
40833>>>        End
40833>>>>
40833>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
40833>>>        Else Begin
40834>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
40835>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
40835>>>            If (bOK = False) Begin   
40837>>>                Move False to bResult
40838>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
40839>>>>
40839>>>            End
40839>>>>
40839>>>        End
40839>>>>
40839>>>        
40839>>>        Get phIntFilesTable to hIntFilesTable
40840>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
40843>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
40844>>>        // This will automatically create the phIntFilesTable if not exists.
40844>>>        // It is used to save data from the current set of .int files.
40844>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
40846>>>            Send AutoCreateIntFilesTable
40847>>>            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
40848>>>            If (bIntFilesTablesCheckDone = False) Begin
40850>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
40851>>>                Send Exit_Application of ghoApplication
40852>>>            End
40852>>>>
40852>>>        End                                                       
40852>>>>
40852>>>        
40852>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
40852>>>        // ToDo: Or should this always be attempted? Else the 
40852>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
40853>>>        Move (IsDebuggerPresent()) to bDevelop
40854>>>        If (bDevelop = False) Begin
40856>>>            Get vFolderExists sDDSrcPath to bDevelop
40857>>>        End
40857>>>>
40857>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
40858>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
40859>>>        For iCount from 1 to iDataPaths
40865>>>>
40865>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
40866>>>            Get vFolderFormat sDataPath to sDataPath 
40867>>>            Get vFolderExists sDataPath to bExists
40868>>>            If (bExists = True) Begin                  
40870>>>                Move 0 to hTable
40871>>>                Repeat
40871>>>>
40871>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
40874>>>                    If (hTable <> 0) Begin
40876>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
40879>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
40880>>>                        If (bIsSQL = True) Begin     
40882>>>                            Get _TableNameOnly sIntFileName to sIntFileName
40883>>>                            Move (sIntFileName + ".int")    to sIntFileName
40884>>>                            Get IsIntFileSaved sIntFileName to bSaved  
40885>>>                            Move True to bOK            
40886>>>                            
40886>>>                            // Save .int file to database if not done previously.
40886>>>                            // We only attempt to read .int files on a development machine.
40886>>>                            If (bDevelop = True) Begin
40888>>>                                If (bSaved = False) Begin
40890>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
40891>>>                                    If (bOK = False) Begin
40893>>>                                        Move False to bResult    
40894>>>                                    End
40894>>>>
40894>>>                                End         
40894>>>>
40894>>>                                If (bOK = True) Begin
40896>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
40897>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
40899>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
40900>>>                                        If (bOK = False) Begin
40902>>>                                            Move False to bResult
40903>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
40904>>>>
40904>>>                                        End
40904>>>>
40904>>>                                    End
40904>>>>
40904>>>                                End
40904>>>>
40904>>>                            End
40904>>>>
40904>>>                            
40904>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
40905>>>                            If (bExists = False) Begin                           
40907>>>                                // If the .int file is missing on disk; create it from database.
40907>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
40908>>>                                If (bOK = False) Begin         
40910>>>                                    Move False to bResult
40911>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
40912>>>>
40912>>>                                End
40912>>>>
40912>>>                            End
40912>>>>
40912>>>                        End
40912>>>>
40912>>>                    End
40912>>>>
40912>>>                Until (hTable = 0)
40914>>>            End
40914>>>>
40914>>>        Loop       
40915>>>>
40915>>>        
40915>>>        // If an error occured we need to exit the application.
40915>>>        If (bResult = False) Begin  
40917>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
40918>>>            Send Exit_Application
40919>>>        End
40919>>>>
40919>>>        
40919>>>    End_Procedure               
40920>>>
40920>>>    // To update currently saved IntFile data to the database.
40920>>>    // Because it is much easier, we first delete all current records and
40920>>>    // then saves the changed .int file to the database.
40920>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
40922>>>        Boolean bOK
40922>>>        
40922>>>        Move False to bOK
40923>>>
40923>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
40924>>>        If (bOK = True) Begin
40926>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
40927>>>        End
40927>>>>
40927>>>        
40927>>>        Function_Return bOK
40928>>>    End_Function
40929>>>    
40929>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
40931>>>        Handle hTable
40931>>>        Boolean bOK
40931>>>        Integer iColumn iIndex   
40931>>>        String sFileName
40931>>>        
40931>>>        Move False to bOK
40932>>>        Get phIntFilesTable to hTable
40933>>>        Move 2              to iColumn // This is the "InfFileName" field no.
40934>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
40935>>>
40935>>>        Open hTable
40937>>>        Set_Field_Value hTable iColumn to sIntFileName
40940>>>        Vfind hTable iIndex GE
40942>>>        Get_Field_Value hTable iColumn to sFileName
40945>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
40947>>>            Move True to bOK    
40948>>>        End
40948>>>>
40948>>>        Close hTable
40949>>>        
40949>>>        Function_Return bOK       
40950>>>    End_Function   
40951>>>    
40951>>>    // Checks that the passed .int file is the same as what is saved in the database.
40951>>>    // If not same, the return string array will contain the read .int file,
40951>>>    // else the returned array will be empty.
40951>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
40953>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
40957>>>        Boolean bIsSame
40957>>>        
40957>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
40958>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
40959>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
40960>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
40961>>>        
40961>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
40962>>>        If (bIsSame = False) Begin
40964>>>            Move asIntFileOrg to asReturnIntFile    
40965>>>        End
40965>>>>
40965>>>        
40965>>>        Function_Return asReturnIntFile    
40966>>>    End_Function                                   
40967>>>    
40967>>>    // Takes a string array as parameter and returns a new
40967>>>    // string array without any empty rows and all rows trimmed.
40967>>>    // This is e.g. used by the HasIntFileChanged message to compare
40967>>>    // two .int file arrays. 
40967>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
40969>>>        Integer iSize iCount iRow
40969>>>        String sVal        
40969>>>        String[] asRetValArray
40970>>>        
40970>>>        Move (SizeOfArray(asIntFile)) to iSize
40971>>>        If (iSize = 0) Begin
40973>>>            Function_Return asRetValArray
40974>>>        End                          
40974>>>>
40974>>>        Decrement iSize         
40975>>>        Move 0 to iRow
40976>>>        
40976>>>        For iCount from 0  to iSize
40982>>>>
40982>>>            Move asIntFile[iCount] to sVal
40983>>>            Move (Trim(sVal)) to sVal
40984>>>            If (sVal <> "") Begin
40986>>>                Move sVal to asRetValArray[iRow]
40987>>>                Increment iRow        
40988>>>            End
40988>>>>
40988>>>        Loop
40989>>>>
40989>>>        
40989>>>        Function_Return asRetValArray
40990>>>    End_Function
40991>>>    
40991>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
40993>>>        Handle hTable
40993>>>        Boolean bOK bErr
40993>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
40993>>>        Number iID
40993>>>        String sFileName
40993>>>        String[] asIntFile
40994>>>        
40994>>>        Move Err to bErr
40995>>>        Move False to Err
40996>>>        Move False to bOK
40997>>>        Get phIntFilesTable to hTable  
40998>>>        Move 1              to iIDCol
40999>>>        Move 2              to iFileCol
41000>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
41001>>>        Move 1              to iIDIdx   // Main ID index.
41002>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
41003>>>
41003>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
41004>>>        Move (SizeOfArray(asIntFile)) to iSize
41005>>>        If (iSize = 0) Begin
41007>>>            Function_Return False
41008>>>        End
41008>>>>
41008>>>        Decrement iSize
41009>>>        Open hTable  
41011>>>                  
41011>>>        // Find the last used ID no:
41011>>>        Fill_Field hTable iIDCol with DF_HIGH
41013>>>        Vfind hTable iIDIdx LE
41015>>>        Get_Field_Value hTable iIDCol to iID 
41018>>>        // This only happens the very first time we save a record.
41018>>>        If (iID = 999999999999) Begin
41020>>>            Move 0 to iID
41021>>>        End
41021>>>>
41021>>>        Increment iID        
41022>>>        
41022>>>        Lock
41023>>>>
41023>>>            For iCount from 0 to iSize
41029>>>>
41029>>>                Clear hTable
41030>>>                Set_Field_Value hTable iIDCol   to iID     
41033>>>                Set_Field_Value hTable iFileCol to sIntFileName
41036>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
41039>>>                SaveRecord hTable
41040>>>                Increment iID
41041>>>            Loop
41042>>>>
41042>>>        Unlock
41043>>>>
41043>>>        Close hTable
41044>>>        
41044>>>        Move (not(Err)) to bOK
41045>>>        Move bErr to Err
41046>>>        
41046>>>        Function_Return bOK
41047>>>    End_Function
41048>>>    
41048>>>    // Deletes all records for the passed sIntFileName value,
41048>>>    // from the phIntFilesTable.
41048>>>    // Returns True if no errors occured.
41048>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
41050>>>        Handle hTable
41050>>>        Boolean bOK bErr bFound
41050>>>        Integer iFileCol iIndex
41050>>>        String sVal
41050>>>        String[] asIntFile
41051>>>        
41051>>>        Move Err to bErr
41052>>>        Move False to Err
41053>>>        Move False to bOK
41054>>>        Move 2              to iFileCol
41055>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
41056>>>        Get phIntFilesTable to hTable  
41057>>>        Open hTable  
41059>>>                  
41059>>>        // Find the first record
41059>>>        Set_Field_Value hTable iFileCol to sIntFileName
41062>>>        Vfind hTable iIndex GE
41064>>>        Get_Field_Value hTable iFileCol to sVal
41067>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
41068>>>        While (bFound = True)
41072>>>            Delete hTable
41073>>>            Vfind hTable iIndex GT
41075>>>            Get_Field_Value hTable iFileCol to sVal
41078>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
41079>>>        Loop
41080>>>>
41080>>>        Unlock
41081>>>>
41081>>>        Close hTable
41082>>>        
41082>>>        Move (not(Err)) to bOK
41083>>>        Move bErr to Err
41084>>>        
41084>>>        Function_Return bOK
41085>>>    End_Function
41086>>>
41086>>>    // Returns all saved phIntFilesTable records for the passed 
41086>>>    // sIntFileName value as a string array.
41086>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
41088>>>        Handle hTable
41088>>>        Boolean bOK bErr bFound
41088>>>        Integer iFileCol iTextCol iIndex
41088>>>        String sVal sFileName
41088>>>        String[] asIntFile asEmptyArray
41090>>>        
41090>>>        Move Err to bErr
41091>>>        Move False to Err
41092>>>        Move False to bOK
41093>>>        Move 2              to iFileCol
41094>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
41095>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
41096>>>        Get phIntFilesTable to hTable  
41097>>>        Open hTable  
41099>>>
41099>>>        // Find the first record
41099>>>        Set_Field_Value hTable iFileCol to sIntFileName
41102>>>        Vfind hTable iIndex GE
41104>>>        Get_Field_Value hTable iFileCol to sFileName
41107>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
41108>>>        While (bFound = True)
41112>>>            Get_Field_Value hTable iFileCol to sFileName
41115>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
41116>>>            If (bFound = True) Begin
41118>>>                Get_Field_Value hTable iTextCol to sVal
41121>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
41122>>>            End
41122>>>>
41122>>>            Vfind hTable iIndex GT
41124>>>        Loop
41125>>>>
41125>>>        
41125>>>        Close hTable
41126>>>        Move (not(Err)) to bOK
41127>>>        If (bOK = False) Begin
41129>>>            Move asEmptyArray to asIntFile
41130>>>        End
41130>>>>
41130>>>        Move bErr to Err               
41131>>>        
41131>>>        Function_Return asIntFile
41132>>>    End_Function
41133>>>
41133>>>    // Reads the passed sIntFileName from disk and returns its value
41133>>>    // as a string array.
41133>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
41135>>>        String[] asIntFile       
41136>>>        String sFileName sLine
41136>>>        Integer iCh iSize iCount
41136>>>        
41136>>>        Get vFolderFormat sPath to sPath
41137>>>        If (not(sIntFileName contains ".")) Begin
41139>>>            Move (sIntFileName + ".int") to sIntFileName
41140>>>        End
41140>>>>
41140>>>        Move (sPath + sIntFileName) to sFileName
41141>>>        Get Seq_Open_input_Channel sFileName to iCh
41142>>>        If (iCh < 0) Begin
41144>>>            Function_Return asIntFile
41145>>>        End                                 
41145>>>>
41145>>>        
41145>>>        Repeat
41145>>>>
41145>>>            Readln channel iCh sLine
41147>>>            If (SeqEof = False) Begin
41149>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
41150>>>            End
41150>>>>
41150>>>        Until (SeqEof = True)
41152>>>        Send Seq_Close_Channel iCh    
41153>>>        
41153>>>        Function_Return asIntFile
41154>>>    End_Function
41155>>>    
41155>>>    // Reads the Filelist.cfg from memeory as a resource.
41155>>>    // The Filelist.cfg has been compiled into the program.
41155>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
41157>>>        Integer iCh iCount
41157>>>        Number nByteCount
41157>>>        String[] asFileListArray sEmptyArray
41159>>>        String sLine
41159>>>        UChar[] uCharData
41160>>>        
41160>>>        Move False to Err
41161>>>        Get Seq_New_Channel to iCh
41162>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
41164>>>            Error DFERR_PROGRAM 'No channel available...'
41165>>>>
41165>>>            Function_Return sEmptyArray
41166>>>        End
41166>>>>
41166>>>
41166>>>        // First decide the size of the script
41166>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
41168>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
41170>>>        Close_Input channel iCh
41172>>>        Send Seq_Release_Channel iCh
41173>>>
41173>>>        Function_Return uCharData
41174>>>    End_Function    
41175>>>    
41175>>>    // Writes a copy of the workspace Filelist.cfg to disk.
41175>>>    // It does so by reading from a memory resource, as the file has
41175>>>    // been compiled into the program.
41175>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
41177>>>        Boolean bOK bErr
41177>>>        Integer iSize iCh
41177>>>        
41177>>>        Move Err to bErr
41178>>>        Move False to Err
41179>>>        Move False to bOK
41180>>>        Move (SizeOfArray(asFileListArray)) to iSize
41181>>>        If (iSize = 0) Begin
41183>>>            Function_Return False
41184>>>        End
41184>>>>
41184>>>
41184>>>        Get Seq_New_Channel to iCh
41185>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
41187>>>            Error DFERR_PROGRAM 'No channel available...'
41188>>>>
41188>>>            Function_Return False
41189>>>        End                      
41189>>>>
41189>>>        
41189>>>        Direct_Output channel iCh sFileListName
41191>>>        Writeln channel iCh asFileListArray
41194>>>                
41194>>>        Close_Input channel iCh
41196>>>        Send Seq_Release_Channel iCh
41197>>>        Move (not(Err)) to bOK
41198>>>        Move bErr to Err
41199>>>        
41199>>>        Function_Return bOK
41200>>>    End_Function
41201>>>
41201>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
41201>>>    // It first deletes the .cch file (if any).
41201>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
41203>>>        Boolean bOK bFound bExists bErr
41203>>>        Integer iCh iSize iCount
41203>>>        String sFileName sCCHFileName sVal
41203>>>        String[] asIntFile
41204>>>        
41204>>>        Move Err to bErr   
41205>>>        Move False to Err
41206>>>        Move False to bOK
41207>>>
41207>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
41208>>>        Move (SizeOfArray(asIntFile)) to iSize
41209>>>        If (iSize = 0) Begin
41211>>>            Function_Return False        
41212>>>        End                      
41212>>>>
41212>>>        Decrement iSize
41213>>>        
41213>>>        Get Seq_New_Channel to iCh
41214>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
41216>>>            Function_Return False
41217>>>        End   
41217>>>>
41217>>>        
41217>>>        // Before we start to actually create the new .int file, make sure we delete
41217>>>        // the .cch file first.                                     
41217>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
41218>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
41219>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
41220>>>        If (bExists = True) Begin
41222>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
41223>>>            If (bOK = False) Begin
41225>>>                Function_Return False
41226>>>            End
41226>>>>
41226>>>        End
41226>>>>
41226>>>        
41226>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
41228>>>        For iCount from 0 to iSize
41234>>>>
41234>>>            Writeln channel iCh asIntFile[iCount]
41237>>>        Loop
41238>>>>
41238>>>        
41238>>>        Close_Input channel iCh
41240>>>        Send Seq_Release_Channel iCh
41241>>>        Move (not(Err)) to bOK
41242>>>        Move bErr to Err
41243>>>        
41243>>>        Function_Return bOK
41244>>>    End_Function   
41245>>>              
41245>>>    // Automatically writes .int files to disk that is missing.
41245>>>    // We only need to make this test this once, but because the message is called
41245>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
41245>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
41245>>>    Procedure AutoCreateIntFilesTable 
41247>>>        Integer hTable 
41247>>>        Boolean bIntFilesTablesCheckDone bTableExists
41247>>>        String sInfoTxt 
41247>>>        
41247>>>        Get phIntFilesTable to hTable  
41248>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
41249>>>        If (bIntFilesTablesCheckDone = True) Begin
41251>>>            Procedure_Return
41252>>>        End
41252>>>>
41252>>>
41252>>>        If (hTable < 1) Begin
41254>>>            Set Private.pbIntFilesTablesCheckDone to False
41255>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
41256>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
41257>>>>
41257>>>            Procedure_Return
41258>>>        End
41258>>>>
41258>>>
41258>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
41259>>>        If (bTableExists = True) Begin
41261>>>            Set Private.pbIntFilesTablesCheckDone to True
41262>>>            Procedure_Return
41263>>>        End
41263>>>>
41263>>>
41263>>>        Send CreateIntFilesTable hTable
41264>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
41265>>>        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
41266>>>    End_Function
41267>>>                
41267>>>    Procedure CreateIntFilesTable Handle hTable
41269>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
41269>>>        Boolean bTableExists bOK bUseConnectionID bExists
41269>>>        tAPIColumn[] APIColumn
41269>>>        tAPIColumn[] APIColumn
41270>>>
41270>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
41271>>>        If (bTableExists = True) Begin
41273>>>            Procedure_Return
41274>>>        End
41274>>>>
41274>>>
41274>>>        Move False to Err
41275>>>        Get psDriverID to sDriverID
41276>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
41277>>>
41277>>>        Move CS_IntFilesTableRootName to sTableName
41278>>>
41278>>>        Move 1                  to APIColumn[0].iFieldNumber
41279>>>        Move "ID"               to APIColumn[0].sFieldName
41280>>>        Move DF_BCD             to APIColumn[0].iType
41281>>>        Move False              to APIColumn[0].bIsSQLType
41282>>>        Move 12                 to APIColumn[0].iLength
41283>>>        Move 0                  to APIColumn[0].iPrecision
41284>>>
41284>>>        Move 2                  to APIColumn[1].iFieldNumber
41285>>>        Move "IntFileName"      to APIColumn[1].sFieldName
41286>>>        Move DF_ASCII           to APIColumn[1].iType
41287>>>        Move False              to APIColumn[1].bIsSQLType
41288>>>        Move 50                 to APIColumn[1].iLength
41289>>>        Move 0                  to APIColumn[1].iPrecision
41290>>>
41290>>>        Move 3                  to APIColumn[2].iFieldNumber
41291>>>        Move "IntLineText"      to APIColumn[2].sFieldName
41292>>>        Move DF_ASCII           to APIColumn[2].iType
41293>>>        Move False              to APIColumn[2].bIsSQLType
41294>>>        Move 100                to APIColumn[2].iLength
41295>>>        Move 0                  to APIColumn[2].iPrecision
41296>>>
41296>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
41297>>>        
41297>>>        If (bOK = True and Err = False) Begin
41299>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
41300>>>        End
41300>>>>
41300>>>        Else Begin
41301>>>            Set Private.pbIntFilesTablesCheckDone to False
41302>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
41303>>>            Error DFERR_PROGRAM sInfoTxt
41304>>>>
41304>>>            Procedure_Return
41305>>>        End
41305>>>>
41305>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
41306>>>        
41306>>>        Open hTable
41308>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
41309>>>        If (bOK = True) Begin
41311>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
41312>>>        End
41312>>>>
41312>>>        If (bOK = False) Begin
41314>>>            Set Private.pbIntFilesTablesCheckDone to False
41315>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
41316>>>            Error DFERR_PROGRAM sInfoTxt
41317>>>>
41317>>>            Procedure_Return
41318>>>        End                    
41318>>>>
41318>>>        
41318>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
41318>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
41319>>>        Get vFolderFormat sDataPath to sDataPath
41320>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
41321>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
41322>>>        If (bExists = True) Begin
41324>>>            Move CS_IntFilesTableRootName to sTableName
41325>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
41326>>>            If (bExists = True) Begin
41328>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
41329>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
41330>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
41331>>>            End
41331>>>>
41331>>>        End
41331>>>>
41331>>>        
41331>>>        Set Private.pbIntFilesTablesCheckDone to True
41332>>>    End_Procedure
41333>>>
41333>>>    Procedure CheckAutoCreateDbVersionTable
41335>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
41335>>>        Integer iDbVersionFileNumber
41335>>>
41335>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
41336>>>        If (bDbVersionCheckDone = True) Begin
41338>>>            Procedure_Return
41339>>>        End
41339>>>>
41339>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
41340>>>        If (bUseCustomDbVersion = True) Begin
41342>>>            Procedure_Return
41343>>>        End
41343>>>>
41343>>>
41343>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
41344>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
41346>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
41347>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
41348>>>>
41348>>>            Send Exit_Application
41349>>>        End
41349>>>>
41349>>>
41349>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
41350>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
41351>>>        If (bTableExists = True) Begin
41353>>>            Set Private.pbDbVersionCheckDone to True
41354>>>            Procedure_Return
41355>>>        End
41355>>>>
41355>>>
41355>>>        Send CreateDbVersionTable iDbVersionFileNumber
41356>>>
41356>>>        // We only need to these DbVersion checks once, but because this message is called
41356>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
41356>>>        // we use a property to only run these tests once.
41356>>>        Set Private.pbDbVersionCheckDone to True
41357>>>    End_Procedure
41358>>>
41358>>>    Procedure CreateDbVersionTable Handle hTable
41360>>>        String sTableName sColumnName sInfoTxt sDriverID 
41360>>>        Boolean bTableExists bOK bUseConnectionID
41360>>>        tAPIColumn[] APIColumn
41360>>>        tAPIColumn[] APIColumn
41361>>>
41361>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
41362>>>        If (bTableExists = True) Begin
41364>>>            Procedure_Return
41365>>>        End
41365>>>>
41365>>>
41365>>>        Get psDriverID to sDriverID
41366>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
41367>>>
41367>>>        Move "DbVersion"        to sTableName
41368>>>        Move 1                  to APIColumn[0].iFieldNumber
41369>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
41370>>>        Move DF_BCD             to APIColumn[0].iType
41371>>>        Move False              to APIColumn[0].bIsSQLType
41372>>>        Move 4                  to APIColumn[0].iLength
41373>>>        Move 2                  to APIColumn[0].iPrecision
41374>>>
41374>>>        Move False to Err                                
41375>>>        
41375>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
41375>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
41375>>>        Set psDriverID to DATAFLEX_ID
41376>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
41377>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
41378>>>        Set psDriverID to sDriverID
41379>>>        
41379>>>        If (bOK = True and Err = False) Begin
41381>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
41381>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
41382>>>        End
41382>>>>
41382>>>        Else Begin
41383>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
41384>>>        End
41384>>>>
41384>>>
41384>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
41385>>>    End_Procedure
41386>>>
41386>>>    Procedure Set pbVerboseState Boolean bVerboseState
41388>>>        Handle ho
41388>>>        Get phoLogFile to ho
41389>>>        Set pbVerboseState of ho to bVerboseState
41390>>>    End_Procedure
41391>>>
41391>>>    Function pbVerboseState Returns Boolean
41393>>>        Boolean bVerboseState
41393>>>        Handle ho
41393>>>        Get phoLogFile to ho
41394>>>        Get pbVerboseState of ho to bVerboseState
41395>>>        Function_Return bVerboseState
41396>>>    End_Function
41397>>>
41397>>>    // Callback functionality used when e.g. calling driver functions directly.
41397>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
41397>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
41399>>>        Integer iPerc
41399>>>        Number nReady nTotal nVersion
41399>>>        Boolean bVerboseState
41399>>>        Handle hoLogFile
41399>>>
41399>>>        Get pbVerboseState to bVerboseState
41400>>>        Get pnCurrentVersionUpdate to nVersion
41401>>>        Get phoLogFile     to hoLogFile
41402>>>        Send DoAdvance of ghoProgressBar
41403>>>
41403>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
41405>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
41406>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
41407>>>        End
41407>>>>
41407>>>        If (sCallback_Text contains "Creating index") Begin
41409>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
41410>>>        End
41410>>>>
41410>>>
41410>>>        Case Begin
41410>>>            Case (iCallback_Type = DF_Message_Text)
41412>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41413>>>                Set Action_Text  of ghoStatusPanel to ""
41414>>>                If (bVerboseState = True) Begin
41416>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41417>>>                End
41417>>>>
41417>>>                Case Break
41418>>>            Case (iCallback_Type = DF_Message_Heading_1)
41421>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41422>>>                If (bVerboseState = True) Begin
41424>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41425>>>                End
41425>>>>
41425>>>                Case Break
41426>>>            Case (iCallback_Type = DF_Message_Heading_2)
41429>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41430>>>                Set Action_Text  of ghoStatusPanel to ""
41431>>>                If (bVerboseState = True) Begin
41433>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41434>>>                End
41434>>>>
41434>>>                Case Break
41435>>>            Case (iCallback_Type = DF_Message_Heading_3)
41438>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41439>>>                Set Action_Text  of ghoStatusPanel to ""
41440>>>                If (bVerboseState = True) Begin
41442>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41443>>>                End
41443>>>>
41443>>>                Case Break
41444>>>            Case (iCallback_Type = DF_Message_Heading_4)
41447>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41448>>>                Set Action_Text  of ghoStatusPanel to ""
41449>>>                If (bVerboseState = True) Begin
41451>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41452>>>                End
41452>>>>
41452>>>                Case Break
41453>>>            Case (iCallback_Type = DF_Message_Heading_5)
41456>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41457>>>                Set Action_Text  of ghoStatusPanel to ""
41458>>>                If (bVerboseState = True) Begin
41460>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41461>>>                End
41461>>>>
41461>>>                Case Break
41462>>>            Case (iCallback_Type = DF_Message_Warning)
41465>>>                If (bVerboseState = True) Begin
41467>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41468>>>                End
41468>>>>
41468>>>                Case Break
41469>>>            Case (iCallback_Type = DF_Message_Progress_Title)
41472>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
41473>>>                Set Action_Text  of ghoStatusPanel to ""
41474>>>                If (bVerboseState = True) Begin
41476>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
41477>>>                End
41477>>>>
41477>>>                Case Break
41478>>>            Case (iCallback_Type = DF_Message_Progress_Value)
41481>>>                //*** Interpret numbers
41481>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
41482>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
41483>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
41484>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
41485>>>                Set piPosition of ghoProgressBar to iPerc
41486>>>                Case Break
41487>>>            Case Else
41487>>>                Set Message_Text to ""
41488>>>                Set Action_Text  to ""
41489>>>        Case End
41489>>>
41489>>>        Send ProcessEvents of ghoStatusPanel
41490>>>        Function_Return False
41491>>>    End_Function
41492>>>
41492>>>    // This was made to be a procedure/function pair so we
41492>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
41492>>>
41492>>>    Procedure Set piDbType Integer iDbType
41494>>>        If (ghoSQLConnectionHandler = 0) Begin
41496>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41497>>>>
41497>>>            Procedure_Return
41498>>>        End
41498>>>>
41498>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
41499>>>    End_Procedure
41500>>>
41500>>>    Function piDbType Returns Integer
41502>>>        Integer iDbType
41502>>>        If (ghoSQLConnectionHandler = 0) Begin
41504>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41505>>>>
41505>>>            Function_Return ""
41506>>>        End
41506>>>>
41506>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
41507>>>        Function_Return iDbType
41508>>>    End_Function
41509>>>
41509>>>    Procedure Set psDriverID String sDriverID
41511>>>        If (ghoSQLConnectionHandler = 0) Begin
41513>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41514>>>>
41514>>>            Procedure_Return
41515>>>        End
41515>>>>
41515>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
41516>>>    End_Procedure
41517>>>
41517>>>    Function psDriverID Returns String
41519>>>        String sValue
41519>>>        If (ghoSQLConnectionHandler = 0) Begin
41521>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41522>>>>
41522>>>            Function_Return ""
41523>>>        End
41523>>>>
41523>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
41524>>>        Function_Return sValue
41525>>>    End_Function
41526>>>
41526>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
41528>>>        If (ghoSQLConnectionHandler = 0) Begin
41530>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41531>>>>
41531>>>            Procedure_Return
41532>>>        End
41532>>>>
41532>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
41533>>>    End_Procedure
41534>>>
41534>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
41536>>>        Integer iRetval
41536>>>        If (ghoSQLConnectionHandler = 0) Begin
41538>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41539>>>>
41539>>>            Function_Return 2
41540>>>        End
41540>>>>
41540>>>
41540>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
41541>>>        Function_Return iRetval
41542>>>    End_Function
41543>>>
41543>>>    Procedure Set psConnectionID String sValue
41545>>>        If (ghoSQLConnectionHandler = 0) Begin
41547>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41548>>>>
41548>>>            Procedure_Return
41549>>>        End
41549>>>>
41549>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
41550>>>    End_Procedure
41551>>>
41551>>>    Function psConnectionID Returns String
41553>>>        String sValue
41553>>>        If (ghoSQLConnectionHandler = 0) Begin
41555>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41556>>>>
41556>>>            Function_Return ""
41557>>>        End
41557>>>>
41557>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
41558>>>
41558>>>        Function_Return sValue
41559>>>    End_Function
41560>>>
41560>>>    // These "properties" are settings of the cCLIHandler class, but are being
41560>>>    // relayed to the ghoSQLConnectionHandler object
41560>>>    // simply by changing one of its parameters.
41560>>>    Procedure Set psServer String sValue
41562>>>        If (ghoSQLConnectionHandler = 0) Begin
41564>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41565>>>>
41565>>>            Procedure_Return
41566>>>        End
41566>>>>
41566>>>        Set psServer of ghoSQLConnectionHandler to sValue
41567>>>    End_Procedure
41568>>>
41568>>>    Function psServer Returns String
41570>>>        String sValue
41570>>>        If (ghoSQLConnectionHandler = 0) Begin
41572>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41573>>>>
41573>>>            Function_Return ""
41574>>>        End
41574>>>>
41574>>>        Get psServer of ghoSQLConnectionHandler to sValue
41575>>>
41575>>>        Function_Return sValue
41576>>>    End_Function
41577>>>
41577>>>    Procedure Set psDatabase String sValue
41579>>>        If (ghoSQLConnectionHandler = 0) Begin
41581>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41582>>>>
41582>>>            Procedure_Return
41583>>>        End
41583>>>>
41583>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
41584>>>    End_Procedure
41585>>>
41585>>>    Function psDatabase Returns String
41587>>>        String sValue
41587>>>        If (ghoSQLConnectionHandler = 0) Begin
41589>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41590>>>>
41590>>>            Function_Return ""
41591>>>        End
41591>>>>
41591>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
41592>>>
41592>>>        Function_Return sValue
41593>>>    End_Function
41594>>>
41594>>>    Procedure Set psUserID String sValue
41596>>>        If (ghoSQLConnectionHandler = 0) Begin
41598>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41599>>>>
41599>>>            Procedure_Return
41600>>>        End
41600>>>>
41600>>>        Set psUserID of ghoSQLConnectionHandler to sValue
41601>>>    End_Procedure
41602>>>
41602>>>    Function psUserID Returns String
41604>>>        String sValue
41604>>>        If (ghoSQLConnectionHandler = 0) Begin
41606>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41607>>>>
41607>>>            Function_Return ""
41608>>>        End
41608>>>>
41608>>>        Get psUserID of ghoSQLConnectionHandler to sValue
41609>>>
41609>>>        Function_Return sValue
41610>>>    End_Function
41611>>>
41611>>>    Procedure Set psPassword String sValue
41613>>>        If (ghoSQLConnectionHandler = 0) Begin
41615>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41616>>>>
41616>>>            Procedure_Return
41617>>>        End
41617>>>>
41617>>>        Set psPassword of ghoSQLConnectionHandler to sValue
41618>>>    End_Procedure
41619>>>
41619>>>    Function psPassword Returns String
41621>>>        String sValue
41621>>>        If (ghoSQLConnectionHandler = 0) Begin
41623>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41624>>>>
41624>>>            Function_Return ""
41625>>>        End
41625>>>>
41625>>>        Get psPassword of ghoSQLConnectionHandler to sValue
41626>>>
41626>>>        Function_Return sValue
41627>>>    End_Function
41628>>>
41628>>>    Procedure Set pbTrusted Boolean bValue
41630>>>        If (ghoSQLConnectionHandler = 0) Begin
41632>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41633>>>>
41633>>>            Procedure_Return
41634>>>        End
41634>>>>
41634>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
41635>>>    End_Procedure
41636>>>
41636>>>    Function pbTrusted Returns Boolean
41638>>>        Boolean bValue
41638>>>        If (ghoSQLConnectionHandler = 0) Begin
41640>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41641>>>>
41641>>>            Function_Return False
41642>>>        End
41642>>>>
41642>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
41643>>>
41643>>>        Function_Return bValue
41644>>>    End_Function
41645>>>
41645>>>    Procedure Set psConnectionString String sValue
41647>>>        If (ghoSQLConnectionHandler = 0) Begin
41649>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41650>>>>
41650>>>            Procedure_Return
41651>>>        End
41651>>>>
41651>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
41652>>>    End_Procedure
41653>>>
41653>>>    Function psConnectionString Returns String
41655>>>        String sValue
41655>>>        If (ghoSQLConnectionHandler = 0) Begin
41657>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41658>>>>
41658>>>            Function_Return ""
41659>>>        End
41659>>>>
41659>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
41660>>>
41660>>>        Function_Return sValue
41661>>>    End_Function
41662>>>
41662>>>    Function piConnectionOptions Returns Integer
41664>>>        Integer iValue
41664>>>        If (ghoSQLConnectionHandler = 0) Begin
41666>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
41667>>>>
41667>>>            Function_Return 0
41668>>>        End
41668>>>>
41668>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
41669>>>
41669>>>        Function_Return iValue
41670>>>    End_Function
41671>>>
41671>>>
41671>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
41673>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
41674>>>    End_Procedure
41675>>>
41675>>>    Function pbCheckDataFlexUserCount Returns Boolean
41677>>>        Boolean bState
41677>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
41678>>>        Function_Return bState
41679>>>    End_Function
41680>>>
41680>>>    Procedure Set psLogTextFile String sValue
41682>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
41683>>>    End_Procedure
41684>>>
41684>>>    Function psLogTextFile Returns String
41686>>>        String sValue
41686>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
41687>>>        Function_Return sValue
41688>>>    End_Function
41689>>>
41689>>>    Procedure Set psEditorProgram String sValue
41691>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
41692>>>    End_Procedure
41693>>>
41693>>>    Function psEditorProgram Returns String
41695>>>        String sValue
41695>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
41696>>>        Function_Return sValue
41697>>>    End_Function
41698>>>
41698>>>    Procedure Set pbUseDataTableLog Boolean bState
41700>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
41701>>>    End_Procedure
41702>>>
41702>>>    Function pbUseDataTableLog Returns Boolean
41704>>>        Boolean bState
41704>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
41705>>>        Function_Return bState
41706>>>    End_Function
41707>>>
41707>>>    Procedure Set pbQuickWrite Boolean bState
41709>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
41710>>>    End_Procedure
41711>>>
41711>>>    Function pbQuickWrite Returns Boolean
41713>>>        Boolean bState
41713>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
41714>>>        Function_Return bState
41715>>>    End_Function
41716>>>
41716>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
41718>>>        Boolean bUpdateVersionObjectError bVerboseState
41718>>>        Integer iSize iCount
41718>>>        Number nVersion
41718>>>        String[] aSQLQueryMessages
41719>>>
41719>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
41720>>>        Set Private.pbDatabaseWasUpdated to bState
41721>>>        // If no errors occurred in the current cDbUpdateVersion object - write
41721>>>        // to the log that it was OK.
41721>>>        If (bUpdateVersionObjectError = False) Begin
41723>>>            Get pnCurrentVersionUpdate to nVersion
41724>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
41725>>>        End
41725>>>>
41725>>>
41725>>>        Get pbVerboseState to bVerboseState
41726>>>        If (bVerboseState = True) Begin
41728>>>            Get paSQLQueryMessages to aSQLQueryMessages
41729>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
41730>>>            Decrement iSize
41731>>>            For iCount from 0 to iSize
41737>>>>
41737>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
41738>>>            Loop
41739>>>>
41739>>>        End
41739>>>>
41739>>>
41739>>>    End_Procedure 
41740>>>    
41740>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
41742>>>        Set Private.piDbVersionFileNumber to iFileNumber
41743>>>    End_Procedure                                         
41744>>>    
41744>>>    Function piDbVersionFileNumber Returns Integer
41746>>>        Function_Return (Private.piDbVersionFileNumber(Self))
41747>>>    End_Function
41748>>>
41748>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
41750>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
41751>>>    End_Procedure                                         
41752>>>    
41752>>>    Function piDbVersionFieldNumber Returns Integer
41754>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
41755>>>    End_Function
41756>>>
41756>>>    Function pbDatabaseWasUpdated Returns Boolean
41758>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
41759>>>    End_Function
41760>>>    
41760>>>    //
41760>>>    Procedure ReinitializeFramework  
41762>>>        tDbVersionInfo[] aDbVersionInfoArray
41762>>>        tDbVersionInfo[] aDbVersionInfoArray
41763>>>        Handle hoDbVersionObject
41763>>>        Integer iSize iCount
41763>>>        
41763>>>        Set Private.pbDatabaseUpdateStarted to False
41764>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
41765>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
41766>>>        Decrement iSize
41767>>>        
41767>>>        For iCount from 0 to iSize
41773>>>>
41773>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
41774>>>            Send ProcessUpdate                  of hoDbVersionObject False
41775>>>        Loop
41776>>>>
41776>>>        Send Cleanup
41777>>>    End_Procedure
41778>>>    
41778>>>    // This event is triggered by the cDbUpdateVersion child class when
41778>>>    // a database change is to be started, and is considered private.
41778>>>    // It is only executed once for the first cDbUpateVersion object!
41778>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
41780>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
41780>>>        Integer iRetval iDataFlexUsers iUserCount
41780>>>        Handle hoUserCountSystem
41780>>>        tUserCount UserCount
41780>>>        tUserCount UserCount
41780>>>        DateTime dtUpdateStarted
41780>>>        tSQLConnection SQLConnection
41780>>>        tSQLConnection SQLConnection
41780>>>
41780>>>        // *Important:* If we already started the update; we do no further checking.
41780>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
41781>>>        If (bDatabaseUpdateStarted = True) Begin
41783>>>            Procedure_Return
41784>>>        End
41784>>>>
41784>>>
41784>>>        // If not silent mode; Ask user if OK to start database update.
41784>>>        If (pbSilentMode(Self) = False) Begin
41786>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
41787>>>            If (iRetval <> MBR_Yes) Begin
41789>>>                Send Exit_Application
41790>>>            End
41790>>>>
41790>>>        End
41790>>>>
41790>>>        
41790>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
41791>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
41792>>>        Send Start_StatusPanel      of ghoStatusPanel
41793>>>
41793>>>        // This will save the status of all open tables including Master/Alias settings,
41793>>>        // so we can restore them later;
41793>>>        Send SaveOpenTables
41794>>>
41794>>>        Move 0 to iDataFlexUsers
41795>>>        // Make various tests to check that the database is not in use.
41795>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
41796>>>        // We also use our own user counting mechanism to guard against the
41796>>>        // database isn't opened already as we need exclusive access to the tables.:
41796>>>        Get phoUserCountSystem to hoUserCountSystem
41797>>>        Get CheckUserCount of hoUserCountSystem to UserCount
41798>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
41799>>>
41799>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
41800>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
41800>>>        If (bCheckDataFlexUserCount = True) Begin
41802>>>            Get_Current_User_Count to iDataFlexUsers
41803>>>            // For some reason DataFlex - in some cases - might think that 2 users
41803>>>            // are in use while debugging from the Studio.
41803>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
41805>>>                Decrement iDataFlexUsers
41806>>>            End
41806>>>>
41806>>>        End 
41806>>>>
41806>>>        Else Begin
41807>>>            Move 1 to iDataFlexUsers 
41808>>>            Move 1 to iUserCount
41809>>>            Move False to bInUse
41810>>>        End
41810>>>>
41810>>>
41810>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
41812>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
41813>>>            If (iRetval <> MBR_Yes) Begin
41815>>>                Send Exit_Application
41816>>>            End
41816>>>>
41816>>>        End
41816>>>>
41816>>>
41816>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
41818>>>            Send Stop_Box CS_DUF_DatabaseInUseText
41819>>>            Send Exit_Application
41820>>>        End
41820>>>>
41820>>>
41820>>>        // This will put a look on the DbUpdateLock.ucf file.
41820>>>        // It is released when the update process is finished
41820>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
41821>>>
41821>>>        Move (CurrentDateTime()) to dtUpdateStarted
41822>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
41823>>>        Set Private.pbDatabaseUpdateStarted to True
41824>>>
41824>>>        // We need to close all tables before starting to make changes.
41824>>>        Close DF_ALL DF_PERMANENT
41825>>>
41825>>>        // If these properties has not exclicitly been set in the object, set them
41825>>>        // to settings from the SQLConnections.ini file;
41825>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
41826>>>        If (psSchema(Self) = "") Begin
41828>>>            Set psSchema            to SQLConnection.sSchema
41829>>>        End
41829>>>>
41829>>>        If (psBaseTableSpace(Self) = "") Begin
41831>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
41832>>>        End
41832>>>>
41832>>>        If (psLongTableSpace(Self) = "") Begin
41834>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
41835>>>        End
41835>>>>
41835>>>        If (psIndexTableSpace(Self) = "") Begin
41837>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
41838>>>        End
41838>>>>
41838>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
41840>>>            Procedure_Return
41841>>>        End
41841>>>>
41841>>>
41841>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
41842>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
41844>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
41845>>>            Send Stop_StatusPanel of ghoStatusPanel
41846>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
41846>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
41847>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
41847>>>            Send Exit_Application
41848>>>        End
41848>>>>
41848>>>    End_Procedure
41849>>>
41849>>>    // *** Hook message for pre-processing ***
41849>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
41849>>>    // Aka, when another table than the standard "DbVersion" is used.
41849>>>    Procedure OnCreateCustomDbVersionTable
41851>>>    End_Procedure
41852>>>    
41852>>>    // *** Hook message for pre-processing ***
41852>>>    // The programmer can use this event for putting code that
41852>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
41852>>>    // child objects are executed.
41852>>>    Procedure OnPreUpdate
41854>>>    End_Procedure
41855>>>
41855>>>    // *** Hook message for post-processing ***
41855>>>    // The programmer should use this event for putting code that
41855>>>    // needs to be executed _after_ all database updates have finished.
41855>>>    Procedure OnPostUpdate
41857>>>    End_Procedure
41858>>>
41858>>>    // *** Hook message for custom DbVersion record find ***
41858>>>    // The programmer can use this event for putting code that
41858>>>    // needs to be executed to find a *custom* DbVersion table record.
41858>>>    // By default the DbVersion table is used but this can be
41858>>>    // customized by adding this line to the code;
41858>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
41858>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
41858>>>    //       to save the current database version to. Only if you use your own
41858>>>    //       table _and_ it is not a system table (contains only one record).
41858>>>    Procedure OnFindVersionRecord
41860>>>        // Open MyTable
41860>>>        // Move xx to MyTable.Field1
41860>>>        // Move yy to MyTable.Field2
41860>>>        // Find le MyTable by Index.x
41860>>>    End_Procedure
41861>>>
41861>>>    // Hook event for writing header error text (pre-update) to
41861>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
41861>>>    // Don't forget to Open the table first (!) as all
41861>>>    // tables have been closed at this stage.
41861>>>    // The start date & time is passed.
41861>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
41863>>>    End_Procedure
41864>>>
41864>>>    // Hook event to log errors to a database table.
41864>>>    // Only called if the pbUseDataTableLog = True.
41864>>>    // Don't forget to Open the table first (!) as all
41864>>>    // tables have been closed at this stage.
41864>>>    // If pbQuickWrite = True the DbUpdateErrorArray
41864>>>    // will contain just one row, as it is called for each error
41864>>>    // that occurred. Else it is called once at the end after all updates
41864>>>    // have run and contains all errors.
41864>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
41866>>>    End_Procedure
41867>>>
41867>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
41867>>>    Procedure Cleanup
41869>>>        Boolean bDatabaseWasUpdated bError
41869>>>
41869>>>        Send CheckAutoCreateDbVersionTable
41870>>>        Send RestoreOpenTables
41871>>>
41871>>>        // The function library have two purposes; one is to use it in the
41871>>>        // Database Update Framework, but it can also be used on its own.
41871>>>        // If that is the case it has its own error handling system, which
41871>>>        // we temporarily disbled when running updates because we have
41871>>>        // error handling/logging here too... We now restore its setting.
41871>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
41873>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
41874>>>        End
41874>>>>
41874>>>        Set pbHandleQueryErrors to True
41875>>>
41875>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
41876>>>        Get pbDbUpdateErrorHasOccured to bError
41877>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
41879>>>
41879>>>            // We should always create the log as it also contains info about
41879>>>            // the update being successful.
41879>>>            Send WriteErrorLog of (phoLogFile(Self))
41880>>>
41880>>>            // This is a programmer's hook message:
41880>>>            Send OnPostUpdate
41881>>>
41881>>>            Send Stop_StatusPanel of ghoStatusPanel
41882>>>
41882>>>            If (pbSilentMode(Self) = False) Begin
41884>>>                If (bError = True) Begin
41886>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
41888>>>                        Send ShowErrorLog of (phoLogFile(Self))
41889>>>                    End
41889>>>>
41889>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
41890>>>                    Send Exit_Application
41891>>>                End
41891>>>>
41891>>>                Else Begin
41892>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
41894>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
41895>>>                    End
41895>>>>
41895>>>                    Else Begin
41896>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
41897>>>                    End
41897>>>>
41897>>>
41897>>>                End
41897>>>>
41897>>>            End
41897>>>>
41897>>>        End
41897>>>>
41897>>>
41897>>>        // Restore the standard error handler:
41897>>>        Get piOrgErrorHandlerID to Error_Object_Id
41898>>>    End_Procedure
41899>>>
41899>>>    // We do this _before_ we close the database to make changes, and save
41899>>>    // all 'Master' & 'Alias' tables settings so we can restore when
41899>>>    // we reopen the database.
41899>>>    Procedure SaveOpenTables
41901>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
41901>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
41902>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
41903>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
41904>>>    End_Procedure
41905>>>
41905>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
41905>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
41905>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
41907>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
41907>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
41908>>>        Integer hTable iMasterAliasType iSize
41908>>>        Boolean bOpen
41908>>>
41908>>>        Move 0 to hTable
41909>>>        Repeat
41909>>>>
41909>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
41912>>>            If (hTable <> 0) Begin
41914>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
41917>>>                If (bOpen = True) Begin
41919>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
41922>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
41923>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
41924>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
41925>>>                End
41925>>>>
41925>>>            End
41925>>>>
41925>>>        Until (hTable = 0)
41927>>>
41927>>>        Function_Return aDbUpdateHandlerMasterAlias
41928>>>    End_Function
41929>>>
41929>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
41929>>>    // Takes one parameter:
41929>>>    //   A struct array with all master & alias
41929>>>    Procedure RestoreOpenTables
41931>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
41931>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
41932>>>        Integer hTable iFileAlias iSize iCount
41932>>>        Boolean bOpen
41932>>>        String sRootName
41932>>>
41932>>>        Move 0 to hTable
41933>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
41934>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
41935>>>        Decrement iSize
41936>>>        For iCount from 0 to iSize
41942>>>>
41942>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
41943>>>            // We also need to check that the table hasn't been removed...
41943>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
41946>>>            If (hTable <> 0 and sRootName <> "") Begin
41948>>>                Open hTable
41950>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
41953>>>                If (bOpen = True) Begin
41955>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
41956>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
41958>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
41961>>>                    End
41961>>>>
41961>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
41964>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
41967>>>                    End
41967>>>>
41967>>>                End
41967>>>>
41967>>>            End
41967>>>>
41967>>>        Loop
41968>>>>
41968>>>    End_Procedure
41969>>>
41969>>>    // This checks for both duplicate pnVersionNumbers _and_ that
41969>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
41969>>>    Procedure CheckForDuplicates Number nVersion
41971>>>        tDbVersionInfo[] DbVersionInfoArray
41971>>>        tDbVersionInfo[] DbVersionInfoArray
41972>>>        Integer iCount iSize iHits iDuplicateIndex
41972>>>        Number nCompare
41972>>>        Handle hObject1 hObject2
41972>>>        String sObjectName1 sObjectName2
41972>>>        Boolean bObjectOrderError
41972>>>
41972>>>        Get paDbVersionInfoArray to DbVersionInfoArray
41973>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
41974>>>        Decrement iSize
41975>>>        Move 0 to iHits
41976>>>        Move 0 to nCompare
41977>>>        Move False to bObjectOrderError
41978>>>        For iCount from 0 to iSize
41984>>>>
41984>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
41986>>>                Increment iHits
41987>>>                If (iHits > 1) Begin
41989>>>                    Move iCount to iDuplicateIndex
41990>>>                    If (nCompare <> 0) Begin
41992>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
41993>>>                    End
41993>>>>
41993>>>                End
41993>>>>
41993>>>            End
41993>>>>
41993>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
41994>>>        Loop
41995>>>>
41995>>>        If (iHits > 1) Begin
41997>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
41998>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
41999>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
42000>>>            Move (Name(hObject1)) to sObjectName1
42001>>>            Move (Name(hObject2)) to sObjectName2
42002>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
42003>>>>
42003>>>            Send Exit_Application
42004>>>        End
42004>>>>
42004>>>        Else If (bObjectOrderError = True) Begin
42007>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
42008>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
42009>>>>
42009>>>            Send Exit_Application
42010>>>        End
42010>>>>
42010>>>    End_Procedure
42011>>>
42011>>>    // We take care of all errors in the Error_Report below and
42011>>>    // collect them all to an array property. So just ignore any
42011>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
42011>>>    // in some other package.
42011>>>    Procedure Ignore_Error Integer iError
42013>>>    End_Procedure
42014>>>
42014>>>    Procedure Trap_Error Integer iError
42016>>>    End_Procedure
42017>>>
42017>>>    // Build complete error description from Flexerrs and user error message.
42017>>>    Function Error_Description Integer Error# String ErrMsg Returns String
42019>>>        String Full_Error_Text
42019>>>        
42019>>>        Move (Trim(ErrMsg)) to ErrMsg
42020>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
42021>>>        
42021>>>        If (ErrMsg <> "") Begin
42023>>>            
42023>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
42025>>>                // Make sure last character of error text is a separating symbol.
42025>>>                // if not, add a "." So we have format of "error-text. error-detail"
42025>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
42028>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
42029>>>            End
42029>>>>
42029>>>            Else ;                Move ErrMsg to Full_Error_Text
42031>>>            
42031>>>        End
42031>>>>
42031>>>        
42031>>>        Function_Return Full_Error_Text
42032>>>    End_Function
42033>>>
42033>>>    // While we update the database we collect all errors in
42033>>>    // the struct array paDbUpdateErrorArray.
42033>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
42035>>>        Number nVersion
42035>>>        Handle hoLogFile 
42035>>>//        String sErrExtraText
42035>>>        
42035>>>        If (Private.pbProcessingError(Self)) Begin
42037>>>            Procedure_Return
42038>>>        End
42038>>>>
42038>>>
42038>>>        // The UtilTableNameFromHandleToString function does a:
42038>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
42038>>>        // and it generates an error if the table is of the embedded type.
42038>>>        // As we don't want to trigger an error in that very specific case,
42038>>>        // we just ignore it here.
42038>>>        //
42038>>>        // If no report mode, just set the err indicator to true.
42038>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
42040>>>            Move False to Err
42041>>>            Procedure_Return
42042>>>        End
42042>>>>
42042>>>
42042>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
42044>>>            Procedure_Return
42045>>>        End
42045>>>>
42045>>>
42045>>>        Set Private.pbProcessingError to True
42046>>>        Set Private.pbUpdateVersionObjectError to True
42047>>>
42047>>>        Set pbDbUpdateErrorHasOccured to True
42048>>>        Get pnCurrentVersionUpdate to nVersion
42049>>>        Get phoLogFile to hoLogFile
42050>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
42051>>>
42051>>>        Set Private.pbProcessingError to False
42052>>>    End_Procedure
42053>>>
42053>>>End_Class
42054>
42054>Object oApplication is a cApplication
42056>    Set psCompany to 'RDC Tools International'
42057>    Set psProduct to 'DUF Auto Update Program'
42058>    Set psProgram to 'Internal use/test of a DUF Update Package'
42059>    Set psVersion to '2023'
42060>    Property String psCompileDateAndTime
42062>End_Object
42063>
42063>Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: 1 now?") to WindowIndex
42064>If (WindowIndex <> MBR_Yes) Begin
42066>    Send Exit_Application
42067>End
42067>
42067>Object oDbUpdateHandler is a cDbUpdateHandler
42069>    Set piDbVersionFileNumber  to 1
42070>    Set piDbVersionFieldNumber to 1
42071>    Set pbAutoCreateDbVersionTable to True  
42072>    Set pbCheckIntFiles to True
42073>
42073>//    Use DUF_MultipleTables1_0.pkg
42073>
42073>End_Object
42074>
42074>If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin
42076>   Send Info_Box 'Nothing to update. (Version number has not changed)'
42077>End
42077>
42077>Send Exit_Application
42078>// *** End-Of-Program Code ***
42078>
Including Resources...
Summary
Memory Available: 103174160384
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 25052
Total Resources: 5
Total Commands : 42077
Total Windows  : 0
Total Pages    : 0
Static Data    : 481981
Message area   : 200402
Total Blocks   : 17192
